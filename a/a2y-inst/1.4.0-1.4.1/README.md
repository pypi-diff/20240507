# Comparing `tmp/a2y_inst-1.4.0-py3-none-any.whl.zip` & `tmp/a2y_inst-1.4.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,32 @@
-Zip file size: 68511 bytes, number of entries: 30
--rw-rw-rw-  2.0 fat        0 b- defN 23-Aug-23 07:29 a2y_inst/__init__.py
--rw-rw-rw-  2.0 fat     1574 b- defN 24-Jan-23 17:57 a2y_inst/ac_power_source.py
--rw-rw-rw-  2.0 fat     1156 b- defN 23-Aug-23 07:29 a2y_inst/bg7tbl.py
--rw-rw-rw-  2.0 fat     2428 b- defN 24-Apr-14 03:04 a2y_inst/curing.py
--rw-rw-rw-  2.0 fat     6219 b- defN 24-Apr-14 03:04 a2y_inst/dispenser.py
--rw-rw-rw-  2.0 fat     2023 b- defN 23-Nov-13 13:00 a2y_inst/dt1309.py
--rw-rw-rw-  2.0 fat     3303 b- defN 24-May-06 15:06 a2y_inst/gwinstek.py
--rw-rw-rw-  2.0 fat     6080 b- defN 23-Aug-23 07:29 a2y_inst/itech.py
--rw-rw-rw-  2.0 fat     2897 b- defN 23-Aug-23 07:29 a2y_inst/jabil.py
--rw-rw-rw-  2.0 fat     1138 b- defN 23-Aug-23 07:29 a2y_inst/keyence.py
--rw-rw-rw-  2.0 fat     1225 b- defN 24-Jan-23 17:57 a2y_inst/kld.py
--rw-rw-rw-  2.0 fat     2494 b- defN 23-Aug-23 07:29 a2y_inst/lb1905.py
--rw-rw-rw-  2.0 fat     2898 b- defN 23-Nov-24 00:58 a2y_inst/mastech.py
--rw-rw-rw-  2.0 fat     2568 b- defN 23-Aug-23 07:29 a2y_inst/mind_vision.py
--rw-rw-rw-  2.0 fat     1726 b- defN 23-Aug-23 07:29 a2y_inst/mini_circuits.py
--rw-rw-rw-  2.0 fat   100593 b- defN 23-Aug-23 07:29 a2y_inst/mitsubishi.py
--rw-rw-rw-  2.0 fat    89768 b- defN 23-Aug-23 07:29 a2y_inst/mvsdk.py
--rw-rw-rw-  2.0 fat     6884 b- defN 24-Jan-23 17:57 a2y_inst/ni845x.py
--rw-rw-rw-  2.0 fat     1371 b- defN 23-Aug-23 07:29 a2y_inst/shengpu.py
--rw-rw-rw-  2.0 fat     3084 b- defN 23-Nov-24 00:58 a2y_inst/tes.py
--rw-rw-rw-  2.0 fat     4416 b- defN 23-Sep-06 02:34 a2y_inst/uhserial.py
--rw-rw-rw-  2.0 fat     5774 b- defN 23-Aug-23 07:29 a2y_inst/victor.py
--rw-rw-rw-  2.0 fat     3744 b- defN 23-Aug-23 07:29 a2y_inst/wordop.py
--rw-rw-rw-  2.0 fat     5737 b- defN 24-Jan-23 17:57 a2y_inst/xinje.py
--rw-rw-rw-  2.0 fat     4736 b- defN 23-Aug-23 07:29 a2y_inst/yhd.py
--rw-rw-rw-  2.0 fat      704 b- defN 24-May-06 15:06 a2y_inst-1.4.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      998 b- defN 24-May-06 15:06 a2y_inst-1.4.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-May-06 15:06 a2y_inst-1.4.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        9 b- defN 24-May-06 15:06 a2y_inst-1.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2287 b- defN 24-May-06 15:06 a2y_inst-1.4.0.dist-info/RECORD
-30 files, 267926 bytes uncompressed, 64933 bytes compressed:  75.8%
+Zip file size: 68731 bytes, number of entries: 30
+-rw-rw-rw-  2.0 fat        0 b- defN 21-Jun-15 02:05 a2y_inst/__init__.py
+-rw-rw-rw-  2.0 fat     1574 b- defN 23-Nov-30 22:29 a2y_inst/ac_power_source.py
+-rw-rw-rw-  2.0 fat     1212 b- defN 23-Jun-23 04:25 a2y_inst/bg7tbl.py
+-rw-rw-rw-  2.0 fat     2489 b- defN 24-Apr-14 14:02 a2y_inst/curing.py
+-rw-rw-rw-  2.0 fat     6418 b- defN 24-Apr-14 14:02 a2y_inst/dispenser.py
+-rw-rw-rw-  2.0 fat     2102 b- defN 23-Nov-07 17:59 a2y_inst/dt1309.py
+-rw-rw-rw-  2.0 fat     3311 b- defN 24-May-07 15:38 a2y_inst/gwinstek.py
+-rw-rw-rw-  2.0 fat     6265 b- defN 21-Oct-10 02:43 a2y_inst/itech.py
+-rw-rw-rw-  2.0 fat     2989 b- defN 22-Apr-30 08:17 a2y_inst/jabil.py
+-rw-rw-rw-  2.0 fat     1138 b- defN 21-Jun-15 02:05 a2y_inst/keyence.py
+-rw-rw-rw-  2.0 fat     1275 b- defN 23-Nov-30 22:25 a2y_inst/kld.py
+-rw-rw-rw-  2.0 fat     2494 b- defN 22-Oct-26 07:48 a2y_inst/lb1905.py
+-rw-rw-rw-  2.0 fat     3016 b- defN 23-Nov-22 11:36 a2y_inst/mastech.py
+-rw-rw-rw-  2.0 fat     2568 b- defN 21-Jun-15 02:05 a2y_inst/mind_vision.py
+-rw-rw-rw-  2.0 fat     1781 b- defN 21-Jun-15 02:05 a2y_inst/mini_circuits.py
+-rw-rw-rw-  2.0 fat   100593 b- defN 23-Jul-28 09:23 a2y_inst/mitsubishi.py
+-rw-rw-rw-  2.0 fat    89768 b- defN 21-Jun-15 02:05 a2y_inst/mvsdk.py
+-rw-rw-rw-  2.0 fat     7107 b- defN 23-Nov-30 22:36 a2y_inst/ni845x.py
+-rw-rw-rw-  2.0 fat     1430 b- defN 21-Sep-03 02:14 a2y_inst/shengpu.py
+-rw-rw-rw-  2.0 fat     3237 b- defN 23-Nov-22 01:26 a2y_inst/tes.py
+-rw-rw-rw-  2.0 fat     4416 b- defN 23-Sep-16 07:54 a2y_inst/uhserial.py
+-rw-rw-rw-  2.0 fat     5953 b- defN 22-Jan-07 02:35 a2y_inst/victor.py
+-rw-rw-rw-  2.0 fat     3744 b- defN 21-Jun-15 02:05 a2y_inst/wordop.py
+-rw-rw-rw-  2.0 fat     5925 b- defN 23-Nov-30 22:45 a2y_inst/xinje.py
+-rw-rw-rw-  2.0 fat     4736 b- defN 21-Nov-07 01:07 a2y_inst/yhd.py
+-rw-rw-rw-  2.0 fat      718 b- defN 24-May-07 16:06 a2y_inst-1.4.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1111 b- defN 24-May-07 16:06 a2y_inst-1.4.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-07 16:06 a2y_inst-1.4.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        9 b- defN 24-May-07 16:06 a2y_inst-1.4.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2288 b- defN 24-May-07 16:06 a2y_inst-1.4.1.dist-info/RECORD
+30 files, 269759 bytes uncompressed, 65153 bytes compressed:  75.8%
```

## zipnote {}

```diff
@@ -69,23 +69,23 @@
 
 Filename: a2y_inst/xinje.py
 Comment: 
 
 Filename: a2y_inst/yhd.py
 Comment: 
 
-Filename: a2y_inst-1.4.0.dist-info/LICENSE
+Filename: a2y_inst-1.4.1.dist-info/LICENSE
 Comment: 
 
-Filename: a2y_inst-1.4.0.dist-info/METADATA
+Filename: a2y_inst-1.4.1.dist-info/METADATA
 Comment: 
 
-Filename: a2y_inst-1.4.0.dist-info/WHEEL
+Filename: a2y_inst-1.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: a2y_inst-1.4.0.dist-info/top_level.txt
+Filename: a2y_inst-1.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: a2y_inst-1.4.0.dist-info/RECORD
+Filename: a2y_inst-1.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## a2y_inst/bg7tbl.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-from serial import Serial as _Serial
-
-
-class FrequencyCounter(_Serial):
-	def __init__(self, port: str, baudrate: int = 9600):
-		_Serial.__init__(self, port, baudrate=baudrate)
-
-	def measure(self, fresh: bool = False) -> float:
-		in_waiting = self.in_waiting
-		if in_waiting > 0:
-			self.read(in_waiting)
-		data = self.readline().strip()
-		if fresh or (b'FA' not in data and b'FB' not in data):
-			data = self.readline().strip()
-
-		index = data.find(b'F')
-		assert index >= 0, f'Data invalid: [{data}]'
-
-		value = float(data[index+2:])
-		return value
-
-	def select_ch1_frequency(self):
-		cmd = b'$E2121*\r\n'
-		self.write(cmd)
-
-	def ch1_imp_50(self):
-		cmd = b'$E3030*\r\n'
-		self.write(cmd)
-
-	def ch1_imp_1M(self):
-		cmd = b'$E3131*\r\n'
-		self.write(cmd)
-
-	def beep_on(self):
-		cmd = b'$E3232*\r\n'
-		self.write(cmd)
-
-	def beep_off(self):
-		cmd = b'$E3333*\r\n'
-		self.write(cmd)
-
-	def high_precision_on(self):
-		cmd = b'$E3434*\r\n'
-		self.write(cmd)
-
-	def high_precision_off(self):
-		cmd = b'$E3535*\r\n'
-		self.write(cmd)
-
-	def ch1_lpf_on(self):
-		cmd = b'$E3636*\r\n'
-		self.write(cmd)
-
-	def ch1_lpf_off(self):
-		cmd = b'$E3737*\r\n'
-		self.write(cmd)
+from serial import Serial as _Serial
+
+
+class FrequencyCounter(_Serial):
+	def __init__(self, port: str, baudrate: int = 9600):
+		_Serial.__init__(self, port, baudrate=baudrate)
+
+	def measure(self, fresh: bool = False) -> float:
+		in_waiting = self.in_waiting
+		if in_waiting > 0:
+			self.read(in_waiting)
+		data = self.readline().strip()
+		if fresh or (b'FA' not in data and b'FB' not in data):
+			data = self.readline().strip()
+
+		index = data.find(b'F')
+		assert index >= 0, f'Data invalid: [{data}]'
+
+		value = float(data[index+2:])
+		return value
+
+	def select_ch1_frequency(self):
+		cmd = b'$E2121*\r\n'
+		self.write(cmd)
+
+	def ch1_imp_50(self):
+		cmd = b'$E3030*\r\n'
+		self.write(cmd)
+
+	def ch1_imp_1M(self):
+		cmd = b'$E3131*\r\n'
+		self.write(cmd)
+
+	def beep_on(self):
+		cmd = b'$E3232*\r\n'
+		self.write(cmd)
+
+	def beep_off(self):
+		cmd = b'$E3333*\r\n'
+		self.write(cmd)
+
+	def high_precision_on(self):
+		cmd = b'$E3434*\r\n'
+		self.write(cmd)
+
+	def high_precision_off(self):
+		cmd = b'$E3535*\r\n'
+		self.write(cmd)
+
+	def ch1_lpf_on(self):
+		cmd = b'$E3636*\r\n'
+		self.write(cmd)
+
+	def ch1_lpf_off(self):
+		cmd = b'$E3737*\r\n'
+		self.write(cmd)
```

## a2y_inst/curing.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-from a2y_modbus import FixMaster
-from threading import Lock
-from typing import List
-
-
-class CuringRTU:
-	"""固化机（最初来自众人行-华工科技项目，品牌未知）简单包装。使用 RS232 波特率 9600 通信，Modbus RTU 协议。"""
-
-	ResourceLock = Lock()
-
-	def __init__(self, port: str, baudrate: int = 9600, timeout: float = 0.5, station: int = 1):
-		CuringRTU.ResourceLock.acquire()
-		try:
-			self.modbus = FixMaster(station, port, baudrate, timeout)
-		except Exception as e:
-			CuringRTU.ResourceLock.release()
-			raise e
-
-	def read_system_registers(self, address: int, count: int) -> List[int]:
-		assert 0 <= address < 0xA and count > 0 and address + count <= 0xA, 'Address or count out of range'
-		return self.modbus.read_registers(address, count)
-
-	def read_channel_registers(self, address: int, count: int, channel: int = 1) -> List[int]:
-		assert 0 <= address < 0x2B and count > 0 and address + count <= 0x2B, 'Address or count out of range'
-		assert 0 < channel <= 8, 'Channel out of range (0, 8]'
-		addr = address | (channel << 8)
-		return self.modbus.read_registers(addr, count)
-
-	def write_channel_registers(self, address: int, values: List[int], channel: int = 1):
-		count = len(values)
-		assert 0 <= address < 0x2B and count > 0 and address + count <= 0x2B, 'Address or count out of range'
-		assert 0 < channel <= 8, 'Channel out of range (0, 8]'
-		addr = address | (channel << 8)
-		self.modbus.write_registers(addr, values)
-
-	def read_error_states(self) -> tuple:
-		error_code = self.read_system_registers(9, 1)[0]
-		alarm_state = self.read_channel_registers(5, 1)
-		return error_code, alarm_state
-
-	def close(self):
-		self.modbus.close()
-		CuringRTU.ResourceLock.release()
-
-	def __enter__(self):
-		return self
-
-	def __exit__(self, exc_type, exc_val, exc_tb):
-		self.close()
-
-	def get_all_plc_needs(self) -> List[int]:
-		values = self.read_system_registers(9, 1)  # [error_code]
-		channel_values = self.read_channel_registers(0x5, 14)
-		values.extend([channel_values[0], channel_values[4], channel_values[13]])  # 报警状态，自动强度，自动点亮时间
-		return values
-
-	def set_all_plc_wants(self, values: List[int]):
-		assert len(values) == 2, f'必须是“自动模式下的强度(0x9)”、“自动模式下的点亮时间(0x12)”这两个参数'
-		strength, duration = values
-		self.write_channel_registers(0x9, [strength])
-		self.write_channel_registers(0x12, [duration])
+from a2y_modbus import FixMaster
+from threading import Lock
+from typing import List
+
+
+class CuringRTU:
+	"""固化机（最初来自众人行-华工科技项目，品牌未知）简单包装。使用 RS232 波特率 9600 通信，Modbus RTU 协议。"""
+
+	ResourceLock = Lock()
+
+	def __init__(self, port: str, baudrate: int = 9600, timeout: float = 0.5, station: int = 1):
+		CuringRTU.ResourceLock.acquire()
+		try:
+			self.modbus = FixMaster(station, port, baudrate, timeout)
+		except Exception as e:
+			CuringRTU.ResourceLock.release()
+			raise e
+
+	def read_system_registers(self, address: int, count: int) -> List[int]:
+		assert 0 <= address < 0xA and count > 0 and address + count <= 0xA, 'Address or count out of range'
+		return self.modbus.read_registers(address, count)
+
+	def read_channel_registers(self, address: int, count: int, channel: int = 1) -> List[int]:
+		assert 0 <= address < 0x2B and count > 0 and address + count <= 0x2B, 'Address or count out of range'
+		assert 0 < channel <= 8, 'Channel out of range (0, 8]'
+		addr = address | (channel << 8)
+		return self.modbus.read_registers(addr, count)
+
+	def write_channel_registers(self, address: int, values: List[int], channel: int = 1):
+		count = len(values)
+		assert 0 <= address < 0x2B and count > 0 and address + count <= 0x2B, 'Address or count out of range'
+		assert 0 < channel <= 8, 'Channel out of range (0, 8]'
+		addr = address | (channel << 8)
+		self.modbus.write_registers(addr, values)
+
+	def read_error_states(self) -> tuple:
+		error_code = self.read_system_registers(9, 1)[0]
+		alarm_state = self.read_channel_registers(5, 1)
+		return error_code, alarm_state
+
+	def close(self):
+		self.modbus.close()
+		CuringRTU.ResourceLock.release()
+
+	def __enter__(self):
+		return self
+
+	def __exit__(self, exc_type, exc_val, exc_tb):
+		self.close()
+
+	def get_all_plc_needs(self) -> List[int]:
+		values = self.read_system_registers(9, 1)  # [error_code]
+		channel_values = self.read_channel_registers(0x5, 14)
+		values.extend([channel_values[0], channel_values[4], channel_values[13]])  # 报警状态，自动强度，自动点亮时间
+		return values
+
+	def set_all_plc_wants(self, values: List[int]):
+		assert len(values) == 2, f'必须是“自动模式下的强度(0x9)”、“自动模式下的点亮时间(0x12)”这两个参数'
+		strength, duration = values
+		self.write_channel_registers(0x9, [strength])
+		self.write_channel_registers(0x12, [duration])
```

## a2y_inst/dispenser.py

 * *Ordering differences only*

```diff
@@ -1,199 +1,199 @@
-from serial import Serial
-from threading import Lock
-from typing import List
-
-
-class DispenserGK:
-	"""点胶机（最初来自众人行-华工科技项目，品牌未知）简单包装，采用 RS232 通信，自定义（ASCII）协议通信，供应商文档称之为“GK通信协议”。"""
-
-	ParamLen = {
-		0x10: [1],
-		0x11: [1],
-		0x12: [4],
-		0x13: [1],
-		0x19: [2],  # 文档中说用于一次读取9个参数，实际只回来2个字节的数据，不知道对应啥参数
-		0x40: [4],
-		0x54: [4]
-	}
-	ResourceLock = Lock()
-
-	def __init__(self, port: str, baudrate: int = 9600, timeout: float = 0.5):
-		DispenserGK.ResourceLock.acquire()
-		try:
-			self.__serial = Serial(port=port, baudrate=baudrate, timeout=timeout)
-		except Exception as e:
-			DispenserGK.ResourceLock.release()
-			raise e
-		self.__last_command_sent = b''
-		self.__last_feedback_received = b''
-
-	def close(self):
-		if self.__serial.is_open:
-			self.__serial.close()
-		DispenserGK.ResourceLock.release()
-
-	def __enter__(self):
-		return self
-
-	def __exit__(self, exc_type, exc_val, exc_tb):
-		self.close()
-
-	@property
-	def last_command_sent(self) -> bytes:
-		return self.__last_command_sent
-
-	@property
-	def last_feedback_received(self) -> bytes:
-		return self.__last_feedback_received
-
-	@property
-	def last_command(self) -> str:
-		return self.last_command_sent.decode('latin')
-
-	@property
-	def last_feedback(self) -> str:
-		return self.last_feedback_received.decode('latin')
-
-	@staticmethod
-	def cal_crc(data: bytes) -> int:
-		crc = 0
-		length = len(data)
-		assert length % 2 == 0, f'Data length must be multiple of 2'
-		for i in range(0, length, 2):
-			content = data[i:i+2]
-			value = int(content, 16)
-			crc += value
-		return crc & 0xFF
-
-	@staticmethod
-	def check_crc(data: bytes) -> bool:
-		assert data.startswith(b':'), f'Data frame must start with ":"'
-		assert data.endswith(b'\r\n'), f'Data frame must end with CRLN'
-		content = data[1:-4]
-		crc = DispenserGK.cal_crc(content)
-		crc2 = int(data[-4:-2], 16)
-		return crc == crc2
-
-	@staticmethod
-	def add_head_tail(command: str) -> bytes:
-		crc = DispenserGK.cal_crc(command.encode())
-		whole = f':{command}{crc:02X}\r\n'
-		return whole.encode('latin')
-
-	@staticmethod
-	def para_len(para: int) -> List[int]:
-		default = [2]
-		return DispenserGK.ParamLen.get(para, default)
-
-	def read_para(self, para: int) -> int:
-		para_lens = DispenserGK.para_len(para)
-		assert len(para_lens) == 1, f'函数 read_para 仅用于读取单一参数的值。'
-		values = self.do_read_paras(para)
-		return values[0]
-
-	def read_multi_parameters(self, para: int) -> List[int]:
-		return self.do_read_paras(para)
-
-	def do_read_paras(self, para: int) -> List[int]:
-		command = b':00%02X%02X\r\n' % (para, para)
-		self.__last_command_sent = command
-		self.__serial.write(command)
-		para_lens = DispenserGK.para_len(para)
-		para_total = sum(para_lens) * 2
-		total = 1 + 2 + 2 + 2 + para_total + 2 + 2
-		feedback = self.__serial.read_until(size=total)
-		self.__last_feedback_received = feedback
-		assert feedback.endswith(b'\n'), f'Read from dispenser timeout'
-		assert DispenserGK.check_crc(feedback), 'Frame CRC invalid'
-		para_data = feedback[7:7+para_total]
-		idx = 0
-		start = 0
-		result = list()
-		while idx < len(para_lens):
-			item_len = para_lens[idx] * 2
-			item = para_data[start:start+item_len]
-			value = int(item, 16)
-			result.append(value)
-			start += item_len
-			idx += 1
-		return result
-
-	def write_para(self, para: int, value: int):
-		data_lens = DispenserGK.para_len(para)
-		assert len(data_lens) == 1, f'函数 write_para 仅用于设置单一参数。'
-		data_len = data_lens[0]
-		data = f'{value:X}'.rjust(data_len * 2, '0')
-		command = f'01{para:02X}{data_len:02X}{data}'
-		whole_command = DispenserGK.add_head_tail(command)
-		self.__serial.write(whole_command)
-		self.__last_command_sent = whole_command
-		feedback = self.__serial.read_until()
-		self.__last_feedback_received = feedback
-		assert feedback.endswith(b'\n'), 'Read from dispenser timeout'
-		error_code = int(feedback[3:5], 16)
-		assert error_code == 0, f'参数设置出错，错误码：{error_code:02X}'
-
-	def action_control(self, action: int, start: int):
-		command = f'02{action:02X}{start:02X}'
-		whole_command = DispenserGK.add_head_tail(command)
-		self.__serial.write(whole_command)
-		self.__last_command_sent = whole_command
-		feedback = self.__serial.read_until()
-		self.__last_feedback_received = feedback
-		assert feedback.endswith(b'\n'), 'Read from dispenser timeout'
-		error_code = int(feedback[3:5], 16)
-		assert error_code == 0, f'动作控制出错，错误码：{error_code:02X}'
-
-	def start_nozzle_heater(self):
-		self.action_control(action=0x2, start=1)
-
-	def stop_nozzle_heater(self):
-		self.action_control(action=0x2, start=0)
-
-	def get_nozzle_setting_temperature(self) -> int:
-		return self.read_para(0x20)
-
-	def get_nozzle_temperature(self) -> int:
-		return self.read_para(0x52)
-
-	def get_what_you_need(self):
-		"""
-		这个函数用于给通信调试助手使用
-		"""
-		needle_shift = self.read_para(0x13)
-		raising_time = self.read_para(0x14) / 100
-		open_time = self.read_para(0x15) / 100
-		falling_time = self.read_para(0x16) / 100
-		close_time = self.read_para(0x17) / 100
-		nozzle_temperature = self.get_nozzle_setting_temperature() / 10
-		alarm_state = f'{self.get_alarm_state():04X}'
-		result = dict(
-			needle_shift=needle_shift,
-			needle_raising_time=raising_time,
-			open_time=open_time,
-			needle_falling_time=falling_time,
-			close_time=close_time,
-			nozzle_temperature=nozzle_temperature,
-			alarm_state=alarm_state
-		)
-		return result
-
-	def get_alarm_state(self) -> int:
-		return self.read_para(0x30)
-
-	def set_what_you_want(self, values: List[int]):
-		assert len(values) == 6, '必须是“撞针行程、撞针上升时间、开阀时间、撞针下降时间、关阀时间、喷嘴加热温度”这6个参数'
-		paras = [0x13, 0x14, 0x15, 0x16, 0x17, 0x20]
-		for value, para in zip(values, paras):
-			self.write_para(para, value)
-
-	def get_all(self) -> List[int]:
-		"""
-		这个函数主要给自动程序使用
-		"""
-		paras = [0x13, 0x14, 0x15, 0x16, 0x17, 0x20, 0x30]
-		values = []
-		for para in paras:
-			value = self.read_para(para)
-			values.append(value)
-		return values
+from serial import Serial
+from threading import Lock
+from typing import List
+
+
+class DispenserGK:
+	"""点胶机（最初来自众人行-华工科技项目，品牌未知）简单包装，采用 RS232 通信，自定义（ASCII）协议通信，供应商文档称之为“GK通信协议”。"""
+
+	ParamLen = {
+		0x10: [1],
+		0x11: [1],
+		0x12: [4],
+		0x13: [1],
+		0x19: [2],  # 文档中说用于一次读取9个参数，实际只回来2个字节的数据，不知道对应啥参数
+		0x40: [4],
+		0x54: [4]
+	}
+	ResourceLock = Lock()
+
+	def __init__(self, port: str, baudrate: int = 9600, timeout: float = 0.5):
+		DispenserGK.ResourceLock.acquire()
+		try:
+			self.__serial = Serial(port=port, baudrate=baudrate, timeout=timeout)
+		except Exception as e:
+			DispenserGK.ResourceLock.release()
+			raise e
+		self.__last_command_sent = b''
+		self.__last_feedback_received = b''
+
+	def close(self):
+		if self.__serial.is_open:
+			self.__serial.close()
+		DispenserGK.ResourceLock.release()
+
+	def __enter__(self):
+		return self
+
+	def __exit__(self, exc_type, exc_val, exc_tb):
+		self.close()
+
+	@property
+	def last_command_sent(self) -> bytes:
+		return self.__last_command_sent
+
+	@property
+	def last_feedback_received(self) -> bytes:
+		return self.__last_feedback_received
+
+	@property
+	def last_command(self) -> str:
+		return self.last_command_sent.decode('latin')
+
+	@property
+	def last_feedback(self) -> str:
+		return self.last_feedback_received.decode('latin')
+
+	@staticmethod
+	def cal_crc(data: bytes) -> int:
+		crc = 0
+		length = len(data)
+		assert length % 2 == 0, f'Data length must be multiple of 2'
+		for i in range(0, length, 2):
+			content = data[i:i+2]
+			value = int(content, 16)
+			crc += value
+		return crc & 0xFF
+
+	@staticmethod
+	def check_crc(data: bytes) -> bool:
+		assert data.startswith(b':'), f'Data frame must start with ":"'
+		assert data.endswith(b'\r\n'), f'Data frame must end with CRLN'
+		content = data[1:-4]
+		crc = DispenserGK.cal_crc(content)
+		crc2 = int(data[-4:-2], 16)
+		return crc == crc2
+
+	@staticmethod
+	def add_head_tail(command: str) -> bytes:
+		crc = DispenserGK.cal_crc(command.encode())
+		whole = f':{command}{crc:02X}\r\n'
+		return whole.encode('latin')
+
+	@staticmethod
+	def para_len(para: int) -> List[int]:
+		default = [2]
+		return DispenserGK.ParamLen.get(para, default)
+
+	def read_para(self, para: int) -> int:
+		para_lens = DispenserGK.para_len(para)
+		assert len(para_lens) == 1, f'函数 read_para 仅用于读取单一参数的值。'
+		values = self.do_read_paras(para)
+		return values[0]
+
+	def read_multi_parameters(self, para: int) -> List[int]:
+		return self.do_read_paras(para)
+
+	def do_read_paras(self, para: int) -> List[int]:
+		command = b':00%02X%02X\r\n' % (para, para)
+		self.__last_command_sent = command
+		self.__serial.write(command)
+		para_lens = DispenserGK.para_len(para)
+		para_total = sum(para_lens) * 2
+		total = 1 + 2 + 2 + 2 + para_total + 2 + 2
+		feedback = self.__serial.read_until(size=total)
+		self.__last_feedback_received = feedback
+		assert feedback.endswith(b'\n'), f'Read from dispenser timeout'
+		assert DispenserGK.check_crc(feedback), 'Frame CRC invalid'
+		para_data = feedback[7:7+para_total]
+		idx = 0
+		start = 0
+		result = list()
+		while idx < len(para_lens):
+			item_len = para_lens[idx] * 2
+			item = para_data[start:start+item_len]
+			value = int(item, 16)
+			result.append(value)
+			start += item_len
+			idx += 1
+		return result
+
+	def write_para(self, para: int, value: int):
+		data_lens = DispenserGK.para_len(para)
+		assert len(data_lens) == 1, f'函数 write_para 仅用于设置单一参数。'
+		data_len = data_lens[0]
+		data = f'{value:X}'.rjust(data_len * 2, '0')
+		command = f'01{para:02X}{data_len:02X}{data}'
+		whole_command = DispenserGK.add_head_tail(command)
+		self.__serial.write(whole_command)
+		self.__last_command_sent = whole_command
+		feedback = self.__serial.read_until()
+		self.__last_feedback_received = feedback
+		assert feedback.endswith(b'\n'), 'Read from dispenser timeout'
+		error_code = int(feedback[3:5], 16)
+		assert error_code == 0, f'参数设置出错，错误码：{error_code:02X}'
+
+	def action_control(self, action: int, start: int):
+		command = f'02{action:02X}{start:02X}'
+		whole_command = DispenserGK.add_head_tail(command)
+		self.__serial.write(whole_command)
+		self.__last_command_sent = whole_command
+		feedback = self.__serial.read_until()
+		self.__last_feedback_received = feedback
+		assert feedback.endswith(b'\n'), 'Read from dispenser timeout'
+		error_code = int(feedback[3:5], 16)
+		assert error_code == 0, f'动作控制出错，错误码：{error_code:02X}'
+
+	def start_nozzle_heater(self):
+		self.action_control(action=0x2, start=1)
+
+	def stop_nozzle_heater(self):
+		self.action_control(action=0x2, start=0)
+
+	def get_nozzle_setting_temperature(self) -> int:
+		return self.read_para(0x20)
+
+	def get_nozzle_temperature(self) -> int:
+		return self.read_para(0x52)
+
+	def get_what_you_need(self):
+		"""
+		这个函数用于给通信调试助手使用
+		"""
+		needle_shift = self.read_para(0x13)
+		raising_time = self.read_para(0x14) / 100
+		open_time = self.read_para(0x15) / 100
+		falling_time = self.read_para(0x16) / 100
+		close_time = self.read_para(0x17) / 100
+		nozzle_temperature = self.get_nozzle_setting_temperature() / 10
+		alarm_state = f'{self.get_alarm_state():04X}'
+		result = dict(
+			needle_shift=needle_shift,
+			needle_raising_time=raising_time,
+			open_time=open_time,
+			needle_falling_time=falling_time,
+			close_time=close_time,
+			nozzle_temperature=nozzle_temperature,
+			alarm_state=alarm_state
+		)
+		return result
+
+	def get_alarm_state(self) -> int:
+		return self.read_para(0x30)
+
+	def set_what_you_want(self, values: List[int]):
+		assert len(values) == 6, '必须是“撞针行程、撞针上升时间、开阀时间、撞针下降时间、关阀时间、喷嘴加热温度”这6个参数'
+		paras = [0x13, 0x14, 0x15, 0x16, 0x17, 0x20]
+		for value, para in zip(values, paras):
+			self.write_para(para, value)
+
+	def get_all(self) -> List[int]:
+		"""
+		这个函数主要给自动程序使用
+		"""
+		paras = [0x13, 0x14, 0x15, 0x16, 0x17, 0x20, 0x30]
+		values = []
+		for para in paras:
+			value = self.read_para(para)
+			values.append(value)
+		return values
```

## a2y_inst/dt1309.py

 * *Ordering differences only*

```diff
@@ -1,79 +1,79 @@
-from serial import Serial as _Serial
-from threading import Thread as _Thread, Event as _Event
-from time import sleep as _sleep
-from typing import Optional as _Optional
-
-
-class DT1309(_Serial):
-	def __init__(self, port: str):
-		_Serial.__init__(self, port=port, baudrate=9600, timeout=0.5)
-		self.__value: float = -1
-		self.interval = 0.2
-
-		self.__ready_event = _Event()
-		self.__stop_flag = False
-		self.last_frame = ''
-
-		self.__checking_thread: _Optional[_Thread] = None
-		self.start()
-
-	def start(self):
-		assert self.__checking_thread is None, 'Device has started.'
-		self.__stop_flag = False
-		self.__checking_thread = _Thread(target=self.__checker)
-		self.__checking_thread.start()
-
-	def stop(self):
-		if self.__checking_thread is not None:
-			self.__stop_flag = True
-			self.__checking_thread.join()
-			self.__checking_thread = None
-
-	def close(self):
-		self.stop()
-		super(DT1309, self).close()
-
-	def open(self):
-		super(DT1309, self).open()
-		self.start()
-
-	def __checker(self):
-		while not self.__stop_flag:
-			self.flushInput()
-			self.write(b'\x00\x00')
-			char = self.read()
-			timeout = False
-			while char != b'\xCE':
-				if char == b'':
-					timeout = True
-					break
-				else:
-					char = self.read()
-			if timeout:
-				continue
-			data = self.read(4)
-			hex_items = [hex(c)[2:].upper().zfill(2) for c in data]
-			hex_str = ' '.join(hex_items)
-			self.last_frame = f'CE {hex_str}'
-			if len(data) != 4 or data[0] not in [0, 1, 2] or data[1] not in [0x80, 0x88]:
-				continue
-			high = int(hex(data[2])[2:])
-			low = int(hex(data[3])[2:])
-			value = high * 100 + low
-			for i in range(data[0]):
-				value = value / 10
-			if data[1] == 0x88:
-				value = value * 1000
-
-			self.__value = value
-			self.__ready_event.set()
-
-			_sleep(self.interval)
-
-	@property
-	def lux(self) -> _Optional[float]:
-		assert self.__checking_thread is not None and not self.__stop_flag, 'Device must be started first.'
-		self.__ready_event.clear()
-		if not self.__ready_event.wait(timeout=3):
-			return None
-		return self.__value
+from serial import Serial as _Serial
+from threading import Thread as _Thread, Event as _Event
+from time import sleep as _sleep
+from typing import Optional as _Optional
+
+
+class DT1309(_Serial):
+	def __init__(self, port: str):
+		_Serial.__init__(self, port=port, baudrate=9600, timeout=0.5)
+		self.__value: float = -1
+		self.interval = 0.2
+
+		self.__ready_event = _Event()
+		self.__stop_flag = False
+		self.last_frame = ''
+
+		self.__checking_thread: _Optional[_Thread] = None
+		self.start()
+
+	def start(self):
+		assert self.__checking_thread is None, 'Device has started.'
+		self.__stop_flag = False
+		self.__checking_thread = _Thread(target=self.__checker)
+		self.__checking_thread.start()
+
+	def stop(self):
+		if self.__checking_thread is not None:
+			self.__stop_flag = True
+			self.__checking_thread.join()
+			self.__checking_thread = None
+
+	def close(self):
+		self.stop()
+		super(DT1309, self).close()
+
+	def open(self):
+		super(DT1309, self).open()
+		self.start()
+
+	def __checker(self):
+		while not self.__stop_flag:
+			self.flushInput()
+			self.write(b'\x00\x00')
+			char = self.read()
+			timeout = False
+			while char != b'\xCE':
+				if char == b'':
+					timeout = True
+					break
+				else:
+					char = self.read()
+			if timeout:
+				continue
+			data = self.read(4)
+			hex_items = [hex(c)[2:].upper().zfill(2) for c in data]
+			hex_str = ' '.join(hex_items)
+			self.last_frame = f'CE {hex_str}'
+			if len(data) != 4 or data[0] not in [0, 1, 2] or data[1] not in [0x80, 0x88]:
+				continue
+			high = int(hex(data[2])[2:])
+			low = int(hex(data[3])[2:])
+			value = high * 100 + low
+			for i in range(data[0]):
+				value = value / 10
+			if data[1] == 0x88:
+				value = value * 1000
+
+			self.__value = value
+			self.__ready_event.set()
+
+			_sleep(self.interval)
+
+	@property
+	def lux(self) -> _Optional[float]:
+		assert self.__checking_thread is not None and not self.__stop_flag, 'Device must be started first.'
+		self.__ready_event.clear()
+		if not self.__ready_event.wait(timeout=3):
+			return None
+		return self.__value
```

## a2y_inst/gwinstek.py

```diff
@@ -12,17 +12,17 @@
 	"""
 	def __init__(self, port: str, baudrate: int = 115200):
 		_Serial.__init__(self, port=port, baudrate=baudrate, timeout=0.5)
 		self.__last_sent = ''
 		self.__last_recv = ''
 
 	def write_command(self, command: str):
-		cmd = command.encode('ascii')
 		if not command.endswith('\n'):
-			cmd = f'{cmd}\n'
+			command = f'{command}\n'
+		cmd = command.encode('ascii')
 		self.__last_sent = cmd
 		self.write(cmd)
 
 	def read_feedback(self) -> str:
 		fb = self.read_until()
 		try:
 			feedback = fb.decode('ascii')
```

## a2y_inst/itech.py

 * *Ordering differences only*

```diff
@@ -1,185 +1,185 @@
-from serial import Serial as Serial
-from typing import Union as _Union
-from enum import Enum
-
-
-class LoadMode(Enum):
-	CC = 0
-	CV = 1
-	CW = 2
-	CR = 3
-
-
-class IT8500plus:
-	def __init__(self, port: str, baudrate: int = 9600):
-		self.__serial = Serial(port, baudrate=baudrate, timeout=0.5)
-
-	@staticmethod
-	def checksum(data: _Union[bytearray, bytes]) -> int:
-		assert len(data) >= 25
-		crc = 0
-		for i in range(25):
-			crc += data[i]
-		return crc & 0xFF
-
-	def read_frame(self):
-		frame = self.__serial.read(26)
-		if len(frame) != 26:
-			raise IOError('Communicate with IT8500plus timeout.')
-		if frame[0] != 0xAA:
-			raise IOError('IT8500plus frame header invalid.')
-		if IT8500plus.checksum(frame) != frame[25]:
-			raise IOError('IT8500plus frame checksum error.')
-
-		return frame
-
-	def read_setting_feedback_frame(self):
-		frame = self.read_frame()
-		if frame[2] != 0x12:
-			raise IOError(f'IT8500plus Setting Feedback frame format invalid: command byte is not 0x12: {frame[2]}.')
-		if frame[3] != 0x80:
-			raise IOError(f'IT58500plus says that you have make some mistakes on your command: {frame[3]:02X}H.')
-		return frame
-
-	def __set_something(self, frame):
-		self.__serial.write(frame)
-		self.read_setting_feedback_frame()
-
-	def read_getting_multi_bytes_feedback_frame(self, cmd: int, count: int):
-		frame = self.read_frame()
-		if frame[2] != cmd:
-			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
-		return frame[3:3+count]
-
-	def read_getting_one_bye_feedback_frame(self, cmd: int) -> int:
-		frame = self.read_frame()
-		if frame[2] != cmd:
-			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
-		return frame[3]
-
-	def __get_one_byte(self, frame) -> int:
-		self.__serial.write(frame)
-		return self.read_getting_one_bye_feedback_frame(frame[2])
-
-	def read_getting_u16int_feedback_frame(self, cmd: int) -> int:
-		frame = self.read_frame()
-		if frame[2] != cmd:
-			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
-		return (frame[4] << 8) | frame[3]
-
-	def __get_uint16(self, frame) -> int:
-		self.__serial.write(frame)
-		return self.read_getting_u16int_feedback_frame(frame[2])
-
-	def read_getting_u32int_feedback_frame(self, cmd: int) -> int:
-		frame = self.read_frame()
-		if frame[2] != cmd:
-			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
-		return frame[3] | (frame[4] << 8) | (frame[5] << 16) | (frame[6] << 24)
-
-	def __get_uint32(self, frame) -> int:
-		self.__serial.write(frame)
-		return self.read_getting_u32int_feedback_frame(frame[2])
-
-	@staticmethod
-	def build_frame(station: int, cmd: int, data: _Union[bytearray, bytes, list]):
-		assert len(data) <= 22
-		frame = bytearray(26)
-		frame[0] = 0xAA
-		frame[1] = station
-		frame[2] = cmd
-		for idx, byte in enumerate(data):
-			frame[idx+3] = byte
-		frame[-1] = IT8500plus.checksum(frame)
-		return frame
-
-	def set_control_mode(self, station: int, mode: _Union[str, bool, int]):
-		"""
-		设置负载仪的控制模式：通过本地面板控制的本地模式，或者是通过通信端口控制的远程模式（remote mode）。
-		"""
-		if isinstance(mode, str):
-			mode_value = 1 if mode == 'remote' else 0
-		elif isinstance(mode, bool):
-			mode_value = 1 if mode else 0
-		elif isinstance(mode, int):
-			mode_value = 0 if mode == 0 else 1
-		else:
-			raise ValueError(f'Unknown mode: {mode} with type {type(mode)}.')
-		frame = IT8500plus.build_frame(station, 0x20, [mode_value])
-		self.__set_something(frame)
-
-	def set_remote_mode(self, station: int):
-		"""
-		设置负载仪为远程模式。只有在远程模式下，负载仪才会响应从通信端口传入的其他的设置、控制命令。
-		"""
-		self.set_control_mode(station, mode=1)
-
-	def set_load_mode(self, station: int, mode: LoadMode):
-		frame = IT8500plus.build_frame(station, 0x28, [mode.value])
-		self.__set_something(frame)
-
-	def get_load_mode(self, station: int):
-		frame = IT8500plus.build_frame(station, 0x29, [])
-		feedback = self.__get_one_byte(frame)
-		return LoadMode(feedback)
-
-	def set_cc_current(self, station: int, current: float):
-		cur = int(current * 10000)
-		data = [0] * 4
-		data[0] = cur & 0xFF
-		data[1] = (cur >> 8) & 0xFF
-		data[2] = (cur >> 16) & 0xFF
-		data[3] = (cur >> 24) & 0xFF
-		frame = IT8500plus.build_frame(station, 0x2A, data)
-		self.__set_something(frame)
-
-	def get_cc_current(self, station: int) -> float:
-		frame = IT8500plus.build_frame(station, 0x2B, [])
-		current = self.__get_uint32(frame)
-		return current / 10000
-
-	def get_load_status(self, station: int) -> dict:
-		status = dict()
-		frame = IT8500plus.build_frame(station, 0x5F, [])
-		self.__serial.write(frame)
-		data = self.read_getting_multi_bytes_feedback_frame(0x5F, 26-3-1)
-		for idx, name in enumerate(['voltage', 'current', 'power']):
-			start = idx * 4
-			value = data[start] | (data[start+1] << 8) | (data[start+2] << 16) | (data[start+3] << 24)
-			status[name] = value
-		status['operation_status'] = data[12]
-		status['query_status'] = data[13] | (data[14] << 8)
-		# TODO: 保存其他那些“散热器温度”等数据
-		return status
-
-	def get_real_current(self, station: int) -> float:
-		status = self.get_load_status(station)
-		return status['current'] / 10000
-
-	def get_real_voltage(self, station: int) -> float:
-		status = self.get_load_status(station)
-		return status['voltage'] / 1000
-
-	def get_real_power(self, station: int) -> float:
-		status = self.get_load_status(station)
-		return status['power'] / 1000
-
-	def set_input_state(self, station: int, state: _Union[bool, str]):
-		if isinstance(state, str):
-			if state.upper() in ['ON', '1']:
-				i_state = 1
-			else:
-				i_state = 0
-		else:
-			i_state = 1 if state else 0
-		frame = IT8500plus.build_frame(station, 0x21, [i_state])
-		self.__set_something(frame)
-
-	def turn_on(self, station: int):
-		self.set_input_state(station, True)
-
-	def turn_off(self, station: int):
-		self.set_input_state(station, False)
-
-	def close(self):
-		self.__serial.close()
+from serial import Serial as Serial
+from typing import Union as _Union
+from enum import Enum
+
+
+class LoadMode(Enum):
+	CC = 0
+	CV = 1
+	CW = 2
+	CR = 3
+
+
+class IT8500plus:
+	def __init__(self, port: str, baudrate: int = 9600):
+		self.__serial = Serial(port, baudrate=baudrate, timeout=0.5)
+
+	@staticmethod
+	def checksum(data: _Union[bytearray, bytes]) -> int:
+		assert len(data) >= 25
+		crc = 0
+		for i in range(25):
+			crc += data[i]
+		return crc & 0xFF
+
+	def read_frame(self):
+		frame = self.__serial.read(26)
+		if len(frame) != 26:
+			raise IOError('Communicate with IT8500plus timeout.')
+		if frame[0] != 0xAA:
+			raise IOError('IT8500plus frame header invalid.')
+		if IT8500plus.checksum(frame) != frame[25]:
+			raise IOError('IT8500plus frame checksum error.')
+
+		return frame
+
+	def read_setting_feedback_frame(self):
+		frame = self.read_frame()
+		if frame[2] != 0x12:
+			raise IOError(f'IT8500plus Setting Feedback frame format invalid: command byte is not 0x12: {frame[2]}.')
+		if frame[3] != 0x80:
+			raise IOError(f'IT58500plus says that you have make some mistakes on your command: {frame[3]:02X}H.')
+		return frame
+
+	def __set_something(self, frame):
+		self.__serial.write(frame)
+		self.read_setting_feedback_frame()
+
+	def read_getting_multi_bytes_feedback_frame(self, cmd: int, count: int):
+		frame = self.read_frame()
+		if frame[2] != cmd:
+			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
+		return frame[3:3+count]
+
+	def read_getting_one_bye_feedback_frame(self, cmd: int) -> int:
+		frame = self.read_frame()
+		if frame[2] != cmd:
+			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
+		return frame[3]
+
+	def __get_one_byte(self, frame) -> int:
+		self.__serial.write(frame)
+		return self.read_getting_one_bye_feedback_frame(frame[2])
+
+	def read_getting_u16int_feedback_frame(self, cmd: int) -> int:
+		frame = self.read_frame()
+		if frame[2] != cmd:
+			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
+		return (frame[4] << 8) | frame[3]
+
+	def __get_uint16(self, frame) -> int:
+		self.__serial.write(frame)
+		return self.read_getting_u16int_feedback_frame(frame[2])
+
+	def read_getting_u32int_feedback_frame(self, cmd: int) -> int:
+		frame = self.read_frame()
+		if frame[2] != cmd:
+			raise IOError(f'IT8500plus feedback command byte is not matched. Send: {cmd:02X}H, Recf: {frame[2]:02X}H.')
+		return frame[3] | (frame[4] << 8) | (frame[5] << 16) | (frame[6] << 24)
+
+	def __get_uint32(self, frame) -> int:
+		self.__serial.write(frame)
+		return self.read_getting_u32int_feedback_frame(frame[2])
+
+	@staticmethod
+	def build_frame(station: int, cmd: int, data: _Union[bytearray, bytes, list]):
+		assert len(data) <= 22
+		frame = bytearray(26)
+		frame[0] = 0xAA
+		frame[1] = station
+		frame[2] = cmd
+		for idx, byte in enumerate(data):
+			frame[idx+3] = byte
+		frame[-1] = IT8500plus.checksum(frame)
+		return frame
+
+	def set_control_mode(self, station: int, mode: _Union[str, bool, int]):
+		"""
+		设置负载仪的控制模式：通过本地面板控制的本地模式，或者是通过通信端口控制的远程模式（remote mode）。
+		"""
+		if isinstance(mode, str):
+			mode_value = 1 if mode == 'remote' else 0
+		elif isinstance(mode, bool):
+			mode_value = 1 if mode else 0
+		elif isinstance(mode, int):
+			mode_value = 0 if mode == 0 else 1
+		else:
+			raise ValueError(f'Unknown mode: {mode} with type {type(mode)}.')
+		frame = IT8500plus.build_frame(station, 0x20, [mode_value])
+		self.__set_something(frame)
+
+	def set_remote_mode(self, station: int):
+		"""
+		设置负载仪为远程模式。只有在远程模式下，负载仪才会响应从通信端口传入的其他的设置、控制命令。
+		"""
+		self.set_control_mode(station, mode=1)
+
+	def set_load_mode(self, station: int, mode: LoadMode):
+		frame = IT8500plus.build_frame(station, 0x28, [mode.value])
+		self.__set_something(frame)
+
+	def get_load_mode(self, station: int):
+		frame = IT8500plus.build_frame(station, 0x29, [])
+		feedback = self.__get_one_byte(frame)
+		return LoadMode(feedback)
+
+	def set_cc_current(self, station: int, current: float):
+		cur = int(current * 10000)
+		data = [0] * 4
+		data[0] = cur & 0xFF
+		data[1] = (cur >> 8) & 0xFF
+		data[2] = (cur >> 16) & 0xFF
+		data[3] = (cur >> 24) & 0xFF
+		frame = IT8500plus.build_frame(station, 0x2A, data)
+		self.__set_something(frame)
+
+	def get_cc_current(self, station: int) -> float:
+		frame = IT8500plus.build_frame(station, 0x2B, [])
+		current = self.__get_uint32(frame)
+		return current / 10000
+
+	def get_load_status(self, station: int) -> dict:
+		status = dict()
+		frame = IT8500plus.build_frame(station, 0x5F, [])
+		self.__serial.write(frame)
+		data = self.read_getting_multi_bytes_feedback_frame(0x5F, 26-3-1)
+		for idx, name in enumerate(['voltage', 'current', 'power']):
+			start = idx * 4
+			value = data[start] | (data[start+1] << 8) | (data[start+2] << 16) | (data[start+3] << 24)
+			status[name] = value
+		status['operation_status'] = data[12]
+		status['query_status'] = data[13] | (data[14] << 8)
+		# TODO: 保存其他那些“散热器温度”等数据
+		return status
+
+	def get_real_current(self, station: int) -> float:
+		status = self.get_load_status(station)
+		return status['current'] / 10000
+
+	def get_real_voltage(self, station: int) -> float:
+		status = self.get_load_status(station)
+		return status['voltage'] / 1000
+
+	def get_real_power(self, station: int) -> float:
+		status = self.get_load_status(station)
+		return status['power'] / 1000
+
+	def set_input_state(self, station: int, state: _Union[bool, str]):
+		if isinstance(state, str):
+			if state.upper() in ['ON', '1']:
+				i_state = 1
+			else:
+				i_state = 0
+		else:
+			i_state = 1 if state else 0
+		frame = IT8500plus.build_frame(station, 0x21, [i_state])
+		self.__set_something(frame)
+
+	def turn_on(self, station: int):
+		self.set_input_state(station, True)
+
+	def turn_off(self, station: int):
+		self.set_input_state(station, False)
+
+	def close(self):
+		self.__serial.close()
```

## a2y_inst/jabil.py

 * *Ordering differences only*

```diff
@@ -1,92 +1,92 @@
-from typing import List
-
-
-class Measurement:
-	def __init__(self, name: str, result: bool = True, value=None, date_time: str = ''):
-		self.name = name
-		self.result = result
-		self.value = value
-		self.date_time = date_time
-
-	def is_ok(self):
-		return self.result
-
-	def is_ng(self):
-		return not self.is_ok()
-
-	@property
-	def result_str(self) -> str:
-		return 'Pass' if self.result else 'Fail'
-
-
-class Tar:
-	def __init__(
-			self, serial_number: str = 'NoSerial', customer='', board_style='', tester_name='',
-			test_process='', fixture_slot=1, assembly_number='', assembly_revision='',
-			firmware_revision='', test_status='P', line='1',
-			**kwargs
-	):
-		self.test_process = test_process
-		self.test_status = test_status
-
-		self.serial_number = serial_number
-		self.customer = customer
-		self.board_style = board_style
-		self.tester_name = tester_name
-		self.fixture_slot = fixture_slot
-		self.assembly_number = assembly_number
-		self.assembly_revision = assembly_revision
-		self.firmware_revision = firmware_revision
-		self.line = line
-		self.fail_message = ''
-		self.measurements: List[Measurement] = []
-		self.kwargs = kwargs
-
-	def load_test_report(self, measurements: List[Measurement], aborted: bool = False):
-		if aborted:
-			self.test_status = 'A'
-
-		for measurement_raw in measurements:
-			measurement: Measurement = measurement_raw
-			if self.test_status == 'P' and measurement.is_ng():
-				self.test_status = 'F'
-				self.fail_message = measurement.name
-		self.measurements = measurements
-
-	def generate(self, filename: str):
-		LE = '\n'
-		start_date = ''
-		stop_date = ''
-		for measurement in self.measurements:
-			if start_date == '' or measurement.date_time < start_date:
-				start_date = measurement.date_time
-			if stop_date < measurement.date_time:
-				stop_date = measurement.date_time
-		with open(filename, 'w') as f:
-			f.write('S%s%s' % (self.serial_number, LE))
-			f.write('C%s%s' % (self.customer, LE))
-			f.write('B%s%s' % (self.board_style, LE))
-			f.write('N%s%s' % (self.tester_name, LE))
-			f.write('P%s%s' % (self.test_process, LE))
-			f.write('s%s%s' % (self.fixture_slot, LE))
-			f.write('n%s%s' % (self.assembly_number, LE))
-			f.write('r%s%s' % (self.assembly_revision, LE))
-			f.write('W%s%s' % (self.firmware_revision, LE))
-			f.write('T%s%s' % (self.test_status, LE))
-			f.write('L%s%s' % (self.line, LE))
-
-			for key, value in self.kwargs.items():
-				f.write(f'{key}{value}{LE}')
-
-			f.write('[%s%s' % (start_date, LE))
-			f.write(']%s%s' % (stop_date, LE))
-			if self.test_status == 'F':
-				f.write('F%sM%s%s' % (LE, self.fail_message, LE))
-
-			for measurement_raw in self.measurements:
-				measurement: Measurement = measurement_raw
-				f.write('M%s%s' % (measurement.name, LE))
-				if measurement.value is not None and measurement.value != '':
-					f.write('d%s%s' % (measurement.value, LE))
-				else:
-					f.write('d%s%s' % (measurement.result_str, LE))
+from typing import List
+
+
+class Measurement:
+	def __init__(self, name: str, result: bool = True, value=None, date_time: str = ''):
+		self.name = name
+		self.result = result
+		self.value = value
+		self.date_time = date_time
+
+	def is_ok(self):
+		return self.result
+
+	def is_ng(self):
+		return not self.is_ok()
+
+	@property
+	def result_str(self) -> str:
+		return 'Pass' if self.result else 'Fail'
+
+
+class Tar:
+	def __init__(
+			self, serial_number: str = 'NoSerial', customer='', board_style='', tester_name='',
+			test_process='', fixture_slot=1, assembly_number='', assembly_revision='',
+			firmware_revision='', test_status='P', line='1',
+			**kwargs
+	):
+		self.test_process = test_process
+		self.test_status = test_status
+
+		self.serial_number = serial_number
+		self.customer = customer
+		self.board_style = board_style
+		self.tester_name = tester_name
+		self.fixture_slot = fixture_slot
+		self.assembly_number = assembly_number
+		self.assembly_revision = assembly_revision
+		self.firmware_revision = firmware_revision
+		self.line = line
+		self.fail_message = ''
+		self.measurements: List[Measurement] = []
+		self.kwargs = kwargs
+
+	def load_test_report(self, measurements: List[Measurement], aborted: bool = False):
+		if aborted:
+			self.test_status = 'A'
+
+		for measurement_raw in measurements:
+			measurement: Measurement = measurement_raw
+			if self.test_status == 'P' and measurement.is_ng():
+				self.test_status = 'F'
+				self.fail_message = measurement.name
+		self.measurements = measurements
+
+	def generate(self, filename: str):
+		LE = '\n'
+		start_date = ''
+		stop_date = ''
+		for measurement in self.measurements:
+			if start_date == '' or measurement.date_time < start_date:
+				start_date = measurement.date_time
+			if stop_date < measurement.date_time:
+				stop_date = measurement.date_time
+		with open(filename, 'w') as f:
+			f.write('S%s%s' % (self.serial_number, LE))
+			f.write('C%s%s' % (self.customer, LE))
+			f.write('B%s%s' % (self.board_style, LE))
+			f.write('N%s%s' % (self.tester_name, LE))
+			f.write('P%s%s' % (self.test_process, LE))
+			f.write('s%s%s' % (self.fixture_slot, LE))
+			f.write('n%s%s' % (self.assembly_number, LE))
+			f.write('r%s%s' % (self.assembly_revision, LE))
+			f.write('W%s%s' % (self.firmware_revision, LE))
+			f.write('T%s%s' % (self.test_status, LE))
+			f.write('L%s%s' % (self.line, LE))
+
+			for key, value in self.kwargs.items():
+				f.write(f'{key}{value}{LE}')
+
+			f.write('[%s%s' % (start_date, LE))
+			f.write(']%s%s' % (stop_date, LE))
+			if self.test_status == 'F':
+				f.write('F%sM%s%s' % (LE, self.fail_message, LE))
+
+			for measurement_raw in self.measurements:
+				measurement: Measurement = measurement_raw
+				f.write('M%s%s' % (measurement.name, LE))
+				if measurement.value is not None and measurement.value != '':
+					f.write('d%s%s' % (measurement.value, LE))
+				else:
+					f.write('d%s%s' % (measurement.result_str, LE))
```

## a2y_inst/kld.py

 * *Ordering differences only*

```diff
@@ -1,50 +1,50 @@
-from a2y_modbus import Master as _Master
-import struct
-
-
-class K4:
-	"""凯利德K4系列数显电测仪表 RS485 Modbus 通信接口"""
-	def __init__(self, port, baudrate=4800, timeout: float = 0.5):
-		self.master = _Master(port, baudrate, timeout=timeout)
-
-	def close(self):
-		self.master.close()
-
-	def __enter__(self):
-		return self
-
-	def __exit__(self, exc_type, exc_val, exc_tb):
-		self.close()
-
-	def __read_float(self, station, address):
-		low, high = self.master.read_registers(station, address, 2)
-		package = struct.pack('HH', high, low)
-		return struct.unpack('f', package)[0]
-
-	def Read(self, station=1):
-		self.master.serial.flushInput()
-		return self.__read_float(station, 0)
-
-	def ReadUA(self, station=1):
-		"""读取A相电压"""
-		return self.__read_float(station, 3)
-
-	def ReadUB(self, station=1):
-		"""相电压"""
-		return self.__read_float(station, 5)
-
-	def ReadUC(self, station=1):
-		"""相电压"""
-		return self.__read_float(station, 7)
-
-	def ReadIA(self, station=1):
-		"""相电流"""
-		return self.__read_float(station, 9)
-
-	def ReadIB(self, station=1):
-		"""相电流"""
-		return self.__read_float(station, 11)
-
-	def ReadIC(self, station=1):
-		"""相电流"""
-		return self.__read_float(station, 13)
+from a2y_modbus import Master as _Master
+import struct
+
+
+class K4:
+	"""凯利德K4系列数显电测仪表 RS485 Modbus 通信接口"""
+	def __init__(self, port, baudrate=4800, timeout: float = 0.5):
+		self.master = _Master(port, baudrate, timeout=timeout)
+
+	def close(self):
+		self.master.close()
+
+	def __enter__(self):
+		return self
+
+	def __exit__(self, exc_type, exc_val, exc_tb):
+		self.close()
+
+	def __read_float(self, station, address):
+		low, high = self.master.read_registers(station, address, 2)
+		package = struct.pack('HH', high, low)
+		return struct.unpack('f', package)[0]
+
+	def Read(self, station=1):
+		self.master.serial.flushInput()
+		return self.__read_float(station, 0)
+
+	def ReadUA(self, station=1):
+		"""读取A相电压"""
+		return self.__read_float(station, 3)
+
+	def ReadUB(self, station=1):
+		"""相电压"""
+		return self.__read_float(station, 5)
+
+	def ReadUC(self, station=1):
+		"""相电压"""
+		return self.__read_float(station, 7)
+
+	def ReadIA(self, station=1):
+		"""相电流"""
+		return self.__read_float(station, 9)
+
+	def ReadIB(self, station=1):
+		"""相电流"""
+		return self.__read_float(station, 11)
+
+	def ReadIC(self, station=1):
+		"""相电流"""
+		return self.__read_float(station, 13)
```

## a2y_inst/mastech.py

 * *Ordering differences only*

```diff
@@ -1,118 +1,118 @@
-from serial import Serial as _Serial
-from threading import Thread
-from time import sleep, time as now
-from typing import Optional
-
-
-class MS6701(_Serial):
-	"""A Digital Sound Level Meter"""
-
-	InvalidValue = -1.0
-
-	def __init__(self, port: str, baudrate=2400, timeout=0.1):
-		_Serial.__init__(self, port, baudrate=baudrate, timeout=timeout)
-		self.Value: float = MS6701.InvalidValue
-		self.RealTime = False
-		self.Range = 6
-		self.Minimum = 30
-		self.Maximum = 130
-		self.OverRange = False
-		self.UnderRange = False
-		self.Slow = False
-		self.Weighting = 'C'
-		self.MemoryFull = False
-		self.MaxMode = False
-		self.BatteryLow = False
-		self.__stop_flag = False
-		self.__thread: Optional[Thread] = None
-
-		self.Start()
-
-	def Start(self):
-		assert self.__thread is None, 'Device has been started.'
-
-		if not self.is_open:
-			self.open()
-
-		self.__thread = Thread(target=self.__ReadingThread)
-		self.__thread.start()
-
-	def Stop(self):
-		assert(self.__thread is not None)
-
-		self.__stop_flag = True
-		self.__thread.join()
-		self.__thread = None
-
-		self.close()
-
-	def ReadFrame(self, timeout: float = 3, use_stop_flag: bool = False) -> bytes:
-		if timeout is None or timeout <= 0:
-			end = float('inf')
-		else:
-			end = now() + timeout
-		frame = b''
-		while now() < end:
-			if use_stop_flag and self.__stop_flag:
-				break
-
-			if self.in_waiting == 0:
-				sleep(0.1)
-				continue
-			else:
-				sleep(0.1)
-				frame = self.read(18)
-				for idx, c in enumerate(frame):
-					if (c & 0x80) != 0:
-						if idx > 0:
-							frame = frame[idx:] + self.read(idx)
-				if len(frame) == 18:
-					break
-		return frame
-
-	def ParseFrame(self, frame: bytes):
-		for i in range(2, 18):
-			if frame[i] >= 10:
-				raise ValueError('Data format invalid from MS6701')
-		byte0 = frame[0]
-		self.RealTime = (byte0 & 0x20) != 0
-		self.Range = (byte0 & 0x7)
-		if self.Range == 6:
-			self.Minimum = 30
-			self.Maximum = 130
-		else:
-			self.Minimum = 30 + self.Range * 10
-			self.Maximum = 80 + self.Range * 10
-		flags = frame[1]
-		self.OverRange = (flags & 1) != 0
-		self.UnderRange = (flags & 2) != 0
-		self.Slow = (flags & 4) != 0
-		self.Weighting = 'A' if (flags & 8) != 0 else 'C'
-		self.MemoryFull = (flags & 0x10) != 0
-		self.MaxMode = (flags & 0x20) != 0
-		self.BatteryLow = (flags & 0x40) != 0
-		self.Value = frame[2] * 100 + frame[3] * 10 + frame[4] + frame[5] * 0.1
-
-		return self.Value
-
-	def GetValueString(self) -> str:
-		if self.Value < 0:
-			return 'N/A'
-		if self.OverRange:
-			return '> %.1f' % self.Value
-		if self.UnderRange:
-			return '< %.1f' % self.Value
-		return '%.1f' % self.Value
-
-	def __ReadingThread(self):
-		while not self.__stop_flag:
-			frame = self.ReadFrame(use_stop_flag=True)
-			if len(frame) != 18:
-				self.Value = MS6701.InvalidValue
-			else:
-				try:
-					self.ParseFrame(frame)
-				except Exception as _e:
-					import traceback
-					traceback.print_exc()
-					self.Value = MS6701.InvalidValue
+from serial import Serial as _Serial
+from threading import Thread
+from time import sleep, time as now
+from typing import Optional
+
+
+class MS6701(_Serial):
+	"""A Digital Sound Level Meter"""
+
+	InvalidValue = -1.0
+
+	def __init__(self, port: str, baudrate=2400, timeout=0.1):
+		_Serial.__init__(self, port, baudrate=baudrate, timeout=timeout)
+		self.Value: float = MS6701.InvalidValue
+		self.RealTime = False
+		self.Range = 6
+		self.Minimum = 30
+		self.Maximum = 130
+		self.OverRange = False
+		self.UnderRange = False
+		self.Slow = False
+		self.Weighting = 'C'
+		self.MemoryFull = False
+		self.MaxMode = False
+		self.BatteryLow = False
+		self.__stop_flag = False
+		self.__thread: Optional[Thread] = None
+
+		self.Start()
+
+	def Start(self):
+		assert self.__thread is None, 'Device has been started.'
+
+		if not self.is_open:
+			self.open()
+
+		self.__thread = Thread(target=self.__ReadingThread)
+		self.__thread.start()
+
+	def Stop(self):
+		assert(self.__thread is not None)
+
+		self.__stop_flag = True
+		self.__thread.join()
+		self.__thread = None
+
+		self.close()
+
+	def ReadFrame(self, timeout: float = 3, use_stop_flag: bool = False) -> bytes:
+		if timeout is None or timeout <= 0:
+			end = float('inf')
+		else:
+			end = now() + timeout
+		frame = b''
+		while now() < end:
+			if use_stop_flag and self.__stop_flag:
+				break
+
+			if self.in_waiting == 0:
+				sleep(0.1)
+				continue
+			else:
+				sleep(0.1)
+				frame = self.read(18)
+				for idx, c in enumerate(frame):
+					if (c & 0x80) != 0:
+						if idx > 0:
+							frame = frame[idx:] + self.read(idx)
+				if len(frame) == 18:
+					break
+		return frame
+
+	def ParseFrame(self, frame: bytes):
+		for i in range(2, 18):
+			if frame[i] >= 10:
+				raise ValueError('Data format invalid from MS6701')
+		byte0 = frame[0]
+		self.RealTime = (byte0 & 0x20) != 0
+		self.Range = (byte0 & 0x7)
+		if self.Range == 6:
+			self.Minimum = 30
+			self.Maximum = 130
+		else:
+			self.Minimum = 30 + self.Range * 10
+			self.Maximum = 80 + self.Range * 10
+		flags = frame[1]
+		self.OverRange = (flags & 1) != 0
+		self.UnderRange = (flags & 2) != 0
+		self.Slow = (flags & 4) != 0
+		self.Weighting = 'A' if (flags & 8) != 0 else 'C'
+		self.MemoryFull = (flags & 0x10) != 0
+		self.MaxMode = (flags & 0x20) != 0
+		self.BatteryLow = (flags & 0x40) != 0
+		self.Value = frame[2] * 100 + frame[3] * 10 + frame[4] + frame[5] * 0.1
+
+		return self.Value
+
+	def GetValueString(self) -> str:
+		if self.Value < 0:
+			return 'N/A'
+		if self.OverRange:
+			return '> %.1f' % self.Value
+		if self.UnderRange:
+			return '< %.1f' % self.Value
+		return '%.1f' % self.Value
+
+	def __ReadingThread(self):
+		while not self.__stop_flag:
+			frame = self.ReadFrame(use_stop_flag=True)
+			if len(frame) != 18:
+				self.Value = MS6701.InvalidValue
+			else:
+				try:
+					self.ParseFrame(frame)
+				except Exception as _e:
+					import traceback
+					traceback.print_exc()
+					self.Value = MS6701.InvalidValue
```

## a2y_inst/mini_circuits.py

 * *Ordering differences only*

```diff
@@ -1,55 +1,55 @@
-import win32com.client
-
-
-class RUDAT:
-	def __init__(self):
-		self.__handle = win32com.client.Dispatch("mcl_RUDAT.USB_DAT")
-		assert self.__handle is not None
-
-	def connect(self, sn: str = ''):
-		"""
-		在执行读取、写入配置参数前，需要连接仪器。
-		:param sn: 要连接仪器的设备序列号。如果系统只连接着一个仪器，可以传入空字符串（不是None）。
-		:return: No return value. 如果连接失败，将抛出 IOError 异常。
-		"""
-		ret = self.__handle.Connect(sn)
-		if ret != 1:
-			raise IOError('Connect to RUDAT failed.')
-
-	def disconnect(self):
-		"""
-		断开与仪器的连接。
-		:return: No return value.
-		"""
-		self.__handle.Disconnect()
-
-	def get(self) -> float:
-		"""
-		读取衰减器的当前衰减配置值。如果读取失败，将抛出 IOError 异常。
-		:return: 当前配置值，浮点数。
-		"""
-		_value = 0.0
-		ret, value = self.__handle.Read_Att(_value)
-		if ret != 1:
-			raise IOError('get attenuate setting failed.')
-		return value
-
-	def set(self, value: float):
-		"""
-		设置衰减器的衰减值。
-		:param value: 目标设置值。
-		:return: 如果成功，无返回值；如果与仪器通信失败，抛出 IOError 异常；如果目标设置值超出可设置范围，抛出 ValueError 异常。
-		"""
-		ret, _value = self.__handle.SetAttenuation(value)
-		if ret == 2:
-			raise ValueError('attenuate value overflow.')
-		if ret != 1:
-			raise IOError('set attenuate value failed.')
-
-	@property
-	def native_handle(self):
-		"""
-		获取控制仪器的句柄。当封装的函数无法满足需要的时候，可以通过此句柄调用底层接口。
-		:return: 仪器控制句柄，一个 Windows COM 对象。
-		"""
-		return self.__handle
+import win32com.client
+
+
+class RUDAT:
+	def __init__(self):
+		self.__handle = win32com.client.Dispatch("mcl_RUDAT.USB_DAT")
+		assert self.__handle is not None
+
+	def connect(self, sn: str = ''):
+		"""
+		在执行读取、写入配置参数前，需要连接仪器。
+		:param sn: 要连接仪器的设备序列号。如果系统只连接着一个仪器，可以传入空字符串（不是None）。
+		:return: No return value. 如果连接失败，将抛出 IOError 异常。
+		"""
+		ret = self.__handle.Connect(sn)
+		if ret != 1:
+			raise IOError('Connect to RUDAT failed.')
+
+	def disconnect(self):
+		"""
+		断开与仪器的连接。
+		:return: No return value.
+		"""
+		self.__handle.Disconnect()
+
+	def get(self) -> float:
+		"""
+		读取衰减器的当前衰减配置值。如果读取失败，将抛出 IOError 异常。
+		:return: 当前配置值，浮点数。
+		"""
+		_value = 0.0
+		ret, value = self.__handle.Read_Att(_value)
+		if ret != 1:
+			raise IOError('get attenuate setting failed.')
+		return value
+
+	def set(self, value: float):
+		"""
+		设置衰减器的衰减值。
+		:param value: 目标设置值。
+		:return: 如果成功，无返回值；如果与仪器通信失败，抛出 IOError 异常；如果目标设置值超出可设置范围，抛出 ValueError 异常。
+		"""
+		ret, _value = self.__handle.SetAttenuation(value)
+		if ret == 2:
+			raise ValueError('attenuate value overflow.')
+		if ret != 1:
+			raise IOError('set attenuate value failed.')
+
+	@property
+	def native_handle(self):
+		"""
+		获取控制仪器的句柄。当封装的函数无法满足需要的时候，可以通过此句柄调用底层接口。
+		:return: 仪器控制句柄，一个 Windows COM 对象。
+		"""
+		return self.__handle
```

## a2y_inst/ni845x.py

 * *Ordering differences only*

```diff
@@ -1,223 +1,223 @@
-from ctypes import WinDLL as _WinDLL, c_char_p as _char_p, POINTER as _POINTER, pointer as _pointer
-from ctypes import c_ulong as _ulong, c_int as _int, c_char as _char, c_uint32 as _uint32, c_uint8 as _uint8
-from ctypes import c_int32 as _int32, c_uint16 as _uint16
-from ctypes import byref as _byref
-from typing import List as _List, Sequence as _Sequence
-
-
-_dll = _WinDLL('Ni845x.dll')
-
-_status_to_string = _dll.ni845xStatusToString
-_status_to_string.argstypes = [_int32, _uint32, _char_p]
-_status_to_string.restype = None
-
-
-def _descript_error_code(error_code: int) -> str:
-	buf = (_char * 256)()
-	_status_to_string(error_code, 255, buf)
-	return buf.value.decode('latin')
-
-
-class Ni845Exception(Exception):
-	def __init__(self, error_code: int):
-		self.__error_code = error_code
-		Exception.__init__(self, _descript_error_code(error_code))
-
-	@property
-	def error_code(self) -> int:
-		return self.__error_code
-
-
-def _err_checker(error_code: int):
-	if error_code != 0:
-		raise Ni845Exception(error_code)
-
-
-_Handle = _ulong
-_PHandle = _POINTER(_Handle)
-
-_find_device = _dll.ni845xFindDevice
-_find_device.argtypes = [_char_p, _POINTER(_ulong), _POINTER(_uint32)]
-_find_device.restype = _err_checker
-
-_open = _dll.ni845xOpen
-_open.argtypes = [_char_p, _PHandle]
-_open.restype = _err_checker
-
-_close = _dll.ni845xClose
-_close.argtypes = [_Handle]
-_close.restype = _err_checker
-
-_set_io_voltage_level = _dll.ni845xSetIoVoltageLevel
-_set_io_voltage_level.argtypes = [_Handle, _uint8]
-_set_io_voltage_level.restype = _err_checker
-
-_i2c_set_pullup_enable = _dll.ni845xI2cSetPullupEnable
-_i2c_set_pullup_enable.argtypes = [_Handle, _uint8]
-_i2c_set_pullup_enable.restype = _err_checker
-
-_i2c_configuration_open = _dll.ni845xI2cConfigurationOpen
-_i2c_configuration_open.argtypes = [_PHandle]
-_i2c_configuration_open.restype = _err_checker
-
-_i2c_configuration_close = _dll.ni845xI2cConfigurationClose
-_i2c_configuration_close.argtypes = [_Handle]
-_i2c_configuration_close.restype = _err_checker
-
-_i2c_configuration_get_address_size = _dll.ni845xI2cConfigurationGetAddressSize
-_i2c_configuration_get_address_size.argtypes = [_Handle, _POINTER(_int32)]
-_i2c_configuration_get_address_size.restype = _err_checker
-
-_i2c_configuration_set_address_size = _dll.ni845xI2cConfigurationSetAddressSize
-_i2c_configuration_set_address_size.argtypes = [_Handle, _int32]
-_i2c_configuration_set_address_size.restype = _err_checker
-
-_i2c_configuration_get_address = _dll.ni845xI2cConfigurationGetAddress
-_i2c_configuration_get_address.argtypes = [_Handle, _POINTER(_uint16)]
-_i2c_configuration_get_address.restype = _err_checker
-
-_i2c_configuration_set_address = _dll.ni845xI2cConfigurationSetAddress
-_i2c_configuration_set_address.argtypes = [_Handle, _uint16]
-_i2c_configuration_set_address.restype = _err_checker
-
-_i2c_configuration_get_clock_rate = _dll.ni845xI2cConfigurationGetClockRate
-_i2c_configuration_get_clock_rate.argtypes = [_Handle, _POINTER(_uint16)]
-_i2c_configuration_get_clock_rate.restype = _err_checker
-
-_i2c_configuration_set_clock_rate = _dll.ni845xI2cConfigurationSetClockRate
-_i2c_configuration_set_clock_rate.argtypes = [_Handle, _uint16]
-_i2c_configuration_set_clock_rate.restype = _err_checker
-
-_i2c_read = _dll.ni845xI2cRead
-_i2c_read.argtypes = [_Handle, _Handle, _uint32, _POINTER(_uint32), _POINTER(_uint8)]
-_i2c_read.restype = _err_checker
-
-_i2c_write = _dll.ni845xI2cWrite
-_i2c_write.argtypes = [_Handle, _Handle, _uint32, _POINTER(_uint8)]
-_i2c_write.restype = _err_checker
-
-_i2c_write_read = _dll.ni845xI2cWriteRead
-_i2c_write_read.argtypes = [_Handle, _Handle, _uint32, _POINTER(_uint8), _uint32, _POINTER(_uint32), _POINTER(_uint8)]
-_i2c_write_read.restype = _err_checker
-
-
-class I2CConfiguration:
-	def __init__(self):
-		self.__handle = _Handle()
-		_i2c_configuration_open(_byref(self.__handle))
-
-	@property
-	def handle(self):
-		return self.__handle
-
-	@property
-	def clock_rate(self) -> int:
-		value = _uint16()
-		_i2c_configuration_get_clock_rate(self.__handle, _byref(value))
-		return value.value
-
-	@clock_rate.setter
-	def clock_rate(self, rate: int):
-		_i2c_configuration_set_clock_rate(self.__handle, rate)
-
-	@property
-	def address_size(self) -> int:
-		value = _int32()
-		_i2c_configuration_get_address_size(self.__handle, _byref(value))
-		return value.value
-
-	@address_size.setter
-	def address_size(self, size: int):
-		_i2c_configuration_set_address_size(self.__handle, size)
-
-	@property
-	def address(self) -> int:
-		addr = _uint16()
-		_i2c_configuration_get_address(self.__handle, _byref(addr))
-		return addr.value
-
-	@address.setter
-	def address(self, addr: int):
-		_i2c_configuration_set_address(self.__handle, addr)
-
-	def close(self):
-		if self.__handle.value != 0:
-			_i2c_configuration_close(self.__handle)
-			self.__handle.value = 0
-
-	def __del__(self):
-		self.close()
-
-
-class NI845x:
-	def __init__(self, device_id: str):
-		self.__handle = _Handle()
-		_open(device_id.encode('latin'), _byref(self.__handle))
-		self.__i2c_configuration = I2CConfiguration()
-
-	@property
-	def i2c_configuration(self) -> I2CConfiguration:
-		return self.__i2c_configuration
-
-	def i2c_read(self, size: int = 1) -> _List[int]:
-		assert size > 0
-		buf = (_uint8 * size)()
-		size_read = _uint32()
-		_i2c_read(self.__handle, self.i2c_configuration.handle, size, _byref(size_read), buf)
-		return list(buf[:size_read.value])
-
-	def i2c_write(self, data: _Sequence):
-		size = len(data)
-		assert size > 0
-		buf = (_uint8 * size)()
-		for i in range(size):
-			buf[i] = data[i]
-		_i2c_write(self.__handle, self.i2c_configuration.handle, size, buf)
-
-	def i2c_write_read(self, data_to_write: _Sequence, size_to_read: int) -> _List[int]:
-		size_to_write = len(data_to_write)
-		assert size_to_write > 0 and size_to_read > 0
-		write_buf = (_uint8 * size_to_write)()
-		for i in range(size_to_write):
-			write_buf[i] = data_to_write[i]
-		size_read = _uint32()
-		read_buf = (_uint8 * size_to_read)()
-		_i2c_write_read(
-			self.__handle, self.i2c_configuration.handle,
-			size_to_write, write_buf,
-			size_to_read, _byref(size_read), read_buf
-		)
-		data = read_buf[:size_read.value]
-		return list(data)
-
-	def enable_i2c_pullup(self, enable: bool = True):
-		iv = 1 if enable else 0
-		value = _uint8(iv)
-		_i2c_set_pullup_enable(self.__handle, value)
-
-	def disable_i2c_pullup(self):
-		self.enable_i2c_pullup(False)
-
-	def set_io_voltage_level(self, voltage: int):
-		_set_io_voltage_level(self.__handle, voltage)
-
-	def close(self):
-		if self.__handle.value != 0:
-			self.i2c_configuration.close()
-			_close(self.__handle)
-			self.__handle.value = 0
-
-	def __del__(self):
-		self.close()
-
-
-def open_default_device() -> NI845x:
-	"""
-	打开系统中找到的第一个 NI845x 设备
-	:return: NI845x 设备对象
-	"""
-	name_buffer = (_char * 260)()
-	_find_device(name_buffer, None, None)
-	if len(name_buffer.value) == 0:
-		raise IOError('NI845x device not found.')
-	return NI845x(name_buffer.value.decode('latin'))
+from ctypes import WinDLL as _WinDLL, c_char_p as _char_p, POINTER as _POINTER, pointer as _pointer
+from ctypes import c_ulong as _ulong, c_int as _int, c_char as _char, c_uint32 as _uint32, c_uint8 as _uint8
+from ctypes import c_int32 as _int32, c_uint16 as _uint16
+from ctypes import byref as _byref
+from typing import List as _List, Sequence as _Sequence
+
+
+_dll = _WinDLL('Ni845x.dll')
+
+_status_to_string = _dll.ni845xStatusToString
+_status_to_string.argstypes = [_int32, _uint32, _char_p]
+_status_to_string.restype = None
+
+
+def _descript_error_code(error_code: int) -> str:
+	buf = (_char * 256)()
+	_status_to_string(error_code, 255, buf)
+	return buf.value.decode('latin')
+
+
+class Ni845Exception(Exception):
+	def __init__(self, error_code: int):
+		self.__error_code = error_code
+		Exception.__init__(self, _descript_error_code(error_code))
+
+	@property
+	def error_code(self) -> int:
+		return self.__error_code
+
+
+def _err_checker(error_code: int):
+	if error_code != 0:
+		raise Ni845Exception(error_code)
+
+
+_Handle = _ulong
+_PHandle = _POINTER(_Handle)
+
+_find_device = _dll.ni845xFindDevice
+_find_device.argtypes = [_char_p, _POINTER(_ulong), _POINTER(_uint32)]
+_find_device.restype = _err_checker
+
+_open = _dll.ni845xOpen
+_open.argtypes = [_char_p, _PHandle]
+_open.restype = _err_checker
+
+_close = _dll.ni845xClose
+_close.argtypes = [_Handle]
+_close.restype = _err_checker
+
+_set_io_voltage_level = _dll.ni845xSetIoVoltageLevel
+_set_io_voltage_level.argtypes = [_Handle, _uint8]
+_set_io_voltage_level.restype = _err_checker
+
+_i2c_set_pullup_enable = _dll.ni845xI2cSetPullupEnable
+_i2c_set_pullup_enable.argtypes = [_Handle, _uint8]
+_i2c_set_pullup_enable.restype = _err_checker
+
+_i2c_configuration_open = _dll.ni845xI2cConfigurationOpen
+_i2c_configuration_open.argtypes = [_PHandle]
+_i2c_configuration_open.restype = _err_checker
+
+_i2c_configuration_close = _dll.ni845xI2cConfigurationClose
+_i2c_configuration_close.argtypes = [_Handle]
+_i2c_configuration_close.restype = _err_checker
+
+_i2c_configuration_get_address_size = _dll.ni845xI2cConfigurationGetAddressSize
+_i2c_configuration_get_address_size.argtypes = [_Handle, _POINTER(_int32)]
+_i2c_configuration_get_address_size.restype = _err_checker
+
+_i2c_configuration_set_address_size = _dll.ni845xI2cConfigurationSetAddressSize
+_i2c_configuration_set_address_size.argtypes = [_Handle, _int32]
+_i2c_configuration_set_address_size.restype = _err_checker
+
+_i2c_configuration_get_address = _dll.ni845xI2cConfigurationGetAddress
+_i2c_configuration_get_address.argtypes = [_Handle, _POINTER(_uint16)]
+_i2c_configuration_get_address.restype = _err_checker
+
+_i2c_configuration_set_address = _dll.ni845xI2cConfigurationSetAddress
+_i2c_configuration_set_address.argtypes = [_Handle, _uint16]
+_i2c_configuration_set_address.restype = _err_checker
+
+_i2c_configuration_get_clock_rate = _dll.ni845xI2cConfigurationGetClockRate
+_i2c_configuration_get_clock_rate.argtypes = [_Handle, _POINTER(_uint16)]
+_i2c_configuration_get_clock_rate.restype = _err_checker
+
+_i2c_configuration_set_clock_rate = _dll.ni845xI2cConfigurationSetClockRate
+_i2c_configuration_set_clock_rate.argtypes = [_Handle, _uint16]
+_i2c_configuration_set_clock_rate.restype = _err_checker
+
+_i2c_read = _dll.ni845xI2cRead
+_i2c_read.argtypes = [_Handle, _Handle, _uint32, _POINTER(_uint32), _POINTER(_uint8)]
+_i2c_read.restype = _err_checker
+
+_i2c_write = _dll.ni845xI2cWrite
+_i2c_write.argtypes = [_Handle, _Handle, _uint32, _POINTER(_uint8)]
+_i2c_write.restype = _err_checker
+
+_i2c_write_read = _dll.ni845xI2cWriteRead
+_i2c_write_read.argtypes = [_Handle, _Handle, _uint32, _POINTER(_uint8), _uint32, _POINTER(_uint32), _POINTER(_uint8)]
+_i2c_write_read.restype = _err_checker
+
+
+class I2CConfiguration:
+	def __init__(self):
+		self.__handle = _Handle()
+		_i2c_configuration_open(_byref(self.__handle))
+
+	@property
+	def handle(self):
+		return self.__handle
+
+	@property
+	def clock_rate(self) -> int:
+		value = _uint16()
+		_i2c_configuration_get_clock_rate(self.__handle, _byref(value))
+		return value.value
+
+	@clock_rate.setter
+	def clock_rate(self, rate: int):
+		_i2c_configuration_set_clock_rate(self.__handle, rate)
+
+	@property
+	def address_size(self) -> int:
+		value = _int32()
+		_i2c_configuration_get_address_size(self.__handle, _byref(value))
+		return value.value
+
+	@address_size.setter
+	def address_size(self, size: int):
+		_i2c_configuration_set_address_size(self.__handle, size)
+
+	@property
+	def address(self) -> int:
+		addr = _uint16()
+		_i2c_configuration_get_address(self.__handle, _byref(addr))
+		return addr.value
+
+	@address.setter
+	def address(self, addr: int):
+		_i2c_configuration_set_address(self.__handle, addr)
+
+	def close(self):
+		if self.__handle.value != 0:
+			_i2c_configuration_close(self.__handle)
+			self.__handle.value = 0
+
+	def __del__(self):
+		self.close()
+
+
+class NI845x:
+	def __init__(self, device_id: str):
+		self.__handle = _Handle()
+		_open(device_id.encode('latin'), _byref(self.__handle))
+		self.__i2c_configuration = I2CConfiguration()
+
+	@property
+	def i2c_configuration(self) -> I2CConfiguration:
+		return self.__i2c_configuration
+
+	def i2c_read(self, size: int = 1) -> _List[int]:
+		assert size > 0
+		buf = (_uint8 * size)()
+		size_read = _uint32()
+		_i2c_read(self.__handle, self.i2c_configuration.handle, size, _byref(size_read), buf)
+		return list(buf[:size_read.value])
+
+	def i2c_write(self, data: _Sequence):
+		size = len(data)
+		assert size > 0
+		buf = (_uint8 * size)()
+		for i in range(size):
+			buf[i] = data[i]
+		_i2c_write(self.__handle, self.i2c_configuration.handle, size, buf)
+
+	def i2c_write_read(self, data_to_write: _Sequence, size_to_read: int) -> _List[int]:
+		size_to_write = len(data_to_write)
+		assert size_to_write > 0 and size_to_read > 0
+		write_buf = (_uint8 * size_to_write)()
+		for i in range(size_to_write):
+			write_buf[i] = data_to_write[i]
+		size_read = _uint32()
+		read_buf = (_uint8 * size_to_read)()
+		_i2c_write_read(
+			self.__handle, self.i2c_configuration.handle,
+			size_to_write, write_buf,
+			size_to_read, _byref(size_read), read_buf
+		)
+		data = read_buf[:size_read.value]
+		return list(data)
+
+	def enable_i2c_pullup(self, enable: bool = True):
+		iv = 1 if enable else 0
+		value = _uint8(iv)
+		_i2c_set_pullup_enable(self.__handle, value)
+
+	def disable_i2c_pullup(self):
+		self.enable_i2c_pullup(False)
+
+	def set_io_voltage_level(self, voltage: int):
+		_set_io_voltage_level(self.__handle, voltage)
+
+	def close(self):
+		if self.__handle.value != 0:
+			self.i2c_configuration.close()
+			_close(self.__handle)
+			self.__handle.value = 0
+
+	def __del__(self):
+		self.close()
+
+
+def open_default_device() -> NI845x:
+	"""
+	打开系统中找到的第一个 NI845x 设备
+	:return: NI845x 设备对象
+	"""
+	name_buffer = (_char * 260)()
+	_find_device(name_buffer, None, None)
+	if len(name_buffer.value) == 0:
+		raise IOError('NI845x device not found.')
+	return NI845x(name_buffer.value.decode('latin'))
```

## a2y_inst/shengpu.py

 * *Ordering differences only*

```diff
@@ -1,59 +1,59 @@
-from serial import Serial as _Serial
-from time import sleep
-
-
-class SP312B(_Serial):
-	"""
-	盛普科技SP312B型等精度通用计数器相位计
-	"""
-
-	def __init__(self, port, continuous=False, timeout=None, baudrate=9600):
-		self.continuous = continuous
-		if timeout is None:
-			timeout = 0.3 if continuous else 1
-		_Serial.__init__(self, port, baudrate=baudrate, timeout=timeout)
-
-	@staticmethod
-	def parse_value(fb):
-		unit_index = 0
-		unit_char = ''
-		unit_coe = 1
-		for c in fb:
-			if c not in '0123456789.':
-				unit_char = c
-				break
-			unit_index += 1
-		if unit_char == 'k' or unit_char == 'K':
-			unit_coe = 1000
-		elif unit_char == 'm':
-			unit_coe = 0.001
-		elif unit_char == 'M':
-			unit_coe = 1000000
-
-		try:
-			return float(fb[:unit_index]) * unit_coe
-		except Exception as e:
-			raise ValueError('Error: Inappropriate value format from SP312B')
-
-	def measure(self):
-		self.flushInput()
-		if self.continuous:
-			sleep(0.05)
-			if self.in_waiting > 0:
-				self.readline()
-			fb = self.readline()
-			if fb == '':
-				fb = '0.0'
-		else:
-			self.write(b':MEAS?\n')
-			fb = self.readline().decode('utf8')
-			if fb == '':
-				fb = '0.0'
-			elif len(fb) < 2:
-				raise IOError('Error: SP312B Communication Fail')
-		return SP312B.parse_value(fb)
-
-	def set_to_frequency(self):
-		self.write(b'SYST:KEY 1\n')
-		if self.continuous:
-			self.write(b':init:cont on\n')
+from serial import Serial as _Serial
+from time import sleep
+
+
+class SP312B(_Serial):
+	"""
+	盛普科技SP312B型等精度通用计数器相位计
+	"""
+
+	def __init__(self, port, continuous=False, timeout=None, baudrate=9600):
+		self.continuous = continuous
+		if timeout is None:
+			timeout = 0.3 if continuous else 1
+		_Serial.__init__(self, port, baudrate=baudrate, timeout=timeout)
+
+	@staticmethod
+	def parse_value(fb):
+		unit_index = 0
+		unit_char = ''
+		unit_coe = 1
+		for c in fb:
+			if c not in '0123456789.':
+				unit_char = c
+				break
+			unit_index += 1
+		if unit_char == 'k' or unit_char == 'K':
+			unit_coe = 1000
+		elif unit_char == 'm':
+			unit_coe = 0.001
+		elif unit_char == 'M':
+			unit_coe = 1000000
+
+		try:
+			return float(fb[:unit_index]) * unit_coe
+		except Exception as e:
+			raise ValueError('Error: Inappropriate value format from SP312B')
+
+	def measure(self):
+		self.flushInput()
+		if self.continuous:
+			sleep(0.05)
+			if self.in_waiting > 0:
+				self.readline()
+			fb = self.readline()
+			if fb == '':
+				fb = '0.0'
+		else:
+			self.write(b':MEAS?\n')
+			fb = self.readline().decode('utf8')
+			if fb == '':
+				fb = '0.0'
+			elif len(fb) < 2:
+				raise IOError('Error: SP312B Communication Fail')
+		return SP312B.parse_value(fb)
+
+	def set_to_frequency(self):
+		self.write(b'SYST:KEY 1\n')
+		if self.continuous:
+			self.write(b':init:cont on\n')
```

## a2y_inst/tes.py

 * *Ordering differences only*

```diff
@@ -1,153 +1,153 @@
-from serial import Serial as _Serial
-from time import sleep
-
-
-class TES1336A(_Serial):
-	def __init__(self, port):
-		_Serial.__init__(self, port, baudrate=9600)
-		self.timeout = 0.5
-
-	def read_data_frame(self) -> bytes:
-		c = self.read()
-		while c != b'':
-			if c == b'\x02':
-				break
-			c = self.read()
-		fb = c
-		if fb == b'':
-			return fb
-		c = self.read()
-		while c != b'':
-			fb += c
-			if c == b'\x03' and len(fb) == 5:
-				break
-			c = self.read()
-		if c != b'\x03':
-			raise IOError('TES1336A IO Error')
-
-		if len(fb) != 5:
-			raise IOError('Invalid feedback format from TES1336A')
-
-		return fb
-
-	def send_read_data_command(self):
-		sleep(0.05)
-		self.flushInput()
-		self.write(b' ')
-		sleep(0.25)
-		self.write(b' ')
-
-	def shift_range(self):
-		sleep(0.05)
-		self.write(b' ')
-		sleep(0.2)
-		self.write(b'F')
-		sleep(0.2)
-		self.write(b'\x10')
-
-		sleep(3)
-
-	def set_unit_lux(self):
-		sleep(0.05)
-		self.write(b' ')
-		sleep(0.2)
-		self.write(b'F')
-		sleep(0.2)
-		self.write(b'\x00')
-
-	def try_read_data(self) -> bytes:
-		self.send_read_data_command()
-		return self.read_data_frame()
-
-	def read_data(self, try_count: int = 3) -> bytes:
-		fb = b''
-		i = 0
-		while i != try_count:
-			try:
-				fb = self.try_read_data()
-				if len(fb) == 5:
-					break
-			except Exception as _e:
-				pass
-			i += 1
-
-		if i == try_count:
-			raise IOError('Read data from TES1336A timeout')
-
-		return fb
-
-	@staticmethod
-	def parse_range(fb: bytes) -> int:
-		rg = ((fb[1] >> 4) & 0x3)
-		return [20, 200, 2000, 20000][rg]
-
-	@staticmethod
-	def parse_unit(fb: bytes):
-		return (fb[1] >> 3) & 0x1
-
-	@staticmethod
-	def is_battery_low(fb: bytes):
-		return (fb[1] & 1) != 0
-
-	@staticmethod
-	def is_hold(fb: bytes):
-		return ((fb[1] >> 2) & 1) != 0
-
-	@staticmethod
-	def out_of_range(fb: bytes):
-		return fb[3] == 0xFF
-
-	@staticmethod
-	def parse_value(fb: bytes):
-		if TES1336A.out_of_range(fb):
-			return -1
-		rg = TES1336A.parse_range(fb)
-		bcd = ((fb[2] & 0x1F) << 8) + fb[3]
-		value = 0
-		for i in range(4):
-			value += ((bcd >> (4*i)) & 0xF) * (10**i)
-
-		if rg == 20:
-			value /= 100.0
-		elif rg == 200:
-			value /= 10.0
-		elif rg == 20000:
-			value *= 10.0
-
-		return value
-
-	@staticmethod
-	def under_range(fb: bytes):
-		rg = TES1336A.parse_range(fb)
-		value = TES1336A.parse_value(fb)
-		if value < 0 or rg == 20:
-			return False
-		return (rg * 1.0 / value) >= 20
-
-	@staticmethod
-	def absolute_out_of_range(fb: bytes):
-		rg = TES1336A.parse_range(fb)
-		return TES1336A.out_of_range(fb) and rg == 20000
-
-	@staticmethod
-	def is_best_range(fb: bytes):
-		return (not TES1336A.out_of_range(fb)) and (not TES1336A.under_range(fb))
-
-	def set_best_range(self, fb: bytes):
-		i = 0
-		while (not TES1336A.is_best_range(fb)) and (i != 9):
-			if TES1336A.absolute_out_of_range(fb):
-				raise OverflowError('TES1336A value too large to be represented')
-			self.shift_range()
-			fb = self.read_data()
-			i += 1
-
-		if not TES1336A.is_best_range(fb):
-			raise IOError('Fail to set TES1336A range')
-
-		return fb
-
-	def read_value(self):
-		fb = self.read_data()
-		fb = self.set_best_range(fb)
-		return TES1336A.parse_value(fb)
+from serial import Serial as _Serial
+from time import sleep
+
+
+class TES1336A(_Serial):
+	def __init__(self, port):
+		_Serial.__init__(self, port, baudrate=9600)
+		self.timeout = 0.5
+
+	def read_data_frame(self) -> bytes:
+		c = self.read()
+		while c != b'':
+			if c == b'\x02':
+				break
+			c = self.read()
+		fb = c
+		if fb == b'':
+			return fb
+		c = self.read()
+		while c != b'':
+			fb += c
+			if c == b'\x03' and len(fb) == 5:
+				break
+			c = self.read()
+		if c != b'\x03':
+			raise IOError('TES1336A IO Error')
+
+		if len(fb) != 5:
+			raise IOError('Invalid feedback format from TES1336A')
+
+		return fb
+
+	def send_read_data_command(self):
+		sleep(0.05)
+		self.flushInput()
+		self.write(b' ')
+		sleep(0.25)
+		self.write(b' ')
+
+	def shift_range(self):
+		sleep(0.05)
+		self.write(b' ')
+		sleep(0.2)
+		self.write(b'F')
+		sleep(0.2)
+		self.write(b'\x10')
+
+		sleep(3)
+
+	def set_unit_lux(self):
+		sleep(0.05)
+		self.write(b' ')
+		sleep(0.2)
+		self.write(b'F')
+		sleep(0.2)
+		self.write(b'\x00')
+
+	def try_read_data(self) -> bytes:
+		self.send_read_data_command()
+		return self.read_data_frame()
+
+	def read_data(self, try_count: int = 3) -> bytes:
+		fb = b''
+		i = 0
+		while i != try_count:
+			try:
+				fb = self.try_read_data()
+				if len(fb) == 5:
+					break
+			except Exception as _e:
+				pass
+			i += 1
+
+		if i == try_count:
+			raise IOError('Read data from TES1336A timeout')
+
+		return fb
+
+	@staticmethod
+	def parse_range(fb: bytes) -> int:
+		rg = ((fb[1] >> 4) & 0x3)
+		return [20, 200, 2000, 20000][rg]
+
+	@staticmethod
+	def parse_unit(fb: bytes):
+		return (fb[1] >> 3) & 0x1
+
+	@staticmethod
+	def is_battery_low(fb: bytes):
+		return (fb[1] & 1) != 0
+
+	@staticmethod
+	def is_hold(fb: bytes):
+		return ((fb[1] >> 2) & 1) != 0
+
+	@staticmethod
+	def out_of_range(fb: bytes):
+		return fb[3] == 0xFF
+
+	@staticmethod
+	def parse_value(fb: bytes):
+		if TES1336A.out_of_range(fb):
+			return -1
+		rg = TES1336A.parse_range(fb)
+		bcd = ((fb[2] & 0x1F) << 8) + fb[3]
+		value = 0
+		for i in range(4):
+			value += ((bcd >> (4*i)) & 0xF) * (10**i)
+
+		if rg == 20:
+			value /= 100.0
+		elif rg == 200:
+			value /= 10.0
+		elif rg == 20000:
+			value *= 10.0
+
+		return value
+
+	@staticmethod
+	def under_range(fb: bytes):
+		rg = TES1336A.parse_range(fb)
+		value = TES1336A.parse_value(fb)
+		if value < 0 or rg == 20:
+			return False
+		return (rg * 1.0 / value) >= 20
+
+	@staticmethod
+	def absolute_out_of_range(fb: bytes):
+		rg = TES1336A.parse_range(fb)
+		return TES1336A.out_of_range(fb) and rg == 20000
+
+	@staticmethod
+	def is_best_range(fb: bytes):
+		return (not TES1336A.out_of_range(fb)) and (not TES1336A.under_range(fb))
+
+	def set_best_range(self, fb: bytes):
+		i = 0
+		while (not TES1336A.is_best_range(fb)) and (i != 9):
+			if TES1336A.absolute_out_of_range(fb):
+				raise OverflowError('TES1336A value too large to be represented')
+			self.shift_range()
+			fb = self.read_data()
+			i += 1
+
+		if not TES1336A.is_best_range(fb):
+			raise IOError('Fail to set TES1336A range')
+
+		return fb
+
+	def read_value(self):
+		fb = self.read_data()
+		fb = self.set_best_range(fb)
+		return TES1336A.parse_value(fb)
```

## a2y_inst/victor.py

 * *Ordering differences only*

```diff
@@ -1,179 +1,179 @@
-from serial import Serial as _Serial
-from threading import Lock as _Lock
-from time import sleep as _sleep
-from enum import Enum as _Enum
-from typing import Tuple as _Tuple
-
-
-class Function(_Enum):
-	DCV = '0'
-	ACV = '1'
-	DCI = '2'
-	ACI = '3'
-	OHM_2W = '4'
-	OHM_4W = '5'
-	CONT = '6'
-	DIODE = '7'
-	FREQ = '8'
-	DUTY = '8'
-	CAP = '9'
-	TEMP = '\x3A'
-	RTD = '\x3B'
-	dBm = '\x3C'
-
-
-class Range(_Enum):
-	DCV_50mV = '0'
-	DCV_500mV = '1'
-	DCV_5V = '2'
-	DCV_50V = '3'
-	DCV_500V = '4'
-	DCV_1000V = '5'
-
-	DCI_500uA = '0'
-	DCI_5000uA = '1'
-	DCI_50mA = '2'
-	DCI_500mA = '3'
-	DCI_5A = '4'
-	DCI_10A = '5'
-
-	# TODO: 补充完善其他的量程值
-
-
-class Speed(_Enum):
-	Slow = '0'
-	Fast = '1'
-
-
-class VC8246:
-	# 如果你想用 USB 虚拟串口，需要先在仪器上修改一下设置。设置方法：
-	# 按一下“Utility”键，这时屏幕上显示“rS232”，表示当前通信接口是 DB9 的 RS232 接口。
-	# 按一下向下的小三角方向键，屏幕上显示 USB。按一下“AUTO”按键，保存。设置完成，可以断电重启仪器。
-	Head = '#*'
-	Tail = '\r\n'
-
-	def __init__(self, port: str, baudrate: int = 9600, timeout: float = 1):
-		"""
-		在使用频率测试功能时，根据仪器文档，最好把 timeout 参数设置为比 3 稍大的值。
-		"""
-		self.__serial = _Serial(port, baudrate=baudrate, timeout=timeout)
-		self.__lock = _Lock()
-
-	def close(self):
-		self.__serial.close()
-
-	def open(self):
-		self.__serial.open()
-
-	@property
-	def timeout(self) -> float:
-		return self.__serial.timeout
-
-	@timeout.setter
-	def timeout(self, value: float):
-		self.__serial.timeout = value
-
-	@property
-	def is_open(self) -> bool:
-		return self.__serial.is_open
-
-	@staticmethod
-	def construct_data_frame(data: str) -> str:
-		frame = f'{VC8246.Head}{data}{VC8246.Tail}'
-		return frame
-
-	def send_command(self, command: str):
-		"""
-		根据通信协议，把指令 command 包装成一个完整的数据帧，然后发送给仪器。
-		通信时没有加锁，不能用在多线程环境。也不接收数据，调用者应当随后调用 recv_feedback 来收取仪器的响应数据。
-		设计上调用者不应当直接使用此函数。
-		"""
-		frame = VC8246.construct_data_frame(command)
-		data = frame.encode('latin')
-		self.__serial.write(data)
-
-	def recv_feedback(self) -> str:
-		"""
-		收取仪器返回的响应数据。根据通信协议，做最基本的解析，从数据帧中抽取出有用的数据，返回给调用者。
-		通信时没有加锁，不能用在多线程环境。
-		设计上调用者不应当直接使用此函数。
-		"""
-		raw_data = self.__serial.readline()
-		data = raw_data.decode('latin')
-		if data == '':
-			raise TimeoutError('Receive from VC8246 timeout')
-		if not data.startswith(VC8246.Head):
-			raise IOError(f'Data received from VC8246 format invalid: "{data}"')
-		if not data.endswith(VC8246.Tail):
-			raise IOError(f'Data received from VC8246 format invalid: "{data}"')
-		feedback = data[2:-2]
-		return feedback
-
-	def query(self, command: str) -> str:
-		with self.__lock:
-			self.__serial.flushInput()
-			self.send_command(command)
-			feedback = self.recv_feedback()
-		return feedback
-
-	def query_ack(self, command: str):
-		feedback = self.query(command)
-		if feedback == '\x15\x00':
-			raise IOError(f'NAK from VC8246')
-		if feedback != '\x06\x00':
-			raise IOError(f'Feedback of command "{command}" from VC8246 invalid: "{feedback}"')
-
-	def reset(self):
-		"""
-		复位仪器。之后，想再次远程控制仪器，需要先调用 connect 函数。
-		"""
-		self.query_ack('RST')
-
-	def connect(self, timeout: float = 2):
-		"""
-		发送“ONL”指令，使得仪器进入远程控制状态。
-		麻烦的是，如果仪器在收到此指令前已经处于远程控制状态时，它将不响应。我们无法知道是通信出了问题？还是原本就处于远控状态？
-		为此，我们如果超时没有收到响应，就先发一个“RST”指令，复位仪器，然后再发送一次“ONL”指令。
-		据观测，仪器复位大概需要 2 秒，这就是 timeout 参数的默认值的来源。
-		"""
-		try:
-			self.query_ack('ONL')
-		except TimeoutError:
-			self.reset()
-			_sleep(timeout)
-			self.query_ack('ONL')
-
-	def config(self, function: Function, measuring_range: Range, speed: Speed = Speed.Fast):
-		"""
-		配置仪器的测量功能、量程，以及速率。
-		测量功能、量程，以及速率存在一定的对应关系。这个函数里面没有执行任何的检查。没有做过无效实验。
-		请调用者自行保证使用对应功能有效的量程和速率。
-		"""
-		command = f'INS{function.value}{measuring_range.value}{speed.value}'
-		self.query_ack(command)
-
-	def fetch(self) -> _Tuple[float, float]:
-		"""
-		读取仪器当前读数。
-		目前对返回数据的格式检查比较严格，对不同型号的仪器可能会不兼容。这需要开发者在出现问题时补充修正。
-		返回值包括两项数据，第 0 项是测量值，第 1 项意义不明。待到明白时再做说明。
-		频率测试跟占空比测试的功能码是一样的（8），那么，这两项数据是否一项是频率值，另一项是占空比值？有待验证。
-		TODO: 如上所述
-		"""
-		feedback = self.query('RD?')
-		if not feedback.startswith('RD'):
-			raise IOError(f'Feedback of command "RD?" from VC8246 invalid: "{feedback}"')
-		if len(feedback) != 2+7+7:
-			raise IOError(f'Feedback of command "RD?" from VC8246 is unsupported: "{feedback}"')
-
-		value_str = feedback[2:9]
-		temp_str = feedback[9:-1]
-		try:
-			if value_str == '+FFFFFF':  # 超出量程
-				value = float('inf')
-			else:
-				value = float(value_str)
-			temp = float(temp_str)
-		except ValueError:
-			raise IOError(f'Value feedback from VC8246 is invalid: "{feedback}"')
-		return value, temp
+from serial import Serial as _Serial
+from threading import Lock as _Lock
+from time import sleep as _sleep
+from enum import Enum as _Enum
+from typing import Tuple as _Tuple
+
+
+class Function(_Enum):
+	DCV = '0'
+	ACV = '1'
+	DCI = '2'
+	ACI = '3'
+	OHM_2W = '4'
+	OHM_4W = '5'
+	CONT = '6'
+	DIODE = '7'
+	FREQ = '8'
+	DUTY = '8'
+	CAP = '9'
+	TEMP = '\x3A'
+	RTD = '\x3B'
+	dBm = '\x3C'
+
+
+class Range(_Enum):
+	DCV_50mV = '0'
+	DCV_500mV = '1'
+	DCV_5V = '2'
+	DCV_50V = '3'
+	DCV_500V = '4'
+	DCV_1000V = '5'
+
+	DCI_500uA = '0'
+	DCI_5000uA = '1'
+	DCI_50mA = '2'
+	DCI_500mA = '3'
+	DCI_5A = '4'
+	DCI_10A = '5'
+
+	# TODO: 补充完善其他的量程值
+
+
+class Speed(_Enum):
+	Slow = '0'
+	Fast = '1'
+
+
+class VC8246:
+	# 如果你想用 USB 虚拟串口，需要先在仪器上修改一下设置。设置方法：
+	# 按一下“Utility”键，这时屏幕上显示“rS232”，表示当前通信接口是 DB9 的 RS232 接口。
+	# 按一下向下的小三角方向键，屏幕上显示 USB。按一下“AUTO”按键，保存。设置完成，可以断电重启仪器。
+	Head = '#*'
+	Tail = '\r\n'
+
+	def __init__(self, port: str, baudrate: int = 9600, timeout: float = 1):
+		"""
+		在使用频率测试功能时，根据仪器文档，最好把 timeout 参数设置为比 3 稍大的值。
+		"""
+		self.__serial = _Serial(port, baudrate=baudrate, timeout=timeout)
+		self.__lock = _Lock()
+
+	def close(self):
+		self.__serial.close()
+
+	def open(self):
+		self.__serial.open()
+
+	@property
+	def timeout(self) -> float:
+		return self.__serial.timeout
+
+	@timeout.setter
+	def timeout(self, value: float):
+		self.__serial.timeout = value
+
+	@property
+	def is_open(self) -> bool:
+		return self.__serial.is_open
+
+	@staticmethod
+	def construct_data_frame(data: str) -> str:
+		frame = f'{VC8246.Head}{data}{VC8246.Tail}'
+		return frame
+
+	def send_command(self, command: str):
+		"""
+		根据通信协议，把指令 command 包装成一个完整的数据帧，然后发送给仪器。
+		通信时没有加锁，不能用在多线程环境。也不接收数据，调用者应当随后调用 recv_feedback 来收取仪器的响应数据。
+		设计上调用者不应当直接使用此函数。
+		"""
+		frame = VC8246.construct_data_frame(command)
+		data = frame.encode('latin')
+		self.__serial.write(data)
+
+	def recv_feedback(self) -> str:
+		"""
+		收取仪器返回的响应数据。根据通信协议，做最基本的解析，从数据帧中抽取出有用的数据，返回给调用者。
+		通信时没有加锁，不能用在多线程环境。
+		设计上调用者不应当直接使用此函数。
+		"""
+		raw_data = self.__serial.readline()
+		data = raw_data.decode('latin')
+		if data == '':
+			raise TimeoutError('Receive from VC8246 timeout')
+		if not data.startswith(VC8246.Head):
+			raise IOError(f'Data received from VC8246 format invalid: "{data}"')
+		if not data.endswith(VC8246.Tail):
+			raise IOError(f'Data received from VC8246 format invalid: "{data}"')
+		feedback = data[2:-2]
+		return feedback
+
+	def query(self, command: str) -> str:
+		with self.__lock:
+			self.__serial.flushInput()
+			self.send_command(command)
+			feedback = self.recv_feedback()
+		return feedback
+
+	def query_ack(self, command: str):
+		feedback = self.query(command)
+		if feedback == '\x15\x00':
+			raise IOError(f'NAK from VC8246')
+		if feedback != '\x06\x00':
+			raise IOError(f'Feedback of command "{command}" from VC8246 invalid: "{feedback}"')
+
+	def reset(self):
+		"""
+		复位仪器。之后，想再次远程控制仪器，需要先调用 connect 函数。
+		"""
+		self.query_ack('RST')
+
+	def connect(self, timeout: float = 2):
+		"""
+		发送“ONL”指令，使得仪器进入远程控制状态。
+		麻烦的是，如果仪器在收到此指令前已经处于远程控制状态时，它将不响应。我们无法知道是通信出了问题？还是原本就处于远控状态？
+		为此，我们如果超时没有收到响应，就先发一个“RST”指令，复位仪器，然后再发送一次“ONL”指令。
+		据观测，仪器复位大概需要 2 秒，这就是 timeout 参数的默认值的来源。
+		"""
+		try:
+			self.query_ack('ONL')
+		except TimeoutError:
+			self.reset()
+			_sleep(timeout)
+			self.query_ack('ONL')
+
+	def config(self, function: Function, measuring_range: Range, speed: Speed = Speed.Fast):
+		"""
+		配置仪器的测量功能、量程，以及速率。
+		测量功能、量程，以及速率存在一定的对应关系。这个函数里面没有执行任何的检查。没有做过无效实验。
+		请调用者自行保证使用对应功能有效的量程和速率。
+		"""
+		command = f'INS{function.value}{measuring_range.value}{speed.value}'
+		self.query_ack(command)
+
+	def fetch(self) -> _Tuple[float, float]:
+		"""
+		读取仪器当前读数。
+		目前对返回数据的格式检查比较严格，对不同型号的仪器可能会不兼容。这需要开发者在出现问题时补充修正。
+		返回值包括两项数据，第 0 项是测量值，第 1 项意义不明。待到明白时再做说明。
+		频率测试跟占空比测试的功能码是一样的（8），那么，这两项数据是否一项是频率值，另一项是占空比值？有待验证。
+		TODO: 如上所述
+		"""
+		feedback = self.query('RD?')
+		if not feedback.startswith('RD'):
+			raise IOError(f'Feedback of command "RD?" from VC8246 invalid: "{feedback}"')
+		if len(feedback) != 2+7+7:
+			raise IOError(f'Feedback of command "RD?" from VC8246 is unsupported: "{feedback}"')
+
+		value_str = feedback[2:9]
+		temp_str = feedback[9:-1]
+		try:
+			if value_str == '+FFFFFF':  # 超出量程
+				value = float('inf')
+			else:
+				value = float(value_str)
+			temp = float(temp_str)
+		except ValueError:
+			raise IOError(f'Value feedback from VC8246 is invalid: "{feedback}"')
+		return value, temp
```

## a2y_inst/xinje.py

 * *Ordering differences only*

```diff
@@ -1,188 +1,188 @@
-from a2y_modbus import Master as _Modbus, ModbusTCPMaster as _ModbusTCPMaster
-import struct
-from threading import Lock as _Lock
-from typing import List as _List
-
-
-class XCPlc:
-	def __init__(self, port: str, baudrate: int = 115200, timeout: float = 0.3):
-		self.__modbus = _Modbus(port, baudrate=baudrate, timeout=timeout)
-		self.__lock = _Lock()
-
-	def __enter__(self):
-		return self
-
-	def __exit__(self, exc_type, exc_val, exc_tb):
-		self.__modbus.close()
-
-	def set_coil(self, station: int, name: str, value: bool):
-		coil_type = name[0]
-		if coil_type == 'Y':
-			start_address = 0x4800
-		elif coil_type == 'X':
-			raise TypeError(f'Writing readonly coil: "{name}".')
-		else:
-			raise TypeError(f'Coil type "{coil_type}" is not supported yet.')
-		shift = int(name[1:], 8)
-		with self.__lock:
-			self.__modbus.write_coil(station=station, address=start_address + shift, value=value)
-
-	def get_coils(self, station: int, name: str, count: int) -> _List[bool]:
-		assert 0 < count <= 16
-		coil_type = name[0]
-		if coil_type == 'X':
-			start_address = 0x4000
-		elif coil_type == 'Y':
-			start_address = 0x4800
-		else:
-			raise TypeError(f'Coil type "{coil_type}" is not supported yet.')
-		shift = int(name[1:], 8)
-		with self.__lock:
-			values = self.__modbus.read_coils(station=station, address=start_address + shift, count=count)
-		return values
-
-	def get_coil(self, station: int, name: str) -> bool:
-		return self.get_coils(station, name, 1)[0]
-
-	@staticmethod
-	def register_name_to_address(name: str) -> int:
-		num_start_idx = -1
-		for idx, char in enumerate(name):
-			if str.isdigit(char):
-				num_start_idx = idx
-				break
-		assert num_start_idx > 0
-		register_type = name[:num_start_idx]
-		if register_type != 'D':
-			raise TypeError(f'Register type "{register_type}" is not supported yet.')
-		address = int(name[num_start_idx:])
-		return address
-
-	def set_uint16(self, station: int, name: str, value: int):
-		address = XCPlc.register_name_to_address(name)
-		with self.__lock:
-			self.__modbus.write_uint16(station, address, value)
-
-	def get_uint16(self, station: int, name: str) -> int:
-		address = XCPlc.register_name_to_address(name)
-		with self.__lock:
-			return self.__modbus.read_register(station, address)
-
-	def get_multi_uint16(self, station: int, name: str, count: int) -> _List[int]:
-		address = XCPlc.register_name_to_address(name)
-		with self.__lock:
-			return self.__modbus.read_registers(station, address, count)
-
-
-class XD5E:
-	def __init__(self, host: str, port: int = 502, station: int = 1, timeout: float = 0.5):
-		self.__modbus = _ModbusTCPMaster(host=host, port=port, station=station, timeout=timeout)
-
-	def close(self):
-		self.__modbus.close()
-
-	def __enter__(self):
-		return self
-
-	def __exit__(self, exc_type, exc_val, exc_tb):
-		self.close()
-
-	@property
-	def station(self):
-		return self.__modbus.station
-
-	@station.setter
-	def station(self, value: int):
-		self.__modbus.station = value
-
-	@staticmethod
-	def register_name_to_address(name: str) -> int:
-		upper = name.upper()
-		if upper.startswith('D'):
-			address = int(upper[1:])
-			assert 0 <= address < 20480, f'D register out of range [0, 20480)'
-		elif upper.startswith('HD'):
-			address = int(upper[2:])
-			assert 0 <= address < 6144, f'HD register out of range [0, 6144)'
-			address += 0xA080
-		else:
-			raise ValueError(f'Register type {upper} not supported yet')
-
-		return address
-
-	def get_uint16(self, name: str):
-		address = XD5E.register_name_to_address(name)
-		return self.__modbus.read_register(address)
-
-	def get_int16(self, name: str):
-		u_value = self.get_uint16(name)
-		package = struct.pack('H', u_value)
-		return struct.unpack('h', package)[0]
-
-	def set_uint16(self, name: str, value: int):
-		address = XD5E.register_name_to_address(name)
-		self.__modbus.write_registers(address, [value])
-
-	def set_int16(self, name: str, value: int):
-		package = struct.pack('h', value)
-		u_value = struct.unpack('H', package)[0]
-		self.set_uint16(name, u_value)
-
-	def get_multi_uint16(self, name: str, count: int):
-		address = XD5E.register_name_to_address(name)
-		return self.__modbus.read_registers(address, count)
-
-	def get_multi_int16(self, name: str, count: int):
-		u_values = self.get_multi_uint16(name, count)
-		values = list()
-		for u_value in u_values:
-			package = struct.pack('H', u_value)
-			value = struct.unpack('h', package)[0]
-			values.append(value)
-		return values
-
-	def set_multi_uint16(self, name: str, values: _List[int]):
-		address = XD5E.register_name_to_address(name)
-		self.__modbus.write_registers(address, values)
-
-	def set_multi_int16(self, name: str, values: _List[int]):
-		u_values = list()
-		for value in values:
-			package = struct.pack('h', value)
-			u_value = struct.unpack('H', package)[0]
-			u_values.append(u_value)
-		self.set_multi_uint16(name, u_values)
-
-	def set_string(self, value: str, name: str, register_count: int, encoding: str = 'latin'):
-		data = value.encode(encoding=encoding)
-		max_len = register_count * 2
-		items = list(data[:max_len])
-		register_values = []
-		if len(items) % 2 != 0:
-			items.append(0)
-
-		for i in range(0, len(items), 2):
-			register = (items[i+1] << 8) | items[i]
-			register_values.append(register)
-
-		register_values.extend([0] * (register_count - len(register_values)))
-		self.set_multi_uint16(name, register_values)
-
-	def get_string(self, name: str, register_count: int, encoding: str = 'latin'):
-		register_values = self.get_multi_uint16(name, register_count)
-		items = []
-		for register in register_values:
-			back, front = ((register >> 8) & 0xFF), (register & 0xFF)
-			if front == 0:
-				break
-			items.append(front)
-			if back != 0:
-				items.append(back)
-		b_str = bytes(items)
-		string = b_str.decode(encoding=encoding)
-		return string
-
-
-XDME = XD5E
-XL5E = XD5E
-XLME = XD5E
+from a2y_modbus import Master as _Modbus, ModbusTCPMaster as _ModbusTCPMaster
+import struct
+from threading import Lock as _Lock
+from typing import List as _List
+
+
+class XCPlc:
+	def __init__(self, port: str, baudrate: int = 115200, timeout: float = 0.3):
+		self.__modbus = _Modbus(port, baudrate=baudrate, timeout=timeout)
+		self.__lock = _Lock()
+
+	def __enter__(self):
+		return self
+
+	def __exit__(self, exc_type, exc_val, exc_tb):
+		self.__modbus.close()
+
+	def set_coil(self, station: int, name: str, value: bool):
+		coil_type = name[0]
+		if coil_type == 'Y':
+			start_address = 0x4800
+		elif coil_type == 'X':
+			raise TypeError(f'Writing readonly coil: "{name}".')
+		else:
+			raise TypeError(f'Coil type "{coil_type}" is not supported yet.')
+		shift = int(name[1:], 8)
+		with self.__lock:
+			self.__modbus.write_coil(station=station, address=start_address + shift, value=value)
+
+	def get_coils(self, station: int, name: str, count: int) -> _List[bool]:
+		assert 0 < count <= 16
+		coil_type = name[0]
+		if coil_type == 'X':
+			start_address = 0x4000
+		elif coil_type == 'Y':
+			start_address = 0x4800
+		else:
+			raise TypeError(f'Coil type "{coil_type}" is not supported yet.')
+		shift = int(name[1:], 8)
+		with self.__lock:
+			values = self.__modbus.read_coils(station=station, address=start_address + shift, count=count)
+		return values
+
+	def get_coil(self, station: int, name: str) -> bool:
+		return self.get_coils(station, name, 1)[0]
+
+	@staticmethod
+	def register_name_to_address(name: str) -> int:
+		num_start_idx = -1
+		for idx, char in enumerate(name):
+			if str.isdigit(char):
+				num_start_idx = idx
+				break
+		assert num_start_idx > 0
+		register_type = name[:num_start_idx]
+		if register_type != 'D':
+			raise TypeError(f'Register type "{register_type}" is not supported yet.')
+		address = int(name[num_start_idx:])
+		return address
+
+	def set_uint16(self, station: int, name: str, value: int):
+		address = XCPlc.register_name_to_address(name)
+		with self.__lock:
+			self.__modbus.write_uint16(station, address, value)
+
+	def get_uint16(self, station: int, name: str) -> int:
+		address = XCPlc.register_name_to_address(name)
+		with self.__lock:
+			return self.__modbus.read_register(station, address)
+
+	def get_multi_uint16(self, station: int, name: str, count: int) -> _List[int]:
+		address = XCPlc.register_name_to_address(name)
+		with self.__lock:
+			return self.__modbus.read_registers(station, address, count)
+
+
+class XD5E:
+	def __init__(self, host: str, port: int = 502, station: int = 1, timeout: float = 0.5):
+		self.__modbus = _ModbusTCPMaster(host=host, port=port, station=station, timeout=timeout)
+
+	def close(self):
+		self.__modbus.close()
+
+	def __enter__(self):
+		return self
+
+	def __exit__(self, exc_type, exc_val, exc_tb):
+		self.close()
+
+	@property
+	def station(self):
+		return self.__modbus.station
+
+	@station.setter
+	def station(self, value: int):
+		self.__modbus.station = value
+
+	@staticmethod
+	def register_name_to_address(name: str) -> int:
+		upper = name.upper()
+		if upper.startswith('D'):
+			address = int(upper[1:])
+			assert 0 <= address < 20480, f'D register out of range [0, 20480)'
+		elif upper.startswith('HD'):
+			address = int(upper[2:])
+			assert 0 <= address < 6144, f'HD register out of range [0, 6144)'
+			address += 0xA080
+		else:
+			raise ValueError(f'Register type {upper} not supported yet')
+
+		return address
+
+	def get_uint16(self, name: str):
+		address = XD5E.register_name_to_address(name)
+		return self.__modbus.read_register(address)
+
+	def get_int16(self, name: str):
+		u_value = self.get_uint16(name)
+		package = struct.pack('H', u_value)
+		return struct.unpack('h', package)[0]
+
+	def set_uint16(self, name: str, value: int):
+		address = XD5E.register_name_to_address(name)
+		self.__modbus.write_registers(address, [value])
+
+	def set_int16(self, name: str, value: int):
+		package = struct.pack('h', value)
+		u_value = struct.unpack('H', package)[0]
+		self.set_uint16(name, u_value)
+
+	def get_multi_uint16(self, name: str, count: int):
+		address = XD5E.register_name_to_address(name)
+		return self.__modbus.read_registers(address, count)
+
+	def get_multi_int16(self, name: str, count: int):
+		u_values = self.get_multi_uint16(name, count)
+		values = list()
+		for u_value in u_values:
+			package = struct.pack('H', u_value)
+			value = struct.unpack('h', package)[0]
+			values.append(value)
+		return values
+
+	def set_multi_uint16(self, name: str, values: _List[int]):
+		address = XD5E.register_name_to_address(name)
+		self.__modbus.write_registers(address, values)
+
+	def set_multi_int16(self, name: str, values: _List[int]):
+		u_values = list()
+		for value in values:
+			package = struct.pack('h', value)
+			u_value = struct.unpack('H', package)[0]
+			u_values.append(u_value)
+		self.set_multi_uint16(name, u_values)
+
+	def set_string(self, value: str, name: str, register_count: int, encoding: str = 'latin'):
+		data = value.encode(encoding=encoding)
+		max_len = register_count * 2
+		items = list(data[:max_len])
+		register_values = []
+		if len(items) % 2 != 0:
+			items.append(0)
+
+		for i in range(0, len(items), 2):
+			register = (items[i+1] << 8) | items[i]
+			register_values.append(register)
+
+		register_values.extend([0] * (register_count - len(register_values)))
+		self.set_multi_uint16(name, register_values)
+
+	def get_string(self, name: str, register_count: int, encoding: str = 'latin'):
+		register_values = self.get_multi_uint16(name, register_count)
+		items = []
+		for register in register_values:
+			back, front = ((register >> 8) & 0xFF), (register & 0xFF)
+			if front == 0:
+				break
+			items.append(front)
+			if back != 0:
+				items.append(back)
+		b_str = bytes(items)
+		string = b_str.decode(encoding=encoding)
+		return string
+
+
+XDME = XD5E
+XL5E = XD5E
+XLME = XD5E
```

## Comparing `a2y_inst-1.4.0.dist-info/LICENSE` & `a2y_inst-1.4.1.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,14 +1,14 @@
-This is private software.
-
-Anyone without authorization is NOT allowed to copy, modify, publish, use, compile, sell, or
-distribute this software, either in source code form or as a compiled
-binary, for any purpose, commercial or non-commercial, and by any
-means.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
-OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-OTHER DEALINGS IN THE SOFTWARE.
+This is private software.
+
+Anyone without authorization is NOT allowed to copy, modify, publish, use, compile, sell, or
+distribute this software, either in source code form or as a compiled
+binary, for any purpose, commercial or non-commercial, and by any
+means.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
```

## Comparing `a2y_inst-1.4.0.dist-info/RECORD` & `a2y_inst-1.4.1.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 a2y_inst/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 a2y_inst/ac_power_source.py,sha256=PDKgR2R92DY2uOkeasoo3AKn1Jur1POHcpLTz24-K4A,1574
-a2y_inst/bg7tbl.py,sha256=6uReXoiWnqoeIvI2Fq_6ig8X_OtZmYfe7Cv7w5mXTmo,1156
-a2y_inst/curing.py,sha256=yUBl9o94fIcAUhqiqqGowDaERfPWbXHJNF-eLHibchQ,2428
-a2y_inst/dispenser.py,sha256=j-R73Jn88mrQYURt6-VDo4WRs2ZMqmogChYUpMQR7g8,6219
-a2y_inst/dt1309.py,sha256=-lo_edhV-osNegYXua7PxNobom3j6WHFYOWUhaebjSY,2023
-a2y_inst/gwinstek.py,sha256=FwPP71FhUdzMA4ybnIhdOM8DV8H-TmyIZXeJF2frVt8,3303
-a2y_inst/itech.py,sha256=eqLAuj72pjBCsYA0z4Ohr0vVmJeLiKCGxxmDbZ-ryXg,6080
-a2y_inst/jabil.py,sha256=Yk6UOoN6YMnewoLYNhPhIlB_V12CzE3BH5le3yIFBQo,2897
+a2y_inst/bg7tbl.py,sha256=aDBuGC_Qn99TZDpQY0JASqGqvJ32eE1LYP-lH_mevpE,1212
+a2y_inst/curing.py,sha256=afNPxcZoxnrMxTtS5QKF_yFSGxIhN6onj0mrMMVOUck,2489
+a2y_inst/dispenser.py,sha256=5dN2wW_ZlrJ_MLufjAvOmgLzW4La-Gt7jfeuVVYvENA,6418
+a2y_inst/dt1309.py,sha256=J6R-b0PK34jDAKPUgPFm5VMBpQOa-4fymc2on_6qJwY,2102
+a2y_inst/gwinstek.py,sha256=_YdRf-pqRPYFh7IO9Mei3IXws6dgBid53oAQnj47N9A,3311
+a2y_inst/itech.py,sha256=nHX7mLGVo9OfL55wW3jk-OoucggYx--jm8mfRr9GDvI,6265
+a2y_inst/jabil.py,sha256=oPKe_ln2lX5Mf9RT2pXw3_2ayyYAdudzmXQd4WxoQi4,2989
 a2y_inst/keyence.py,sha256=fnhrqy6kEB0dBflhRYZR7XEfr8C9hhUOtg8Xf4uMK5g,1138
-a2y_inst/kld.py,sha256=U-fDYqK6trsdHN6FRLhxMiV_XYAN6pEizfoyAVEf--0,1225
+a2y_inst/kld.py,sha256=sVC-gO_fE9D8KF0QTNABgHLxzOWqIYBMEHKLIso8QfU,1275
 a2y_inst/lb1905.py,sha256=3QbGYJpVNozrAgSzV_d-azr9jLe72U-9xr_T4IfBrSM,2494
-a2y_inst/mastech.py,sha256=oGVaoxS75xkvnaXWI_5CkujtaSy-8TTyUiwIS0iWGxw,2898
+a2y_inst/mastech.py,sha256=QEWVpGzsIij7yovNCW23-5qhUm9I20XP4yydXymuaaE,3016
 a2y_inst/mind_vision.py,sha256=40t76-w-IAu0GG_LV5Qh5bUJTZdmPy1p59EQi7u66dg,2568
-a2y_inst/mini_circuits.py,sha256=st4_FEYzT7bQPgUdT-OUc0lJfUy8KNh10So5bzvfC8U,1726
+a2y_inst/mini_circuits.py,sha256=EvVV-8yqEm8UrpK3dvadjFeVfWY-TAeF-qxFo5O34U0,1781
 a2y_inst/mitsubishi.py,sha256=xBmlcChM_ItPpasi1KcvHYxalnKowirZYbrGh9ykAs4,100593
 a2y_inst/mvsdk.py,sha256=4iRQ197cepjXZhbbWbRUxpZ9Knr3_B5PQPwbiH582Pg,89768
-a2y_inst/ni845x.py,sha256=SrcqK1fkmCIFN-LnaeOyORHR7snJAO3WnYwev2lHk5A,6884
-a2y_inst/shengpu.py,sha256=LL3RMDonEAt3M4GKZIss0ELkKWIMPVhNCHXLlVBazqE,1371
-a2y_inst/tes.py,sha256=OZJYBlmdoHGB9rXetADWPMBk-SjWH0IygPSqoLsv1mI,3084
+a2y_inst/ni845x.py,sha256=X4Ezafy39h4Mz3abLk8nilPJI1gqIAxg9BhU_-sskew,7107
+a2y_inst/shengpu.py,sha256=MeSG47DVE3chmjuYLQKGOdoOC9FK86GklsPC5VNMNCk,1430
+a2y_inst/tes.py,sha256=v2k9ZhiUfm69Z-wT3WJ9dCv8NlL-xl7CqGUrRlQ0xBY,3237
 a2y_inst/uhserial.py,sha256=Z5jsUOxVzjhj9OFOLIUyZFjU9ADIBc7LaWNErvDzYHE,4416
-a2y_inst/victor.py,sha256=A2zm6_PwSt2sfO84v9SW6iylgfN17JYs9RAN_OWvYc8,5774
+a2y_inst/victor.py,sha256=B-X7r9L1oYIMX6P30WEEHMuh1scuxumXenqSAHcXbQ0,5953
 a2y_inst/wordop.py,sha256=Wj7-KG8_jl_bZl6p6q7VTtrfsMTMQ6865Rvl4QRox-0,3744
-a2y_inst/xinje.py,sha256=U5OC3VD0ZFoeDFuSLJyGURkf8WkDGzPCacaFtO2ii5Q,5737
+a2y_inst/xinje.py,sha256=YmtEvEnsEOSodj74JBeBTGUS07IFN3lDikVgvsrcZJg,5925
 a2y_inst/yhd.py,sha256=OZ0FMRpkTRj9eRGQaqb3p4_aDwwQwxmHRR7xxZlboWk,4736
-a2y_inst-1.4.0.dist-info/LICENSE,sha256=w7owyu3RhoF9_okSTBzIxlowcdzIbfTnCR24-3ap_7s,704
-a2y_inst-1.4.0.dist-info/METADATA,sha256=SYanbm7NMWSLPwWoDMLLbbnSSadY_8qiL5ZpfIZMXZ0,998
-a2y_inst-1.4.0.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-a2y_inst-1.4.0.dist-info/top_level.txt,sha256=zdZrngJr0mtBXsjq1wZsfdbmkywSqGl0YaiIgkiByEI,9
-a2y_inst-1.4.0.dist-info/RECORD,,
+a2y_inst-1.4.1.dist-info/LICENSE,sha256=7jRZP-sMIeFzANh8v_27Scj1GU6BOPfsQjBqXtTjt6s,718
+a2y_inst-1.4.1.dist-info/METADATA,sha256=s0vFbilz1c9DkVYQzpavQRf23XauldBHrEyGb8_d2hg,1111
+a2y_inst-1.4.1.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+a2y_inst-1.4.1.dist-info/top_level.txt,sha256=zdZrngJr0mtBXsjq1wZsfdbmkywSqGl0YaiIgkiByEI,9
+a2y_inst-1.4.1.dist-info/RECORD,,
```

