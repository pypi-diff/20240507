# Comparing `tmp/c2cgeoportal_admin-2.6.0-py3-none-any.whl.zip` & `tmp/c2cgeoportal_admin-2.7.1.83-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,91 +1,94 @@
-Zip file size: 139733 bytes, number of entries: 89
--rw-r--r--  2.0 unx     4677 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/__init__.py
--rw-r--r--  2.0 unx     4592 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/routes.py
--rw-r--r--  2.0 unx     2362 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/subscribers.py
--rw-r--r--  2.0 unx     6043 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/widgets.py
--rw-r--r--  2.0 unx        0 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/lib/__init__.py
--rw-r--r--  2.0 unx    10962 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/lib/ogcserver_synchronizer.py
--rw-r--r--  2.0 unx        0 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/__init__.py
--rw-r--r--  2.0 unx     2070 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/dimensions.py
--rw-r--r--  2.0 unx     2476 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/functionalities.py
--rw-r--r--  2.0 unx     2277 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/interfaces.py
--rw-r--r--  2.0 unx     6537 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/metadata.py
--rw-r--r--  2.0 unx     2343 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/restriction_areas.py
--rw-r--r--  2.0 unx     2253 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/roles.py
--rw-r--r--  2.0 unx     6274 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/treegroup.py
--rw-r--r--  2.0 unx     2094 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/schemas/treeitem.py
--rw-r--r--  2.0 unx     3178 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/static/layertree.css
--rw-r--r--  2.0 unx     2383 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/static/navbar.css
--rw-r--r--  2.0 unx     1888 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/static/theme.css
--rw-r--r--  2.0 unx     1420 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/404.jinja2
--rw-r--r--  2.0 unx     1302 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/edit.jinja2
--rw-r--r--  2.0 unx     1516 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/home.jinja2
--rw-r--r--  2.0 unx     2005 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/index.jinja2
--rw-r--r--  2.0 unx     9027 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/layertree.jinja2
--rw-r--r--  2.0 unx     4105 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/layout.jinja2
--rw-r--r--  2.0 unx     3101 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/navigation_navbar.jinja2
--rw-r--r--  2.0 unx     1660 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/navigation_vertical.jinja2
--rw-r--r--  2.0 unx     3567 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/ogcserver_synchronize.jinja2
--rw-r--r--  2.0 unx     2159 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/child.pt
--rw-r--r--  2.0 unx     6625 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/children.pt
--rw-r--r--  2.0 unx     2627 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/dimension.pt
--rw-r--r--  2.0 unx     1211 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/dimensions.pt
--rw-r--r--  2.0 unx     3223 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/layer_fields.pt
--rw-r--r--  2.0 unx     2459 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/layer_group_fields.pt
--rw-r--r--  2.0 unx     3956 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/layer_v1_fields.pt
--rw-r--r--  2.0 unx     3538 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/metadata.pt
--rw-r--r--  2.0 unx     1476 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/metadatas.pt
--rw-r--r--  2.0 unx     1724 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/ogcserver_fields.pt
--rw-r--r--  2.0 unx     1731 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/restriction_area_fields.pt
--rw-r--r--  2.0 unx     2623 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/role_fields.pt
--rw-r--r--  2.0 unx     3083 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/theme_fields.pt
--rw-r--r--  2.0 unx     1753 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/templates/widgets/user_fields.pt
--rw-r--r--  2.0 unx        0 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/__init__.py
--rw-r--r--  2.0 unx     2465 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/dimension_layers.py
--rw-r--r--  2.0 unx     3144 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/functionalities.py
--rw-r--r--  2.0 unx     1804 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/home.py
--rw-r--r--  2.0 unx     3468 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/interfaces.py
--rw-r--r--  2.0 unx     3826 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/layer_groups.py
--rw-r--r--  2.0 unx     2897 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/layers.py
--rw-r--r--  2.0 unx     4103 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/layers_vectortiles.py
--rw-r--r--  2.0 unx     7314 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/layers_wms.py
--rw-r--r--  2.0 unx     7084 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/layers_wmts.py
--rw-r--r--  2.0 unx     7954 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/layertree.py
--rw-r--r--  2.0 unx     3342 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/oauth2_clients.py
--rw-r--r--  2.0 unx     6178 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/ogc_servers.py
--rw-r--r--  2.0 unx     5369 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/restriction_areas.py
--rw-r--r--  2.0 unx     5578 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/roles.py
--rw-r--r--  2.0 unx     5502 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/themes.py
--rw-r--r--  2.0 unx     5405 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/themes_ordering.py
--rw-r--r--  2.0 unx     3787 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/treeitems.py
--rw-r--r--  2.0 unx     5193 b- defN 21-Jul-06 10:47 c2cgeoportal_admin/views/users.py
--rw-r--r--  2.0 unx     9599 b- defN 21-Jul-06 10:47 tests/__init__.py
--rw-r--r--  2.0 unx     2065 b- defN 21-Jul-06 10:47 tests/conftest.py
--rw-r--r--  2.0 unx     4654 b- defN 21-Jul-06 10:47 tests/test_edit_url.py
--rw-r--r--  2.0 unx     3857 b- defN 21-Jul-06 10:47 tests/test_functionalities.py
--rw-r--r--  2.0 unx      426 b- defN 21-Jul-06 10:47 tests/test_home.py
--rw-r--r--  2.0 unx     4768 b- defN 21-Jul-06 10:47 tests/test_interface.py
--rw-r--r--  2.0 unx    11441 b- defN 21-Jul-06 10:47 tests/test_layer_groups.py
--rw-r--r--  2.0 unx     9509 b- defN 21-Jul-06 10:47 tests/test_layers_vectortiles.py
--rw-r--r--  2.0 unx    18503 b- defN 21-Jul-06 10:47 tests/test_layers_wms.py
--rw-r--r--  2.0 unx    11355 b- defN 21-Jul-06 10:47 tests/test_layers_wmts.py
--rw-r--r--  2.0 unx     8336 b- defN 21-Jul-06 10:47 tests/test_layertree.py
--rw-r--r--  2.0 unx     2307 b- defN 21-Jul-06 10:47 tests/test_learn.py
--rw-r--r--  2.0 unx      920 b- defN 21-Jul-06 10:47 tests/test_left_menu.py
--rw-r--r--  2.0 unx      354 b- defN 21-Jul-06 10:47 tests/test_main.py
--rw-r--r--  2.0 unx    11637 b- defN 21-Jul-06 10:47 tests/test_metadatas.py
--rw-r--r--  2.0 unx     5814 b- defN 21-Jul-06 10:47 tests/test_oauth2_clients.py
--rw-r--r--  2.0 unx     6150 b- defN 21-Jul-06 10:47 tests/test_ogc_servers.py
--rw-r--r--  2.0 unx     8026 b- defN 21-Jul-06 10:47 tests/test_restriction_areas.py
--rw-r--r--  2.0 unx    11730 b- defN 21-Jul-06 10:47 tests/test_role.py
--rw-r--r--  2.0 unx    15119 b- defN 21-Jul-06 10:47 tests/test_themes.py
--rw-r--r--  2.0 unx     2260 b- defN 21-Jul-06 10:47 tests/test_themes_ordering.py
--rw-r--r--  2.0 unx      592 b- defN 21-Jul-06 10:47 tests/test_treegroup.py
--rw-r--r--  2.0 unx    11738 b- defN 21-Jul-06 10:47 tests/test_user.py
--rw-r--r--  2.0 unx     1351 b- defN 21-Jul-06 10:47 tests/themes_ordering.py
--rw-r--r--  2.0 unx     1276 b- defN 21-Jul-06 11:29 c2cgeoportal_admin-2.6.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 21-Jul-06 11:29 c2cgeoportal_admin-2.6.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       52 b- defN 21-Jul-06 11:29 c2cgeoportal_admin-2.6.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       25 b- defN 21-Jul-06 11:29 c2cgeoportal_admin-2.6.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     8330 b- defN 21-Jul-06 11:29 c2cgeoportal_admin-2.6.0.dist-info/RECORD
-89 files, 384999 bytes uncompressed, 126303 bytes compressed:  67.2%
+Zip file size: 149613 bytes, number of entries: 92
+-rw-r--r--  2.0 unx     4959 b- defN 24-May-07 15:28 c2cgeoportal_admin/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 15:28 c2cgeoportal_admin/py.typed
+-rw-r--r--  2.0 unx     4676 b- defN 24-May-07 15:28 c2cgeoportal_admin/routes.py
+-rw-r--r--  2.0 unx     2430 b- defN 24-May-07 15:28 c2cgeoportal_admin/subscribers.py
+-rw-r--r--  2.0 unx     6132 b- defN 24-May-07 15:28 c2cgeoportal_admin/widgets.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 15:28 c2cgeoportal_admin/lib/__init__.py
+-rw-r--r--  2.0 unx     3380 b- defN 24-May-07 15:28 c2cgeoportal_admin/lib/lingua_extractor.py
+-rw-r--r--  2.0 unx    15421 b- defN 24-May-07 15:28 c2cgeoportal_admin/lib/ogcserver_synchronizer.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/__init__.py
+-rw-r--r--  2.0 unx     2290 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/dimensions.py
+-rw-r--r--  2.0 unx     3941 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/functionalities.py
+-rw-r--r--  2.0 unx     2578 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/interfaces.py
+-rw-r--r--  2.0 unx     8991 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/metadata.py
+-rw-r--r--  2.0 unx     2598 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/restriction_areas.py
+-rw-r--r--  2.0 unx     2507 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/roles.py
+-rw-r--r--  2.0 unx     7039 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/treegroup.py
+-rw-r--r--  2.0 unx     2117 b- defN 24-May-07 15:28 c2cgeoportal_admin/schemas/treeitem.py
+-rw-r--r--  2.0 unx     3177 b- defN 24-May-07 15:28 c2cgeoportal_admin/static/layertree.css
+-rw-r--r--  2.0 unx     2307 b- defN 24-May-07 15:28 c2cgeoportal_admin/static/navbar.css
+-rw-r--r--  2.0 unx     2025 b- defN 24-May-07 15:28 c2cgeoportal_admin/static/theme.css
+-rw-r--r--  2.0 unx     1420 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/404.jinja2
+-rw-r--r--  2.0 unx     1302 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/edit.jinja2
+-rw-r--r--  2.0 unx     1516 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/home.jinja2
+-rw-r--r--  2.0 unx     2005 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/index.jinja2
+-rw-r--r--  2.0 unx     9830 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/layertree.jinja2
+-rw-r--r--  2.0 unx     4105 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/layout.jinja2
+-rw-r--r--  2.0 unx     4166 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/navigation_navbar.jinja2
+-rw-r--r--  2.0 unx     4327 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/ogcserver_synchronize.jinja2
+-rw-r--r--  2.0 unx     2159 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/child.pt
+-rw-r--r--  2.0 unx     6625 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/children.pt
+-rw-r--r--  2.0 unx     2627 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/dimension.pt
+-rw-r--r--  2.0 unx     1211 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/dimensions.pt
+-rw-r--r--  2.0 unx     1969 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/functionality_fields.pt
+-rw-r--r--  2.0 unx     3223 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/layer_fields.pt
+-rw-r--r--  2.0 unx     2459 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/layer_group_fields.pt
+-rw-r--r--  2.0 unx     3956 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/layer_v1_fields.pt
+-rw-r--r--  2.0 unx     3735 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/metadata.pt
+-rw-r--r--  2.0 unx     1476 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/metadatas.pt
+-rw-r--r--  2.0 unx     1724 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/ogcserver_fields.pt
+-rw-r--r--  2.0 unx     1731 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/restriction_area_fields.pt
+-rw-r--r--  2.0 unx     2623 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/role_fields.pt
+-rw-r--r--  2.0 unx     3083 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/theme_fields.pt
+-rw-r--r--  2.0 unx     1753 b- defN 24-May-07 15:28 c2cgeoportal_admin/templates/widgets/user_fields.pt
+-rw-r--r--  2.0 unx        0 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/__init__.py
+-rw-r--r--  2.0 unx     2598 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/dimension_layers.py
+-rw-r--r--  2.0 unx     4002 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/functionalities.py
+-rw-r--r--  2.0 unx     1943 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/home.py
+-rw-r--r--  2.0 unx     3465 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/interfaces.py
+-rw-r--r--  2.0 unx     3956 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/layer_groups.py
+-rw-r--r--  2.0 unx     3039 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/layers.py
+-rw-r--r--  2.0 unx     4932 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/layers_vectortiles.py
+-rw-r--r--  2.0 unx     7954 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/layers_wms.py
+-rw-r--r--  2.0 unx     7731 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/layers_wmts.py
+-rw-r--r--  2.0 unx     8589 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/layertree.py
+-rw-r--r--  2.0 unx     3740 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/oauth2_clients.py
+-rw-r--r--  2.0 unx     7476 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/ogc_servers.py
+-rw-r--r--  2.0 unx     5549 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/restriction_areas.py
+-rw-r--r--  2.0 unx     5858 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/roles.py
+-rw-r--r--  2.0 unx     5710 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/themes.py
+-rw-r--r--  2.0 unx     5590 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/themes_ordering.py
+-rw-r--r--  2.0 unx     3860 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/treeitems.py
+-rw-r--r--  2.0 unx     5355 b- defN 24-May-07 15:28 c2cgeoportal_admin/views/users.py
+-rw-r--r--  2.0 unx     9525 b- defN 24-May-07 15:28 tests/__init__.py
+-rw-r--r--  2.0 unx     2119 b- defN 24-May-07 15:28 tests/conftest.py
+-rw-r--r--  2.0 unx     4495 b- defN 24-May-07 15:28 tests/test_edit_url.py
+-rw-r--r--  2.0 unx     4126 b- defN 24-May-07 15:28 tests/test_functionalities.py
+-rw-r--r--  2.0 unx      426 b- defN 24-May-07 15:28 tests/test_home.py
+-rw-r--r--  2.0 unx     4704 b- defN 24-May-07 15:28 tests/test_interface.py
+-rw-r--r--  2.0 unx    11062 b- defN 24-May-07 15:28 tests/test_layer_groups.py
+-rw-r--r--  2.0 unx     9395 b- defN 24-May-07 15:28 tests/test_layers_vectortiles.py
+-rw-r--r--  2.0 unx    18175 b- defN 24-May-07 15:28 tests/test_layers_wms.py
+-rw-r--r--  2.0 unx    11185 b- defN 24-May-07 15:28 tests/test_layers_wmts.py
+-rw-r--r--  2.0 unx    11336 b- defN 24-May-07 15:28 tests/test_layertree.py
+-rw-r--r--  2.0 unx     2307 b- defN 24-May-07 15:28 tests/test_learn.py
+-rw-r--r--  2.0 unx      920 b- defN 24-May-07 15:28 tests/test_left_menu.py
+-rw-r--r--  2.0 unx     2515 b- defN 24-May-07 15:28 tests/test_lingua_extractor_config.py
+-rw-r--r--  2.0 unx      365 b- defN 24-May-07 15:28 tests/test_main.py
+-rw-r--r--  2.0 unx    12089 b- defN 24-May-07 15:28 tests/test_metadatas.py
+-rw-r--r--  2.0 unx     5782 b- defN 24-May-07 15:28 tests/test_oauth2_clients.py
+-rw-r--r--  2.0 unx     6436 b- defN 24-May-07 15:28 tests/test_ogc_servers.py
+-rw-r--r--  2.0 unx     7925 b- defN 24-May-07 15:28 tests/test_restriction_areas.py
+-rw-r--r--  2.0 unx    11820 b- defN 24-May-07 15:28 tests/test_role.py
+-rw-r--r--  2.0 unx    15181 b- defN 24-May-07 15:28 tests/test_themes.py
+-rw-r--r--  2.0 unx     2244 b- defN 24-May-07 15:28 tests/test_themes_ordering.py
+-rw-r--r--  2.0 unx      576 b- defN 24-May-07 15:28 tests/test_treegroup.py
+-rw-r--r--  2.0 unx    11659 b- defN 24-May-07 15:28 tests/test_user.py
+-rw-r--r--  2.0 unx     1343 b- defN 24-May-07 15:28 tests/themes_ordering.py
+-rw-r--r--  2.0 unx     1491 b- defN 24-May-07 16:11 c2cgeoportal_admin-2.7.1.83.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-07 16:11 c2cgeoportal_admin-2.7.1.83.dist-info/WHEEL
+-rw-r--r--  2.0 unx      164 b- defN 24-May-07 16:11 c2cgeoportal_admin-2.7.1.83.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       25 b- defN 24-May-07 16:11 c2cgeoportal_admin-2.7.1.83.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     8626 b- defN 24-May-07 16:11 c2cgeoportal_admin-2.7.1.83.dist-info/RECORD
+92 files, 415048 bytes uncompressed, 135703 bytes compressed:  67.3%
```

## zipnote {}

```diff
@@ -1,22 +1,28 @@
 Filename: c2cgeoportal_admin/__init__.py
 Comment: 
 
+Filename: c2cgeoportal_admin/py.typed
+Comment: 
+
 Filename: c2cgeoportal_admin/routes.py
 Comment: 
 
 Filename: c2cgeoportal_admin/subscribers.py
 Comment: 
 
 Filename: c2cgeoportal_admin/widgets.py
 Comment: 
 
 Filename: c2cgeoportal_admin/lib/__init__.py
 Comment: 
 
+Filename: c2cgeoportal_admin/lib/lingua_extractor.py
+Comment: 
+
 Filename: c2cgeoportal_admin/lib/ogcserver_synchronizer.py
 Comment: 
 
 Filename: c2cgeoportal_admin/schemas/__init__.py
 Comment: 
 
 Filename: c2cgeoportal_admin/schemas/dimensions.py
@@ -69,17 +75,14 @@
 
 Filename: c2cgeoportal_admin/templates/layout.jinja2
 Comment: 
 
 Filename: c2cgeoportal_admin/templates/navigation_navbar.jinja2
 Comment: 
 
-Filename: c2cgeoportal_admin/templates/navigation_vertical.jinja2
-Comment: 
-
 Filename: c2cgeoportal_admin/templates/ogcserver_synchronize.jinja2
 Comment: 
 
 Filename: c2cgeoportal_admin/templates/widgets/child.pt
 Comment: 
 
 Filename: c2cgeoportal_admin/templates/widgets/children.pt
@@ -87,14 +90,17 @@
 
 Filename: c2cgeoportal_admin/templates/widgets/dimension.pt
 Comment: 
 
 Filename: c2cgeoportal_admin/templates/widgets/dimensions.pt
 Comment: 
 
+Filename: c2cgeoportal_admin/templates/widgets/functionality_fields.pt
+Comment: 
+
 Filename: c2cgeoportal_admin/templates/widgets/layer_fields.pt
 Comment: 
 
 Filename: c2cgeoportal_admin/templates/widgets/layer_group_fields.pt
 Comment: 
 
 Filename: c2cgeoportal_admin/templates/widgets/layer_v1_fields.pt
@@ -213,14 +219,17 @@
 
 Filename: tests/test_learn.py
 Comment: 
 
 Filename: tests/test_left_menu.py
 Comment: 
 
+Filename: tests/test_lingua_extractor_config.py
+Comment: 
+
 Filename: tests/test_main.py
 Comment: 
 
 Filename: tests/test_metadatas.py
 Comment: 
 
 Filename: tests/test_oauth2_clients.py
@@ -246,23 +255,23 @@
 
 Filename: tests/test_user.py
 Comment: 
 
 Filename: tests/themes_ordering.py
 Comment: 
 
-Filename: c2cgeoportal_admin-2.6.0.dist-info/METADATA
+Filename: c2cgeoportal_admin-2.7.1.83.dist-info/METADATA
 Comment: 
 
-Filename: c2cgeoportal_admin-2.6.0.dist-info/WHEEL
+Filename: c2cgeoportal_admin-2.7.1.83.dist-info/WHEEL
 Comment: 
 
-Filename: c2cgeoportal_admin-2.6.0.dist-info/entry_points.txt
+Filename: c2cgeoportal_admin-2.7.1.83.dist-info/entry_points.txt
 Comment: 
 
-Filename: c2cgeoportal_admin-2.6.0.dist-info/top_level.txt
+Filename: c2cgeoportal_admin-2.7.1.83.dist-info/top_level.txt
 Comment: 
 
-Filename: c2cgeoportal_admin-2.6.0.dist-info/RECORD
+Filename: c2cgeoportal_admin-2.7.1.83.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## c2cgeoportal_admin/__init__.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -24,37 +22,39 @@
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
+from typing import Any
+
 import c2cgeoform
 import c2cwsgiutils.pretty_json
+import sqlalchemy
 import zope.sqlalchemy
 from c2c.template.config import config as configuration
 from pkg_resources import resource_filename
 from pyramid.config import Configurator
 from pyramid.events import BeforeRender, NewRequest
 from sqlalchemy import engine_from_config
 from sqlalchemy.orm import configure_mappers, sessionmaker
+from transaction import TransactionManager
 from translationstring import TranslationStringFactory
 
 from c2cgeoportal_admin.subscribers import add_localizer, add_renderer_globals
 
 search_paths = (resource_filename(__name__, "templates/widgets"),) + c2cgeoform.default_search_paths
 c2cgeoform.default_search_paths = search_paths
 
 _ = TranslationStringFactory("c2cgeoportal_admin")
 
 
 def main(_, **settings):
-    """
-    This function returns a Pyramid WSGI application.
-    """
+    """Return a Pyramid WSGI application."""
     configuration.init(settings.get("app.cfg"))
     settings.update(configuration.get_config())
 
     config = Configurator(settings=settings)
 
     c2cwsgiutils.pretty_json.init(config)
     config.include("c2cgeoportal_admin")
@@ -64,15 +64,17 @@
     settings["tm.manager_hook"] = "pyramid_tm.explicit_manager"
 
     configure_mappers()
     engine = engine_from_config(settings)
     session_factory = sessionmaker()
     session_factory.configure(bind=engine)
 
-    def get_tm_session(session_factory, transaction_manager):
+    def get_tm_session(
+        session_factory: sessionmaker, transaction_manager: TransactionManager
+    ) -> sqlalchemy.orm.session.Session:
         dbsession = session_factory()
         zope.sqlalchemy.register(dbsession, transaction_manager=transaction_manager)
         return dbsession
 
     # Make request.dbsession available for use in Pyramid
     config.add_request_method(
         # request.tm is the transaction manager used by pyramid_tm
@@ -84,35 +86,40 @@
     config.add_subscriber(add_renderer_globals, BeforeRender)
     config.add_subscriber(add_localizer, NewRequest)
 
     return config.make_wsgi_app()
 
 
 class PermissionSetter:
-    def __init__(self, config):
+    """Set the permission to the admin user."""
+
+    def __init__(self, config: Configurator):
         self.default_permission_to_revert = None
         self.config = config
 
     def __enter__(self) -> None:
         self.config.commit()  # avoid .ConfigurationConflictError
         if self.config.introspector.get_category("default permission"):
             self.default_permission_to_revert = self.config.introspector.get_category("default permission")[
                 0
             ]["introspectable"]["value"]
         self.config.set_default_permission("admin")
 
-    def __exit__(self, _type, value, traceback):
+    def __exit__(self, _type: Any, value: Any, traceback: Any) -> None:
         self.config.commit()  # avoid .ConfigurationConflictError
         self.config.set_default_permission(self.default_permission_to_revert)
 
 
-def includeme(config: Configurator):
+def includeme(config: Configurator) -> None:
+    """Initialize the Pyramid application."""
     config.include("pyramid_jinja2")
     config.include("c2cgeoform")
     config.include("c2cgeoportal_commons")
     config.include("c2cgeoportal_admin.routes")
     # Use pyramid_tm to hook the transaction lifecycle to the request
     config.include("pyramid_tm")
     config.add_translation_dirs("c2cgeoportal_admin:locale")
 
+    configure_mappers()
+
     with PermissionSetter(config):
         config.scan()
```

## c2cgeoportal_admin/routes.py

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 # Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
@@ -28,20 +26,21 @@
 # either expressed or implied, of the FreeBSD Project.
 
 
 from c2cgeoform.routes import register_route, register_routes
 
 
 def includeme(config):
+    """Initialize the Pyramid routes."""
     config.add_static_view("c2cgeoportal_admin_node_modules", "c2cgeoportal_admin:node_modules")
     config.override_asset(
         to_override="c2cgeoportal_admin:node_modules/", override_with="/opt/c2cgeoportal/admin/node_modules"
     )
     # Because c2cgeoform widgets target {root_package}:node_modules/...
-    asset_spec = "{}:node_modules/".format(config.root_package.__name__)
+    asset_spec = f"{config.root_package.__name__}:node_modules/"
     config.add_static_view("root_package_node_modules", asset_spec)
     config.override_asset(to_override=asset_spec, override_with="/opt/c2cgeoportal/admin/node_modules")
 
     config.add_static_view("admin_static", "c2cgeoportal_admin:static", cache_max_age=3600)
 
     register_route(config, "admin", "/{application:admin}/")
     register_route(config, "layertree", "/{application:admin}/layertree")
@@ -55,14 +54,15 @@
         config, "ogcserver_synchronize", "/{application:admin}/{table:ogc_servers}/{id}/synchronize"
     )
 
     from c2cgeoportal_commons.models.main import (  # pylint: disable=import-outside-toplevel
         Functionality,
         Interface,
         LayerGroup,
+        LayerVectorTiles,
         LayerWMS,
         LayerWMTS,
         OGCServer,
         RestrictionArea,
         Role,
         Theme,
     )
@@ -72,14 +72,15 @@
     )
 
     visible_routes = [
         ("themes", Theme),
         ("layer_groups", LayerGroup),
         ("layers_wms", LayerWMS),
         ("layers_wmts", LayerWMTS),
+        ("layers_vectortiles", LayerVectorTiles),
         ("ogc_servers", OGCServer),
         ("restriction_areas", RestrictionArea),
         ("users", User),
         ("roles", Role),
         ("functionalities", Functionality),
         ("interfaces", Interface),
         ("oauth2_clients", OAuth2Client),
```

## c2cgeoportal_admin/subscribers.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -30,24 +28,26 @@
 
 from pyramid.i18n import TranslationStringFactory, get_localizer
 
 # see https://docs.pylonsproject.org/projects/pyramid-cookbook/en/latest/templates/mako_i18n.html*
 
 
 def add_renderer_globals(event):
+    """Add the localizer to the global event."""
     request = event["request"]
     event["_"] = request.translate
     event["localizer"] = request.localizer
 
 
 tsf1 = TranslationStringFactory("c2cgeoportal_admin")
 tsf2 = TranslationStringFactory("c2cgeoform")
 
 
 def add_localizer(event):
+    """Add the localizer to the request."""
     request = event.request
     localizer = get_localizer(request)
 
     def auto_translate(*args, **kwargs):
         result = localizer.translate(tsf1(*args, **kwargs))
         return localizer.translate(tsf2(*args, **kwargs)) if result == args[0] else result
```

## c2cgeoportal_admin/widgets.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2024, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -23,17 +21,18 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
-from typing import Optional
+from typing import Any, Optional
 
 import colander
+import pyramid.request
 from colander import Mapping, SchemaNode
 from deform import widget
 from deform.widget import MappingWidget, SequenceWidget
 
 from c2cgeoportal_commons.models.main import TreeItem
 
 registry = widget.default_resource_registry
@@ -51,18 +50,19 @@
     SchemaNode(widget._StrippedString(), name="date"),  # pylint: disable=protected-access
     SchemaNode(widget._StrippedString(), name="time"),  # pylint: disable=protected-access
     SchemaNode(widget._StrippedString(), name="date_submit", missing=""),  # pylint: disable=protected-access
     SchemaNode(widget._StrippedString(), name="time_submit", missing=""),  # pylint: disable=protected-access
 )
 
 
-class ChildWidget(MappingWidget):
+class ChildWidget(MappingWidget):  # type: ignore
     """
-    Extension of the widget ````deform.widget.MappingWidget`` to be used in conjunction with ChildrenWidget,
-    to manage n-m relationships.
+    Extension of the widget ````deform.widget.MappingWidget``.
+
+    To be used in conjunction with ChildrenWidget, to manage n-m relationships.
 
     Do not embed complete children forms, but just an hidden input for child primary key.
 
     **Attributes/Arguments**
 
     input_name (required)
         Form input name namely the name of the schema field identifying the child in the relation.
@@ -78,43 +78,46 @@
 
     edit_url (optional)
         A function taking request and child as parameter and returning
         an URL to the corresponding resource.
 
     For further attributes, please refer to the documentation of
     ``deform.widget.MappingWidget`` in the deform documentation:
-    <http://deform.readthedocs.org/en/latest/api.html>
+    <https://deform.readthedocs.org/en/latest/api.html>
     """
 
     template = "child"
     input_name = "treeitem_id"
     model = TreeItem
     label_field = "name"
 
-    def icon_class(self, child) -> Optional[str]:  # pylint: disable=no-self-use,useless-return
+    def icon_class(self, child: Any) -> Optional[str]:  # pylint: disable=no-self-use,useless-return
         del child
         return None
 
-    def edit_url(self, request, child) -> Optional[str]:  # pylint: disable=no-self-use,useless-return
+    def edit_url(  # pylint: disable=no-self-use,useless-return
+        self, request: pyramid.request.Request, child: Any
+    ) -> Optional[str]:
         del request
         del child
         return None
 
     def serialize(self, field, cstruct, **kw):
         if cstruct[self.input_name] == colander.null:
             kw["child"] = self.model()
         else:
             kw["child"] = field.schema.dbsession.query(self.model).get(int(cstruct[self.input_name]))
         return super().serialize(field, cstruct, **kw)
 
 
-class ChildrenWidget(SequenceWidget):
+class ChildrenWidget(SequenceWidget):  # type: ignore
     """
-    Extension of the widget ````deform.widget.SequenceWidget``, to be used in conjunction with ChildWidget,
-    to manage n-m relationships.
+    Extension of the widget ````deform.widget.SequenceWidget``.
+
+    To be used in conjunction with ChildWidget, to manage n-m relationships.
 
     Use Magicsuggest for searching into parent schema candidates property, which should be a list of
     dictionaries of the form:
     {
         "id": "Value to be set in child identifier input (child_input_name)",
         "label": "The text to display in MagicSuggest",
         "icon_class": "An optional icon class for the MagisSuggest entries",
@@ -125,15 +128,15 @@
     **Attributes/Arguments**
 
     child_input_name (required)
         The name of the child input to fill with selected child primary key.
 
     For further attributes, please refer to the documentation of
     ``deform.widget.SequenceWidget`` in the deform documentation:
-    <http://deform.readthedocs.org/en/latest/api.html>
+    <https://deform.readthedocs.org/en/latest/api.html>
     """
 
     template = "children"
     category = "structural"
     add_subitem = True
     orderable = True
     child_input_name = "treeitem_id"
```

## c2cgeoportal_admin/lib/ogcserver_synchronizer.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2020, Camptocamp SA
+# Copyright (c) 2020-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -24,136 +22,229 @@
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
+import functools
 import logging
 from io import StringIO
-from typing import Set, cast  # noqa, pylint: disable=unused-import
+from typing import Any, Optional, Set, cast
+from xml.etree.ElementTree import Element  # nosec
 
+import pyramid.request
 import requests
 from defusedxml import ElementTree
+from sqlalchemy.orm.session import Session
 
-from c2cgeoportal_commons.lib.url import add_url_params, get_url2
+from c2cgeoportal_commons.lib.url import get_url2
 from c2cgeoportal_commons.models import main
 
 
-class dry_run_transaction:  # noqa N801: class names should use CapWords convention
-    def __init__(self, dbsession, dry_run):
+class dry_run_transaction:  # noqa ignore=N801: class names should use CapWords convention
+    def __init__(self, dbsession: Session, dry_run: bool):
         self.dbsession = dbsession
         self.dry_run = dry_run
 
-    def __enter__(self):
+    def __enter__(self) -> None:
         if self.dry_run:
             self.dbsession.begin_nested()
 
-    def __exit__(self, exc_type, exc_val, exc_tb):
+    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
         if self.dry_run:
             self.dbsession.rollback()
 
 
 class OGCServerSynchronizer:
-    def __init__(self, request, ogc_server):
+    """A processor which imports WMS Capabilities in layer tree."""
+
+    def __init__(
+        self,
+        request: pyramid.request.Request,
+        ogc_server: main.OGCServer,
+        force_parents: bool = False,
+        force_ordering: bool = False,
+        clean: bool = False,
+    ) -> None:
+        """
+        Initialize the Synchronizer.
+
+        request
+            The current pyramid request object. Used to retrieve the SQLAlchemy Session object,
+            and to construct the capabilities URL.
+
+        ogc_server
+            The considered OGCServer from witch to import the capabilities.
+
+        force_parents
+            When set to True, overwrite parents of each node with those from the capabilities.
+
+        force_ordering
+            When set to True, sort children of each node in order from the capabilities.
+
+        clean
+            When set to True, remove layers which do not exist in capabilities and remove all empty groups.
+        """
         self._request = request
         self._ogc_server = ogc_server
+        self._force_parents = force_parents
+        self._force_ordering = force_ordering
+        self._clean = clean
+
         self._default_wms = main.LayerWMS()
         self._interfaces = None
 
         self._logger = logging.Logger(str(self), logging.INFO)
         self._log = StringIO()
         self._log_handler = logging.StreamHandler(self._log)
         self._logger.addHandler(self._log_handler)
 
         self._items_found = 0
         self._themes_added = 0
         self._groups_added = 0
+        self._groups_removed = 0
         self._layers_added = 0
+        self._layers_removed = 0
 
-    def __str__(self):
-        return "OGCServerSynchronizer({})".format(self._ogc_server.name)
+    def __str__(self) -> str:
+        return f"OGCServerSynchronizer({self._ogc_server.name})"
 
-    def logger(self):
+    def logger(self) -> logging.Logger:
         return self._logger
 
-    def report(self):
+    def report(self) -> str:
         return self._log.getvalue()
 
-    def check_layers(self):
+    def check_layers(self) -> None:
         capabilities = ElementTree.fromstring(self.wms_capabilities())
         layers = self._request.dbsession.query(main.LayerWMS).filter(
             main.LayerWMS.ogc_server == self._ogc_server
         )
         items = 0
         invalids = 0
         for layer in layers:
             valid = True
             reason = None
             for name in layer.layer.split(","):
-                el = capabilities.find(".//Layer[Name='{}']".format(name))
+                if "'" in name:
+                    valid = False
+                    reason = "Layer name contains quote"
+                    self._logger.info(reason)
+                    break
+                el = capabilities.find(f".//Layer[Name='{name}']")
                 if el is None:
                     valid = False
-                    reason = "Layer {} does not exists on OGC server".format(name)
+                    reason = f"Layer {name} does not exists on OGC server"
                     self._logger.info(reason)
+                    if self._clean:
+                        self._request.dbsession.delete(layer)
+                        self._logger.info("Removed layer %s", name)
+                        self._layers_removed += 1
                     break
-                if layer.style and el.find("./Style/Name[.='{}']".format(layer.style)) is None:
+                if layer.style and el.find(f"./Style/Name[.='{layer.style}']") is None:
                     valid = False
-                    reason = "Style {} does not exists in Layer {}".format(layer.style, name)
+                    reason = f"Style {layer.style} does not exists in Layer {name}"
                     self._logger.info(reason)
                     break
             layer.valid = valid
             if not valid:
                 invalids += 1
             layer.invalid_reason = reason
             items += 1
+
+        if self._clean:
+            groups = self._request.dbsession.query(main.LayerGroup)
+            for group in groups:
+                if len(group.children_relation) == 0:
+                    self._request.dbsession.delete(group)
+                    self._logger.info("Removed empty group %s", group.name)
+                    self._groups_removed += 1
+
         self._logger.info("Checked %s layers, %s are invalid", items, invalids)
 
-    def synchronize(self, dry_run=False):
+    def synchronize(self, dry_run: bool = False) -> None:
+        """
+        Run the import of capabilities in layer tree.
+
+        dry_run
+            When set to True, do not commit but roll back transaction at end of synchronization.
+        """
         with dry_run_transaction(self._request.dbsession, dry_run):
             self.do_synchronize()
             if dry_run:
                 self._logger.info("Rolling back transaction due to dry run")
 
-    def do_synchronize(self):
+    def do_synchronize(self) -> None:
         self._items_found = 0
         self._themes_added = 0
         self._groups_added = 0
+        self._groups_removed = 0
         self._layers_added = 0
+        self._layers_removed = 0
 
         self._default_wms = cast(
             main.LayerWMS, main.LayerWMS.get_default(self._request.dbsession) or main.LayerWMS()
         )
         self._interfaces = self._request.dbsession.query(main.Interface).all()
 
         capabilities = ElementTree.fromstring(self.wms_capabilities())
         theme_layers = capabilities.findall("Capability/Layer/Layer")
         for theme_layer in theme_layers:
             self.synchronize_layer(theme_layer)
 
-        self._logger.info("%s items were found", self._items_found)
-        self._logger.info("%s themes were added", self._themes_added)
-        self._logger.info("%s groups were added", self._groups_added)
-        self._logger.info("%s layers were added", self._layers_added)
+        if self._clean:
+            self.check_layers()
+
+        self._logger.info("%s items found", self._items_found)
+        self._logger.info("%s themes added", self._themes_added)
+        self._logger.info("%s groups added", self._groups_added)
+        self._logger.info("%s groups removed", self._groups_removed)
+        self._logger.info("%s layers added", self._layers_added)
+        self._logger.info("%s layers removed", self._layers_removed)
 
-    def synchronize_layer(self, el, parent=None):
+    def synchronize_layer(self, el: Element, parent: Optional[main.TreeGroup] = None) -> main.TreeItem:
         if el.find("Layer") is None:
             tree_item = self.get_layer_wms(el, parent)
         elif parent is None:
             tree_item = self.get_theme(el)
         else:
             tree_item = self.get_layer_group(el, parent)
 
+        server_children = []
         for child in el.findall("Layer"):
-            self.synchronize_layer(child, tree_item)
+            child_item = self.synchronize_layer(child, tree_item)
 
-    def get_theme(self, el):
-        name = el.find("Name").text
+            if isinstance(tree_item, main.Theme) and isinstance(child_item, main.LayerWMS):
+                # We cannot add layers in themes
+                continue
+
+            server_children.append(child_item)
+
+        if self._force_ordering and isinstance(tree_item, main.TreeGroup):
+            # Force children ordering, server_children first, external_children last
+            external_children = [item for item in tree_item.children if item not in server_children]
+            children = server_children + external_children
+            if tree_item.children != children:
+                tree_item._set_children(  # pylint: disable=protected-access
+                    server_children + external_children, order=True
+                )
+                self._logger.info("Children of %s have been sorted", tree_item.name)
+
+        return tree_item
 
-        theme = self._request.dbsession.query(main.Theme).filter(main.Theme.name == name).one_or_none()
+    def get_theme(self, el: ElementTree) -> main.Theme:
+        name_el = el.find("Name")
+        assert name_el is not None
+        name = name_el.text
+
+        theme = cast(
+            Optional[main.Theme],
+            self._request.dbsession.query(main.Theme).filter(main.Theme.name == name).one_or_none(),
+        )
 
         if theme is None:
             theme = main.Theme()
             theme.name = name
             theme.public = False
             theme.interfaces = self._interfaces
 
@@ -161,43 +252,60 @@
             self._logger.info("Layer %s added as new theme", name)
             self._themes_added += 1
         else:
             self._items_found += 1
 
         return theme
 
-    def get_layer_group(self, el, parent):
-        name = el.find("Name").text
-
-        group = (
-            self._request.dbsession.query(main.LayerGroup).filter(main.LayerGroup.name == name).one_or_none()
+    def get_layer_group(self, el: Element, parent: main.TreeGroup) -> main.LayerGroup:
+        name_el = el.find("Name")
+        assert name_el is not None
+        name = name_el.text
+        assert name is not None
+
+        group = cast(
+            Optional[main.LayerGroup],
+            (
+                self._request.dbsession.query(main.LayerGroup)
+                .filter(main.LayerGroup.name == name)
+                .one_or_none()
+            ),
         )
 
         if group is None:
-            group = main.LayerGroup(name=el.find("Name").text)
-            group.parents_relation.append(main.LayergroupTreeitem(group=parent))  # noqa, pylint: no-member
+            group = main.LayerGroup(name=name)
+            group.parents_relation.append(main.LayergroupTreeitem(group=parent))
 
             self._request.dbsession.add(group)
             self._logger.info("Layer %s added as new group in theme %s", name, parent.name)
             self._groups_added += 1
         else:
             self._items_found += 1
 
-        return group
+            if self._force_parents and group.parents != [parent]:
+                group.parents_relation = [main.LayergroupTreeitem(group=parent)]
+                self._logger.info("Group %s moved to %s", name, parent.name)
 
-    def get_layer_wms(self, el, parent):
-        name = el.find("Name").text
+        return group
 
-        layer = self._request.dbsession.query(main.LayerWMS).filter(main.LayerWMS.name == name).one_or_none()
+    def get_layer_wms(self, el: Element, parent: Optional[main.TreeGroup] = None) -> main.LayerWMS:
+        name_el = el.find("Name")
+        assert name_el is not None
+        name = name_el.text
+
+        layer = cast(
+            Optional[main.LayerWMS],
+            self._request.dbsession.query(main.LayerWMS).filter(main.LayerWMS.name == name).one_or_none(),
+        )
 
         if layer is None:
             layer = main.LayerWMS()
 
             # TreeItem
-            layer.name = el.find("Name").text
+            layer.name = name
             layer.description = self._default_wms.description
             layer.metadatas = [main.Metadata(name=m.name, value=m.value) for m in self._default_wms.metadatas]
 
             # Layer
             layer.public = False
             layer.geo_table = None
             layer.exclude_properties = self._default_wms.exclude_properties
@@ -212,25 +320,25 @@
                     description=d.description,
                 )
                 for d in self._default_wms.dimensions
             ]
 
             # LayerWMS
             layer.ogc_server = self._ogc_server
-            layer.layer = el.find("Name").text
+            layer.layer = name
             layer.style = (
                 self._default_wms.style
-                if el.find("./Style/Name[.='{}']".format(self._default_wms.style)) is not None
+                if el.find(f"./Style/Name[.='{self._default_wms.style}']") is not None
                 else None
             )
             # layer.time_mode =
             # layer.time_widget =
 
             self._request.dbsession.add(layer)
-            if parent is None or isinstance(parent, main.Theme):
+            if not isinstance(parent, main.LayerGroup):
                 self._logger.info("Layer %s added as new layer with no parent", name)
             else:
                 layer.parents_relation.append(main.LayergroupTreeitem(group=parent))
                 self._logger.info("Layer %s added as new layer in group %s", name, parent.name)
             self._layers_added += 1
 
         else:
@@ -238,60 +346,64 @@
             if layer.ogc_server is not self._ogc_server:
                 self._logger.info(
                     "Layer %s: another layer already exists with the same name in OGC server %s",
                     name,
                     self._ogc_server.name,
                 )
 
+            parents = [parent] if isinstance(parent, main.LayerGroup) else []
+            if self._force_parents and layer.parents != parents:
+                layer.parents_relation = [main.LayergroupTreeitem(group=parent) for parent in parents]
+                self._logger.info("Layer %s moved to %s", name, parent.name if parent else "root")
+
         return layer
 
-    def wms_capabilities(self):
+    @functools.lru_cache()
+    def wms_capabilities(self) -> bytes:
         errors: Set[str] = set()
         url = get_url2(
-            "The OGC server '{}'".format(self._ogc_server.name),
+            f"The OGC server '{self._ogc_server.name}'",
             self._ogc_server.url,
             self._request,
             errors,
         )
         if url is None:
             raise Exception("\n".join(errors))
 
         # Add functionality params
         # sparams = get_mapserver_substitution_params(self.request)
-        # url = add_url_params(url, sparams)
+        # url.add_query(url, sparams)
 
-        url = add_url_params(
-            url,
+        url.add_query(
             {
                 "SERVICE": "WMS",
                 "VERSION": "1.1.1",
                 "REQUEST": "GetCapabilities",
-                "ROLE_ID": "0",
+                "ROLE_IDS": "0",
                 "USER_ID": "0",
             },
         )
 
         self._logger.info("Get WMS GetCapabilities from: %s", url)
 
         headers = {}
 
         # Add headers for Geoserver
         if self._ogc_server.auth == main.OGCSERVER_AUTH_GEOSERVER:
             headers["sec-username"] = "root"
             headers["sec-roles"] = "root"
 
-        response = requests.get(url, headers=headers, timeout=300)
+        response = requests.get(url.url(), headers=headers, timeout=300)
         self._logger.info("Got response %s in %.1fs.", response.status_code, response.elapsed.total_seconds())
         response.raise_for_status()
 
         # With WMS 1.3 it returns text/xml also in case of error :-(
         if response.headers.get("Content-Type", "").split(";")[0].strip() not in [
             "application/vnd.ogc.wms_xml",
             "text/xml",
         ]:
             raise Exception(
-                "GetCapabilities from URL {} returns a wrong Content-Type: {}\n{}".format(
-                    url, response.headers.get("Content-Type", ""), response.text
-                )
+                f"GetCapabilities from URL '{url}' returns a wrong Content-Type: "
+                f"{response.headers.get('Content-Type', '')}\n{response.text}"
             )
 
         return response.content
```

## c2cgeoportal_admin/schemas/dimensions.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -27,17 +25,21 @@
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 import colander
 from c2cgeoform.schema import GeoFormSchemaNode
 from deform.widget import MappingWidget, SequenceWidget
+from sqlalchemy.orm.attributes import InstrumentedAttribute
 
-from c2cgeoportal_admin import _
 from c2cgeoportal_commons.models.main import Dimension
 
-dimensions_schema_node = colander.SequenceSchema(
-    GeoFormSchemaNode(Dimension, name="dimension", widget=MappingWidget(template="dimension")),
-    name="dimensions",
-    title=_("Dimensions"),
-    widget=SequenceWidget(category="structural", template="dimensions"),
-)
+
+def dimensions_schema_node(prop: InstrumentedAttribute) -> colander.SequenceSchema:
+    """Get the scheme of the dimensions."""
+    return colander.SequenceSchema(
+        GeoFormSchemaNode(Dimension, name="dimension", widget=MappingWidget(template="dimension")),
+        name=prop.key,
+        title=prop.info["colanderalchemy"]["title"],
+        description=prop.info["colanderalchemy"]["description"],
+        widget=SequenceWidget(category="structural", template="dimensions"),
+    )
```

## c2cgeoportal_admin/schemas/functionalities.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -24,32 +22,75 @@
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
+from typing import Any, Dict, List
+
 import colander
 from c2cgeoform.ext.deform_ext import RelationCheckBoxListWidget
 from c2cgeoform.schema import GeoFormManyToManySchemaNode, manytomany_validator
-from sqlalchemy import select
+from sqlalchemy import inspect, select
+from sqlalchemy.orm.attributes import InstrumentedAttribute
+from sqlalchemy.orm.decl_api import DeclarativeMeta
 from sqlalchemy.sql.functions import concat
 
 from c2cgeoportal_commons.models.main import Functionality
 
-functionalities_schema_node = colander.SequenceSchema(
-    GeoFormManyToManySchemaNode(Functionality),
-    name="functionalities",
-    widget=RelationCheckBoxListWidget(
-        select([Functionality.id, concat(Functionality.name, "=", Functionality.value).label("label")]).alias(
-            "functionality_labels"
-        ),
-        "id",
-        "label",
-        order_by="label",
-        edit_url=lambda request, value: request.route_url(
-            "c2cgeoform_item", table="functionalities", id=value
-        ),
-    ),
-    validator=manytomany_validator,
-    missing=colander.drop,
-)
+
+def available_functionalities_for(settings: Dict[str, Any], model: DeclarativeMeta) -> List[Dict[str, Any]]:
+    """Return filtered list of functionality definitions."""
+    mapper = inspect(model)
+    relevant_for = {mapper.local_table.name}
+    return [
+        f
+        for f in settings["admin_interface"]["available_functionalities"]
+        if relevant_for & set(f.get("relevant_for", relevant_for))
+    ]
+
+
+def functionalities_widget(model: DeclarativeMeta) -> colander.deferred:
+    """Return a colander deferred which itself returns a widget for the functionalities field."""
+
+    def create_widget(node, kw):
+        del node
+
+        return RelationCheckBoxListWidget(
+            select(
+                [
+                    Functionality.id,
+                    concat(Functionality.name, "=", Functionality.value).label("label"),
+                ]
+            )
+            .where(
+                Functionality.name.in_(
+                    [f["name"] for f in available_functionalities_for(kw["request"].registry.settings, model)]
+                )
+            )
+            .alias("functionality_labels"),
+            "id",
+            "label",
+            order_by="label",
+            edit_url=lambda request, value: request.route_url(
+                "c2cgeoform_item", table="functionalities", id=value
+            ),
+        )
+
+    return colander.deferred(create_widget)
+
+
+def functionalities_schema_node(
+    prop: InstrumentedAttribute, model: DeclarativeMeta
+) -> colander.SequenceSchema:
+    """Get the schema of the functionalities."""
+
+    return colander.SequenceSchema(
+        GeoFormManyToManySchemaNode(Functionality),
+        name=prop.key,
+        title=prop.info["colanderalchemy"]["title"],
+        description=prop.info["colanderalchemy"].get("description"),
+        widget=functionalities_widget(model),
+        validator=manytomany_validator,
+        missing=colander.drop,
+    )
```

## c2cgeoportal_admin/schemas/interfaces.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -27,25 +25,31 @@
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 import colander
 from c2cgeoform.ext.deform_ext import RelationCheckBoxListWidget
 from c2cgeoform.schema import GeoFormManyToManySchemaNode, manytomany_validator
+from sqlalchemy.orm.attributes import InstrumentedAttribute
 
-from c2cgeoportal_admin import _
 from c2cgeoportal_commons.models.main import Interface
 
-interfaces_schema_node = colander.SequenceSchema(
-    GeoFormManyToManySchemaNode(Interface),
-    name="interfaces",
-    title=_("Interfaces"),
-    widget=RelationCheckBoxListWidget(
-        Interface,
-        "id",
-        "name",
-        order_by="name",
-        edit_url=lambda request, value: request.route_url("c2cgeoform_item", table="interfaces", id=value),
-    ),
-    validator=manytomany_validator,
-    missing=colander.drop,
-)
+
+def interfaces_schema_node(prop: InstrumentedAttribute) -> colander.SequenceSchema:
+    """Get the serializable representation of an interface."""
+    return colander.SequenceSchema(
+        GeoFormManyToManySchemaNode(Interface),
+        name=prop.key,
+        title=prop.info["colanderalchemy"]["title"],
+        description=prop.info["colanderalchemy"]["description"],
+        widget=RelationCheckBoxListWidget(
+            Interface,
+            "id",
+            "name",
+            order_by="name",
+            edit_url=lambda request, value: request.route_url(
+                "c2cgeoform_item", table="interfaces", id=value
+            ),
+        ),
+        validator=manytomany_validator,
+        missing=colander.drop,
+    )
```

## c2cgeoportal_admin/schemas/metadata.py

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 # Copyright (c) 2018-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
@@ -23,83 +21,106 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
-
 import json
-from typing import Any, Dict, List, Optional, cast
+from typing import Any, Dict, List, Optional, Set, Union, cast
 
 import colander
+import pyramid.request
 from c2cgeoform.schema import GeoFormSchemaNode
 from deform.widget import MappingWidget, SelectWidget, SequenceWidget, TextAreaWidget
+from sqlalchemy import inspect
+from sqlalchemy.orm.attributes import InstrumentedAttribute
+from sqlalchemy.orm.decl_api import DeclarativeMeta
+from sqlalchemy.orm.mapper import Mapper
 
 from c2cgeoportal_admin import _
 from c2cgeoportal_commons.lib.validators import url
 from c2cgeoportal_commons.models.main import Metadata
 
 
-@colander.deferred
-def metadata_definitions(node, kw):
-    del node
-    return {m["name"]: m for m in kw["request"].registry.settings["admin_interface"]["available_metadata"]}
+def get_relevant_for(model: Union[DeclarativeMeta, Mapper]) -> Set[str]:
+    """Return list of relevant_for values for passed class."""
+    mapper = inspect(model)
+    relevant_for = {mapper.local_table.name}  # or mapper.polymorphic_identity
+    if mapper.inherits:
+        relevant_for |= get_relevant_for(mapper.inherits)
+    return relevant_for
+
+
+def metadata_definitions(settings: Dict[str, Any], model: DeclarativeMeta) -> List[Dict[str, Any]]:
+    """Return filtered list metadata definitions."""
+    return [
+        m
+        for m in settings["admin_interface"]["available_metadata"]
+        if get_relevant_for(model) & set(m.get("relevant_for", ["treeitem"]))
+    ]
 
 
-class MetadataSelectWidget(SelectWidget):
-    """Extends class SelectWidget to support undefined metadatas.
+class MetadataSelectWidget(SelectWidget):  # type: ignore
+    """
+    Extends class SelectWidget to support undefined metadata.
 
     Override serialize to add option in values for current cstruct when needed.
     """
 
-    def serialize(self, field, cstruct, **kw):
+    def serialize(self, field: Any, cstruct: Any, **kw: Any) -> Any:
         values = kw.get("values", self.values)
         if isinstance(cstruct, str) and (cstruct, cstruct) not in values:
             values = values.copy()
             values.append((cstruct, cstruct))
         kw["values"] = values
         return super().serialize(field, cstruct, **kw)
 
 
-@colander.deferred
-def metadata_name_widget(node, kw):
-    del node
-    return MetadataSelectWidget(
-        values=[
-            (m["name"], m["name"])
-            for m in sorted(
-                kw["request"].registry.settings["admin_interface"]["available_metadata"],
-                key=lambda m: m["name"],
-            )
-        ]
-    )
+def metadata_name_widget(model: DeclarativeMeta) -> colander.deferred:
+    """Return a colander deferred which itself returns a widget for the metadata name field."""
+
+    def create_widget(node, kw):
+        del node
+        return MetadataSelectWidget(
+            values=[
+                (m["name"], m["name"])
+                for m in sorted(
+                    metadata_definitions(kw["request"].registry.settings, model),
+                    key=lambda m: cast(str, m["name"]),
+                )
+            ]
+        )
+
+    return colander.deferred(create_widget)
 
 
 def json_validator(node, value):
+    """Validate the value to be a valid JSON."""
     try:
         json.loads(value)
     except ValueError as e:
         raise colander.Invalid(node, _('Parser report: "{}"').format(str(e)))
 
 
 def regex_validator(node, value):
+    """Validate the value with a regexp."""
     definition = node.metadata_definitions.get(value["name"], {})
     if definition.get("type", "string") == "regex":
         validator = colander.Regex(definition["regex"], msg=_(definition["error_message"]))
         try:
             validator(node["string"], value["string"])
         except colander.Invalid as e:
             error = colander.Invalid(node)
             error.add(e, node.children.index(node["string"]))
-            raise error
+            raise error from e
 
 
-class BooleanMetadata(colander.Boolean):
-    """Boolean metadata values are stored as string in database"""
+class BooleanMetadata(colander.Boolean):  # type: ignore
+    """Boolean metadata values are stored as string in database."""
 
     def serialize(self, node, appstruct):
         if appstruct == "true":
             appstruct = True
         elif appstruct == "false":
             appstruct = False
         else:
@@ -111,37 +132,45 @@
         if appstruct is True:
             return "true"
         if appstruct is False:
             return "false"
         return None
 
 
-class MetadataSchemaNode(GeoFormSchemaNode):  # pylint: disable=abstract-method
+class MetadataSchemaNode(GeoFormSchemaNode):  # type: ignore # pylint: disable=abstract-method
+    """The metadata schema."""
 
     metadata_definitions: Optional[Dict[str, Any]] = None
 
-    def __init__(self, *args, **kw):
+    def __init__(self, *args: Any, **kw: Any):
         super().__init__(*args, **kw)
 
         self.available_types: List[str] = []
 
         self._add_value_node("string", colander.String())
         self._add_value_node("liste", colander.String())
         self._add_value_node("boolean", BooleanMetadata())
         self._add_value_node("int", colander.Int())
         self._add_value_node("float", colander.Float())
         self._add_value_node("url", colander.String(), validator=url)
         self._add_value_node(
             "json", colander.String(), widget=TextAreaWidget(rows=10), validator=json_validator
         )
 
-    def _add_value_node(self, type_name, colander_type, **kw):
+    def _add_value_node(self, type_name: str, colander_type: colander.SchemaType, **kw: Any) -> None:
         self.add_before(
             "description",
-            colander.SchemaNode(colander_type, name=type_name, title=_("Value"), missing=colander.null, **kw),
+            colander.SchemaNode(
+                colander_type,
+                name=type_name,
+                title=Metadata.value.info["colanderalchemy"]["title"],
+                description=Metadata.value.info["colanderalchemy"]["description"],
+                missing=colander.null,
+                **kw,
+            ),
         )
         self.available_types.append(type_name)
 
     def objectify(self, dict_, context=None):
         # depending on the type get the value from the right widget
         dict_["value"] = dict_[self._ui_type(dict_["name"])]
         return super().objectify(dict_, context)
@@ -149,28 +178,52 @@
     def dictify(self, obj):
         dict_ = super().dictify(obj)
         value = obj.value or colander.null
         # depending on the type set the value in the right widget
         dict_[self._ui_type(obj.name)] = value
         return dict_
 
-    def _ui_type(self, metadata_name: str):
+    def _ui_type(self, metadata_name: str) -> str:
         metadata_type = (
-            cast(Dict[str, Any], self.metadata_definitions).get(metadata_name, {}).get("type", "string")
+            cast(Dict[str, Dict[str, str]], self.metadata_definitions)
+            .get(metadata_name, {})
+            .get("type", "string")
         )
         return metadata_type if metadata_type in self.available_types else "string"
 
 
-metadatas_schema_node = colander.SequenceSchema(
-    MetadataSchemaNode(
-        Metadata,
-        name="metadata",
-        metadata_definitions=metadata_definitions,
-        validator=regex_validator,
-        widget=MappingWidget(template="metadata"),
-        overrides={"name": {"widget": metadata_name_widget}},
-    ),
-    name="metadatas",
-    title=_("Metadatas"),
-    metadata_definitions=metadata_definitions,
-    widget=SequenceWidget(template="metadatas", category="structural"),
-)
+def _translate_available_metadata(
+    available_metadata: Dict[str, Any], request: pyramid.request.Request
+) -> Dict[str, Any]:
+    result = {}
+    result.update(available_metadata)
+    result["description"] = request.localizer.translate(_(available_metadata.get("description", "").strip()))
+    return result
+
+
+def metadata_schema_node(prop: InstrumentedAttribute, model: DeclarativeMeta) -> colander.SequenceSchema:
+    """Get the schema of a collection of metadata."""
+
+    # Deferred which returns a dictionary with metadata name as key and metadata definition as value.
+    # Needed to get the metadata types on UI side.
+    metadata_definitions_dict = colander.deferred(
+        lambda node, kw: {
+            m["name"]: _translate_available_metadata(m, kw["request"])
+            for m in metadata_definitions(kw["request"].registry.settings, model)
+        }
+    )
+
+    return colander.SequenceSchema(
+        MetadataSchemaNode(
+            Metadata,
+            name="metadata",
+            metadata_definitions=metadata_definitions_dict,
+            validator=regex_validator,
+            widget=MappingWidget(template="metadata"),
+            overrides={"name": {"widget": metadata_name_widget(model)}},
+        ),
+        name=prop.key,
+        title=prop.info["colanderalchemy"]["title"],
+        description=prop.info["colanderalchemy"]["description"],
+        metadata_definitions=metadata_definitions_dict,
+        widget=SequenceWidget(template="metadatas", category="structural"),
+    )
```

## c2cgeoportal_admin/schemas/restriction_areas.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -27,27 +25,31 @@
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 import colander
 from c2cgeoform.ext.deform_ext import RelationCheckBoxListWidget
 from c2cgeoform.schema import GeoFormManyToManySchemaNode, manytomany_validator
+from sqlalchemy.orm.attributes import InstrumentedAttribute
 
-from c2cgeoportal_admin import _
 from c2cgeoportal_commons.models.main import RestrictionArea
 
-restrictionareas_schema_node = colander.SequenceSchema(
-    GeoFormManyToManySchemaNode(RestrictionArea),
-    name="restrictionareas",
-    title=_("Restriction areas"),
-    widget=RelationCheckBoxListWidget(
-        RestrictionArea,
-        "id",
-        "name",
-        order_by="name",
-        edit_url=lambda request, value: request.route_url(
-            "c2cgeoform_item", table="restriction_areas", id=value
+
+def restrictionareas_schema_node(prop: InstrumentedAttribute) -> colander.SequenceSchema:
+    """Get the schema of a restriction area."""
+    return colander.SequenceSchema(
+        GeoFormManyToManySchemaNode(RestrictionArea),
+        name=prop.key,
+        title=prop.info["colanderalchemy"]["title"],
+        description=prop.info["colanderalchemy"].get("description"),
+        widget=RelationCheckBoxListWidget(
+            RestrictionArea,
+            "id",
+            "name",
+            order_by="name",
+            edit_url=lambda request, value: request.route_url(
+                "c2cgeoform_item", table="restriction_areas", id=value
+            ),
         ),
-    ),
-    validator=manytomany_validator,
-    missing=colander.drop,
-)
+        validator=manytomany_validator,
+        missing=colander.drop,
+    )
```

## c2cgeoportal_admin/schemas/roles.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -27,22 +25,26 @@
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 import colander
 from c2cgeoform.ext.deform_ext import RelationCheckBoxListWidget
 from c2cgeoform.schema import GeoFormManyToManySchemaNode, manytomany_validator
+from sqlalchemy.orm.attributes import InstrumentedAttribute
 
 from c2cgeoportal_commons.models.main import Role
 
 
-def roles_schema_node(name):
+def roles_schema_node(prop: InstrumentedAttribute) -> colander.SequenceSchema:
+    """Get the schema of all the items."""
     return colander.SequenceSchema(
         GeoFormManyToManySchemaNode(Role),
-        name=name,
+        name=prop.key,
+        title=prop.info["colanderalchemy"]["title"],
+        description=prop.info["colanderalchemy"].get("description"),
         widget=RelationCheckBoxListWidget(
             Role,
             "id",
             "name",
             order_by="name",
             edit_url=lambda request, value: request.route_url("c2cgeoform_item", table="roles", id=value),
         ),
```

## c2cgeoportal_admin/schemas/treegroup.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2022, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -26,46 +24,55 @@
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 import logging
 from functools import partial
+from typing import Any, Dict, List, Optional
 
 import colander
+import pyramid.request
 from c2cgeoform.schema import GeoFormSchemaNode
 from sqlalchemy.orm import aliased
 from sqlalchemy.sql.expression import case, func
 
 from c2cgeoportal_admin import _
 from c2cgeoportal_admin.widgets import ChildrenWidget, ChildWidget
-from c2cgeoportal_commons.models.main import LayergroupTreeitem, TreeItem
+from c2cgeoportal_commons.lib.literal import Literal
+from c2cgeoportal_commons.models.main import LayergroupTreeitem, TreeGroup, TreeItem
 
 LOG = logging.getLogger(__name__)
 
 # Correspondence between TreeItem.item_type and route table segment
 ITEM_TYPE_ROUTE_MAP = {
     "theme": "themes",
     "group": "layer_groups",
     "layer": None,
     "l_wms": "layers_wms",
-    "l_wmts": "layers_wms",
+    "l_wmts": "layers_wmts",
 }
 
 
-class ChildSchemaNode(GeoFormSchemaNode):  # pylint: disable=abstract-method
+class ChildSchemaNode(GeoFormSchemaNode):  # type: ignore # pylint: disable=abstract-method
+    """Schema of the child nodes."""
+
     def objectify(self, dict_, context=None):
         if dict_.get("id", None):
             context = self.dbsession.query(LayergroupTreeitem).get(dict_["id"])
         context = super().objectify(dict_, context)
         context.treeitem = self.dbsession.query(TreeItem).get(dict_["treeitem_id"])
         return context
 
 
-def treeitems(node, kw, only_groups=False):  # pylint: disable=unused-argument
+def treeitems(
+    node: TreeGroup, kw: Dict[str, pyramid.request.Request], only_groups: bool = False
+) -> List[Dict[str, Any]]:
+    """Get a serializable representation of the tree items."""
+    del node
     dbsession = kw["request"].dbsession
 
     group = case([(func.count(LayergroupTreeitem.id) == 0, "Unlinked")], else_="Others")
 
     query = (
         dbsession.query(TreeItem, group)
         .distinct()
@@ -97,69 +104,83 @@
     if only_groups:
         query = query.filter(TreeItem.item_type == "group")
 
     return [
         {
             "id": item.id,
             "label": item.name,
-            "icon_class": "icon-{}".format(item.item_type),
+            "icon_class": f"icon-{item.item_type}",
             "edit_url": treeitem_edit_url(kw["request"], item),
             "group": group,
         }
         for item, group in query
     ]
 
 
 def children_validator(node, cstruct):
+    """Get the validator on the children nodes."""
     for dict_ in cstruct:
         if not dict_["treeitem_id"] in [item["id"] for item in node.candidates]:
             raise colander.Invalid(
                 node,
                 _("Value {} does not exist in table {} or is not allowed to avoid cycles").format(
                     dict_["treeitem_id"], TreeItem.__tablename__
                 ),
             )
 
 
-def base_deferred_parent_id_validator(node, kw, model):  # pylint: disable=unused-argument
+def base_deferred_parent_id_validator(node, kw, model):
+    """Get the validator on the parent node ID."""
+    del node
+
     def validator(node, cstruct):
         if kw["dbsession"].query(model).filter(model.id == cstruct).count() == 0:
-            raise colander.Invalid(
-                node, "Value {} does not exist in table {}".format(cstruct, model.__tablename__)
-            )
+            raise colander.Invalid(node, f"Value {cstruct} does not exist in table {model.__tablename__}")
 
     return validator
 
 
-def treeitem_edit_url(request, treeitem):
+def treeitem_edit_url(request: pyramid.request.Request, treeitem: TreeGroup) -> Optional[str]:
+    """Get the tree item editing URL."""
     if treeitem.item_type is None:
         return None
     table = ITEM_TYPE_ROUTE_MAP.get(treeitem.item_type, None)
     if table is None:
         LOG.warning("%s not found in ITEM_TYPE_ROUTE_MAP", treeitem.item_type)
         return None
-    return request.route_url(
+    return request.route_url(  # type: ignore
         "c2cgeoform_item",
         table=ITEM_TYPE_ROUTE_MAP[treeitem.item_type],
         id=treeitem.id,
     )
 
 
-def children_schema_node(only_groups=False):
+def children_schema_node(only_groups: bool = False) -> colander.SequenceSchema:
+    """Geth the sequence to the children nodes."""
     return colander.SequenceSchema(
         ChildSchemaNode(
             LayergroupTreeitem,
             name="layergroup_treeitem",
             widget=ChildWidget(
                 input_name="treeitem_id",
                 model=TreeItem,
                 label_field="name",
-                icon_class=lambda treeitem: "icon-{}".format(treeitem.item_type),
+                icon_class=lambda treeitem: f"icon-{treeitem.item_type}",
                 edit_url=treeitem_edit_url,
             ),
         ),
         name="children_relation",
         title=_("Children"),
+        description=Literal(
+            _(
+                """
+                <div class="help-block">
+                    <p>The ordered children elements.</p>
+                    <hr>
+                </div>
+                """
+            ),
+        ),
         candidates=colander.deferred(partial(treeitems, only_groups=only_groups)),
         validator=children_validator,
         widget=ChildrenWidget(child_input_name="treeitem_id", add_subitem=True, orderable=True),
     )
```

## c2cgeoportal_admin/schemas/treeitem.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2018-2020, Camptocamp SA
+# Copyright (c) 2018-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -34,14 +32,15 @@
 import deform
 
 from c2cgeoportal_admin.schemas.treegroup import base_deferred_parent_id_validator
 
 
 # Used for the creation of a new layer/layergroup from the layertree
 def parent_id_node(model):
+    """Get the scheme to the parent node ID."""
     return colander.SchemaNode(
         colander.Integer(),
         name="parent_id",
         missing=colander.drop,
         validator=colander.deferred(partial(base_deferred_parent_id_validator, model=model)),
         widget=deform.widget.HiddenWidget(),
     )
```

## c2cgeoportal_admin/static/layertree.css

```diff
@@ -60,15 +60,14 @@
 .jstree-grid-wrapper .jstree-grid-separator {
   display: none;
 }
 .jstree.jstree-grid-cell {
   padding-left: 0px;
 }
 
-
 .jstree-grid-wrapper .jstree-node,
 .jstree-grid-wrapper .jstree-grid-cell-regular {
   border-top: 1px solid #ddd;
 }
 .jstree-grid-wrapper .jstree-grid-cell-regular {
   height: 34px;
 }
@@ -111,15 +110,15 @@
   font-family: 'Glyphicons Halflings';
   font-style: normal;
   font-weight: 400;
   -webkit-font-smoothing: antialiased;
 }
 
 .jstree-open .jstree-icon.jstree-ocl:before {
-  content: "\e252";
+  content: '\e252';
 }
 .jstree-closed .jstree-icon.jstree-ocl:before {
-  content: "\e250";
+  content: '\e250';
 }
 .jstree-leaf .jstree-icon.jstree-ocl:before {
-  content: "";
+  content: '';
 }
```

## c2cgeoportal_admin/static/navbar.css

```diff
@@ -28,53 +28,54 @@
 @media (min-width: 992px) {
   .navbar-default .navbar-collapse {
     padding-left: 0px;
   }
 }
 
 @media (min-width: 992px) and (max-width: 1125px) {
-  .navbar-default .navbar-nav>li>a {
+  .navbar-default .navbar-nav > li > a {
     max-width: 8.5vw;
     overflow: hidden;
     text-overflow: ellipsis;
     white-space: nowrap;
   }
 }
 
 /*csslint important: false*/
 @media (max-width: 991px) {
-    .navbar-header {
-        float: none;
-    }
-    .navbar-left,.navbar-right {
-        float: none !important;
-    }
-    .navbar-toggle {
-        display: block;
-    }
-    .navbar-collapse {
-        border-top: 1px solid transparent;
-        box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
-    }
-    .navbar-fixed-top {
-        top: 0;
-        border-width: 0 0 1px;
-    }
-    .navbar-collapse.collapse {
-        display: none!important;
-    }
-    .navbar-nav {
-        float: none!important;
-        margin-top: 7.5px;
-    }
-    .navbar-nav>li {
-        float: none;
-    }
-    .navbar-nav>li>a {
-        padding-top: 10px;
-        padding-bottom: 10px;
-    }
-    .collapse.in{
-        display:block !important;
-    }
+  .navbar-header {
+    float: none;
+  }
+  .navbar-left,
+  .navbar-right {
+    float: none !important;
+  }
+  .navbar-toggle {
+    display: block;
+  }
+  .navbar-collapse {
+    border-top: 1px solid transparent;
+    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
+  }
+  .navbar-fixed-top {
+    top: 0;
+    border-width: 0 0 1px;
+  }
+  .navbar-collapse.collapse {
+    display: none !important;
+  }
+  .navbar-nav {
+    float: none !important;
+    margin-top: 7.5px;
+  }
+  .navbar-nav > li {
+    float: none;
+  }
+  .navbar-nav > li > a {
+    padding-top: 10px;
+    padding-bottom: 10px;
+  }
+  .collapse.in {
+    display: block !important;
+  }
 }
 /*csslint important: true*/
```

## c2cgeoportal_admin/static/theme.css

```diff
@@ -17,41 +17,43 @@
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
-@import "navbar.css";
+@import 'navbar.css';
 
-.nav>li>a {
+.nav > li > a {
   padding-left: 8px;
   padding-right: 8px;
 }
 
 .bootstrap-table th.actions,
-.bootstrap-table td.actions
-{
+.bootstrap-table td.actions {
   width: 30px;
 }
 
 .icon-theme:before {
-  content: "\e139";
+  content: '\e139';
 }
 .icon-group:before {
-  content: "\e118";
+  content: '\e118';
 }
 .icon-l_wms:before {
-  content: "\e060";
+  content: '\e060';
 }
 .icon-l_wmts:before {
-  content: "\e011";
+  content: '\e011';
+}
+.icon-mvt:before {
+  content: '\e011';
 }
 .icon-user:before {
-  content: "\e008";
+  content: '\e008';
 }
 
 .ms-res-ctn .ms-res-item {
   color: initial;
 }
 
 .item-theme,
@@ -70,7 +72,12 @@
 .item-theme .deform-close-button {
   visibility: hidden;
 }
 
 #layertree .alert-info {
   margin-top: 30px;
 }
+
+.item-functionalities .checkbox label {
+  overflow: hidden;
+  overflow-wrap: break-word;
+}
```

## c2cgeoportal_admin/templates/layertree.jinja2

```diff
@@ -33,35 +33,52 @@
 <script type="text/javascript" src="{{request.static_url('c2cgeoportal_admin:node_modules/jstreegrid/jstreegrid.js')}}"></script>
 <script type="text/javascript" src="{{request.static_url('c2cgeoportal_admin:node_modules/jquery.scrollintoview/jquery.scrollintoview.js')}}"></script>
 {% endblock extra_scripts %}
 
 {% block content %}
 <div id="layertree" class="container-fluid">
     <div id="toolbar">
-      <div class="btn-group">
-        {% if limit_exceeded %}
-        <button id="layertree-expand" type="button" class="btn btn-default"><span class="glyphicon glyphicon-chevron-down"></span> {{_("Expand all")}}</button>
-        {% endif %}
-        <button id="layertree-collapse" type="button" class="btn btn-default"><span class="glyphicon glyphicon-chevron-up"></span> {{_("Collapse all")}}</button>
-      </div>
-      <div class="btn-group">
-        <a id="layertree-ordering" class="btn btn-default" href="{{request.route_url('layertree_ordering')}}"><span class="glyphicon glyphicon-sort"></span> {{_("Edit themes order")}}</a>
-      </div>
+      <form class="form-inline">
+        <div class="form-group">
+          <label for="interface">{{ _("Interface") }}</label>
+          <select class="form-control" id="interface">
+            <option value="all">{{ _("All") }}</option>
+            {% for interface in interfaces %}
+            <option>{{ interface.name }}</option>
+            {% endfor %}
+          </select>
+        </div>
+        <div class="btn-group">
+          {% if limit_exceeded %}
+          <button id="layertree-expand" type="button" class="btn btn-default"><span class="glyphicon glyphicon-chevron-down"></span> {{_("Expand all")}}</button>
+          {% endif %}
+          <button id="layertree-collapse" type="button" class="btn btn-default"><span class="glyphicon glyphicon-chevron-up"></span> {{_("Collapse all")}}</button>
+        </div>
+        <div class="btn-group">
+          <a id="layertree-ordering" class="btn btn-default" href="{{request.route_url('layertree_ordering')}}"><span class="glyphicon glyphicon-sort"></span> {{_("Edit themes order")}}</a>
+        </div>
+      </form>
     </div>
 
     <div id="tree"></div>
 
     <script type="text/javascript">
     $(function () {
       const $jstree = $('#tree').jstree({
         core: {
           data: function(node, callback) {
             var url = "{{ request.route_url('layertree_children') }}";
+            let separator = '?';
             if (node.id != '#') {
               url += "?group_id=" + node.data.id + "&path=" + node.id;
+              separator = '&';
+            }
+            const interface = $('#interface')[0].value;
+            if (interface != 'all') {
+              url += separator + "interface=" + interface;
             }
             $.ajax({ url: url })
             .done(function(data) {
               callback.call(this, data.map(function(item) {
                 return {
                   id: item.path,
                   text: '&nbsp;' + item.name,
@@ -222,13 +239,18 @@
         $jstree.jstree(true).close_all();
       });
 
       $(window).resize(function() {
         $('.jstree-grid-wrapper').height($(window).height() - $('nav').height() - $('#toolbar').height() - 50);
         $('.jstree-grid-wrapper').width('100%');
       });
+
+      const interfaceField = $('#interface');
+      interfaceField.on('change', function(e) {
+        $jstree.jstree(true).refresh();
+      });
     });
     </script>
 
 </div>
 
 {% endblock content %}
```

## c2cgeoportal_admin/templates/navigation_navbar.jinja2

```diff
@@ -146,49 +146,116 @@
 00000910: 6b65 7927 5d29 7d7d 223e 7b7b 7265 7175  key'])}}">{{requ
 00000920: 6573 742e 6c6f 6361 6c69 7a65 722e 7472  est.localizer.tr
 00000930: 616e 736c 6174 6528 7461 626c 655b 2770  anslate(table['p
 00000940: 6c75 7261 6c27 5d29 7d7d 3c2f 613e 0a20  lural'])}}</a>. 
 00000950: 2020 2020 2020 203c 2f6c 693e 0a20 2020         </li>.   
 00000960: 2020 2020 207b 2520 656e 6466 6f72 2025       {% endfor %
 00000970: 7d0a 2020 2020 2020 3c2f 756c 3e0a 0a20  }.      </ul>.. 
-00000980: 2020 2020 203c 756c 2063 6c61 7373 3d22       <ul class="
-00000990: 6e61 7620 6e61 7662 6172 2d6e 6176 206e  nav navbar-nav n
-000009a0: 6176 6261 722d 7269 6768 7422 3e0a 2020  avbar-right">.  
-000009b0: 2020 2020 2020 3c6c 6920 6964 3d22 6c61        <li id="la
-000009c0: 6e67 7561 6765 2d64 726f 7064 6f77 6e22  nguage-dropdown"
-000009d0: 2063 6c61 7373 3d22 6472 6f70 646f 776e   class="dropdown
-000009e0: 223e 0a20 2020 2020 2020 2020 203c 6120  ">.          <a 
-000009f0: 6872 6566 3d22 2322 2063 6c61 7373 3d22  href="#" class="
-00000a00: 6472 6f70 646f 776e 2d74 6f67 676c 6522  dropdown-toggle"
-00000a10: 2064 6174 612d 746f 6767 6c65 3d22 6472   data-toggle="dr
-00000a20: 6f70 646f 776e 2220 726f 6c65 3d22 6275  opdown" role="bu
-00000a30: 7474 6f6e 2220 6172 6961 2d68 6173 706f  tton" aria-haspo
-00000a40: 7075 703d 2274 7275 6522 2061 7269 612d  pup="true" aria-
-00000a50: 6578 7061 6e64 6564 3d22 6661 6c73 6522  expanded="false"
-00000a60: 3e7b 7b72 6571 7565 7374 2e6c 6f63 616c  >{{request.local
-00000a70: 655f 6e61 6d65 7d7d 203c 7370 616e 2063  e_name}} <span c
-00000a80: 6c61 7373 3d22 6361 7265 7422 3e3c 2f73  lass="caret"></s
-00000a90: 7061 6e3e 3c2f 613e 0a20 2020 2020 2020  pan></a>.       
-00000aa0: 2020 203c 756c 2063 6c61 7373 3d22 6472     <ul class="dr
-00000ab0: 6f70 646f 776e 2d6d 656e 7522 3e0a 2020  opdown-menu">.  
-00000ac0: 2020 2020 2020 2020 2020 7b25 2066 6f72            {% for
-00000ad0: 206c 6f63 616c 6520 696e 2072 6571 7565   locale in reque
-00000ae0: 7374 2e72 6567 6973 7472 792e 7365 7474  st.registry.sett
-00000af0: 696e 6773 5b27 6176 6169 6c61 626c 655f  ings['available_
-00000b00: 6c6f 6361 6c65 5f6e 616d 6573 275d 2025  locale_names'] %
-00000b10: 7d0a 2020 2020 2020 2020 2020 2020 3c6c  }.            <l
-00000b20: 693e 3c61 2068 7265 663d 227b 7b72 6571  i><a href="{{req
-00000b30: 7565 7374 2e72 6f75 7465 5f75 726c 2827  uest.route_url('
-00000b40: 6332 6367 656f 666f 726d 5f6c 6f63 616c  c2cgeoform_local
-00000b50: 6527 2c20 5f71 7565 7279 3d28 2827 6c61  e', _query=(('la
-00000b60: 6e67 7561 6765 272c 206c 6f63 616c 6529  nguage', locale)
-00000b70: 2c29 297d 7d22 3e7b 7b6c 6f63 616c 657d  ,))}}">{{locale}
-00000b80: 7d3c 2f61 3e3c 2f6c 693e 0a20 2020 2020  }</a></li>.     
-00000b90: 2020 2020 2020 207b 2520 656e 6466 6f72         {% endfor
-00000ba0: 2025 7d0a 2020 2020 2020 2020 2020 3c2f   %}.          </
-00000bb0: 756c 3e0a 2020 2020 2020 2020 3c2f 6c69  ul>.        </li
-00000bc0: 3e0a 2020 2020 2020 3c2f 756c 3e0a 2020  >.      </ul>.  
-00000bd0: 2020 3c2f 6469 763e 3c21 2d2d 202f 2e6e    </div><!-- /.n
-00000be0: 6176 6261 722d 636f 6c6c 6170 7365 202d  avbar-collapse -
-00000bf0: 2d3e 0a20 203c 2f64 6976 3e3c 212d 2d20  ->.  </div><!-- 
-00000c00: 2f2e 636f 6e74 6169 6e65 722d 666c 7569  /.container-flui
-00000c10: 6420 2d2d 3e0a 3c2f 6e61 763e 0a         d -->.</nav>.
+00000980: 2020 2020 203c 6275 7474 6f6e 2069 643d       <button id=
+00000990: 2268 656c 702d 6275 7474 6f6e 2220 7479  "help-button" ty
+000009a0: 7065 3d22 6275 7474 6f6e 2220 636c 6173  pe="button" clas
+000009b0: 733d 2262 746e 2062 746e 2d64 6566 6175  s="btn btn-defau
+000009c0: 6c74 206e 6176 6261 722d 6274 6e20 6e61  lt navbar-btn na
+000009d0: 7662 6172 2d72 6967 6874 223e 7b7b 5f28  vbar-right">{{_(
+000009e0: 2253 686f 7720 6865 6c70 2229 7d7d 3c2f  "Show help")}}</
+000009f0: 6275 7474 6f6e 3e0a 2020 2020 2020 3c73  button>.      <s
+00000a00: 6372 6970 743e 0a20 2020 2020 2024 2866  cript>.      $(f
+00000a10: 756e 6374 696f 6e28 2920 7b0a 2020 2020  unction() {.    
+00000a20: 2020 2020 636f 6e73 7420 6b65 7920 3d20      const key = 
+00000a30: 2761 646d 696e 5368 6f77 4865 6c70 273b  'adminShowHelp';
+00000a40: 0a0a 2020 2020 2020 2020 636f 6e73 7420  ..        const 
+00000a50: 6765 7443 7572 7265 6e74 5661 6c75 6520  getCurrentValue 
+00000a60: 3d20 6675 6e63 7469 6f6e 2829 207b 0a20  = function() {. 
+00000a70: 2020 2020 2020 2020 202f 2f20 4765 7420           // Get 
+00000a80: 6375 7272 656e 7420 7661 6c75 6520 6672  current value fr
+00000a90: 6f6d 206c 6f63 616c 5374 6f72 6167 650a  om localStorage.
+00000aa0: 2020 2020 2020 2020 2020 2f2f 2054 7275            // Tru
+00000ab0: 6520 6279 2064 6566 6175 6c74 0a20 2020  e by default.   
+00000ac0: 2020 2020 2020 2072 6574 7572 6e20 6c6f         return lo
+00000ad0: 6361 6c53 746f 7261 6765 2e67 6574 4974  calStorage.getIt
+00000ae0: 656d 286b 6579 2920 213d 3d20 2766 616c  em(key) !== 'fal
+00000af0: 7365 270a 2020 2020 2020 2020 7d0a 0a20  se'.        }.. 
+00000b00: 2020 2020 2020 2063 6f6e 7374 2061 7070         const app
+00000b10: 6c79 203d 2066 756e 6374 696f 6e28 7661  ly = function(va
+00000b20: 6c75 6529 207b 0a20 2020 2020 2020 2020  lue) {.         
+00000b30: 202f 2f20 4170 706c 7920 736f 6d65 2076   // Apply some v
+00000b40: 616c 7565 206f 6e20 5549 0a20 2020 2020  alue on UI.     
+00000b50: 2020 2020 2069 6620 2876 616c 7565 2920       if (value) 
+00000b60: 7b0a 2020 2020 2020 2020 2020 2020 2428  {.            $(
+00000b70: 2223 6865 6c70 2d62 7574 746f 6e22 292e  "#help-button").
+00000b80: 6164 6443 6c61 7373 2822 6163 7469 7665  addClass("active
+00000b90: 2229 0a20 2020 2020 2020 2020 2020 2024  ").            $
+00000ba0: 2822 2e68 656c 702d 626c 6f63 6b22 292e  (".help-block").
+00000bb0: 7265 6d6f 7665 436c 6173 7328 2268 6964  removeClass("hid
+00000bc0: 6465 6e22 290a 2020 2020 2020 2020 2020  den").          
+00000bd0: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
+00000be0: 2020 2020 2024 2822 2368 656c 702d 6275       $("#help-bu
+00000bf0: 7474 6f6e 2229 2e72 656d 6f76 6543 6c61  tton").removeCla
+00000c00: 7373 2822 6163 7469 7665 2229 0a20 2020  ss("active").   
+00000c10: 2020 2020 2020 2020 2024 2822 2e68 656c           $(".hel
+00000c20: 702d 626c 6f63 6b22 292e 6164 6443 6c61  p-block").addCla
+00000c30: 7373 2822 6869 6464 656e 2229 0a20 2020  ss("hidden").   
+00000c40: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00000c50: 207d 0a0a 2020 2020 2020 2020 2428 2223   }..        $("#
+00000c60: 6865 6c70 2d62 7574 746f 6e22 292e 636c  help-button").cl
+00000c70: 6963 6b28 6675 6e63 7469 6f6e 2829 207b  ick(function() {
+00000c80: 0a20 2020 2020 2020 2020 202f 2f20 546f  .          // To
+00000c90: 6767 6c65 2076 616c 7565 2069 6e20 6c6f  ggle value in lo
+00000ca0: 6361 6c53 746f 7261 6765 2061 6e64 2061  calStorage and a
+00000cb0: 7070 6c79 206f 6e20 5549 0a20 2020 2020  pply on UI.     
+00000cc0: 2020 2020 206c 6f63 616c 5374 6f72 6167       localStorag
+00000cd0: 652e 7365 7449 7465 6d28 6b65 792c 2067  e.setItem(key, g
+00000ce0: 6574 4375 7272 656e 7456 616c 7565 2829  etCurrentValue()
+00000cf0: 203f 2027 6661 6c73 6527 203a 2027 7472   ? 'false' : 'tr
+00000d00: 7565 2729 3b0a 2020 2020 2020 2020 2020  ue');.          
+00000d10: 6170 706c 7928 6765 7443 7572 7265 6e74  apply(getCurrent
+00000d20: 5661 6c75 6528 2929 0a20 2020 2020 2020  Value()).       
+00000d30: 207d 290a 0a20 2020 2020 2020 202f 2f20   })..        // 
+00000d40: 4170 706c 7920 6375 7272 656e 7420 7661  Apply current va
+00000d50: 6c75 6520 6672 6f6d 206c 6f63 616c 5374  lue from localSt
+00000d60: 6f72 6167 6520 6f6e 2055 490a 2020 2020  orage on UI.    
+00000d70: 2020 2020 6170 706c 7928 6765 7443 7572      apply(getCur
+00000d80: 7265 6e74 5661 6c75 6528 2929 0a20 2020  rentValue()).   
+00000d90: 2020 207d 293b 0a20 2020 2020 203c 2f73     });.      </s
+00000da0: 6372 6970 743e 0a0a 2020 2020 2020 3c75  cript>..      <u
+00000db0: 6c20 636c 6173 733d 226e 6176 206e 6176  l class="nav nav
+00000dc0: 6261 722d 6e61 7620 6e61 7662 6172 2d72  bar-nav navbar-r
+00000dd0: 6967 6874 223e 0a20 2020 2020 2020 203c  ight">.        <
+00000de0: 6c69 2069 643d 226c 616e 6775 6167 652d  li id="language-
+00000df0: 6472 6f70 646f 776e 2220 636c 6173 733d  dropdown" class=
+00000e00: 2264 726f 7064 6f77 6e22 3e0a 2020 2020  "dropdown">.    
+00000e10: 2020 2020 2020 3c61 2068 7265 663d 2223        <a href="#
+00000e20: 2220 636c 6173 733d 2264 726f 7064 6f77  " class="dropdow
+00000e30: 6e2d 746f 6767 6c65 2220 6461 7461 2d74  n-toggle" data-t
+00000e40: 6f67 676c 653d 2264 726f 7064 6f77 6e22  oggle="dropdown"
+00000e50: 2072 6f6c 653d 2262 7574 746f 6e22 2061   role="button" a
+00000e60: 7269 612d 6861 7370 6f70 7570 3d22 7472  ria-haspopup="tr
+00000e70: 7565 2220 6172 6961 2d65 7870 616e 6465  ue" aria-expande
+00000e80: 643d 2266 616c 7365 223e 7b7b 7265 7175  d="false">{{requ
+00000e90: 6573 742e 6c6f 6361 6c65 5f6e 616d 657d  est.locale_name}
+00000ea0: 7d20 3c73 7061 6e20 636c 6173 733d 2263  } <span class="c
+00000eb0: 6172 6574 223e 3c2f 7370 616e 3e3c 2f61  aret"></span></a
+00000ec0: 3e0a 2020 2020 2020 2020 2020 3c75 6c20  >.          <ul 
+00000ed0: 636c 6173 733d 2264 726f 7064 6f77 6e2d  class="dropdown-
+00000ee0: 6d65 6e75 223e 0a20 2020 2020 2020 2020  menu">.         
+00000ef0: 2020 207b 2520 666f 7220 6c6f 6361 6c65     {% for locale
+00000f00: 2069 6e20 7265 7175 6573 742e 7265 6769   in request.regi
+00000f10: 7374 7279 2e73 6574 7469 6e67 735b 2761  stry.settings['a
+00000f20: 7661 696c 6162 6c65 5f6c 6f63 616c 655f  vailable_locale_
+00000f30: 6e61 6d65 7327 5d20 257d 0a20 2020 2020  names'] %}.     
+00000f40: 2020 2020 2020 203c 6c69 3e3c 6120 6872         <li><a hr
+00000f50: 6566 3d22 7b7b 7265 7175 6573 742e 726f  ef="{{request.ro
+00000f60: 7574 655f 7572 6c28 2763 3263 6765 6f66  ute_url('c2cgeof
+00000f70: 6f72 6d5f 6c6f 6361 6c65 272c 205f 7175  orm_locale', _qu
+00000f80: 6572 793d 2828 276c 616e 6775 6167 6527  ery=(('language'
+00000f90: 2c20 6c6f 6361 6c65 292c 2929 7d7d 223e  , locale),))}}">
+00000fa0: 7b7b 6c6f 6361 6c65 7d7d 3c2f 613e 3c2f  {{locale}}</a></
+00000fb0: 6c69 3e0a 2020 2020 2020 2020 2020 2020  li>.            
+00000fc0: 7b25 2065 6e64 666f 7220 257d 0a20 2020  {% endfor %}.   
+00000fd0: 2020 2020 2020 203c 2f75 6c3e 0a20 2020         </ul>.   
+00000fe0: 2020 2020 203c 2f6c 693e 0a20 2020 2020       </li>.     
+00000ff0: 203c 2f75 6c3e 0a20 2020 203c 2f64 6976   </ul>.    </div
+00001000: 3e3c 212d 2d20 2f2e 6e61 7662 6172 2d63  ><!-- /.navbar-c
+00001010: 6f6c 6c61 7073 6520 2d2d 3e0a 2020 3c2f  ollapse -->.  </
+00001020: 6469 763e 3c21 2d2d 202f 2e63 6f6e 7461  div><!-- /.conta
+00001030: 696e 6572 2d66 6c75 6964 202d 2d3e 0a3c  iner-fluid -->.<
+00001040: 2f6e 6176 3e0a                           /nav>.
```

## c2cgeoportal_admin/templates/ogcserver_synchronize.jinja2

```diff
@@ -55,14 +55,26 @@
       <p>Download the WMS Capabilities and for each &lt;Layer>&gt; element:</p>
       <ul>
         <li>if the <code>&lt;Layer&gt;</code> element does not contains any other <code>&lt;Layer&gt;</code> element, it will create a <code>LayerWMS</code> object;</li>
         <li>else if the Layer element is at top level, it will create a <code>Theme</code> object;</li>
         <li>else it will create a <code>Group</code> object.</li>
       </ul>
       <form method="POST" class="deform" id="form-synchronize">
+        <div class="form-group">
+            <input type="checkbox" name="force-parents" id="force-parents-field">
+            <label for="force-parents-field" class="control-label">{{_("Force parents re-initialization.")}}</label>
+        </div>
+        <div class="form-group">
+            <input type="checkbox" name="force-ordering" id="force-ordering-field">
+            <label for="force-ordering-field" class="control-label">{{_("Force children sorting, current server at top and other servers at bottom.")}}</label>
+        </div>
+        <div class="form-group">
+            <input type="checkbox" name="clean" id="clean">
+            <label for="clean" class="control-label">{{_("Remove unexisting layers and empty groups.")}}</label>
+        </div>
         <button type="submit" name="synchronize" class="btn btn-primary">{{_("Synchronize")}}</button>
       </form>
     </div>
   </div>
 
   {% if success %}
   <div class="alert alert-success">
```

## c2cgeoportal_admin/templates/widgets/metadata.pt

```diff
@@ -71,21 +71,27 @@
        const $name = $('#' + oid);
        const $metadataItem = $name.closest('.item-metadata');
 
        var updateType = function() {
          $metadataItem.find('.col-value .form-group').hide();
          $metadataItem.find('.col-value .form-group .form-control').attr('disabled', true);
 
-         var type = (c2cgeoportalAdmin.metadata_definitions[$name.val()] || {}).type || 'string';
+         var metadataDef = c2cgeoportalAdmin.metadata_definitions[$name.val()] || {};
+         var type = metadataDef.type || 'string';
+         var description = metadataDef.description || '';
+
          $typedFormgroup = $metadataItem.find('.item-' + type);
          if ($typedFormgroup.length == 0) {
            $typedFormgroup = $metadataItem.find('.item-string');
          }
          $typedFormgroup.show();
          $typedFormgroup.find('.form-control').attr('disabled', false);
+
+         $helpBlock = $typedFormgroup.find('p.help-block');
+         $helpBlock.text(description);
        };
        $name.change(function() {
          updateType();
        });
        updateType();
      }
    );
```

## c2cgeoportal_admin/views/dimension_layers.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -26,33 +24,36 @@
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
 from itertools import groupby
+from typing import cast
 
+import sqlalchemy
 from c2cgeoform.views.abstract_views import ListField
 from sqlalchemy.orm import subqueryload
 
 from c2cgeoportal_admin.views.layers import LayerViews
 from c2cgeoportal_commons.models.main import DimensionLayer
 
 _list_field = partial(ListField, DimensionLayer)
 
 
 class DimensionLayerViews(LayerViews):
+    """The layer with dimensions administration view."""
 
     _extra_list_fields = [
         _list_field(
             "dimensions",
             renderer=lambda layer_wms: "; ".join(
                 [
-                    "{}: {}".format(group[0], ", ".join([d.value or "NULL" for d in group[1]]))
-                    for group in groupby(layer_wms.dimensions, lambda d: d.name)
+                    f"{group[0]}: {', '.join([d.value or 'NULL' for d in group[1]])}"
+                    for group in groupby(layer_wms.dimensions, lambda d: cast(str, d.name))
                 ]
             ),
         )
     ] + LayerViews._extra_list_fields
 
-    def _base_query(self, query):
+    def _base_query(self, query: sqlalchemy.orm.query.Query) -> sqlalchemy.orm.query.Query:
         return super()._base_query(query.options(subqueryload("dimensions")))
```

## c2cgeoportal_admin/views/functionalities.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -25,28 +23,56 @@
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
+from typing import Any, Dict
 
+import colander
+import pyramid.request
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import AbstractViews, ListField
+from deform.widget import FormWidget
 from pyramid.view import view_config, view_defaults
 
+from c2cgeoportal_admin import _
 from c2cgeoportal_commons.models.main import Functionality
 
 _list_field = partial(ListField, Functionality)
 
-base_schema = GeoFormSchemaNode(Functionality)
+
+def _translate_available_functionality(
+    available_functionality: Dict[str, Any], request: pyramid.request.Request
+) -> Dict[str, Any]:
+    result = {}
+    result.update(available_functionality)
+    result["description"] = request.localizer.translate(
+        _(available_functionality.get("description", "").strip())
+    )
+    return result
+
+
+base_schema = GeoFormSchemaNode(
+    Functionality,
+    widget=FormWidget(fields_template="functionality_fields"),
+    functionalities=colander.deferred(
+        lambda node, kw: {
+            f["name"]: _translate_available_functionality(f, kw["request"])
+            for f in kw["request"].registry.settings["admin_interface"]["available_functionalities"]
+        },
+    ),
+)
 
 
 @view_defaults(match_param="table=functionalities")
-class FunctionalityViews(AbstractViews):
+class FunctionalityViews(AbstractViews):  # type: ignore
+    """The functionality administration view."""
+
     _list_fields = [_list_field("id"), _list_field("name"), _list_field("description"), _list_field("value")]
     _id_field = "id"
     _model = Functionality
     _base_schema = base_schema
 
     @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
     def index(self):
```

## c2cgeoportal_admin/views/home.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -24,14 +22,16 @@
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
+import pyramid.request
 from pyramid.httpexceptions import HTTPFound
 from pyramid.view import view_config
 
 
-@view_config(route_name="admin")
-def home_view(request):
+@view_config(route_name="admin")  # type: ignore  # type: ignore
+def home_view(request: pyramid.request.Request) -> HTTPFound:
+    """Get the main administration view, redirect to the layertree."""
     return HTTPFound(request.route_url("layertree", application="admin"))
```

## c2cgeoportal_admin/views/interfaces.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -38,27 +36,27 @@
 
 _list_field = partial(ListField, Interface)
 
 base_schema = GeoFormSchemaNode(Interface)
 
 
 @view_defaults(match_param="table=interfaces")
-class InterfacesViews(AbstractViews):
+class InterfacesViews(AbstractViews):  # type: ignore
+    """The interface administration view."""
+
     _list_fields = [
         _list_field("id"),
         _list_field("name"),
         _list_field("description"),
         _list_field(
             "layers", renderer=lambda interface: ", ".join([layer.name or "" for layer in interface.layers])
         ),
         _list_field(
             "theme",
-            renderer=lambda interface: ", ".join(
-                ["{}-{}".format(t.name, t.name) or "" for t in interface.theme]
-            ),
+            renderer=lambda interface: ", ".join([f"{t.name}-{t.name}" or "" for t in interface.theme]),
         ),
     ]
     _id_field = "id"
     _model = Interface
     _base_schema = base_schema
 
     @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
```

## c2cgeoportal_admin/views/layer_groups.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -25,48 +23,48 @@
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
+from typing import Optional
 
+import sqlalchemy
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import ListField
 from deform.widget import FormWidget
 from pyramid.view import view_config, view_defaults
 
-from c2cgeoportal_admin.schemas.metadata import metadatas_schema_node
+from c2cgeoportal_admin.schemas.metadata import metadata_schema_node
 from c2cgeoportal_admin.schemas.treegroup import children_schema_node
 from c2cgeoportal_admin.schemas.treeitem import parent_id_node
 from c2cgeoportal_admin.views.treeitems import TreeItemViews
 from c2cgeoportal_commons.models.main import LayerGroup, TreeGroup
 
 _list_field = partial(ListField, LayerGroup)
 
-
 base_schema = GeoFormSchemaNode(LayerGroup, widget=FormWidget(fields_template="layer_group_fields"))
 base_schema.add(children_schema_node())
-base_schema.add(metadatas_schema_node.clone())
+base_schema.add(metadata_schema_node(LayerGroup.metadatas, LayerGroup))
 base_schema.add_unique_validator(LayerGroup.name, LayerGroup.id)
-base_schema.add(parent_id_node(TreeGroup))
+base_schema.add(parent_id_node(TreeGroup))  # type: ignore
 
 
 @view_defaults(match_param="table=layer_groups")
 class LayerGroupsViews(TreeItemViews):
+    """The layer group administration view."""
 
-    _list_fields = (
-        TreeItemViews._list_fields + [_list_field("is_expanded")] + TreeItemViews._extra_list_fields
-    )
+    _list_fields = TreeItemViews._list_fields + TreeItemViews._extra_list_fields
 
     _id_field = "id"
     _model = LayerGroup
     _base_schema = base_schema
 
-    def _base_query(self, query=None):
+    def _base_query(self, query: Optional[sqlalchemy.orm.query.Query] = None) -> sqlalchemy.orm.query.Query:
         return super()._base_query(self._request.dbsession.query(LayerGroup).distinct())
 
     @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
     def index(self):
         return super().index()
 
     @view_config(route_name="c2cgeoform_grid", renderer="fast_json")
```

## c2cgeoportal_admin/views/layers.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -25,48 +23,51 @@
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
+from typing import cast
 
+import sqlalchemy
 from c2cgeoform.views.abstract_views import ListField
 from sqlalchemy.orm import subqueryload
 
 from c2cgeoportal_admin.views.treeitems import TreeItemViews
 from c2cgeoportal_commons.models.main import Interface, Layer
 
 _list_field = partial(ListField, Layer)
 
 
 class LayerViews(TreeItemViews):
+    """The layer administration view."""
 
     _list_fields = TreeItemViews._list_fields + [
         _list_field("public"),
         _list_field("geo_table"),
         _list_field("exclude_properties"),
     ]
 
     _extra_list_fields = [
         _list_field(
             "interfaces",
             renderer=lambda layer_wms: ", ".join(
-                [i.name or "" for i in sorted(layer_wms.interfaces, key=lambda i: i.name)]
+                [i.name or "" for i in sorted(layer_wms.interfaces, key=lambda i: cast(str, i.name))]
             ),
             sort_column=Interface.name,
             filter_column=Interface.name,
         ),
         _list_field(
             "restrictionareas",
             renderer=lambda layer_wms: ", ".join(
-                [r.name or "" for r in sorted(layer_wms.restrictionareas, key=lambda r: r.name)]
+                [r.name or "" for r in sorted(layer_wms.restrictionareas, key=lambda r: cast(str, r.name))]
             ),
         ),
     ] + TreeItemViews._extra_list_fields
 
-    def _base_query(self, query):
+    def _base_query(self, query: sqlalchemy.orm.query.Query) -> sqlalchemy.orm.query.Query:
         return super()._base_query(
-            query.outerjoin("interfaces")
+            query.outerjoin(Layer.interfaces)
             .options(subqueryload("interfaces"))
             .options(subqueryload("restrictionareas"))
         )
```

## c2cgeoportal_admin/views/layers_vectortiles.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -25,64 +23,86 @@
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
+from typing import Optional
 
+import sqlalchemy
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import ListField
 from deform.widget import FormWidget
+from pyramid.httpexceptions import HTTPNotFound
 from pyramid.view import view_config, view_defaults
 
+from c2cgeoportal_admin import _
 from c2cgeoportal_admin.schemas.interfaces import interfaces_schema_node
-from c2cgeoportal_admin.schemas.metadata import metadatas_schema_node
+from c2cgeoportal_admin.schemas.metadata import metadata_schema_node
 from c2cgeoportal_admin.schemas.restriction_areas import restrictionareas_schema_node
 from c2cgeoportal_admin.schemas.treeitem import parent_id_node
 from c2cgeoportal_admin.views.dimension_layers import DimensionLayerViews
+from c2cgeoportal_commons.lib.literal import Literal
 from c2cgeoportal_commons.models.main import LayerGroup, LayerVectorTiles
 
 _list_field = partial(ListField, LayerVectorTiles)
 
 
 base_schema = GeoFormSchemaNode(LayerVectorTiles, widget=FormWidget(fields_template="layer_fields"))
-base_schema.add(metadatas_schema_node.clone())
-base_schema.add(interfaces_schema_node.clone())
-base_schema.add(restrictionareas_schema_node.clone())
+base_schema.add(metadata_schema_node(LayerVectorTiles.metadatas, LayerVectorTiles))
+base_schema.add(interfaces_schema_node(LayerVectorTiles.interfaces))
+base_schema.add(restrictionareas_schema_node(LayerVectorTiles.restrictionareas))
 base_schema.add_unique_validator(LayerVectorTiles.name, LayerVectorTiles.id)
-base_schema.add(parent_id_node(LayerGroup))
+base_schema.add(parent_id_node(LayerGroup))  # type: ignore
 
 
 @view_defaults(match_param="table=layers_vectortiles")
 class LayerVectorTilesViews(DimensionLayerViews):
+    """The vector tiles administration view."""
+
     _list_fields = (
         DimensionLayerViews._list_fields
         + [_list_field("style"), _list_field("xyz")]
         + DimensionLayerViews._extra_list_fields
     )
     _id_field = "id"
     _model = LayerVectorTiles
     _base_schema = base_schema
 
-    def _base_query(self, query=None):
+    def _base_query(self, query: Optional[sqlalchemy.orm.query.Query] = None) -> sqlalchemy.orm.query.Query:
         del query
         return super()._base_query(self._request.dbsession.query(LayerVectorTiles).distinct())
 
     @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
     def index(self):
         return super().index()
 
     @view_config(route_name="c2cgeoform_grid", renderer="fast_json")
     def grid(self):
         return super().grid()
 
+    def schema(self) -> GeoFormSchemaNode:
+        try:
+            obj = self._get_object()
+        except HTTPNotFound:
+            obj = None
+
+        schema = self._base_schema.clone()
+        schema["style"].description = Literal(
+            _("{}<br>Current runtime value is: {}").format(
+                schema["style"].description,
+                obj.style_description(self._request),
+            )
+        )
+        return schema
+
     @view_config(route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2")
     def view(self):
-        return super().edit()
+        return super().edit(self.schema())
 
     @view_config(route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2")
     def save(self):
         return super().save()
 
     @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")
     def delete(self):
```

## c2cgeoportal_admin/views/layers_wms.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -23,48 +21,50 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
-# pylint: disable=no-member
-
 
 from functools import partial
+from typing import Any, Dict, List, Optional
 
+import sqlalchemy
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import ItemAction, ListField
 from deform.widget import FormWidget
 from pyramid.view import view_config, view_defaults
 from sqlalchemy import delete, insert, inspect, update
 from zope.sqlalchemy import mark_changed
 
 from c2cgeoportal_admin import _
 from c2cgeoportal_admin.schemas.dimensions import dimensions_schema_node
 from c2cgeoportal_admin.schemas.interfaces import interfaces_schema_node
-from c2cgeoportal_admin.schemas.metadata import metadatas_schema_node
+from c2cgeoportal_admin.schemas.metadata import metadata_schema_node
 from c2cgeoportal_admin.schemas.restriction_areas import restrictionareas_schema_node
 from c2cgeoportal_admin.schemas.treeitem import parent_id_node
 from c2cgeoportal_admin.views.dimension_layers import DimensionLayerViews
 from c2cgeoportal_commons.models.main import LayerGroup, LayerWMS, LayerWMTS, OGCServer, TreeItem
 
 _list_field = partial(ListField, LayerWMS)
 
 base_schema = GeoFormSchemaNode(LayerWMS, widget=FormWidget(fields_template="layer_fields"))
-base_schema.add(dimensions_schema_node.clone())
-base_schema.add(metadatas_schema_node.clone())
-base_schema.add(interfaces_schema_node.clone())
-base_schema.add(restrictionareas_schema_node.clone())
+base_schema.add(dimensions_schema_node(LayerWMS.dimensions))
+base_schema.add(metadata_schema_node(LayerWMS.metadatas, LayerWMS))
+base_schema.add(interfaces_schema_node(LayerWMS.interfaces))
+base_schema.add(restrictionareas_schema_node(LayerWMS.restrictionareas))
 base_schema.add_unique_validator(LayerWMS.name, LayerWMS.id)
-base_schema.add(parent_id_node(LayerGroup))
+base_schema.add(parent_id_node(LayerGroup))  # type: ignore
 
 
 @view_defaults(match_param="table=layers_wms")
 class LayerWmsViews(DimensionLayerViews):
+    """The WMS layer administration view."""
+
     _list_fields = (
         DimensionLayerViews._list_fields
         + [
             _list_field(
                 "ogc_server",
                 renderer=lambda layer_wms: layer_wms.ogc_server.name,
                 sort_column=OGCServer.name,
@@ -79,67 +79,71 @@
         ]
         + DimensionLayerViews._extra_list_fields
     )
     _id_field = "id"
     _model = LayerWMS
     _base_schema = base_schema
 
-    def _base_query(self, query=None):
+    def _base_query(self, query: Optional[sqlalchemy.orm.query.Query] = None) -> sqlalchemy.orm.query.Query:
         del query
         return super()._base_query(self._request.dbsession.query(LayerWMS).distinct().outerjoin("ogc_server"))
 
-    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
-    def index(self):
-        return super().index()
-
-    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")
-    def grid(self):
-        return super().grid()
+    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")  # type: ignore
+    def index(self) -> Dict[str, Any]:
+        return super().index()  # type: ignore
+
+    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")  # type: ignore
+    def grid(self) -> Dict[str, Any]:
+        return super().grid()  # type: ignore
 
-    def _item_actions(self, item, readonly=False):
-        actions = super()._item_actions(item, readonly)
+    def _item_actions(self, item: LayerWMS, readonly: bool = False) -> List[ItemAction]:
+        actions: List[ItemAction] = super()._item_actions(item, readonly)
         if inspect(item).persistent:
             actions.insert(
                 next((i for i, v in enumerate(actions) if v.name() == "delete")),
                 ItemAction(
                     name="convert_to_wmts",
                     label=_("Convert to WMTS"),
                     icon="glyphicon icon-l_wmts",
                     url=self._request.route_url("convert_to_wmts", id=getattr(item, self._id_field)),
                     method="POST",
                     confirmation=_("Are you sure you want to convert this layer to WMTS?"),
                 ),
             )
         return actions
 
-    @view_config(route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2")
-    def view(self):
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2"
+    )
+    def view(self) -> Dict[str, Any]:
         if self._is_new():
             dbsession = self._request.dbsession
             default_wms = LayerWMS.get_default(dbsession)
             if default_wms:
-                return self.copy(default_wms, excludes=["name", "layer"])
-        return super().edit()
+                return self.copy(default_wms, excludes=["name", "layer"])  # type: ignore
+        return super().edit()  # type: ignore
+
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2"
+    )
+    def save(self) -> Dict[str, Any]:
+        return super().save()  # type: ignore
 
-    @view_config(route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2")
-    def save(self):
-        return super().save()
-
-    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")
-    def delete(self):
-        return super().delete()
+    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")  # type: ignore
+    def delete(self) -> Dict[str, Any]:
+        return super().delete()  # type: ignore
 
-    @view_config(
+    @view_config(  # type: ignore
         route_name="c2cgeoform_item_duplicate", request_method="GET", renderer="../templates/edit.jinja2"
     )
-    def duplicate(self):
-        return super().duplicate()
+    def duplicate(self) -> Dict[str, Any]:
+        return super().duplicate()  # type: ignore
 
-    @view_config(route_name="convert_to_wmts", request_method="POST", renderer="fast_json")
-    def convert_to_wmts(self):
+    @view_config(route_name="convert_to_wmts", request_method="POST", renderer="fast_json")  # type: ignore
+    def convert_to_wmts(self) -> Dict[str, Any]:
         src = self._get_object()
         dbsession = self._request.dbsession
         default_wmts = LayerWMTS.get_default(dbsession)
         values = (
             {"url": default_wmts.url, "matrix_set": default_wmts.matrix_set}
             if default_wmts
             else {"url": "", "matrix_set": ""}
```

## c2cgeoportal_admin/views/layers_wmts.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -23,48 +21,50 @@
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
-# pylint: disable=no-member
-
 
 from functools import partial
+from typing import Any, Dict, List, Optional
 
+import sqlalchemy
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import ItemAction, ListField
 from deform.widget import FormWidget
 from pyramid.view import view_config, view_defaults
 from sqlalchemy import delete, insert, inspect, update
 from zope.sqlalchemy import mark_changed
 
 from c2cgeoportal_admin import _
 from c2cgeoportal_admin.schemas.dimensions import dimensions_schema_node
 from c2cgeoportal_admin.schemas.interfaces import interfaces_schema_node
-from c2cgeoportal_admin.schemas.metadata import metadatas_schema_node
+from c2cgeoportal_admin.schemas.metadata import metadata_schema_node
 from c2cgeoportal_admin.schemas.restriction_areas import restrictionareas_schema_node
 from c2cgeoportal_admin.schemas.treeitem import parent_id_node
 from c2cgeoportal_admin.views.dimension_layers import DimensionLayerViews
 from c2cgeoportal_commons.models.main import LayerGroup, LayerWMS, LayerWMTS, OGCServer, TreeItem
 
 _list_field = partial(ListField, LayerWMTS)
 
 base_schema = GeoFormSchemaNode(LayerWMTS, widget=FormWidget(fields_template="layer_fields"))
-base_schema.add(dimensions_schema_node.clone())
-base_schema.add(metadatas_schema_node.clone())
-base_schema.add(interfaces_schema_node.clone())
-base_schema.add(restrictionareas_schema_node.clone())
+base_schema.add(dimensions_schema_node(LayerWMTS.dimensions))
+base_schema.add(metadata_schema_node(LayerWMTS.metadatas, LayerWMTS))
+base_schema.add(interfaces_schema_node(LayerWMTS.interfaces))
+base_schema.add(restrictionareas_schema_node(LayerWMTS.restrictionareas))
 base_schema.add_unique_validator(LayerWMTS.name, LayerWMTS.id)
-base_schema.add(parent_id_node(LayerGroup))
+base_schema.add(parent_id_node(LayerGroup))  # type: ignore
 
 
 @view_defaults(match_param="table=layers_wmts")
 class LayerWmtsViews(DimensionLayerViews):
+    """The WMTS layer administration view."""
+
     _list_fields = (
         DimensionLayerViews._list_fields
         + [
             _list_field("url"),
             _list_field("layer"),
             _list_field("style"),
             _list_field("matrix_set"),
@@ -72,66 +72,70 @@
         ]
         + DimensionLayerViews._extra_list_fields
     )
     _id_field = "id"
     _model = LayerWMTS
     _base_schema = base_schema
 
-    def _base_query(self, query=None):
+    def _base_query(self, query: Optional[sqlalchemy.orm.query.Query] = None) -> sqlalchemy.orm.query.Query:
         return super()._base_query(self._request.dbsession.query(LayerWMTS).distinct())
 
-    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
-    def index(self):
-        return super().index()
-
-    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")
-    def grid(self):
-        return super().grid()
+    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")  # type: ignore
+    def index(self) -> Dict[str, Any]:
+        return super().index()  # type: ignore
+
+    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")  # type: ignore
+    def grid(self) -> Dict[str, Any]:
+        return super().grid()  # type: ignore
 
-    def _item_actions(self, item, readonly=False):
-        actions = super()._item_actions(item, readonly)
+    def _item_actions(self, item: LayerWMTS, readonly: bool = False) -> List[ItemAction]:
+        actions: List[ItemAction] = super()._item_actions(item, readonly)
         if inspect(item).persistent:
             actions.insert(
                 next((i for i, v in enumerate(actions) if v.name() == "delete")),
                 ItemAction(
                     name="convert_to_wms",
                     label=_("Convert to WMS"),
                     icon="glyphicon icon-l_wmts",
                     url=self._request.route_url("convert_to_wms", id=getattr(item, self._id_field)),
                     method="POST",
                     confirmation=_("Are you sure you want to convert this layer to WMS?"),
                 ),
             )
         return actions
 
-    @view_config(route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2")
-    def view(self):
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2"
+    )
+    def view(self) -> Dict[str, Any]:
         if self._is_new():
             dbsession = self._request.dbsession
             default_wmts = LayerWMTS.get_default(dbsession)
             if default_wmts:
-                return self.copy(default_wmts, excludes=["name", "layer"])
-        return super().edit()
+                return self.copy(default_wmts, excludes=["name", "layer"])  # type: ignore
+        return super().edit()  # type: ignore
+
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2"
+    )
+    def save(self) -> Dict[str, Any]:
+        return super().save()  # type: ignore
 
-    @view_config(route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2")
-    def save(self):
-        return super().save()
-
-    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")
-    def delete(self):
-        return super().delete()
+    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")  # type: ignore
+    def delete(self) -> Dict[str, Any]:
+        return super().delete()  # type: ignore
 
-    @view_config(
+    @view_config(  # type: ignore
         route_name="c2cgeoform_item_duplicate", request_method="GET", renderer="../templates/edit.jinja2"
     )
-    def duplicate(self):
-        return super().duplicate()
+    def duplicate(self) -> Dict[str, Any]:
+        return super().duplicate()  # type: ignore
 
-    @view_config(route_name="convert_to_wms", request_method="POST", renderer="fast_json")
-    def convert_to_wms(self):
+    @view_config(route_name="convert_to_wms", request_method="POST", renderer="fast_json")  # type: ignore
+    def convert_to_wms(self) -> Dict[str, Any]:
         src = self._get_object()
         dbsession = self._request.dbsession
         default_wms = LayerWMS.get_default(dbsession)
         values = (
             {
                 "ogc_server_id": default_wms.ogc_server_id,
                 "time_mode": default_wms.time_mode,
```

## c2cgeoportal_admin/views/layertree.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -24,73 +22,86 @@
 # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
+from typing import Any, Dict, List, Optional
+
+import pyramid.request
 from c2cgeoform.views.abstract_views import ItemAction
 from pyramid.httpexceptions import HTTPNotFound
 from pyramid.view import view_config, view_defaults
 from translationstring import TranslationStringFactory
 
 from c2cgeoportal_admin import _
-from c2cgeoportal_commons.models.main import LayergroupTreeitem, Theme, TreeItem
+from c2cgeoportal_commons.models.main import Interface, Layer, LayergroupTreeitem, Theme, TreeItem
 
 itemtypes_tables = {
     "theme": "themes",
     "group": "layer_groups",
     "l_wms": "layers_wms",
     "l_wmts": "layers_wmts",
 }
 
 
 @view_defaults(match_param=("application=admin"))
 class LayerTreeViews:
-    def __init__(self, request):
+    """The layer tree administration view."""
+
+    def __init__(self, request: pyramid.request.Request):
         self._request = request
         self._dbsession = request.dbsession
 
-    @view_config(route_name="layertree", renderer="../templates/layertree.jinja2")
-    def index(self):
+    @view_config(route_name="layertree", renderer="../templates/layertree.jinja2")  # type: ignore
+    def index(self) -> Dict[str, int]:
         node_limit = self._request.registry.settings["admin_interface"].get("layer_tree_max_nodes")
         limit_exceeded = self._dbsession.query(LayergroupTreeitem).count() < node_limit
-        return {"limit_exceeded": limit_exceeded}
+        return {"limit_exceeded": limit_exceeded, "interfaces": self._dbsession.query(Interface).all()}
 
-    @view_config(route_name="layertree_children", renderer="fast_json")
-    def children(self):
+    @view_config(route_name="layertree_children", renderer="fast_json")  # type: ignore
+    def children(self) -> List[Dict[str, Any]]:
+        interface = self._request.params.get("interface", None)
         group_id = self._request.params.get("group_id", None)
         path = self._request.params.get("path", "")
 
-        client_tsf = TranslationStringFactory("{}-client".format(self._request.registry.package_name))
+        client_tsf = TranslationStringFactory(f"{self._request.registry.package_name}-client")
 
         if group_id is None:
             items = self._dbsession.query(Theme).order_by(Theme.ordering)
+            if interface is not None:
+                items = items.join(Theme.interfaces).filter(Interface.name == interface)
+
         else:
             items = (
                 self._dbsession.query(TreeItem)
-                .join(TreeItem.parents_relation)  # pylint: disable=no-member
+                .join(TreeItem.parents_relation)
                 .filter(LayergroupTreeitem.treegroup_id == group_id)
+                .order_by(LayergroupTreeitem.ordering)
             )
 
         return [
             {
                 "id": item.id,
                 "item_type": item.item_type,
                 "name": item.name,
                 "translated_name": self._request.localizer.translate(client_tsf(item.name)),
                 "description": item.description,
-                "path": "{}_{}".format(path, item.id),
+                "path": f"{path}_{item.id}",
                 "parent_path": path,
                 "actions": [action.to_dict(self._request) for action in self._item_actions(item, group_id)],
             }
             for item in items
+            if interface is None
+            or not isinstance(item, Layer)
+            or interface in [interface.name for interface in item.interfaces]
         ]
 
-    def _item_actions(self, item, parent_id=None):
+    def _item_actions(self, item: TreeItem, parent_id: Optional[int] = None) -> List[ItemAction]:
         actions = []
         actions.append(
             ItemAction(
                 name="edit",
                 label=_("Edit"),
                 icon="glyphicon glyphicon-pencil",
                 url=self._request.route_url(
@@ -101,40 +112,37 @@
 
         if item.item_type in ("theme", "group"):
             actions.append(
                 ItemAction(
                     name="new_layer_group",
                     label=_("New layer group"),
                     icon="glyphicon glyphicon-plus",
-                    url="{}?parent_id={}".format(
-                        self._request.route_url("c2cgeoform_item", table="layer_groups", id="new"), item.id
-                    ),
+                    url=f"{self._request.route_url('c2cgeoform_item', table='layer_groups', id='new')}?"
+                    f"parent_id={item.id}",
                 )
             )
 
         if item.item_type == "group":
             actions.append(
                 ItemAction(
                     name="new_layer_wms",
                     label=_("New WMS layer"),
                     icon="glyphicon glyphicon-plus",
-                    url="{}?parent_id={}".format(
-                        self._request.route_url("c2cgeoform_item", table="layers_wms", id="new"), item.id
-                    ),
+                    url=f"{self._request.route_url('c2cgeoform_item', table='layers_wms', id='new')}?"
+                    f"parent_id={item.id}",
                 )
             )
 
             actions.append(
                 ItemAction(
                     name="new_layer_wmts",
                     label=_("New WMTS layer"),
                     icon="glyphicon glyphicon-plus",
-                    url="{}?parent_id={}".format(
-                        self._request.route_url("c2cgeoform_item", table="layers_wmts", id="new"), item.id
-                    ),
+                    url=f"{self._request.route_url('c2cgeoform_item', table='layers_wmts', id='new')}?"
+                    f"parent_id={item.id}",
                 )
             )
 
         actions.append(
             ItemAction(
                 name="duplicate",
                 label=_("Duplicate"),
@@ -166,32 +174,32 @@
                 method="DELETE",
                 confirmation=_("Are your sure you want to delete this record?"),
             )
         )
 
         return actions
 
-    @view_config(route_name="layertree_unlink", request_method="DELETE", renderer="fast_json")
-    def unlink(self):
+    @view_config(route_name="layertree_unlink", request_method="DELETE", renderer="fast_json")  # type: ignore
+    def unlink(self) -> Dict[str, Any]:
         group_id = self._request.matchdict.get("group_id")
         item_id = self._request.matchdict.get("item_id")
         link = (
             self._request.dbsession.query(LayergroupTreeitem)
             .filter(LayergroupTreeitem.treegroup_id == group_id)
             .filter(LayergroupTreeitem.treeitem_id == item_id)
             .one_or_none()
         )
         if link is None:
             raise HTTPNotFound()
         self._request.dbsession.delete(link)
         self._request.dbsession.flush()
         return {"success": True, "redirect": self._request.route_url("layertree")}
 
-    @view_config(route_name="layertree_delete", request_method="DELETE", renderer="fast_json")
-    def delete(self):
+    @view_config(route_name="layertree_delete", request_method="DELETE", renderer="fast_json")  # type: ignore
+    def delete(self) -> Dict[str, Any]:
         item_id = self._request.matchdict.get("item_id")
         item = self._request.dbsession.query(TreeItem).get(item_id)
         if item is None:
             raise HTTPNotFound()
         self._request.dbsession.delete(item)
         self._request.dbsession.flush()
         return {"success": True, "redirect": self._request.route_url("layertree")}
```

## c2cgeoportal_admin/views/oauth2_clients.py

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 # Copyright (c) 2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
@@ -25,60 +23,67 @@
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
+from typing import Any, Dict
 
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import AbstractViews, ListField
 from pyramid.view import view_config, view_defaults
 
 from c2cgeoportal_commons.models.static import OAuth2Client
 
 _list_field = partial(ListField, OAuth2Client)
 
 base_schema = GeoFormSchemaNode(OAuth2Client)
 base_schema.add_unique_validator(OAuth2Client.client_id, OAuth2Client.id)
 
 
 @view_defaults(match_param="table=oauth2_clients")
-class OAuth2ClientViews(AbstractViews):
+class OAuth2ClientViews(AbstractViews):  # type: ignore
+    """The oAuth2 client administration view."""
+
     _list_fields = [
         _list_field("id"),
         _list_field("client_id"),
         _list_field("secret"),
         _list_field("redirect_uri"),
     ]
     _id_field = "id"
     _model = OAuth2Client
     _base_schema = base_schema
 
     def _base_query(self):
         return self._request.dbsession.query(OAuth2Client)
 
-    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
-    def index(self):
-        return super().index()
-
-    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")
-    def grid(self):
-        return super().grid()
-
-    @view_config(route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2")
-    def view(self):
-        return super().edit()
-
-    @view_config(route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2")
-    def save(self):
-        return super().save()
-
-    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")
-    def delete(self):
-        return super().delete()
+    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")  # type: ignore
+    def index(self) -> Dict[str, Any]:
+        return super().index()  # type: ignore
+
+    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")  # type: ignore
+    def grid(self) -> Dict[str, Any]:
+        return super().grid()  # type: ignore
+
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2"
+    )
+    def view(self) -> Dict[str, Any]:
+        return super().edit()  # type: ignore
+
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2"
+    )
+    def save(self) -> Dict[str, Any]:
+        return super().save()  # type: ignore
+
+    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")  # type: ignore
+    def delete(self) -> Dict[str, Any]:
+        return super().delete()  # type: ignore
 
-    @view_config(
+    @view_config(  # type: ignore
         route_name="c2cgeoform_item_duplicate", request_method="GET", renderer="../templates/edit.jinja2"
     )
-    def duplicate(self):
-        return super().duplicate()
+    def duplicate(self) -> Dict[str, Any]:
+        return super().duplicate()  # type: ignore
```

## c2cgeoportal_admin/views/ogc_servers.py

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 # Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
@@ -25,34 +23,38 @@
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
+from typing import Any, Dict, List, cast
 
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import AbstractViews, ItemAction, ListField, UserMessage
 from deform.widget import FormWidget
 from pyramid.httpexceptions import HTTPNotFound
 from pyramid.view import view_config, view_defaults
 from sqlalchemy import inspect
 
 from c2cgeoportal_admin import _
 from c2cgeoportal_admin.lib.ogcserver_synchronizer import OGCServerSynchronizer
+from c2cgeoportal_commons.lib.literal import Literal
 from c2cgeoportal_commons.models.main import OGCServer
 
 _list_field = partial(ListField, OGCServer)
 
 base_schema = GeoFormSchemaNode(OGCServer, widget=FormWidget(fields_template="ogcserver_fields"))
 base_schema.add_unique_validator(OGCServer.name, OGCServer.id)
 
 
 @view_defaults(match_param="table=ogc_servers")
-class OGCServerViews(AbstractViews):
+class OGCServerViews(AbstractViews):  # type: ignore
+    """The OGC server administration view."""
+
     _list_fields = [
         _list_field("id"),
         _list_field("name"),
         _list_field("description"),
         _list_field("url"),
         _list_field("url_wfs"),
         _list_field("type"),
@@ -69,89 +71,115 @@
         **AbstractViews.MSG_COL,
         "cannot_delete": UserMessage(
             _("Impossible to delete this server while it contains WMS layers."),
             "alert-danger",
         ),
     }
 
-    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
-    def index(self):
-        return super().index()
-
-    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")
-    def grid(self):
-        return super().grid()
+    @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")  # type: ignore
+    def index(self) -> Dict[str, Any]:
+        return super().index()  # type: ignore
+
+    @view_config(route_name="c2cgeoform_grid", renderer="fast_json")  # type: ignore
+    def grid(self) -> Dict[str, Any]:
+        return super().grid()  # type: ignore
 
-    def schema(self):
+    def schema(self) -> GeoFormSchemaNode:
         try:
             obj = self._get_object()
         except HTTPNotFound:
             obj = None
 
         schema = self._base_schema.clone()
-        schema["url"].description = obj.url_description(self._request)
-        schema["url_wfs"].description = obj.url_wfs_description(self._request)
+        schema["url"].description = Literal(
+            _("{}<br>Current runtime value is: {}").format(
+                schema["url"].description,
+                obj.url_description(self._request),
+            )
+        )
+        schema["url_wfs"].description = Literal(
+            _("{}<br>Current runtime value is: {}").format(
+                schema["url_wfs"].description,
+                obj.url_wfs_description(self._request),
+            )
+        )
         return schema
 
-    def _item_actions(self, item, readonly=False):
-        actions = super()._item_actions(item, readonly)
+    def _item_actions(self, item: OGCServer, readonly: bool = False) -> List[Any]:
+        actions = cast(List[Any], super()._item_actions(item, readonly))
         if inspect(item).persistent:
             actions.insert(
                 next((i for i, v in enumerate(actions) if v.name() == "delete")),
                 ItemAction(
                     name="synchronize",
                     label=_("Synchronize"),
                     icon="glyphicon glyphicon-import",
                     url=self._request.route_url("ogcserver_synchronize", id=getattr(item, self._id_field)),
                 ),
             )
         return actions
 
-    @view_config(route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2")
-    def view(self):
-        return super().edit(self.schema())
-
-    @view_config(route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2")
-    def save(self):
-        return super().save()
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="GET", renderer="../templates/edit.jinja2"
+    )
+    def view(self) -> Dict[str, Any]:
+        return super().edit(self.schema())  # type: ignore
 
-    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")
-    def delete(self):
+    @view_config(  # type: ignore
+        route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2"
+    )
+    def save(self) -> Dict[str, Any]:
+        return super().save()  # type: ignore
+
+    @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")  # type: ignore
+    def delete(self) -> Dict[str, Any]:
         obj = self._get_object()
         if len(obj.layers) > 0:
             return {
                 "success": True,
                 "redirect": self._request.route_url(
                     "c2cgeoform_item",
                     action="edit",
                     id=obj.id,
                     _query=[("msg_col", "cannot_delete")],
                 ),
             }
-        return super().delete()
+        return super().delete()  # type: ignore
 
-    @view_config(
+    @view_config(  # type: ignore
         route_name="c2cgeoform_item_duplicate", request_method="GET", renderer="../templates/edit.jinja2"
     )
-    def duplicate(self):
-        return super().duplicate()
+    def duplicate(self) -> Dict[str, Any]:
+        return super().duplicate()  # type: ignore
 
-    @view_config(route_name="ogcserver_synchronize", renderer="../templates/ogcserver_synchronize.jinja2")
-    def synchronize(self):
+    @view_config(  # type: ignore
+        route_name="ogcserver_synchronize", renderer="../templates/ogcserver_synchronize.jinja2"
+    )
+    def synchronize(self) -> Dict[str, Any]:
         obj = self._get_object()
 
         if self._request.method == "GET":
             return {
                 "ogcserver": obj,
                 "success": None,
                 "report": None,
             }
 
         if self._request.method == "POST":
-            synchronizer = OGCServerSynchronizer(self._request, obj)
+            force_parents = self._request.POST.get("force-parents", "false") == "on"
+            force_ordering = self._request.POST.get("force-ordering", "false") == "on"
+            clean = self._request.POST.get("clean", "false") == "on"
+
+            synchronizer = OGCServerSynchronizer(
+                self._request,
+                obj,
+                force_parents=force_parents,
+                force_ordering=force_ordering,
+                clean=clean,
+            )
             if "check" in self._request.params:
                 synchronizer.check_layers()
             elif "dry-run" in self._request.params:
                 synchronizer.synchronize(dry_run=True)
             elif "synchronize" in self._request.params:
                 synchronizer.synchronize()
             return {
```

## c2cgeoportal_admin/views/restriction_areas.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -33,35 +31,35 @@
 import colander
 from c2cgeoform.schema import GeoFormManyToManySchemaNode, GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import AbstractViews, ListField
 from deform.widget import FormWidget
 from pyramid.view import view_config, view_defaults
 from sqlalchemy.orm import subqueryload
 
-from c2cgeoportal_admin import _
 from c2cgeoportal_admin.schemas.roles import roles_schema_node
 from c2cgeoportal_admin.schemas.treegroup import treeitem_edit_url
 from c2cgeoportal_admin.widgets import ChildrenWidget, ChildWidget
 from c2cgeoportal_commons.models.main import Layer, RestrictionArea
 
 _list_field = partial(ListField, RestrictionArea)
 
 base_schema = GeoFormSchemaNode(RestrictionArea, widget=FormWidget(fields_template="restriction_area_fields"))
-base_schema.add_before("area", roles_schema_node("roles"))
+base_schema.add_before("area", roles_schema_node(RestrictionArea.roles))
 base_schema.add_unique_validator(RestrictionArea.name, RestrictionArea.id)
 
 
 def layers(node, kw):  # pylint: disable=unused-argument
+    """Get the layers serializable representation."""
     dbsession = kw["request"].dbsession
     query = dbsession.query(Layer).order_by(Layer.name)
     return [
         {
             "id": layer.id,
             "label": layer.name,
-            "icon_class": "icon-{}".format(layer.item_type),
+            "icon_class": f"icon-{layer.item_type}",
             "edit_url": treeitem_edit_url(kw["request"], layer),
             "group": "All",
         }
         for layer in query
     ]
 
 
@@ -71,40 +69,43 @@
             Layer,
             name="layer",
             includes=["id"],
             widget=ChildWidget(
                 input_name="id",
                 model=Layer,
                 label_field="name",
-                icon_class=lambda layer: "icon-{}".format(layer.item_type),
+                icon_class=lambda layer: f"icon-{layer.item_type}",
                 edit_url=treeitem_edit_url,
             ),
         ),
         name="layers",
-        title=_("Layers"),
+        title=RestrictionArea.layers.info["colanderalchemy"]["title"],
+        description=RestrictionArea.layers.info["colanderalchemy"]["description"],
         candidates=colander.deferred(layers),
         widget=ChildrenWidget(child_input_name="id", orderable=False),
     )
 )
 
 
 @view_defaults(match_param="table=restriction_areas")
-class RestrictionAreaViews(AbstractViews):
+class RestrictionAreaViews(AbstractViews):  # type: ignore
+    """The restriction area administration view."""
+
     _list_fields = [
         _list_field("id"),
         _list_field("name"),
         _list_field("description"),
         _list_field("readwrite"),
         _list_field(
             "roles", renderer=lambda restriction_area: ", ".join(r.name for r in restriction_area.roles)
         ),
         _list_field(
             "layers",
             renderer=lambda restriction_area: ", ".join(
-                "{}-{}".format(layer.item_type, layer.name) or "" for layer in restriction_area.layers
+                f"{layer.item_type}-{layer.name}" or "" for layer in restriction_area.layers
             ),
         ),
     ]
     _id_field = "id"
     _model = RestrictionArea
     _base_schema = base_schema
```

## c2cgeoportal_admin/views/roles.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -33,30 +31,30 @@
 import colander
 from c2cgeoform.schema import GeoFormManyToManySchemaNode, GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import AbstractViews, ListField
 from deform.widget import FormWidget
 from pyramid.view import view_config, view_defaults
 from sqlalchemy.orm import subqueryload
 
-from c2cgeoportal_admin import _
 from c2cgeoportal_admin.schemas.functionalities import functionalities_schema_node
 from c2cgeoportal_admin.schemas.restriction_areas import restrictionareas_schema_node
 from c2cgeoportal_admin.widgets import ChildrenWidget, ChildWidget
 from c2cgeoportal_commons.models.main import Role
 from c2cgeoportal_commons.models.static import User
 
 _list_field = partial(ListField, Role)
 
 base_schema = GeoFormSchemaNode(Role, widget=FormWidget(fields_template="role_fields"))
-base_schema.add_before("extent", functionalities_schema_node.clone())
-base_schema.add_before("extent", restrictionareas_schema_node.clone())
+base_schema.add_before("extent", functionalities_schema_node(Role.functionalities, Role))
+base_schema.add_before("extent", restrictionareas_schema_node(Role.restrictionareas))
 base_schema.add_unique_validator(Role.name, Role.id)
 
 
 def users(node, kw):  # pylint: disable=unused-argument
+    """Get the user serializable metadata."""
     dbsession = kw["request"].dbsession
     query = dbsession.query(User).order_by(User.username)
     return [
         {
             "id": user.id,
             "label": user.username,
             "icon_class": "icon-user",
@@ -71,45 +69,50 @@
     ]
 
 
 base_schema.add(
     colander.SequenceSchema(
         GeoFormManyToManySchemaNode(
             User,
-            name="layer",
+            name="user",
             includes=["id"],
             widget=ChildWidget(
                 input_name="id",
                 model=User,
                 label_field="username",
                 icon_class=lambda user: "icon-user",
                 edit_url=lambda request, user: request.route_url(
                     "c2cgeoform_item",
                     table="users",
                     id=user.id,
                 ),
             ),
         ),
-        name="users",
-        title=_("Users"),
+        name=Role.users.key,
+        title=Role.users.info["colanderalchemy"]["title"],
+        description=Role.users.info["colanderalchemy"]["description"],
         candidates=colander.deferred(users),
         widget=ChildrenWidget(child_input_name="id", orderable=False, category="structural"),
     )
 )
+# Not possible to overwrite this in constructor.
+base_schema["users"].children[0].description = ""
 
 
 @view_defaults(match_param="table=roles")
-class RoleViews(AbstractViews):
+class RoleViews(AbstractViews):  # type: ignore
+    """The roles administration view."""
+
     _list_fields = [
         _list_field("id"),
         _list_field("name"),
         _list_field("description"),
         _list_field(
             "functionalities",
-            renderer=lambda role: ", ".join(["{}={}".format(f.name, f.value) for f in role.functionalities]),
+            renderer=lambda role: ", ".join([f"{f.name}={f.value}" for f in role.functionalities]),
         ),
         _list_field(
             "restrictionareas", renderer=lambda role: ", ".join([r.name or "" for r in role.restrictionareas])
         ),
     ]
     _id_field = "id"
     _model = Role
```

## c2cgeoportal_admin/views/themes.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -25,87 +23,90 @@
 
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
+from typing import Optional, cast
 
+import sqlalchemy
 from c2cgeoform.schema import GeoFormSchemaNode
 from c2cgeoform.views.abstract_views import ListField
 from deform.widget import FormWidget
 from pyramid.view import view_config, view_defaults
 from sqlalchemy.orm import subqueryload
 from sqlalchemy.sql.functions import concat
 
 from c2cgeoportal_admin.schemas.functionalities import functionalities_schema_node
 from c2cgeoportal_admin.schemas.interfaces import interfaces_schema_node
-from c2cgeoportal_admin.schemas.metadata import metadatas_schema_node
+from c2cgeoportal_admin.schemas.metadata import metadata_schema_node
 from c2cgeoportal_admin.schemas.roles import roles_schema_node
 from c2cgeoportal_admin.schemas.treegroup import children_schema_node
 from c2cgeoportal_admin.views.treeitems import TreeItemViews
 from c2cgeoportal_commons.models.main import Functionality, Interface, Role, Theme
 
 _list_field = partial(ListField, Theme)
 
 base_schema = GeoFormSchemaNode(Theme, widget=FormWidget(fields_template="theme_fields"))
 base_schema.add(children_schema_node(only_groups=True))
-base_schema.add(functionalities_schema_node.clone())
-base_schema.add(roles_schema_node("restricted_roles"))
-base_schema.add(interfaces_schema_node.clone())
-base_schema.add(metadatas_schema_node.clone())
+base_schema.add(functionalities_schema_node(Theme.functionalities, Theme))
+base_schema.add(roles_schema_node(Theme.restricted_roles))
+base_schema.add(interfaces_schema_node(Theme.interfaces))
+base_schema.add(metadata_schema_node(Theme.metadatas, Theme))
 base_schema.add_unique_validator(Theme.name, Theme.id)
 
 
 @view_defaults(match_param="table=themes")
 class ThemeViews(TreeItemViews):
+    """The theme administration view."""
 
     _list_fields = (
         TreeItemViews._list_fields
         + [
             _list_field("ordering"),
             _list_field("public"),
             _list_field("icon"),
             _list_field(
                 "functionalities",
                 renderer=lambda themes: ", ".join(
                     [
-                        "{}={}".format(f.name, f.value)
-                        for f in sorted(themes.functionalities, key=lambda f: f.name)
+                        f"{f.name}={f.value}"
+                        for f in sorted(themes.functionalities, key=lambda f: cast(str, f.name))
                     ]
                 ),
                 filter_column=concat(Functionality.name, "=", Functionality.value),
             ),
             _list_field(
                 "restricted_roles",
                 renderer=lambda themes: ", ".join([r.name or "" for r in themes.restricted_roles]),
                 filter_column=Role.name,
             ),
             _list_field(
                 "interfaces",
                 renderer=lambda themes: ", ".join(
-                    [i.name or "" for i in sorted(themes.interfaces, key=lambda i: i.name)]
+                    [i.name or "" for i in sorted(themes.interfaces, key=lambda i: cast(str, i.name))]
                 ),
                 filter_column=Interface.name,
             ),
         ]
         + TreeItemViews._extra_list_fields_no_parents
     )
 
     _id_field = "id"
     _model = Theme
     _base_schema = base_schema
 
-    def _base_query(self, query=None):
+    def _base_query(self, query: Optional[sqlalchemy.orm.query.Query] = None) -> sqlalchemy.orm.query.Query:
         return super()._base_query(
             self._request.dbsession.query(Theme)
             .distinct()
             .outerjoin("interfaces")
-            .outerjoin("restricted_roles")
-            .outerjoin("functionalities")
+            .outerjoin(Theme.restricted_roles)
+            .outerjoin(Theme.functionalities)
             .options(subqueryload("functionalities"))
             .options(subqueryload("restricted_roles"))
             .options(subqueryload("interfaces"))
         )
 
     @view_config(route_name="c2cgeoform_index", renderer="../templates/index.jinja2")
     def index(self):
```

## c2cgeoportal_admin/views/themes_ordering.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -37,61 +35,68 @@
 
 from c2cgeoportal_admin import _
 from c2cgeoportal_admin.schemas.treegroup import treeitem_edit_url
 from c2cgeoportal_admin.widgets import ChildrenWidget, ChildWidget
 from c2cgeoportal_commons.models.main import Theme, TreeItem
 
 
-class ThemeOrderSchema(GeoFormSchemaNode):  # pylint: disable=abstract-method
+class ThemeOrderSchema(GeoFormSchemaNode):  # type: ignore # pylint: disable=abstract-method
+    """The theme order schema."""
+
     def objectify(self, dict_, context=None):
         context = self.dbsession.query(Theme).get(dict_["id"])
         context = super().objectify(dict_, context)
         return context
 
 
 @colander.deferred
 def themes(node, kw):  # pylint: disable=unused-argument
+    """Get some theme metadata."""
     query = kw["dbsession"].query(Theme).order_by(Theme.ordering, Theme.name)
     return [
-        {"id": item.id, "label": item.name, "icon_class": "icon-{}".format(item.item_type), "group": "All"}
+        {"id": item.id, "label": item.name, "icon_class": f"icon-{item.item_type}", "group": "All"}
         for item in query
     ]
 
 
 def themes_validator(node, cstruct):
+    """Validate the theme."""
     for dict_ in cstruct:
         if not dict_["id"] in [item["id"] for item in node.candidates]:
             raise colander.Invalid(
                 node,
                 _("Value {} does not exist in table {}").format(dict_["id"], Theme.__tablename__),
             )
 
 
-class ThemesOrderingSchema(colander.MappingSchema):
+class ThemesOrderingSchema(colander.MappingSchema):  # type: ignore
+    """The theme ordering schema."""
+
     themes = colander.SequenceSchema(
         ThemeOrderSchema(
             Theme,
             includes=["id", "ordering"],
             name="theme",
             widget=ChildWidget(
                 input_name="id",
                 model=TreeItem,
                 label_field="name",
-                icon_class=lambda item: "icon-{}".format(item.item_type),
+                icon_class=lambda item: f"icon-{item.item_type}",
                 edit_url=treeitem_edit_url,
             ),
         ),
         name="themes",
         candidates=themes,
         validator=themes_validator,
         widget=ChildrenWidget(child_input_name="id", add_subitem=False, orderable=True),
     )
 
 
-class ThemesOrdering(AbstractViews):
+class ThemesOrdering(AbstractViews):  # type: ignore
+    """The theme ordering admin view."""
 
     _base_schema = ThemesOrderingSchema()
 
     @view_config(route_name="layertree_ordering", request_method="GET", renderer="../templates/edit.jinja2")
     def view(self):
         form = self._form()
         dict_ = {
```

## c2cgeoportal_admin/views/treeitems.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2021, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -26,37 +24,38 @@
 # The views and conclusions contained in the software and documentation are those
 # of the authors and should not be interpreted as representing official policies,
 # either expressed or implied, of the FreeBSD Project.
 
 
 from functools import partial
 
+import sqlalchemy
 from c2cgeoform.views.abstract_views import AbstractViews, ListField
 from pyramid.view import view_config
 from sqlalchemy.orm import subqueryload
 from sqlalchemy.sql.functions import concat
 
 from c2cgeoportal_commons.models.main import LayergroupTreeitem, Metadata, TreeGroup, TreeItem
 
 _list_field = partial(ListField, TreeItem)
 
 
-class TreeItemViews(AbstractViews):
+class TreeItemViews(AbstractViews):  # type: ignore
+    """The admin tree item view."""
+
     _list_fields = [
         _list_field("id"),
         _list_field("name"),
         _list_field("description"),
     ]
 
     _extra_list_fields_no_parents = [
         _list_field(
             "metadatas",
-            renderer=lambda layers_group: ", ".join(
-                ["{}: {}".format(m.name, m.value) or "" for m in layers_group.metadatas]
-            ),
+            renderer=lambda treeitem: ", ".join([f"{m.name}: {m.value}" or "" for m in treeitem.metadatas]),
             filter_column=concat(Metadata.name, ": ", Metadata.value).label("metadata"),
         )
     ]
     _extra_list_fields = [
         _list_field(
             "parents_relation",
             renderer=lambda layer_wms: ", ".join(
@@ -68,22 +67,24 @@
         )
     ] + _extra_list_fields_no_parents
 
     @view_config(route_name="c2cgeoform_item", request_method="POST", renderer="../templates/edit.jinja2")
     def save(self):
         response = super().save()
         # correctly handles the validation error as if there is a validation error, cstruct is empty
-        has_to_be_registred_in_parent = (
+        has_to_be_registered_in_parent = (
             hasattr(self, "_appstruct") and self._appstruct is not None and self._appstruct.get("parent_id")
         )
-        if has_to_be_registred_in_parent:
-            parent = self._request.dbsession.query(TreeGroup).get(has_to_be_registred_in_parent)
+        if has_to_be_registered_in_parent:
+            parent = self._request.dbsession.query(TreeGroup).get(has_to_be_registered_in_parent)
             rel = LayergroupTreeitem(parent, self._obj, 100)
             self._request.dbsession.add(rel)
         return response
 
-    def _base_query(self, query):  # pylint: disable=arguments-differ
+    def _base_query(  # pylint: disable=arguments-differ
+        self, query: sqlalchemy.orm.query.Query
+    ) -> sqlalchemy.orm.query.Query:
         return (
             query.outerjoin("metadatas")
             .options(subqueryload("parents_relation").joinedload("treegroup"))
             .options(subqueryload("metadatas"))
         )
```

## c2cgeoportal_admin/views/users.py

```diff
@@ -1,10 +1,8 @@
-# -*- coding: utf-8 -*-
-
-# Copyright (c) 2017-2020, Camptocamp SA
+# Copyright (c) 2017-2022, Camptocamp SA
 # All rights reserved.
 
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions are met:
 
 # 1. Redistributions of source code must retain the above copyright notice, this
 #    list of conditions and the following disclaimer.
@@ -42,22 +40,24 @@
 from c2cgeoportal_commons.lib.email_ import send_email_config
 from c2cgeoportal_commons.models.main import Role
 from c2cgeoportal_commons.models.static import User
 
 _list_field = partial(ListField, User)
 
 base_schema = GeoFormSchemaNode(User, widget=FormWidget(fields_template="user_fields"))
-base_schema.add(roles_schema_node("roles"))
+base_schema.add(roles_schema_node(User.roles))
 base_schema.add_unique_validator(User.username, User.id)
 
 settings_role = aliased(Role)
 
 
 @view_defaults(match_param="table=users")
-class UserViews(AbstractViews):
+class UserViews(AbstractViews):  # type: ignore
+    """The admin user view."""
+
     _list_fields = [
         _list_field("id"),
         _list_field("username"),
         _list_field("email"),
         _list_field("last_login"),
         _list_field("expire_on"),
         _list_field("deactivated"),
@@ -115,14 +115,16 @@
 
                 send_email_config(
                     settings=self._request.registry.settings,
                     email_config_name="welcome_email",
                     email=user.email,
                     user=user.username,
                     password=password,
+                    application_url=self._request.route_url("base"),
+                    current_url=self._request.current_route_url(),
                 )
 
             return response
 
         return super().save()
 
     @view_config(route_name="c2cgeoform_item", request_method="DELETE", renderer="fast_json")
```

## tests/__init__.py

```diff
@@ -34,27 +34,27 @@
         Interface,
         LayerGroup,
         LayergroupTreeitem,
         Metadata,
         RestrictionArea,
     )
 
-    restrictionareas = [RestrictionArea(name="restrictionarea_{}".format(i)) for i in range(0, 5)]
+    restrictionareas = [RestrictionArea(name=f"restrictionarea_{i}") for i in range(0, 5)]
 
     interfaces = [Interface(name) for name in ["desktop", "mobile", "edit", "routing"]]
 
     dimensions_protos = [("Date", "2017"), ("Date", "2018"), ("Date", "1988"), ("CLC", "all")]
 
     metadatas_protos = [
         ("copyable", "true"),
         ("disclaimer", " le momo"),
         ("snappingConfig", '{"tolerance": 50}'),
     ]
 
-    groups = [LayerGroup(name="layer_group_{}".format(i)) for i in range(0, 5)]
+    groups = [LayerGroup(name=f"layer_group_{i}") for i in range(0, 5)]
 
     layers = []
     for i in range(0, 25):
 
         layer = layer_builder(i)
 
         if add_dimension:
@@ -91,26 +91,26 @@
 
 class AbstractViewsTests:
 
     _prefix = None  # url prefix (index view url). Example: /users
 
     def get(self, test_app, path="", locale="en", status=200, **kwargs):
         return test_app.get(
-            "{}{}".format(self._prefix, path),
-            headers={"Cookie": "_LOCALE_={}".format(locale)},
+            f"{self._prefix}{path}",
+            headers={"Cookie": f"_LOCALE_={locale}"},
             status=status,
             **kwargs,
         )
 
     def get_item(self, test_app, item_id, **kwargs):
-        return self.get(test_app, "/{}".format(item_id), **kwargs)
+        return self.get(test_app, f"/{item_id}", **kwargs)
 
     def check_left_menu(self, resp, title):
         link = resp.html.select_one(".navbar li.active a")
-        assert "http://localhost{}".format(self._prefix) == link.attrs["href"]
+        assert f"http://localhost{self._prefix}" == link.attrs["href"]
         assert title == link.getText()
 
     def check_grid_headers(self, resp, expected_col_headers, new="New"):
         pp = pprint.PrettyPrinter(indent=4)
         effective_cols = [
             (th.attrs["data-field"], th.getText(), th.attrs["data-sortable"]) for th in resp.html.select("th")
         ]
@@ -120,27 +120,27 @@
         )
         actions = resp.html.select_one('th[data-field="actions"]')
         assert "false" == actions.attrs["data-sortable"]
         assert 1 == len(list(filter(lambda x: next(x.stripped_strings) == new, resp.html.findAll("a"))))
 
     def check_search(self, test_app, search="", offset=0, limit=10, sort="", order="", total=None):
         json = test_app.post(
-            "{}/grid.json".format(self._prefix),
+            f"{self._prefix}/grid.json",
             params={"offset": offset, "limit": limit, "search": search, "sort": sort, "order": order},
             status=200,
         ).json
         if total is not None:
             assert total == json["total"]
         return json
 
     def check_checkboxes(self, form, name, expected):
         for i, exp in enumerate(expected):
             field = form.get(name, index=i)
-            checkbox = form.html.select_one("#{}".format(field.id))
-            label = form.html.select_one("label[for={}]".format(field.id))
+            checkbox = form.html.select_one(f"#{field.id}")
+            label = form.html.select_one(f"label[for={field.id}]")
             assert exp["label"] == list(label.stripped_strings)[0]
             assert exp["value"] == checkbox["value"]
             assert exp["checked"] == field.checked
 
     def _check_interfaces(self, form, interfaces, item):
         self.check_checkboxes(
             form,
```

## tests/conftest.py

```diff
@@ -52,23 +52,24 @@
 @pytest.fixture(scope="session")
 @pytest.mark.usefixtures("app_env", "dbsession")
 def app(app_env, dbsession):
     config = testing.setUp(registry=app_env["registry"])
     config.add_request_method(lambda request: dbsession, "dbsession", reify=True)
     config.add_route("user_add", "user_add")
     config.add_route("users_nb", "users_nb")
+    config.add_route("base", "/", static=True)
     config.scan(package="tests")
     app = config.make_wsgi_app()
     yield app
 
 
 @pytest.fixture(scope="session")
 @pytest.mark.usefixtures("app_env")
 def settings(app_env):
     yield app_env.get("registry").settings
 
 
-@pytest.fixture(scope="session")  # noqa: F811
+@pytest.fixture(scope="session")  # noqa: ignore=F811
 @pytest.mark.usefixtures("app")
 def test_app(request, app):
     testapp = WebTestApp(app)
     yield testapp
```

## tests/test_edit_url.py

```diff
@@ -20,56 +20,54 @@
         LayerWMTS,
         OGCServer,
         RestrictionArea,
         Role,
         Theme,
     )
 
-    restrictionareas = [RestrictionArea(name="restrictionarea_{}".format(i)) for i in range(0, 5)]
+    restrictionareas = [RestrictionArea(name=f"restrictionarea_{i}") for i in range(0, 5)]
     functionalities = {}
-    for name in ("default_basemap", "location"):
+    for name in ("default_basemap", "default_theme"):
         functionalities[name] = []
         for v in range(0, 4):
-            functionality = Functionality(name=name, value="value_{}".format(v))
+            functionality = Functionality(name=name, value=f"value_{v}")
             dbsession.add(functionality)
             functionalities[name].append(functionality)
 
     interfaces = [Interface(name) for name in ["desktop", "mobile", "edit", "routing"]]
     ogc_server = OGCServer(name="ogc_server")
 
     layers_wmts = []
     for i in range(0, 5):
-        name = "layer_wmts_{}".format(i)
+        name = f"layer_wmts_{i}"
         layer_wmts = LayerWMTS(name=name)
         layer_wmts.layer = name
-        layer_wmts.url = "https://server{}.net/wmts".format(i)
+        layer_wmts.url = f"https://server{i}.net/wmts"
         layer_wmts.restrictionareas = [restrictionareas[i % 5], restrictionareas[(i + 2) % 5]]
         if i % 10 != 1:
             layer_wmts.interfaces = [interfaces[i % 4], interfaces[(i + 2) % 4]]
         layer_wmts.public = 1 == i % 2
         layer_wmts.image_type = "image/jpeg"
         dbsession.add(layer_wmts)
         layers_wmts.append(layer_wmts)
 
     layers_wms = []
     for i in range(0, 5):
-        layer_wms = LayerWMS(name="layer_wms_{}".format(i))
-        layer_wms.layer = "wms_layer_{}".format(i)
+        layer_wms = LayerWMS(name=f"layer_wms_{i}")
+        layer_wms.layer = f"wms_layer_{i}"
         layer_wms.ogc_server = ogc_server
         layers_wms.append(layer_wms)
         dbsession.add(layer_wms)
         layers_wms.append(layer_wms)
 
     roles = []
     for i in range(0, 5):
         role = Role("secretary_" + str(i))
         role.functionalities = [
-            functionalities["default_basemap"][0],
-            functionalities["location"][0],
-            functionalities["location"][1],
+            functionalities["default_theme"][0],
         ]
         role.restrictionareas = [restrictionareas[0], restrictionareas[1]]
         dbsession.add(role)
         roles.append(role)
 
     dbsession.flush()
 
@@ -94,20 +92,20 @@
 
 @pytest.mark.usefixtures("edit_url_test_data", "test_app")
 class TestUrlEdit(AbstractViewsTests):
 
     _prefix = "/admin/"
 
     def _get(self, test_app, tablename, pk):
-        path = "/{}/{}".format(tablename, pk)
+        path = f"/{tablename}/{pk}"
         return test_app.get(path, status=200)
 
     def _check_link(self, test_app, resp, item, table, status):
-        link = resp.html.select_one(".form-group.item-{} a".format(item))
-        assert re.match(r"http://localhost/admin/{}/\d+".format(table), link["href"]) is not None
+        link = resp.html.select_one(f".form-group.item-{item} a")
+        assert re.match(rf"http://localhost/admin/{table}/\d+", link["href"]) is not None
         test_app.get(link.get("href"), status=status)
 
     def test_layer_wms_edit(self, edit_url_test_data, test_app):
         resp = self._get(test_app, "admin/layers_wms", edit_url_test_data["layers_wms"][0].id)
         self._check_link(test_app, resp, "restrictionareas", "restriction_areas", 200)
         self._check_link(test_app, resp, "interfaces", "interfaces", 200)
```

## tests/test_functionalities.py

```diff
@@ -5,23 +5,26 @@
 import pytest
 
 from . import AbstractViewsTests
 
 
 @pytest.fixture(scope="function")
 @pytest.mark.usefixtures("dbsession", "transact")
-def functionality_test_data(dbsession, transact):
+def functionality_test_data(dbsession, transact, settings):
     del transact
 
     from c2cgeoportal_commons.models.main import Functionality
 
     functionalities = []
     for i in range(0, 4):
-        functionality = Functionality(name="functionality_{}".format(i), value="value_{}".format(i))
-        functionality.description = "description_{}".format(i)
+        functionality = Functionality(
+            settings["admin_interface"]["available_functionalities"][i]["name"],
+            value=f"value_{i}",
+        )
+        functionality.description = f"description_{i}"
         dbsession.add(functionality)
         functionalities.append(functionality)
 
     dbsession.flush()
 
     yield {"functionalities": functionalities}
 
@@ -43,15 +46,15 @@
             ("description", "Description", "true"),
             ("value", "Value", "true"),
         ]
         self.check_grid_headers(resp, expected)
 
     def test_grid_search(self, test_app):
         # search on functionality name
-        self.check_search(test_app, "functionality_0", total=1)
+        self.check_search(test_app, "default_basemap", total=1)
 
     def test_submit_new(self, dbsession, test_app):
         from c2cgeoportal_commons.models.main import Functionality
 
         resp = test_app.post(
             "/admin/functionalities/new",
             {"name": "new_name", "description": "new_description", "value": "new_value"},
@@ -61,38 +64,48 @@
         assert str(functionality.id) == re.match(
             r"http://localhost/admin/functionalities/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
         assert functionality.name == "new_name"
 
     def test_edit(self, test_app, functionality_test_data):
         functionality = functionality_test_data["functionalities"][0]
-        resp = test_app.get("/admin/functionalities/{}".format(functionality.id), status=200)
+        resp = test_app.get(f"/admin/functionalities/{functionality.id}", status=200)
         form = resp.form
         assert str(functionality.id) == self.get_first_field_named(form, "id").value
         assert "hidden" == self.get_first_field_named(form, "id").attrs["type"]
         assert functionality.name == form["name"].value
         form["description"] = "new_description"
         assert form.submit().status_int == 302
         assert functionality.description == "new_description"
 
     def test_delete(self, test_app, functionality_test_data, dbsession):
         from c2cgeoportal_commons.models.main import Functionality
 
         functionality = functionality_test_data["functionalities"][0]
         deleted_id = functionality.id
-        test_app.delete("/admin/functionalities/{}".format(deleted_id), status=200)
+        test_app.delete(f"/admin/functionalities/{deleted_id}", status=200)
         assert dbsession.query(Functionality).get(deleted_id) is None
 
     def test_duplicate(self, functionality_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Functionality
 
         functionality = functionality_test_data["functionalities"][3]
-        resp = test_app.get("/admin/functionalities/{}/duplicate".format(functionality.id), status=200)
+
+        resp = test_app.get(f"/admin/functionalities/{functionality.id}/duplicate", status=200)
+
         form = resp.form
-        assert "" == self.get_first_field_named(form, "id").value
-        self.set_first_field_named(form, "name", "clone")
+        assert form["name"].value == functionality.name
+        assert form["description"].value == functionality.description
+        assert form["value"].value == functionality.value
+        form["value"].value = "another_value"
         resp = form.submit("submit")
+
         assert resp.status_int == 302
-        functionality = dbsession.query(Functionality).filter(Functionality.name == "clone").one()
+        functionality = (
+            dbsession.query(Functionality)
+            .filter(Functionality.name == functionality.name)
+            .filter(Functionality.value == "another_value")
+            .one()
+        )
         assert str(functionality.id) == re.match(
             r"http://localhost/admin/functionalities/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
```

## tests/test_interface.py

```diff
@@ -12,30 +12,30 @@
 def interface_test_data(dbsession, transact):
     del transact
 
     from c2cgeoportal_commons.models.main import Interface, LayerWMS, OGCServer, Theme
 
     themes = []
     for i in range(0, 5):
-        theme = Theme(name="theme_{}".format(i), ordering=1)
+        theme = Theme(name=f"theme_{i}", ordering=1)
         themes.append(theme)
 
-    servers = [OGCServer(name="server_{}".format(i)) for i in range(0, 4)]
+    servers = [OGCServer(name=f"server_{i}") for i in range(0, 4)]
 
     layers = []
     for i in range(0, 15):
-        layer = LayerWMS(name="layer_wms_{}".format(i))
+        layer = LayerWMS(name=f"layer_wms_{i}")
         layer.public = 1 == i % 2
         layer.ogc_server = servers[i % 4]
         dbsession.add(layer)
         layers.append(layer)
 
     interfaces = []
     for i in range(0, 5):
-        interface = Interface(name="interface_{}".format(i), description="description_{}".format(i))
+        interface = Interface(name=f"interface_{i}", description=f"description_{i}")
         interface.themes = [themes[i % 2], themes[(i + 5) % 5]]
         interface.layers = [layers[i % 2], layers[(i + 4) % 5]]
 
         dbsession.add(interface)
         interfaces.append(interface)
 
     dbsession.flush()
@@ -97,30 +97,30 @@
     def test_edit(self, test_app, interface_test_data, dbsession):
         from c2cgeoportal_commons.models.main import Interface
 
         interface = interface_test_data["interfaces"][0]
         descriptions = "{}, {}".format(
             interface_test_data["interfaces"][0].description, interface_test_data["interfaces"][1].description
         )
-        resp = test_app.get("/admin/interfaces/{}".format(interface.id), status=200)
+        resp = test_app.get(f"/admin/interfaces/{interface.id}", status=200)
         form = resp.form
         form["description"] = descriptions
         assert str(interface.id) == self.get_first_field_named(form, "id").value
         assert "hidden" == self.get_first_field_named(form, "id").attrs["type"]
         assert interface.name == self.get_first_field_named(form, "name").value
         assert form.submit().status_int == 302
         assert len(dbsession.query(Interface).filter(Interface.description == descriptions).all()) == 1
 
     def test_delete(self, test_app, interface_test_data, dbsession):
         from c2cgeoportal_commons.models.main import Interface
 
         interface = interface_test_data["interfaces"][0]
-        test_app.delete("/admin/interfaces/{}".format(interface.id), status=200)
+        test_app.delete(f"/admin/interfaces/{interface.id}", status=200)
         assert len(dbsession.query(Interface).filter(Interface.id == interface.id).all()) == 0
 
     def test_duplicate(self, interface_test_data, test_app):
         interface = interface_test_data["interfaces"][3]
-        resp = test_app.get("/admin/interfaces/{}/duplicate".format(interface.id), status=200)
+        resp = test_app.get(f"/admin/interfaces/{interface.id}/duplicate", status=200)
         form = resp.form
         assert "" == self.get_first_field_named(form, "id").value
         assert str(interface.description or "") == "description_3"
         assert form.submit().status_int == 302
```

## tests/test_layer_groups.py

```diff
@@ -18,15 +18,15 @@
         ("copyable", "true"),
         ("disclaimer", " le momo"),
         ("snappingConfig", '{"tolerance": 50}'),
     ]
 
     groups = []
     for i in range(0, 12):
-        group = LayerGroup(name="groups_{num:02d}".format(num=i), is_expanded=False)
+        group = LayerGroup(name=f"groups_{i:02d}")
         group.metadatas = [
             Metadata(name=metadatas_protos[id][0], value=metadatas_protos[id][1])
             for id in [i % 3, (i + 2) % 3]
         ]
         for metadata in group.metadatas:
             metadata.item = group
 
@@ -69,15 +69,14 @@
         self.check_left_menu(resp, "Layers groups")
 
         expected = [
             ("actions", "", "false"),
             ("id", "id", "true"),
             ("name", "Name"),
             ("description", "Description"),
-            ("is_expanded", "Expanded"),
             ("parents_relation", "Parents", "false"),
             ("metadatas", "Metadatas", "false"),
         ]
         self.check_grid_headers(resp, expected)
 
     def test_grid_complex_column_val(self, test_app, layer_groups_test_data):
         json = self.check_search(test_app, sort="name")
@@ -99,16 +98,14 @@
 
         form = self.get_item(test_app, group.id).form
 
         assert str(group.id) == self.get_first_field_named(form, "id").value
         assert "hidden" == self.get_first_field_named(form, "id").attrs["type"]
         assert group.name == self.get_first_field_named(form, "name").value
         assert str(group.description or "") == self.get_first_field_named(form, "description").value
-        assert group.is_expanded is False
-        assert group.is_expanded == form["is_expanded"].checked
 
         self.check_children(
             form,
             "children_relation",
             [
                 {
                     "label": rel.treeitem.name,
@@ -117,15 +114,14 @@
                 for rel in group.children_relation
             ],
         )
 
         new_values = {
             "name": "new_name",
             "description": "new description",
-            "is_expanded": True,
         }
         for key, value in new_values.items():
             self.set_first_field_named(form, key, value)
 
         resp = form.submit("submit")
         assert str(group.id) == re.match(
             r"http://localhost/admin/layer_groups/(.*)\?msg_col=submit_ok", resp.location
@@ -140,15 +136,15 @@
 
     def test_post_new_with_children_invalid(self, test_app, layer_groups_test_data):
         """
         Check there is no rendering error when validation fails.
         """
         groups = layer_groups_test_data["groups"]
         resp = test_app.post(
-            "{}/new".format(self._prefix),
+            f"{self._prefix}/new",
             (
                 ("_charset_", "UTF-8"),
                 ("__formid__", "deform"),
                 ("id", ""),
                 ("__start__", "children_relation:sequence"),
                 ("__start__", "layergroup_treeitem:mapping"),
                 ("id", ""),
@@ -161,15 +157,15 @@
             status=200,
         )
         assert "Required" == resp.html.select_one(".item-name .help-block").getText().strip()
 
     def test_post_new_with_children_success(self, test_app, dbsession, layer_groups_test_data):
         groups = layer_groups_test_data["groups"]
         resp = test_app.post(
-            "{}/new".format(self._prefix),
+            f"{self._prefix}/new",
             (
                 ("_charset_", "UTF-8"),
                 ("__formid__", "deform"),
                 ("name", "new_with_children"),
                 ("description", ""),
                 ("id", ""),
                 ("__start__", "children_relation:sequence"),
@@ -203,18 +199,20 @@
         ).group(1)
 
         assert [groups[3].id, groups[4].id, groups[5].id] == [
             rel.treeitem_id for rel in group.children_relation
         ]
 
     def test_post_with_ancestor(self, layer_groups_test_data, test_app):
-        """Check that ancestors are refused to avoid cycles"""
+        """
+        Check that ancestors are refused to avoid cycles.
+        """
         groups = layer_groups_test_data["groups"]
         resp = test_app.post(
-            "{}/{}".format(self._prefix, groups[3].id),
+            f"{self._prefix}/{groups[3].id}",
             (
                 ("_charset_", "UTF-8"),
                 ("__formid__", "deform"),
                 ("id", str(groups[3].id)),
                 ("name", groups[3].name),
                 ("__start__", "children_relation:sequence"),
                 ("__start__", "layergroup_treeitem:mapping"),
@@ -224,33 +222,31 @@
                 ("__end__", "layergroup_treeitem:mapping"),
                 ("__end__", "children_relation:sequence"),
                 ("formsubmit", "formsubmit"),
             ),
             status=200,
         )
         assert (
-            "Value {} does not exist in table treeitem or is not allowed to avoid cycles".format(groups[1].id)
+            f"Value {groups[1].id} does not exist in table treeitem or is not allowed to avoid cycles"
             == resp.html.select_one(".item-children_relation + .help-block").getText().strip()
         )
 
     def test_duplicate(self, layer_groups_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import LayerGroup
 
         group = layer_groups_test_data["groups"][1]
 
-        resp = test_app.get("{}/{}/duplicate".format(self._prefix, group.id), status=200)
+        resp = test_app.get(f"{self._prefix}/{group.id}/duplicate", status=200)
         form = resp.form
 
         group = dbsession.query(LayerGroup).filter(LayerGroup.id == group.id).one()
 
         assert "" == self.get_first_field_named(form, "id").value
         assert group.name == self.get_first_field_named(form, "name").value
         assert str(group.description or "") == self.get_first_field_named(form, "description").value
-        assert group.is_expanded is False
-        assert group.is_expanded == form["is_expanded"].checked
 
         self.check_children(
             form,
             "children_relation",
             [
                 {"label": rel.treeitem.name, "values": {"id": "", "treeitem_id": str(rel.treeitem.id)}}
                 for rel in group.children_relation
@@ -259,27 +255,27 @@
 
         self.set_first_field_named(form, "name", "duplicated")
         resp = form.submit("submit")
 
         duplicated = dbsession.query(LayerGroup).filter(LayerGroup.name == "duplicated").one()
 
         assert str(duplicated.id) == re.match(
-            r"http://localhost{}/(.*)\?msg_col=submit_ok".format(self._prefix), resp.location
+            rf"http://localhost{self._prefix}/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
         assert duplicated.id != group.id
         assert duplicated.children_relation[0].id != group.children_relation[0].id
         assert duplicated.children_relation[0].treeitem.id == group.children_relation[0].treeitem.id
 
     def test_unicity_validator(self, layer_groups_test_data, test_app):
         group = layer_groups_test_data["groups"][1]
-        resp = test_app.get("{}/{}/duplicate".format(self._prefix, group.id), status=200)
+        resp = test_app.get(f"{self._prefix}/{group.id}/duplicate", status=200)
 
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(group.name))
+        self._check_submission_problem(resp, f"{group.name} is already used.")
 
     def test_delete(self, test_app, dbsession, layer_groups_test_data):
         from c2cgeoportal_commons.models.main import LayerGroup, LayergroupTreeitem, TreeGroup, TreeItem
 
         group_id = layer_groups_test_data["groups"][9].id
 
         assert (
@@ -288,15 +284,15 @@
         )
 
         assert (
             1
             == dbsession.query(LayergroupTreeitem).filter(LayergroupTreeitem.treeitem_id == group_id).count()
         )
 
-        test_app.delete("/admin/layer_groups/{}".format(group_id), status=200)
+        test_app.delete(f"/admin/layer_groups/{group_id}", status=200)
 
         dbsession.expire_all()
 
         assert dbsession.query(LayerGroup).get(group_id) is None
         assert dbsession.query(TreeGroup).get(group_id) is None
         assert dbsession.query(TreeItem).get(group_id) is None
```

## tests/test_layers_vectortiles.py

```diff
@@ -10,21 +10,21 @@
 @pytest.fixture(scope="function")
 @pytest.mark.usefixtures("dbsession", "transact")
 def layer_vectortiles_test_data(dbsession, transact):
     del transact
 
     from c2cgeoportal_commons.models.main import LayerVectorTiles, OGCServer
 
-    servers = [OGCServer(name="server_{}".format(i)) for i in range(0, 4)]
+    servers = [OGCServer(name=f"server_{i}") for i in range(0, 4)]
     for i, server in enumerate(servers):
-        server.url = "http://wms.geo.admin.ch_{}".format(i)
+        server.url = f"http://wms.geo.admin.ch_{i}"
         server.image_type = "image/jpeg" if i % 2 == 0 else "image/png"
 
     def layer_builder(i):
-        name = "layer_vectortiles_{}".format(i)
+        name = f"layer_vectortiles_{i}"
         layer = LayerVectorTiles(name=name)
         layer.layer = name
         layer.public = 1 == i % 2
         layer.style = "https://vectortiles-staging.geoportail.lu/styles/roadmap/style.json"
         layer.xyz = "https://vectortiles-staging.geoportail.lu/styles/roadmap/{z}/{x}/{y}.png"
         return layer
 
@@ -118,19 +118,19 @@
         assert layer.public == form["public"].checked
         assert str(layer.geo_table or "") == form["geo_table"].value
         assert str(layer.exclude_properties or "") == form["exclude_properties"].value
         assert str(layer.style or "") == form["style"].value
         assert str(layer.xyz or "") == form["xyz"].value
 
         interfaces = layer_vectortiles_test_data["interfaces"]
-        assert set((interfaces[0].id, interfaces[2].id)) == set(i.id for i in layer.interfaces)
+        assert {interfaces[0].id, interfaces[2].id} == {i.id for i in layer.interfaces}
         self._check_interfaces(form, interfaces, layer)
 
         ras = layer_vectortiles_test_data["restrictionareas"]
-        assert set((ras[0].id, ras[2].id)) == set(i.id for i in layer.restrictionareas)
+        assert {ras[0].id, ras[2].id} == {i.id for i in layer.restrictionareas}
         self._check_restrictionsareas(form, ras, layer)
 
         new_values = {
             "name": "new_name",
             "description": "new description",
             "public": True,
             "geo_table": "new_geo_table",
@@ -142,27 +142,25 @@
         for key, value in new_values.items():
             self.set_first_field_named(form, key, value)
         form["interfaces"] = [interfaces[1].id, interfaces[3].id]
         form["restrictionareas"] = [ras[1].id, ras[3].id]
 
         resp = form.submit("submit")
         assert str(layer.id) == re.match(
-            r"http://localhost{}/(.*)\?msg_col=submit_ok".format(self._prefix), resp.location
+            rf"http://localhost{self._prefix}/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
 
         dbsession.expire(layer)
         for key, value in new_values.items():
             if isinstance(value, bool):
                 assert value == getattr(layer, key)
             else:
                 assert str(value or "") == str(getattr(layer, key) or "")
-        assert set([interfaces[1].id, interfaces[3].id]) == set(
-            [interface.id for interface in layer.interfaces]
-        )
-        assert set([ras[1].id, ras[3].id]) == set([ra.id for ra in layer.restrictionareas])
+        assert {interfaces[1].id, interfaces[3].id} == {interface.id for interface in layer.interfaces}
+        assert {ras[1].id, ras[3].id} == {ra.id for ra in layer.restrictionareas}
 
     def test_submit_new(self, dbsession, test_app, layer_vectortiles_test_data):
         from c2cgeoportal_commons.models.main import LayerVectorTiles
 
         resp = test_app.post(
             "/admin/layers_vectortiles/new",
             {
@@ -181,28 +179,28 @@
         ).group(1)
 
     def test_duplicate(self, layer_vectortiles_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import LayerVectorTiles
 
         layer = layer_vectortiles_test_data["layers"][3]
 
-        resp = test_app.get("/admin/layers_vectortiles/{}/duplicate".format(layer.id), status=200)
+        resp = test_app.get(f"/admin/layers_vectortiles/{layer.id}/duplicate", status=200)
         form = resp.form
 
         assert "" == self.get_first_field_named(form, "id").value
         assert layer.name == self.get_first_field_named(form, "name").value
         assert str(layer.description or "") == self.get_first_field_named(form, "description").value
         assert layer.public is True
         assert layer.public == form["public"].checked
         assert str(layer.geo_table or "") == form["geo_table"].value
         assert str(layer.exclude_properties or "") == form["exclude_properties"].value
         assert str(layer.style or "") == form["style"].value
         assert str(layer.xyz or "") == form["xyz"].value
         interfaces = layer_vectortiles_test_data["interfaces"]
-        assert set((interfaces[3].id, interfaces[1].id)) == set(i.id for i in layer.interfaces)
+        assert {interfaces[3].id, interfaces[1].id} == {i.id for i in layer.interfaces}
         self._check_interfaces(form, interfaces, layer)
 
         self.set_first_field_named(form, "name", "clone")
         resp = form.submit("submit")
 
         layer = dbsession.query(LayerVectorTiles).filter(LayerVectorTiles.name == "clone").one()
         assert str(layer.id) == re.match(
@@ -214,12 +212,12 @@
         assert layer_vectortiles_test_data["layers"][3].metadatas[1].name == layer.metadatas[1].name
 
     def test_delete(self, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Layer, LayerVectorTiles, TreeItem
 
         layer_id = dbsession.query(LayerVectorTiles.id).first().id
 
-        test_app.delete("/admin/layers_vectortiles/{}".format(layer_id), status=200)
+        test_app.delete(f"/admin/layers_vectortiles/{layer_id}", status=200)
 
         assert dbsession.query(LayerVectorTiles).get(layer_id) is None
         assert dbsession.query(Layer).get(layer_id) is None
         assert dbsession.query(TreeItem).get(layer_id) is None
```

## tests/test_layers_wms.py

```diff
@@ -10,24 +10,24 @@
 @pytest.fixture(scope="function")
 @pytest.mark.usefixtures("dbsession", "transact")
 def layer_wms_test_data(dbsession, transact):
     del transact
 
     from c2cgeoportal_commons.models.main import LayerWMS, OGCServer
 
-    servers = [OGCServer(name="server_{}".format(i)) for i in range(0, 4)]
+    servers = [OGCServer(name=f"server_{i}") for i in range(0, 4)]
     for i, server in enumerate(servers):
-        server.url = "http://wms.geo.admin.ch_{}".format(i)
+        server.url = f"http://wms.geo.admin.ch_{i}"
         server.image_type = "image/jpeg" if i % 2 == 0 else "image/png"
 
     def layer_builder(i):
-        layer = LayerWMS(name="layer_wms_{}".format(i))
-        layer.layer = "layer_{}".format(i)
+        layer = LayerWMS(name=f"layer_wms_{i}")
+        layer.layer = f"layer_{i}"
         layer.public = 1 == i % 2
-        layer.geo_table = "geotable_{}".format(i)
+        layer.geo_table = f"geotable_{i}"
         layer.ogc_server = servers[i % 4]
         layer.style = "dcontrast"
         return layer
 
     data = factory_build_layers(layer_builder, dbsession)
     data["servers"] = servers
     data["default"] = get_test_default_layers(dbsession, servers[1])
@@ -169,19 +169,19 @@
         assert str(layer.ogc_server_id) == form["ogc_server_id"].value
         assert str(layer.layer or "") == form["layer"].value
         assert str(layer.style or "") == form["style"].value
         assert str(layer.time_mode) == form["time_mode"].value
         assert str(layer.time_widget) == form["time_widget"].value
 
         interfaces = layer_wms_test_data["interfaces"]
-        assert set((interfaces[0].id, interfaces[2].id)) == set(i.id for i in layer.interfaces)
+        assert {interfaces[0].id, interfaces[2].id} == {i.id for i in layer.interfaces}
         self._check_interfaces(form, interfaces, layer)
 
         ras = layer_wms_test_data["restrictionareas"]
-        assert set((ras[0].id, ras[2].id)) == set(i.id for i in layer.restrictionareas)
+        assert {ras[0].id, ras[2].id} == {i.id for i in layer.restrictionareas}
         self._check_restrictionsareas(form, ras, layer)
 
         new_values = {
             "name": "new_name",
             "description": "new description",
             "public": True,
             "geo_table": "new_geo_table",
@@ -196,27 +196,25 @@
         for key, value in new_values.items():
             self.set_first_field_named(form, key, value)
         form["interfaces"] = [interfaces[1].id, interfaces[3].id]
         form["restrictionareas"] = [ras[1].id, ras[3].id]
 
         resp = form.submit("submit")
         assert str(layer.id) == re.match(
-            r"http://localhost{}/(.*)\?msg_col=submit_ok".format(self._prefix), resp.location
+            rf"http://localhost{self._prefix}/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
 
         dbsession.expire(layer)
         for key, value in new_values.items():
             if isinstance(value, bool):
                 assert value == getattr(layer, key)
             else:
                 assert str(value or "") == str(getattr(layer, key) or "")
-        assert set([interfaces[1].id, interfaces[3].id]) == set(
-            [interface.id for interface in layer.interfaces]
-        )
-        assert set([ras[1].id, ras[3].id]) == set([ra.id for ra in layer.restrictionareas])
+        assert {interfaces[1].id, interfaces[3].id} == {interface.id for interface in layer.interfaces}
+        assert {ras[1].id, ras[3].id} == {ra.id for ra in layer.restrictionareas}
 
     def test_submit_new(self, dbsession, test_app, layer_wms_test_data):
         from c2cgeoportal_commons.models.main import LayerWMS
 
         resp = test_app.post(
             "/admin/layers_wms/new",
             {
@@ -240,15 +238,15 @@
         ).group(1)
 
     def test_duplicate(self, layer_wms_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import LayerWMS
 
         layer = layer_wms_test_data["layers"][3]
 
-        resp = test_app.get("/admin/layers_wms/{}/duplicate".format(layer.id), status=200)
+        resp = test_app.get(f"/admin/layers_wms/{layer.id}/duplicate", status=200)
         form = resp.form
 
         assert "" == self.get_first_field_named(form, "id").value
         assert layer.name == self.get_first_field_named(form, "name").value
         assert str(layer.description or "") == self.get_first_field_named(form, "description").value
         assert layer.public is True
         assert layer.public == form["public"].checked
@@ -256,19 +254,19 @@
         assert str(layer.exclude_properties or "") == form["exclude_properties"].value
         assert str(layer.ogc_server_id) == form["ogc_server_id"].value
         assert str(layer.layer or "") == form["layer"].value
         assert str(layer.style or "") == form["style"].value
         assert str(layer.time_mode) == form["time_mode"].value
         assert str(layer.time_widget) == form["time_widget"].value
         interfaces = layer_wms_test_data["interfaces"]
-        assert set((interfaces[3].id, interfaces[1].id)) == set(i.id for i in layer.interfaces)
+        assert {interfaces[3].id, interfaces[1].id} == {i.id for i in layer.interfaces}
         self._check_interfaces(form, interfaces, layer)
 
         ras = layer_wms_test_data["restrictionareas"]
-        assert set((ras[3].id, ras[0].id)) == set(i.id for i in layer.restrictionareas)
+        assert {ras[3].id, ras[0].id} == {i.id for i in layer.restrictionareas}
         self._check_restrictionsareas(form, ras, layer)
 
         self._check_dimensions(resp.html, layer.dimensions, duplicated=True)
 
         self.set_first_field_named(form, "name", "clone")
         resp = form.submit("submit")
 
@@ -285,20 +283,17 @@
         from c2cgeoportal_commons.models.main import LayerWMS, LayerWMTS
 
         layer = layer_wms_test_data["layers"][3]
 
         assert 0 == dbsession.query(LayerWMTS).filter(LayerWMTS.name == layer.name).count()
         assert 1 == dbsession.query(LayerWMS).filter(LayerWMS.name == layer.name).count()
 
-        resp = test_app.post("/admin/layers_wms/{}/convert_to_wmts".format(layer.id), status=200)
+        resp = test_app.post(f"/admin/layers_wms/{layer.id}/convert_to_wmts", status=200)
         assert resp.json["success"]
-        assert (
-            "http://localhost/admin/layers_wmts/{}?msg_col=submit_ok".format(layer.id)
-            == resp.json["redirect"]
-        )
+        assert f"http://localhost/admin/layers_wmts/{layer.id}?msg_col=submit_ok" == resp.json["redirect"]
 
         assert 1 == dbsession.query(LayerWMTS).filter(LayerWMTS.name == layer.name).count()
         assert 0 == dbsession.query(LayerWMS).filter(LayerWMS.name == layer.name).count()
 
         resp = test_app.get(resp.json["redirect"], status=200)
         form = resp.form
 
@@ -324,73 +319,67 @@
             "Your submission has been taken into account."
             == resp.html.find("div", {"class": "msg-lbl"}).getText()
         )
 
     def test_convert_image_type_from_ogcserver(self, layer_wms_test_data, test_app):
         layer = layer_wms_test_data["layers"][3]
 
-        resp = test_app.post("/admin/layers_wms/{}/convert_to_wmts".format(layer.id), status=200)
+        resp = test_app.post(f"/admin/layers_wms/{layer.id}/convert_to_wmts", status=200)
         assert resp.json["success"]
-        assert (
-            "http://localhost/admin/layers_wmts/{}?msg_col=submit_ok".format(layer.id)
-            == resp.json["redirect"]
-        )
+        assert f"http://localhost/admin/layers_wmts/{layer.id}?msg_col=submit_ok" == resp.json["redirect"]
 
         resp = test_app.get(resp.json["redirect"], status=200)
         assert "image/png" == resp.form["image_type"].value
 
         layer = layer_wms_test_data["layers"][2]
-        resp = test_app.post("/admin/layers_wms/{}/convert_to_wmts".format(layer.id), status=200)
+        resp = test_app.post(f"/admin/layers_wms/{layer.id}/convert_to_wmts", status=200)
         assert resp.json["success"]
-        assert (
-            "http://localhost/admin/layers_wmts/{}?msg_col=submit_ok".format(layer.id)
-            == resp.json["redirect"]
-        )
+        assert f"http://localhost/admin/layers_wmts/{layer.id}?msg_col=submit_ok" == resp.json["redirect"]
 
         resp = test_app.get(resp.json["redirect"], status=200)
         assert "image/jpeg" == resp.form["image_type"].value
 
     def test_convert_without_wmts_defaults(self, test_app, layer_wms_test_data, dbsession):
         from c2cgeoportal_commons.models.main import LayerWMTS
 
         dbsession.delete(LayerWMTS.get_default(dbsession))
         layer = layer_wms_test_data["layers"][3]
-        test_app.post("/admin/layers_wms/{}/convert_to_wmts".format(layer.id), status=200)
+        test_app.post(f"/admin/layers_wms/{layer.id}/convert_to_wmts", status=200)
 
     def test_unicity_validator(self, layer_wms_test_data, test_app):
         layer = layer_wms_test_data["layers"][2]
-        resp = test_app.get("/admin/layers_wms/{}/duplicate".format(layer.id), status=200)
+        resp = test_app.get(f"/admin/layers_wms/{layer.id}/duplicate", status=200)
 
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(layer.name))
+        self._check_submission_problem(resp, f"{layer.name} is already used.")
 
     def test_unicity_validator_does_not_matter_amongst_cousin(self, layer_wms_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import LayerGroup, LayerWMS
 
         assert 1 == dbsession.query(LayerGroup).filter(LayerGroup.name == "layer_group_0").count()
 
         assert dbsession.query(LayerWMS).filter(LayerWMS.name == "layer_group_0").one_or_none() is None
 
         layer = layer_wms_test_data["layers"][2]
-        resp = test_app.get("/admin/layers_wms/{}/duplicate".format(layer.id), status=200)
+        resp = test_app.get(f"/admin/layers_wms/{layer.id}/duplicate", status=200)
         self.set_first_field_named(resp.form, "name", "layer_group_0")
         resp = resp.form.submit("submit")
 
         # layer = dbsession.query(LayerWMS). \
         #     filter(LayerWMS.name == 'layer_group_0'). \
         #     one()
         # assert str(layer.id) == re.match('http://localhost/admin/layers_wms/(.*)', resp.location).group(1)
 
     def test_delete(self, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Layer, LayerWMS, TreeItem
 
         layer_id = dbsession.query(LayerWMS.id).first().id
 
-        test_app.delete("/admin/layers_wms/{}".format(layer_id), status=200)
+        test_app.delete(f"/admin/layers_wms/{layer_id}", status=200)
 
         assert dbsession.query(LayerWMS).get(layer_id) is None
         assert dbsession.query(Layer).get(layer_id) is None
         assert dbsession.query(TreeItem).get(layer_id) is None
 
     def test_submit_new_no_layer_name(self, test_app, layer_wms_test_data):
         resp = test_app.post(
@@ -413,9 +402,9 @@
             "There was a problem with your submission"
             == resp.html.select_one('div[class="error-msg-lbl"]').text
         )
         assert (
             "Errors have been highlighted below" == resp.html.select_one('div[class="error-msg-detail"]').text
         )
         assert ["WMS layer name"] == sorted(
-            [(x.select_one("label").text.strip()) for x in resp.html.select("[class~='has-error']")]
+            (x.select_one("label").text.strip()) for x in resp.html.select("[class~='has-error']")
         )
```

## tests/test_layers_wmts.py

```diff
@@ -15,20 +15,20 @@
     from c2cgeoportal_commons.models.main import LayerWMTS, OGCServer
 
     server = OGCServer(name="server_1")
     server.url = "http://wms.geo.admin.ch_1"
     server.image_type = "image/png"
 
     def layer_builder(i):
-        name = "layer_wmts_{}".format(i)
+        name = f"layer_wmts_{i}"
         layer = LayerWMTS(name=name)
         layer.layer = name
-        layer.url = "https:///wms.geo.admin.ch_{}.org?service=wms&request=GetCapabilities".format(i)
+        layer.url = f"https:///wms.geo.admin.ch_{i}.org?service=wms&request=GetCapabilities"
         layer.public = 1 == i % 2
-        layer.geo_table = "geotable_{}".format(i)
+        layer.geo_table = f"geotable_{i}"
         layer.image_type = "image/jpeg"
         layer.style = "dcontrast"
         return layer
 
     data = factory_build_layers(layer_builder, dbsession)
     data["default"] = get_test_default_layers(dbsession, server)
 
@@ -117,19 +117,19 @@
         assert str(layer.url or "") == self.get_first_field_named(form, "url").value
         assert str(layer.layer or "") == form["layer"].value
         assert str(layer.style or "") == form["style"].value
         assert str(layer.matrix_set or "") == form["matrix_set"].value
         assert str(layer.image_type or "") == form["image_type"].value
 
         interfaces = layer_wmts_test_data["interfaces"]
-        assert set((interfaces[0].id, interfaces[2].id)) == set(i.id for i in layer.interfaces)
+        assert {interfaces[0].id, interfaces[2].id} == {i.id for i in layer.interfaces}
         self._check_interfaces(form, interfaces, layer)
 
         ras = layer_wmts_test_data["restrictionareas"]
-        assert set((ras[0].id, ras[2].id)) == set(i.id for i in layer.restrictionareas)
+        assert {ras[0].id, ras[2].id} == {i.id for i in layer.restrictionareas}
         self._check_restrictionsareas(form, ras, layer)
 
         new_values = {
             "name": "new_name",
             "description": "new description",
             "public": True,
             "geo_table": "new_geo_table",
@@ -144,34 +144,32 @@
         for key, value in new_values.items():
             self.set_first_field_named(form, key, value)
         form["interfaces"] = [interfaces[1].id, interfaces[3].id]
         form["restrictionareas"] = [ras[1].id, ras[3].id]
 
         resp = form.submit("submit")
         assert str(layer.id) == re.match(
-            r"http://localhost{}/(.*)\?msg_col=submit_ok".format(self._prefix), resp.location
+            rf"http://localhost{self._prefix}/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
 
         dbsession.expire(layer)
         for key, value in new_values.items():
             if isinstance(value, bool):
                 assert value == getattr(layer, key)
             else:
                 assert str(value or "") == str(getattr(layer, key) or "")
-        assert set([interfaces[1].id, interfaces[3].id]) == set(
-            [interface.id for interface in layer.interfaces]
-        )
-        assert set([ras[1].id, ras[3].id]) == set([ra.id for ra in layer.restrictionareas])
+        assert {interfaces[1].id, interfaces[3].id} == {interface.id for interface in layer.interfaces}
+        assert {ras[1].id, ras[3].id} == {ra.id for ra in layer.restrictionareas}
 
     def test_duplicate(self, layer_wmts_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import LayerWMTS
 
         layer = layer_wmts_test_data["layers"][3]
 
-        resp = test_app.get("/admin/layers_wmts/{}/duplicate".format(layer.id), status=200)
+        resp = test_app.get(f"/admin/layers_wmts/{layer.id}/duplicate", status=200)
         form = resp.form
 
         assert "" == self.get_first_field_named(form, "id").value
         assert layer.name == self.get_first_field_named(form, "name").value
         assert str(layer.description or "") == self.get_first_field_named(form, "description").value
         assert layer.public is True
         assert layer.public == form["public"].checked
@@ -192,40 +190,38 @@
         ).group(1)
 
     def test_delete(self, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Layer, LayerWMTS, TreeItem
 
         layer_id = dbsession.query(LayerWMTS.id).first().id
 
-        test_app.delete("/admin/layers_wmts/{}".format(layer_id), status=200)
+        test_app.delete(f"/admin/layers_wmts/{layer_id}", status=200)
 
         assert dbsession.query(LayerWMTS).get(layer_id) is None
         assert dbsession.query(Layer).get(layer_id) is None
         assert dbsession.query(TreeItem).get(layer_id) is None
 
     def test_unicity_validator(self, layer_wmts_test_data, test_app):
         layer = layer_wmts_test_data["layers"][2]
-        resp = test_app.get("/admin/layers_wmts/{}/duplicate".format(layer.id), status=200)
+        resp = test_app.get(f"/admin/layers_wmts/{layer.id}/duplicate", status=200)
 
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(layer.name))
+        self._check_submission_problem(resp, f"{layer.name} is already used.")
 
     def test_convert_common_fields_copied(self, layer_wmts_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import LayerWMS, LayerWMTS
 
         layer = layer_wmts_test_data["layers"][3]
 
         assert 0 == dbsession.query(LayerWMS).filter(LayerWMS.name == layer.name).count()
         assert 1 == dbsession.query(LayerWMTS).filter(LayerWMTS.name == layer.name).count()
 
-        resp = test_app.post("/admin/layers_wmts/{}/convert_to_wms".format(layer.id), status=200)
-        assert (
-            "http://localhost/admin/layers_wms/{}?msg_col=submit_ok".format(layer.id) == resp.json["redirect"]
-        )
+        resp = test_app.post(f"/admin/layers_wmts/{layer.id}/convert_to_wms", status=200)
+        assert f"http://localhost/admin/layers_wms/{layer.id}?msg_col=submit_ok" == resp.json["redirect"]
 
         assert 1 == dbsession.query(LayerWMS).filter(LayerWMS.name == layer.name).count()
         assert 0 == dbsession.query(LayerWMTS).filter(LayerWMTS.name == layer.name).count()
 
         resp = test_app.get(resp.json["redirect"], status=200)
         form = resp.form
 
@@ -252,8 +248,8 @@
         )
 
     def test_convert_without_wms_defaults(self, test_app, layer_wmts_test_data, dbsession):
         from c2cgeoportal_commons.models.main import LayerWMS
 
         dbsession.delete(LayerWMS.get_default(dbsession))
         layer = layer_wmts_test_data["layers"][3]
-        test_app.post("/admin/layers_wmts/{}/convert_to_wms".format(layer.id), status=200)
+        test_app.post(f"/admin/layers_wmts/{layer.id}/convert_to_wms", status=200)
```

## tests/test_layertree.py

```diff
@@ -9,56 +9,74 @@
 
 @pytest.fixture(scope="function")
 @pytest.mark.usefixtures("dbsession", "transact")
 def layertree_test_data(dbsession, transact):
     del transact
 
     from c2cgeoportal_commons.models.main import (
+        Interface,
         LayerGroup,
         LayergroupTreeitem,
         LayerWMS,
         LayerWMTS,
         OGCServer,
         Theme,
     )
 
+    interface1 = Interface("interface1")
+    dbsession.add(interface1)
+    interface2 = Interface("interface2")
+    dbsession.add(interface2)
+
     layers_wms = []
     ogc_server = OGCServer(name="ogc_server")
     dbsession.add(ogc_server)
-    for i in range(0, 10):
-        layer_wms = LayerWMS(name="layer_wms_{}".format(i))
+    for i in range(10):
+        layer_wms = LayerWMS(name=f"layer_wms_{i}")
+        if i == 1:
+            layer_wms.interfaces = [interface1]
+        elif i > 1:
+            layer_wms.interfaces = [interface1, interface2]
         layer_wms.ogc_server = ogc_server
         layers_wms.append(layer_wms)
         dbsession.add(layer_wms)
 
     layers_wmts = []
-    for i in range(0, 10):
-        layer_wmts = LayerWMTS(name="layer_wmts_{}".format(i))
+    for i in range(10):
+        layer_wmts = LayerWMTS(name=f"layer_wmts_{i}")
+        if i == 1:
+            layer_wmts.interfaces = [interface1]
+        elif i > 1:
+            layer_wmts.interfaces = [interface1, interface2]
         layer_wmts.url = "http://localhost/wmts"
         layer_wmts.layer = layer_wmts.name
         layers_wmts.append(layer_wmts)
         dbsession.add(layer_wmts)
 
     groups = []
-    for i in range(0, 10):
-        group = LayerGroup(name="layer_group_{}".format(i))
+    for i in range(10):
+        group = LayerGroup(name=f"layer_group_{i}")
         groups.append(group)
         dbsession.add(group)
 
         for j, items in enumerate((layers_wms, layers_wmts)):
             dbsession.add(LayergroupTreeitem(group=group, item=items[i], ordering=j))
 
     # a group in a group
     dbsession.add(LayergroupTreeitem(group=groups[9], item=groups[8], ordering=3))
 
     themes = []
-    for i in range(0, 5):
-        theme = Theme(name="theme_{}".format(i))
+    for i in range(5):
+        theme = Theme(name=f"theme_{i}")
         themes.append(theme)
         dbsession.add(theme)
+        if i == 1:
+            theme.interfaces = [interface1]
+        elif i > 1:
+            theme.interfaces = [interface1, interface2]
 
         dbsession.add(LayergroupTreeitem(group=theme, item=groups[i], ordering=0))
         dbsession.add(LayergroupTreeitem(group=theme, item=groups[i + 5], ordering=1))
 
     themes[0].ordering = 1
     themes[3].ordering = 2
     themes[1].ordering = 3
@@ -70,14 +88,15 @@
     yield (
         {
             "themes": themes,
             "groups": groups,
             "layers_wms": layers_wms,
             "layers_wmts": layers_wmts,
             "ogc_servers": [ogc_server],
+            "interfaces": [interface1, interface2],
         }
     )
 
 
 @patch(
     "c2cgeoportal_admin.views.layertree.TranslationStringFactory",
     new=lambda factory_domain: (str(factory_domain) + "_{}_").format,
@@ -89,33 +108,33 @@
 
     def test_index(self, test_app):
         self.get(test_app, status=200)
 
     def check_edit_action(self, test_app, nodes, table, item_id):
         node = next(n for n in nodes if n["id"] == item_id)
         action = next(a for a in node["actions"] if a["name"] == "edit")
-        assert "http://localhost/admin/{}/{}".format(table, item_id) == action["url"]
+        assert f"http://localhost/admin/{table}/{item_id}" == action["url"]
         test_app.get(action["url"], status=200)
 
     def check_unlink_action(self, test_app, nodes, group_id, item_id):
         node = next(n for n in nodes if n["id"] == item_id)
         action = next(a for a in node["actions"] if a["name"] == "unlink")
-        assert "http://localhost/admin/layertree/unlink/{}/{}".format(group_id, item_id) == action["url"]
+        assert f"http://localhost/admin/layertree/unlink/{group_id}/{item_id}" == action["url"]
         test_app.delete(action["url"], status=200)
 
     def check_translation(self, nodes, item):
         node = next(n for n in nodes if n["id"] == item.id)
         expected_factory_domain = "c2cgeoportal_admin-client"
         assert (expected_factory_domain + "_{}_").format(item.name) == node["translated_name"]
 
     def check_new_action(self, test_app, nodes, parent_id, action_name, label, route_table, required_fields):
         node = next(n for n in nodes if n["id"] == parent_id)
         action = next(a for a in node["actions"] if a["name"] == action_name)
         assert label == action["label"]
-        assert "http://localhost/admin/{}/new?parent_id={}".format(route_table, parent_id) == action["url"]
+        assert f"http://localhost/admin/{route_table}/new?parent_id={parent_id}" == action["url"]
 
         form = test_app.get(action["url"], status=200).form
         assert form["parent_id"].value == str(parent_id)
         for required_field in required_fields:
             form[required_field] = required_fields[required_field]
         form.submit("submit", 302)
 
@@ -146,20 +165,34 @@
             theme.id,
             "new_layer_group",
             "New layer group",
             "layer_groups",
             {"name": "new_name_from_layer_group"},
         )
 
-    def test_groups(self, test_app, layertree_test_data):
+    def test_groups(self, test_app, layertree_test_data, dbsession):
         theme = layertree_test_data["themes"][0]
+
+        # Invert children order (to test ordering)
+        theme.children_relation[0].ordering = 1
+        theme.children_relation[1].ordering = 0
+        dbsession.flush()
+
         resp = self.get(test_app, "/children?group_id={0}&path=_{0}".format(theme.id), status=200)
         nodes = resp.json
         assert 2 == len(nodes)
 
+        # check groups are sorted by ordering
+        expected = [
+            relation.treeitem.name
+            for relation in sorted(theme.children_relation, key=lambda relation: relation.ordering)
+        ]
+        group_names = [node["name"] for node in nodes]
+        assert expected == group_names
+
         group = layertree_test_data["groups"][0]
         self.check_edit_action(test_app, nodes, "layer_groups", group.id)
         self.check_unlink_action(test_app, nodes, theme.id, group.id)
         self.check_translation(nodes, group)
 
         ogc_server = layertree_test_data["ogc_servers"][0]
         self.check_new_action(
@@ -182,23 +215,37 @@
                 "url": "http://localhost/wmts/fromtree",
                 "name": "layer-wmts-from-tree",
                 "image_type": "image/jpeg",
                 "layer": "layer-wmts-from-tree",
             },
         )
 
-    def test_layers(self, test_app, layertree_test_data):
+    def test_layers(self, test_app, layertree_test_data, dbsession):
         theme = layertree_test_data["themes"][0]
         group = layertree_test_data["groups"][0]
+
+        # Invert children order (to test ordering)
+        group.children_relation[0].ordering = 1
+        group.children_relation[1].ordering = 0
+        dbsession.flush()
+
         resp = self.get(
             test_app, "/children?group_id={0}&path=_{1}_{0}".format(group.id, theme.id), status=200
         )
         nodes = resp.json
         assert len(nodes) == 2
 
+        # check layers are sorted by ordering
+        expected = [
+            relation.treeitem.name
+            for relation in sorted(group.children_relation, key=lambda relation: relation.ordering)
+        ]
+        layer_names = [node["name"] for node in nodes]
+        assert expected == layer_names
+
         layer_wms = layertree_test_data["layers_wms"][0]
         layer_wmts = layertree_test_data["layers_wmts"][0]
 
         for table, item_id in (("layers_wms", layer_wms.id), ("layers_wmts", layer_wmts.id)):
             self.check_edit_action(test_app, nodes, table, item_id)
 
         for group_id, item_id in ((group.id, layer_wmts.id), (group.id, layer_wms.id)):
@@ -206,15 +253,15 @@
 
         for item in [layer_wms, layer_wmts]:
             self.check_translation(nodes, item)
 
     def test_unlink(self, test_app, layertree_test_data, dbsession):
         group = layertree_test_data["groups"][0]
         item = layertree_test_data["layers_wms"][0]
-        test_app.delete("/admin/layertree/unlink/{}/{}".format(group.id, item.id), status=200)
+        test_app.delete(f"/admin/layertree/unlink/{group.id}/{item.id}", status=200)
         dbsession.expire_all()
         assert item not in group.children
 
     def test_delete(self, test_app, layertree_test_data, dbsession):
         from c2cgeoportal_commons.models.main import LayerGroup, LayerWMS, LayerWMTS
 
         groups = layertree_test_data["groups"]
@@ -222,9 +269,46 @@
         layers_wmts = layertree_test_data["layers_wmts"]
 
         for item_id, model in (
             (layers_wmts[1].id, LayerWMTS),
             (layers_wms[1].id, LayerWMS),
             (groups[1].id, LayerGroup),
         ):
-            test_app.delete("/admin/layertree/delete/{}".format(item_id), status=200)
+            test_app.delete(f"/admin/layertree/delete/{item_id}", status=200)
             assert dbsession.query(model).get(item_id) is None
+
+    @pytest.mark.parametrize(
+        "params,expected",
+        [
+            ({}, ["theme_0", "theme_3", "theme_1", "theme_2", "theme_4"]),
+            ({"interface": "interface1"}, ["theme_3", "theme_1", "theme_2", "theme_4"]),
+            ({"interface": "interface2"}, ["theme_3", "theme_2", "theme_4"]),
+        ],
+    )
+    def test_themes_interfaces(self, test_app, layertree_test_data, params, expected):
+        resp = self.get(test_app, "/children", status=200, params=params)
+        nodes = resp.json
+        assert expected == [node["name"] for node in nodes if node["item_type"] == "theme"]
+
+    @pytest.mark.parametrize(
+        "interface,index,length",
+        [
+            (None, 0, 2),
+            (None, 1, 2),
+            (None, 2, 2),
+            ("interface1", 0, 0),
+            ("interface1", 1, 2),
+            ("interface1", 2, 2),
+            ("interface2", 0, 0),
+            ("interface2", 1, 0),
+            ("interface2", 2, 2),
+        ],
+    )
+    def test_layers_interface(self, test_app, layertree_test_data, interface, index, length):
+        theme = layertree_test_data["themes"][index]
+        group = layertree_test_data["groups"][index]
+        params = {"group_id": group.id, "path": f"_{theme.id}_{group.id}"}
+        if interface:
+            params["interface"] = interface
+        resp = self.get(test_app, "/children", status=200, params=params)
+        nodes = resp.json
+        assert length == len(nodes)
```

## tests/test_main.py

```diff
@@ -1,12 +1,14 @@
 import pytest
 from pyramid import testing
 from webtest import TestApp as WebTestApp
 
 
 @pytest.mark.usefixtures("app_env")
 def test_main(app_env):
-    """Test dev environment"""
+    """
+    Test dev environment.
+    """
     config = testing.setUp(registry=app_env["registry"])
     app = config.make_wsgi_app()
     testapp = WebTestApp(app)
     testapp.get("/admin/layertree/children", status=200)
```

## tests/test_metadatas.py

```diff
@@ -81,28 +81,28 @@
             if metadata.value == "true":
                 return True
             if metadata.value == "false":
                 return False
             return None
         return metadata.value
 
-    def _check_metadatas(self, test_app, item, metadatas):
+    def _check_metadatas(self, test_app, item, metadatas, model):
+        from c2cgeoportal_admin.schemas.metadata import metadata_definitions
+
         settings = test_app.app.registry.settings
         self._check_sequence(
             item,
             [
                 [
                     {"name": "id", "value": str(m.id), "hidden": True},
                     {
                         "name": "name",
                         "value": [
                             {"text": s_m["name"], "value": s_m["name"], "selected": s_m["name"] == m.name}
-                            for s_m in sorted(
-                                settings["admin_interface"]["available_metadata"], key=lambda m: m["name"]
-                            )
+                            for s_m in sorted(metadata_definitions(settings, model), key=lambda m: m["name"])
                         ],
                         "label": "Name",
                     },
                     {
                         "name": self.__metadata_ui_type(test_app, m.name),
                         "value": self.expected_value(test_app, m),
                     },
@@ -127,15 +127,15 @@
             status=status,
         )
 
     def _post_invalid_metadata(self, test_app, url, base_mapping, name, value, error_msg):
         resp = self._post_metadata(test_app, url, base_mapping, name, value, 200)
         assert (
             error_msg
-            == resp.html.select_one(".item-{} .help-block".format(self.__metadata_ui_type(test_app, name)))
+            == resp.html.select_one(f".item-{self.__metadata_ui_type(test_app, name)} .help-block")
             .getText()
             .strip()
         )
         return resp
 
     @staticmethod
     def _base_metadata_params(metadatas_test_data):
@@ -152,48 +152,52 @@
             self._base_metadata_params(metadatas_test_data),
             "_float",
             "number",
             '"number" is not a number',
         )
 
     def test_get_true_boolean_metadata(self, metadatas_test_data, test_app):
-        metadatas_test_data["layer_wms"].get_metadatas("_boolean")[0].value = "true"
-        self._test_edit_treeitem("layers_wms", metadatas_test_data["layer_wms"], test_app)
+        from c2cgeoportal_commons.models.main import LayerWMS
+
+        metadatas_test_data["layer_wms"].get_metadata("_boolean")[0].value = "true"
+        self._test_edit_treeitem("layers_wms", metadatas_test_data["layer_wms"], test_app, LayerWMS)
 
     def test_get_false_boolean_metadata(self, metadatas_test_data, test_app):
-        metadatas_test_data["layer_wms"].get_metadatas("_boolean")[0].value = "false"
-        self._test_edit_treeitem("layers_wms", metadatas_test_data["layer_wms"], test_app)
+        from c2cgeoportal_commons.models.main import LayerWMS
+
+        metadatas_test_data["layer_wms"].get_metadata("_boolean")[0].value = "false"
+        self._test_edit_treeitem("layers_wms", metadatas_test_data["layer_wms"], test_app, LayerWMS)
 
     def test_post_true_boolean_metadata(self, test_app, metadatas_test_data, dbsession):
         from c2cgeoportal_commons.models.main import LayerWMS
 
         self._post_metadata(
             test_app,
             "/admin/layers_wms/new",
             self._base_metadata_params(metadatas_test_data),
             "_boolean",
             "true",
             302,
         )
         layer = dbsession.query(LayerWMS).filter(LayerWMS.name == "new_name").one()
-        assert layer.get_metadatas("_boolean")[0].value == "true"
+        assert layer.get_metadata("_boolean")[0].value == "true"
 
     def test_post_false_boolean_metadata(self, test_app, metadatas_test_data, dbsession):
         from c2cgeoportal_commons.models.main import LayerWMS
 
         self._post_metadata(
             test_app,
             "/admin/layers_wms/new",
             self._base_metadata_params(metadatas_test_data),
             "_boolean",
             "false",
             302,
         )
         layer = dbsession.query(LayerWMS).filter(LayerWMS.name == "new_name").one()
-        assert layer.get_metadatas("_boolean")[0].value == "false"
+        assert layer.get_metadata("_boolean")[0].value == "false"
 
     def test_valid_float_metadata(self, test_app, metadatas_test_data):
         self._post_metadata(
             test_app,
             "/admin/layers_wms/new",
             self._base_metadata_params(metadatas_test_data),
             "_float",
@@ -300,37 +304,47 @@
             "/admin/layers_wms/new",
             self._base_metadata_params(metadatas_test_data),
             "_color",
             "#007DCD",
             302,
         )
 
-    def _test_edit_treeitem(self, prefix, item, test_app):
-        resp = self.get(test_app, "{}/{}".format(prefix, item.id))
-        self._check_metadatas(test_app, resp.html.select_one(".item-metadatas"), item.metadatas)
+    def _test_edit_treeitem(self, prefix, item, test_app, model):
+        resp = self.get(test_app, f"{prefix}/{item.id}")
+        self._check_metadatas(test_app, resp.html.select_one(".item-metadatas"), item.metadatas, model)
         resp.form.submit("submit", status=302)
 
     def test_layer_wms_metadatas(self, metadatas_test_data, test_app):
-        self._test_edit_treeitem("layers_wms", metadatas_test_data["layer_wms"], test_app)
+        from c2cgeoportal_commons.models.main import LayerWMS
+
+        self._test_edit_treeitem("layers_wms", metadatas_test_data["layer_wms"], test_app, LayerWMS)
 
     def test_layer_wmts_metadatas(self, metadatas_test_data, test_app):
-        self._test_edit_treeitem("layers_wmts", metadatas_test_data["layer_wmts"], test_app)
+        from c2cgeoportal_commons.models.main import LayerWMTS
+
+        self._test_edit_treeitem("layers_wmts", metadatas_test_data["layer_wmts"], test_app, LayerWMTS)
 
     def test_theme_metadatas(self, metadatas_test_data, test_app):
-        self._test_edit_treeitem("themes", metadatas_test_data["theme"], test_app)
+        from c2cgeoportal_commons.models.main import Theme
+
+        self._test_edit_treeitem("themes", metadatas_test_data["theme"], test_app, Theme)
 
     def test_group_metadatas(self, metadatas_test_data, test_app):
-        self._test_edit_treeitem("layer_groups", metadatas_test_data["group"], test_app)
+        from c2cgeoportal_commons.models.main import LayerGroup
+
+        self._test_edit_treeitem("layer_groups", metadatas_test_data["group"], test_app, LayerGroup)
 
     def test_undefined_metadata(self, metadatas_test_data, test_app):
-        """Undefined metadata must be kept intact across submissions"""
+        """
+        Undefined metadata must be kept intact across submissions.
+        """
         from c2cgeoportal_commons.models.main import Metadata
 
         layer = metadatas_test_data["layer_wms"]
         layer.metadatas = [Metadata("_undefined", "This is an undefined metadata")]
 
-        resp = self.get(test_app, "layers_wms/{}".format(layer.id))
+        resp = self.get(test_app, f"layers_wms/{layer.id}")
         resp.form.submit("submit", status=302)
 
         metadata = layer.metadatas[0]
         assert metadata.name == "_undefined"
         assert metadata.value == "This is an undefined metadata"
```

## tests/test_oauth2_clients.py

```diff
@@ -113,15 +113,15 @@
         assert "New redirect URI" == oauth2_client.redirect_uri
 
     def test_duplicate(self, oauth2_clients_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.static import OAuth2Client
 
         oauth2_client_proto = oauth2_clients_test_data["oauth2_clients"][7]
 
-        resp = test_app.get("/admin/oauth2_clients/{}/duplicate".format(oauth2_client_proto.id), status=200)
+        resp = test_app.get(f"/admin/oauth2_clients/{oauth2_client_proto.id}/duplicate", status=200)
         form = resp.form
 
         assert "" == self.get_first_field_named(form, "id").value
         assert oauth2_client_proto.client_id == form["client_id"].value
         assert oauth2_client_proto.secret == form["secret"].value
         assert oauth2_client_proto.redirect_uri == form["redirect_uri"].value
         form["client_id"].value = "clone"
@@ -133,24 +133,24 @@
         ).group(1)
         assert oauth2_client_proto.id != oauth2_client.id
 
     def test_delete(self, test_app, dbsession):
         from c2cgeoportal_commons.models.static import OAuth2Client
 
         oauth2_client_id = dbsession.query(OAuth2Client.id).first().id
-        test_app.delete("/admin/oauth2_clients/{}".format(oauth2_client_id), status=200)
+        test_app.delete(f"/admin/oauth2_clients/{oauth2_client_id}", status=200)
         assert dbsession.query(OAuth2Client).get(oauth2_client_id) is None
 
     def test_unicity_validator(self, oauth2_clients_test_data, test_app):
         oauth2_client_proto = oauth2_clients_test_data["oauth2_clients"][7]
-        resp = test_app.get("/admin/oauth2_clients/{}/duplicate".format(oauth2_client_proto.id), status=200)
+        resp = test_app.get(f"/admin/oauth2_clients/{oauth2_client_proto.id}/duplicate", status=200)
 
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(oauth2_client_proto.client_id))
+        self._check_submission_problem(resp, f"{oauth2_client_proto.client_id} is already used.")
 
     @pytest.mark.usefixtures("raise_db_error_on_query")
     def test_grid_dberror(self, dbsession):
         from c2cgeoportal_admin.views.oauth2_clients import OAuth2ClientViews
 
         request = DummyRequest(dbsession=dbsession, params={"offset": 0, "limit": 10})
         info = OAuth2ClientViews(request).grid()
```

## tests/test_ogc_servers.py

```diff
@@ -13,16 +13,16 @@
     del transact
 
     from c2cgeoportal_commons.models.main import OGCServer
 
     auth = ["No auth", "Standard auth", "Geoserver auth", "Proxy"]
     servers = []
     for i in range(0, 8):
-        server = OGCServer(name="server_{}".format(i), description="description_{}".format(i))
-        server.url = "https://somebasicurl_{}.com".format(i)
+        server = OGCServer(name=f"server_{i}", description=f"description_{i}")
+        server.url = f"https://somebasicurl_{i}.com"
         server.image_type = "image/jpeg" if i % 2 == 0 else "image/png"
         server.auth = auth[i % 4]
         dbsession.add(server)
         servers.append(server)
 
     dbsession.flush()
 
@@ -77,79 +77,90 @@
         assert str(ogc_server.id) == re.match(
             r"http://localhost/admin/ogc_servers/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
         assert ogc_server.name == "new_name"
 
     def test_edit(self, test_app, ogc_server_test_data):
         ogc_server = ogc_server_test_data["ogc_servers"][0]
-        resp = test_app.get("/admin/ogc_servers/{}".format(ogc_server.id), status=200)
+        resp = test_app.get(f"/admin/ogc_servers/{ogc_server.id}", status=200)
         form = resp.form
         assert str(ogc_server.id) == self.get_first_field_named(form, "id").value
         assert "hidden" == self.get_first_field_named(form, "id").attrs["type"]
         assert ogc_server.name == form["name"].value
         form["description"] = "new_description"
         assert form.submit().status_int == 302
         assert ogc_server.description == "new_description"
 
     def test_delete(self, test_app, ogc_server_test_data, dbsession):
         from c2cgeoportal_commons.models.main import OGCServer
 
         ogc_server = ogc_server_test_data["ogc_servers"][0]
         deleted_id = ogc_server.id
-        test_app.delete("/admin/ogc_servers/{}".format(deleted_id), status=200)
+        test_app.delete(f"/admin/ogc_servers/{deleted_id}", status=200)
         assert dbsession.query(OGCServer).get(deleted_id) is None
 
     def test_duplicate(self, ogc_server_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import OGCServer
 
         ogc_server = ogc_server_test_data["ogc_servers"][3]
-        resp = test_app.get("/admin/ogc_servers/{}/duplicate".format(ogc_server.id), status=200)
+        resp = test_app.get(f"/admin/ogc_servers/{ogc_server.id}/duplicate", status=200)
         form = resp.form
         assert "" == self.get_first_field_named(form, "id").value
         self.set_first_field_named(form, "name", "clone")
         resp = form.submit("submit")
         assert resp.status_int == 302
         server = dbsession.query(OGCServer).filter(OGCServer.name == "clone").one()
         assert str(server.id) == re.match(
             r"http://localhost/admin/ogc_servers/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
 
     def test_unicity_validator(self, ogc_server_test_data, test_app):
         ogc_server = ogc_server_test_data["ogc_servers"][3]
-        resp = test_app.get("/admin/ogc_servers/{}/duplicate".format(ogc_server.id), status=200)
+        resp = test_app.get(f"/admin/ogc_servers/{ogc_server.id}/duplicate", status=200)
 
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(ogc_server.name))
+        self._check_submission_problem(resp, f"{ogc_server.name} is already used.")
 
     def test_check_success(self, ogc_server_test_data, test_app):
         ogc_server = ogc_server_test_data["ogc_servers"][3]
         ogc_server.url = "config://mapserver"
-        resp = test_app.get("/admin/ogc_servers/{}/synchronize".format(ogc_server.id), status=200)
+        resp = test_app.get(f"/admin/ogc_servers/{ogc_server.id}/synchronize", status=200)
 
         resp = resp.forms["form-check"].submit("submit")
 
         assert list(resp.html.find("div", class_="alert-success").stripped_strings) == [
             "OGC Server has been successfully synchronized."
         ]
 
     def test_dry_run_success(self, ogc_server_test_data, test_app):
         ogc_server = ogc_server_test_data["ogc_servers"][3]
         ogc_server.url = "config://mapserver"
-        resp = test_app.get("/admin/ogc_servers/{}/synchronize".format(ogc_server.id), status=200)
+        resp = test_app.get(f"/admin/ogc_servers/{ogc_server.id}/synchronize", status=200)
 
         resp = resp.forms["form-dry-run"].submit("submit")
 
         assert list(resp.html.find("div", class_="alert-success").stripped_strings) == [
             "OGC Server has been successfully synchronized."
         ]
 
     def test_synchronize_success(self, ogc_server_test_data, test_app):
         ogc_server = ogc_server_test_data["ogc_servers"][3]
         ogc_server.url = "config://mapserver"
-        resp = test_app.get("/admin/ogc_servers/{}/synchronize".format(ogc_server.id), status=200)
+        resp = test_app.get(f"/admin/ogc_servers/{ogc_server.id}/synchronize", status=200)
 
         resp = resp.forms["form-synchronize"].submit("submit")
 
         assert list(resp.html.find("div", class_="alert-success").stripped_strings) == [
             "OGC Server has been successfully synchronized."
         ]
+
+        form = resp.forms["form-synchronize"]
+        form["force-parents"].checked = True
+        form["force-ordering"].checked = True
+        form["clean"].checked = True
+
+        resp = form.submit("submit")
+
+        assert list(resp.html.find("div", class_="alert-success").stripped_strings) == [
+            "OGC Server has been successfully synchronized."
+        ]
```

## tests/test_restriction_areas.py

```diff
@@ -21,24 +21,24 @@
     for i in range(0, 4):
         roles.append(Role("secretary_" + str(i)))
     dbsession.add_all(roles)
 
     ogc_server = OGCServer(name="test_server")
     layers = []
     for i in range(0, 4):
-        layer = LayerWMS(name="layer_{}".format(i), layer="layer_{}".format(i), public=False)
+        layer = LayerWMS(name=f"layer_{i}", layer=f"layer_{i}", public=False)
         layer.ogc_server = ogc_server
         layers.append(layer)
     dbsession.add_all(layers)
 
     restrictionareas = []
     for i in range(0, 4):
-        restrictionarea = RestrictionArea(name="restrictionarea_{}".format(i))
+        restrictionarea = RestrictionArea(name=f"restrictionarea_{i}")
         restrictionarea.area = from_shape(box(485869.5728, 76443.1884, 837076.5648, 299941.7864), srid=21781)
-        restrictionarea.description = "description_{}".format(i)
+        restrictionarea.description = f"description_{i}"
         restrictionarea.roles = [roles[i % 4], roles[(i + 2) % 4]]
         restrictionarea.layers = [layers[i % 4], layers[(i + 2) % 4]]
         dbsession.add(restrictionarea)
         restrictionareas.append(restrictionarea)
 
     dbsession.flush()
     yield {
@@ -109,24 +109,24 @@
         assert str(restriction_area.id) == re.match(
             r"http://localhost/admin/restriction_areas/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
 
         assert restriction_area.name == "new_name"
         assert restriction_area.description == "new_description"
         assert restriction_area.readwrite
-        assert set(restriction_area.roles) == set([roles[0], roles[1]])
-        assert set(restriction_area.layers) == set([layers[0], layers[1]])
+        assert set(restriction_area.roles) == {roles[0], roles[1]}
+        assert set(restriction_area.layers) == {layers[0], layers[1]}
 
     def test_unicity_validator(self, restriction_area_test_data, test_app):
         restriction_area = restriction_area_test_data["restriction_areas"][2]
 
-        resp = test_app.get("/admin/restriction_areas/{}/duplicate".format(restriction_area.id), status=200)
+        resp = test_app.get(f"/admin/restriction_areas/{restriction_area.id}/duplicate", status=200)
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(restriction_area.name))
+        self._check_submission_problem(resp, f"{restriction_area.name} is already used.")
 
     def test_edit(self, test_app, restriction_area_test_data, dbsession):
         restriction_area = restriction_area_test_data["restriction_areas"][0]
         roles = restriction_area_test_data["roles"]
 
         # Ensure restriction_area.layers is loaded with relationship "order_by"
         dbsession.expire(restriction_area)
@@ -158,36 +158,34 @@
 
         form["description"] = "new_description"
         form["roles"] = [roles[i].id for i in range(0, 3)]
         form.submit("submit")
 
         dbsession.expire(restriction_area)
         assert restriction_area.description == "new_description"
-        assert set(restriction_area.roles) == set([roles[i] for i in range(0, 3)])
+        assert set(restriction_area.roles) == {roles[i] for i in range(0, 3)}
 
     def test_delete(self, test_app, restriction_area_test_data, dbsession):
         from c2cgeoportal_commons.models.main import RestrictionArea
 
         restriction_area = restriction_area_test_data["restriction_areas"][0]
         deleted_id = restriction_area.id
-        test_app.delete("/admin/restriction_areas/{}".format(deleted_id), status=200)
+        test_app.delete(f"/admin/restriction_areas/{deleted_id}", status=200)
         assert dbsession.query(RestrictionArea).get(deleted_id) is None
 
     def test_duplicate(self, restriction_area_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import RestrictionArea
 
         restriction_area = restriction_area_test_data["restriction_areas"][3]
         roles = restriction_area_test_data["roles"]
 
         # Ensure restriction_area.layers is loaded with relationship "order_by"
         dbsession.expire(restriction_area)
 
-        form = test_app.get(
-            "/admin/restriction_areas/{}/duplicate".format(restriction_area.id), status=200
-        ).form
+        form = test_app.get(f"/admin/restriction_areas/{restriction_area.id}/duplicate", status=200).form
 
         assert "" == self.get_first_field_named(form, "id").value
         self._check_roles(form, roles, restriction_area)
         self.check_children(
             form,
             "layers",
             [
```

## tests/test_role.py

```diff
@@ -15,35 +15,36 @@
 @pytest.mark.usefixtures("dbsession", "transact")
 def roles_test_data(dbsession, transact):
     del transact
 
     from c2cgeoportal_commons.models.main import Functionality, RestrictionArea, Role
     from c2cgeoportal_commons.models.static import User
 
+    # Note that "default_basemap" is not relevant for roles
     functionalities = {}
-    for name in ("default_basemap", "location"):
+    for name in ("default_basemap", "default_theme", "print_template"):
         functionalities[name] = []
         for v in range(0, 4):
-            functionality = Functionality(name=name, value="value_{}".format(v))
+            functionality = Functionality(name=name, value=f"value_{v}")
             dbsession.add(functionality)
             functionalities[name].append(functionality)
 
     restrictionareas = []
     for i in range(0, 5):
-        restrictionarea = RestrictionArea(name="restrictionarea_{}".format(i))
+        restrictionarea = RestrictionArea(name=f"restrictionarea_{i}")
         dbsession.add(restrictionarea)
         restrictionareas.append(restrictionarea)
 
     roles = []
     for i in range(0, 23):
         role = Role("secretary_" + str(i))
         role.functionalities = [
-            functionalities["default_basemap"][0],
-            functionalities["location"][0],
-            functionalities["location"][1],
+            functionalities["default_theme"][0],
+            functionalities["print_template"][0],
+            functionalities["print_template"][1],
         ]
         role.restrictionareas = [restrictionareas[0], restrictionareas[1]]
         role.extent = from_shape(box(485869.5728, 76443.1884, 837076.5648, 299941.7864), srid=21781)
         dbsession.add(role)
         roles.append(role)
 
     # Users roles must not be broken with role name changes
@@ -116,15 +117,15 @@
                 ("__formid__", "deform"),
                 ("id", ""),
                 ("name", "new_name"),
                 ("description", "new_description"),
                 ("extent", ""),
                 ("__start__", "functionalities:sequence"),
                 ("functionalities", str(functionalities["default_basemap"][0].id)),
-                ("functionalities", str(functionalities["location"][1].id)),
+                ("functionalities", str(functionalities["print_template"][1].id)),
                 ("__end__", "functionalities:sequence"),
                 ("__start__", "restrictionareas:sequence"),
                 ("restrictionareas", str(restrictionareas[0].id)),
                 ("restrictionareas", str(restrictionareas[1].id)),
                 ("__end__", "restrictionareas:sequence"),
                 ("__start__", "users:sequence"),
                 ("__start__", "user:mapping"),
@@ -142,19 +143,20 @@
         role = dbsession.query(Role).filter(Role.name == "new_name").one()
         assert str(role.id) == re.match(
             r"http://localhost/admin/roles/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
 
         assert role.name == "new_name"
         assert role.description == "new_description"
-        assert set(role.functionalities) == set(
-            [functionalities["default_basemap"][0], functionalities["location"][1]]
-        )
-        assert set(role.restrictionareas) == set([restrictionareas[0], restrictionareas[1]])
-        assert set(role.users) == set([users[0], users[1]])
+        assert set(role.functionalities) == {
+            functionalities["default_basemap"][0],
+            functionalities["print_template"][1],
+        }
+        assert set(role.restrictionareas) == {restrictionareas[0], restrictionareas[1]}
+        assert set(role.users) == {users[0], users[1]}
 
     def test_edit(self, dbsession, test_app, roles_test_data):
         role = roles_test_data["roles"][10]
 
         # Ensure role.users is loaded with relationship "order_by"
         dbsession.expire(role)
 
@@ -170,41 +172,41 @@
                 (664577.4194513536, 5753148.2510447875),
                 (1167544.3397631699, 5748064.729594703),
             ]
         )
         assert expected.almost_equals(shape(json.loads(form["extent"].value)), decimal=0)
 
         functionalities = roles_test_data["functionalities"]
-        assert (
-            set(
-                (
-                    functionalities["default_basemap"][0].id,
-                    functionalities["location"][0].id,
-                    functionalities["location"][1].id,
-                )
-            )
-            == set(f.id for f in role.functionalities)
-        )
+        assert {
+            functionalities["default_theme"][0].id,
+            functionalities["print_template"][0].id,
+            functionalities["print_template"][1].id,
+        } == {f.id for f in role.functionalities}
         self.check_checkboxes(
             form,
             "functionalities",
             [
                 {
-                    "label": "{}={}".format(f.name, f.value),
+                    "label": f"{f.name}={f.value}",
                     "value": str(f.id),
                     "checked": f in role.functionalities,
                 }
-                for f in sum(
-                    [roles_test_data["functionalities"][name] for name in ("default_basemap", "location")], []
+                for f in sorted(
+                    [
+                        f
+                        for f in sum(functionalities.values(), [])
+                        if f.name in ("default_theme", "print_template")
+                    ],
+                    key=lambda f: (f.name, f.value),
                 )
             ],
         )
 
         ras = roles_test_data["restrictionareas"]
-        assert set((ras[0].id, ras[1].id)) == set(ra.id for ra in role.restrictionareas)
+        assert {ras[0].id, ras[1].id} == {ra.id for ra in role.restrictionareas}
         self.check_checkboxes(
             form,
             "restrictionareas",
             [
                 {"label": ra.name, "value": str(ra.id), "checked": ra in role.restrictionareas}
                 for ra in sorted(ras, key=lambda ra: ra.name)
             ],
@@ -233,17 +235,17 @@
                         [1000000, 5800000],
                     ]
                 ],
             }
         )
 
         functionality_ids = [
-            roles_test_data["functionalities"]["default_basemap"][1].id,
-            roles_test_data["functionalities"]["location"][1].id,
-            roles_test_data["functionalities"]["default_basemap"][2].id,
+            roles_test_data["functionalities"]["default_theme"][1].id,
+            roles_test_data["functionalities"]["print_template"][1].id,
+            roles_test_data["functionalities"]["print_template"][2].id,
         ]
         form["functionalities"] = [str(id) for id in functionality_ids]
 
         ra_ids = [roles_test_data["restrictionareas"][2].id, roles_test_data["restrictionareas"][3].id]
         form["restrictionareas"] = [str(id) for id in ra_ids]
 
         resp = form.submit("submit")
@@ -264,23 +266,23 @@
                 (513083.1504351135, 245400.5416369234),
                 (511073.1973649057, 108541.7344432737),
                 (719383.7988896352, 109062.8141734005),
             ]
         )
         assert expected.almost_equals(to_shape(role.extent), decimal=0)
 
-        assert set(functionality_ids) == set([f.id for f in role.functionalities])
-        assert set(ra_ids) == set([f.id for f in role.restrictionareas])
+        assert set(functionality_ids) == {f.id for f in role.functionalities}
+        assert set(ra_ids) == {f.id for f in role.restrictionareas}
 
     def test_duplicate(self, roles_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Role
 
         role_proto = roles_test_data["roles"][7]
 
-        resp = test_app.get("/admin/roles/{}/duplicate".format(role_proto.id), status=200)
+        resp = test_app.get(f"/admin/roles/{role_proto.id}/duplicate", status=200)
         form = resp.form
 
         assert "" == self.get_first_field_named(form, "id").value
         assert role_proto.name == form["name"].value
         assert role_proto.description == form["description"].value
         form["name"].value = "clone"
         resp = form.submit("submit")
@@ -294,24 +296,24 @@
         assert set(role_proto.restrictionareas) == set(role.restrictionareas)
         assert set(role_proto.users) == set(role.users)
 
     def test_delete(self, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Role
 
         role_id = dbsession.query(Role.id).first().id
-        test_app.delete("/admin/roles/{}".format(role_id), status=200)
+        test_app.delete(f"/admin/roles/{role_id}", status=200)
         assert dbsession.query(Role).get(role_id) is None
 
     def test_unicity_validator(self, roles_test_data, test_app):
         role_proto = roles_test_data["roles"][7]
-        resp = test_app.get("/admin/roles/{}/duplicate".format(role_proto.id), status=200)
+        resp = test_app.get(f"/admin/roles/{role_proto.id}/duplicate", status=200)
 
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(role_proto.name))
+        self._check_submission_problem(resp, f"{role_proto.name} is already used.")
 
     @pytest.mark.usefixtures("raise_db_error_on_query")
     def test_grid_dberror(self, dbsession):
         from c2cgeoportal_admin.views.roles import RoleViews
 
         request = DummyRequest(dbsession=dbsession, params={"offset": 0, "limit": 10})
         info = RoleViews(request).grid()
```

## tests/test_themes.py

```diff
@@ -21,47 +21,52 @@
         Metadata,
         OGCServer,
         Role,
         Theme,
     )
 
     interfaces = [Interface(name) for name in ["desktop", "mobile", "edit", "routing"]]
+    dbsession.add_all(interfaces)
 
-    groups = [LayerGroup(name="layer_group_{}".format(i)) for i in range(0, 5)]
+    groups = [LayerGroup(name=f"layer_group_{i}") for i in range(0, 5)]
+    dbsession.add_all(groups)
 
     layer = LayerWMS(name="layer_wms")
     layer.ogc_server = OGCServer(name="server")
-    dbsession.add(layer)
     layers = [layer]
+    dbsession.add_all(layers)
 
+    # Note that "default_theme" is not relevant for themes
     functionalities = [
-        Functionality(name=name, value="value_{}".format(v))
-        for name in ("default_basemap", "location")
+        Functionality(name=name, value=f"value_{v}")
+        for name in ("default_basemap", "default_theme")
         for v in range(0, 4)
     ]
+    dbsession.add_all(functionalities)
 
     roles = [Role("secretary_" + str(i)) for i in range(0, 4)]
+    dbsession.add_all(roles)
 
     metadatas_protos = [
         ("copyable", "true"),
         ("disclaimer", " le momo"),
         ("snappingConfig", '{"tolerance": 50}'),
     ]
     themes = []
     for i in range(0, 25):
-        theme = Theme(name="theme_{}".format(i), ordering=1, icon="icon_{}".format(i))
+        theme = Theme(name=f"theme_{i}", ordering=1, icon=f"icon_{i}")
         theme.public = 1 == i % 2
         theme.interfaces = [interfaces[i % 4], interfaces[(i + 2) % 4]]
         theme.metadatas = [
             Metadata(name=metadatas_protos[id][0], value=metadatas_protos[id][1])
             for id in [i % 3, (i + 2) % 3]
         ]
         for metadata in theme.metadatas:
             metadata.item = theme
-        theme.functionalities = [functionalities[i % 8], functionalities[(i + 3) % 8]]
+        theme.functionalities = [functionalities[i % 4]]
         theme.restricted_roles = [roles[i % 4], roles[(i + 2) % 4]]
 
         dbsession.add(
             LayergroupTreeitem(group=theme, item=groups[i % 5], ordering=len(groups[i % 5].children_relation))
         )
         dbsession.add(
             LayergroupTreeitem(
@@ -113,15 +118,15 @@
         json = self.check_search(test_app)
 
         first_row = json["rows"][0]
         first_theme = theme_test_data["themes"][0]
 
         assert first_theme.id == int(first_row["_id_"])
         assert first_theme.name == first_row["name"]
-        assert "default_basemap=value_0, default_basemap=value_3" == first_row["functionalities"]
+        assert "default_basemap=value_0" == first_row["functionalities"]
         assert "secretary_0, secretary_2" == first_row["restricted_roles"]
         assert "desktop, edit" == first_row["interfaces"]
         assert 'copyable: true, snappingConfig: {"tolerance": 50}' == first_row["metadatas"]
 
     def test_grid_search(self, test_app):
         # search on metadatas key and value parts
         self.check_search(test_app, "disclai ", total=16)
@@ -142,49 +147,52 @@
         self.check_search(test_app, "disclaimer m_m_", total=16)
 
         # search on functionalities
         self.check_search(test_app, "default_basemap value_0", total=7)
 
     def test_public_checkbox_edit(self, test_app, theme_test_data):
         theme = theme_test_data["themes"][10]
-        form10 = test_app.get("/admin/themes/{}".format(theme.id), status=200).form
+        form10 = test_app.get(f"/admin/themes/{theme.id}", status=200).form
         assert not form10["public"].checked
         theme = theme_test_data["themes"][11]
-        form11 = test_app.get("/admin/themes/{}".format(theme.id), status=200).form
+        form11 = test_app.get(f"/admin/themes/{theme.id}", status=200).form
         assert form11["public"].checked
 
     def test_edit(self, test_app, theme_test_data, dbsession):
         theme = theme_test_data["themes"][0]
 
-        resp = test_app.get("/admin/themes/{}".format(theme.id), status=200)
+        resp = test_app.get(f"/admin/themes/{theme.id}", status=200)
         form = resp.form
 
         assert str(theme.id) == self.get_first_field_named(form, "id").value
         assert "hidden" == self.get_first_field_named(form, "id").attrs["type"]
         assert theme.name == self.get_first_field_named(form, "name").value
         assert str(theme.description or "") == self.get_first_field_named(form, "description").value
         assert str(theme.ordering or "") == self.get_first_field_named(form, "ordering").value
         assert theme.public == form["public"].checked
 
         interfaces = theme_test_data["interfaces"]
-        assert set((interfaces[0].id, interfaces[2].id)) == set(i.id for i in theme.interfaces)
+        assert {interfaces[0].id, interfaces[2].id} == {i.id for i in theme.interfaces}
         self._check_interfaces(form, interfaces, theme)
 
         functionalities = theme_test_data["functionalities"]
-        assert set((functionalities[0].id, functionalities[3].id)) == set(f.id for f in theme.functionalities)
+        assert {functionalities[0].id} == {f.id for f in theme.functionalities}
         self.check_checkboxes(
             form,
             "functionalities",
             [
                 {
-                    "label": "{}={}".format(f.name, f.value),
+                    "label": f"{f.name}={f.value}",
                     "value": str(f.id),
                     "checked": f in theme.functionalities,
                 }
-                for f in sorted(functionalities, key=lambda f: (f.name, f.value))
+                for f in sorted(
+                    [f for f in functionalities if f.name in ("default_basemap")],
+                    key=lambda f: (f.name, f.value),
+                )
             ],
         )
 
         self.check_children(
             form,
             "children_relation",
             [
@@ -216,29 +224,25 @@
 
         dbsession.expire(theme)
         for key, value in new_values.items():
             if isinstance(value, bool):
                 assert value == getattr(theme, key)
             else:
                 assert str(value or "") == str(getattr(theme, key) or "")
-        assert set([interfaces[1].id, interfaces[3].id]) == set(
-            [interface.id for interface in theme.interfaces]
-        )
-        assert set([functionalities[2].id]) == set(
-            [functionality.id for functionality in theme.functionalities]
-        )
+        assert {interfaces[1].id, interfaces[3].id} == {interface.id for interface in theme.interfaces}
+        assert {functionalities[2].id} == {functionality.id for functionality in theme.functionalities}
         assert 0 == len(theme.restricted_roles)
 
     def test_post_new_with_children_invalid(self, test_app, theme_test_data):
         """
         Check there is no rendering error when validation fails.
         """
         groups = theme_test_data["groups"]
         resp = test_app.post(
-            "{}/new".format(self._prefix),
+            f"{self._prefix}/new",
             (
                 ("_charset_", "UTF-8"),
                 ("__formid__", "deform"),
                 ("id", ""),
                 ("__start__", "children_relation:sequence"),
                 ("__start__", "layergroup_treeitem:mapping"),
                 ("id", ""),
@@ -252,15 +256,15 @@
         )
 
         self._check_submission_problem(resp, "Required")
 
     def test_post_new_with_children_success(self, test_app, dbsession, theme_test_data):
         groups = theme_test_data["groups"]
         resp = test_app.post(
-            "{}/new".format(self._prefix),
+            f"{self._prefix}/new",
             (
                 ("_charset_", "UTF-8"),
                 ("__formid__", "deform"),
                 ("name", "new_with_children"),
                 ("description", ""),
                 ("ordering", "100"),
                 ("id", ""),
@@ -300,15 +304,15 @@
 
     def test_post_new_with_child_layer(self, theme_test_data, test_app):
         """
         Check layers are rejected by the validator (also means that they are not proposed to the user).
         """
         layers = theme_test_data["layers"]
         resp = test_app.post(
-            "{}/new".format(self._prefix),
+            f"{self._prefix}/new",
             (
                 ("_charset_", "UTF-8"),
                 ("__formid__", "deform"),
                 ("name", "new_with_child_layer"),
                 ("description", ""),
                 ("ordering", "100"),
                 ("id", ""),
@@ -320,51 +324,54 @@
                 ("__end__", "layergroup_treeitem:mapping"),
                 ("__end__", "children_relation:sequence"),
                 ("formsubmit", "formsubmit"),
             ),
             status=200,
         )
         assert (
-            "Value {} does not exist in table treeitem or is not allowed to avoid cycles".format(layers[0].id)
+            f"Value {layers[0].id} does not exist in table treeitem or is not allowed to avoid cycles"
             == resp.html.select_one(".item-children_relation + .help-block").getText().strip()
         )
 
     def test_duplicate(self, theme_test_data, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Theme
 
         theme = theme_test_data["themes"][1]
 
-        resp = test_app.get("{}/{}/duplicate".format(self._prefix, theme.id), status=200)
+        resp = test_app.get(f"{self._prefix}/{theme.id}/duplicate", status=200)
         form = resp.form
 
         assert "" == self.get_first_field_named(form, "id").value
         assert "hidden" == self.get_first_field_named(form, "id").attrs["type"]
         assert theme.name == self.get_first_field_named(form, "name").value
         assert str(theme.description or "") == self.get_first_field_named(form, "description").value
         assert str(theme.ordering or "") == self.get_first_field_named(form, "ordering").value
 
         assert theme.public == form["public"].checked
 
         interfaces = theme_test_data["interfaces"]
-        assert set((interfaces[1].id, interfaces[3].id)) == set(i.id for i in theme.interfaces)
+        assert {interfaces[1].id, interfaces[3].id} == {i.id for i in theme.interfaces}
 
         self._check_interfaces(form, interfaces, theme)
 
         functionalities = theme_test_data["functionalities"]
-        assert set((functionalities[1].id, functionalities[4].id)) == set(f.id for f in theme.functionalities)
+        assert {functionalities[1].id} == {f.id for f in theme.functionalities}
         self.check_checkboxes(
             form,
             "functionalities",
             [
                 {
-                    "label": "{}={}".format(f.name, f.value),
+                    "label": f"{f.name}={f.value}",
                     "value": str(f.id),
                     "checked": f in theme.functionalities,
                 }
-                for f in sorted(functionalities, key=lambda f: (f.name, f.value))
+                for f in sorted(
+                    [f for f in functionalities if f.name in ("default_basemap")],
+                    key=lambda f: (f.name, f.value),
+                )
             ],
         )
 
         theme = dbsession.query(Theme).filter(Theme.id == theme.id).one()
 
         self.check_children(
             form,
@@ -377,27 +384,27 @@
 
         self.set_first_field_named(form, "name", "duplicated")
         resp = form.submit("submit")
 
         duplicated = dbsession.query(Theme).filter(Theme.name == "duplicated").one()
 
         assert str(duplicated.id) == re.match(
-            r"http://localhost{}/(.*)\?msg_col=submit_ok".format(self._prefix), resp.location
+            rf"http://localhost{self._prefix}/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
         assert duplicated.id != theme.id
         assert duplicated.children_relation[0].id != theme.children_relation[0].id
         assert duplicated.children_relation[0].treeitem.id == theme.children_relation[0].treeitem.id
 
     def test_delete(self, test_app, dbsession):
         from c2cgeoportal_commons.models.main import Theme
 
         theme_id = dbsession.query(Theme.id).first().id
-        test_app.delete("/admin/themes/{}".format(theme_id), status=200)
+        test_app.delete(f"/admin/themes/{theme_id}", status=200)
         assert dbsession.query(Theme).get(theme_id) is None
 
     def test_unicity_validator(self, theme_test_data, test_app):
         theme = theme_test_data["themes"][1]
-        resp = test_app.get("{}/{}/duplicate".format(self._prefix, theme.id), status=200)
+        resp = test_app.get(f"{self._prefix}/{theme.id}/duplicate", status=200)
 
         resp = resp.form.submit("submit")
 
-        self._check_submission_problem(resp, "{} is already used.".format(theme.name))
+        self._check_submission_problem(resp, f"{theme.name} is already used.")
```

## tests/test_themes_ordering.py

```diff
@@ -10,15 +10,15 @@
 def theme_test_data(dbsession, transact):
     del transact
 
     from c2cgeoportal_commons.models.main import Theme
 
     themes = []
     for i in range(0, 3):
-        theme = Theme(name="theme_{}".format(i), ordering=i, icon="icon_{}".format(i))
+        theme = Theme(name=f"theme_{i}", ordering=i, icon=f"icon_{i}")
 
         dbsession.add(theme)
         themes.append(theme)
 
     dbsession.flush()
 
     yield {
```

## tests/test_treegroup.py

```diff
@@ -1,14 +1,14 @@
 # pylint: disable=no-self-use
 
 from . import AbstractViewsTests
 
 
 class TestTreeGroup(AbstractViewsTests):
     def check_children(self, form, group, expected):
-        form_group = form.html.select_one(".item-{}".format(group))
+        form_group = form.html.select_one(f".item-{group}")
         items = form_group.select(".deform-seq-item")
         assert len(expected) == len(items)
         for item, exp in zip(items, expected):
             assert exp["label"] == item.select_one(".well").getText().strip()
             for key, value in exp["values"].items():
-                assert value == item.select_one('input[name="{}"]'.format(key))["value"]
+                assert value == item.select_one(f'input[name="{key}"]')["value"]
```

## tests/test_user.py

```diff
@@ -16,21 +16,21 @@
     del transact
 
     from c2cgeoportal_commons.models.main import Role
     from c2cgeoportal_commons.models.static import User
 
     roles = []
     for i in range(0, 4):
-        roles.append(Role("secretary_{}".format(i)))
+        roles.append(Role(f"secretary_{i}"))
         dbsession.add(roles[i])
     users = []
     for i in range(0, 23):
         user = User(
-            "babar_{}".format(i),
-            email="mail{}@valid.net".format(i),
+            f"babar_{i}",
+            email=f"mail{i}@valid.net",
             settings_role=roles[i % 4],
             roles=[roles[i % 4]],
         )
         user.password = "pr$ident"
         user.is_password_changed = i % 2 == 1
         users.append(user)
         dbsession.add(user)
@@ -89,15 +89,15 @@
         ]
         self.check_grid_headers(resp, expected, new="Nouveau")
 
     def test_view_edit(self, test_app, users_test_data):
         user = users_test_data["users"][9]
         roles = users_test_data["roles"]
 
-        resp = test_app.get("/admin/users/{}".format(user.id), status=200)
+        resp = test_app.get(f"/admin/users/{user.id}", status=200)
 
         assert resp.form["username"].value == user.username
         assert resp.form["email"].value == user.email
         assert resp.form["settings_role_id"].options == [("", False, "- Select -")] + [
             (str(role.id), role.name == "secretary_1", role.name) for role in roles
         ]
         assert resp.form["settings_role_id"].value == str(user.settings_role_id)
@@ -116,33 +116,33 @@
         resp.form.submit("submit")
 
         for key, value in new_values.items():
             if isinstance(value, bool):
                 assert value == getattr(user, key)
             else:
                 assert str(value or "") == str(getattr(user, key) or "")
-        assert set([roles[2].id, roles[3].id]) == set([role.id for role in user.roles])
+        assert {roles[2].id, roles[3].id} == {role.id for role in user.roles}
 
     def test_delete(self, test_app, users_test_data, dbsession):
         from c2cgeoportal_commons.models.static import User, user_role
 
         user = users_test_data["users"][9]
         deleted_id = user.id
-        test_app.delete("/admin/users/{}".format(deleted_id), status=200)
+        test_app.delete(f"/admin/users/{deleted_id}", status=200)
         assert dbsession.query(User).get(deleted_id) is None
         assert dbsession.query(user_role).filter(user_role.c.user_id == user.id).count() == 0
 
     @patch("c2cgeoportal_commons.lib.email_.smtplib.SMTP")
     @patch("c2cgeoportal_admin.views.users.pwgenerator.generate")
     def test_submit_update(self, pw_gen_mock, smtp_mock, dbsession, test_app, users_test_data):
         user = users_test_data["users"][11]
         roles = users_test_data["roles"]
 
         resp = test_app.post(
-            "/admin/users/{}".format(user.id),
+            f"/admin/users/{user.id}",
             (
                 ("__formid__", "deform"),
                 ("_charset_", "UTF-8"),
                 ("formsubmit", "formsubmit"),
                 ("item_type", "user"),
                 ("id", user.id),
                 ("username", "new_name_with"),
@@ -151,32 +151,32 @@
                 ("__start__", "roles:sequence"),
                 ("roles", roles[0].id),
                 ("roles", roles[3].id),
                 ("__end__", "roles:sequence"),
             ),
             status=302,
         )
-        assert resp.location == "http://localhost/admin/users/{}?msg_col=submit_ok".format(user.id)
+        assert resp.location == f"http://localhost/admin/users/{user.id}?msg_col=submit_ok"
 
         dbsession.expire(user)
         assert user.username == "new_name_with"
         assert user.email == "new_mail@valid.net"
         assert user.settings_role.name == "secretary_2"
-        assert set(r.id for r in user.roles) == set(roles[i].id for i in [0, 3])
+        assert {r.id for r in user.roles} == {roles[i].id for i in [0, 3]}
         assert user.validate_password("pr$ident")
 
         assert not pw_gen_mock.called, "method should not have been called"
         assert not smtp_mock.called, "method should not have been called"
 
     def test_unicity_validator(self, users_test_data, test_app):
         user = users_test_data["users"][11]
         roles = users_test_data["roles"]
 
         resp = test_app.post(
-            "/admin/users/{}".format(user.id),
+            f"/admin/users/{user.id}",
             {
                 "__formid__": "deform",
                 "_charset_": "UTF-8",
                 "formsubmit": "formsubmit",
                 "item_type": "user",
                 "id": user.id,
                 "username": "babar_0",
@@ -195,15 +195,15 @@
         smtp_mock.return_value = sender_mock
         pw_gen_mock.return_value = "basile"
         from c2cgeoportal_commons.models.static import User
 
         user = users_test_data["users"][7]
         roles = users_test_data["roles"]
 
-        resp = test_app.get("/admin/users/{}/duplicate".format(user.id), status=200)
+        resp = test_app.get(f"/admin/users/{user.id}/duplicate", status=200)
         form = resp.form
 
         assert "" == form["id"].value
         assert user.username == form["username"].value
         assert user.email == form["email"].value
         assert str(user.settings_role_id) == form["settings_role_id"].value
         self._check_roles(resp.form, roles, user)
@@ -215,15 +215,15 @@
         new_user = dbsession.query(User).filter(User.username == "clone").one()
 
         assert str(new_user.id) == re.match(
             r"http://localhost/admin/users/(.*)\?msg_col=submit_ok", resp.location
         ).group(1)
         assert user.id != new_user.id
         assert user.settings_role_id == new_user.settings_role_id
-        assert set([role.id for role in user.roles]) == set([role.id for role in new_user.roles])
+        assert {role.id for role in user.roles} == {role.id for role in new_user.roles}
         assert not new_user.is_password_changed
         assert not new_user.validate_password("pr$ident")
 
         parts = list(email.message_from_string(sender_mock.sendmail.mock_calls[0][1][2]).walk())
         assert EXPECTED_WELCOME_MAIL.format("clone", "clone", "basile") == parts[1].get_payload(
             decode=True
         ).decode("utf8")
@@ -300,12 +300,14 @@
         from c2cgeoportal_admin.views.users import UserViews
 
         request = DummyRequest(dbsession=dbsession, params={"offset": 0, "limit": 10})
         info = UserViews(request).grid()
         assert info.status_int == 500, "Expected 500 status when db error"
 
     def test_grid_settings_role_none(self, dbsession, test_app):
-        """Grid view must work even if a user's settings_role is None"""
+        """
+        Grid view must work even if a user's settings_role is None.
+        """
         from c2cgeoportal_commons.models.static import User
 
         dbsession.add(User("test", email="test@valid.net"))
         self.check_search(test_app, "test", total=1)
```

## tests/themes_ordering.py

```diff
@@ -10,15 +10,15 @@
 def themes_ordering_test_data(dbsession, transact):
     del transact
 
     from c2cgeoportal_commons.models.main import Theme
 
     themes = []
     for i in range(0, 25):
-        theme = Theme(name="theme_{}".format(i), ordering=100)
+        theme = Theme(name=f"theme_{i}", ordering=100)
         dbsession.add(theme)
         themes.append(theme)
 
     dbsession.flush()
 
     yield {"themes": themes}
```

## Comparing `c2cgeoportal_admin-2.6.0.dist-info/METADATA` & `c2cgeoportal_admin-2.7.1.83.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,47 +1,50 @@
 Metadata-Version: 2.1
 Name: c2cgeoportal-admin
-Version: 2.6.0
+Version: 2.7.1.83
 Summary: c2cgeoportal admin
 Home-page: https://github.com/camptocamp/c2cgeoportal/
 Author: Camptocamp
 Author-email: info@camptocamp.com
-License: UNKNOWN
 Keywords: web gis geoportail c2cgeoportal geocommune pyramid
-Platform: UNKNOWN
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
+Classifier: Development Status :: 6 - Mature
+Classifier: Environment :: Web Environment
 Classifier: Framework :: Pyramid
-Classifier: Topic :: Internet :: WWW/HTTP
-Classifier: Topic :: Internet :: WWW/HTTP :: WSGI :: Application
+Classifier: Intended Audience :: Other Audience
 Classifier: License :: OSI Approved :: BSD License
-Classifier: Development Status :: 6 - Mature
+Classifier: Operating System :: OS Independent
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Topic :: Scientific/Engineering :: GIS
+Classifier: Typing :: Typed
 Description-Content-Type: text/markdown
 Requires-Dist: c2cgeoform
 Requires-Dist: c2cwsgiutils
 Requires-Dist: colander
 Requires-Dist: deform
 Requires-Dist: passwordgenerator
 Requires-Dist: pyproj
 Requires-Dist: pyramid
 Requires-Dist: pyramid-debugtoolbar
 Requires-Dist: pyramid-jinja2
 Requires-Dist: pyramid-tm
 Requires-Dist: sqlalchemy
-Requires-Dist: translationstring
 Requires-Dist: zope.event
+Requires-Dist: translationstring
+Requires-Dist: jinja2 (>=2.11.3)
+Requires-Dist: pygments (>=2.7.4)
+Requires-Dist: setuptools (>=65.5.1)
+Requires-Dist: requests (>=2.31.0)
 
 # c2cgeoportal admin interface
 
 ## Run the c2cgeoportal_admin development web server
 
 From this folder (admin):
 
 ```
 make preparedev
 make serve
 ```
 
 Now open http://localhost:8888/ in your favorite browser.
-
-
```

## Comparing `c2cgeoportal_admin-2.6.0.dist-info/RECORD` & `c2cgeoportal_admin-2.7.1.83.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,89 +1,92 @@
-c2cgeoportal_admin/__init__.py,sha256=8rMRUDG1AT8jV6PgIE8T1AZF0-3yt0ffd7SuKRl8_FM,4677
-c2cgeoportal_admin/routes.py,sha256=wCZstX9oqUQDN9ztnitCgaM5Q38q9CYpOnSgVE_5nHI,4592
-c2cgeoportal_admin/subscribers.py,sha256=NKvpObGpgVqmTTU7q-A_EsPMEaA6eyKfa6kezlR11H4,2362
-c2cgeoportal_admin/widgets.py,sha256=oi88Ot2swpnlLOFpdQ014KBrkaynq_nRbqtm7r7xJWA,6043
+c2cgeoportal_admin/__init__.py,sha256=4UYLGCcfxd8mfHojIalTFmaYNgD67WFbgVhw2sl5yok,4959
+c2cgeoportal_admin/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+c2cgeoportal_admin/routes.py,sha256=So17Lj2v8UigkxVwfYJrK_piDejRkvekPiFibyr3qiw,4676
+c2cgeoportal_admin/subscribers.py,sha256=P1CaccDTpuxrWak_gMN2qBurz3OrAZ6aZ1LA7P3avu8,2430
+c2cgeoportal_admin/widgets.py,sha256=tW6brDW-95LuRnSsRd_8xVRKNAkwkYtdi8zQ44TBj18,6132
 c2cgeoportal_admin/lib/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-c2cgeoportal_admin/lib/ogcserver_synchronizer.py,sha256=KBJPQCSt8b67_u2rhRGr8AsbfcxaCTaRaCkWKPW5ufg,10962
+c2cgeoportal_admin/lib/lingua_extractor.py,sha256=Dw4vo46TcUnJ7vvxgFezPYidfEdL2pHJUM0qxAaJ1KE,3380
+c2cgeoportal_admin/lib/ogcserver_synchronizer.py,sha256=NuCV8EpUso01to2PYbh6NpXPcD702pQOSslah__Bzus,15421
 c2cgeoportal_admin/schemas/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-c2cgeoportal_admin/schemas/dimensions.py,sha256=U9-JvFZhCbrQp7Y0WaghJF6tBvXPoSbPBbHIRjCd6hM,2070
-c2cgeoportal_admin/schemas/functionalities.py,sha256=K8O5Fkave5XiT2tGwi8emLzOPRUdZhSvachiZ93c3Js,2476
-c2cgeoportal_admin/schemas/interfaces.py,sha256=r-EaDPMrrGoJopzqqLqZbYU1uVU4ezwMvoyt-FnBAm0,2277
-c2cgeoportal_admin/schemas/metadata.py,sha256=ihKGWiaT5ZT98sqTKySitlDWXYEUEkfwpFt_Xcwf8lE,6537
-c2cgeoportal_admin/schemas/restriction_areas.py,sha256=SX5KBXTg8w-JFscGZrfiiJRJmJ6eIzONnhInBF6yHcc,2343
-c2cgeoportal_admin/schemas/roles.py,sha256=Ye_b5pyB5-xtPMO1IYO64JuLmr5EKHb2BjhFbS6fJaE,2253
-c2cgeoportal_admin/schemas/treegroup.py,sha256=x9zB3JW86tt2tXNRlqk4Ac811uTkMdhbGvA82vHVxww,6274
-c2cgeoportal_admin/schemas/treeitem.py,sha256=P0qZZrxbAPo878p36-yyQ0k_slxuml2ij8Ev9GeWUJE,2094
-c2cgeoportal_admin/static/layertree.css,sha256=QwAOIswiqDx0u6Nnu1SD2L9Mcdj58hM6uQy-KxnLXCk,3178
-c2cgeoportal_admin/static/navbar.css,sha256=ibw_qIqf2KtBy1u48t4v1qFJcBsTBlUX1582nEjo3Sw,2383
-c2cgeoportal_admin/static/theme.css,sha256=GSAn136wI5FslMJf3N9D3OA2e-85GmlHmWjlxQ_UiKo,1888
+c2cgeoportal_admin/schemas/dimensions.py,sha256=rPMEuIdGiVGS5e0xqXUu-COVKlrWg9rpp-xe-8aHbOQ,2290
+c2cgeoportal_admin/schemas/functionalities.py,sha256=AptqKn2oyy74qivzihNfeNvmaDILsl36bSoJdSNXh9Y,3941
+c2cgeoportal_admin/schemas/interfaces.py,sha256=0NCRDZOqbw7Bwj-l3GNsVwYDHck4F0q1fCSo1kTYoOY,2578
+c2cgeoportal_admin/schemas/metadata.py,sha256=px0Teh0vtyimQfzL7zXHXIEkWtBbD00OsadfDDeqSkY,8991
+c2cgeoportal_admin/schemas/restriction_areas.py,sha256=48hFUgFznl_1bYsl490YSXLbXfjCY_f6gURQtB_7eIk,2598
+c2cgeoportal_admin/schemas/roles.py,sha256=4JJrgZNKsj_wru_YGOWxZTEXGVm0hahbAkYf2aePGzI,2507
+c2cgeoportal_admin/schemas/treegroup.py,sha256=-s_aKAzwYwS9zVsuqQAp_7M_-c00LVq-R6dC8BiUWk0,7039
+c2cgeoportal_admin/schemas/treeitem.py,sha256=qnjrLd2LD7NCBjXqzw7aRn83cw_hYZbepJdLzOz0rBk,2117
+c2cgeoportal_admin/static/layertree.css,sha256=tk54KGW0yRRmdrY35gOCZG3qTsqWtGNEwvBYPQKhaVs,3177
+c2cgeoportal_admin/static/navbar.css,sha256=QIaAQsb4n17OfwdKEQdmNDVPCP23Yu-oGW4xsSaHyW0,2307
+c2cgeoportal_admin/static/theme.css,sha256=eHtBEJcBtDhyZJvCKNxE5hgril0VpLtcDKfNFdgCSVw,2025
 c2cgeoportal_admin/templates/404.jinja2,sha256=F05OZUzJljcieoCFMP7Oz1F6Jb-VZ06hTOSc9mrb87g,1420
 c2cgeoportal_admin/templates/edit.jinja2,sha256=rkBQiz0JZdL7VDq8XrhRLTv6JaiFt_QB8CwP3NMHWQY,1302
 c2cgeoportal_admin/templates/home.jinja2,sha256=WDQwmBGMZxsiOLw9YeYPLuca_mjjntjrTh529euzd1o,1516
 c2cgeoportal_admin/templates/index.jinja2,sha256=HPgilbqh5dv-yc_T_bc1hV2DEtV2wD617_aAERC2VSk,2005
-c2cgeoportal_admin/templates/layertree.jinja2,sha256=WE1Omy_zL29JsoOzWMk-Q-1JTkNatBtaFtDIAY_R-3E,9027
+c2cgeoportal_admin/templates/layertree.jinja2,sha256=1ys5XDY3nb4gAu8JazkwSFeJUdGRadT7WaBuvin_hYg,9830
 c2cgeoportal_admin/templates/layout.jinja2,sha256=KCDwATUYBu-ZXv7ijo0S0PlTmKtU-JxW8gMhvPA_kAE,4105
-c2cgeoportal_admin/templates/navigation_navbar.jinja2,sha256=7H2QbvQqyUB76dicBR9wCQKdoYV8-J0cr4Yg8WXg9M4,3101
-c2cgeoportal_admin/templates/navigation_vertical.jinja2,sha256=-sktZjkK3MbtVYNihx2UNmjOAYS1V1ur1NlJcfoZsDk,1660
-c2cgeoportal_admin/templates/ogcserver_synchronize.jinja2,sha256=XA28459fEr_REXoWlxa9aUaRbsVSbdr05LuknoeZm08,3567
+c2cgeoportal_admin/templates/navigation_navbar.jinja2,sha256=XzVQDpo3ClIiRxWf5eDULHZi9u-veYOmndiE_Twqxog,4166
+c2cgeoportal_admin/templates/ogcserver_synchronize.jinja2,sha256=rdQfbHBzrV5VUq5TC97QR7pv8bRvrdKaUUZpnQyldoE,4327
 c2cgeoportal_admin/templates/widgets/child.pt,sha256=JjxI0oVADhS3SoFgg0iN8P4ca1I_UGr7fWRp3wpZXsE,2159
 c2cgeoportal_admin/templates/widgets/children.pt,sha256=0TPpatvmZcU2TxbcZMjDz8VQcLGtoHkuDJ-eAGvjXho,6625
 c2cgeoportal_admin/templates/widgets/dimension.pt,sha256=1BXmE7s9JpzaJSHAQEtZk0DHB11pQ4FNQPaG_4c8CYo,2627
 c2cgeoportal_admin/templates/widgets/dimensions.pt,sha256=LjWjsgdcFYZxpB_30-3NOfvq5KYkKTu49F-P-r9d5Jg,1211
+c2cgeoportal_admin/templates/widgets/functionality_fields.pt,sha256=8TvwXCmQOtYFkiqsa4AHFUYsWk92LLnthz8bDrLmMBc,1969
 c2cgeoportal_admin/templates/widgets/layer_fields.pt,sha256=RJBYt8ji6YQp9ZaNZJD-caLgy856a6rzlKSMnuZWphw,3223
 c2cgeoportal_admin/templates/widgets/layer_group_fields.pt,sha256=xnqIqFjPPan81OqLwKeDnvNtlhEvYss6h2J9txH5neE,2459
 c2cgeoportal_admin/templates/widgets/layer_v1_fields.pt,sha256=w-MujUevHWmnOkOTbbvES6alDoL_UO1eiMj8SCxcQEY,3956
-c2cgeoportal_admin/templates/widgets/metadata.pt,sha256=YKgOJSnGidbwug5umzhBQ4eHPDbdzNR3DH7M15m3IKg,3538
+c2cgeoportal_admin/templates/widgets/metadata.pt,sha256=jWiLmS0J-cwFkqUxxZwKnkPNX9ShTG2zj0tUCq4TMjQ,3735
 c2cgeoportal_admin/templates/widgets/metadatas.pt,sha256=ErgAH0DA94MO7gqEJ2iZdQ9LRptP2YKH78yze-jdl2Q,1476
 c2cgeoportal_admin/templates/widgets/ogcserver_fields.pt,sha256=x0bDmgrnj9SA6RCVpg3k2lTkkXPkuBFPKMScDgDeyGU,1724
 c2cgeoportal_admin/templates/widgets/restriction_area_fields.pt,sha256=pZVE0KcitAF7HXc3ZlniLr0QwSD05TOhlgieLUR1i7Q,1731
 c2cgeoportal_admin/templates/widgets/role_fields.pt,sha256=gVd9eRYaqw8fGmZauqEUS_Igmyxaa71qcmdC1KUx5nY,2623
 c2cgeoportal_admin/templates/widgets/theme_fields.pt,sha256=68G1Ya8-Dc6pCeP-taQ0ofCIpnY_v0rouazkFhfQflU,3083
 c2cgeoportal_admin/templates/widgets/user_fields.pt,sha256=twmajhUYL1xa47Eu-iATKifNPA5lu3SGpqdKajH6gL8,1753
 c2cgeoportal_admin/views/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-c2cgeoportal_admin/views/dimension_layers.py,sha256=brEA1L7RXABKQLoScK5S2tjWn7jm9xRHgzAj3BjmgHw,2465
-c2cgeoportal_admin/views/functionalities.py,sha256=SfMoEShBTOFj_20V3JHVDToOMrmHoLWd4K87Yf_TDgM,3144
-c2cgeoportal_admin/views/home.py,sha256=_WJgyna095opx_b9PuchjeVEztj3tFWCx5Low3RVK-s,1804
-c2cgeoportal_admin/views/interfaces.py,sha256=EEcwNqzk9ZNJ5o7Fcbdf62iMkyjBQSv04y7SQT-XvtA,3468
-c2cgeoportal_admin/views/layer_groups.py,sha256=OBM48lbCDfeI772k3ypukGEbhIwzt5hW4REr-Bs78Zw,3826
-c2cgeoportal_admin/views/layers.py,sha256=OhEITd5AWEYCztGmrK_PP59CeTOcgRp2AE3g_ghdG6U,2897
-c2cgeoportal_admin/views/layers_vectortiles.py,sha256=gOAwB7j2esEKuDvZtNQEVy8SCAfICNvXWMcx61x4qiE,4103
-c2cgeoportal_admin/views/layers_wms.py,sha256=V7PHrimLs_l5iS7zhxDFRfhWSRFBsohtWpE_OM7gkPs,7314
-c2cgeoportal_admin/views/layers_wmts.py,sha256=xvhxifKtyixmswwSUj8mSWBnWMdFc1Rpmexh0apzEXs,7084
-c2cgeoportal_admin/views/layertree.py,sha256=0sxWBWljqCWKM1rEZek1a6K7gRWVIXXfWn-sr5UVqBA,7954
-c2cgeoportal_admin/views/oauth2_clients.py,sha256=j6kPtxU7vpeJ8Hx58twCLBV-jkVl3_gsxEx6tOLEkms,3342
-c2cgeoportal_admin/views/ogc_servers.py,sha256=zy7dE8DLl811d4hdOFopknD8xhkEKGJwIeOhlUBSlTM,6178
-c2cgeoportal_admin/views/restriction_areas.py,sha256=ozR86-lo3DXBSr_CPn9-AxpDhZWscXUvqKsqIHovSKk,5369
-c2cgeoportal_admin/views/roles.py,sha256=wSBtpX8CuPhI5L9UHS1rxck8-r3mlFz5oGUiIaPU1EA,5578
-c2cgeoportal_admin/views/themes.py,sha256=q7dnR-SzsvnXbH5pHrvpYeF2FuazBLZsmvWTnjxPx88,5502
-c2cgeoportal_admin/views/themes_ordering.py,sha256=eRR81U6ocvmnUtwtdBR20ir525g2FSIEDNaC5DAY-NY,5405
-c2cgeoportal_admin/views/treeitems.py,sha256=GRGHu1ixeALE2PoLw1xOAHkJbICtS6xozKqn8pSXg6U,3787
-c2cgeoportal_admin/views/users.py,sha256=bA4Ym5xmNIBgqNBk2H5bWHhdR4saYN2Ee_k1unzgrlQ,5193
-tests/__init__.py,sha256=ro7p4MDwv2b8wIQ3jDKErfrDahzvQBYKlKXhixxzvfI,9599
-tests/conftest.py,sha256=ahIRbwn9t6Nmb-4ZE-slO2dOQDQbPX9RYrLOn2qGzGw,2065
-tests/test_edit_url.py,sha256=u-0HNUgMu0CVtYbdgixSyqy961Ii2Yh2At07LSObgPI,4654
-tests/test_functionalities.py,sha256=ZgGeRP0eNLAxhgfT6Wj3zxtnClKuNqEGGl8oMVs9tZ4,3857
+c2cgeoportal_admin/views/dimension_layers.py,sha256=jupwqX_kO37ukcWE-SsO290JdKENEmfoYxk4sRWb25Y,2598
+c2cgeoportal_admin/views/functionalities.py,sha256=U51DvRd6Jg40VQm66kyVy363cDGGEol0WwaQC8b2ZKM,4002
+c2cgeoportal_admin/views/home.py,sha256=h_hJWIKpzJeSmXl58J0nvZdEg7avSYOOVUEEnlV-r0k,1943
+c2cgeoportal_admin/views/interfaces.py,sha256=3Sl-57PchMlUw_RrvL7F4KTpa57ifpNjOxk-nWqMXpk,3465
+c2cgeoportal_admin/views/layer_groups.py,sha256=CbuURDXMcRXnWbW9aEhXP9nSiSiFq4m3JdtgQS6agxs,3956
+c2cgeoportal_admin/views/layers.py,sha256=xjvcRvKVpeD-LRuVwE8PGkDT-Kih9ADX0beEDcOP1bE,3039
+c2cgeoportal_admin/views/layers_vectortiles.py,sha256=lREdMc7bo2TVqdf-s6MzNXZoauReqFS_K-Hng49NUT4,4932
+c2cgeoportal_admin/views/layers_wms.py,sha256=p3g2zc2waMBBrlFQjgTUn9YTg3WcXQofx5Yw1b3ozAg,7954
+c2cgeoportal_admin/views/layers_wmts.py,sha256=IxvF_knk3HYsa8gKhIaZsyi5Uhmv_Qrmd50gU8BPla8,7731
+c2cgeoportal_admin/views/layertree.py,sha256=x1nTVwyf-ZK7M0gIDpsDdySMZm3XmE6yGEE9j8VYQ4Y,8589
+c2cgeoportal_admin/views/oauth2_clients.py,sha256=hovhxGKK3et_Lny7UuXsterP_OUSZ1HW7YqhawEXrOw,3740
+c2cgeoportal_admin/views/ogc_servers.py,sha256=rK0dIS2XLTc5EDeGrnDf_mpHlNXJsCEyUpci_lIexR8,7476
+c2cgeoportal_admin/views/restriction_areas.py,sha256=0Zpo8p5Zsw3JdPCH8kqWr020boBpNiKMhARKcgCsOVU,5549
+c2cgeoportal_admin/views/roles.py,sha256=7BjQ0zLcsf6JW8OgBKJukaMRksUB-VKTeILfhP9bLG0,5858
+c2cgeoportal_admin/views/themes.py,sha256=Qv6sZ7op90JEd7ASGuTU68rjTdsRrGlf0clYqqumuFI,5710
+c2cgeoportal_admin/views/themes_ordering.py,sha256=NYN3I2tDwLW5E4G-695DwV0dCbHUAObWVFYZ8Bir1-o,5590
+c2cgeoportal_admin/views/treeitems.py,sha256=p-Ba_v3UFtUZEmlct4MZmkwv7jzMoxNKnCVa_FX2hxg,3860
+c2cgeoportal_admin/views/users.py,sha256=YzyKYDDTVn69NQPkrlkmbpgrtsIkK_cxqlcWa6utAVA,5355
+tests/__init__.py,sha256=JbVMbOZgS0u5_MhWBnyzT1gdv3cXwhkXyLQgDqpZAik,9525
+tests/conftest.py,sha256=ah7JmR2epDZul2rmMH5wuUzkSpXIjm8dd-cgGjK6_k0,2119
+tests/test_edit_url.py,sha256=00Q9E3QOtsEEB0YJQehllFr1ztQCU3wc9OyayXCHYI4,4495
+tests/test_functionalities.py,sha256=CPHxBueoCt8W76VJN2sCouxQyc7LD7ccusRah5UK2ys,4126
 tests/test_home.py,sha256=oA4i-V9jJQQgHD9Gz79mgIEMUCRw3tmIQVqdhM9Q2Fo,426
-tests/test_interface.py,sha256=VzMlV6k73V0mKIP8RFcrDe7TS8OOonUXhey_Z5hQC3Q,4768
-tests/test_layer_groups.py,sha256=7PWhPegITgdsy7c8blyw3QRAUOXfecKgA2IaVXaxPpg,11441
-tests/test_layers_vectortiles.py,sha256=lYd27gKbQBewYmdK128M8c9SbruBupfx0-OpBlMYF3Q,9509
-tests/test_layers_wms.py,sha256=5x5i1EUTyCu_LRt9uTkYHPrnQuBozS8xk6_e02qmDjA,18503
-tests/test_layers_wmts.py,sha256=UF1xVSjF-ETN8JMRtwvGZwWAfqUk66hZOcJvKlXNvik,11355
-tests/test_layertree.py,sha256=5HWTY_R_eSfN3C2JOVv0zA9r6PxlK05MnhPFobLkz_U,8336
+tests/test_interface.py,sha256=ml1yM4t1o6jIQEHZRwMywjt7mjkUhP-34VKBgHOmWes,4704
+tests/test_layer_groups.py,sha256=Bb1Rsy8QkzGee6edY4UQY8hcxvp54PE7gXUcHoi__JA,11062
+tests/test_layers_vectortiles.py,sha256=DjOLkm3o8nPJJbd010Xi_pwHTK5roiHoQBYAuNaZW5c,9395
+tests/test_layers_wms.py,sha256=MISvkAjEZ4oSD1xg7Zah_GKiBHNu60D8kT03f241wuc,18175
+tests/test_layers_wmts.py,sha256=jjO3AbOQgHgC2yXdYke339W11Ygz1b8DpuAn4OXLnxE,11185
+tests/test_layertree.py,sha256=uu-2AzVtqr87eqq9w_5EWPR_KIXFFjEipEA0_ImnkCU,11336
 tests/test_learn.py,sha256=gQwe-Bim0eihZH0rbBWDn6_rIBxvQD_lyu9MlOljupM,2307
 tests/test_left_menu.py,sha256=-K_429ZcW5Hsz317StIRVz8VtU7GDMH7UCTzZDfckUo,920
-tests/test_main.py,sha256=r2CibHqXh4MoX7bjwRr1pXPAfhCGK7Jbmfu7XmMm_gQ,354
-tests/test_metadatas.py,sha256=fFbOx8wd_e4fZ0XTbt8uDD9Rkrialrj4pWXnCc61Jl8,11637
-tests/test_oauth2_clients.py,sha256=-Ib4npWgWzbc8PcufPEEklwsb9DdNMqsV02eEfva2nc,5814
-tests/test_ogc_servers.py,sha256=grjAruIQG7PMvsJdu_OQZlk4hrBEWHFJ-R960PL08Go,6150
-tests/test_restriction_areas.py,sha256=iVWz_dhQ-jjIoW4ZhZlP9mNVy5vW--wUqMuJ4efuEWA,8026
-tests/test_role.py,sha256=absegjdV2cK6l9urH15iOf-dj_KLqglJvyyyfHVpD5U,11730
-tests/test_themes.py,sha256=cHbAKuDATv5cR3Y0kqaSfGCzcH9114mv3lwI_9uDmKg,15119
-tests/test_themes_ordering.py,sha256=AqJ8HOfL6__QnZIjl7RqsQLbH352iR8pokNshctQOeQ,2260
-tests/test_treegroup.py,sha256=CBM77NxjWygcikjgci20R4MEnnwQLpFI9AExM83s118,592
-tests/test_user.py,sha256=-m1t50cazeTWDRQtLogFDP2iwJ14cko6bWkovFOpol4,11738
-tests/themes_ordering.py,sha256=b6PpQQbbB9RqKKiBl5iF7T3tQGgvJ18LGTJCbP31FVQ,1351
-c2cgeoportal_admin-2.6.0.dist-info/METADATA,sha256=iNHLMRs8cbvEDbPmQw9M7LOMaZOmB_OWchUNNQ95kkw,1276
-c2cgeoportal_admin-2.6.0.dist-info/WHEEL,sha256=g4nMs7d-Xl9-xC9XovUrsDHGXt-FT0E17Yqo92DEfvY,92
-c2cgeoportal_admin-2.6.0.dist-info/entry_points.txt,sha256=CroEMatntjAOxN-0qHPOOjVrtmBg_WxpUcUmvRtUJZA,52
-c2cgeoportal_admin-2.6.0.dist-info/top_level.txt,sha256=DgcTJgTvpJUB8HqwYB14PdLBPAOAFk0B8oqnSTFoAU4,25
-c2cgeoportal_admin-2.6.0.dist-info/RECORD,,
+tests/test_lingua_extractor_config.py,sha256=3dqgIdCB1M3YPzXrgDCFQ74t0t4QRXwdQZSy6AMqKp8,2515
+tests/test_main.py,sha256=_gUdMrMMAEzvGIf1QwkoHQkd0eBACz05ycTidCHP5Ao,365
+tests/test_metadatas.py,sha256=dawAKLxyWy4Ok3TWAR5zsB_IN_Ci_VJdjNE9fU5NVjE,12089
+tests/test_oauth2_clients.py,sha256=UaTz7jE0-V2JJ4VkjA3W0FlzgkfacI1jchiynXNNYbc,5782
+tests/test_ogc_servers.py,sha256=qPrbLFw8zaPOpk-fbydJUtfgLl9nxA81jOUNd1l8EUI,6436
+tests/test_restriction_areas.py,sha256=S97lbxHghyhz9h8Sv78jYt2EOQEgwlUp8zCfOtmV-OU,7925
+tests/test_role.py,sha256=99Rk4PCTtoVzbiTP3cR3cVkuIArdLywBl2Hx8Pk5lnE,11820
+tests/test_themes.py,sha256=e-OGon6beHfY4q8xOGsYjW-_pm0-wTA18DPBOz6F9iM,15181
+tests/test_themes_ordering.py,sha256=qIEgLgIjSYpWqMVXBAhOk6BKBUAPXkiXsxWB_A1Dy4s,2244
+tests/test_treegroup.py,sha256=Plv119G4TWlurWLE7Z1mWGeHHPScK_fWKcDmDzMUlIU,576
+tests/test_user.py,sha256=pW2Fsbw8wIP2H3BxAMUojSonhMMyr63jsWFmEteaogk,11659
+tests/themes_ordering.py,sha256=mbjTJHl63UVdv5SsfgDrjOx-1z6C5L4wDSCzIh7LPAE,1343
+c2cgeoportal_admin-2.7.1.83.dist-info/METADATA,sha256=TT7bat-v0qEsnHKb32W0CSMoBwDWUYiAmtGox5o-Hjk,1491
+c2cgeoportal_admin-2.7.1.83.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+c2cgeoportal_admin-2.7.1.83.dist-info/entry_points.txt,sha256=ZF-xnP-Q_zr7y6yRmVqjIGVZ1L2iKi5uaOxjxJQBuG4,164
+c2cgeoportal_admin-2.7.1.83.dist-info/top_level.txt,sha256=DgcTJgTvpJUB8HqwYB14PdLBPAOAFk0B8oqnSTFoAU4,25
+c2cgeoportal_admin-2.7.1.83.dist-info/RECORD,,
```

