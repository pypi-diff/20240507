# Comparing `tmp/mwxlib-0.94.5-py3-none-any.whl.zip` & `tmp/mwxlib-0.94.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 171456 bytes, number of entries: 28
+Zip file size: 171309 bytes, number of entries: 28
 -rw-rw-rw-  2.0 fat      834 b- defN 24-Apr-25 02:43 mwx/__init__.py
--rw-rw-rw-  2.0 fat     5070 b- defN 24-Apr-30 06:40 mwx/bookshelf.py
--rw-rw-rw-  2.0 fat    47196 b- defN 24-Apr-23 02:09 mwx/controls.py
--rw-rw-rw-  2.0 fat    75494 b- defN 24-Apr-29 18:26 mwx/framework.py
--rw-rw-rw-  2.0 fat    69991 b- defN 24-Apr-29 18:23 mwx/graphman.py
+-rw-rw-rw-  2.0 fat     5000 b- defN 24-May-07 05:46 mwx/bookshelf.py
+-rw-rw-rw-  2.0 fat    47185 b- defN 24-May-03 17:38 mwx/controls.py
+-rw-rw-rw-  2.0 fat    75272 b- defN 24-May-07 06:49 mwx/framework.py
+-rw-rw-rw-  2.0 fat    70027 b- defN 24-May-03 17:38 mwx/graphman.py
 -rw-rw-rw-  2.0 fat    49957 b- defN 23-Oct-30 22:59 mwx/images.py
 -rw-rw-rw-  2.0 fat    32682 b- defN 24-Mar-26 09:41 mwx/matplot2.py
 -rw-rw-rw-  2.0 fat    65442 b- defN 24-Apr-27 10:54 mwx/matplot2g.py
 -rw-rw-rw-  2.0 fat    27224 b- defN 24-Apr-19 03:02 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     5671 b- defN 23-Dec-23 15:51 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   135647 b- defN 24-Apr-30 06:36 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat   135627 b- defN 24-May-07 05:46 mwx/nutshell.py
 -rw-rw-rw-  2.0 fat    37399 b- defN 24-Apr-30 05:03 mwx/utilus.py
 -rw-rw-rw-  2.0 fat    12717 b- defN 24-Feb-16 07:48 mwx/wxmon.py
 -rw-rw-rw-  2.0 fat    19129 b- defN 24-Feb-13 10:31 mwx/wxpdb.py
 -rw-rw-rw-  2.0 fat     5578 b- defN 24-Feb-13 10:31 mwx/wxwil.py
 -rw-rw-rw-  2.0 fat     7334 b- defN 24-Apr-30 06:36 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat       41 b- defN 24-Apr-19 03:02 mwx/plugins/__init__.py
 -rw-rw-rw-  2.0 fat     9399 b- defN 24-Apr-19 03:02 mwx/plugins/ffmpeg_view.py
 -rw-rw-rw-  2.0 fat     2675 b- defN 24-Apr-19 03:02 mwx/plugins/fft_view.py
 -rw-rw-rw-  2.0 fat    10110 b- defN 24-Apr-19 03:02 mwx/plugins/frame_listview.py
 -rw-rw-rw-  2.0 fat      816 b- defN 24-Apr-19 03:02 mwx/plugins/line_profile.py
 -rw-rw-rw-  2.0 fat       12 b- defN 24-Apr-19 03:02 mwx/py/__init__.py
 -rw-rw-rw-  2.0 fat    16806 b- defN 23-Nov-10 02:50 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 24-Apr-30 06:44 mwxlib-0.94.5.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1925 b- defN 24-Apr-30 06:44 mwxlib-0.94.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-30 06:44 mwxlib-0.94.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 24-Apr-30 06:44 mwxlib-0.94.5.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2093 b- defN 24-Apr-30 06:44 mwxlib-0.94.5.dist-info/RECORD
-28 files, 642429 bytes uncompressed, 168210 bytes compressed:  73.8%
+-rw-rw-rw-  2.0 fat     1091 b- defN 24-May-07 07:33 mwxlib-0.94.8.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1925 b- defN 24-May-07 07:33 mwxlib-0.94.8.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-07 07:33 mwxlib-0.94.8.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 24-May-07 07:33 mwxlib-0.94.8.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2093 b- defN 24-May-07 07:33 mwxlib-0.94.8.dist-info/RECORD
+28 files, 642142 bytes uncompressed, 168063 bytes compressed:  73.8%
```

## zipnote {}

```diff
@@ -63,23 +63,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.94.5.dist-info/LICENSE
+Filename: mwxlib-0.94.8.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.94.5.dist-info/METADATA
+Filename: mwxlib-0.94.8.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.94.5.dist-info/WHEEL
+Filename: mwxlib-0.94.8.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.94.5.dist-info/top_level.txt
+Filename: mwxlib-0.94.8.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.94.5.dist-info/RECORD
+Filename: mwxlib-0.94.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/bookshelf.py

```diff
@@ -23,16 +23,15 @@
             None : {
                    'buffer_new' : [ None, self.on_buffer_new ],
                  'buffer_saved' : [ None, ],
                 'buffer_loaded' : [ None, ],
                'buffer_deleted' : [ None, self.on_buffer_deleted ],
              'buffer_activated' : [ None, self.on_buffer_selected ],
            'buffer_inactivated' : [ None, ],
-         'buffer_caption_reset' : [ None, self.on_buffer_filename ],
-        'buffer_filename_reset' : [ None, self.on_buffer_filename ],
+       'buffer_caption_updated' : [ None, self.on_buffer_filename ],
             },
         }
         
         ## self.Bind(wx.EVT_TREE_ITEM_GETTOOLTIP, self.OnItemTooltip)
         self.Bind(wx.EVT_TREE_SEL_CHANGED, self.OnSelChanged)
         self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)
```

## mwx/controls.py

```diff
@@ -737,15 +737,15 @@
         else:
             for p, v in zip(params, argv):
                 try:
                     p.reset(v) # eval v:str -> value
                 except AttributeError:
                     p.value = v
                 except Exception as e: # failed to eval
-                    print("- Failed to reset {!r}: {}".format(p, e))
+                    print(f"- Failed to reset {p!r}:", e)
                     pass
     
     reset_params = set_params #: for backward compatibility
     
     def copy_to_clipboard(self, checked_only=False):
         params = self.get_params(checked_only)
         text = '\t'.join(str(p) if isinstance(p, Param) else
```

## mwx/framework.py

```diff
@@ -1,11 +1,11 @@
 #! python3
 """mwxlib framework.
 """
-__version__ = "0.94.5"
+__version__ = "0.94.8"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 from contextlib import contextmanager
 import traceback
 import warnings
@@ -290,20 +290,22 @@
         if not map:
             map = state
         elif map == '*':
             map = state = None
         key += ' pressed'
         
         if map not in self.handler:
-            warnings.warn(f"New map to define_key {keymap!r} in {self}.", stacklevel=2)
+            warnings.warn(f"New map to define_key {keymap!r} in {self}.",
+                          stacklevel=2)
             self.make_keymap(map) # make new keymap
         
         transaction = self.handler[map].get(key, [state])
         if len(transaction) > 1:
-            warnings.warn(f"Duplicate define_key {keymap!r} in {self}.", stacklevel=2)
+            warnings.warn(f"Duplicate define_key {keymap!r} in {self}.",
+                          stacklevel=2)
         
         if action is None:
             self.handler[map].pop(key, None) # cf. undefine_key
             return lambda f: self.define_key(keymap, f, *args, **kwargs)
         
         F = _F(action, *args, **kwargs)
         @wraps(F)
@@ -321,15 +323,16 @@
 class CtrlInterface(KeyCtrlInterfaceMixin):
     """Mouse/Key event interface mixin.
     """
     handler = property(lambda self: self.__handler)
     
     def __init__(self):
         if hasattr(self, 'handler'):
-            warnings.warn(f"Duplicate iniheritance of CtrlInterface by {self}.", stacklevel=2)
+            warnings.warn(f"Duplicate iniheritance of CtrlInterface by {self}.",
+                          stacklevel=2)
             return
         self.__key = ''
         self.__button = ''
         self.__isDragging = False
         self.__handler = FSM({None:{}, 0:{}})
         
         _M = self._mouse_handler
@@ -626,15 +629,16 @@
         return next((item.SubMenu for item in root.MenuItems if item.ItemLabel == key), None)
     
     def update(self, key):
         """Update items of the menu that has specified key:root/branch.
         Call when the menulist is changed.
         """
         if not self.Parent:
-            warnings.warn(f"No parents bound to {self}.", stacklevel=2)
+            warnings.warn(f"No parents bound to {self}.",
+                          stacklevel=2)
             return
         
         menu = self.getmenu(key)
         if not menu:
             self.reset()
             return
         
@@ -653,15 +657,16 @@
             self.EnableTop(j, bool(values)) # Disable empty main menu.
     
     def reset(self):
         """Recreates the menubar if the Parent was attached.
         Call when the menulist is changed.
         """
         if not self.Parent:
-            warnings.warn(f"No parents bound to {self}.", stacklevel=2)
+            warnings.warn(f"No parents bound to {self}.",
+                          stacklevel=2)
             return
         
         for j in range(self.GetMenuCount()): # remove and del all top-level menu
             menu = self.Remove(0)
             menu.Destroy()
         
         for j, (key, values) in enumerate(self):
@@ -1169,23 +1174,26 @@
         self.watcher.Bind(wx.EVT_SHOW, self.OnGhostShow)
         
         self._mgr = aui.AuiManager()
         self._mgr.SetManagedWindow(self)
         self._mgr.SetDockSizeConstraint(0.5, 0.5) # (w, h)/N
         
         self._mgr.AddPane(self.console,
-                          aui.AuiPaneInfo().Name("console").CenterPane().Show(1))
+                          aui.AuiPaneInfo().Name("console").CenterPane()
+                             .MaximizeButton().Show(1))
         
         self._mgr.AddPane(self.ghost,
                           aui.AuiPaneInfo().Name("ghost")
-                             .Caption("Ghost in the Shell").Right().Show(0))
+                             .Caption("Ghost in the Shell").Right()
+                             .MaximizeButton().Show(0))
         
         self._mgr.AddPane(self.watcher,
                           aui.AuiPaneInfo().Name("watcher")
-                             .Caption("Watchdog in the Shell").Right().Position(1).Show(0))
+                             .Caption("Watchdog in the Shell").Right().Position(1)
+                             .MaximizeButton().Show(0))
         
         self._mgr.Update()
         
         self.Unbind(wx.EVT_CLOSE)
         self.Bind(wx.EVT_CLOSE, self.OnClose)
         self.Bind(wx.EVT_SHOW, self.OnShow)
         
@@ -1240,79 +1248,71 @@
                 'monitor_begin' : [ None, self.on_monitor_begin ],
                   'monitor_end' : [ None, self.on_monitor_end ],
                    'buffer_new' : [ None, ],
                     'shell_new' : [ None, ],
                       'add_log' : [ None, self.add_log ],
                      'add_help' : [ None, self.add_help ],
                  'title_window' : [ None, self.on_title_window ],
-         'buffer_caption_reset' : [ None, self.on_buffer_caption ], # => self.OnActivate
+       'buffer_caption_updated' : [ None, self.on_buffer_caption ], # => self.OnActivate
             },
             0 : {
                     '* pressed' : (0, fork_debugger),
                    '* released' : (0, fork_debugger),
                   'C-g pressed' : (0, self.quit, fork_debugger),
                    'f1 pressed' : (0, self.About),
                   'C-f pressed' : (0, self.OnFindText),
                    'f3 pressed' : (0, self.OnFindNext),
                  'S-f3 pressed' : (0, self.OnFindPrev),
-                  'f11 pressed' : (0, _F(self.toggle_window, self.ghost, doc="Toggle ghost")),
-                'S-f11 pressed' : (0, _F(self.toggle_window, self.watcher, doc="Toggle watcher")),
-                  'f12 pressed' : (0, _F(self.Close, alias="close", doc="Close the window")),
+                  'f11 pressed' : (0, _F(self.toggle_window, self.ghost, alias='toggle_ghost')),
+                'S-f11 pressed' : (0, _F(self.toggle_window, self.watcher, alias='toggle_watcher')),
+                  'f12 pressed' : (0, _F(self.Close, alias="close")),
              '*f[0-9]* pressed' : (0, ),
             },
         })
         
-        ## py-mode
         self.Scratch.set_attributes(Style=Nautilus.STYLE)
+        self.Log.set_attributes(ReadOnly=True)
+        self.Help.set_attributes(ReadOnly=True)
         
         self.set_hookable(self.Scratch)
+        self.set_hookable(self.Log)
         
         @self.Scratch.define_key('C-j')
-        @postcall
         def eval_line():
             shell = self.current_shell
             self.Scratch.buffer.py_eval_line(shell.globals, shell.locals)
         
         @self.Scratch.define_key('C-S-j')
-        @postcall
         def eval_buffer():
             shell = self.current_shell
             self.Scratch.buffer.py_exec_region(shell.globals, shell.locals)
         
-        ## text-mode
-        self.set_hookable(self.Log)
-        
-        self.Log.set_attributes(ReadOnly=True)
-        self.Help.set_attributes(ReadOnly=True)
+        ## Session
+        self.SESSION_FILE = get_rootpath(".debrc")
+        self.SCRATCH_FILE = get_rootpath("scratch.py")
+        self.LOGGING_FILE = get_rootpath("deb-logging.log")
         
         self.load_session(
             os.path.abspath(debrc) if debrc else self.SESSION_FILE)
-        
-    SESSION_FILE = get_rootpath(".debrc")
-    SCRATCH_FILE = get_rootpath("scratch.py")
-    LOGGING_FILE = get_rootpath("deb-logging.log")
     
     def load_session(self, filename):
         """Load session from file."""
         def _fload(editor, filename):
             try:
                 buffer = editor.default_buffer or editor.new_buffer()
                 buffer.LoadFile(filename)
                 buffer.EmptyUndoBuffer()
             except Exception:
                 pass
         
-        for book in self.all_editors:
-            book.delete_all_buffers() # Note: *log* is also flushed.
+        _fload(self.Scratch, self.SCRATCH_FILE) # restore scratch
         
         ## Re-open the *log* file.
         self.add_log("#! Opened: <{}>\r\n".format(datetime.datetime.now()))
         
-        _fload(self.Scratch, self.SCRATCH_FILE) # restore scratch
-        
         fn = os.path.abspath(filename)
         try:
             with open(fn, encoding='utf-8', newline='') as i:
                 exec(i.read())
         except FileNotFoundError:
             pass
         self.SESSION_FILE = fn
@@ -1540,45 +1540,40 @@
                 
                 ## Thanks are also due to wx.
                 "#{!r}".format(wx),
                 "To show the credit, press C-M-Mbutton.\n",
                 ))
             )
     
-    def toggle_window(self, win, focus=False):
-        self.popup_window(win, show=None, focus=focus)
+    def toggle_window(self, win):
+        pane = self._mgr.GetPane(win)
+        if pane.IsDocked():
+            if not self.console.IsShown():
+                self._mgr.RestoreMaximizedPane()
+                self._mgr.Update()
+                return
+        self.popup_window(win, not pane.IsShown())
     
-    def popup_window(self, win, show=True, focus=True):
-        """Show the notebook page and move the focus.
-        
-        Args:
-            win  : window to popup
-            show : True, False, otherwise None:toggle
-                   The pane window will be hidden if no show.
-        """
+    def popup_window(self, win, show=True):
+        """Show the notebook page and keep the focus."""
         wnd = wx.Window.FindFocus() # original focus
         
         for pane in self._mgr.GetAllPanes():
             nb = pane.window
             if nb is win:
                 break
             j = nb.GetPageIndex(win) # find and select page
             if j != -1:
                 if j != nb.Selection:
                     nb.Selection = j # the focus is moved
                 break
         else:
             return # no such pane.window
         
-        if show is None:
-            show = not pane.IsShown() # toggle show
-        
-        if focus and win.IsShown():
-            win.SetFocus() # move focus
-        elif wnd:
+        if wnd:
             wnd.SetFocus() # restore focus
         
         ## Modify the floating position of the pane when displayed.
         ## Note: This is a known bug in wxWidgets 3.17 -- 3.20,
         ##       and will be fixed in wxPython 4.2.1.
         if wx.Display.GetFromWindow(pane.window) == -1:
             pane.floating_pos = wx.GetMousePosition()
@@ -1601,60 +1596,59 @@
         self.debugger.send_input('\n') # terminates the reader of threading pdb
         shell = self.debugger.interactive_shell # reset interp locals
         del shell.locals
         del shell.globals
         self.indicator.Value = 1
         self.message("Quit")
     
-    def _load(self, filename, lineno, editor, verbose=False):
+    def _load(self, filename, lineno, editor):
         """Load file in the session (internal use only)."""
         if isinstance(editor, str):
             editor = getattr(self, editor, None)
         if editor:
-            return editor.load_file(filename, lineno, verbose)
+            return editor.load_file(filename, lineno, verbose=0)
     
-    def load(self, filename, lineno=0, show=True, focus=False):
+    def load(self, filename, lineno=0, show=True):
         """Load file @where the object is defined.
         
         Args:
             filename : target filename:str or object.
                        It also supports <'filename:lineno'> format.
             lineno   : Set mark to lineno on load.
             show     : Show the page.
-            focus    : Focus the window if visible.
         """
         if not isinstance(filename, str):
             filename = where(filename)
             if filename is None:
                 return None
         if not lineno:
             m = re.match("(.*?):([0-9]+)", filename)
             if m:
                 filename, ln = m.groups()
                 lineno = int(ln)
         editor = self.find_editor(filename) or self.Log
         ret = editor.load_file(filename, lineno, verbose=1)
         if ret:
-            self.popup_window(editor, show, focus)
+            self.popup_window(editor, show)
         return ret
     
     def info(self, obj):
         self.rootshell.info(obj)
     
     def help(self, obj):
         self.rootshell.help(obj)
     
     def watch(self, obj):
         if isinstance(obj, wx.Object):
             self.monitor.watch(obj)
-            self.popup_window(self.monitor, focus=0)
+            self.popup_window(self.monitor)
         elif hasattr(obj, '__dict__'):
             self.linfo.watch(obj.__dict__)
             self.ginfo.watch({})
-            self.popup_window(self.linfo, focus=0)
+            self.popup_window(self.linfo)
     
     def highlight(self, obj, *args, **kwargs):
         self.inspector.highlight(obj, *args, **kwargs)
     
     def timeit(self, obj, *args, **kwargs):
         """Measure the duration cpu time (per one execution)."""
         from timeit import timeit
@@ -1728,16 +1722,16 @@
         if not self:
             return
         shell = self.debugger.interactive_shell
         shell.write("#<-- Enter [n]ext to continue.\n", -1)
         shell.prompt()
         shell.SetFocus()
         self.Show()
-        self.popup_window(self.ghost, focus=0)
-        self.popup_window(self.linfo, focus=0)
+        self.popup_window(self.ghost)
+        self.popup_window(self.linfo)
         self.add_log("<-- Beginning of debugger\r\n")
         self.indicator.Value = 2
     
     def on_debug_next(self, frame):
         """Called from cmdloop."""
         if not self:
             return
@@ -1745,15 +1739,15 @@
         shell.globals = gs = frame.f_globals
         shell.locals = ls = frame.f_locals
         if self.ginfo.target is not gs:
             self.ginfo.watch(gs)
         if self.linfo.target is not ls:
             self.linfo.watch(ls)
         self.on_title_window(frame)
-        self.popup_window(self.debugger.editor, focus=0)
+        self.popup_window(self.debugger.editor)
         dispatcher.send(signal='Interpreter.push',
                         sender=shell, command=None, more=False)
         command = shell.cmdline
         if command and not command.isspace():
             command = re.sub(r"^(.*)", r"    \1", command, flags=re.M)
             self.add_log(command)
         self.message("Debugger is busy now (Press [C-g] to quit).")
@@ -1851,26 +1845,26 @@
     
     def add_help(self, text):
         """Add text to the help buffer."""
         buf = self.Help.default_buffer or self.Help.new_buffer()
         with buf.off_readonly():
             buf.SetText(text)
         ## Overwrite text and popup the window.
-        self.popup_window(self.Help, focus=0)
+        self.popup_window(self.Help)
     
     def clone_shell(self, target):
         if not hasattr(target, '__dict__'):
             raise TypeError("primitive objects cannot be targeted")
         
         shell = self.rootshell.__class__(self, target, name="clone",
                     style=wx.CLIP_CHILDREN|wx.BORDER_NONE)
         self.handler('shell_new', shell)
         self.console.AddPage(shell, typename(shell.target))
-        self.Show()
-        self.popup_window(shell, focus=1)
+        self.popup_window(shell)
+        shell.SetFocus()
         return shell
     
     def delete_shell(self, shell):
         """Close the current shell."""
         if shell is self.rootshell:
             ## self.message("- Don't close the root shell.")
             return
```

## mwx/graphman.py

```diff
@@ -469,15 +469,15 @@
             for art in self.Arts:
                 art.set_visible(show)
             ## To avoid RuntimeError, check if canvas object has been deleted.
             canvas = art.axes.figure.canvas
             if canvas:
                 canvas.draw_idle()
         except Exception as e:
-            print("- Failed to draw Arts of {}: {}".format(self.__module__, e))
+            print(f"- Failed to draw Arts of {self.__module__}:", e)
             del self.Arts
 
 
 class Layer(ControlPanel, LayerInterface):
     """Graphman.Layer
     """
     def __init__(self, parent, session=None, **kwargs):
@@ -1051,15 +1051,16 @@
         """Register dummy plug; Add module.Plugin(Layer).
         """
         if not module:
             module = inspect.getmodule(cls) # rebase module or __main__
         
         if issubclass(cls, LayerInterface):
             cls.__module__ = module.__name__ # __main__ to module
-            warnings.warn(f"Duplicate iniheritance of LayerInterface by {cls}.", stacklevel=2)
+            warnings.warn(f"Duplicate iniheritance of LayerInterface by {cls}.",
+                          stacklevel=2)
             module.Plugin = cls
             return cls
         
         class _Plugin(cls, LayerInterface):
             def __init__(self, parent, session=None, **kwargs):
                 cls.__init__(self, parent, **kwargs)
                 LayerInterface.__init__(self, parent, session)
@@ -1095,21 +1096,22 @@
         
         try:
             if name in sys.modules:
                 module = reload(sys.modules[name])
             else:
                 module = import_module(name)
         except Exception as e:
-            print("- Unable to load {!r}: {}".format(root, e))
+            print(f"- Unable to load {root!r}:", e)
             return False
         
         ## the module must have a class `Plugin`.
         if not hasattr(module, 'Plugin'):
             if isinstance(root, type):
-                warnings.warn(f"Use dummy plug for debugging {name!r}.", stacklevel=3)
+                warnings.warn(f"Use dummy plug for debugging {name!r}.",
+                              stacklevel=3)
                 module.__dummy_plug__ = root
                 self.register(root, module)
         else:
             if hasattr(module, '__dummy_plug__'):
                 root = module.__dummy_plug__         # old class (imported)
                 cls = getattr(module, root.__name__) # new class (reloaded)
                 self.register(cls, module)
```

## mwx/nutshell.py

```diff
@@ -1382,40 +1382,40 @@
     
     Name = name # page.window.Name for save/loadPerspective
     
     @property
     def filename(self):
         return self.__filename
     
-    @filename.setter
-    def filename(self, fn):
+    def update_filestamp(self, fn):
         if fn and os.path.isfile(fn):
-            self.__mtime = os.path.getmtime(fn)
+            self.__mtime = os.path.getmtime(fn) # update timestamp (modified time)
         else:
             self.__mtime = None
         if self.__filename != fn:
             self.__filename = fn
-            self.parent.handler('buffer_filename_reset', self)
             self.update_caption()
     
     @property
     def mtdelta(self):
         """Timestamp delta (for checking external mod).
         
         Returns:
             None : No file
             = 0  : a file
             > 0  : a file edited externally
             < 0  : a url file
         """
         fn = self.filename
-        if fn and os.path.isfile(fn):
-            return os.path.getmtime(fn) - self.__mtime
-        if fn and re.match(url_re, fn):
-            return -1
+        if fn:
+            if os.path.isfile(fn):
+                return os.path.getmtime(fn) - self.__mtime
+            if re.match(url_re, fn):
+                return -1
+        return None
     
     @property
     def caption_prefix(self):
         prefix = ''
         dt = self.mtdelta
         if dt is not None:
             if self.IsModified():
@@ -1425,17 +1425,18 @@
             elif dt < 0:
                 prefix += '%'
         if prefix:
             prefix += ' '
         return prefix
     
     def update_caption(self):
+        caption = self.caption_prefix + self.name
         try:
-            if self.parent.set_caption(self, self.caption_prefix + self.name):
-                self.parent.handler('buffer_caption_reset', self)
+            if self.parent.set_caption(self, caption):
+                self.parent.handler('buffer_caption_updated', self)
         except AttributeError:
             pass
     
     @property
     def need_buffer_save(self):
         """Returns whether the buffer should be saved.
         The file has been modified internally.
@@ -1461,15 +1462,15 @@
     
     def __init__(self, parent, filename=None, **kwargs):
         EditWindow.__init__(self, parent, **kwargs)
         EditorInterface.__init__(self)
         
         self.parent = parent
         self.__filename = filename
-        self.filename = filename
+        self.update_filestamp(filename)
         self.code = None
         
         self.Bind(stc.EVT_STC_UPDATEUI, self.OnUpdate) # skip to brace matching
         
         self.Bind(stc.EVT_STC_INDICATOR_CLICK, self.OnIndicatorClick)
         
         self.Bind(stc.EVT_STC_SAVEPOINTLEFT, self.OnSavePointLeft)
@@ -1586,31 +1587,31 @@
     ## --------------------------------
     
     def _load_textfile(self, text, filename):
         with self.off_readonly():
             self.Text = text
             self.EmptyUndoBuffer()
             self.SetSavePoint()
-        self.filename = filename
+        self.update_filestamp(filename)
         self.handler('buffer_loaded', self)
     
     def _load_file(self, filename):
         """Wrapped method of LoadFile."""
         if self.LoadFile(filename):
-            self.filename = filename
+            self.update_filestamp(filename)
             self.EmptyUndoBuffer()
             self.SetSavePoint()
             self.handler('buffer_loaded', self)
             return True
         return False
     
     def _save_file(self, filename):
         """Wrapped method of SaveFile."""
         if self.SaveFile(filename):
-            self.filename = filename
+            self.update_filestamp(filename)
             self.SetSavePoint()
             self.handler('buffer_saved', self)
             return True
         return False
     
     def LoadFile(self, filename):
         """Load the contents of file into the editor.
@@ -1765,16 +1766,15 @@
                    'buffer_new' : [ None, dispatch ],
                  'buffer_saved' : [ None, dispatch ],
                 'buffer_loaded' : [ None, dispatch ],
                'buffer_deleted' : [ None, dispatch ],
               'buffer_modified' : [ None, dispatch ],
              'buffer_activated' : [ None, dispatch, self.on_activated ],
            'buffer_inactivated' : [ None, dispatch, self.on_inactivated ],
-         'buffer_caption_reset' : [ None, dispatch ],
-        'buffer_filename_reset' : [ None, dispatch ],
+       'buffer_caption_updated' : [ None, dispatch ],
              '*button* pressed' : [ None, dispatch, skip ],
             '*button* released' : [ None, dispatch, skip ],
             },
             0 : { # Normal mode
                  'M-up pressed' : (0, _F(self.previous_buffer)),
                'M-down pressed' : (0, _F(self.next_buffer)),
             },
@@ -1991,15 +1991,15 @@
                 return False
             else:
                 if buf._load_file(filename):
                     self.swap_buffer(buf, lineno)
                     return True
                 return False
         except Exception as e:
-            self.post_message("Failed to load {!r}: {}".format(buf.name, e))
+            self.post_message(f"Failed to load {filename!r}:", e)
             self.delete_buffer(buf)
             if org:
                 self.swap_buffer(org)
             return False
         finally:
             self.Thaw()
     
@@ -2027,15 +2027,15 @@
         try:
             if buf._save_file(filename):
                 if buf is self.default_buffer:
                     self.default_buffer = None
                 return True
             return False
         except Exception as e:
-            self.post_message("Failed to save {!r}: {}".format(buf.name, e))
+            self.post_message(f"Failed to save {filename!r}:", e)
             return False
     
     def load_buffer(self, buf=None):
         """Confirm the load with the dialog."""
         buf = buf or self.buffer
         dt = buf.mtdelta
         if dt is None:
@@ -2880,15 +2880,15 @@
                 if not self.target.shell:
                     del self.target.shell # delete the facade <wx.py.shell.ShellFacade>
             except AttributeError:
                 pass
         wx.CallAfter(_del)
     
     def on_activated(self, shell):
-        """Called when shell:self is activated.
+        """Called when the shell:self is activated.
         Reset localvars assigned for the shell target.
         """
         self.trace_position()
         self.parent.handler('title_window', self.target)
         try:
             self.target.shell = self # overwrite the facade <wx.py.shell.ShellFacade>
         except AttributeError:
```

## Comparing `mwxlib-0.94.5.dist-info/LICENSE` & `mwxlib-0.94.8.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.94.5.dist-info/METADATA` & `mwxlib-0.94.8.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.94.5
+Version: 0.94.8
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `mwxlib-0.94.5.dist-info/RECORD` & `mwxlib-0.94.8.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 mwx/__init__.py,sha256=zLsXDgqyC5NsPCjRxjS2huvZ3uDyeOJ1vapotqe2ULM,834
-mwx/bookshelf.py,sha256=UVVIwHaGO4aEHwZ8x5SKjpL-3MmQ1s6kkyuyRZqKWvU,5070
-mwx/controls.py,sha256=1eguX5eofsA6hmS2y7R4hvlFjFikVoZ8v2S1ES7rjEU,47196
-mwx/framework.py,sha256=Hi16j2sajupXq2_m37VMfxumj6eXwfaGq8Le26IMfFc,75494
-mwx/graphman.py,sha256=kntmZcVxIubUtH7mLiDyDr2rXw_2iEvtV9DkFDYtt8s,69991
+mwx/bookshelf.py,sha256=WEILqqxzGtdNUiUvn8oa4aTCSnzO11_MrV2L8sXKjXI,5000
+mwx/controls.py,sha256=prp1NhZqv1XANhi2PPxW9jtrgwj_02XMOOyyzZ48klM,47185
+mwx/framework.py,sha256=9ZWmc31eMBdtFPqTTd21dtyiYsiBA8U0MRuLzIMMVoI,75272
+mwx/graphman.py,sha256=9MG0BzQh5lDDadyPPXps2M0hf6mPN3G0MQbBGdplY_I,70027
 mwx/images.py,sha256=mrnUYH12I3XLVSZcEXlpVltX0XMxufbl2yRvDIQJZqc,49957
 mwx/matplot2.py,sha256=qaF_gvLoLn-TimLbRR59KUavNr1ZpZQdSMqjzJk47rk,32682
 mwx/matplot2g.py,sha256=mDaD367wjq6xsyIDX9ot8jLwYYGayoavWMhqsQVBHac,65442
 mwx/matplot2lg.py,sha256=tg8u7w4DxiJdPN-E197NOmbQpc_1gZkgDHYv_xUhbFA,27224
 mwx/mgplt.py,sha256=ITzxA97yDwr_35BUk5OqnyskSuKVDbpf2AQCKY1jHTI,5671
-mwx/nutshell.py,sha256=VcUDTzqdBdHztVGfkjqEL9DUO6cKaGYvYCAME0Jl0qk,135647
+mwx/nutshell.py,sha256=SWlACsEHGtsLxw3l16TnNALNAB2_ObE7IO0eqo1s4eQ,135627
 mwx/utilus.py,sha256=FTJhVFmx6TAE5rvZ_nfxZgyyaW4zMpXEz74v72X6m7Y,37399
 mwx/wxmon.py,sha256=Qk86VbuuW2rR46pqEYLur13G_aloWz5SVv6sib30YY0,12717
 mwx/wxpdb.py,sha256=2z3ZD9Oo1H-ONBHlaprkB9hrTmAI7o03sqO46ppEFE4,19129
 mwx/wxwil.py,sha256=JK1du4i1RVMbDLqN8jLRDSu_JhKEp4mhHVMElzo4yoE,5578
 mwx/wxwit.py,sha256=MQxXR6VqqT25K6dTQ1U_42SMq1yJT6y54xrMq-OMOaQ,7334
 mwx/plugins/__init__.py,sha256=jnJ-Sl9XJ_7BFDslD_r7dsbxsOT57q_IaEriV53XIGY,41
 mwx/plugins/ffmpeg_view.py,sha256=vUYNybIJsF1JGkDzjBgDyBQvDh8e1oKHlEMY5Fwc8L4,9399
 mwx/plugins/fft_view.py,sha256=evj2kCe6N10JQczW8IajgLVrUWOihQaHQ2xiBzAsAl4,2675
 mwx/plugins/frame_listview.py,sha256=T-2xSv_D2bk9fJ64aiSEe1rJRTeqaIpLVAYEUXW5vz8,10110
 mwx/plugins/line_profile.py,sha256=WJB5z7F53yg4dII2R36IFZvtkSOGWT669b1HmAAXSnQ,816
 mwx/py/__init__.py,sha256=xykgfOytOwNuvXsfkLoumFZSTN-iBsHOjczYXngjmUE,12
 mwx/py/filling.py,sha256=KaHooM32hrGGgqw75Cbt8lAvACwC6RXadob9LGgNnEc,16806
-mwxlib-0.94.5.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
-mwxlib-0.94.5.dist-info/METADATA,sha256=tMDN9Giu-NWqUZx5Pzf0OzlAtx_P6HSMW8EVWd0scMw,1925
-mwxlib-0.94.5.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-mwxlib-0.94.5.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
-mwxlib-0.94.5.dist-info/RECORD,,
+mwxlib-0.94.8.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
+mwxlib-0.94.8.dist-info/METADATA,sha256=fHCSJqHLZhgT8iK4xUBbA2apLus3rSQMqMh0w-O7DxU,1925
+mwxlib-0.94.8.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+mwxlib-0.94.8.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
+mwxlib-0.94.8.dist-info/RECORD,,
```

