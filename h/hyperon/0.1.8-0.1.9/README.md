# Comparing `tmp/hyperon-0.1.8-pp39-pypy39_pp73-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/hyperon-0.1.9-pp39-pypy39_pp73-manylinux_2_17_i686.manylinux2014_i686.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 2071366 bytes, number of entries: 23
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-25 11:37 hyperon-0.1.8.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-25 11:37 hyperon.libs/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-25 11:37 hyperon/
--rwxr-xr-x  2.0 unx  5629776 b- defN 24-Apr-25 11:37 hyperonpy.pypy39-pp73-x86_64-linux-gnu.so
--rw-rw-r--  2.0 unx     1450 b- defN 24-Apr-25 11:37 hyperon-0.1.8.dist-info/RECORD
--rw-r--r--  2.0 unx       18 b- defN 24-Apr-25 11:37 hyperon-0.1.8.dist-info/top_level.txt
--rw-r--r--  2.0 unx      162 b- defN 24-Apr-25 11:37 hyperon-0.1.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       45 b- defN 24-Apr-25 11:37 hyperon-0.1.8.dist-info/entry_points.txt
--rw-r--r--  2.0 unx     1070 b- defN 24-Apr-25 11:37 hyperon-0.1.8.dist-info/METADATA
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-25 11:37 hyperon/exts/
--rw-r--r--  2.0 unx    26416 b- defN 24-Apr-25 11:37 hyperon/atoms.py
--rw-r--r--  2.0 unx     1071 b- defN 24-Apr-25 11:37 hyperon/metta.py
--rw-r--r--  2.0 unx      641 b- defN 24-Apr-25 11:37 hyperon/conversion.py
--rw-r--r--  2.0 unx      342 b- defN 24-Apr-25 11:37 hyperon/__init__.py
--rw-r--r--  2.0 unx    16101 b- defN 24-Apr-25 11:37 hyperon/runner.py
--rw-r--r--  2.0 unx      160 b- defN 24-Apr-25 11:37 hyperon/_version.py
--rw-r--r--  2.0 unx     2424 b- defN 24-Apr-25 11:37 hyperon/ext.py
--rw-r--r--  2.0 unx     7642 b- defN 24-Apr-25 11:37 hyperon/stdlib.py
--rw-r--r--  2.0 unx    15055 b- defN 24-Apr-25 11:37 hyperon/base.py
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-25 11:37 hyperon/exts/das_gate/
--rw-r--r--  2.0 unx     7444 b- defN 24-Apr-25 11:37 hyperon/exts/das_gate/dasgate.py
--rw-r--r--  2.0 unx       46 b- defN 24-Apr-25 11:37 hyperon/exts/das_gate/__init__.py
--rw-r--r--  2.0 unx       32 b- defN 24-Apr-25 11:37 hyperon/exts/das_gate/requirements.txt
-23 files, 5709895 bytes uncompressed, 2068504 bytes compressed:  63.8%
+Zip file size: 2187146 bytes, number of entries: 23
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-07 11:23 hyperon-0.1.9.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-07 11:23 hyperon.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-07 11:23 hyperon/
+-rwxr-xr-x  2.0 unx  5671964 b- defN 24-May-07 11:23 hyperonpy.pypy39-pp73-x86-linux-gnu.so
+-rw-rw-r--  2.0 unx     1447 b- defN 24-May-07 11:23 hyperon-0.1.9.dist-info/RECORD
+-rw-r--r--  2.0 unx       18 b- defN 24-May-07 11:23 hyperon-0.1.9.dist-info/top_level.txt
+-rw-r--r--  2.0 unx      158 b- defN 24-May-07 11:23 hyperon-0.1.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       45 b- defN 24-May-07 11:23 hyperon-0.1.9.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx     1070 b- defN 24-May-07 11:23 hyperon-0.1.9.dist-info/METADATA
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-07 11:23 hyperon/exts/
+-rw-r--r--  2.0 unx    26673 b- defN 24-May-07 11:23 hyperon/atoms.py
+-rw-r--r--  2.0 unx     1071 b- defN 24-May-07 11:23 hyperon/metta.py
+-rw-r--r--  2.0 unx      641 b- defN 24-May-07 11:23 hyperon/conversion.py
+-rw-r--r--  2.0 unx      342 b- defN 24-May-07 11:23 hyperon/__init__.py
+-rw-r--r--  2.0 unx    16101 b- defN 24-May-07 11:23 hyperon/runner.py
+-rw-r--r--  2.0 unx      160 b- defN 24-May-07 11:23 hyperon/_version.py
+-rw-r--r--  2.0 unx     2424 b- defN 24-May-07 11:23 hyperon/ext.py
+-rw-r--r--  2.0 unx     9397 b- defN 24-May-07 11:23 hyperon/stdlib.py
+-rw-r--r--  2.0 unx    15055 b- defN 24-May-07 11:23 hyperon/base.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-07 11:23 hyperon/exts/das_gate/
+-rw-r--r--  2.0 unx     7444 b- defN 24-May-07 11:23 hyperon/exts/das_gate/dasgate.py
+-rw-r--r--  2.0 unx       46 b- defN 24-May-07 11:23 hyperon/exts/das_gate/__init__.py
+-rw-r--r--  2.0 unx       32 b- defN 24-May-07 11:23 hyperon/exts/das_gate/requirements.txt
+23 files, 5754088 bytes uncompressed, 2184290 bytes compressed:  62.0%
```

## zipnote {}

```diff
@@ -1,32 +1,32 @@
-Filename: hyperon-0.1.8.dist-info/
+Filename: hyperon-0.1.9.dist-info/
 Comment: 
 
 Filename: hyperon.libs/
 Comment: 
 
 Filename: hyperon/
 Comment: 
 
-Filename: hyperonpy.pypy39-pp73-x86_64-linux-gnu.so
+Filename: hyperonpy.pypy39-pp73-x86-linux-gnu.so
 Comment: 
 
-Filename: hyperon-0.1.8.dist-info/RECORD
+Filename: hyperon-0.1.9.dist-info/RECORD
 Comment: 
 
-Filename: hyperon-0.1.8.dist-info/top_level.txt
+Filename: hyperon-0.1.9.dist-info/top_level.txt
 Comment: 
 
-Filename: hyperon-0.1.8.dist-info/WHEEL
+Filename: hyperon-0.1.9.dist-info/WHEEL
 Comment: 
 
-Filename: hyperon-0.1.8.dist-info/entry_points.txt
+Filename: hyperon-0.1.9.dist-info/entry_points.txt
 Comment: 
 
-Filename: hyperon-0.1.8.dist-info/METADATA
+Filename: hyperon-0.1.9.dist-info/METADATA
 Comment: 
 
 Filename: hyperon/exts/
 Comment: 
 
 Filename: hyperon/atoms.py
 Comment:
```

## hyperon/atoms.py

```diff
@@ -23,17 +23,17 @@
         return (isinstance(other, Atom) and
                 hp.atom_eq(self.catom, other.catom))
 
     def __repr__(self):
         """Renders a human-readable text description of the Atom."""
         return hp.atom_to_str(self.catom)
 
-    def get_type(self):
-        """Gets the type of the current Atom instance"""
-        return hp.atom_get_type(self.catom)
+    def get_metatype(self):
+        """Gets the metatype (kind) of the current Atom instance"""
+        return hp.atom_get_metatype(self.catom)
 
     def iterate(self):
         """Performs a depth-first exhaustive iteration of an Atom and all its children recursively."""
         res = hp.atom_iterate(self.catom)
         result = []
         for r in res:
             result.append(Atom._from_catom(r))
@@ -42,15 +42,15 @@
     def match_atom(self, b):
         """Matches one Atom with another, establishing bindings between them."""
         return BindingsSet(hp.atom_match_atom(self.catom, b.catom))
 
     @staticmethod
     def _from_catom(catom):
         """Constructs an Atom by wrapping a C Atom"""
-        type = hp.atom_get_type(catom)
+        type = hp.atom_get_metatype(catom)
         if type == AtomKind.SYMBOL:
             return SymbolAtom(catom)
         elif type == AtomKind.VARIABLE:
             return VariableAtom(catom)
         elif type == AtomKind.EXPR:
             return ExpressionAtom(catom)
         elif type == AtomKind.GROUNDED:
@@ -186,15 +186,15 @@
 
 def _priv_call_execute_on_grounded_atom(gnd, typ, args):
     """
     Private glue for Hyperonpy implementation.
     Executes grounded Atoms.
     """
     # ... if hp.atom_to_str(typ) == AtomType.UNDEFINED
-    res_typ = AtomType.UNDEFINED if hp.atom_get_type(typ) != AtomKind.EXPR \
+    res_typ = AtomType.UNDEFINED if hp.atom_get_metatype(typ) != AtomKind.EXPR \
         else Atom._from_catom(hp.atom_get_children(typ)[-1])
     args = [Atom._from_catom(catom) for catom in args]
     return gnd.execute(*args, res_typ=res_typ)
 
 def _priv_call_match_on_grounded_atom(gnd, catom):
     """
     Private glue for Hyperonpy implementation.
@@ -210,15 +210,15 @@
     return gnd.serialize(serializer)
 
 def _priv_compare_value_atom(gnd, catom):
     """
     Private glue for Hyperonpy implementation.
     Tests for equality between a grounded value atom and another atom
     """
-    if hp.atom_get_type(catom) == AtomKind.GROUNDED:
+    if hp.atom_get_metatype(catom) == AtomKind.GROUNDED:
         atom = GroundedAtom(catom)
         return gnd == atom.get_object()
     else:
         return False
 
 def atoms_are_equivalent(first, second):
     """Check if two atoms are equivalent"""
@@ -379,15 +379,15 @@
                         for c in ch[1:]:
                             try:
                                 kwarg = c.get_children()
                                 assert len(kwarg) == 2
                             except:
                                 raise RuntimeError(f"Incorrect kwarg format {kwarg}")
                             try:
-                                kwargs[repr(kwarg[0])] = kwarg[1].get_object().content
+                                kwargs[get_string_value(kwarg[0])] = kwarg[1].get_object().content
                             except:
                                 raise NoReduceError()
                         continue
                 try:
                     args.append(a.get_object().content)
                 except:
                     # NOTE:
@@ -701,7 +701,14 @@
     def iterator(self):
         """Returns an iterator over all Bindings frames"""
         res = hp.bindings_set_list(self.c_set)
         result = []
         for r in res:
             result.append(Bindings(r))
         return iter(result)
+
+def get_string_value(value) -> str:
+    if not isinstance(value, str):
+        value = repr(value)
+    if len(value) > 2 and ("\"" == value[0]) and ("\"" == value[-1]):
+        return value[1:-1]
+    return value
```

## hyperon/_version.py

```diff
@@ -1,4 +1,4 @@
 # file generated by setuptools_scm
 # don't change, don't track in version control
-__version__ = version = '0.1.8'
-__version_tuple__ = version_tuple = (0, 1, 8)
+__version__ = version = '0.1.9'
+__version_tuple__ = version_tuple = (0, 1, 9)
```

## hyperon/stdlib.py

```diff
@@ -1,13 +1,13 @@
 import re
 import sys
 import os
 
 from .atoms import ExpressionAtom, E, GroundedAtom, OperationAtom, ValueAtom, NoReduceError, AtomType, MatchableObject, \
-    G, S, Atoms
+    G, S, Atoms, get_string_value, GroundedObject, SymbolAtom
 from .base import Tokenizer, SExprParser
 from .ext import register_atoms, register_tokens
 import hyperonpy as hp
 
 class Char:
     """Emulate Char type as in a traditional FPL"""
     def __init__(self, char):
@@ -59,21 +59,14 @@
         r"<=": lessEqAtom,
         r">=": greaterEqAtom,
         r"or": orAtom,
         r"and": andAtom,
         r"not": notAtom
     }
 
-def get_string_value(value) -> str:
-    if not isinstance(value, str):
-        value = repr(value)
-    if len(value) > 2 and ("\"" == value[0]) and ("\"" == value[-1]):
-        return value[1:-1]
-    return value
-
 class RegexMatchableObject(MatchableObject):
     ''' To match atoms with regular expressions'''
 
     def __init__(self, content, id=None):
         super().__init__(content, id)
 
         self.content = self.content.replace("[[", "(").replace("]]", ")").replace("~", " ")
@@ -208,7 +201,56 @@
         return [Atoms.UNIT]
 
     loadAtom = OperationAtom('load-ascii', load_ascii_atom,
                              unwrap=False)
     return {
         r"load-ascii": loadAtom
     }
+
+def try_unwrap_python_object(a, is_symbol_to_str = False):
+    if isinstance(a, GroundedAtom):
+        # FIXME? Do we need to unwrap a grounded object if it is not GroundedObject?
+        return a.get_object().content if isinstance(a.get_object(), GroundedObject) else a.get_object()
+    if is_symbol_to_str and isinstance(a, SymbolAtom):
+        return a.get_name()
+    return a
+
+# convert nested tuples to nested python tuples or lists
+def _py_tuple_list(tuple_list, metta_tuple):
+    rez = []
+    for a in metta_tuple.get_children():
+        if isinstance(a, ExpressionAtom):
+            rez.append(_py_tuple_list(tuple_list, a))
+        else:
+            rez.append(try_unwrap_python_object(a))
+    return tuple_list(rez)
+
+def py_tuple(metta_tuple):
+    return [ValueAtom(_py_tuple_list(tuple, metta_tuple))]
+
+def py_list(metta_tuple):
+    return [ValueAtom(_py_tuple_list(list, metta_tuple))]
+
+def tuple_to_keyvalue(a):
+    ac = a.get_children()
+    if len(ac) != 2:
+        raise Exception("Syntax error in tuple_to_keyvalue")
+    return try_unwrap_python_object(ac[0], is_symbol_to_str = True), try_unwrap_python_object(ac[1])
+
+# convert pair of tuples to python dictionary
+def py_dict(metta_tuple):
+    return [ValueAtom(dict([tuple_to_keyvalue(a) for a in metta_tuple.get_children()]))]
+
+# chain python objects with |  (syntactic sugar for langchain)
+def py_chain(metta_tuple):
+    objects = [try_unwrap_python_object(a) for a in metta_tuple.get_children()]
+    result = objects[0]
+    for obj in objects[1:]:
+        result = result | obj
+    return [ValueAtom(result)]
+
+@register_atoms()
+def py_funs():
+    return {"py-tuple": OperationAtom("py-tuple", py_tuple, unwrap = False),
+            "py-list" : OperationAtom("py-list" , py_list , unwrap = False),
+            "py-dict" : OperationAtom("py-dict" , py_dict , unwrap = False),
+            "py-chain": OperationAtom("py-chain", py_chain, unwrap = False)}
```

## Comparing `hyperon-0.1.8.dist-info/METADATA` & `hyperon-0.1.9.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: hyperon
-Version: 0.1.8
+Version: 0.1.9
 Summary: Hyperon API in Python
 License: MIT License
 Keywords: metta,hyperon,opencog
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Development Status :: 2 - Pre-Alpha
 Classifier: Operating System :: POSIX :: Linux
```

