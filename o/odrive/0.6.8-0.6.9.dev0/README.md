# Comparing `tmp/odrive-0.6.8-py3-none-any.whl.zip` & `tmp/odrive-0.6.9.dev0-py37-none-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,52 +1,51 @@
-Zip file size: 1947530 bytes, number of entries: 50
--rw-r--r--  2.0 unx     5065 b- defN 24-Jan-11 13:05 odrive/__init__.py
--rw-r--r--  2.0 unx     2353 b- defN 24-Jan-11 13:05 odrive/api_client.py
--rw-r--r--  2.0 unx    53241 b- defN 24-Jan-11 13:05 odrive/config.py
--rw-r--r--  2.0 unx    13415 b- defN 24-Jan-11 13:05 odrive/crypto.py
--rw-r--r--  2.0 unx     6221 b- defN 24-Jan-11 13:05 odrive/database.py
--rw-r--r--  2.0 unx    19525 b- defN 24-Jan-11 13:05 odrive/dfu.py
--rw-r--r--  2.0 unx    16597 b- defN 24-Jan-11 13:05 odrive/enums.py
--rw-r--r--  2.0 unx     3489 b- defN 24-Jan-11 13:05 odrive/firmware.py
--rw-r--r--  2.0 unx     1965 b- defN 24-Jan-11 13:05 odrive/hw_version.py
--rw-r--r--  2.0 unx     3069 b- defN 24-Jan-11 13:05 odrive/legacy.py
--rw-r--r--  2.0 unx     3828 b- defN 24-Jan-11 13:05 odrive/legacy_config.py
--rw-r--r--  2.0 unx     6684 b- defN 24-Jan-11 13:05 odrive/release_api.py
--rw-r--r--  2.0 unx     4557 b- defN 24-Jan-11 13:05 odrive/rich_text.py
--rw-r--r--  2.0 unx     5362 b- defN 24-Jan-11 13:05 odrive/shell.py
--rw-r--r--  2.0 unx    36587 b- defN 24-Jan-11 13:05 odrive/utils.py
--rw-r--r--  2.0 unx       21 b- defN 24-Jan-11 13:05 odrive/version.py
--rw-r--r--  2.0 unx      308 b- defN 24-Jan-11 13:05 odrive/data/brakeRs.json
--rw-r--r--  2.0 unx     3051 b- defN 24-Jan-11 13:05 odrive/data/drvs.json
--rw-r--r--  2.0 unx     2740 b- defN 24-Jan-11 13:05 odrive/data/encoders.json
--rw-r--r--  2.0 unx     3361 b- defN 24-Jan-11 13:05 odrive/data/motors.json
--rw-r--r--  2.0 unx     1076 b- defN 24-Jan-11 13:05 odrive/data/odrive-micro-x1.json
--rw-r--r--  2.0 unx      937 b- defN 24-Jan-11 13:05 odrive/data/odrive-micro-x3.json
--rw-r--r--  2.0 unx     1150 b- defN 24-Jan-11 13:05 odrive/data/odrive-s1-x4.json
--rw-r--r--  2.0 unx     1336 b- defN 24-Jan-11 13:05 odrive/data/odrive-v4.4.json
--rw-r--r--  2.0 unx      141 b- defN 24-Jan-11 13:05 odrive/data/schema-brakeR.json
--rw-r--r--  2.0 unx      138 b- defN 24-Jan-11 13:05 odrive/data/schema-drv.json
--rw-r--r--  2.0 unx      142 b- defN 24-Jan-11 13:05 odrive/data/schema-encoders.json
--rw-r--r--  2.0 unx      140 b- defN 24-Jan-11 13:05 odrive/data/schema-motors.json
--rw-r--r--  2.0 unx       93 b- defN 24-Jan-11 13:05 odrive/data/schema-odrive.json
--rw-r--r--  2.0 unx     9044 b- defN 24-Jan-11 13:05 odrive/data/schema.json
--rw-r--r--  2.0 unx    10136 b- defN 24-Jan-11 13:05 odrive/dfuse/DfuDevice.py
--rw-r--r--  2.0 unx       54 b- defN 24-Jan-11 13:05 odrive/dfuse/__init__.py
--rw-r--r--  2.0 unx      105 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/__init__.py
--rwxr-xr-x  2.0 unx   712336 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libfibre-linux-aarch64.so
--rwxr-xr-x  2.0 unx   757096 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libfibre-linux-amd64.so
--rwxr-xr-x  2.0 unx   783708 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libfibre-linux-armhf.so
--rwxr-xr-x  2.0 unx  1703365 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libfibre-macos-arm.dylib
--rw-r--r--  2.0 unx   686544 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libfibre-macos-x86.dylib
--rwxr-xr-x  2.0 unx  1235470 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libfibre-windows-amd64.dll
--rw-r--r--  2.0 unx    40071 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libfibre.py
--rwxr-xr-x  2.0 unx    61576 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/libwinpthread-1.dll
--rw-r--r--  2.0 unx     6356 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/shell.py
--rw-r--r--  2.0 unx     4788 b- defN 24-Jan-11 13:05 odrive/pyfibre/fibre/utils.py
--rwxr-xr-x  2.0 unx     1570 b- defN 24-Jan-11 13:05 odrive-0.6.8.data/scripts/odrive_demo.py
--rwxr-xr-x  2.0 unx    11457 b- defN 24-Jan-11 13:05 odrive-0.6.8.data/scripts/odrivetool
--rwxr-xr-x  2.0 unx       43 b- defN 24-Jan-11 13:05 odrive-0.6.8.data/scripts/odrivetool.bat
--rw-r--r--  2.0 unx      598 b- defN 24-Jan-11 13:05 odrive-0.6.8.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Jan-11 13:05 odrive-0.6.8.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 24-Jan-11 13:05 odrive-0.6.8.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     4186 b- defN 24-Jan-11 13:05 odrive-0.6.8.dist-info/RECORD
-50 files, 6225194 bytes uncompressed, 1940932 bytes compressed:  68.8%
+Zip file size: 1374154 bytes, number of entries: 49
+-rw-r--r--  2.0 unx     5119 b- defN 24-May-07 17:17 odrive/__init__.py
+-rw-r--r--  2.0 unx     2353 b- defN 24-May-07 17:17 odrive/api_client.py
+-rw-r--r--  2.0 unx    53265 b- defN 24-May-07 17:17 odrive/config.py
+-rw-r--r--  2.0 unx    13415 b- defN 24-May-07 17:17 odrive/crypto.py
+-rw-r--r--  2.0 unx     6272 b- defN 24-May-07 17:17 odrive/database.py
+-rw-r--r--  2.0 unx     8502 b- defN 24-May-07 17:17 odrive/dfu.py
+-rw-r--r--  2.0 unx    16597 b- defN 24-May-07 17:17 odrive/enums.py
+-rw-r--r--  2.0 unx     3489 b- defN 24-May-07 17:17 odrive/firmware.py
+-rw-r--r--  2.0 unx     2026 b- defN 24-May-07 17:17 odrive/hw_version.py
+-rw-r--r--  2.0 unx     3069 b- defN 24-May-07 17:17 odrive/legacy.py
+-rw-r--r--  2.0 unx     3857 b- defN 24-May-07 17:17 odrive/legacy_config.py
+-rw-r--r--  2.0 unx    18908 b- defN 24-May-07 17:17 odrive/legacy_dfu.py
+-rw-r--r--  2.0 unx    13903 b- defN 24-May-07 17:17 odrive/libodrive.py
+-rw-r--r--  2.0 unx     7049 b- defN 24-May-07 17:17 odrive/release_api.py
+-rw-r--r--  2.0 unx     4557 b- defN 24-May-07 17:17 odrive/rich_text.py
+-rw-r--r--  2.0 unx     5514 b- defN 24-May-07 17:17 odrive/shell.py
+-rw-r--r--  2.0 unx    36587 b- defN 24-May-07 17:17 odrive/utils.py
+-rw-r--r--  2.0 unx       26 b- defN 24-May-07 17:17 odrive/version.py
+-rw-r--r--  2.0 unx      308 b- defN 24-May-07 17:17 odrive/data/brakeRs.json
+-rw-r--r--  2.0 unx     3051 b- defN 24-May-07 17:17 odrive/data/drvs.json
+-rw-r--r--  2.0 unx     2740 b- defN 24-May-07 17:17 odrive/data/encoders.json
+-rw-r--r--  2.0 unx     3681 b- defN 24-May-07 17:17 odrive/data/motors.json
+-rw-r--r--  2.0 unx     1076 b- defN 24-May-07 17:17 odrive/data/odrive-micro-x1.json
+-rw-r--r--  2.0 unx      888 b- defN 24-May-07 17:17 odrive/data/odrive-micro-x3.json
+-rw-r--r--  2.0 unx      888 b- defN 24-May-07 17:17 odrive/data/odrive-micro-x4.json
+-rw-r--r--  2.0 unx     1150 b- defN 24-May-07 17:17 odrive/data/odrive-s1-x4.json
+-rw-r--r--  2.0 unx     1336 b- defN 24-May-07 17:17 odrive/data/odrive-v4.4.json
+-rw-r--r--  2.0 unx      141 b- defN 24-May-07 17:17 odrive/data/schema-brakeR.json
+-rw-r--r--  2.0 unx      138 b- defN 24-May-07 17:17 odrive/data/schema-drv.json
+-rw-r--r--  2.0 unx      142 b- defN 24-May-07 17:17 odrive/data/schema-encoders.json
+-rw-r--r--  2.0 unx      140 b- defN 24-May-07 17:17 odrive/data/schema-motors.json
+-rw-r--r--  2.0 unx       93 b- defN 24-May-07 17:17 odrive/data/schema-odrive.json
+-rw-r--r--  2.0 unx     9044 b- defN 24-May-07 17:17 odrive/data/schema.json
+-rw-r--r--  2.0 unx    10136 b- defN 24-May-07 17:17 odrive/dfuse/DfuDevice.py
+-rw-r--r--  2.0 unx       54 b- defN 24-May-07 17:17 odrive/dfuse/__init__.py
+-rw-r--r--  2.0 unx  3514636 b- defN 24-May-07 17:17 odrive/lib/libodrive-windows-x64.dll
+-rw-r--r--  2.0 unx      105 b- defN 24-May-07 17:17 odrive/pyfibre/fibre/__init__.py
+-rwxr-xr-x  2.0 unx  1235470 b- defN 24-May-07 17:17 odrive/pyfibre/fibre/libfibre-windows-amd64.dll
+-rw-r--r--  2.0 unx    40071 b- defN 24-May-07 17:17 odrive/pyfibre/fibre/libfibre.py
+-rwxr-xr-x  2.0 unx    61576 b- defN 24-May-07 17:17 odrive/pyfibre/fibre/libwinpthread-1.dll
+-rw-r--r--  2.0 unx     6356 b- defN 24-May-07 17:17 odrive/pyfibre/fibre/shell.py
+-rw-r--r--  2.0 unx     4788 b- defN 24-May-07 17:17 odrive/pyfibre/fibre/utils.py
+-rwxr-xr-x  2.0 unx     1570 b- defN 24-May-07 17:17 odrive-0.6.9.dev0.data/scripts/odrive_demo.py
+-rwxr-xr-x  2.0 unx    12586 b- defN 24-May-07 17:17 odrive-0.6.9.dev0.data/scripts/odrivetool
+-rwxr-xr-x  2.0 unx       43 b- defN 24-May-07 17:17 odrive-0.6.9.dev0.data/scripts/odrivetool.bat
+-rw-r--r--  2.0 unx      603 b- defN 24-May-07 17:17 odrive-0.6.9.dev0.dist-info/METADATA
+-rw-r--r--  2.0 unx       99 b- defN 24-May-07 17:17 odrive-0.6.9.dev0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 24-May-07 17:17 odrive-0.6.9.dev0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     4039 b- defN 24-May-07 17:17 odrive-0.6.9.dev0.dist-info/RECORD
+49 files, 5121463 bytes uncompressed, 1367796 bytes compressed:  73.3%
```

## zipnote {}

```diff
@@ -27,14 +27,20 @@
 
 Filename: odrive/legacy.py
 Comment: 
 
 Filename: odrive/legacy_config.py
 Comment: 
 
+Filename: odrive/legacy_dfu.py
+Comment: 
+
+Filename: odrive/libodrive.py
+Comment: 
+
 Filename: odrive/release_api.py
 Comment: 
 
 Filename: odrive/rich_text.py
 Comment: 
 
 Filename: odrive/shell.py
@@ -60,14 +66,17 @@
 
 Filename: odrive/data/odrive-micro-x1.json
 Comment: 
 
 Filename: odrive/data/odrive-micro-x3.json
 Comment: 
 
+Filename: odrive/data/odrive-micro-x4.json
+Comment: 
+
 Filename: odrive/data/odrive-s1-x4.json
 Comment: 
 
 Filename: odrive/data/odrive-v4.4.json
 Comment: 
 
 Filename: odrive/data/schema-brakeR.json
@@ -90,30 +99,18 @@
 
 Filename: odrive/dfuse/DfuDevice.py
 Comment: 
 
 Filename: odrive/dfuse/__init__.py
 Comment: 
 
-Filename: odrive/pyfibre/fibre/__init__.py
-Comment: 
-
-Filename: odrive/pyfibre/fibre/libfibre-linux-aarch64.so
-Comment: 
-
-Filename: odrive/pyfibre/fibre/libfibre-linux-amd64.so
-Comment: 
-
-Filename: odrive/pyfibre/fibre/libfibre-linux-armhf.so
-Comment: 
-
-Filename: odrive/pyfibre/fibre/libfibre-macos-arm.dylib
+Filename: odrive/lib/libodrive-windows-x64.dll
 Comment: 
 
-Filename: odrive/pyfibre/fibre/libfibre-macos-x86.dylib
+Filename: odrive/pyfibre/fibre/__init__.py
 Comment: 
 
 Filename: odrive/pyfibre/fibre/libfibre-windows-amd64.dll
 Comment: 
 
 Filename: odrive/pyfibre/fibre/libfibre.py
 Comment: 
@@ -123,29 +120,29 @@
 
 Filename: odrive/pyfibre/fibre/shell.py
 Comment: 
 
 Filename: odrive/pyfibre/fibre/utils.py
 Comment: 
 
-Filename: odrive-0.6.8.data/scripts/odrive_demo.py
+Filename: odrive-0.6.9.dev0.data/scripts/odrive_demo.py
 Comment: 
 
-Filename: odrive-0.6.8.data/scripts/odrivetool
+Filename: odrive-0.6.9.dev0.data/scripts/odrivetool
 Comment: 
 
-Filename: odrive-0.6.8.data/scripts/odrivetool.bat
+Filename: odrive-0.6.9.dev0.data/scripts/odrivetool.bat
 Comment: 
 
-Filename: odrive-0.6.8.dist-info/METADATA
+Filename: odrive-0.6.9.dev0.dist-info/METADATA
 Comment: 
 
-Filename: odrive-0.6.8.dist-info/WHEEL
+Filename: odrive-0.6.9.dev0.dist-info/WHEEL
 Comment: 
 
-Filename: odrive-0.6.8.dist-info/top_level.txt
+Filename: odrive-0.6.9.dev0.dist-info/top_level.txt
 Comment: 
 
-Filename: odrive-0.6.8.dist-info/RECORD
+Filename: odrive-0.6.9.dev0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odrive/__init__.py

```diff
@@ -6,14 +6,15 @@
 # in order to avoid any version mismatch issues,
 sys.path.insert(0, os.path.join(os.path.dirname(os.path.realpath(__file__)), "pyfibre"))
 
 import asyncio
 import concurrent
 import threading
 import time
+from typing import Optional
 
 from .version import __version__
 from .utils import get_serial_number_str, get_serial_number_str_sync, attach_metadata
 
 # Backwards compatibility with Python 3.6 (default on Ubuntu 18.04)
 if sys.version_info < (3, 7):
     asyncio.get_running_loop = asyncio.get_event_loop
@@ -125,17 +126,17 @@
         
         if (not cancellation_token is None) and (cancellation_token in wait_result.done):
             raise concurrent.futures.CancelledError()
         elif (not signal in wait_result.done):
             raise TimeoutError()
 
 
-async def find_any_async(path: str = default_search_path, serial_number: str = None):
+async def find_any_async(path: str = default_search_path, serial_number: Optional[str] = None):
     start_discovery(path)
 
     while True:
         signal = connected_devices_changed
         with _discovery_lock:
             for obj in connected_devices:
                 if serial_number is None or obj._serial_number == serial_number:
                     return obj
-        await asyncio.wrap_future(signal)
+        await asyncio.shield(asyncio.wrap_future(signal))
```

## odrive/config.py

```diff
@@ -1287,10 +1287,10 @@
     while AxisState(axis.requested_state) == state:
         time.sleep(0.1)
     while ProcedureResult(axis.procedure_result) == ProcedureResult.BUSY:
         time.sleep(0.1)
 
     result = ProcedureResult(axis.procedure_result)
     if result == ProcedureResult.DISARMED:
-        raise Exception("Device failed with {}".format(ODriveError(axis.disarm_reason).name))
+        raise Exception("Device failed with {}".format(repr(ODriveError(axis.disarm_reason))))
     elif result != ProcedureResult.SUCCESS:
-        raise Exception("Device returned {}".format(result))
+        raise Exception("Device returned {}".format(repr(ProcedureResult(result))))
```

## odrive/database.py

```diff
@@ -163,14 +163,15 @@
             'ODrive Pro v4.3-58V': HwVersion(4, 3, 58),
             'ODrive Pro v4.4-58V': HwVersion(4, 4, 58),
             'ODrive S1 X1': HwVersion(5, 0, 0),
             'ODrive S1 X3': HwVersion(5, 1, 0),
             'ODrive S1 X4': HwVersion(5, 2, 0),
             'ODrive Micro X1': HwVersion(6, 0, 0),
             'ODrive Micro X3': HwVersion(6, 1, 0),
+            'ODrive Micro X4': HwVersion(6, 2, 0),
         }[k]: v
         for k, v in data['odrives'].items()
     }
 
     # Postprocessing: include inherited properties for each encoder
     for key, encoder in list(data['encoders'].items()):
         while 'inherits' in encoder:
```

## odrive/dfu.py

```diff
@@ -1,461 +1,195 @@
-#!/usr/bin/env python
-"""
-Tool for flashing .hex files to the ODrive via the STM built-in USB DFU mode.
-"""
-
 import aiohttp
 import asyncio
-import concurrent
-import sys
-import time
-import threading
-from typing import Iterator, List, Tuple, Optional
-import platform
-import struct
-import re
-import io
 import os
-import usb.core
+from typing import Optional
+
 import fibre
 import odrive
-import odrive.legacy_config
 import odrive.firmware
-from odrive.utils import OperationAbortedException
-from odrive.dfuse import *
-from odrive.hw_version import HwVersion
-import odrive.release_api as release_api
 from odrive.release_api import VersionRelationship, format_version
-
+from .hw_version import HwVersion
+from .libodrive import Interface, LibODrive, Device, Firmware
 
 class DfuError(Exception):
     pass
 
-class ODriveInDfuMode(DfuDevice):
-    def __init__(self, usbdev):
-        DfuDevice.__init__(self, usbdev)
-        self.board = None
-        self._initialized = False
-
-    def init(self, logger, ask):
-        if self._initialized:
-            return
-        self._initialized = True
-        DfuDevice.init(self)
-
-        is_odrive3 = ('OTP Memory' in self.memories) and (self.memories['OTP Memory']['sectors'][0]['addr'] == 0x1fff7800)
-        if is_odrive3:
-            otp_sectors = self.memories['OTP Memory']['sectors']
-        else:
-            otp_sectors = None
-
-        if logger._verbose and is_odrive3:
-            logger.debug("OTP:")
-
-            self.select_memory('OTP Memory')
-            self.clear_status()
-
-            # 512 Byte OTP
-            otp_sector = [s for s in otp_sectors if s['addr'] == 0x1fff7800][0]
-            data = self.read_sector(otp_sector)
-            logger.debug(' '.join('{:02X}'.format(x) for x in data))
-
-            # 16 lock bytes
-            otp_lock_sector = [s for s in otp_sectors if s['addr'] == 0x1fff7A00][0]
-            data = self.read_sector(otp_lock_sector)
-            logger.debug(' '.join('{:02X}'.format(x) for x in data))
-
-        if is_odrive3:
-            # Reads the hardware version from one-time-programmable memory.
-            # This is written on all ODrives sold since Summer 2018.
-            otp_sectors = self.memories['OTP Memory']['sectors']
-            otp_sector = [s for s in otp_sectors if s['addr'] == 0x1fff7800][0]
-            self.select_memory('OTP Memory')
-            self.clear_status()
-            otp_data = self.read_sector(otp_sector)
-            if otp_data[0] == 0:
-                otp_data = otp_data[16:]
-            if otp_data[0] == 0xfe:
-                self.board = HwVersion(otp_data[3], otp_data[4], otp_data[5])
-            else:
-                self.board = HwVersion(3, 0, 0)
-        else:
-            if ask:
-                guess = HwVersion(4, 4, 58) if 'OTP Memory' in self.memories else HwVersion(5, 2, 0)
-                if not odrive.utils.yes_no_prompt(f'Hardware version detection not yet supported for this ODrive. Is this an {guess.display_name}?', False):
-                    raise DfuError("Could not determine hardware version.")
-                self.board = guess
-            else:
-                self.board = None
-
-
-class DfuDeviceDiscovery():
-    def __init__(self):
-        self._executor = None
-        self._usb_lock = threading.Lock()
-
-    def _get_devices(self):
-        # Note that this function can interfere with DFU if run at the same time
-        with self._usb_lock:
-            all_devices = {}
-            for dev in usb.core.find(idVendor=0x0483, idProduct=0xdf11, find_all=True):
-                try:
-                    serial_number = dev.serial_number
-                except ValueError:
-                    print("found device but could not check serial number (retrying in 1s)")
-                    continue
-                all_devices[serial_number] = ODriveInDfuMode(dev)
-        return all_devices
-
-    async def __aenter__(self):
-        self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=1).__enter__()
-        return self
-
-    async def __aexit__(self, exc_type, exc_val, exc_tb):
-        self._executor.__exit__(exc_type, exc_val, exc_tb)
-
-    async def discover(self, serial_number: str):
-        while True:
-            devices = await asyncio.get_running_loop().run_in_executor(self._executor, self._get_devices)
-
-            if serial_number is None and len(devices) > 0:
-                return next(iter(devices.values()))
-            if (not serial_number is None) and (serial_number in devices):
-                return devices[serial_number]
-
-            await asyncio.sleep(1)
-
-
-async def enter_dfu_mode(device, dfu_discoverer: DfuDeviceDiscovery) -> ODriveInDfuMode:
+async def enter_dfu_mode(device, discoverer: Interface) -> Device:
     """
-    Puts the specified device into DFU mode.
+    Puts the specified device into (new) DFU mode.
     """
-    if not hasattr(device, "enter_dfu_mode"):
-        raise Exception(
-            "The firmware on device {:08X} cannot soft enter DFU mode.\n"
-            "Please remove power, put the DFU switch into DFU mode,\n"
-            "then apply power again. Then try again.\n"
-            "If it still doesn't work, you can try to use the DeFuse app or \n"
-            "dfu-util, see the odrive documentation.\n"
-            "You can also flash the firmware using STLink (`make flash`)"
-            .format(device.serial_number)
-        )
-
     serial_number = "{:08X}".format(device.serial_number)
     print("Putting device {:08X} into DFU mode...".format(device.serial_number))
     try:
-        device.enter_dfu_mode()
+        result = device.enter_dfu_mode2()
     except fibre.ObjectLostError:
-        pass # this is expected because the device reboots
-
-    dfu_device = dfu_discoverer.discover(serial_number)
-
-    if platform.system() == "Windows":
-        async with _show_deferred_message(10, "Still waiting for the device to reappear.\n" "Use the Zadig utility to set the driver of 'STM32 BOOTLOADER' to libusb-win32."):
-            return await dfu_device
-    else:
-        return await dfu_device
-
+        result = True # this is expected because the device reboots
+    if not result:
+        raise DfuError("Failed to enter DFU mode.")
+
+    device = await discoverer.wait_for(serial_number, is_bootloader=True)
+    await device.connect_bootloader()
+    return device
+
+async def write_firmware(device: Device, fw: Firmware, erase_all: bool):
+    def print_progress(new_action_group: bool, action_string: str, action_index: int, n_actions: int):
+        if new_action_group and action_index != 0:
+            print()
+        print(f"DFU: {action_string}    ", end='\r')
+    try:
+        await device.run_installation(fw, erase_all, print_progress)
+    finally:
+        print()
 
-async def write_firmware(device, firmware: odrive.firmware.FirmwareFile, dfu_discoverer: DfuDeviceDiscovery, erase_all: bool, logger):
+async def await_first(tasks):
     """
-    Puts the device into DFU mode (if it's not already in DFU mode), writes
-    the specified firmware file and then takes the device out of DFU mode.
-
-    erase_all: If True, the entire flash memory is erased, including NVM.
-               If False, only sectors that are overwritten is erased.
+    Awaits the first of several tasks or futures and cancels the others.
     """
-    
-    if not isinstance(device, ODriveInDfuMode):
-        device = await enter_dfu_mode(device, dfu_discoverer)
-
-    device.init(logger, ask=False)
-    if device.board == HwVersion(3, 0, 0):
-        # Jump to application
-        device.jump_to_application(0x08000000)
-        raise DfuError(
-            "Could not determine hardware version. Flashing precompiled "
-             "firmware could lead to unexpected results. Please use an "
-             "STLink/2 to force-update the firmware anyway. Refer to "
-             "https://docs.odriverobotics.com/developer-guide for details.")
-
-    logger.debug("Memories on device: ")
-    for k, mem in device.memories.items():
-        logger.debug("{} sectors:".format(k))
-        for sector in mem['sectors']:
-            logger.debug(" {:08X} to {:08X}".format(
-                sector['addr'],
-                sector['addr'] + sector['len'] - 1))
-
-    # fill sectors with data
-    sections = list(firmware.get_flash_sections())
-    for name, addr, content in sections:
-        logger.debug(f"loading section {name} to 0x{addr:08x} ... 0x{(addr+len(content)):08x}")
-
-    touched_sectors = list(_populate_sectors(device.memories['Internal Flash']['sectors'], sections))
-    logger.debug("The following sectors will be flashed: ")
-    for sector,_ in touched_sectors:
-        logger.debug(" {:08X} to {:08X}".format(sector['addr'], sector['addr'] + sector['len'] - 1))
+    # TODO: is there any standard way to do this in one line?
+    done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
+    for t in pending:
+        t.cancel()
+    for t in pending:
+        try:
+            await t
+        except asyncio.CancelledError:
+            pass
+    return (await asyncio.gather(*done))[0]
+
+async def get_firmware(board: HwVersion, current_build_id_short: Optional[str], channel: Optional[str], version: Optional[str], logger, interactive: bool, release_type: str = 'firmware'):
+    async with aiohttp.ClientSession() as session:
+        if channel:
+            logger.info(f"Checking online for latest {board.display_name} {release_type} on channel {channel}...")
+        else:
+            logger.info(f"Checking online for {board.display_name} {release_type} version {format_version(version)}...")
+        api_client = odrive.api_client.ApiClient(session)
+        release_api = odrive.release_api.ReleaseApi(api_client)
+
+        firmware_index = await release_api.get_index(release_type)
+
+        # If we're fetching normal firmware, use whatever file the release
+        # server returns as preferred file URL.
+        # If we're fetching the bootloader, need to select between multiple
+        # files on the release server.
+        file = 'bootloader_installer.elf' if release_type == 'bootloader' else None
+
+        try:
+            if channel:
+                manifest = firmware_index.get_latest(channel, app='default', board=board, file=file)
+            else:
+                manifest = firmware_index.get_version(version, app='default', board=board, file=file)
+        except odrive.release_api.ChannelNotFoundError as ex:
+            raise DfuError(ex)
+        except odrive.release_api.FirmwareNotFoundError:
+            raise DfuError(f"No {release_type} found matching the specified criteria.")
+
+        if interactive:
+            version_relationship = firmware_index.compare(current_build_id_short, manifest['commit_hash'], channel, app='default', board=board)
+            prompt = {
+                VersionRelationship.UNKNOWN: "Found compatible firmware ({to_version}). Install now?",
+                VersionRelationship.EQUAL: "Your current firmware ({to_version}) is up to date. Do you want to reinstall this version?",
+                VersionRelationship.UPGRADE: "Found new firmware ({from_hash} => {to_version}). Install now?",
+                VersionRelationship.DOWNGRADE: "Found older firmware ({from_hash} => {to_version}). Install now?",
+            }[version_relationship]
+        
+            if not odrive.utils.yes_no_prompt(prompt.format(from_hash=current_build_id_short, to_version=format_version(manifest['commit_hash'])), True):
+                raise odrive.utils.OperationAbortedException()
 
-    device.select_memory('Internal Flash')
-    device.clear_status()
+        logger.info(f"Downloading {release_type}...")
+        return odrive.firmware.FirmwareFile.from_file(await release_api.load(manifest))
 
-    # Erase
-    try:
-        internal_flash_sectors = device.memories['Internal Flash']['sectors']
-        if erase_all:
-            erase_sectors = internal_flash_sectors
-        else:
-            erase_sectors = [s for s, d in touched_sectors]
-        for i, sector in enumerate(erase_sectors):
-            print("Erasing... (sector {}/{})  \r".format(i, len(erase_sectors)), end='', flush=True)
-            device.erase_sector(sector)
-        print('Erasing... done            \r', end='', flush=True)
-    finally:
-        print('', flush=True)
+async def run_dfu(libodrive: LibODrive, dfu_discoverer: Interface, serial_number: Optional[str], path: Optional[str], channel: Optional[str], version: Optional[str], erase_all: bool, logger, interactive: bool = True):
+    """
+    See dfu_ui for description.
+    """
+    assert sum([bool(path), bool(channel), bool(version)]) == 1
 
-    # Flash
-    try:
-        for i, (sector, data) in enumerate(touched_sectors):
-            print("Flashing... (sector {}/{})  \r".format(i, len(touched_sectors)), end='', flush=True)
-            device.write_sector(sector, data)
-        print('Flashing... done            \r', end='', flush=True)
-    finally:
-        print('', flush=True)
+    logger.info("Waiting for ODrive...")
 
-    # Verify
-    try:
-        for i, (sector, expected_data) in enumerate(touched_sectors):
-            print("Verifying... (sector {}/{})  \r".format(i, len(touched_sectors)), end='', flush=True)
-            observed_data = device.read_sector(sector)
-            mismatch_pos = _get_first_mismatch_index(observed_data, expected_data)
-            if not mismatch_pos is None:
-                mismatch_pos -= mismatch_pos % 16
-                observed_snippet = ' '.join('{:02X}'.format(x) for x in observed_data[mismatch_pos:mismatch_pos+16])
-                expected_snippet = ' '.join('{:02X}'.format(x) for x in expected_data[mismatch_pos:mismatch_pos+16])
-                raise RuntimeError("Verification failed around address 0x{:08X}:\n".format(sector['addr'] + mismatch_pos) +
-                                   "  expected: " + expected_snippet + "\n"
-                                   "  observed: " + observed_snippet)
-        print('Verifying... done            \r', end='', flush=True)
-    finally:
-        print('', flush=True)
+    # Wait for device either in DFU mode or in normal mode, whichever is
+    # found first.
+    device = await await_first([
+        asyncio.create_task(odrive.find_any_async(serial_number=serial_number)),
+        asyncio.create_task(dfu_discoverer.wait_for(serial_number=serial_number, is_bootloader=True))
+    ])
+
+    found_in_dfu = isinstance(device, Device)
+
+    if not found_in_dfu:
+        bootloader_version = device.bootloader_version if hasattr(device, "bootloader_version") else 0
+        if bootloader_version == 0:
+            raise DfuError(
+                "New DFU system not installed on device {:08X}.\n"
+                "Please follow instructions for one-time setup here:\n"
+                "https://docs.odriverobotics.com/v/latest/guides/new-dfu.html\n"
+                "or use the legacy DFU system (odrivetool legacy-dfu)."
+                .format(device.serial_number)
+            )
 
-    # Jump to application
-    device.jump_to_application(0x08000000)
+        # Note: we don't do ahead of time compatibility check until the
+        # bootloader version has stabilized. Just-in-time checking is
+        # handled in libodrive (when bootloader is already started).
+
+    if found_in_dfu:
+        await device.connect_bootloader()
+
+    if path:
+        assert os.path.isfile(path)
+        assert channel is None
+        file = odrive.firmware.FirmwareFile.from_file(path)
+    else:
+        board: HwVersion = device.hw_version if isinstance(device, Device) else device._board
+        build_id_short: Optional[str] = "{:08x}".format(device.commit_hash) if hasattr(device, 'commit_hash') else None
+        file = await get_firmware(board, build_id_short, channel, version, logger, interactive)
 
+    with libodrive.open_firmware(file.as_buffer()) as firmware:
+        print("loaded firmware: ")
+        print("  Version: " + str(".".join(str(n) for n in firmware.fw_version)))
+        print("  Build ID: " + "".join(f"{b:02x}" for b in firmware.build))
+        print("  Hardware: " + firmware.hw_version.display_name)
 
-def unlock_device(serial_number, cancellation_token):
-    # TODO: this function is outdated
-    
-    print("Looking for ODrive in DFU mode...")
-    print("If the program hangs at this point, try to set the DFU switch to \"DFU\" and power cycle the ODrive.")
+        if not isinstance(device, Device):
+            device = await enter_dfu_mode(device, dfu_discoverer)
 
-    stm_device = find_device_in_dfu_mode(serial_number, cancellation_token)
-    dfudev = DfuDevice(stm_device)
+        assert device.is_bootloader
+        await write_firmware(device, firmware, erase_all)
 
-    print("Unlocking device (this may take a few seconds)...")
-    dfudev.unprotect()
-    print("done")
-    print("")
-    print("Now do the following:")
-    print(" 1. Put the DFU switch on the ODrive to \"DFU\"")
-    print(" 2. Power-cycle the ODrive")
-    print(" 3. Run \"odrivetool dfu\" (or any third party DFU tool)")
-    print(" 4. Put the DFU switch on the ODrive to \"RUN\"")
+    logger.info("Waiting for the device to reappear...")
+    device = await odrive.find_any_async(odrive.default_usb_search_path, serial_number)
+    logger.success("Device firmware update successful.")
 
 
-async def launch_dfu(serial_number: str, path: Optional[str], channel: Optional[str], version: Optional[str], erase_all: bool, logger, force: bool = False):
+async def dfu_ui(serial_number: Optional[str], path: Optional[str], channel: Optional[str], version: Optional[str], erase_all: bool, logger, interactive: bool = True):
     """
     Runs the complete interactive DFU process:
 
     1. Wait for device in either DFU mode or normal mode. If `serial_number` is
        None, the first discovered device is selected, otherwise only the
        specified device is accepted.
 
-    2. If `path` is None, check for the latest firmware, present it to the user
-       and ask whether to continue. Otherwise don't ask and always continue.
+    2. If `path` is None, check for the latest or specified firmware, present it
+       to the user and ask whether to continue. Otherwise don't ask and always
+       continue.
 
     3. If the device is in normal mode, put it into DFU mode.
 
-    4. Write flash memory.
+    4. Erase, write and verify flash memory.
 
     5. Exit DFU mode.
 
+    Parameters
+    ----------
     path: Path to a .elf path or None to check online.
     channel: Channel on which to check for firmware (master, devel, ...)
     version: Exact firmware version
     """
+    libodrive = LibODrive(loop=asyncio.get_running_loop())
 
-    assert sum([bool(path), bool(channel), bool(version)]) == 1
-
-    async with DfuDeviceDiscovery() as dfu_discoverer:
-        logger.info("Waiting for ODrive...")
-
-        # Wait for device either in DFU mode or in normal mode, whichever is
-        # found first.
-        done, pending = await asyncio.wait([
-            asyncio.create_task(odrive.find_any_async(serial_number=serial_number)),
-            asyncio.create_task(dfu_discoverer.discover(serial_number=serial_number))
-        ], return_when=asyncio.FIRST_COMPLETED)
-        for t in pending:
-            t.cancel()
-            try:
-                await t
-            except asyncio.CancelledError:
-                pass
-        device = (await asyncio.gather(*done))[0]
-
-        found_in_dfu = isinstance(device, ODriveInDfuMode)
-
-        if not found_in_dfu:
-            current_fw_version = (
-                (device.fw_version_major, device.fw_version_minor, device.fw_version_revision)
-                if hasattr(device, "fw_version_major") and hasattr(device, "fw_version_minor") and hasattr(device, "fw_version_revision")
-                else (0, 0, 0)
-            )
-
-            hw_version_major = device.hw_version_major if hasattr(device, "hw_version_major") else 0
-
-            buggy_firmwares = {(0, 6, 5), (0, 6, 6)}
-
-            if hw_version_major == 0 or current_fw_version == (0, 0, 0) or (hw_version_major == 4 and (current_fw_version in buggy_firmwares)):
-                raise DfuError(
-                    "The firmware on device {:08X} does not support starting a firmware update from\n"
-                    "RUN mode. Please remove power, put the DFU switch into DFU mode, then apply power\n"
-                    "again. Then try again.\n"
-                    "Refer to https://docs.odriverobotics.com/v/latest/guides/firmware-update.html for details."
-                    .format(device.serial_number)
-                )
-
-        if path:
-            assert os.path.isfile(path)
-            assert channel is None
-            file = odrive.firmware.FirmwareFile.from_file(path)
-        else:
-            if isinstance(device, ODriveInDfuMode):
-                device.init(logger, ask=True)
-                board = device.board
-            else:
-                board = device._board
-
-            async with aiohttp.ClientSession() as session:
-                if channel:
-                    logger.info(f"Checking online for latest {board.display_name} firmware on channel {channel}...")
-                else:
-                    logger.info(f"Checking online for {board.display_name} firmware version {format_version(version)}...")
-                api_client = odrive.api_client.ApiClient(session)
-                release_api = odrive.release_api.ReleaseApi(api_client)
-
-                firmware_index = await release_api.get_index('firmware')
-
-                try:
-                    if channel:
-                        manifest = firmware_index.get_latest(channel, app='default', board=board)
-                    else:
-                        manifest = firmware_index.get_version(version, app='default', board=board)
-                except odrive.release_api.ChannelNotFoundError as ex:
-                    raise DfuError(ex)
-                except odrive.release_api.FirmwareNotFoundError:
-                    raise DfuError(f"No firmware found matching the specified criteria.")
-
-                if hasattr(device, 'commit_hash'):
-                    device_commit = "{:08x}".format(device.commit_hash)
-                else:
-                    device_commit = None
-                
-                if not force:
-                    version_relationship = firmware_index.compare(device_commit, manifest['commit_hash'], channel, app='default', board=board)
-                    prompt = {
-                        VersionRelationship.UNKNOWN: "Found compatible firmware ({to_version}). Install now?",
-                        VersionRelationship.EQUAL: "Your current firmware ({to_version}) is up to date. Do you want to reinstall this version?",
-                        VersionRelationship.UPGRADE: "Found new firmware ({from_hash} => {to_version}). Install now?",
-                        VersionRelationship.DOWNGRADE: "Found older firmware ({from_hash} => {to_version}). Install now?",
-                    }[version_relationship]
-                
-                    if not odrive.utils.yes_no_prompt(prompt.format(from_hash=device_commit, to_version=format_version(manifest['commit_hash'])), True):
-                        raise odrive.utils.OperationAbortedException()
-
-                logger.info("Downloading firmware...")
-                file = odrive.firmware.FirmwareFile.from_file(await release_api.load(manifest))
-
-        may_have_config = found_in_dfu or (hasattr(device, 'user_config_loaded') and device.user_config_loaded)
-        if may_have_config and not force:
-            if not odrive.utils.yes_no_prompt("The device may have user configuration that will be lost after the firmware upgrade. If you want to back this up please run `odrivetool backup-config` first. Do you want to continue anyway?", True):
-                return
-
-        await write_firmware(device, file, dfu_discoverer, erase_all, logger)
-
-        if not found_in_dfu:
-            logger.info("Waiting for the device to reappear...")
-            device = await odrive.find_any_async(odrive.default_usb_search_path, serial_number)
-            logger.success("Device firmware update successful.")
-        else:
-            logger.success("Firmware upload successful.")
-            logger.info("To complete the firmware update, set the DFU switch to \"RUN\" and power cycle the board.")
-
-
-def _populate_sectors(sectors, sections: List[Tuple[int, bytes]]):
-    """
-    Checks for which on-device sectors there is data in the hex file and
-    returns a (sector, data) tuple for each touched sector where data
-    is a byte array of the same size as the sector.
-    """
-    for sector in sectors:
-        sector_addr = sector['addr']
-        sector_content = bytes([0xff]) * sector['len']
-
-        # check if any segment from the hexfile overlaps with this sector
-        touched = False
-        for section_name, section_addr, section_content in sections:
-            if section_addr + len(section_content) <= sector_addr:
-                continue # section is completely before current sector
-            if section_addr >= sector_addr + len(sector_content):
-                continue # section is completely after current sector
-
-            # prune start and end of section
-            if section_addr < sector_addr:
-                section_content = section_content[(sector_addr - section_addr):]
-                section_addr = sector_addr
-            if section_addr + len(section_content) > sector_addr + len(sector_content): # prune end
-                section_content = section_content[:(sector_addr + len(sector_content) - section_addr)]
-            
-            # insert section data into sector
-            sector_content = sector_content[:(section_addr - sector_addr)] + section_content + sector_content[(section_addr - sector_addr + len(section_content)):]
-            touched = True
-
-        if touched:
-            yield (sector, sector_content)
-
-
-def _get_first_mismatch_index(array1, array2):
-    """
-    Compares two arrays and returns the index of the
-    first unequal item or None if both arrays are equal
-    """
-    if len(array1) != len(array2):
-        raise Exception("arrays must be same size")
-    for pos in range(len(array1)):
-        if (array1[pos] != array2[pos]):
-            return pos
-    return None
-
-
-def _show_deferred_message(delay: float, msg: str):
-    async def msg_loop():
-        while True:
-            await asyncio.sleep(delay)
-            print(msg)
-
-    class MsgLoopCtx():
-        def __init__(self):
-            self._task = None
-        async def __aenter__(self):
-            self._task = asyncio.create_task(msg_loop())
-            return self
-        async def __aexit__(self, exc_type, exc_val, exc_tb):
-            self._task.cancel()
+    try:
+        with libodrive.start_usb_discovery() as dfu_discoverer:
+            libodrive._worker_thread.start()
             try:
-                await self._task
-            except asyncio.CancelledError:
-                pass # expected due to cancel() call above
-    
-    return MsgLoopCtx()
+                await run_dfu(libodrive, dfu_discoverer, serial_number, path, channel, version, erase_all, logger, interactive)
+            finally:
+                libodrive.stop_thread()
+    finally:
+        libodrive.deinit()
```

## odrive/hw_version.py

```diff
@@ -1,10 +1,10 @@
 
 import re
-from typing import List, NamedTuple
+from typing import List, NamedTuple, Tuple
 
 class HwVersion(NamedTuple):
     """
     Represents a hardware version triplet.
     See also hw_version.hpp and hw_version.dart.
     """
     product_line: int
@@ -15,15 +15,15 @@
     def from_string(arg: str):
         """
         Constructs a HwVersion from a string of the form "4.4.58".
         """
         return HwVersion(*(int(i) for i in re.match(r'^([0-9]+)\.([0-9]+).([0-9]+)$', arg).groups()))
 
     @staticmethod
-    def from_tuple(arg: List):
+    def from_tuple(arg: Tuple[int, int, int]):
         """
         Constructs a HwVersion from a tuple or list of the form (4, 4, 58).
         """
         assert len(arg) == 3
         assert all([type(a) == int for a in arg])
         return HwVersion(*arg)
 
@@ -54,13 +54,14 @@
                 1: "ODrive S1 X3",
                 2: "ODrive S1",
             }.get(self.version, "unknown ODrive S")
         elif self.product_line == 6:
             return {
                 0: "ODrive Micro X1",
                 1: "ODrive Micro X3",
+                2: "ODrive Micro X4",
             }.get(self.version, "unknown ODrive Micro")
         else:
             return "unknown device"
 
     def to_json(self):
         return [self.product_line, self.version, self.variant]
```

## odrive/legacy_config.py

```diff
@@ -1,66 +1,86 @@
 
 import json
 import os
 import tempfile
+from typing import List
 import fibre.libfibre
 import odrive
 from odrive.utils import OperationAbortedException, yes_no_prompt
 
-def _property_paths(prefix, obj):
-    for k in dir(obj):
-        v = getattr(obj, k)
-        if k.startswith('_') and k.endswith('_property'):
-            yield '.'.join(prefix + [k[1:-9]]), v
-        elif not k.startswith('_') and isinstance(v, fibre.libfibre.RemoteObject):
-            yield from _property_paths(prefix + [k], v)
+def _property_dict(device):
+    def _impl(prefix, obj):
+        for k in dir(obj):
+            v = getattr(obj, k)
+            if k.startswith('_') and k.endswith('_property'):
+                yield '.'.join(prefix + [k[1:-9]]), v
+            elif not k.startswith('_') and isinstance(v, fibre.libfibre.RemoteObject):
+                yield from _impl(prefix + [k], v)
+    return {k: v for k, v in list(_impl([], device))}
 
-def _get_dict(obj, is_config_object, prop_dict):
-    result = {}
+def _flatten(prefix: List[str], config: dict):
+    for k, v in config.items():
+        if isinstance(v, dict):
+            yield from _flatten(prefix + [k], v)
+        else:
+            yield '.'.join(prefix + [k]), v
+
+def restore_config(device, config: dict):
+    """
+    Parameters
+    ----------
+    device: The ODrive to write the config to.
+    config: A dictionary of the form {path: value}
+    """
+    errors = []
+    prop_dict = _property_dict(device)
+
+    # flatten config dict for legacy compatibility
+    config = {k: v for k, v in _flatten([], config)}
 
-    for k in dir(obj):
-        v = getattr(obj, k)
-        if k.startswith('_') and k.endswith('_property') and is_config_object:
-            v = v.read()
-            if isinstance(v, fibre.libfibre.RemoteObject):
+    for name, v in config.items():
+        try:
+            remote_attribute = prop_dict[name]
+            if isinstance(v, str) and hasattr(type(remote_attribute), 'exchange') and type(remote_attribute).exchange._inputs[1][1] == 'object_ref':
                 v = prop_dict[v]
-                print("path:", v)
-            result[k[1:-9]] = v
-        elif not k.startswith('_') and isinstance(v, fibre.libfibre.RemoteObject):
-            sub_dict = _get_dict(v, (k == 'config') or is_config_object, prop_dict)
-            if sub_dict != {}:
-                result[k] = sub_dict
+            remote_attribute.exchange(v)
+        except Exception as ex:
+            errors.append("Could not restore {}: {}".format(name, str(ex)))
+
+    return errors
+
+def backup_config(device) -> dict:
+    """
+    Returns a dict of the form {path: value} containing all properties on the
+    ODrive that have "config" in their path.
+
+    Parameters
+    ----------
+    device: The device to read from
+    """
+    prop_dict = _property_dict(device)
+    result = {}
+
+    for k, prop in prop_dict.items():
+        if ".config." in f".{k}.":
+            val = prop.read()
+            if isinstance(val, fibre.libfibre.RemoteObject):
+                val = prop_dict[val]
+                print("path:", val)
+            result[k] = val
 
     return result
 
-def _set_dict(obj, path, config_dict, prop_dict):
-    errors = []
-    for (k,v) in config_dict.items():
-        name = ".".join(path + [k])
-        if not k in dir(obj):
-            errors.append("Could not restore {}: property not found on device".format(name))
-            continue
-        if isinstance(v, dict):
-            errors += _set_dict(getattr(obj, k), path + [k], v, prop_dict)
-        else:
-            try:
-                remote_attribute = getattr(obj, '_' + k + '_property')
-                if isinstance(v, str) and hasattr(type(remote_attribute), 'exchange') and type(remote_attribute).exchange._inputs[1][1] == 'object_ref':
-                    v = prop_dict[v]
-                remote_attribute.exchange(v)
-            except Exception as ex:
-                errors.append("Could not restore {}: {}".format(name, str(ex)))
-    return errors
 
 def get_temp_config_filename(device):
     serial_number = odrive.get_serial_number_str_sync(device)
     safe_serial_number = ''.join(filter(str.isalnum, serial_number))
     return os.path.join(tempfile.gettempdir(), 'odrive-config-{}.json'.format(safe_serial_number))
 
-def backup_config(device, filename, logger):
+def backup_config_ui(device, filename, logger):
     """
     Exports the configuration of an ODrive to a JSON file.
     If no file name is provided, the file is placed into a
     temporary directory.
     """
 
     if filename is None:
@@ -68,35 +88,32 @@
 
     logger.info("Saving configuration to {}...".format(filename))
 
     if os.path.exists(filename):
         if not yes_no_prompt("The file {} already exists. Do you want to override it?".format(filename), True):
             raise OperationAbortedException()
 
-    prop_dict = list(_property_paths([], device))
-    print([k for k, v in prop_dict])
-    data = _get_dict(device, False, {v: k for k, v in prop_dict})
+    data = backup_config(device)
     with open(filename, 'w') as file:
-        json.dump(data, file)
+        json.dump(data, file, indent=2)
     logger.info("Configuration saved.")
 
-def restore_config(device, filename, logger):
+def restore_config_ui(device, filename, logger):
     """
     Restores the configuration stored in a file 
     """
 
     if filename is None:
         filename = get_temp_config_filename(device)
 
     with open(filename) as file:
         data = json.load(file)
 
     logger.info("Restoring configuration from {}...".format(filename))
-    prop_dict = list(_property_paths([], device))
-    errors = _set_dict(device, [], data, {k: v for k, v in prop_dict})
+    errors = restore_config(device, data)
 
     for error in errors:
         logger.info(error)
     if errors:
         logger.warn("Some of the configuration could not be restored.")
     
     try:
```

## odrive/release_api.py

```diff
@@ -63,15 +63,15 @@
         self._open_channels = {c['channel']: c['commits'] for c in channels if not c['closed']}
         self._closed_channels = {c['channel']: c['commits'] for c in channels if c['closed']}
 
     @property
     def open_channel_names(self):
         return list(self._open_channels.keys())
 
-    def _get_filtered_versions(self, channel_info: list, **qualifiers: dict) -> list:
+    def _get_filtered_versions(self, channel_info: list, has_file: Optional[str], **qualifiers: dict) -> list:
         """
         Returns a list of version info objects where all qualifiers match and
         where the version name is contained in channel_info.
 
         The list is ordered "most relevant first".
 
         Specifically, it is sorted on two levels:
@@ -80,67 +80,72 @@
         """
         if 'product' in qualifiers:
             import warnings
             warnings.warn('The "product" qualifier is deprecated. Use "board" instead.', DeprecationWarning, stacklevel=0)
 
         version_infos = [
             c for c in self._commits
-            if (c['commit_hash'] in channel_info) and all((k in c) and (c[k] == v) for k, v in qualifiers.items())
+            if (c['commit_hash'] in channel_info) and (has_file is None or has_file in c.get('index', [])) and all((k in c) and (c[k] == v) for k, v in qualifiers.items())
         ]
         return sorted(version_infos, key=lambda c: (
             channel_info.index(c['commit_hash']),
             {'internal': 0, 'public': 1}.get(c.get('variant', None), 2)))
 
     def _get_channel_info(self, channel: str):
         if channel in self._open_channels:
             return self._open_channels[channel]
         elif channel in self._closed_channels:
             return self._closed_channels[channel]
         else:
             raise ChannelNotFoundError(f"Channel {channel} not found.")
 
-    def _get_manifest(self, version_info):
+    def _get_manifest(self, version_info, file: Optional[str] = None):
         content_key = version_info['content']
 
+        url = self._files[content_key]['url']
+        if not file is None:
+            base_url = url[:url.rfind('/')] # substring up to last /
+            url = base_url + '/' + file
+
         return {
             'content_key': safe_b64encode(content_key),
             'commit_hash': version_info['commit_hash'],
             'release_date': self._files[content_key]['release_date'],
-            'url': self._files[content_key]['url']
+            'url': url
         }
 
-    def get_latest(self, channel: str, **qualifiers: dict):
+    def get_latest(self, channel: str, file: Optional[str] = None, **qualifiers: dict):
         """
         Checks for the latest firmware on the specified channel with the specified
         qualifiers (product, app).
 
         If the specified channel is not found or empty, an exception is thrown.
         Returns a metadata manifest for the release that was found.
         """
         channel_info = list(reversed(self._get_channel_info(channel)))
-        filtered_versions = self._get_filtered_versions(channel_info, **qualifiers)
+        filtered_versions = self._get_filtered_versions(channel_info, has_file=file, **qualifiers)
 
         if len(filtered_versions) == 0:
             raise FirmwareNotFoundError()
 
-        return self._get_manifest(filtered_versions[0])
+        return self._get_manifest(filtered_versions[0], file)
 
-    def get_version(self, version: str, **qualifiers: dict):
+    def get_version(self, version: str, file: Optional[str] = None, **qualifiers: dict):
         """
         Looks up the release information for the specified commit with the
         specified qualifiers (product, app).
 
         Returns a metadata manifest for the release that was found.
         """
-        filtered_versions = self._get_filtered_versions(channel_info=[version], **qualifiers)
+        filtered_versions = self._get_filtered_versions(channel_info=[version], has_file=file, **qualifiers)
 
         if len(filtered_versions) == 0:
             raise FirmwareNotFoundError()
 
-        return self._get_manifest(filtered_versions[0])
+        return self._get_manifest(filtered_versions[0], file)
 
     def compare(self, from_version: Optional[str], to_version: str, channel: str, **qualifiers: dict):
         """
         Checks if the specified transition is an upgrade or not.
         """
 
         return VersionRelationship.UNKNOWN # TODO
```

## odrive/shell.py

```diff
@@ -3,14 +3,15 @@
 import sys
 import platform
 import threading
 import fibre
 import odrive
 import odrive.enums
 import odrive.config
+import odrive.legacy_config
 import odrive.dfu
 import odrive.utils
 
 def print_banner():
     print("Website: https://odriverobotics.com/")
     print("Docs: https://docs.odriverobotics.com/")
     print("Forums: https://discourse.odriverobotics.com/")
@@ -105,14 +106,16 @@
         'ram_osci_trigger': odrive.utils.ram_osci_trigger,
         'ram_osci_download': _wrap_async(odrive.utils.ram_osci_download),
         'ram_osci_run': _wrap_async(odrive.utils.ram_osci_run),
         'BulkCapture': odrive.utils.BulkCapture,
         'step_and_plot': odrive.utils.step_and_plot,
         'calculate_thermistor_coeffs': odrive.utils.calculate_thermistor_coeffs,
         'set_motor_thermistor_coeffs': odrive.utils.set_motor_thermistor_coeffs,
+        'backup_config': odrive.legacy_config.backup_config,
+        'restore_config': odrive.legacy_config.restore_config,
     }
 
     # Import a bunch of variables and functions from various sources
     interactive_variables.update(_import_from(ShellVariables))
     interactive_variables.update(_import_from(odrive.enums))
     interactive_variables.update(_import_from(odrive.config))
```

## odrive/version.py

```diff
@@ -1 +1 @@
-__version__ = '0.6.8'
+__version__ = '0.6.9.dev0'
```

## odrive/data/motors.json

### Pretty-printed

 * *Similarity: 0.9090909090909091%*

 * *Differences: {"'NEMA32-Leison'": "OrderedDict([('phase_resistance', 0.1505899578332901), ('phase_inductance', "*

 * *                    "0.00010684521112125367), ('pole_pairs', 4), ('kv', 145), ('max_current', 8), "*

 * *                    "('thermistor_r25', 10000), ('thermistor_beta', 3435), ('max_temp', 140), "*

 * *                    "('show_in_gui', False)])"}*

```diff
@@ -88,14 +88,25 @@
         "phase_inductance": 0.0001071,
         "phase_resistance": 0.147,
         "pole_pairs": 4,
         "show_in_gui": false,
         "thermistor_beta": 3435,
         "thermistor_r25": 10000
     },
+    "NEMA32-Leison": {
+        "kv": 145,
+        "max_current": 8,
+        "max_temp": 140,
+        "phase_inductance": 0.00010684521112125367,
+        "phase_resistance": 0.1505899578332901,
+        "pole_pairs": 4,
+        "show_in_gui": false,
+        "thermistor_beta": 3435,
+        "thermistor_r25": 10000
+    },
     "NEMA34-JKongMotor": {
         "max_current": 20,
         "max_temp": 140,
         "phase_inductance": 9.068e-05,
         "phase_resistance": 0.0623,
         "pole_pairs": 4,
         "show_in_gui": false,
```

## odrive/data/odrive-micro-x3.json

### Pretty-printed

 * *Similarity: 0.9705882352941176%*

 * *Differences: {"'step_dir'": '[]'}*

```diff
@@ -46,20 +46,15 @@
     "spi": [
         {
             "miso": "miso",
             "mosi": "mosi",
             "sck": "sck"
         }
     ],
-    "step_dir": [
-        {
-            "dir": "gpio11",
-            "step": "gpio10"
-        }
-    ],
+    "step_dir": [],
     "temp_in": [
         {
             "io": "gpio1",
             "r_load": 1000,
             "thermistor_bottom": true
         }
     ],
```

## Comparing `odrive-0.6.8.data/scripts/odrive_demo.py` & `odrive-0.6.9.dev0.data/scripts/odrive_demo.py`

 * *Files identical despite different names*

## Comparing `odrive-0.6.8.data/scripts/odrivetool` & `odrive-0.6.9.dev0.data/scripts/odrivetool`

 * *Files 10% similar despite different names*

```diff
@@ -47,15 +47,15 @@
 shell_parser = subparsers.add_parser('shell', help='Drop into an interactive python shell that lets you interact with the ODrive(s)')
 shell_parser.add_argument("--no-ipython", action="store_true",
                           help="Use the regular Python shell "
                           "instead of the IPython shell, "
                           "even if IPython is installed.")
 
 # These two DFU commands are aliases except for the info message
-for command in ['dfu', 'legacy-dfu']:
+for command in ['new-dfu', 'dfu', 'legacy-dfu', 'install-bootloader']:
     dfu_parser = subparsers.add_parser(command, help="Upgrade the ODrive device firmware."
                                                 "If no serial number is specified, the first ODrive that is found is updated")
     dfu_parser.add_argument('file', nargs='?',
                             help='The .elf file to be flashed. Make sure target board version '
                             'of the firmware file matches the actual board version. '
                             'You can download the latest release manually from '
                             'https://github.com/odriverobotics/ODrive/releases. '
@@ -65,19 +65,26 @@
                             help='The release channel to download from. '
                             'Mutually exclusive with --version. '
                             'If no channel, no version and no firmware file is specified, '
                             'the "master" channel is used. ')
     dfu_parser.add_argument('--version', action='store',
                             help='The version name to download. '
                             'Mutually exclusive with --channel.')
-    dfu_parser.add_argument('--no-erase-all', action='store_true',
-                            help='If specified, only those flash sectors occupied '
-                            'by the firmware will be erased. If not specified, all '
-                            'flash sectors (including non-volatile config) will be '
-                            'erased.')
+    if command != 'new-dfu': # Only valid for legacy-dfu
+        dfu_parser.add_argument('--no-erase-all', action='store_true',
+                                help='If specified, only those flash sectors occupied '
+                                'by the firmware will be erased. If not specified, all '
+                                'flash sectors (including non-volatile config) will be '
+                                'erased.')
+    else:
+        dfu_parser.add_argument('--erase-all', action='store_true',
+                                help='If specified, all flash sectors (including those '
+                                'containing non-volatile config) will be erased. '
+                                'If not specified, only those flash sectors occupied '
+                                'by the firmware will be erased.')
 
 unlock_parser = subparsers.add_parser('unlock', help="Try to remove read-out protection."
                                                "If no serial number is specified, the first ODrive that is found is unlocked")
 
 backup_config_parser = subparsers.add_parser('backup-config', help="Saves the configuration of the ODrive to a JSON file")
 backup_config_parser.add_argument('file', nargs='?',
                         help="Path to the file where to store the data. "
@@ -85,15 +92,14 @@
 
 restore_config_parser = subparsers.add_parser('restore-config', help="Restores the configuration of the ODrive from a JSON file")
 restore_config_parser.add_argument('file', nargs='?',
                         help="Path to the file that contains the configuration data. "
                         "If no path is provided, the configuration is loaded from {}.".format(tempfile.gettempdir()))
 
 subparsers.add_parser('liveplotter', help="For plotting of odrive parameters (i.e. position) in real time")
-subparsers.add_parser('drv-status', help="Show status of the on-board DRV8301 chips (for debugging only)")
 subparsers.add_parser('rate-test', help="Estimate the average transmission bandwidth over USB")
 
 # General arguments
 parser.add_argument("-p", "--path", metavar="PATH", action="store",
                     help="The path(s) where ODrive(s) should be discovered.\n"
                     "By default the script will connect to any ODrive on USB.\n\n"
                     "To select a specific USB device:\n"
@@ -153,42 +159,65 @@
             print("  If you find issues, please report them")
             print("  on https://github.com/odriverobotics/ODrive/issues")
             print("  or better yet, submit a pull request to fix it.")
             print("")
         import odrive.shell
         odrive.shell.launch_shell(args, logger)
 
-    elif args.command == 'dfu' or args.command == 'legacy-dfu':
+    elif args.command == 'new-dfu':
+        print_version()
+
+        import odrive.dfu
+        try:
+            if sum([bool(args.file), bool(args.channel), bool(args.version)]) > 1:
+                raise odrive.dfu.DfuError("Only one of firmware-file, --channel or --version must be specified.")
+            elif sum([bool(args.file), bool(args.channel), bool(args.version)]) == 0:
+                args.channel = 'master'
+
+            asyncio.run(odrive.dfu.dfu_ui(
+                serial_number=args.serial_number,
+                path=args.file,
+                channel=args.channel,
+                version=args.version,
+                erase_all=args.erase_all,
+                logger=logger))
+        except odrive.dfu.DfuError as ex:
+            logger.error(str(ex))
+            sys.exit(1)
+
+    elif args.command == 'dfu' or args.command == 'legacy-dfu' or args.command == 'install-bootloader':
         print_version()
 
         if args.command == 'dfu':
             logger.warn("Try our new firmware update system!")
             logger.warn("Supports firmware updates from the Web GUI and firmware updates via CAN bus.")
-            logger.warn("More info and migration instructions here: https://docs.odriverobotics.com/v/devel/guides/new-dfu.html.")
+            logger.warn("More info and migration instructions here: https://docs.odriverobotics.com/v/latest/guides/new-dfu.html.")
 
-        import odrive.dfu
+        import odrive.legacy_dfu
         try:
             if 'win32' in sys.platform:
                 # needed for subprocess support
                 # https://docs.python.org/3/library/asyncio-platforms.html#asyncio-windows-subprocess
                 asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
 
             if sum([bool(args.file), bool(args.channel), bool(args.version)]) > 1:
                 raise odrive.dfu.DfuError("Only one of firmware-file, --channel or --version must be specified.")
             elif sum([bool(args.file), bool(args.channel), bool(args.version)]) == 0:
                 args.channel = 'master'
 
-            asyncio.run(odrive.dfu.launch_dfu(
+            asyncio.run(odrive.legacy_dfu.launch_dfu(
                 serial_number=args.serial_number,
                 path=args.file,
                 channel=args.channel,
                 version=args.version,
                 erase_all=not args.no_erase_all,
-                logger=logger))
-        except odrive.dfu.DfuError as ex:
+                logger=logger,
+                installing_bootloader=args.command == 'install-bootloader',
+                release_type='bootloader' if args.command == 'install-bootloader' else 'firmware'))
+        except odrive.legacy_dfu.DfuError as ex:
             logger.error(str(ex))
             sys.exit(1)
 
     elif args.command == 'unlock':
         print_version()
         import odrive.dfu
         odrive.dfu.unlock_device(args.serial_number, None)
@@ -205,37 +234,30 @@
             my_odrive.axis1.encoder.pos_estimate,
         ])
 
         print("Showing plot. Press Ctrl+C to exit.")
         while not cancellation_token.is_set():
             time.sleep(1)
 
-    elif args.command == 'drv-status':
-        from odrive.utils import print_drv_regs
-        print("Waiting for ODrive...")
-        my_odrive = odrive.find_any(path=args.path, serial_number=args.serial_number)
-        print_drv_regs("Motor 0", my_odrive.axis0.motor)
-        print_drv_regs("Motor 1", my_odrive.axis1.motor)
-
     elif args.command == 'rate-test':
         from odrive.utils import rate_test
         print("Waiting for ODrive...")
         my_odrive = odrive.find_any(path=args.path, serial_number=args.serial_number)
         rate_test(my_odrive)
 
     elif args.command == 'backup-config':
-        from odrive.legacy_config import backup_config
+        from odrive.legacy_config import backup_config_ui
         print("Waiting for ODrive...")
         my_odrive = odrive.find_any(path=args.path, serial_number=args.serial_number)
-        backup_config(my_odrive, args.file, logger)
+        backup_config_ui(my_odrive, args.file, logger)
 
     elif args.command == 'restore-config':
-        from odrive.legacy_config import restore_config
+        from odrive.legacy_config import restore_config_ui
         print("Waiting for ODrive...")
         my_odrive = odrive.find_any(path=args.path, serial_number=args.serial_number)
-        restore_config(my_odrive, args.file, logger)
+        restore_config_ui(my_odrive, args.file, logger)
 
     else:
         raise Exception("unknown command: " + args.command)
 
 except OperationAbortedException:
     logger.info("Operation aborted.")
```

## Comparing `odrive-0.6.8.dist-info/METADATA` & `odrive-0.6.9.dev0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: odrive
-Version: 0.6.8
+Version: 0.6.9.dev0
 Summary: Control utilities for the ODrive high performance motor controller
 Home-page: https://odriverobotics.com/
 Author: ODrive Robotics Inc
 Author-email: info@odriverobotics.com
 License: MIT
 Keywords: odrive,motor,motor control,servo
 Platform: UNKNOWN
```

## Comparing `odrive-0.6.8.dist-info/RECORD` & `odrive-0.6.9.dev0.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,50 +1,49 @@
-odrive/__init__.py,sha256=wLKgGAMUqRXh-ZP2d2tuBAuPmi4TkoSt-7XW6mU9f6o,5065
+odrive/__init__.py,sha256=qHt_JPF8fRjw1EtSmXp6aoX2okmYJsI-Ob__byGv6X8,5119
 odrive/api_client.py,sha256=B_rTRbyJIo0d1uS71FDqN3cUAgrT-dYFN-zYNw4VYs8,2353
-odrive/config.py,sha256=IZoaK9YK9yX3CJmisIK2I7OZ9_t3IaVqUhbiSIYl2rs,53241
+odrive/config.py,sha256=3UWAArlBP8bmqGF5B-XNJZKLxCXGkqlLXULzLEtq6Cg,53265
 odrive/crypto.py,sha256=wA7KFwlolkv1nMnOthkOLxi2cms2h3_W1uiEQUB1fls,13415
-odrive/database.py,sha256=pGhxJAbcwwi6z03wzWbVgFO49NQluooMc5XkD_E1Fsg,6221
-odrive/dfu.py,sha256=sbHwOrb_LliLVmWw1O7GRqvVcXRYQQnFTKRkzC8-uH0,19525
+odrive/database.py,sha256=pNislHP35RcCCnP1GwuTnUhBQV-lDFlejHcDpNFaWis,6272
+odrive/dfu.py,sha256=YHAH6kTt9joFD44WrW4aym_Hz55Zl0lZRVSxf3xRf50,8502
 odrive/enums.py,sha256=k4U0ZCBMYdOwXgU71X8t4J6MMYjyZvDFZgET9uTTdPs,16597
 odrive/firmware.py,sha256=hb8UpfWa-AKU_n-NEprOujcOJzI3mF7P555ZvbK9VfM,3489
-odrive/hw_version.py,sha256=ubGnxvFMftO_KI-wULaT2kxE46_ZU_ZTeW3YP5008IE,1965
+odrive/hw_version.py,sha256=ALb4gIoAvu_gNRUKsPiR2e4HXgZ_F8fEs1roCKPqzpE,2026
 odrive/legacy.py,sha256=kfM0OyMPoGW1kDxZi26gdypkehQGXaH904jce_T3Ogc,3069
-odrive/legacy_config.py,sha256=58oBbfEJIXD19EmEI8u3YQuutkGrI6Z0wFjbSssIRtU,3828
-odrive/release_api.py,sha256=UD872qmw24HtndQs5tAXxVW-_ThbiYY_kUdGMb_a5D0,6684
+odrive/legacy_config.py,sha256=ZK25i7CSFl6Rz_cePtx0dMsYCsOBAzU6vXniGmQ4IbM,3857
+odrive/legacy_dfu.py,sha256=mLj0k4dhzFDHabhCcRFJn1lY03ikNE0LJW27KEE0nAM,18908
+odrive/libodrive.py,sha256=ESkjl1CzH_6Tle6zQoVIN8HiEOwe3hkecEtnLq4sNhA,13903
+odrive/release_api.py,sha256=w1A-GA2B6rKISJ09yvxDjaFHuJPZ9azQL660wdl5dME,7049
 odrive/rich_text.py,sha256=L6SZVnV8cTDUtR7qO2vc0ddELyfA68costdufjACqZg,4557
-odrive/shell.py,sha256=JDKvx0FSZF1gF8OOXbLneqldZANN4YZeEei0MDDj4mM,5362
+odrive/shell.py,sha256=JZ0En0knJ45B6ETtfgAXEr7oL85cQPCU2L3X3hTcOkQ,5514
 odrive/utils.py,sha256=w81g1GNftfo4eO9Wx6JVGc8jP_zn9U4rXwy47Vbjwt4,36587
-odrive/version.py,sha256=45VZa7WiiyMfnHV3wXd7OZeYUr3Ri5EgvBPDQfyUAPc,21
+odrive/version.py,sha256=fdYqZmLuysogFGDnIzSTE6Tgj1DBJUV12qKTbQ3D7dk,26
 odrive/data/brakeRs.json,sha256=OkMzo2DvuqPnkzWbR6uMRgYxO866anr1Yf_tvajgO64,308
 odrive/data/drvs.json,sha256=8iB8csKpdEewet9hHP0HuRZJZJmjuWQU88I3SBrE1ks,3051
 odrive/data/encoders.json,sha256=5JhdxKu4JzT2vPFM78bEO-jBlhKV1pIcPdIVlRl1rIk,2740
-odrive/data/motors.json,sha256=VspVNHhm6YZZm6zyLIonF3_riwSMHGEC5YX3t8CnaEM,3361
+odrive/data/motors.json,sha256=xZ5pGYBojefbIBcf5MZ6zndHOtrRqgZfPiIy5TozKoo,3681
 odrive/data/odrive-micro-x1.json,sha256=2z1sMwyDz7RVMkJmJDRJkVPuuAUVbMm-NzMNKoZpVXI,1076
-odrive/data/odrive-micro-x3.json,sha256=LMzUyH0ZcgKyf0ACDE3yRSXCvFykliTqK1_98rdRwKM,937
+odrive/data/odrive-micro-x3.json,sha256=L_CzJl0vIPfTepKMN2RwXHkcNXfjf3I8rL5xgYoAf7U,888
+odrive/data/odrive-micro-x4.json,sha256=75sYfmISduwLxapq7XcpkHDdnuv6NR2IG1F4jzegTFE,888
 odrive/data/odrive-s1-x4.json,sha256=SW-030PX9sDkocrK1cXfBwVDRL2lNAgC_RNRF5_QcJQ,1150
 odrive/data/odrive-v4.4.json,sha256=JSsDSCR4AAw9tP_xPX51oKAKiHHueM3noqUbmrI7Ibk,1336
 odrive/data/schema-brakeR.json,sha256=hBreKlfyqehKQIZ2S_kUBAxaCnN3_SyHvfvVl1y5czw,141
 odrive/data/schema-drv.json,sha256=mwyduLsmXZpUVc0uJs7fZzLJKHp-Cv8kxswpT-s_XRk,138
 odrive/data/schema-encoders.json,sha256=6jMevEPFwB7-VLSI2BfaCj-zMAnburCZ1RfMqvF2xtU,142
 odrive/data/schema-motors.json,sha256=GHTbJjI0Wqis-7hrigcdTapFAobB8a50-1AnAa7k5NU,140
 odrive/data/schema-odrive.json,sha256=57gQBK7ZRtvI_BggsKkqf0Cfvw5DL-hRIS-yNcHlxsw,93
 odrive/data/schema.json,sha256=vvjypkK9SJgPbNJvG50aUj03_l1vYL6tVvPHze3zzCg,9044
 odrive/dfuse/DfuDevice.py,sha256=bueeS19mfPoT27D5yIRtMp1w2U9QBPzA_7Z2JbpQRIY,10136
 odrive/dfuse/__init__.py,sha256=SqD-q-CoJh4j6hr1a9BE2cP4LeQ278ZsuWOcoN0AtcY,54
+odrive/lib/libodrive-windows-x64.dll,sha256=9AYeNgjbLl9V1ZzE5ne1xk2oL8BtJIBvf-dYFBnBT_k,3514636
 odrive/pyfibre/fibre/__init__.py,sha256=rdIJGCovzGDddBGyIsOQn7woKhUYjFyieJnNuhiBeMI,105
-odrive/pyfibre/fibre/libfibre-linux-aarch64.so,sha256=KohkLZa_mxBXCdACxsjAt0ZizlNULlRx8q7B4Zhd4lQ,712336
-odrive/pyfibre/fibre/libfibre-linux-amd64.so,sha256=hfOixGM-al1pdEAt0wYJVhgJbVGT7AxxWlnzH1OciMw,757096
-odrive/pyfibre/fibre/libfibre-linux-armhf.so,sha256=7ULtz8dgRyxh2A0fsUmM6EcGsf4YoJXDvnF4wTAYW6s,783708
-odrive/pyfibre/fibre/libfibre-macos-arm.dylib,sha256=J6_FhKh4BehKKwgsjGNQO-yULZp5iGa3G5h0l3-8sMo,1703365
-odrive/pyfibre/fibre/libfibre-macos-x86.dylib,sha256=HblN0ZURN657I6aSIFDrvy5mPP1yyXcNT6_SIshlmAk,686544
 odrive/pyfibre/fibre/libfibre-windows-amd64.dll,sha256=k0fUViBGNdydQqmFgGlsb0g0dnVt1kxyah2HKVayjqE,1235470
 odrive/pyfibre/fibre/libfibre.py,sha256=j3ywl917iDNndW_wpLbddXtIzOtk3mmb0IC12NXuXNI,40071
 odrive/pyfibre/fibre/libwinpthread-1.dll,sha256=jDYWluWzHcgDhM7zC1s0Qw9lLZi0HyTnV01WX2Ebx5Y,61576
 odrive/pyfibre/fibre/shell.py,sha256=eHgWVVy-CfJ3mK4s1xjozjWTuvnq_PGx-vId0c9tcJc,6356
 odrive/pyfibre/fibre/utils.py,sha256=rd8NoiVcUcM_c_LRRCvizFluMROr12L3G1doyQWmHOI,4788
-odrive-0.6.8.data/scripts/odrive_demo.py,sha256=RQVEadmIwNKjk4K4p2u6JMas8OVxqPHKG57yZRVXWQM,1570
-odrive-0.6.8.data/scripts/odrivetool,sha256=h_YadsHWdMu7kTLGeOX8-W16cOh948kGGBel267dt9g,11457
-odrive-0.6.8.data/scripts/odrivetool.bat,sha256=s-gOwGZmQy-k14P70z_elSbToWJV_Er8sx5fkxFu1GE,43
-odrive-0.6.8.dist-info/METADATA,sha256=igArSNBehvVkGLd-KN1J79JCDY95uopIwff9aWXBMDs,598
-odrive-0.6.8.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-odrive-0.6.8.dist-info/top_level.txt,sha256=M46r8k9EGZCfhy0EIMcBrK7-Xmpb4WjOs7ei3HVOaBk,7
-odrive-0.6.8.dist-info/RECORD,,
+odrive-0.6.9.dev0.data/scripts/odrive_demo.py,sha256=RQVEadmIwNKjk4K4p2u6JMas8OVxqPHKG57yZRVXWQM,1570
+odrive-0.6.9.dev0.data/scripts/odrivetool,sha256=QSQOsDew_xPTmvQZrfz41XrWVCUNn4NYtxuhwkpqAU4,12586
+odrive-0.6.9.dev0.data/scripts/odrivetool.bat,sha256=s-gOwGZmQy-k14P70z_elSbToWJV_Er8sx5fkxFu1GE,43
+odrive-0.6.9.dev0.dist-info/METADATA,sha256=WBaqD_yxOGLPhTGwhlh1YggDBCKz01wcb5hwtPvuqiY,603
+odrive-0.6.9.dev0.dist-info/WHEEL,sha256=KiPL0PI64mGLY_MHX7c-grPOEh7bS2zxdBak-i5y7xE,99
+odrive-0.6.9.dev0.dist-info/top_level.txt,sha256=M46r8k9EGZCfhy0EIMcBrK7-Xmpb4WjOs7ei3HVOaBk,7
+odrive-0.6.9.dev0.dist-info/RECORD,,
```

