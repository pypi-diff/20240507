# Comparing `tmp/igraph-0.9.8.tar.gz` & `tmp/igraph-0.9.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "igraph-0.9.8.tar", last modified: Thu Oct 28 20:11:04 2021, max compression
+gzip compressed data, was "igraph-0.9.9.tar", last modified: Mon Jan 10 13:49:49 2022, max compression
```

## Comparing `igraph-0.9.8.tar` & `igraph-0.9.9.tar`

### file list

```diff
@@ -1,2133 +1,2279 @@
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.730950 igraph-0.9.8/
--rw-r--r--   0 runner    (1001) docker     (121)    17987 2021-10-28 20:10:52.000000 igraph-0.9.8/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)      155 2021-10-28 20:10:52.000000 igraph-0.9.8/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (121)     2381 2021-10-28 20:11:04.726950 igraph-0.9.8/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)     8735 2021-10-28 20:10:52.000000 igraph-0.9.8/README.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.278930 igraph-0.9.8/igraph.egg-info/
--rw-r--r--   0 runner    (1001) docker     (121)     2381 2021-10-28 20:11:04.000000 igraph-0.9.8/igraph.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)    98749 2021-10-28 20:11:04.000000 igraph-0.9.8/igraph.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2021-10-28 20:11:04.000000 igraph-0.9.8/igraph.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:04.000000 igraph-0.9.8/igraph.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (121)        7 2021-10-28 20:11:04.000000 igraph-0.9.8/igraph.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.278930 igraph-0.9.8/scripts/
--rwxr-xr-x   0 runner    (1001) docker     (121)      127 2021-10-28 20:10:52.000000 igraph-0.9.8/scripts/igraph
--rwxr-xr-x   0 runner    (1001) docker     (121)     2166 2021-10-28 20:10:52.000000 igraph-0.9.8/scripts/mkdoc.sh
--rw-r--r--   0 runner    (1001) docker     (121)       38 2021-10-28 20:11:04.730950 igraph-0.9.8/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (121)    33448 2021-10-28 20:10:52.000000 igraph-0.9.8/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.270929 igraph-0.9.8/src/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.286930 igraph-0.9.8/src/_igraph/
--rw-r--r--   0 runner    (1001) docker     (121)     8845 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/arpackobject.c
--rw-r--r--   0 runner    (1001) docker     (121)     1658 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/arpackobject.h
--rw-r--r--   0 runner    (1001) docker     (121)    62691 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/attributes.c
--rw-r--r--   0 runner    (1001) docker     (121)     3872 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/attributes.h
--rw-r--r--   0 runner    (1001) docker     (121)     8553 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/bfsiter.c
--rw-r--r--   0 runner    (1001) docker     (121)     1696 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/bfsiter.h
--rw-r--r--   0 runner    (1001) docker     (121)     2493 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/common.c
--rw-r--r--   0 runner    (1001) docker     (121)     1915 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/common.h
--rw-r--r--   0 runner    (1001) docker     (121)    96221 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/convert.c
--rw-r--r--   0 runner    (1001) docker     (121)     8346 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/convert.h
--rw-r--r--   0 runner    (1001) docker     (121)    10203 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/dfsiter.c
--rw-r--r--   0 runner    (1001) docker     (121)     1686 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/dfsiter.h
--rw-r--r--   0 runner    (1001) docker     (121)    23020 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/edgeobject.c
--rw-r--r--   0 runner    (1001) docker     (121)     2000 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/edgeobject.h
--rw-r--r--   0 runner    (1001) docker     (121)    31746 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/edgeseqobject.c
--rw-r--r--   0 runner    (1001) docker     (121)     1951 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/edgeseqobject.h
--rw-r--r--   0 runner    (1001) docker     (121)     3170 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/error.c
--rw-r--r--   0 runner    (1001) docker     (121)     1594 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/error.h
--rw-r--r--   0 runner    (1001) docker     (121)     6575 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/filehandle.c
--rw-r--r--   0 runner    (1001) docker     (121)     1535 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/filehandle.h
--rw-r--r--   0 runner    (1001) docker     (121)      176 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/force_cpp_linker.cpp
--rw-r--r--   0 runner    (1001) docker     (121)   622813 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/graphobject.c
--rw-r--r--   0 runner    (1001) docker     (121)    17462 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/graphobject.h
--rw-r--r--   0 runner    (1001) docker     (121)    33748 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/igraphmodule.c
--rw-r--r--   0 runner    (1001) docker     (121)     2566 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/igraphmodule_api.h
--rw-r--r--   0 runner    (1001) docker     (121)    16985 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/indexing.c
--rw-r--r--   0 runner    (1001) docker     (121)     1347 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/indexing.h
--rw-r--r--   0 runner    (1001) docker     (121)     8857 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/operators.c
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/operators.h
--rw-r--r--   0 runner    (1001) docker     (121)     1020 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/platform.h
--rw-r--r--   0 runner    (1001) docker     (121)      974 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/preamble.h
--rw-r--r--   0 runner    (1001) docker     (121)     5116 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/pyhelpers.c
--rw-r--r--   0 runner    (1001) docker     (121)     1945 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/pyhelpers.h
--rw-r--r--   0 runner    (1001) docker     (121)     9645 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/random.c
--rw-r--r--   0 runner    (1001) docker     (121)     1035 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/random.h
--rw-r--r--   0 runner    (1001) docker     (121)    29067 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/vertexobject.c
--rw-r--r--   0 runner    (1001) docker     (121)     2047 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/vertexobject.h
--rw-r--r--   0 runner    (1001) docker     (121)    34598 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/vertexseqobject.c
--rw-r--r--   0 runner    (1001) docker     (121)     1998 2021-10-28 20:10:52.000000 igraph-0.9.8/src/_igraph/vertexseqobject.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.290930 igraph-0.9.8/src/igraph/
--rw-r--r--   0 runner    (1001) docker     (121)   216008 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.290930 igraph-0.9.8/src/igraph/app/
--rw-r--r--   0 runner    (1001) docker     (121)       32 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/app/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    18426 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/app/shell.py
--rw-r--r--   0 runner    (1001) docker     (121)    65054 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/clustering.py
--rw-r--r--   0 runner    (1001) docker     (121)    16312 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/configuration.py
--rw-r--r--   0 runner    (1001) docker     (121)     5754 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/cut.py
--rw-r--r--   0 runner    (1001) docker     (121)    27699 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/datatypes.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.294931 igraph-0.9.8/src/igraph/drawing/
--rw-r--r--   0 runner    (1001) docker     (121)    20926 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     5074 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/baseclasses.py
--rw-r--r--   0 runner    (1001) docker     (121)    92493 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/colors.py
--rw-r--r--   0 runner    (1001) docker     (121)     3923 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/coord.py
--rw-r--r--   0 runner    (1001) docker     (121)    18708 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/edge.py
--rw-r--r--   0 runner    (1001) docker     (121)    56179 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/graph.py
--rw-r--r--   0 runner    (1001) docker     (121)    13893 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/metamagic.py
--rw-r--r--   0 runner    (1001) docker     (121)    16210 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/shapes.py
--rw-r--r--   0 runner    (1001) docker     (121)    13148 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/text.py
--rw-r--r--   0 runner    (1001) docker     (121)    18484 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/utils.py
--rw-r--r--   0 runner    (1001) docker     (121)     4428 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/drawing/vertex.py
--rw-r--r--   0 runner    (1001) docker     (121)     8066 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/formula.py
--rw-r--r--   0 runner    (1001) docker     (121)    17030 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/layout.py
--rw-r--r--   0 runner    (1001) docker     (121)     6036 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/matching.py
--rw-r--r--   0 runner    (1001) docker     (121)    16874 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/operators.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.294931 igraph-0.9.8/src/igraph/remote/
--rw-r--r--   0 runner    (1001) docker     (121)       69 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/remote/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    10360 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/remote/gephi.py
--rw-r--r--   0 runner    (1001) docker     (121)     5704 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/sparse_matrix.py
--rw-r--r--   0 runner    (1001) docker     (121)    22484 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/statistics.py
--rw-r--r--   0 runner    (1001) docker     (121)    14308 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/summary.py
--rw-r--r--   0 runner    (1001) docker     (121)    12161 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/utils.py
--rw-r--r--   0 runner    (1001) docker     (121)       95 2021-10-28 20:10:52.000000 igraph-0.9.8/src/igraph/version.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.298931 igraph-0.9.8/tests/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     5865 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_atlas.py
--rw-r--r--   0 runner    (1001) docker     (121)    10535 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_attributes.py
--rw-r--r--   0 runner    (1001) docker     (121)    29965 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_basic.py
--rw-r--r--   0 runner    (1001) docker     (121)     9996 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_bipartite.py
--rw-r--r--   0 runner    (1001) docker     (121)     8980 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_cliques.py
--rw-r--r--   0 runner    (1001) docker     (121)     3873 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_colortests.py
--rw-r--r--   0 runner    (1001) docker     (121)     6661 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_conversion.py
--rw-r--r--   0 runner    (1001) docker     (121)    21218 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_decomposition.py
--rw-r--r--   0 runner    (1001) docker     (121)    16063 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_edgeseq.py
--rw-r--r--   0 runner    (1001) docker     (121)    10064 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_flow.py
--rw-r--r--   0 runner    (1001) docker     (121)    23297 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_foreign.py
--rw-r--r--   0 runner    (1001) docker     (121)     7516 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_games.py
--rw-r--r--   0 runner    (1001) docker     (121)    18247 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_generators.py
--rw-r--r--   0 runner    (1001) docker     (121)     1487 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_homepage.py
--rw-r--r--   0 runner    (1001) docker     (121)     1890 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_indexing.py
--rw-r--r--   0 runner    (1001) docker     (121)    14525 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_isomorphism.py
--rw-r--r--   0 runner    (1001) docker     (121)     1981 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_iterators.py
--rw-r--r--   0 runner    (1001) docker     (121)    10782 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_layouts.py
--rw-r--r--   0 runner    (1001) docker     (121)     2927 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_matching.py
--rw-r--r--   0 runner    (1001) docker     (121)    16080 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_operators.py
--rw-r--r--   0 runner    (1001) docker     (121)     1206 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_rng.py
--rw-r--r--   0 runner    (1001) docker     (121)     2624 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_separators.py
--rw-r--r--   0 runner    (1001) docker     (121)     1491 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_spectral.py
--rw-r--r--   0 runner    (1001) docker     (121)    35916 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_structural.py
--rw-r--r--   0 runner    (1001) docker     (121)      666 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_unicode_issues.py
--rw-r--r--   0 runner    (1001) docker     (121)    14074 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_vertexseq.py
--rw-r--r--   0 runner    (1001) docker     (121)     2231 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/test_walks.py
--rw-r--r--   0 runner    (1001) docker     (121)      764 2021-10-28 20:10:52.000000 igraph-0.9.8/tests/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.270929 igraph-0.9.8/vendor/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.270929 igraph-0.9.8/vendor/source/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.302931 igraph-0.9.8/vendor/source/igraph/
--rw-r--r--   0 runner    (1001) docker     (121)      770 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.astylerc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.302931 igraph-0.9.8/vendor/source/igraph/.azure/
--rw-r--r--   0 runner    (1001) docker     (121)     3660 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.azure/build-win.yml
--rw-r--r--   0 runner    (1001) docker     (121)     2145 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.azure/build.yml
--rw-r--r--   0 runner    (1001) docker     (121)      207 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.editorconfig
--rw-r--r--   0 runner    (1001) docker     (121)       51 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.git
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.302931 igraph-0.9.8/vendor/source/igraph/.github/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.302931 igraph-0.9.8/vendor/source/igraph/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (121)      349 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.github/ISSUE_TEMPLATE/bug_report.md
--rw-r--r--   0 runner    (1001) docker     (121)      130 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.github/ISSUE_TEMPLATE/config.yml
--rw-r--r--   0 runner    (1001) docker     (121)      427 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.github/ISSUE_TEMPLATE/feature_request.md
--rw-r--r--   0 runner    (1001) docker     (121)      721 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.github/stale.yml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.302931 igraph-0.9.8/vendor/source/igraph/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (121)     2091 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.github/workflows/build-cmake.yml
--rw-r--r--   0 runner    (1001) docker     (121)      968 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.github/workflows/codecov.yml
--rw-r--r--   0 runner    (1001) docker     (121)       84 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.gitignore
--rw-r--r--   0 runner    (1001) docker     (121)      408 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.pre-commit-config.yaml
--rw-r--r--   0 runner    (1001) docker     (121)     3168 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.travis.yml
--rw-r--r--   0 runner    (1001) docker     (121)      221 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/.zenodo.json
--rw-r--r--   0 runner    (1001) docker     (121)     7763 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/ACKNOWLEDGEMENTS.md
--rw-r--r--   0 runner    (1001) docker     (121)      192 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/AUTHORS
--rw-r--r--   0 runner    (1001) docker     (121)    30359 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/CHANGELOG.md
--rw-r--r--   0 runner    (1001) docker     (121)     4888 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     8029 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/CODE_OF_CONDUCT.md
--rw-r--r--   0 runner    (1001) docker     (121)     9386 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/CONTRIBUTING.md
--rw-r--r--   0 runner    (1001) docker     (121)    18006 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/COPYING
--rw-r--r--   0 runner    (1001) docker     (121)       57 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/ChangeLog
--rw-r--r--   0 runner    (1001) docker     (121)       19 2021-10-28 20:11:04.000000 igraph-0.9.8/vendor/source/igraph/IGRAPH_VERSION
--rw-r--r--   0 runner    (1001) docker     (121)      264 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/INSTALL
--rw-r--r--   0 runner    (1001) docker     (121)      208 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/NEWS
--rw-r--r--   0 runner    (1001) docker     (121)    62768 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/ONEWS
--rw-r--r--   0 runner    (1001) docker     (121)     1014 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/README.md
--rw-r--r--   0 runner    (1001) docker     (121)     2815 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/appveyor.yml
--rw-r--r--   0 runner    (1001) docker     (121)     3926 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/azure-pipelines.yml
--rw-r--r--   0 runner    (1001) docker     (121)      467 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/codecov.yml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.314931 igraph-0.9.8/vendor/source/igraph/doc/
--rw-r--r--   0 runner    (1001) docker     (121)     9202 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1776 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/adjlist.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1860 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/arpack.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     4296 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/attributes.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     3957 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/basicigraph.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1921 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/bibdatabase.xml
--rw-r--r--   0 runner    (1001) docker     (121)     1115 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/bipartite.xxml
--rw-r--r--   0 runner    (1001) docker     (121)    19499 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/c-docbook.re
--rw-r--r--   0 runner    (1001) docker     (121)     1574 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/cliques.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      365 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/coloring.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     2571 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/community.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      492 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/cycles.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      781 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/docbook.outlang
--rwxr-xr-x   0 runner    (1001) docker     (121)    15992 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/doxrox.py
--rw-r--r--   0 runner    (1001) docker     (121)      810 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/dqueue.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      511 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/embedding.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     2597 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/error.xxml
--rw-r--r--   0 runner    (1001) docker     (121)    22530 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/fdl.xml
--rw-r--r--   0 runner    (1001) docker     (121)     1706 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/flows.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1701 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/foreign.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     2880 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/generators.xxml
--rw-r--r--   0 runner    (1001) docker     (121)    19583 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/gpl.xml
--rw-r--r--   0 runner    (1001) docker     (121)      596 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/graphlets.xxml
--rw-r--r--   0 runner    (1001) docker     (121)    12450 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/gtk-doc.xsl
--rw-r--r--   0 runner    (1001) docker     (121)      657 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/heap.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1255 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/hrg.xxml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.314931 igraph-0.9.8/vendor/source/igraph/doc/html/
--rw-r--r--   0 runner    (1001) docker     (121)      654 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/html/home.png
--rw-r--r--   0 runner    (1001) docker     (121)      459 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/html/left.png
--rw-r--r--   0 runner    (1001) docker     (121)      472 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/html/right.png
--rw-r--r--   0 runner    (1001) docker     (121)     5619 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/html/style.css
--rw-r--r--   0 runner    (1001) docker     (121)      622 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/html/toggle.js
--rw-r--r--   0 runner    (1001) docker     (121)      406 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/html/up.png
--rw-r--r--   0 runner    (1001) docker     (121)     4725 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/igraph-docs.xml
--rw-r--r--   0 runner    (1001) docker     (121)     1684 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/igraph.3
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.318932 igraph-0.9.8/vendor/source/igraph/doc/igraphlogo/
--rw-r--r--   0 runner    (1001) docker     (121)     6138 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/igraphlogo/igraph-white.svg.gz
--rw-r--r--   0 runner    (1001) docker     (121)     6101 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/igraphlogo/igraph.svg.gz
--rw-r--r--   0 runner    (1001) docker     (121)     1952 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/igraphlogo/igraph2.svg.gz
--rw-r--r--   0 runner    (1001) docker     (121)    22058 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/installation.xml
--rw-r--r--   0 runner    (1001) docker     (121)     4684 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/introduction.xml
--rw-r--r--   0 runner    (1001) docker     (121)     2160 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/isomorphism.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     3620 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/iterators.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1961 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/layout.xxml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.318932 igraph-0.9.8/vendor/source/igraph/doc/licenses/
--rw-r--r--   0 runner    (1001) docker     (121)    21393 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-en.txt
--rw-r--r--   0 runner    (1001) docker     (121)    22395 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-fr.txt
--rw-r--r--   0 runner    (1001) docker     (121)    15220 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/licenses/gpl-2.0.txt
--rw-r--r--   0 runner    (1001) docker     (121)    32473 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/licenses/gpl-3.0.txt
--rw-r--r--   0 runner    (1001) docker     (121)    24478 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/licenses/lgpl-2.1.txt
--rw-r--r--   0 runner    (1001) docker     (121)     7652 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/licenses/lgpl-3.0.txt
--rw-r--r--   0 runner    (1001) docker     (121)      430 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/licenses.xml
--rw-r--r--   0 runner    (1001) docker     (121)     4224 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/matrix.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      341 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/memory.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1096 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/motifs.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1373 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/nongraph.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1199 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/operators.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     4251 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/pmt.xml
--rw-r--r--   0 runner    (1001) docker     (121)     1143 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/progress.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      678 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/psumtree.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1785 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/random.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      710 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/scg.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      528 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/separators.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     4656 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/sparsemat.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     2098 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/sparsematrix.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      762 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/spatialgames.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      636 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/stack.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      852 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/status.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     8810 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/structural.xxml
--rw-r--r--   0 runner    (1001) docker     (121)      893 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/strvector.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1942 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/threading.xxml
--rw-r--r--   0 runner    (1001) docker     (121)    10660 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/tutorial.xml
--rw-r--r--   0 runner    (1001) docker     (121)     5618 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/vector.xxml
--rw-r--r--   0 runner    (1001) docker     (121)     1680 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/version-greater-or-equal.xsl
--rw-r--r--   0 runner    (1001) docker     (121)      781 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/doc/visitors.xxml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.270929 igraph-0.9.8/vendor/source/igraph/etc/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.322932 igraph-0.9.8/vendor/source/igraph/etc/cmake/
--rw-r--r--   0 runner    (1001) docker     (121)      619 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/BuildType.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      162 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/CTestCustom.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)      999 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/CheckTLSSupport.cmake
--rw-r--r--   0 runner    (1001) docker     (121)    28036 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/CodeCoverage.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     2474 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/FindARPACK.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     2445 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/FindCXSparse.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1086 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/FindGLPK.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1074 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/FindGMP.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     4904 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1283 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)      959 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/JoinPaths.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1681 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/PadString.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1506 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/PreventInSourceBuilds.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      244 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/UseCCacheWhenInstalled.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1163 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/benchmark_helpers.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     3428 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/compilers.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     2490 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/cpack_install_script.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      336 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/create_igraph_version_file.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      169 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/debugging.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     5456 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/dependencies.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      257 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/features.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     1623 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/generate_tags_file.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      222 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/helpers.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      413 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/igraph-config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (121)      638 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/lto.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     2273 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/packaging.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     2699 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/pkgconfig_helpers.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     3137 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/run_legacy_test.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     3383 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/sanitizers.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     2803 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/summary.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     4433 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/test_helpers.cmake
--rw-r--r--   0 runner    (1001) docker     (121)      478 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/tls.cmake
--rw-r--r--   0 runner    (1001) docker     (121)     3831 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/etc/cmake/version.cmake
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.270929 igraph-0.9.8/vendor/source/igraph/examples/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.370934 igraph-0.9.8/vendor/source/igraph/examples/simple/
--rw-r--r--   0 runner    (1001) docker     (121)     1572 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/adjlist.c
--rw-r--r--   0 runner    (1001) docker     (121)   408798 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/ak-4102.max
--rw-r--r--   0 runner    (1001) docker     (121)    10668 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/assortativity.c
--rw-r--r--   0 runner    (1001) docker     (121)       87 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/assortativity.out
--rw-r--r--   0 runner    (1001) docker     (121)     3794 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/bellman_ford.c
--rw-r--r--   0 runner    (1001) docker     (121)      546 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/bellman_ford.out
--rw-r--r--   0 runner    (1001) docker     (121)     1110 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/blas.c
--rw-r--r--   0 runner    (1001) docker     (121)       32 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/blas.out
--rw-r--r--   0 runner    (1001) docker     (121)    13304 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes.c
--rw-r--r--   0 runner    (1001) docker     (121)    13273 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes.out
--rw-r--r--   0 runner    (1001) docker     (121)     2428 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes2.c
--rw-r--r--   0 runner    (1001) docker     (121)     6761 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes2.out
--rw-r--r--   0 runner    (1001) docker     (121)     6883 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes3.c
--rw-r--r--   0 runner    (1001) docker     (121)     7407 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes3.out
--rw-r--r--   0 runner    (1001) docker     (121)     3161 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes4.c
--rw-r--r--   0 runner    (1001) docker     (121)     2496 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes4.out
--rw-r--r--   0 runner    (1001) docker     (121)   144652 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/celegansneural.gml
--rw-r--r--   0 runner    (1001) docker     (121)     5148 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/centralization.c
--rw-r--r--   0 runner    (1001) docker     (121)     5693 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cohesive_blocks.c
--rw-r--r--   0 runner    (1001) docker     (121)      910 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/cohesive_blocks.out
--rw-r--r--   0 runner    (1001) docker     (121)     2410 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dijkstra.c
--rw-r--r--   0 runner    (1001) docker     (121)      430 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dijkstra.out
--rw-r--r--   0 runner    (1001) docker     (121)     5129 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dominator_tree.c
--rw-r--r--   0 runner    (1001) docker     (121)      344 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dominator_tree.out
--rw-r--r--   0 runner    (1001) docker     (121)     1389 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dot.c
--rw-r--r--   0 runner    (1001) docker     (121)     1546 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dot.out
--rw-r--r--   0 runner    (1001) docker     (121)     3075 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dqueue.c
--rw-r--r--   0 runner    (1001) docker     (121)        9 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/dqueue.out
--rw-r--r--   0 runner    (1001) docker     (121)       92 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/edgelist1.dl
--rw-r--r--   0 runner    (1001) docker     (121)      105 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/edgelist2.dl
--rw-r--r--   0 runner    (1001) docker     (121)      145 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/edgelist3.dl
--rw-r--r--   0 runner    (1001) docker     (121)       98 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/edgelist4.dl
--rw-r--r--   0 runner    (1001) docker     (121)      129 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/edgelist5.dl
--rw-r--r--   0 runner    (1001) docker     (121)      172 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/edgelist6.dl
--rw-r--r--   0 runner    (1001) docker     (121)       44 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/edgelist7.dl
--rw-r--r--   0 runner    (1001) docker     (121)     2422 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/eigenvector_centrality.c
--rw-r--r--   0 runner    (1001) docker     (121)      803 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/eigenvector_centrality.out
--rw-r--r--   0 runner    (1001) docker     (121)     2077 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/even_tarjan.c
--rw-r--r--   0 runner    (1001) docker     (121)     3469 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/flow.c
--rw-r--r--   0 runner    (1001) docker     (121)     8346 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/flow2.c
--rw-r--r--   0 runner    (1001) docker     (121)      221 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/flow2.out
--rw-r--r--   0 runner    (1001) docker     (121)     1419 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/foreign.c
--rw-r--r--   0 runner    (1001) docker     (121)       72 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/foreign.out
--rw-r--r--   0 runner    (1001) docker     (121)       65 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/fullmatrix1.dl
--rw-r--r--   0 runner    (1001) docker     (121)      116 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/fullmatrix2.dl
--rw-r--r--   0 runner    (1001) docker     (121)      116 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/fullmatrix3.dl
--rw-r--r--   0 runner    (1001) docker     (121)      149 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/fullmatrix4.dl
--rw-r--r--   0 runner    (1001) docker     (121)     1405 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/gml.c
--rw-r--r--   0 runner    (1001) docker     (121)     4644 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/gml.out
--rw-r--r--   0 runner    (1001) docker     (121)     1029 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-default-attrs.xml
--rw-r--r--   0 runner    (1001) docker     (121)    15944 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-hsa05010.xml
--rw-r--r--   0 runner    (1001) docker     (121)      282 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-lenient.xml
--rw-r--r--   0 runner    (1001) docker     (121)     1100 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-malformed.xml
--rw-r--r--   0 runner    (1001) docker     (121)      410 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-namespace.xml
--rw-r--r--   0 runner    (1001) docker     (121)     5625 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/graphml.c
--rw-r--r--   0 runner    (1001) docker     (121)      659 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/graphml.out
--rw-r--r--   0 runner    (1001) docker     (121)     2569 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_add_edges.c
--rw-r--r--   0 runner    (1001) docker     (121)       75 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_add_edges.out
--rw-r--r--   0 runner    (1001) docker     (121)     1747 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_add_vertices.c
--rw-r--r--   0 runner    (1001) docker     (121)      931 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_adjacency.c
--rw-r--r--   0 runner    (1001) docker     (121)     5776 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.c
--rw-r--r--   0 runner    (1001) docker     (121)     1149 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.out
--rw-r--r--   0 runner    (1001) docker     (121)     1543 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_atlas.c
--rw-r--r--   0 runner    (1001) docker     (121)      115 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_atlas.out
--rw-r--r--   0 runner    (1001) docker     (121)      610 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_average_path_length.c
--rw-r--r--   0 runner    (1001) docker     (121)     3760 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_barabasi_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     3647 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_barabasi_game2.c
--rw-r--r--   0 runner    (1001) docker     (121)     2698 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs.c
--rw-r--r--   0 runner    (1001) docker     (121)      293 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs.out
--rw-r--r--   0 runner    (1001) docker     (121)     1930 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs_callback.c
--rw-r--r--   0 runner    (1001) docker     (121)       54 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs_callback.out
--rw-r--r--   0 runner    (1001) docker     (121)     1559 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs_simple.c
--rw-r--r--   0 runner    (1001) docker     (121)       66 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs_simple.out
--rw-r--r--   0 runner    (1001) docker     (121)     2726 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_biconnected_components.c
--rw-r--r--   0 runner    (1001) docker     (121)       44 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_biconnected_components.out
--rw-r--r--   0 runner    (1001) docker     (121)     2145 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bipartite_create.c
--rw-r--r--   0 runner    (1001) docker     (121)       32 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bipartite_create.out
--rw-r--r--   0 runner    (1001) docker     (121)     5730 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bipartite_projection.c
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_cliques.c
--rw-r--r--   0 runner    (1001) docker     (121)      329 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_cliques.out
--rw-r--r--   0 runner    (1001) docker     (121)     1609 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_cocitation.c
--rw-r--r--   0 runner    (1001) docker     (121)      115 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_cocitation.out
--rw-r--r--   0 runner    (1001) docker     (121)     1521 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_coloring.c
--rw-r--r--   0 runner    (1001) docker     (121)     7199 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.c
--rw-r--r--   0 runner    (1001) docker     (121)     1082 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.out
--rw-r--r--   0 runner    (1001) docker     (121)     7640 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.c
--rw-r--r--   0 runner    (1001) docker     (121)      731 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.out
--rw-r--r--   0 runner    (1001) docker     (121)     3482 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_fluid_communities.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_fluid_communities.out
--rw-r--r--   0 runner    (1001) docker     (121)     1801 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_label_propagation.c
--rw-r--r--   0 runner    (1001) docker     (121)       50 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_label_propagation.out
--rw-r--r--   0 runner    (1001) docker     (121)     4112 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_leading_eigenvector.c
--rw-r--r--   0 runner    (1001) docker     (121)      153 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_leading_eigenvector.out
--rw-r--r--   0 runner    (1001) docker     (121)     2877 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_leiden.c
--rw-r--r--   0 runner    (1001) docker     (121)      317 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_leiden.out
--rw-r--r--   0 runner    (1001) docker     (121)     3783 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_multilevel.c
--rw-r--r--   0 runner    (1001) docker     (121)      956 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_multilevel.out
--rw-r--r--   0 runner    (1001) docker     (121)     3967 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_optimal_modularity.c
--rw-r--r--   0 runner    (1001) docker     (121)     3132 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_complementer.c
--rw-r--r--   0 runner    (1001) docker     (121)      348 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_complementer.out
--rw-r--r--   0 runner    (1001) docker     (121)     3589 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_compose.c
--rw-r--r--   0 runner    (1001) docker     (121)       56 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_compose.out
--rw-r--r--   0 runner    (1001) docker     (121)     5480 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_convex_hull.c
--rw-r--r--   0 runner    (1001) docker     (121)      485 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_convex_hull.out
--rw-r--r--   0 runner    (1001) docker     (121)     1513 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_copy.c
--rw-r--r--   0 runner    (1001) docker     (121)     2359 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_create.c
--rw-r--r--   0 runner    (1001) docker     (121)     1749 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_decompose.c
--rw-r--r--   0 runner    (1001) docker     (121)       72 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_decompose.out
--rw-r--r--   0 runner    (1001) docker     (121)     6523 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_degree.c
--rw-r--r--   0 runner    (1001) docker     (121)      115 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_degree.out
--rw-r--r--   0 runner    (1001) docker     (121)     2905 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_degree_sequence_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      140 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_degree_sequence_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     2349 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_delete_edges.c
--rw-r--r--   0 runner    (1001) docker     (121)     2064 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_delete_vertices.c
--rw-r--r--   0 runner    (1001) docker     (121)     9972 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_deterministic_optimal_imitation.c
--rw-r--r--   0 runner    (1001) docker     (121)     1896 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_diameter.c
--rw-r--r--   0 runner    (1001) docker     (121)       46 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_diameter.out
--rw-r--r--   0 runner    (1001) docker     (121)     4478 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_difference.c
--rw-r--r--   0 runner    (1001) docker     (121)      201 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_difference.out
--rw-r--r--   0 runner    (1001) docker     (121)     2278 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_disjoint_union.c
--rw-r--r--   0 runner    (1001) docker     (121)      134 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_disjoint_union.out
--rw-r--r--   0 runner    (1001) docker     (121)      667 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_eccentricity.c
--rw-r--r--   0 runner    (1001) docker     (121)       60 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_eccentricity.out
--rw-r--r--   0 runner    (1001) docker     (121)     2017 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_empty.c
--rw-r--r--   0 runner    (1001) docker     (121)      904 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_erdos_renyi_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     2251 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_es_pairs.c
--rw-r--r--   0 runner    (1001) docker     (121)     2675 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_feedback_arc_set.c
--rw-r--r--   0 runner    (1001) docker     (121)       11 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_feedback_arc_set.out
--rw-r--r--   0 runner    (1001) docker     (121)     3714 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_feedback_arc_set_ip.c
--rw-r--r--   0 runner    (1001) docker     (121)       22 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_feedback_arc_set_ip.out
--rw-r--r--   0 runner    (1001) docker     (121)     3545 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_fisher_yates_shuffle.c
--rw-r--r--   0 runner    (1001) docker     (121)      485 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_free.c
--rw-r--r--   0 runner    (1001) docker     (121)     2312 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_full.c
--rw-r--r--   0 runner    (1001) docker     (121)      265 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_full.out
--rw-r--r--   0 runner    (1001) docker     (121)     7089 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_all_shortest_paths_dijkstra.c
--rw-r--r--   0 runner    (1001) docker     (121)      147 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_all_shortest_paths_dijkstra.out
--rw-r--r--   0 runner    (1001) docker     (121)     4515 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_eid.c
--rw-r--r--   0 runner    (1001) docker     (121)       38 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_eid.out
--rw-r--r--   0 runner    (1001) docker     (121)     7365 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_eids.c
--rw-r--r--   0 runner    (1001) docker     (121)       17 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_eids.out
--rw-r--r--   0 runner    (1001) docker     (121)     4149 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_shortest_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)       88 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_shortest_paths.out
--rw-r--r--   0 runner    (1001) docker     (121)     7686 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_shortest_paths_dijkstra.c
--rw-r--r--   0 runner    (1001) docker     (121)      116 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_shortest_paths_dijkstra.out
--rw-r--r--   0 runner    (1001) docker     (121)     1686 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_girth.c
--rw-r--r--   0 runner    (1001) docker     (121)     1410 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_grg_game.c
--rw-r--r--   0 runner    (1001) docker     (121)       51 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_grg_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     2661 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_has_multiple.c
--rw-r--r--   0 runner    (1001) docker     (121)     2745 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_independent_sets.c
--rw-r--r--   0 runner    (1001) docker     (121)      340 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_independent_sets.out
--rw-r--r--   0 runner    (1001) docker     (121)     4003 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_intersection.c
--rw-r--r--   0 runner    (1001) docker     (121)       27 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_intersection.out
--rw-r--r--   0 runner    (1001) docker     (121)     1167 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_directed.c
--rw-r--r--   0 runner    (1001) docker     (121)     1727 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_loop.c
--rw-r--r--   0 runner    (1001) docker     (121)       34 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_loop.out
--rw-r--r--   0 runner    (1001) docker     (121)     2251 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_minimal_separator.c
--rw-r--r--   0 runner    (1001) docker     (121)     1788 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_multiple.c
--rw-r--r--   0 runner    (1001) docker     (121)       46 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_multiple.out
--rw-r--r--   0 runner    (1001) docker     (121)     2632 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_separator.c
--rw-r--r--   0 runner    (1001) docker     (121)     9989 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_isomorphic_vf2.c
--rw-r--r--   0 runner    (1001) docker     (121)     2244 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_knn.c
--rw-r--r--   0 runner    (1001) docker     (121)     8046 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dgeev.c
--rw-r--r--   0 runner    (1001) docker     (121)     6902 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dgeevx.c
--rw-r--r--   0 runner    (1001) docker     (121)     4194 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dgesv.c
--rw-r--r--   0 runner    (1001) docker     (121)       41 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dgesv.out
--rw-r--r--   0 runner    (1001) docker     (121)     6574 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dsyevr.c
--rw-r--r--   0 runner    (1001) docker     (121)     6878 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_laplacian.c
--rw-r--r--   0 runner    (1001) docker     (121)     1040 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_laplacian.out
--rw-r--r--   0 runner    (1001) docker     (121)     1433 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_layout_reingold_tilford.c
--rw-r--r--   0 runner    (1001) docker     (121)      231 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_layout_reingold_tilford.in
--rw-r--r--   0 runner    (1001) docker     (121)     2196 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lcf.c
--rw-r--r--   0 runner    (1001) docker     (121)     4708 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_maximal_cliques.c
--rw-r--r--   0 runner    (1001) docker     (121)      528 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_maximal_cliques.out
--rw-r--r--   0 runner    (1001) docker     (121)    10009 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_maximum_bipartite_matching.c
--rw-r--r--   0 runner    (1001) docker     (121)     3682 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_mincut.c
--rw-r--r--   0 runner    (1001) docker     (121)      278 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_mincut.out
--rw-r--r--   0 runner    (1001) docker     (121)     1765 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimal_separators.c
--rw-r--r--   0 runner    (1001) docker     (121)     5541 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimum_size_separators.c
--rw-r--r--   0 runner    (1001) docker     (121)      174 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimum_size_separators.out
--rw-r--r--   0 runner    (1001) docker     (121)     2513 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimum_spanning_tree.c
--rw-r--r--   0 runner    (1001) docker     (121)      264 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimum_spanning_tree.out
--rw-r--r--   0 runner    (1001) docker     (121)     2166 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_motifs_randesu.c
--rw-r--r--   0 runner    (1001) docker     (121)      165 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_motifs_randesu.out
--rw-r--r--   0 runner    (1001) docker     (121)     2110 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_neighbors.c
--rw-r--r--   0 runner    (1001) docker     (121)       19 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_neighbors.out
--rw-r--r--   0 runner    (1001) docker     (121)      964 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_pagerank.c
--rw-r--r--   0 runner    (1001) docker     (121)    22341 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_power_law_fit.c
--rw-r--r--   0 runner    (1001) docker     (121)      655 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_power_law_fit.out
--rw-r--r--   0 runner    (1001) docker     (121)     1497 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_radius.c
--rw-r--r--   0 runner    (1001) docker     (121)     6305 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_random_sample.c
--rw-r--r--   0 runner    (1001) docker     (121)     2042 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_dl.c
--rw-r--r--   0 runner    (1001) docker     (121)      619 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_dl.out
--rw-r--r--   0 runner    (1001) docker     (121)     1197 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.c
--rw-r--r--   0 runner    (1001) docker     (121)    11670 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.out
--rw-r--r--   0 runner    (1001) docker     (121)       42 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_lgl-1.lgl
--rw-r--r--   0 runner    (1001) docker     (121)       47 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_lgl-2.lgl
--rw-r--r--   0 runner    (1001) docker     (121)       10 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_lgl-3.lgl
--rw-r--r--   0 runner    (1001) docker     (121)     2329 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_lgl.c
--rw-r--r--   0 runner    (1001) docker     (121)       48 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_lgl.out
--rw-r--r--   0 runner    (1001) docker     (121)     1794 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_reciprocity.c
--rw-r--r--   0 runner    (1001) docker     (121)     1459 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_ring.c
--rw-r--r--   0 runner    (1001) docker     (121)       83 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_ring.out
--rw-r--r--   0 runner    (1001) docker     (121)    11716 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_roulette_wheel_imitation.c
--rw-r--r--   0 runner    (1001) docker     (121)     2591 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping.c
--rw-r--r--   0 runner    (1001) docker     (121)     2000 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping.out
--rw-r--r--   0 runner    (1001) docker     (121)     2755 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping2.c
--rw-r--r--   0 runner    (1001) docker     (121)       80 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping2.out
--rw-r--r--   0 runner    (1001) docker     (121)     3669 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping3.c
--rw-r--r--   0 runner    (1001) docker     (121)       80 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping3.out
--rw-r--r--   0 runner    (1001) docker     (121)     3109 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping4.c
--rw-r--r--   0 runner    (1001) docker     (121)       80 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping4.out
--rw-r--r--   0 runner    (1001) docker     (121)     3794 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.c
--rw-r--r--   0 runner    (1001) docker     (121)     1070 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.out
--rw-r--r--   0 runner    (1001) docker     (121)     4558 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.c
--rw-r--r--   0 runner    (1001) docker     (121)     1053 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.out
--rw-r--r--   0 runner    (1001) docker     (121)     4046 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.c
--rw-r--r--   0 runner    (1001) docker     (121)      769 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.out
--rw-r--r--   0 runner    (1001) docker     (121)     6833 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_similarity.c
--rw-r--r--   0 runner    (1001) docker     (121)      888 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_similarity.out
--rw-r--r--   0 runner    (1001) docker     (121)     3149 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_simplify.c
--rw-r--r--   0 runner    (1001) docker     (121)       40 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_simplify.out
--rw-r--r--   0 runner    (1001) docker     (121)     1090 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_small.c
--rw-r--r--   0 runner    (1001) docker     (121)       20 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_small.out
--rw-r--r--   0 runner    (1001) docker     (121)     5478 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat.c
--rw-r--r--   0 runner    (1001) docker     (121)     3684 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat.out
--rw-r--r--   0 runner    (1001) docker     (121)     8530 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat3.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat3.out
--rw-r--r--   0 runner    (1001) docker     (121)     8044 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat4.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat4.out
--rw-r--r--   0 runner    (1001) docker     (121)     2068 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat6.c
--rw-r--r--   0 runner    (1001) docker     (121)     2261 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat7.c
--rw-r--r--   0 runner    (1001) docker     (121)     6184 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat8.c
--rw-r--r--   0 runner    (1001) docker     (121)     1138 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_star.c
--rw-r--r--   0 runner    (1001) docker     (121)       24 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_star.out
--rw-r--r--   0 runner    (1001) docker     (121)     9772 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_stochastic_imitation.c
--rw-r--r--   0 runner    (1001) docker     (121)     6045 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_strvector.c
--rw-r--r--   0 runner    (1001) docker     (121)      594 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_strvector.out
--rw-r--r--   0 runner    (1001) docker     (121)    13498 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_subisomorphic_lad.c
--rw-r--r--   0 runner    (1001) docker     (121)      310 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_subisomorphic_lad.out
--rw-r--r--   0 runner    (1001) docker     (121)     1692 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_to_undirected.c
--rw-r--r--   0 runner    (1001) docker     (121)      241 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_to_undirected.out
--rw-r--r--   0 runner    (1001) docker     (121)     1575 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_topological_sorting.c
--rw-r--r--   0 runner    (1001) docker     (121)       33 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_topological_sorting.out
--rw-r--r--   0 runner    (1001) docker     (121)     3093 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_transitivity.c
--rw-r--r--   0 runner    (1001) docker     (121)     1368 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_tree.c
--rw-r--r--   0 runner    (1001) docker     (121)       44 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_tree.out
--rw-r--r--   0 runner    (1001) docker     (121)     4859 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_union.c
--rw-r--r--   0 runner    (1001) docker     (121)      318 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_union.out
--rw-r--r--   0 runner    (1001) docker     (121)     1400 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vector_ptr_sort.c
--rw-r--r--   0 runner    (1001) docker     (121)     1204 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_version.c
--rw-r--r--   0 runner    (1001) docker     (121)     1875 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_nonadj.c
--rw-r--r--   0 runner    (1001) docker     (121)       25 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_nonadj.out
--rw-r--r--   0 runner    (1001) docker     (121)     1431 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_seq.c
--rw-r--r--   0 runner    (1001) docker     (121)       23 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_seq.out
--rw-r--r--   0 runner    (1001) docker     (121)     2324 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_vector.c
--rw-r--r--   0 runner    (1001) docker     (121)       17 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_vector.out
--rw-r--r--   0 runner    (1001) docker     (121)     3017 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_weighted_adjacency.c
--rw-r--r--   0 runner    (1001) docker     (121)      270 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_weighted_adjacency.out
--rw-r--r--   0 runner    (1001) docker     (121)     1151 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_write_graph_lgl.c
--rw-r--r--   0 runner    (1001) docker     (121)      184 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_write_graph_lgl.out
--rw-r--r--   0 runner    (1001) docker     (121)     2539 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_write_graph_pajek.c
--rw-r--r--   0 runner    (1001) docker     (121)      435 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_write_graph_pajek.out
--rw-r--r--   0 runner    (1001) docker     (121)     5002 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/iso_b03_m1000.A00
--rw-r--r--   0 runner    (1001) docker     (121)     4194 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/karate.gml
--rw-r--r--   0 runner    (1001) docker     (121)     1011 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/links.net
--rw-r--r--   0 runner    (1001) docker     (121)       90 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/nodelist1.dl
--rw-r--r--   0 runner    (1001) docker     (121)       98 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/nodelist2.dl
--rw-r--r--   0 runner    (1001) docker     (121)      881 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/random_seed.c
--rw-r--r--   0 runner    (1001) docker     (121)     6006 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/scg.c
--rw-r--r--   0 runner    (1001) docker     (121)     3686 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/scg.out
--rw-r--r--   0 runner    (1001) docker     (121)     1936 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/test.gxl
--rw-r--r--   0 runner    (1001) docker     (121)     2431 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/walktrap.c
--rw-r--r--   0 runner    (1001) docker     (121)      298 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/simple/walktrap.out
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.370934 igraph-0.9.8/vendor/source/igraph/examples/tutorial/
--rw-r--r--   0 runner    (1001) docker     (121)      531 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/tutorial/tutorial1.c
--rw-r--r--   0 runner    (1001) docker     (121)      985 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/tutorial/tutorial2.c
--rw-r--r--   0 runner    (1001) docker     (121)     1865 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/examples/tutorial/tutorial3.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.370934 igraph-0.9.8/vendor/source/igraph/fuzzing/
--rw-r--r--   0 runner    (1001) docker     (121)      202 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/fuzzing/README.md
--rwxr-xr-x   0 runner    (1001) docker     (121)      503 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/fuzzing/build.sh
--rw-r--r--   0 runner    (1001) docker     (121)     1772 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/fuzzing/read_gml_fuzzer.c
--rw-r--r--   0 runner    (1001) docker     (121)      329 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/igraph.pc.in
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.382934 igraph-0.9.8/vendor/source/igraph/include/
--rw-r--r--   0 runner    (1001) docker     (121)     2934 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph.h
--rw-r--r--   0 runner    (1001) docker     (121)     8341 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_adjlist.h
--rw-r--r--   0 runner    (1001) docker     (121)    14434 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_arpack.h
--rw-r--r--   0 runner    (1001) docker     (121)     1647 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_array.h
--rw-r--r--   0 runner    (1001) docker     (121)     2379 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_array_pmt.h
--rw-r--r--   0 runner    (1001) docker     (121)    35378 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_attributes.h
--rw-r--r--   0 runner    (1001) docker     (121)     4693 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_bipartite.h
--rw-r--r--   0 runner    (1001) docker     (121)     2759 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_blas.h
--rw-r--r--   0 runner    (1001) docker     (121)    11747 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_centrality.h
--rw-r--r--   0 runner    (1001) docker     (121)     5945 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_cliques.h
--rw-r--r--   0 runner    (1001) docker     (121)     3160 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_cocitation.h
--rw-r--r--   0 runner    (1001) docker     (121)     1428 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_cohesive_blocks.h
--rw-r--r--   0 runner    (1001) docker     (121)     1501 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_coloring.h
--rw-r--r--   0 runner    (1001) docker     (121)    14212 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_community.h
--rw-r--r--   0 runner    (1001) docker     (121)     5115 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_complex.h
--rw-r--r--   0 runner    (1001) docker     (121)     2698 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_components.h
--rw-r--r--   0 runner    (1001) docker     (121)     6898 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_constants.h
--rw-r--r--   0 runner    (1001) docker     (121)     4210 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_constructors.h
--rw-r--r--   0 runner    (1001) docker     (121)     2674 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_conversion.h
--rw-r--r--   0 runner    (1001) docker     (121)     3259 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_datatype.h
--rw-r--r--   0 runner    (1001) docker     (121)      567 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_decls.h
--rw-r--r--   0 runner    (1001) docker     (121)     1998 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_dqueue.h
--rw-r--r--   0 runner    (1001) docker     (121)     2270 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_dqueue_pmt.h
--rw-r--r--   0 runner    (1001) docker     (121)     4901 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_eigen.h
--rw-r--r--   0 runner    (1001) docker     (121)     2983 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_embedding.h
--rw-r--r--   0 runner    (1001) docker     (121)     2259 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_epidemics.h
--rw-r--r--   0 runner    (1001) docker     (121)    38071 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_error.h
--rw-r--r--   0 runner    (1001) docker     (121)     1376 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_eulerian.h
--rw-r--r--   0 runner    (1001) docker     (121)     7880 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_flow.h
--rw-r--r--   0 runner    (1001) docker     (121)     4417 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_foreign.h
--rw-r--r--   0 runner    (1001) docker     (121)    13455 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_games.h
--rw-r--r--   0 runner    (1001) docker     (121)     2521 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_graphicality.h
--rw-r--r--   0 runner    (1001) docker     (121)     2023 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_graphlets.h
--rw-r--r--   0 runner    (1001) docker     (121)     2110 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_heap.h
--rw-r--r--   0 runner    (1001) docker     (121)     1735 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_heap_pmt.h
--rw-r--r--   0 runner    (1001) docker     (121)     4658 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_hrg.h
--rw-r--r--   0 runner    (1001) docker     (121)     5721 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_interface.h
--rw-r--r--   0 runner    (1001) docker     (121)     4901 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_interrupt.h
--rw-r--r--   0 runner    (1001) docker     (121)    13233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_iterators.h
--rw-r--r--   0 runner    (1001) docker     (121)     4700 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_lapack.h
--rw-r--r--   0 runner    (1001) docker     (121)    14458 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_layout.h
--rw-r--r--   0 runner    (1001) docker     (121)      312 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_lsap.h
--rw-r--r--   0 runner    (1001) docker     (121)     2404 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_matching.h
--rw-r--r--   0 runner    (1001) docker     (121)     2905 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_matrix.h
--rw-r--r--   0 runner    (1001) docker     (121)    13431 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_matrix_pmt.h
--rw-r--r--   0 runner    (1001) docker     (121)     1462 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_memory.h
--rw-r--r--   0 runner    (1001) docker     (121)     2883 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_microscopic_update.h
--rw-r--r--   0 runner    (1001) docker     (121)     1893 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_mixing.h
--rw-r--r--   0 runner    (1001) docker     (121)     4287 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_motifs.h
--rw-r--r--   0 runner    (1001) docker     (121)     1936 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_neighborhood.h
--rw-r--r--   0 runner    (1001) docker     (121)     4109 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_nongraph.h
--rw-r--r--   0 runner    (1001) docker     (121)     4615 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_operators.h
--rw-r--r--   0 runner    (1001) docker     (121)    10998 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_paths.h
--rw-r--r--   0 runner    (1001) docker     (121)     4130 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_pmt.h
--rw-r--r--   0 runner    (1001) docker     (121)     2288 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_pmt_off.h
--rw-r--r--   0 runner    (1001) docker     (121)     6926 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_progress.h
--rw-r--r--   0 runner    (1001) docker     (121)     1863 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_psumtree.h
--rw-r--r--   0 runner    (1001) docker     (121)     1324 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_qsort.h
--rw-r--r--   0 runner    (1001) docker     (121)     5226 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_random.h
--rw-r--r--   0 runner    (1001) docker     (121)     3100 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_scan.h
--rw-r--r--   0 runner    (1001) docker     (121)     7200 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_scg.h
--rw-r--r--   0 runner    (1001) docker     (121)     1888 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_separators.h
--rw-r--r--   0 runner    (1001) docker     (121)    15198 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_sparsemat.h
--rw-r--r--   0 runner    (1001) docker     (121)     5509 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_spmatrix.h
--rw-r--r--   0 runner    (1001) docker     (121)     2084 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_stack.h
--rw-r--r--   0 runner    (1001) docker     (121)     1952 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_stack_pmt.h
--rw-r--r--   0 runner    (1001) docker     (121)     4285 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_statusbar.h
--rw-r--r--   0 runner    (1001) docker     (121)     7018 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_structural.h
--rw-r--r--   0 runner    (1001) docker     (121)     4095 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_strvector.h
--rw-r--r--   0 runner    (1001) docker     (121)     1471 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_threading.h.in
--rw-r--r--   0 runner    (1001) docker     (121)    15349 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_topology.h
--rw-r--r--   0 runner    (1001) docker     (121)     3158 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_transitivity.h
--rw-r--r--   0 runner    (1001) docker     (121)     2407 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_types.h
--rw-r--r--   0 runner    (1001) docker     (121)     5830 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_vector.h
--rw-r--r--   0 runner    (1001) docker     (121)    14747 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_vector_pmt.h
--rw-r--r--   0 runner    (1001) docker     (121)     4850 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_vector_ptr.h
--rw-r--r--   0 runner    (1001) docker     (121)     1063 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_vector_type.h
--rw-r--r--   0 runner    (1001) docker     (121)     1463 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_version.h.in
--rw-r--r--   0 runner    (1001) docker     (121)     5404 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/include/igraph_visitor.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.270929 igraph-0.9.8/vendor/source/igraph/msvc/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.382934 igraph-0.9.8/vendor/source/igraph/msvc/include/
--rw-r--r--   0 runner    (1001) docker     (121)      222 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/msvc/include/unistd.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.382934 igraph-0.9.8/vendor/source/igraph/src/
--rw-r--r--   0 runner    (1001) docker     (121)    12508 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.382934 igraph-0.9.8/vendor/source/igraph/src/centrality/
--rw-r--r--   0 runner    (1001) docker     (121)    41555 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/betweenness.c
--rw-r--r--   0 runner    (1001) docker     (121)    60559 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/centrality_other.c
--rw-r--r--   0 runner    (1001) docker     (121)    23479 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/centralization.c
--rw-r--r--   0 runner    (1001) docker     (121)    34323 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/closeness.c
--rw-r--r--   0 runner    (1001) docker     (121)     5272 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/coreness.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.386935 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/
--rw-r--r--   0 runner    (1001) docker     (121)     1087 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)      202 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack.h
--rw-r--r--   0 runner    (1001) docker     (121)    10028 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1287 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)      533 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_csc.h
--rw-r--r--   0 runner    (1001) docker     (121)      212 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_csr.h
--rw-r--r--   0 runner    (1001) docker     (121)      230 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_edge_list.h
--rw-r--r--   0 runner    (1001) docker     (121)     4035 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_igraph_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      502 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_igraph_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)     2070 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      754 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)      333 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)     2445 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      858 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)     7168 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1154 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)     4108 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      955 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)      173 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_result.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      573 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_result.h
--rw-r--r--   0 runner    (1001) docker     (121)    30277 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_solver.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     6969 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_solver.h
--rw-r--r--   0 runner    (1001) docker     (121)     1421 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_utils.cpp
--rw-r--r--   0 runner    (1001) docker     (121)      972 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_utils.h
--rw-r--r--   0 runner    (1001) docker     (121)     4768 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     1517 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/centrality/prpack_internal.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.386935 igraph-0.9.8/vendor/source/igraph/src/cliques/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.390935 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/
--rw-r--r--   0 runner    (1001) docker     (121)      644 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     2042 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/README
--rw-r--r--   0 runner    (1001) docker     (121)    45839 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquer.c
--rw-r--r--   0 runner    (1001) docker     (121)     2281 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquer.h
--rw-r--r--   0 runner    (1001) docker     (121)    16379 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquer_graph.c
--rw-r--r--   0 runner    (1001) docker     (121)     1930 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquerconf.h
--rw-r--r--   0 runner    (1001) docker     (121)     2043 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/graph.h
--rw-r--r--   0 runner    (1001) docker     (121)      995 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/misc.h
--rw-r--r--   0 runner    (1001) docker     (121)     8965 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/reorder.c
--rw-r--r--   0 runner    (1001) docker     (121)      980 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/reorder.h
--rw-r--r--   0 runner    (1001) docker     (121)     9396 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/set.h
--rw-r--r--   0 runner    (1001) docker     (121)     1264 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)    11062 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer_wrapper.c
--rw-r--r--   0 runner    (1001) docker     (121)    54671 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/cliques.c
--rw-r--r--   0 runner    (1001) docker     (121)    31566 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/glet.c
--rw-r--r--   0 runner    (1001) docker     (121)    20089 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/maximal_cliques.c
--rw-r--r--   0 runner    (1001) docker     (121)    14753 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/cliques/maximal_cliques_template.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.390935 igraph-0.9.8/vendor/source/igraph/src/community/
--rw-r--r--   0 runner    (1001) docker     (121)    31186 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/community_misc.c
--rw-r--r--   0 runner    (1001) docker     (121)    30166 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/edge_betweenness.c
--rw-r--r--   0 runner    (1001) docker     (121)    44948 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/fast_modularity.c
--rw-r--r--   0 runner    (1001) docker     (121)    11599 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/fluid.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.390935 igraph-0.9.8/vendor/source/igraph/src/community/infomap/
--rw-r--r--   0 runner    (1001) docker     (121)    12060 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap.cc
--rw-r--r--   0 runner    (1001) docker     (121)    12951 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.cc
--rw-r--r--   0 runner    (1001) docker     (121)     2111 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.h
--rw-r--r--   0 runner    (1001) docker     (121)    22807 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Greedy.cc
--rw-r--r--   0 runner    (1001) docker     (121)     2207 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Greedy.h
--rw-r--r--   0 runner    (1001) docker     (121)     2243 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Node.cc
--rw-r--r--   0 runner    (1001) docker     (121)     1386 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Node.h
--rw-r--r--   0 runner    (1001) docker     (121)    13303 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/label_propagation.c
--rw-r--r--   0 runner    (1001) docker     (121)    40693 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/leading_eigenvector.c
--rw-r--r--   0 runner    (1001) docker     (121)    46262 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/leiden.c
--rw-r--r--   0 runner    (1001) docker     (121)    28301 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/louvain.c
--rw-r--r--   0 runner    (1001) docker     (121)    14989 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/modularity.c
--rw-r--r--   0 runner    (1001) docker     (121)     9617 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/optimal_modularity.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.394935 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/
--rw-r--r--   0 runner    (1001) docker     (121)     7009 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetDataTypes.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    24957 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetDataTypes.h
--rw-r--r--   0 runner    (1001) docker     (121)     9889 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetRoutines.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2523 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetRoutines.h
--rw-r--r--   0 runner    (1001) docker     (121)    26029 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/clustertool.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    85538 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/pottsmodel_2.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     7715 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/spinglass/pottsmodel_2.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.394935 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/
--rw-r--r--   0 runner    (1001) docker     (121)     6743 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    33480 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_communities.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     7048 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_communities.h
--rw-r--r--   0 runner    (1001) docker     (121)     6798 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3608 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)     6741 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_heap.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4499 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_heap.h
--rw-r--r--   0 runner    (1001) docker     (121)      940 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/config.h.in
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.394935 igraph-0.9.8/vendor/source/igraph/src/connectivity/
--rw-r--r--   0 runner    (1001) docker     (121)    21890 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/connectivity/cohesive_blocks.c
--rw-r--r--   0 runner    (1001) docker     (121)    52448 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/connectivity/components.c
--rw-r--r--   0 runner    (1001) docker     (121)    31712 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/connectivity/separators.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.394935 igraph-0.9.8/vendor/source/igraph/src/constructors/
--rw-r--r--   0 runner    (1001) docker     (121)    22971 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/adjacency.c
--rw-r--r--   0 runner    (1001) docker     (121)    96579 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/atlas-edges.h
--rw-r--r--   0 runner    (1001) docker     (121)     2818 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/atlas.c
--rw-r--r--   0 runner    (1001) docker     (121)     5033 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/basic_constructors.c
--rw-r--r--   0 runner    (1001) docker     (121)     3227 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/de_bruijn.c
--rw-r--r--   0 runner    (1001) docker     (121)    21986 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/famous.c
--rw-r--r--   0 runner    (1001) docker     (121)     5499 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/full.c
--rw-r--r--   0 runner    (1001) docker     (121)     6187 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/kautz.c
--rw-r--r--   0 runner    (1001) docker     (121)     4654 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/lcf.c
--rw-r--r--   0 runner    (1001) docker     (121)     5648 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/linegraph.c
--rw-r--r--   0 runner    (1001) docker     (121)     3619 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/prufer.c
--rw-r--r--   0 runner    (1001) docker     (121)    17104 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/constructors/regular.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.410936 igraph-0.9.8/vendor/source/igraph/src/core/
--rw-r--r--   0 runner    (1001) docker     (121)     1409 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/array.c
--rw-r--r--   0 runner    (1001) docker     (121)     2743 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/array.pmt
--rw-r--r--   0 runner    (1001) docker     (121)     6083 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/buckets.c
--rw-r--r--   0 runner    (1001) docker     (121)     2784 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/buckets.h
--rw-r--r--   0 runner    (1001) docker     (121)     5771 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/cutheap.c
--rw-r--r--   0 runner    (1001) docker     (121)     2291 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/cutheap.h
--rw-r--r--   0 runner    (1001) docker     (121)     1495 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/dqueue.c
--rw-r--r--   0 runner    (1001) docker     (121)     9722 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/dqueue.pmt
--rw-r--r--   0 runner    (1001) docker     (121)    13880 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/error.c
--rw-r--r--   0 runner    (1001) docker     (121)     2134 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/estack.c
--rw-r--r--   0 runner    (1001) docker     (121)     1789 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/estack.h
--rw-r--r--   0 runner    (1001) docker     (121)      770 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/exceptions.h
--rw-r--r--   0 runner    (1001) docker     (121)     2581 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/fixed_vectorlist.c
--rw-r--r--   0 runner    (1001) docker     (121)     1663 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/fixed_vectorlist.h
--rw-r--r--   0 runner    (1001) docker     (121)    10881 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/grid.c
--rw-r--r--   0 runner    (1001) docker     (121)     3022 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/grid.h
--rw-r--r--   0 runner    (1001) docker     (121)     4344 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/hashtable.c
--rw-r--r--   0 runner    (1001) docker     (121)     2216 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/hashtable.h
--rw-r--r--   0 runner    (1001) docker     (121)     1743 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/heap.c
--rw-r--r--   0 runner    (1001) docker     (121)    10034 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/heap.pmt
--rw-r--r--   0 runner    (1001) docker     (121)    26670 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/indheap.c
--rw-r--r--   0 runner    (1001) docker     (121)     5941 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/indheap.h
--rw-r--r--   0 runner    (1001) docker     (121)     1468 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/interruption.c
--rw-r--r--   0 runner    (1001) docker     (121)     1873 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/interruption.h
--rw-r--r--   0 runner    (1001) docker     (121)     3403 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/marked_queue.c
--rw-r--r--   0 runner    (1001) docker     (121)     2866 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/marked_queue.h
--rw-r--r--   0 runner    (1001) docker     (121)     2317 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/math.h
--rw-r--r--   0 runner    (1001) docker     (121)     4945 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/matrix.c
--rw-r--r--   0 runner    (1001) docker     (121)    49926 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/matrix.pmt
--rw-r--r--   0 runner    (1001) docker     (121)     2467 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/memory.c
--rw-r--r--   0 runner    (1001) docker     (121)     4312 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/printing.c
--rw-r--r--   0 runner    (1001) docker     (121)     5918 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/progress.c
--rw-r--r--   0 runner    (1001) docker     (121)     8744 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/psumtree.c
--rw-r--r--   0 runner    (1001) docker     (121)     8765 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/set.c
--rw-r--r--   0 runner    (1001) docker     (121)     2405 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/set.h
--rw-r--r--   0 runner    (1001) docker     (121)   101936 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/sparsemat.c
--rw-r--r--   0 runner    (1001) docker     (121)    33114 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/spmatrix.c
--rw-r--r--   0 runner    (1001) docker     (121)     2220 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/stack.c
--rw-r--r--   0 runner    (1001) docker     (121)     7602 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/stack.pmt
--rw-r--r--   0 runner    (1001) docker     (121)     4426 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/statusbar.c
--rw-r--r--   0 runner    (1001) docker     (121)    17410 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/strvector.c
--rw-r--r--   0 runner    (1001) docker     (121)    12325 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/trie.c
--rw-r--r--   0 runner    (1001) docker     (121)     2509 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/trie.h
--rw-r--r--   0 runner    (1001) docker     (121)    15482 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/vector.c
--rw-r--r--   0 runner    (1001) docker     (121)    88263 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/vector.pmt
--rw-r--r--   0 runner    (1001) docker     (121)    20849 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/core/vector_ptr.c
--rw-r--r--   0 runner    (1001) docker     (121)     5308 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/f2c.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.410936 igraph-0.9.8/vendor/source/igraph/src/flow/
--rw-r--r--   0 runner    (1001) docker     (121)    99437 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/flow/flow.c
--rw-r--r--   0 runner    (1001) docker     (121)     1529 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/flow/flow_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)    60182 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/flow/st-cuts.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.414936 igraph-0.9.8/vendor/source/igraph/src/games/
--rw-r--r--   0 runner    (1001) docker     (121)    29708 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/barabasi.c
--rw-r--r--   0 runner    (1001) docker     (121)     7232 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/callaway_traits.c
--rw-r--r--   0 runner    (1001) docker     (121)    17789 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/citations.c
--rw-r--r--   0 runner    (1001) docker     (121)    10243 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/correlated.c
--rw-r--r--   0 runner    (1001) docker     (121)    28461 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.422936 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/
--rw-r--r--   0 runner    (1001) docker     (121)     2488 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2658 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.h
--rw-r--r--   0 runner    (1001) docker     (121)     4645 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_definitions.h
--rw-r--r--   0 runner    (1001) docker     (121)    11754 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2477 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.h
--rw-r--r--   0 runner    (1001) docker     (121)    33989 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     8107 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.h
--rw-r--r--   0 runner    (1001) docker     (121)    68708 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    11924 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.h
--rw-r--r--   0 runner    (1001) docker     (121)     8880 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_hash.h
--rw-r--r--   0 runner    (1001) docker     (121)     2895 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_header.h
--rw-r--r--   0 runner    (1001) docker     (121)     6818 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_mr-connected.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     8197 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     3022 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.h
--rw-r--r--   0 runner    (1001) docker     (121)    14049 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_qsort.h
--rw-r--r--   0 runner    (1001) docker     (121)     7838 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     7459 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.h
--rw-r--r--   0 runner    (1001) docker     (121)     2343 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_vertex_cover.h
--rw-r--r--   0 runner    (1001) docker     (121)     9148 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/dotproduct.c
--rw-r--r--   0 runner    (1001) docker     (121)    10230 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/erdos_renyi.c
--rw-r--r--   0 runner    (1001) docker     (121)     6621 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/establishment.c
--rw-r--r--   0 runner    (1001) docker     (121)     9910 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/forestfire.c
--rw-r--r--   0 runner    (1001) docker     (121)     5346 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/grg.c
--rw-r--r--   0 runner    (1001) docker     (121)     3302 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/growing_random.c
--rw-r--r--   0 runner    (1001) docker     (121)     5594 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/islands.c
--rw-r--r--   0 runner    (1001) docker     (121)     3501 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/k_regular.c
--rw-r--r--   0 runner    (1001) docker     (121)    24849 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/preference.c
--rw-r--r--   0 runner    (1001) docker     (121)    14467 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/recent_degree.c
--rw-r--r--   0 runner    (1001) docker     (121)    23603 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/sbm.c
--rw-r--r--   0 runner    (1001) docker     (121)    17296 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/static_fitness.c
--rw-r--r--   0 runner    (1001) docker     (121)     6149 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/tree.c
--rw-r--r--   0 runner    (1001) docker     (121)     3599 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/games/watts_strogatz.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.422936 igraph-0.9.8/vendor/source/igraph/src/graph/
--rw-r--r--   0 runner    (1001) docker     (121)    39893 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/adjlist.c
--rw-r--r--   0 runner    (1001) docker     (121)    15689 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/attributes.c
--rw-r--r--   0 runner    (1001) docker     (121)     5893 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/attributes.h
--rw-r--r--   0 runner    (1001) docker     (121)     2104 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/basic_query.c
--rw-r--r--   0 runner    (1001) docker     (121)   151977 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/cattributes.c
--rw-r--r--   0 runner    (1001) docker     (121)    61374 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/iterators.c
--rw-r--r--   0 runner    (1001) docker     (121)     1496 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/neighbors.h
--rw-r--r--   0 runner    (1001) docker     (121)    73133 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/type_indexededgelist.c
--rw-r--r--   0 runner    (1001) docker     (121)    23996 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/graph/visitors.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.426936 igraph-0.9.8/vendor/source/igraph/src/hrg/
--rw-r--r--   0 runner    (1001) docker     (121)    11754 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/hrg/dendro.h
--rw-r--r--   0 runner    (1001) docker     (121)     6130 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/hrg/graph.h
--rw-r--r--   0 runner    (1001) docker     (121)     5459 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/hrg/graph_simp.h
--rw-r--r--   0 runner    (1001) docker     (121)    34483 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/hrg/hrg.cc
--rw-r--r--   0 runner    (1001) docker     (121)   124948 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/hrg/hrg_types.cc
--rw-r--r--   0 runner    (1001) docker     (121)     6087 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/hrg/rbtree.h
--rw-r--r--   0 runner    (1001) docker     (121)     6953 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/hrg/splittree_eq.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.426936 igraph-0.9.8/vendor/source/igraph/src/internal/
--rw-r--r--   0 runner    (1001) docker     (121)     5474 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/glpk_support.c
--rw-r--r--   0 runner    (1001) docker     (121)     5581 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/glpk_support.h
--rw-r--r--   0 runner    (1001) docker     (121)      931 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/gmp_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     1631 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/hacks.c
--rw-r--r--   0 runner    (1001) docker     (121)     1605 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/hacks.h
--rw-r--r--   0 runner    (1001) docker     (121)    16067 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/lsap.c
--rw-r--r--   0 runner    (1001) docker     (121)    29986 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/pstdint.h
--rw-r--r--   0 runner    (1001) docker     (121)     6776 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/qsort.c
--rw-r--r--   0 runner    (1001) docker     (121)      217 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/qsort_r.c
--rw-r--r--   0 runner    (1001) docker     (121)     7962 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/internal/zeroin.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.434937 igraph-0.9.8/vendor/source/igraph/src/io/
--rw-r--r--   0 runner    (1001) docker     (121)    11444 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/dimacs.c
--rw-r--r--   0 runner    (1001) docker     (121)     1350 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/dl-header.h
--rw-r--r--   0 runner    (1001) docker     (121)     4481 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/dl-lexer.l
--rw-r--r--   0 runner    (1001) docker     (121)     9944 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/dl-parser.y
--rw-r--r--   0 runner    (1001) docker     (121)     5901 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/dl.c
--rw-r--r--   0 runner    (1001) docker     (121)    13291 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/dot.c
--rw-r--r--   0 runner    (1001) docker     (121)     5135 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/edgelist.c
--rw-r--r--   0 runner    (1001) docker     (121)     1332 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/gml-header.h
--rw-r--r--   0 runner    (1001) docker     (121)     3561 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/gml-lexer.l
--rw-r--r--   0 runner    (1001) docker     (121)     8625 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/gml-parser.y
--rw-r--r--   0 runner    (1001) docker     (121)     7801 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/gml-tree.c
--rw-r--r--   0 runner    (1001) docker     (121)     3237 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/gml-tree.h
--rw-r--r--   0 runner    (1001) docker     (121)    32748 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/gml.c
--rw-r--r--   0 runner    (1001) docker     (121)     3717 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/graphdb.c
--rw-r--r--   0 runner    (1001) docker     (121)    71197 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/graphml.c
--rw-r--r--   0 runner    (1001) docker     (121)     9969 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/leda.c
--rw-r--r--   0 runner    (1001) docker     (121)     1155 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/lgl-header.h
--rw-r--r--   0 runner    (1001) docker     (121)     2992 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/lgl-lexer.l
--rw-r--r--   0 runner    (1001) docker     (121)     4305 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/lgl-parser.y
--rw-r--r--   0 runner    (1001) docker     (121)    15690 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/lgl.c
--rw-r--r--   0 runner    (1001) docker     (121)     1137 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/ncol-header.h
--rw-r--r--   0 runner    (1001) docker     (121)     2960 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/ncol-lexer.l
--rw-r--r--   0 runner    (1001) docker     (121)     4101 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/ncol-parser.y
--rw-r--r--   0 runner    (1001) docker     (121)    14455 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/ncol.c
--rw-r--r--   0 runner    (1001) docker     (121)     1453 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/pajek-header.h
--rw-r--r--   0 runner    (1001) docker     (121)     6647 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/pajek-lexer.l
--rw-r--r--   0 runner    (1001) docker     (121)    24603 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/pajek-parser.y
--rw-r--r--   0 runner    (1001) docker     (121)    30263 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/io/pajek.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.446937 igraph-0.9.8/vendor/source/igraph/src/io/parsers/
--rw-r--r--   0 runner    (1001) docker     (121)    68546 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-lexer.c
--rw-r--r--   0 runner    (1001) docker     (121)    17279 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-lexer.h
--rw-r--r--   0 runner    (1001) docker     (121)    69128 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-parser.c
--rw-r--r--   0 runner    (1001) docker     (121)     3096 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-parser.h
--rw-r--r--   0 runner    (1001) docker     (121)    62829 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-lexer.c
--rw-r--r--   0 runner    (1001) docker     (121)    17359 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-lexer.h
--rw-r--r--   0 runner    (1001) docker     (121)    60940 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-parser.c
--rw-r--r--   0 runner    (1001) docker     (121)     3000 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-parser.h
--rw-r--r--   0 runner    (1001) docker     (121)    61120 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-lexer.c
--rw-r--r--   0 runner    (1001) docker     (121)    17359 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-lexer.h
--rw-r--r--   0 runner    (1001) docker     (121)    55751 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-parser.c
--rw-r--r--   0 runner    (1001) docker     (121)     2900 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-parser.h
--rw-r--r--   0 runner    (1001) docker     (121)    61106 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-lexer.c
--rw-r--r--   0 runner    (1001) docker     (121)    17491 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-lexer.h
--rw-r--r--   0 runner    (1001) docker     (121)    55327 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-parser.c
--rw-r--r--   0 runner    (1001) docker     (121)     2893 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-parser.h
--rw-r--r--   0 runner    (1001) docker     (121)    78916 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-lexer.c
--rw-r--r--   0 runner    (1001) docker     (121)    17623 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-lexer.h
--rw-r--r--   0 runner    (1001) docker     (121)    91653 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-parser.c
--rw-r--r--   0 runner    (1001) docker     (121)     3784 2021-08-31 09:17:23.000000 igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-parser.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.450938 igraph-0.9.8/vendor/source/igraph/src/isomorphism/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.454938 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/
--rw-r--r--   0 runner    (1001) docker     (121)     1131 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     2315 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/bignum.hh
--rw-r--r--   0 runner    (1001) docker     (121)      864 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/defs.cc
--rw-r--r--   0 runner    (1001) docker     (121)     2513 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/defs.hh
--rw-r--r--   0 runner    (1001) docker     (121)   148769 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/graph.cc
--rw-r--r--   0 runner    (1001) docker     (121)    29652 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/graph.hh
--rw-r--r--   0 runner    (1001) docker     (121)     2248 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/heap.cc
--rw-r--r--   0 runner    (1001) docker     (121)     2087 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/heap.hh
--rw-r--r--   0 runner    (1001) docker     (121)     1267 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/igraph-changes.md
--rw-r--r--   0 runner    (1001) docker     (121)     3317 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/kqueue.hh
--rw-r--r--   0 runner    (1001) docker     (121)     3022 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/kstack.hh
--rw-r--r--   0 runner    (1001) docker     (121)     3083 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/orbit.cc
--rw-r--r--   0 runner    (1001) docker     (121)     3092 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/orbit.hh
--rw-r--r--   0 runner    (1001) docker     (121)    29783 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/partition.cc
--rw-r--r--   0 runner    (1001) docker     (121)     8323 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/partition.hh
--rw-r--r--   0 runner    (1001) docker     (121)     3083 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/stats.hh
--rw-r--r--   0 runner    (1001) docker     (121)     4439 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.cc
--rw-r--r--   0 runner    (1001) docker     (121)     1997 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.hh
--rw-r--r--   0 runner    (1001) docker     (121)     1501 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/utils.cc
--rw-r--r--   0 runner    (1001) docker     (121)     1297 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/utils.hh
--rw-r--r--   0 runner    (1001) docker     (121)    21125 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss.cc
--rw-r--r--   0 runner    (1001) docker     (121)    55251 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/isoclasses.c
--rw-r--r--   0 runner    (1001) docker     (121)     1604 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/isoclasses.h
--rw-r--r--   0 runner    (1001) docker     (121)     3987 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/isomorphism_misc.c
--rw-r--r--   0 runner    (1001) docker     (121)    64763 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/lad.c
--rw-r--r--   0 runner    (1001) docker     (121)     7173 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/queries.c
--rw-r--r--   0 runner    (1001) docker     (121)    76529 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/isomorphism/vf2.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.458938 igraph-0.9.8/vendor/source/igraph/src/layout/
--rw-r--r--   0 runner    (1001) docker     (121)     6265 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/circular.c
--rw-r--r--   0 runner    (1001) docker     (121)    19005 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/davidson_harel.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.462938 igraph-0.9.8/vendor/source/igraph/src/layout/drl/
--rw-r--r--   0 runner    (1001) docker     (121)     9108 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2773 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid.h
--rw-r--r--   0 runner    (1001) docker     (121)    10327 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid_3d.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2820 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid_3d.h
--rw-r--r--   0 runner    (1001) docker     (121)     2309 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_Node.h
--rw-r--r--   0 runner    (1001) docker     (121)     2327 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_Node_3d.h
--rw-r--r--   0 runner    (1001) docker     (121)    41396 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4913 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph.h
--rw-r--r--   0 runner    (1001) docker     (121)    29053 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph_3d.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     4569 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph_3d.h
--rw-r--r--   0 runner    (1001) docker     (121)    16838 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2978 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout.h
--rw-r--r--   0 runner    (1001) docker     (121)     4652 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout_3d.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2974 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout_3d.h
--rw-r--r--   0 runner    (1001) docker     (121)     7354 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_parse.cpp
--rw-r--r--   0 runner    (1001) docker     (121)     2681 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_parse.h
--rw-r--r--   0 runner    (1001) docker     (121)    28451 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/fruchterman_reingold.c
--rw-r--r--   0 runner    (1001) docker     (121)     9596 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/gem.c
--rw-r--r--   0 runner    (1001) docker     (121)    17302 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/graphopt.c
--rw-r--r--   0 runner    (1001) docker     (121)    27534 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/kamada_kawai.c
--rw-r--r--   0 runner    (1001) docker     (121)    13672 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/large_graph.c
--rw-r--r--   0 runner    (1001) docker     (121)     3124 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/layout_bipartite.c
--rw-r--r--   0 runner    (1001) docker     (121)     3738 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/layout_grid.c
--rw-r--r--   0 runner    (1001) docker     (121)     2456 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/layout_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     2780 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/layout_random.c
--rw-r--r--   0 runner    (1001) docker     (121)    11954 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/mds.c
--rw-r--r--   0 runner    (1001) docker     (121)     9880 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/merge_dla.c
--rw-r--r--   0 runner    (1001) docker     (121)     6678 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/merge_grid.c
--rw-r--r--   0 runner    (1001) docker     (121)     2302 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/merge_grid.h
--rw-r--r--   0 runner    (1001) docker     (121)    35175 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/reingold_tilford.c
--rw-r--r--   0 runner    (1001) docker     (121)    54236 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/layout/sugiyama.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.466938 igraph-0.9.8/vendor/source/igraph/src/linalg/
--rw-r--r--   0 runner    (1001) docker     (121)    52242 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/linalg/arpack.c
--rw-r--r--   0 runner    (1001) docker     (121)     8438 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/linalg/arpack_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     4677 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/linalg/blas.c
--rw-r--r--   0 runner    (1001) docker     (121)     2443 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/linalg/blas_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)    51310 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/linalg/eigen.c
--rw-r--r--   0 runner    (1001) docker     (121)    35661 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/linalg/lapack.c
--rw-r--r--   0 runner    (1001) docker     (121)     6932 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/linalg/lapack_internal.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.466938 igraph-0.9.8/vendor/source/igraph/src/math/
--rw-r--r--   0 runner    (1001) docker     (121)     7462 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/math/bfgs.c
--rw-r--r--   0 runner    (1001) docker     (121)    12037 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/math/complex.c
--rw-r--r--   0 runner    (1001) docker     (121)     9421 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/math/utils.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.474939 igraph-0.9.8/vendor/source/igraph/src/misc/
--rw-r--r--   0 runner    (1001) docker     (121)    41796 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/bipartite.c
--rw-r--r--   0 runner    (1001) docker     (121)    16182 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/chordality.c
--rw-r--r--   0 runner    (1001) docker     (121)    28969 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/cocitation.c
--rw-r--r--   0 runner    (1001) docker     (121)     5635 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/coloring.c
--rw-r--r--   0 runner    (1001) docker     (121)    34597 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/conversion.c
--rw-r--r--   0 runner    (1001) docker     (121)     1016 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/conversion_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)    28165 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/degree_sequence.cpp
--rw-r--r--   0 runner    (1001) docker     (121)    40281 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/embedding.c
--rw-r--r--   0 runner    (1001) docker     (121)    25758 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/feedback_arc_set.c
--rw-r--r--   0 runner    (1001) docker     (121)     1365 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/feedback_arc_set.h
--rw-r--r--   0 runner    (1001) docker     (121)    33818 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/graphicality.c
--rw-r--r--   0 runner    (1001) docker     (121)    42477 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/matching.c
--rw-r--r--   0 runner    (1001) docker     (121)    60098 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/microscopic_update.c
--rw-r--r--   0 runner    (1001) docker     (121)    10818 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/mixing.c
--rw-r--r--   0 runner    (1001) docker     (121)    41229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/motifs.c
--rw-r--r--   0 runner    (1001) docker     (121)    16685 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/other.c
--rw-r--r--   0 runner    (1001) docker     (121)    31712 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/scan.c
--rw-r--r--   0 runner    (1001) docker     (121)     9441 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/sir.c
--rw-r--r--   0 runner    (1001) docker     (121)    18696 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/misc/spanning_trees.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.478939 igraph-0.9.8/vendor/source/igraph/src/operators/
--rw-r--r--   0 runner    (1001) docker     (121)     2079 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/add_edge.c
--rw-r--r--   0 runner    (1001) docker     (121)     3618 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/complementer.c
--rw-r--r--   0 runner    (1001) docker     (121)     4927 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/compose.c
--rw-r--r--   0 runner    (1001) docker     (121)     6227 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/connect_neighborhood.c
--rw-r--r--   0 runner    (1001) docker     (121)     5282 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/contract.c
--rw-r--r--   0 runner    (1001) docker     (121)     6429 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/difference.c
--rw-r--r--   0 runner    (1001) docker     (121)     6306 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/disjoint_union.c
--rw-r--r--   0 runner    (1001) docker     (121)    11820 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/intersection.c
--rw-r--r--   0 runner    (1001) docker     (121)     9312 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/misc_internal.c
--rw-r--r--   0 runner    (1001) docker     (121)     1596 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/misc_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     3561 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/permute.c
--rw-r--r--   0 runner    (1001) docker     (121)    10829 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/rewire.c
--rw-r--r--   0 runner    (1001) docker     (121)    13618 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/rewire_edges.c
--rw-r--r--   0 runner    (1001) docker     (121)      257 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/rewire_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     5623 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/simplify.c
--rw-r--r--   0 runner    (1001) docker     (121)    17609 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/subgraph.c
--rw-r--r--   0 runner    (1001) docker     (121)     1235 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/subgraph.h
--rw-r--r--   0 runner    (1001) docker     (121)     9910 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/operators/union.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.482939 igraph-0.9.8/vendor/source/igraph/src/paths/
--rw-r--r--   0 runner    (1001) docker     (121)    12155 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/all_shortest_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)    22910 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/bellman_ford.c
--rw-r--r--   0 runner    (1001) docker     (121)    43461 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/dijkstra.c
--rw-r--r--   0 runner    (1001) docker     (121)     7446 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/distances.c
--rw-r--r--   0 runner    (1001) docker     (121)    22639 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/eulerian.c
--rw-r--r--   0 runner    (1001) docker     (121)     5132 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/histogram.c
--rw-r--r--   0 runner    (1001) docker     (121)     7859 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/johnson.c
--rw-r--r--   0 runner    (1001) docker     (121)    10568 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/random_walk.c
--rw-r--r--   0 runner    (1001) docker     (121)    46215 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/shortest_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)     6276 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/simple_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)    19699 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/paths/unweighted.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.486939 igraph-0.9.8/vendor/source/igraph/src/properties/
--rw-r--r--   0 runner    (1001) docker     (121)    10815 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/basic_properties.c
--rw-r--r--   0 runner    (1001) docker     (121)    12399 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/constraint.c
--rw-r--r--   0 runner    (1001) docker     (121)     8628 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/convergence_degree.c
--rw-r--r--   0 runner    (1001) docker     (121)    10733 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/dag.c
--rw-r--r--   0 runner    (1001) docker     (121)    18060 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/degrees.c
--rw-r--r--   0 runner    (1001) docker     (121)     7462 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/girth.c
--rw-r--r--   0 runner    (1001) docker     (121)     2823 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/loops.c
--rw-r--r--   0 runner    (1001) docker     (121)    12153 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/multiplicity.c
--rw-r--r--   0 runner    (1001) docker     (121)    17948 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/neighborhood.c
--rw-r--r--   0 runner    (1001) docker     (121)     1087 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/properties_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)    16328 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/spectral.c
--rw-r--r--   0 runner    (1001) docker     (121)    11667 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/trees.c
--rw-r--r--   0 runner    (1001) docker     (121)    33812 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/triangles.c
--rw-r--r--   0 runner    (1001) docker     (121)     4125 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/triangles_template.h
--rw-r--r--   0 runner    (1001) docker     (121)     2951 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/properties/triangles_template1.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.486939 igraph-0.9.8/vendor/source/igraph/src/random/
--rw-r--r--   0 runner    (1001) docker     (121)    74866 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/random/random.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.490939 igraph-0.9.8/vendor/source/igraph/src/scg/
--rw-r--r--   0 runner    (1001) docker     (121)    94554 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/scg/scg.c
--rw-r--r--   0 runner    (1001) docker     (121)     6253 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/scg/scg_approximate_methods.c
--rw-r--r--   0 runner    (1001) docker     (121)     2250 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/scg/scg_exact_scg.c
--rw-r--r--   0 runner    (1001) docker     (121)     4970 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/scg/scg_headers.h
--rw-r--r--   0 runner    (1001) docker     (121)     3441 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/scg/scg_kmeans.c
--rw-r--r--   0 runner    (1001) docker     (121)     8033 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/scg/scg_optimal_method.c
--rw-r--r--   0 runner    (1001) docker     (121)     3076 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/scg/scg_utils.c
--rw-r--r--   0 runner    (1001) docker     (121)     2205 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/src/version.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.490939 igraph-0.9.8/vendor/source/igraph/tests/
--rw-r--r--   0 runner    (1001) docker     (121)    15769 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.494940 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/
--rw-r--r--   0 runner    (1001) docker     (121)     2109 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/bench.h
--rw-r--r--   0 runner    (1001) docker     (121)     2958 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_betweenness.c
--rw-r--r--   0 runner    (1001) docker     (121)     5354 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_betweenness_weighted.c
--rw-r--r--   0 runner    (1001) docker     (121)     1181 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_cliques.c
--rw-r--r--   0 runner    (1001) docker     (121)     5396 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_closeness_weighted.c
--rw-r--r--   0 runner    (1001) docker     (121)      887 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_coloring.c
--rw-r--r--   0 runner    (1001) docker     (121)     1099 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_decompose.c
--rw-r--r--   0 runner    (1001) docker     (121)     2176 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_maximal_cliques.c
--rw-r--r--   0 runner    (1001) docker     (121)     5148 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_pagerank.c
--rw-r--r--   0 runner    (1001) docker     (121)     6036 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_pagerank_weighted.c
--rw-r--r--   0 runner    (1001) docker     (121)     5356 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_power_law_fit.c
--rw-r--r--   0 runner    (1001) docker     (121)     3598 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_random_walk.c
--rw-r--r--   0 runner    (1001) docker     (121)     5498 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_transitivity.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.498940 igraph-0.9.8/vendor/source/igraph/tests/regression/
--rw-r--r--   0 runner    (1001) docker     (121)     1606 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/bug-1033045.c
--rw-r--r--   0 runner    (1001) docker     (121)       50 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/bug-1033045.out
--rw-r--r--   0 runner    (1001) docker     (121)     1445 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/bug-1149658.c
--rw-r--r--   0 runner    (1001) docker     (121)     5110 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/bug_1760.c
--rw-r--r--   0 runner    (1001) docker     (121)      446 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/bug_1760.out
--rw-r--r--   0 runner    (1001) docker     (121)     1436 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/bug_1814.c
--rw-r--r--   0 runner    (1001) docker     (121)     1197 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/bug_1814.out
--rw-r--r--   0 runner    (1001) docker     (121)     1630 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/cattr_bool_bug.c
--rw-r--r--   0 runner    (1001) docker     (121)     2343 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/cattr_bool_bug.graphml
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/cattr_bool_bug2.c
--rw-r--r--   0 runner    (1001) docker     (121)      419 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/cattr_bool_bug2.graphml
--rw-r--r--   0 runner    (1001) docker     (121)      612 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_layout_kamada_kawai_3d_bug_1462.c
--rw-r--r--   0 runner    (1001) docker     (121)       31 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_layout_kamada_kawai_3d_bug_1462.out
--rw-r--r--   0 runner    (1001) docker     (121)     1650 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.c
--rw-r--r--   0 runner    (1001) docker     (121)       66 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.in
--rw-r--r--   0 runner    (1001) docker     (121)      224 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.out
--rw-r--r--   0 runner    (1001) docker     (121)     1926 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_read_graph_gml_invalid_inputs.c
--rw-r--r--   0 runner    (1001) docker     (121)     3634 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/invalid1.gml
--rw-r--r--   0 runner    (1001) docker     (121)        6 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/invalid2.gml
--rw-r--r--   0 runner    (1001) docker     (121)     1654 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/invalid3.gml
--rw-r--r--   0 runner    (1001) docker     (121)       10 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/invalid4.gml
--rw-r--r--   0 runner    (1001) docker     (121)       29 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/regression/invalid5.gml
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.598945 igraph-0.9.8/vendor/source/igraph/tests/unit/
--rw-r--r--   0 runner    (1001) docker     (121)     4785 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/2wheap.c
--rw-r--r--   0 runner    (1001) docker     (121)     7751 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/VF2-compat.c
--rw-r--r--   0 runner    (1001) docker     (121)    11292 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/adjlist.c
--rw-r--r--   0 runner    (1001) docker     (121)     7308 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/adjlist.out
--rw-r--r--   0 runner    (1001) docker     (121)     4665 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/all_shortest_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)      304 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/all_shortest_paths.out
--rw-r--r--   0 runner    (1001) docker     (121)     4292 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/bfs.c
--rw-r--r--   0 runner    (1001) docker     (121)      531 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/bfs.out
--rw-r--r--   0 runner    (1001) docker     (121)     2304 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/bfs_simple.c
--rw-r--r--   0 runner    (1001) docker     (121)      209 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/bfs_simple.out
--rw-r--r--   0 runner    (1001) docker     (121)      169 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/bipartite.net
--rw-r--r--   0 runner    (1001) docker     (121)      914 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/bliss_automorphisms.c
--rw-r--r--   0 runner    (1001) docker     (121)      162 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/bliss_automorphisms.out
--rw-r--r--   0 runner    (1001) docker     (121)     6903 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/cattributes5.c
--rw-r--r--   0 runner    (1001) docker     (121)     7420 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/cattributes5.out
--rw-r--r--   0 runner    (1001) docker     (121)     3951 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/community_label_propagation.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/community_label_propagation.out
--rw-r--r--   0 runner    (1001) docker     (121)     7007 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/community_leiden.c
--rw-r--r--   0 runner    (1001) docker     (121)     1390 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/community_leiden.out
--rw-r--r--   0 runner    (1001) docker     (121)     1361 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/cutheap.c
--rw-r--r--   0 runner    (1001) docker     (121)       21 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/cutheap.out
--rw-r--r--   0 runner    (1001) docker     (121)     3186 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/d_indheap.c
--rw-r--r--   0 runner    (1001) docker     (121)       98 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/d_indheap.out
--rw-r--r--   0 runner    (1001) docker     (121)     2095 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/dgemv.c
--rw-r--r--   0 runner    (1001) docker     (121)      650 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/dgemv.out
--rw-r--r--   0 runner    (1001) docker     (121)     4336 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/edge_selectors.c
--rw-r--r--   0 runner    (1001) docker     (121)      297 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/edge_selectors.out
--rw-r--r--   0 runner    (1001) docker     (121)     4015 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/efficiency.c
--rw-r--r--   0 runner    (1001) docker     (121)     1574 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/efficiency.out
--rw-r--r--   0 runner    (1001) docker     (121)     7793 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/erdos_renyi_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     1973 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/error_macros.c
--rw-r--r--   0 runner    (1001) docker     (121)      111 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/error_macros.out
--rw-r--r--   0 runner    (1001) docker     (121)      542 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/fatal_handler.c
--rw-r--r--   0 runner    (1001) docker     (121)       40 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/fatal_handler.out
--rw-r--r--   0 runner    (1001) docker     (121)     2109 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/full.c
--rw-r--r--   0 runner    (1001) docker     (121)     1569 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/full.out
--rw-r--r--   0 runner    (1001) docker     (121)     3348 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/global_transitivity.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/global_transitivity.out
--rw-r--r--   0 runner    (1001) docker     (121)     2302 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/glpk_error.c
--rw-r--r--   0 runner    (1001) docker     (121)     4873 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/harmonic_centrality.c
--rw-r--r--   0 runner    (1001) docker     (121)     1255 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/harmonic_centrality.out
--rw-r--r--   0 runner    (1001) docker     (121)     4437 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/hashtable.c
--rw-r--r--   0 runner    (1001) docker     (121)      162 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/hashtable.out
--rw-r--r--   0 runner    (1001) docker     (121)     4849 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/heap.c
--rw-r--r--   0 runner    (1001) docker     (121)      772 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/heap.out
--rw-r--r--   0 runner    (1001) docker     (121)     1374 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adhesion.c
--rw-r--r--   0 runner    (1001) docker     (121)     2209 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.c
--rw-r--r--   0 runner    (1001) docker     (121)     1011 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.out
--rw-r--r--   0 runner    (1001) docker     (121)     2022 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adjacent_triangles.c
--rw-r--r--   0 runner    (1001) docker     (121)      381 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adjacent_triangles.out
--rw-r--r--   0 runner    (1001) docker     (121)    13369 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_all_st_cuts.c
--rw-r--r--   0 runner    (1001) docker     (121)      886 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_all_st_cuts.out
--rw-r--r--   0 runner    (1001) docker     (121)     2137 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_are_connected.c
--rw-r--r--   0 runner    (1001) docker     (121)     7041 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.c
--rw-r--r--   0 runner    (1001) docker     (121)      662 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.out
--rw-r--r--   0 runner    (1001) docker     (121)     4485 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.c
--rw-r--r--   0 runner    (1001) docker     (121)     2826 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.out
--rw-r--r--   0 runner    (1001) docker     (121)     2127 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_array.c
--rw-r--r--   0 runner    (1001) docker     (121)      502 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_array.out
--rw-r--r--   0 runner    (1001) docker     (121)     2373 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_attribute_combination_remove.c
--rw-r--r--   0 runner    (1001) docker     (121)      307 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_attribute_combination_remove.out
--rw-r--r--   0 runner    (1001) docker     (121)     2543 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length.c
--rw-r--r--   0 runner    (1001) docker     (121)      832 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length.out
--rw-r--r--   0 runner    (1001) docker     (121)     3502 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.c
--rw-r--r--   0 runner    (1001) docker     (121)      731 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.out
--rw-r--r--   0 runner    (1001) docker     (121)     6428 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      594 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.out
--rw-r--r--   0 runner    (1001) docker     (121)    10952 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_betweenness.c
--rw-r--r--   0 runner    (1001) docker     (121)     1559 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_betweenness.out
--rw-r--r--   0 runner    (1001) docker     (121)     1190 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_bipartite_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      938 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_bridges.c
--rw-r--r--   0 runner    (1001) docker     (121)        8 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_bridges.out
--rw-r--r--   0 runner    (1001) docker     (121)     4173 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_callaway_traits_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     4922 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_cited_type_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      523 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_cited_type_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     3519 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_citing_cited_type_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      137 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_citing_cited_type_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     1769 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_clique_size_hist.c
--rw-r--r--   0 runner    (1001) docker     (121)      204 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_clique_size_hist.out
--rw-r--r--   0 runner    (1001) docker     (121)    11054 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_closeness.c
--rw-r--r--   0 runner    (1001) docker     (121)     3610 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_closeness.out
--rw-r--r--   0 runner    (1001) docker     (121)     1380 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_cohesion.c
--rw-r--r--   0 runner    (1001) docker     (121)    13228 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_community_infomap.c
--rw-r--r--   0 runner    (1001) docker     (121)      892 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_community_infomap.out
--rw-r--r--   0 runner    (1001) docker     (121)     3690 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_community_leading_eigenvector2.c
--rw-r--r--   0 runner    (1001) docker     (121)      197 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_community_leading_eigenvector2.out
--rw-r--r--   0 runner    (1001) docker     (121)     4107 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_compare_communities.c
--rw-r--r--   0 runner    (1001) docker     (121)      644 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_compare_communities.out
--rw-r--r--   0 runner    (1001) docker     (121)     6314 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_complex.c
--rw-r--r--   0 runner    (1001) docker     (121)     1688 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_convergence_degree.c
--rw-r--r--   0 runner    (1001) docker     (121)      111 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_convergence_degree.out
--rw-r--r--   0 runner    (1001) docker     (121)     1408 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_correlated_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      804 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_count_multiple.c
--rw-r--r--   0 runner    (1001) docker     (121)       32 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_count_multiple.out
--rw-r--r--   0 runner    (1001) docker     (121)     2238 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_decompose_strong.c
--rw-r--r--   0 runner    (1001) docker     (121)       52 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_decompose_strong.out
--rw-r--r--   0 runner    (1001) docker     (121)     6465 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_degree_sequence_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     4267 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_density.c
--rw-r--r--   0 runner    (1001) docker     (121)      185 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_density.out
--rw-r--r--   0 runner    (1001) docker     (121)     1982 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_diversity.c
--rw-r--r--   0 runner    (1001) docker     (121)      113 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_diversity.out
--rw-r--r--   0 runner    (1001) docker     (121)     2003 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_dyad_census.c
--rw-r--r--   0 runner    (1001) docker     (121)      271 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_dyad_census.out
--rw-r--r--   0 runner    (1001) docker     (121)     2630 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eccentricity.c
--rw-r--r--   0 runner    (1001) docker     (121)      263 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eccentricity.out
--rw-r--r--   0 runner    (1001) docker     (121)     7037 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_edge_betweenness.c
--rw-r--r--   0 runner    (1001) docker     (121)     1653 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_edge_betweenness.out
--rw-r--r--   0 runner    (1001) docker     (121)     1116 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_edge_disjoint_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)     4813 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix.c
--rw-r--r--   0 runner    (1001) docker     (121)      125 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix.out
--rw-r--r--   0 runner    (1001) docker     (121)     3832 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix2.c
--rw-r--r--   0 runner    (1001) docker     (121)      131 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix2.out
--rw-r--r--   0 runner    (1001) docker     (121)     3193 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix3.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix3.out
--rw-r--r--   0 runner    (1001) docker     (121)     3295 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix4.c
--rw-r--r--   0 runner    (1001) docker     (121)      308 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix4.out
--rw-r--r--   0 runner    (1001) docker     (121)     4124 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric.c
--rw-r--r--   0 runner    (1001) docker     (121)      192 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric.out
--rw-r--r--   0 runner    (1001) docker     (121)     4195 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric_arpack.c
--rw-r--r--   0 runner    (1001) docker     (121)      166 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric_arpack.out
--rw-r--r--   0 runner    (1001) docker     (121)     2182 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_es_path.c
--rw-r--r--   0 runner    (1001) docker     (121)     3584 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_establishment_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     5749 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eulerian_cycle.c
--rw-r--r--   0 runner    (1001) docker     (121)      246 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eulerian_cycle.out
--rw-r--r--   0 runner    (1001) docker     (121)    14892 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eulerian_path.c
--rw-r--r--   0 runner    (1001) docker     (121)     1056 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eulerian_path.out
--rw-r--r--   0 runner    (1001) docker     (121)     2797 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_extended_chordal_ring.c
--rw-r--r--   0 runner    (1001) docker     (121)     2729 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_forest_fire_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      354 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_forest_fire_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     1227 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_from_prufer.c
--rw-r--r--   0 runner    (1001) docker     (121)      163 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_from_prufer.out
--rw-r--r--   0 runner    (1001) docker     (121)     2147 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_full_citation.c
--rw-r--r--   0 runner    (1001) docker     (121)     2248 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.c
--rw-r--r--   0 runner    (1001) docker     (121)     1623 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.out
--rw-r--r--   0 runner    (1001) docker     (121)     1827 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_all_simple_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)      298 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_all_simple_paths.out
--rw-r--r--   0 runner    (1001) docker     (121)     2780 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_incidence.c
--rw-r--r--   0 runner    (1001) docker     (121)      527 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_incidence.out
--rw-r--r--   0 runner    (1001) docker     (121)     5147 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.c
--rw-r--r--   0 runner    (1001) docker     (121)      990 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.out
--rw-r--r--   0 runner    (1001) docker     (121)     3143 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_shortest_paths2.c
--rw-r--r--   0 runner    (1001) docker     (121)      166 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_shortest_paths2.out
--rw-r--r--   0 runner    (1001) docker     (121)     9585 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_shortest_paths_bellman_ford.c
--rw-r--r--   0 runner    (1001) docker     (121)      278 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_shortest_paths_bellman_ford.out
--rw-r--r--   0 runner    (1001) docker     (121)     5982 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.c
--rw-r--r--   0 runner    (1001) docker     (121)     1059 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.out
--rw-r--r--   0 runner    (1001) docker     (121)     8497 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_gomory_hu_tree.c
--rw-r--r--   0 runner    (1001) docker     (121)     1243 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_grg_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     2262 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_growing_random_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     2384 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_hrg.c
--rw-r--r--   0 runner    (1001) docker     (121)     3347 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_hrg2.c
--rw-r--r--   0 runner    (1001) docker     (121)     3217 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_hrg3.c
--rw-r--r--   0 runner    (1001) docker     (121)     5288 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_incident.c
--rw-r--r--   0 runner    (1001) docker     (121)     1294 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_incident.out
--rw-r--r--   0 runner    (1001) docker     (121)     2822 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_layout_sphere.c
--rw-r--r--   0 runner    (1001) docker     (121)     5310 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_neighbors.c
--rw-r--r--   0 runner    (1001) docker     (121)     1301 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_neighbors.out
--rw-r--r--   0 runner    (1001) docker     (121)     3282 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_induced_subgraph.c
--rw-r--r--   0 runner    (1001) docker     (121)      108 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_induced_subgraph.out
--rw-r--r--   0 runner    (1001) docker     (121)     2014 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_induced_subgraph_map.c
--rw-r--r--   0 runner    (1001) docker     (121)     1904 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_intersection2.c
--rw-r--r--   0 runner    (1001) docker     (121)      103 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_intersection2.out
--rw-r--r--   0 runner    (1001) docker     (121)     1507 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_bigraphical.c
--rw-r--r--   0 runner    (1001) docker     (121)      275 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_bigraphical.out
--rw-r--r--   0 runner    (1001) docker     (121)     1334 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_bipartite.c
--rw-r--r--   0 runner    (1001) docker     (121)     3434 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_chordal.c
--rw-r--r--   0 runner    (1001) docker     (121)     1162 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_chordal.out
--rw-r--r--   0 runner    (1001) docker     (121)     8067 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_eulerian.c
--rw-r--r--   0 runner    (1001) docker     (121)      136 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_eulerian.out
--rw-r--r--   0 runner    (1001) docker     (121)     7859 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_graphical.c
--rw-r--r--   0 runner    (1001) docker     (121)     2863 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_graphical.out
--rw-r--r--   0 runner    (1001) docker     (121)     2211 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_mutual.c
--rw-r--r--   0 runner    (1001) docker     (121)      170 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_mutual.out
--rw-r--r--   0 runner    (1001) docker     (121)     2602 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_same_graph.c
--rw-r--r--   0 runner    (1001) docker     (121)     2889 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_tree.c
--rw-r--r--   0 runner    (1001) docker     (121)     4764 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.c
--rw-r--r--   0 runner    (1001) docker     (121)     1051 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.out
--rw-r--r--   0 runner    (1001) docker     (121)     6261 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_k_regular_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      312 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_k_regular_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     2333 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_kautz.c
--rw-r--r--   0 runner    (1001) docker     (121)     2530 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgehrd.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgehrd.out
--rw-r--r--   0 runner    (1001) docker     (121)     2472 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.c
--rw-r--r--   0 runner    (1001) docker     (121)      657 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.out
--rw-r--r--   0 runner    (1001) docker     (121)     4907 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.c
--rw-r--r--   0 runner    (1001) docker     (121)      997 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.out
--rw-r--r--   0 runner    (1001) docker     (121)     3867 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lastcit_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      137 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lastcit_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     6768 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lattice.c
--rw-r--r--   0 runner    (1001) docker     (121)     4662 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_bipartite.c
--rw-r--r--   0 runner    (1001) docker     (121)      961 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_bipartite.out
--rw-r--r--   0 runner    (1001) docker     (121)     3591 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_davidson_harel.c
--rw-r--r--   0 runner    (1001) docker     (121)     3446 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_drl.c
--rw-r--r--   0 runner    (1001) docker     (121)     5396 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_fruchterman_reingold.c
--rw-r--r--   0 runner    (1001) docker     (121)      434 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_fruchterman_reingold.out
--rw-r--r--   0 runner    (1001) docker     (121)     4718 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_graphopt.c
--rw-r--r--   0 runner    (1001) docker     (121)      506 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_graphopt.out
--rw-r--r--   0 runner    (1001) docker     (121)     1996 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_grid.c
--rw-r--r--   0 runner    (1001) docker     (121)      506 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_grid.out
--rw-r--r--   0 runner    (1001) docker     (121)     1739 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_lgl.c
--rw-r--r--   0 runner    (1001) docker     (121)     2962 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_mds.c
--rw-r--r--   0 runner    (1001) docker     (121)      175 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_mds.out
--rw-r--r--   0 runner    (1001) docker     (121)     2501 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_merge.c
--rw-r--r--   0 runner    (1001) docker     (121)     2778 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_merge2.c
--rw-r--r--   0 runner    (1001) docker     (121)      194 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_merge2.out
--rw-r--r--   0 runner    (1001) docker     (121)     1417 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_merge3.c
--rw-r--r--   0 runner    (1001) docker     (121)     1769 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_random_3d.c
--rw-r--r--   0 runner    (1001) docker     (121)      375 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_random_3d.out
--rw-r--r--   0 runner    (1001) docker     (121)     4737 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.c
--rw-r--r--   0 runner    (1001) docker     (121)      934 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.out
--rw-r--r--   0 runner    (1001) docker     (121)     1514 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_extended.c
--rw-r--r--   0 runner    (1001) docker     (121)       16 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_extended.in
--rw-r--r--   0 runner    (1001) docker     (121)     2180 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_star.c
--rw-r--r--   0 runner    (1001) docker     (121)      532 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_star.out
--rw-r--r--   0 runner    (1001) docker     (121)     3545 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.c
--rw-r--r--   0 runner    (1001) docker     (121)      552 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.out
--rw-r--r--   0 runner    (1001) docker     (121)     4151 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_le_community_to_membership.c
--rw-r--r--   0 runner    (1001) docker     (121)      375 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_le_community_to_membership.out
--rw-r--r--   0 runner    (1001) docker     (121)     2492 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_linegraph.c
--rw-r--r--   0 runner    (1001) docker     (121)     1827 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_list_triangles.c
--rw-r--r--   0 runner    (1001) docker     (121)      180 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_list_triangles.out
--rw-r--r--   0 runner    (1001) docker     (121)     3388 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.c
--rw-r--r--   0 runner    (1001) docker     (121)      531 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.out
--rw-r--r--   0 runner    (1001) docker     (121)     9243 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_transitivity.c
--rw-r--r--   0 runner    (1001) docker     (121)     1783 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_transitivity.out
--rw-r--r--   0 runner    (1001) docker     (121)     2888 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques2.c
--rw-r--r--   0 runner    (1001) docker     (121)       66 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques2.out
--rw-r--r--   0 runner    (1001) docker     (121)     2087 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.c
--rw-r--r--   0 runner    (1001) docker     (121)     1199 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.out
--rw-r--r--   0 runner    (1001) docker     (121)     3055 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.c
--rw-r--r--   0 runner    (1001) docker     (121)      744 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.out
--rw-r--r--   0 runner    (1001) docker     (121)     1720 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.c
--rw-r--r--   0 runner    (1001) docker     (121)      198 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.out
--rw-r--r--   0 runner    (1001) docker     (121)     4771 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_modularity.c
--rw-r--r--   0 runner    (1001) docker     (121)      486 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_modularity.out
--rw-r--r--   0 runner    (1001) docker     (121)     4966 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_modularity_matrix.c
--rw-r--r--   0 runner    (1001) docker     (121)     1735 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_modularity_matrix.out
--rw-r--r--   0 runner    (1001) docker     (121)     8675 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_moran_process.c
--rw-r--r--   0 runner    (1001) docker     (121)     4166 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.c
--rw-r--r--   0 runner    (1001) docker     (121)      599 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.out
--rw-r--r--   0 runner    (1001) docker     (121)     2871 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.c
--rw-r--r--   0 runner    (1001) docker     (121)      356 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.out
--rw-r--r--   0 runner    (1001) docker     (121)     3754 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood.c
--rw-r--r--   0 runner    (1001) docker     (121)      743 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood.out
--rw-r--r--   0 runner    (1001) docker     (121)     4045 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.c
--rw-r--r--   0 runner    (1001) docker     (121)     1679 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.out
--rw-r--r--   0 runner    (1001) docker     (121)     3528 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_size.c
--rw-r--r--   0 runner    (1001) docker     (121)      571 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_size.out
--rw-r--r--   0 runner    (1001) docker     (121)    14696 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_pagerank.c
--rw-r--r--   0 runner    (1001) docker     (121)     2232 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_pagerank.out
--rw-r--r--   0 runner    (1001) docker     (121)     6316 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_preference_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      918 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_progress_handler_stderr.c
--rw-r--r--   0 runner    (1001) docker     (121)     6028 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_psumtree.c
--rw-r--r--   0 runner    (1001) docker     (121)     1608 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_qsort.c
--rw-r--r--   0 runner    (1001) docker     (121)      290 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_qsort.out
--rw-r--r--   0 runner    (1001) docker     (121)     1923 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_qsort_r.c
--rw-r--r--   0 runner    (1001) docker     (121)      291 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_qsort_r.out
--rw-r--r--   0 runner    (1001) docker     (121)     1790 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_random_walk.c
--rw-r--r--   0 runner    (1001) docker     (121)     4395 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.c
--rw-r--r--   0 runner    (1001) docker     (121)     8144 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.out
--rw-r--r--   0 runner    (1001) docker     (121)     4500 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      519 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     3202 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_recent_degree_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      232 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_recent_degree_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     2096 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_residual_graph.c
--rw-r--r--   0 runner    (1001) docker     (121)     3316 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rewire.c
--rw-r--r--   0 runner    (1001) docker     (121)     3701 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rewire_directed_edges.c
--rw-r--r--   0 runner    (1001) docker     (121)       76 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rewire_directed_edges.out
--rw-r--r--   0 runner    (1001) docker     (121)     1097 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rng_get_exp.c
--rw-r--r--   0 runner    (1001) docker     (121)     9057 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rng_get_exp.out
--rw-r--r--   0 runner    (1001) docker     (121)     1700 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rng_get_integer.c
--rw-r--r--   0 runner    (1001) docker     (121)      118 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rng_get_integer.out
--rw-r--r--   0 runner    (1001) docker     (121)     2180 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_running_mean.c
--rw-r--r--   0 runner    (1001) docker     (121)      187 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_running_mean.out
--rw-r--r--   0 runner    (1001) docker     (121)     4942 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sbm_game.c
--rw-r--r--   0 runner    (1001) docker     (121)     1057 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sbm_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     1490 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_set_progress_handler.c
--rw-r--r--   0 runner    (1001) docker     (121)      162 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_set_progress_handler.out
--rw-r--r--   0 runner    (1001) docker     (121)     3254 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.c
--rw-r--r--   0 runner    (1001) docker     (121)      730 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.out
--rw-r--r--   0 runner    (1001) docker     (121)     3730 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      514 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     2881 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sir.c
--rw-r--r--   0 runner    (1001) docker     (121)     1396 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sir.out
--rw-r--r--   0 runner    (1001) docker     (121)     2195 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_solve_lsap.c
--rw-r--r--   0 runner    (1001) docker     (121)      109 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_solve_lsap.out
--rw-r--r--   0 runner    (1001) docker     (121)     8013 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat2.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat2.out
--rw-r--r--   0 runner    (1001) docker     (121)    12979 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat5.c
--rw-r--r--   0 runner    (1001) docker     (121)     2255 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat5.out
--rw-r--r--   0 runner    (1001) docker     (121)     2667 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat9.c
--rw-r--r--   0 runner    (1001) docker     (121)     2462 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_droptol.c
--rw-r--r--   0 runner    (1001) docker     (121)      349 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_droptol.out
--rw-r--r--   0 runner    (1001) docker     (121)     2918 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_fkeep.c
--rw-r--r--   0 runner    (1001) docker     (121)      316 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_fkeep.out
--rw-r--r--   0 runner    (1001) docker     (121)     3001 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_getelements_sorted.c
--rw-r--r--   0 runner    (1001) docker     (121)      268 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_getelements_sorted.out
--rw-r--r--   0 runner    (1001) docker     (121)     2005 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_is_symmetric.c
--rw-r--r--   0 runner    (1001) docker     (121)     2153 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_iterator_idx.c
--rw-r--r--   0 runner    (1001) docker     (121)     5613 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.c
--rw-r--r--   0 runner    (1001) docker     (121)      864 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.out
--rw-r--r--   0 runner    (1001) docker     (121)     2650 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_nonzero_storage.c
--rw-r--r--   0 runner    (1001) docker     (121)     1582 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_view.c
--rw-r--r--   0 runner    (1001) docker     (121)       94 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_view.out
--rw-r--r--   0 runner    (1001) docker     (121)     6906 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.c
--rw-r--r--   0 runner    (1001) docker     (121)      669 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.out
--rw-r--r--   0 runner    (1001) docker     (121)     3373 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_split_join_distance.c
--rw-r--r--   0 runner    (1001) docker     (121)      284 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_split_join_distance.out
--rw-r--r--   0 runner    (1001) docker     (121)     1813 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_spmatrix_add_col_values.c
--rw-r--r--   0 runner    (1001) docker     (121)      381 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_spmatrix_add_col_values.out
--rw-r--r--   0 runner    (1001) docker     (121)     1117 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_st_edge_connectivity.c
--rw-r--r--   0 runner    (1001) docker     (121)     2071 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_st_mincut.c
--rw-r--r--   0 runner    (1001) docker     (121)       50 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_st_mincut.out
--rw-r--r--   0 runner    (1001) docker     (121)     1263 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_st_mincut_value.c
--rw-r--r--   0 runner    (1001) docker     (121)     3436 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_static_power_law_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      253 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_static_power_law_game.out
--rw-r--r--   0 runner    (1001) docker     (121)     2614 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_subcomponent.c
--rw-r--r--   0 runner    (1001) docker     (121)      460 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_subcomponent.out
--rw-r--r--   0 runner    (1001) docker     (121)     2257 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_subisomorphic.c
--rw-r--r--   0 runner    (1001) docker     (121)      996 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_to_directed.c
--rw-r--r--   0 runner    (1001) docker     (121)      329 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_to_directed.out
--rw-r--r--   0 runner    (1001) docker     (121)     4748 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_to_prufer.c
--rw-r--r--   0 runner    (1001) docker     (121)     1667 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitive_closure_dag.c
--rw-r--r--   0 runner    (1001) docker     (121)       36 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitive_closure_dag.out
--rw-r--r--   0 runner    (1001) docker     (121)     2887 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitivity_avglocal_undirected.c
--rw-r--r--   0 runner    (1001) docker     (121)      219 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitivity_avglocal_undirected.out
--rw-r--r--   0 runner    (1001) docker     (121)     5625 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.c
--rw-r--r--   0 runner    (1001) docker     (121)      914 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.out
--rw-r--r--   0 runner    (1001) docker     (121)     1286 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vector_floor.c
--rw-r--r--   0 runner    (1001) docker     (121)       67 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vector_floor.out
--rw-r--r--   0 runner    (1001) docker     (121)     1876 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vector_lex_cmp.c
--rw-r--r--   0 runner    (1001) docker     (121)      311 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vector_lex_cmp.out
--rw-r--r--   0 runner    (1001) docker     (121)     1124 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vertex_disjoint_paths.c
--rw-r--r--   0 runner    (1001) docker     (121)     5800 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_weighted_cliques.c
--rw-r--r--   0 runner    (1001) docker     (121)     1946 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_weighted_cliques.out
--rw-r--r--   0 runner    (1001) docker     (121)     2079 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_write_graph_dimacs.c
--rw-r--r--   0 runner    (1001) docker     (121)      206 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_write_graph_dimacs.out
--rw-r--r--   0 runner    (1001) docker     (121)     3580 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_write_graph_leda.c
--rw-r--r--   0 runner    (1001) docker     (121)     1013 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_write_graph_leda.out
--rw-r--r--   0 runner    (1001) docker     (121)     5630 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/inclist.c
--rw-r--r--   0 runner    (1001) docker     (121)     3858 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/inclist.out
--rw-r--r--   0 runner    (1001) docker     (121)      783 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/input.dl
--rw-r--r--   0 runner    (1001) docker     (121)     2179 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/isoclasses.c
--rw-r--r--   0 runner    (1001) docker     (121)       38 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/isoclasses.out
--rw-r--r--   0 runner    (1001) docker     (121)     7684 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/isomorphism_test.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/isomorphism_test.out
--rw-r--r--   0 runner    (1001) docker     (121)     2352 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/levc-stress.c
--rw-r--r--   0 runner    (1001) docker     (121)     1905 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/lineendings.c
--rw-r--r--   0 runner    (1001) docker     (121)      228 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/lineendings.out
--rw-r--r--   0 runner    (1001) docker     (121)     1796 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/marked_queue.c
--rw-r--r--   0 runner    (1001) docker     (121)     4528 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/matrix.c
--rw-r--r--   0 runner    (1001) docker     (121)      861 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/matrix.out
--rw-r--r--   0 runner    (1001) docker     (121)     9087 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/matrix2.c
--rw-r--r--   0 runner    (1001) docker     (121)     3908 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/matrix2.out
--rw-r--r--   0 runner    (1001) docker     (121)     1337 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/matrix3.c
--rw-r--r--   0 runner    (1001) docker     (121)     2447 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/maximal_cliques_callback.c
--rw-r--r--   0 runner    (1001) docker     (121)      450 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/maximal_cliques_hist.c
--rw-r--r--   0 runner    (1001) docker     (121)        6 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/maximal_cliques_hist.out
--rw-r--r--   0 runner    (1001) docker     (121)     1136 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/mt.c
--rw-r--r--   0 runner    (1001) docker     (121)     1587 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek.c
--rw-r--r--   0 runner    (1001) docker     (121)      516 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek1.net
--rw-r--r--   0 runner    (1001) docker     (121)     1540 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek2.c
--rw-r--r--   0 runner    (1001) docker     (121)      516 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek2.net
--rw-r--r--   0 runner    (1001) docker     (121)       27 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek2.out
--rw-r--r--   0 runner    (1001) docker     (121)      537 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek3.net
--rw-r--r--   0 runner    (1001) docker     (121)      536 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek4.net
--rw-r--r--   0 runner    (1001) docker     (121)      518 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek5.net
--rw-r--r--   0 runner    (1001) docker     (121)      517 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek6.net
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bip.net
--rw-r--r--   0 runner    (1001) docker     (121)      249 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bip2.net
--rw-r--r--   0 runner    (1001) docker     (121)     1469 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bipartite.c
--rw-r--r--   0 runner    (1001) docker     (121)      126 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bipartite.out
--rw-r--r--   0 runner    (1001) docker     (121)     3571 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bipartite2.c
--rw-r--r--   0 runner    (1001) docker     (121)     2314 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bipartite2.out
--rw-r--r--   0 runner    (1001) docker     (121)     3118 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_signed.c
--rw-r--r--   0 runner    (1001) docker     (121)      364 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_signed.net
--rw-r--r--   0 runner    (1001) docker     (121)     1435 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_signed.out
--rw-r--r--   0 runner    (1001) docker     (121)     2480 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/random_spanning_tree.c
--rw-r--r--   0 runner    (1001) docker     (121)     6181 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/ring.c
--rw-r--r--   0 runner    (1001) docker     (121)     1924 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/rng_init_destroy_max_min_name_set_default.c
--rw-r--r--   0 runner    (1001) docker     (121)      142 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/rng_init_destroy_max_min_name_set_default.out
--rw-r--r--   0 runner    (1001) docker     (121)      463 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/rng_reproducibility.c
--rw-r--r--   0 runner    (1001) docker     (121)      475 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/rng_reproducibility.out
--rw-r--r--   0 runner    (1001) docker     (121)     5523 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/scg2.c
--rw-r--r--   0 runner    (1001) docker     (121)     1872 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/scg2.out
--rw-r--r--   0 runner    (1001) docker     (121)     4474 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/scg3.c
--rw-r--r--   0 runner    (1001) docker     (121)     1945 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/scg3.out
--rw-r--r--   0 runner    (1001) docker     (121)     2165 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/set.c
--rw-r--r--   0 runner    (1001) docker     (121)       55 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/set.out
--rw-r--r--   0 runner    (1001) docker     (121)     1625 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/simplify_and_colorize.c
--rw-r--r--   0 runner    (1001) docker     (121)      519 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/simplify_and_colorize.out
--rw-r--r--   0 runner    (1001) docker     (121)     2506 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/single_target_shortest_path.c
--rw-r--r--   0 runner    (1001) docker     (121)       43 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/single_target_shortest_path.out
--rw-r--r--   0 runner    (1001) docker     (121)     5982 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/spinglass.c
--rw-r--r--   0 runner    (1001) docker     (121)      232 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/spinglass.out
--rw-r--r--   0 runner    (1001) docker     (121)     6267 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix.c
--rw-r--r--   0 runner    (1001) docker     (121)     1669 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix.out
--rw-r--r--   0 runner    (1001) docker     (121)     1787 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix_clear.c
--rw-r--r--   0 runner    (1001) docker     (121)      649 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix_clear.out
--rw-r--r--   0 runner    (1001) docker     (121)     2346 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/stack.c
--rw-r--r--   0 runner    (1001) docker     (121)     2236 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/strvector_set2_remove_print.c
--rw-r--r--   0 runner    (1001) docker     (121)      287 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/strvector_set2_remove_print.out
--rw-r--r--   0 runner    (1001) docker     (121)    13645 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/test_utilities.inc
--rw-r--r--   0 runner    (1001) docker     (121)     1500 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/tls1.c
--rw-r--r--   0 runner    (1001) docker     (121)     7442 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/tls2.c
--rw-r--r--   0 runner    (1001) docker     (121)      606 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/tls2.out
--rw-r--r--   0 runner    (1001) docker     (121)     2602 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/topological_sorting.c
--rw-r--r--   0 runner    (1001) docker     (121)       40 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/topological_sorting.out
--rw-r--r--   0 runner    (1001) docker     (121)      903 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/tree.c
--rw-r--r--   0 runner    (1001) docker     (121)      464 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/tree.out
--rw-r--r--   0 runner    (1001) docker     (121)     3403 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/tree_game.c
--rw-r--r--   0 runner    (1001) docker     (121)      980 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/triad_census.c
--rw-r--r--   0 runner    (1001) docker     (121)       79 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/triad_census.out
--rw-r--r--   0 runner    (1001) docker     (121)     3871 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/trie.c
--rw-r--r--   0 runner    (1001) docker     (121)      336 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/trie.out
--rw-r--r--   0 runner    (1001) docker     (121)    12137 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vector.c
--rw-r--r--   0 runner    (1001) docker     (121)     1670 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vector.out
--rw-r--r--   0 runner    (1001) docker     (121)     3625 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vector2.c
--rw-r--r--   0 runner    (1001) docker     (121)      294 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vector2.out
--rw-r--r--   0 runner    (1001) docker     (121)     1652 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vector3.c
--rw-r--r--   0 runner    (1001) docker     (121)     8264 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vector_ptr.c
--rw-r--r--   0 runner    (1001) docker     (121)     2975 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vertex_selectors.c
--rw-r--r--   0 runner    (1001) docker     (121)      291 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/vertex_selectors.out
--rw-r--r--   0 runner    (1001) docker     (121)     3998 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/watts_strogatz_game.c
--rw-r--r--   0 runner    (1001) docker     (121)    79087 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/wikti_en_V_syn.elist
--rw-r--r--   0 runner    (1001) docker     (121)     1013 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tests/unit/zero_allocs.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.598945 igraph-0.9.8/vendor/source/igraph/tools/
--rw-r--r--   0 runner    (1001) docker     (121)     2198 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/arpack-sed.txt
--rwxr-xr-x   0 runner    (1001) docker     (121)     2001 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/bump_version.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)     9168 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/getglpk.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.598945 igraph-0.9.8/vendor/source/igraph/tools/lapack/
--rwxr-xr-x   0 runner    (1001) docker     (121)     1151 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/CompletePolish
--rw-r--r--   0 runner    (1001) docker     (121)      299 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/Makefile
--rw-r--r--   0 runner    (1001) docker     (121)      336 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/comment.l
--rw-r--r--   0 runner    (1001) docker     (121)       79 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/delete.sed
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.598945 igraph-0.9.8/vendor/source/igraph/tools/lapack/extra/
--rw-r--r--   0 runner    (1001) docker     (121)      270 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/extra/len_trim.f
--rwxr-xr-x   0 runner    (1001) docker     (121)     4947 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/getlapack.sh
--rw-r--r--   0 runner    (1001) docker     (121)     4789 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/lapack.patch
--rw-r--r--   0 runner    (1001) docker     (121)     1370 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/lenscrub.l
--rw-r--r--   0 runner    (1001) docker     (121)    29859 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/mt.patch
--rw-r--r--   0 runner    (1001) docker     (121)      638 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/lapack/split.sed
--rwxr-xr-x   0 runner    (1001) docker     (121)      749 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/tools/removeexamples.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.598945 igraph-0.9.8/vendor/source/igraph/vendor/
--rw-r--r--   0 runner    (1001) docker     (121)      142 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.610945 igraph-0.9.8/vendor/source/igraph/vendor/cs/
--rw-r--r--   0 runner    (1001) docker     (121)     1884 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)      893 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/License.txt
--rw-r--r--   0 runner    (1001) docker     (121)     7783 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/SuiteSparse_config.h
--rw-r--r--   0 runner    (1001) docker     (121)    32854 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs.h
--rw-r--r--   0 runner    (1001) docker     (121)     1419 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_add.c
--rw-r--r--   0 runner    (1001) docker     (121)    16514 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_amd.c
--rw-r--r--   0 runner    (1001) docker     (121)     2877 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_chol.c
--rw-r--r--   0 runner    (1001) docker     (121)      869 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_cholsol.c
--rw-r--r--   0 runner    (1001) docker     (121)     1005 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_compress.c
--rw-r--r--   0 runner    (1001) docker     (121)     2883 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_counts.c
--rw-r--r--   0 runner    (1001) docker     (121)      579 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_cumsum.c
--rw-r--r--   0 runner    (1001) docker     (121)     1645 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_dfs.c
--rw-r--r--   0 runner    (1001) docker     (121)     6422 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_dmperm.c
--rw-r--r--   0 runner    (1001) docker     (121)      252 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_droptol.c
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_dropzeros.c
--rw-r--r--   0 runner    (1001) docker     (121)     1405 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_dupl.c
--rw-r--r--   0 runner    (1001) docker     (121)      459 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_entry.c
--rw-r--r--   0 runner    (1001) docker     (121)     1118 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_ereach.c
--rw-r--r--   0 runner    (1001) docker     (121)     1375 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_etree.c
--rw-r--r--   0 runner    (1001) docker     (121)      961 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_fkeep.c
--rw-r--r--   0 runner    (1001) docker     (121)      438 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_gaxpy.c
--rw-r--r--   0 runner    (1001) docker     (121)      605 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_happly.c
--rw-r--r--   0 runner    (1001) docker     (121)      866 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_house.c
--rw-r--r--   0 runner    (1001) docker     (121)      332 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_ipvec.c
--rw-r--r--   0 runner    (1001) docker     (121)     1039 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_leaf.c
--rw-r--r--   0 runner    (1001) docker     (121)      755 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_load.c
--rw-r--r--   0 runner    (1001) docker     (121)      522 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_lsolve.c
--rw-r--r--   0 runner    (1001) docker     (121)      547 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_ltsolve.c
--rw-r--r--   0 runner    (1001) docker     (121)     4129 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_lu.c
--rw-r--r--   0 runner    (1001) docker     (121)      873 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_lusol.c
--rw-r--r--   0 runner    (1001) docker     (121)      902 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_malloc.c
--rw-r--r--   0 runner    (1001) docker     (121)     4507 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_maxtrans.c
--rw-r--r--   0 runner    (1001) docker     (121)     1577 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_multiply.c
--rw-r--r--   0 runner    (1001) docker     (121)      479 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_norm.c
--rw-r--r--   0 runner    (1001) docker     (121)     1047 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_permute.c
--rw-r--r--   0 runner    (1001) docker     (121)      482 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_pinv.c
--rw-r--r--   0 runner    (1001) docker     (121)     1091 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_post.c
--rw-r--r--   0 runner    (1001) docker     (121)     1854 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_print.c
--rw-r--r--   0 runner    (1001) docker     (121)      331 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_pvec.c
--rw-r--r--   0 runner    (1001) docker     (121)     3527 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_qr.c
--rw-r--r--   0 runner    (1001) docker     (121)     1883 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_qrsol.c
--rw-r--r--   0 runner    (1001) docker     (121)     1018 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_randperm.c
--rw-r--r--   0 runner    (1001) docker     (121)      697 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_reach.c
--rw-r--r--   0 runner    (1001) docker     (121)      901 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_scatter.c
--rw-r--r--   0 runner    (1001) docker     (121)     1892 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_scc.c
--rw-r--r--   0 runner    (1001) docker     (121)     1167 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_schol.c
--rw-r--r--   0 runner    (1001) docker     (121)     1386 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_spsolve.c
--rw-r--r--   0 runner    (1001) docker     (121)     3834 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_sqr.c
--rw-r--r--   0 runner    (1001) docker     (121)     1783 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_symperm.c
--rw-r--r--   0 runner    (1001) docker     (121)      941 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_tdfs.c
--rw-r--r--   0 runner    (1001) docker     (121)     1053 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_transpose.c
--rw-r--r--   0 runner    (1001) docker     (121)     2106 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_updown.c
--rw-r--r--   0 runner    (1001) docker     (121)      529 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_usolve.c
--rw-r--r--   0 runner    (1001) docker     (121)     4196 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_util.c
--rw-r--r--   0 runner    (1001) docker     (121)      548 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_utsolve.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.650947 igraph-0.9.8/vendor/source/igraph/vendor/f2c/
--rw-r--r--   0 runner    (1001) docker     (121)     5018 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1212 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/Notice
--rw-r--r--   0 runner    (1001) docker     (121)    16876 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/README
--rw-r--r--   0 runner    (1001) docker     (121)      304 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/abort_.c
--rw-r--r--   0 runner    (1001) docker     (121)     5534 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/arithchk.c
--rw-r--r--   0 runner    (1001) docker     (121)     1328 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/backspac.c
--rw-r--r--   0 runner    (1001) docker     (121)      280 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_abs.c
--rw-r--r--   0 runner    (1001) docker     (121)      366 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_cos.c
--rw-r--r--   0 runner    (1001) docker     (121)      952 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_div.c
--rw-r--r--   0 runner    (1001) docker     (121)      361 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_exp.c
--rw-r--r--   0 runner    (1001) docker     (121)      396 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_log.c
--rw-r--r--   0 runner    (1001) docker     (121)      362 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_sin.c
--rw-r--r--   0 runner    (1001) docker     (121)      617 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_sqrt.c
--rw-r--r--   0 runner    (1001) docker     (121)      494 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/cabs.c
--rw-r--r--   0 runner    (1001) docker     (121)   134980 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/changes
--rw-r--r--   0 runner    (1001) docker     (121)     1393 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/close.c
--rw-r--r--   0 runner    (1001) docker     (121)      125 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/comptry.bat
--rw-r--r--   0 runner    (1001) docker     (121)       40 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/ctype.c
--rw-r--r--   0 runner    (1001) docker     (121)     1139 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/ctype.h
--rw-r--r--   0 runner    (1001) docker     (121)      218 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_abs.c
--rw-r--r--   0 runner    (1001) docker     (121)      245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_acos.c
--rw-r--r--   0 runner    (1001) docker     (121)      245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_asin.c
--rw-r--r--   0 runner    (1001) docker     (121)      245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_atan.c
--rw-r--r--   0 runner    (1001) docker     (121)      271 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_atn2.c
--rw-r--r--   0 runner    (1001) docker     (121)      255 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_cnjg.c
--rw-r--r--   0 runner    (1001) docker     (121)      241 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_cos.c
--rw-r--r--   0 runner    (1001) docker     (121)      245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_cosh.c
--rw-r--r--   0 runner    (1001) docker     (121)      232 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_dim.c
--rw-r--r--   0 runner    (1001) docker     (121)      241 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_exp.c
--rw-r--r--   0 runner    (1001) docker     (121)      201 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_imag.c
--rw-r--r--   0 runner    (1001) docker     (121)      269 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_int.c
--rw-r--r--   0 runner    (1001) docker     (121)      291 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_lg10.c
--rw-r--r--   0 runner    (1001) docker     (121)      241 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_log.c
--rw-r--r--   0 runner    (1001) docker     (121)      688 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_mod.c
--rw-r--r--   0 runner    (1001) docker     (121)      281 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_nint.c
--rw-r--r--   0 runner    (1001) docker     (121)      207 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_prod.c
--rw-r--r--   0 runner    (1001) docker     (121)      266 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_sign.c
--rw-r--r--   0 runner    (1001) docker     (121)      241 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_sin.c
--rw-r--r--   0 runner    (1001) docker     (121)      245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_sinh.c
--rw-r--r--   0 runner    (1001) docker     (121)      245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_sqrt.c
--rw-r--r--   0 runner    (1001) docker     (121)      241 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_tan.c
--rw-r--r--   0 runner    (1001) docker     (121)      245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_tanh.c
--rw-r--r--   0 runner    (1001) docker     (121)      217 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/derf_.c
--rw-r--r--   0 runner    (1001) docker     (121)      220 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/derfc_.c
--rw-r--r--   0 runner    (1001) docker     (121)     2624 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/dfe.c
--rw-r--r--   0 runner    (1001) docker     (121)      471 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/dolio.c
--rw-r--r--   0 runner    (1001) docker     (121)      972 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/dtime_.c
--rw-r--r--   0 runner    (1001) docker     (121)     1624 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/due.c
--rw-r--r--   0 runner    (1001) docker     (121)       32 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/dummy.c
--rw-r--r--   0 runner    (1001) docker     (121)      521 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/ef1asc_.c
--rw-r--r--   0 runner    (1001) docker     (121)      427 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/ef1cmc_.c
--rw-r--r--   0 runner    (1001) docker     (121)     2838 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/endfile.c
--rw-r--r--   0 runner    (1001) docker     (121)      248 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/erf_.c
--rw-r--r--   0 runner    (1001) docker     (121)      251 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/erfc_.c
--rw-r--r--   0 runner    (1001) docker     (121)     6442 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/err.c
--rw-r--r--   0 runner    (1001) docker     (121)      839 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/etime_.c
--rw-r--r--   0 runner    (1001) docker     (121)      543 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/exit_.c
--rw-r--r--   0 runner    (1001) docker     (121)     5373 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/f2c.h0
--rw-r--r--   0 runner    (1001) docker     (121)     6060 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/f2ch.add
--rw-r--r--   0 runner    (1001) docker     (121)      684 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/f77_aloc.c
--rw-r--r--   0 runner    (1001) docker     (121)     4933 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/f77vers.c
--rw-r--r--   0 runner    (1001) docker     (121)     2939 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/fio.h
--rw-r--r--   0 runner    (1001) docker     (121)     8566 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/fmt.c
--rw-r--r--   0 runner    (1001) docker     (121)     2006 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/fmt.h
--rw-r--r--   0 runner    (1001) docker     (121)      865 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/fmtlib.c
--rw-r--r--   0 runner    (1001) docker     (121)      665 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/fp.h
--rw-r--r--   0 runner    (1001) docker     (121)      900 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/ftell_.c
--rw-r--r--   0 runner    (1001) docker     (121)      592 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/getarg_.c
--rw-r--r--   0 runner    (1001) docker     (121)     1223 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/getenv_.c
--rw-r--r--   0 runner    (1001) docker     (121)      218 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_abs.c
--rw-r--r--   0 runner    (1001) docker     (121)      230 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_dim.c
--rw-r--r--   0 runner    (1001) docker     (121)      294 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_dnnt.c
--rw-r--r--   0 runner    (1001) docker     (121)      442 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_indx.c
--rw-r--r--   0 runner    (1001) docker     (121)      205 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_len.c
--rw-r--r--   0 runner    (1001) docker     (121)      207 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_mod.c
--rw-r--r--   0 runner    (1001) docker     (121)      281 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_nint.c
--rw-r--r--   0 runner    (1001) docker     (121)      266 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/h_sign.c
--rw-r--r--   0 runner    (1001) docker     (121)      346 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/hl_ge.c
--rw-r--r--   0 runner    (1001) docker     (121)      345 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/hl_gt.c
--rw-r--r--   0 runner    (1001) docker     (121)      346 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/hl_le.c
--rw-r--r--   0 runner    (1001) docker     (121)      345 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/hl_lt.c
--rw-r--r--   0 runner    (1001) docker     (121)    18128 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i77vers.c
--rw-r--r--   0 runner    (1001) docker     (121)      214 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_abs.c
--rw-r--r--   0 runner    (1001) docker     (121)      225 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_dim.c
--rw-r--r--   0 runner    (1001) docker     (121)      291 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_dnnt.c
--rw-r--r--   0 runner    (1001) docker     (121)      430 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_indx.c
--rw-r--r--   0 runner    (1001) docker     (121)      203 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_len.c
--rw-r--r--   0 runner    (1001) docker     (121)      211 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_mod.c
--rw-r--r--   0 runner    (1001) docker     (121)      278 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_nint.c
--rw-r--r--   0 runner    (1001) docker     (121)      260 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/i_sign.c
--rw-r--r--   0 runner    (1001) docker     (121)      196 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/iargc_.c
--rw-r--r--   0 runner    (1001) docker     (121)     2639 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/iio.c
--rw-r--r--   0 runner    (1001) docker     (121)     1125 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/ilnw.c
--rw-r--r--   0 runner    (1001) docker     (121)     2732 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/inquire.c
--rw-r--r--   0 runner    (1001) docker     (121)      334 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/l_ge.c
--rw-r--r--   0 runner    (1001) docker     (121)      333 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/l_gt.c
--rw-r--r--   0 runner    (1001) docker     (121)      334 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/l_le.c
--rw-r--r--   0 runner    (1001) docker     (121)      333 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/l_lt.c
--rw-r--r--   0 runner    (1001) docker     (121)     1097 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/lbitbits.c
--rw-r--r--   0 runner    (1001) docker     (121)      258 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/lbitshft.c
--rw-r--r--   0 runner    (1001) docker     (121)     1594 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/libf2c.lbc
--rw-r--r--   0 runner    (1001) docker     (121)     2051 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/libf2c.sy
--rw-r--r--   0 runner    (1001) docker     (121)     1564 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/lio.h
--rw-r--r--   0 runner    (1001) docker     (121)    14635 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/lread.c
--rw-r--r--   0 runner    (1001) docker     (121)     4616 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/lwrite.c
--rw-r--r--   0 runner    (1001) docker     (121)     2230 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/main.c
--rw-r--r--   0 runner    (1001) docker     (121)     2990 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.sy
--rw-r--r--   0 runner    (1001) docker     (121)     7371 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.u
--rw-r--r--   0 runner    (1001) docker     (121)     2954 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.vc
--rw-r--r--   0 runner    (1001) docker     (121)     2936 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.wat
--rw-r--r--   0 runner    (1001) docker     (121)       50 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/math.hvc
--rw-r--r--   0 runner    (1001) docker     (121)     5174 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/mkfile.plan9
--rw-r--r--   0 runner    (1001) docker     (121)     5701 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/open.c
--rw-r--r--   0 runner    (1001) docker     (121)      424 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_ci.c
--rw-r--r--   0 runner    (1001) docker     (121)      276 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_dd.c
--rw-r--r--   0 runner    (1001) docker     (121)      448 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_di.c
--rw-r--r--   0 runner    (1001) docker     (121)      489 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_hh.c
--rw-r--r--   0 runner    (1001) docker     (121)      488 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_ii.c
--rw-r--r--   0 runner    (1001) docker     (121)      436 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_ri.c
--rw-r--r--   0 runner    (1001) docker     (121)      851 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_zi.c
--rw-r--r--   0 runner    (1001) docker     (121)      549 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_zz.c
--rw-r--r--   0 runner    (1001) docker     (121)      206 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_abs.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_acos.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_asin.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_atan.c
--rw-r--r--   0 runner    (1001) docker     (121)      253 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_atn2.c
--rw-r--r--   0 runner    (1001) docker     (121)      247 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_cnjg.c
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_cos.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_cosh.c
--rw-r--r--   0 runner    (1001) docker     (121)      214 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_dim.c
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_exp.c
--rw-r--r--   0 runner    (1001) docker     (121)      197 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_imag.c
--rw-r--r--   0 runner    (1001) docker     (121)      257 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_int.c
--rw-r--r--   0 runner    (1001) docker     (121)      279 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_lg10.c
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_log.c
--rw-r--r--   0 runner    (1001) docker     (121)      678 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_mod.c
--rw-r--r--   0 runner    (1001) docker     (121)      269 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_nint.c
--rw-r--r--   0 runner    (1001) docker     (121)      248 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_sign.c
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_sin.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_sinh.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_sqrt.c
--rw-r--r--   0 runner    (1001) docker     (121)      229 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_tan.c
--rw-r--r--   0 runner    (1001) docker     (121)      233 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_tanh.c
--rw-r--r--   0 runner    (1001) docker     (121)      718 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/rawio.h
--rw-r--r--   0 runner    (1001) docker     (121)     8925 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/rdfmt.c
--rw-r--r--   0 runner    (1001) docker     (121)      475 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/rewind.c
--rw-r--r--   0 runner    (1001) docker     (121)     1492 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/rsfe.c
--rw-r--r--   0 runner    (1001) docker     (121)     1785 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/rsli.c
--rw-r--r--   0 runner    (1001) docker     (121)    11512 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/rsne.c
--rw-r--r--   0 runner    (1001) docker     (121)     1458 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_cat.c
--rw-r--r--   0 runner    (1001) docker     (121)      722 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_cmp.c
--rw-r--r--   0 runner    (1001) docker     (121)     1024 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_copy.c
--rw-r--r--   0 runner    (1001) docker     (121)     1617 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_paus.c
--rw-r--r--   0 runner    (1001) docker     (121)      759 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_rnge.c
--rw-r--r--   0 runner    (1001) docker     (121)      762 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_stop.c
--rw-r--r--   0 runner    (1001) docker     (121)      181 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/scomptry.bat
--rw-r--r--   0 runner    (1001) docker     (121)      828 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/sfe.c
--rw-r--r--   0 runner    (1001) docker     (121)      689 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/sig_die.c
--rw-r--r--   0 runner    (1001) docker     (121)      842 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/signal1.h
--rw-r--r--   0 runner    (1001) docker     (121)      842 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/signal1.h0
--rw-r--r--   0 runner    (1001) docker     (121)      299 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/signal_.c
--rw-r--r--   0 runner    (1001) docker     (121)      330 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/signbit.c
--rw-r--r--   0 runner    (1001) docker     (121)     1865 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/sue.c
--rw-r--r--   0 runner    (1001) docker     (121)     1405 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/sysdep1.h
--rw-r--r--   0 runner    (1001) docker     (121)     1252 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/sysdep1.h0
--rw-r--r--   0 runner    (1001) docker     (121)      652 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/system_.c
--rw-r--r--   0 runner    (1001) docker     (121)      390 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/typesize.c
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/uio.c
--rw-r--r--   0 runner    (1001) docker     (121)    11215 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/uninit.c
--rw-r--r--   0 runner    (1001) docker     (121)      972 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/util.c
--rw-r--r--   0 runner    (1001) docker     (121)     4747 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/wref.c
--rw-r--r--   0 runner    (1001) docker     (121)     7506 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/wrtfmt.c
--rw-r--r--   0 runner    (1001) docker     (121)     1280 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/wsfe.c
--rw-r--r--   0 runner    (1001) docker     (121)      697 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/wsle.c
--rw-r--r--   0 runner    (1001) docker     (121)      479 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/wsne.c
--rw-r--r--   0 runner    (1001) docker     (121)     3945 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/xsum0.out
--rw-r--r--   0 runner    (1001) docker     (121)     1174 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/xwsne.c
--rw-r--r--   0 runner    (1001) docker     (121)      268 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_abs.c
--rw-r--r--   0 runner    (1001) docker     (121)      363 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_cos.c
--rw-r--r--   0 runner    (1001) docker     (121)      913 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_div.c
--rw-r--r--   0 runner    (1001) docker     (121)      357 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_exp.c
--rw-r--r--   0 runner    (1001) docker     (121)     2729 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_log.c
--rw-r--r--   0 runner    (1001) docker     (121)      359 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_sin.c
--rw-r--r--   0 runner    (1001) docker     (121)      581 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_sqrt.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.682948 igraph-0.9.8/vendor/source/igraph/vendor/glpk/
--rw-r--r--   0 runner    (1001) docker     (121)     2091 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)    35149 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/COPYING
--rw-r--r--   0 runner    (1001) docker     (121)     1541 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/README
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.686948 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/
--rw-r--r--   0 runner    (1001) docker     (121)    26517 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/COPYING
--rw-r--r--   0 runner    (1001) docker     (121)     2447 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/README
--rw-r--r--   0 runner    (1001) docker     (121)     1726 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd.h
--rw-r--r--   0 runner    (1001) docker     (121)     6691 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_1.c
--rw-r--r--   0 runner    (1001) docker     (121)    78194 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_2.c
--rw-r--r--   0 runner    (1001) docker     (121)     5943 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_aat.c
--rw-r--r--   0 runner    (1001) docker     (121)     1985 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_control.c
--rw-r--r--   0 runner    (1001) docker     (121)     1403 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_defaults.c
--rw-r--r--   0 runner    (1001) docker     (121)     6145 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_dump.c
--rw-r--r--   0 runner    (1001) docker     (121)     4526 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_info.c
--rw-r--r--   0 runner    (1001) docker     (121)     3071 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_internal.h
--rw-r--r--   0 runner    (1001) docker     (121)     6586 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_order.c
--rw-r--r--   0 runner    (1001) docker     (121)     4549 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_post_tree.c
--rw-r--r--   0 runner    (1001) docker     (121)     6937 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_postorder.c
--rw-r--r--   0 runner    (1001) docker     (121)     4223 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_preprocess.c
--rw-r--r--   0 runner    (1001) docker     (121)     3405 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_valid.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.686948 igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/
--rw-r--r--   0 runner    (1001) docker     (121)    26517 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/COPYING
--rw-r--r--   0 runner    (1001) docker     (121)     4284 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/README
--rw-r--r--   0 runner    (1001) docker     (121)   127126 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/colamd.c
--rw-r--r--   0 runner    (1001) docker     (121)     2124 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/colamd.h
--rw-r--r--   0 runner    (1001) docker     (121)    12482 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi.h
--rw-r--r--   0 runner    (1001) docker     (121)    53033 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi01.c
--rw-r--r--   0 runner    (1001) docker     (121)    13583 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi02.c
--rw-r--r--   0 runner    (1001) docker     (121)     5231 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi03.c
--rw-r--r--   0 runner    (1001) docker     (121)     4628 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi04.c
--rw-r--r--   0 runner    (1001) docker     (121)     5806 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi05.c
--rw-r--r--   0 runner    (1001) docker     (121)    26668 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi06.c
--rw-r--r--   0 runner    (1001) docker     (121)    14882 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi07.c
--rw-r--r--   0 runner    (1001) docker     (121)    12481 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi08.c
--rw-r--r--   0 runner    (1001) docker     (121)    24420 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi09.c
--rw-r--r--   0 runner    (1001) docker     (121)     9763 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi10.c
--rw-r--r--   0 runner    (1001) docker     (121)    44611 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi11.c
--rw-r--r--   0 runner    (1001) docker     (121)    80620 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi12.c
--rw-r--r--   0 runner    (1001) docker     (121)    22827 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi13.c
--rw-r--r--   0 runner    (1001) docker     (121)     9286 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi14.c
--rw-r--r--   0 runner    (1001) docker     (121)    18883 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi15.c
--rw-r--r--   0 runner    (1001) docker     (121)    11153 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi16.c
--rw-r--r--   0 runner    (1001) docker     (121)    34807 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi17.c
--rw-r--r--   0 runner    (1001) docker     (121)     4319 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi18.c
--rw-r--r--   0 runner    (1001) docker     (121)    46433 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi19.c
--rw-r--r--   0 runner    (1001) docker     (121)    11400 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpavl.c
--rw-r--r--   0 runner    (1001) docker     (121)     4334 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpavl.h
--rw-r--r--   0 runner    (1001) docker     (121)    14778 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfd.c
--rw-r--r--   0 runner    (1001) docker     (121)     2595 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfd.h
--rw-r--r--   0 runner    (1001) docker     (121)     2651 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfx.c
--rw-r--r--   0 runner    (1001) docker     (121)     2393 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfx.h
--rw-r--r--   0 runner    (1001) docker     (121)    43647 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpcpx.c
--rw-r--r--   0 runner    (1001) docker     (121)     7767 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpdmp.c
--rw-r--r--   0 runner    (1001) docker     (121)     2710 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpdmp.h
--rw-r--r--   0 runner    (1001) docker     (121)    50790 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpdmx.c
--rw-r--r--   0 runner    (1001) docker     (121)     6984 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv.h
--rw-r--r--   0 runner    (1001) docker     (121)     7387 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv01.c
--rw-r--r--   0 runner    (1001) docker     (121)     2157 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv02.c
--rw-r--r--   0 runner    (1001) docker     (121)     6766 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv03.c
--rw-r--r--   0 runner    (1001) docker     (121)     4183 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv04.c
--rw-r--r--   0 runner    (1001) docker     (121)     7334 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv05.c
--rw-r--r--   0 runner    (1001) docker     (121)     4723 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv06.c
--rw-r--r--   0 runner    (1001) docker     (121)    16105 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv07.c
--rw-r--r--   0 runner    (1001) docker     (121)     3866 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv08.c
--rw-r--r--   0 runner    (1001) docker     (121)    27486 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpfhv.c
--rw-r--r--   0 runner    (1001) docker     (121)     6803 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpfhv.h
--rw-r--r--   0 runner    (1001) docker     (121)    31769 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpgmp.c
--rw-r--r--   0 runner    (1001) docker     (121)     6349 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpgmp.h
--rw-r--r--   0 runner    (1001) docker     (121)    19319 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glphbm.c
--rw-r--r--   0 runner    (1001) docker     (121)     4624 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glphbm.h
--rw-r--r--   0 runner    (1001) docker     (121)    22707 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpini01.c
--rw-r--r--   0 runner    (1001) docker     (121)     9071 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpini02.c
--rw-r--r--   0 runner    (1001) docker     (121)    22390 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios.h
--rw-r--r--   0 runner    (1001) docker     (121)    53573 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios01.c
--rw-r--r--   0 runner    (1001) docker     (121)    27037 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios02.c
--rw-r--r--   0 runner    (1001) docker     (121)    43354 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios03.c
--rw-r--r--   0 runner    (1001) docker     (121)     7662 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios04.c
--rw-r--r--   0 runner    (1001) docker     (121)    10204 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios05.c
--rw-r--r--   0 runner    (1001) docker     (121)    49159 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios06.c
--rw-r--r--   0 runner    (1001) docker     (121)    19097 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios07.c
--rw-r--r--   0 runner    (1001) docker     (121)    28430 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios08.c
--rw-r--r--   0 runner    (1001) docker     (121)    26387 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios09.c
--rw-r--r--   0 runner    (1001) docker     (121)    12215 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios10.c
--rw-r--r--   0 runner    (1001) docker     (121)    10780 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios11.c
--rw-r--r--   0 runner    (1001) docker     (121)     5894 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios12.c
--rw-r--r--   0 runner    (1001) docker     (121)    39069 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpipm.c
--rw-r--r--   0 runner    (1001) docker     (121)     1326 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpipm.h
--rw-r--r--   0 runner    (1001) docker     (121)    60130 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpk.h
--rw-r--r--   0 runner    (1001) docker     (121)     4009 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplib.h
--rw-r--r--   0 runner    (1001) docker     (121)     9599 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplib01.c
--rw-r--r--   0 runner    (1001) docker     (121)     8867 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplib02.c
--rw-r--r--   0 runner    (1001) docker     (121)    18237 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplib03.c
--rw-r--r--   0 runner    (1001) docker     (121)    31575 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplpf.c
--rw-r--r--   0 runner    (1001) docker     (121)     7762 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplpf.h
--rw-r--r--   0 runner    (1001) docker     (121)    49093 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplpx01.c
--rw-r--r--   0 runner    (1001) docker     (121)    10312 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplpx02.c
--rw-r--r--   0 runner    (1001) docker     (121)     8889 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplpx03.c
--rw-r--r--   0 runner    (1001) docker     (121)    71666 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpluf.c
--rw-r--r--   0 runner    (1001) docker     (121)    15154 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpluf.h
--rw-r--r--   0 runner    (1001) docker     (121)    38912 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplux.c
--rw-r--r--   0 runner    (1001) docker     (121)     8850 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplux.h
--rw-r--r--   0 runner    (1001) docker     (121)    33138 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmat.c
--rw-r--r--   0 runner    (1001) docker     (121)     7472 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmat.h
--rw-r--r--   0 runner    (1001) docker     (121)    89703 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl.h
--rw-r--r--   0 runner    (1001) docker     (121)   175842 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl01.c
--rw-r--r--   0 runner    (1001) docker     (121)    45522 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl02.c
--rw-r--r--   0 runner    (1001) docker     (121)   216018 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl03.c
--rw-r--r--   0 runner    (1001) docker     (121)    47401 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl04.c
--rw-r--r--   0 runner    (1001) docker     (121)    22310 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl05.c
--rw-r--r--   0 runner    (1001) docker     (121)    31519 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl06.c
--rw-r--r--   0 runner    (1001) docker     (121)    46954 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmps.c
--rw-r--r--   0 runner    (1001) docker     (121)     2299 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet.h
--rw-r--r--   0 runner    (1001) docker     (121)     9960 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet01.c
--rw-r--r--   0 runner    (1001) docker     (121)    10526 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet02.c
--rw-r--r--   0 runner    (1001) docker     (121)    24837 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet03.c
--rw-r--r--   0 runner    (1001) docker     (121)    25780 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet04.c
--rw-r--r--   0 runner    (1001) docker     (121)    11269 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet05.c
--rw-r--r--   0 runner    (1001) docker     (121)    12763 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet06.c
--rw-r--r--   0 runner    (1001) docker     (121)     7516 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet07.c
--rw-r--r--   0 runner    (1001) docker     (121)     7525 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet08.c
--rw-r--r--   0 runner    (1001) docker     (121)     9487 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet09.c
--rw-r--r--   0 runner    (1001) docker     (121)    18126 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp.h
--rw-r--r--   0 runner    (1001) docker     (121)    29235 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp01.c
--rw-r--r--   0 runner    (1001) docker     (121)    44188 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp02.c
--rw-r--r--   0 runner    (1001) docker     (121)    98876 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp03.c
--rw-r--r--   0 runner    (1001) docker     (121)    50667 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp04.c
--rw-r--r--   0 runner    (1001) docker     (121)    26621 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp05.c
--rw-r--r--   0 runner    (1001) docker     (121)    18293 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpqmd.c
--rw-r--r--   0 runner    (1001) docker     (121)     2245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpqmd.h
--rw-r--r--   0 runner    (1001) docker     (121)     6252 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprgr.c
--rw-r--r--   0 runner    (1001) docker     (121)     1317 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprgr.h
--rw-r--r--   0 runner    (1001) docker     (121)     2278 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprng.h
--rw-r--r--   0 runner    (1001) docker     (121)     6313 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprng01.c
--rw-r--r--   0 runner    (1001) docker     (121)     2311 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprng02.c
--rw-r--r--   0 runner    (1001) docker     (121)    20421 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpscf.c
--rw-r--r--   0 runner    (1001) docker     (121)     4580 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpscf.h
--rw-r--r--   0 runner    (1001) docker     (121)    16026 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpscl.c
--rw-r--r--   0 runner    (1001) docker     (121)     7234 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpsdf.c
--rw-r--r--   0 runner    (1001) docker     (121)    24891 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspm.c
--rw-r--r--   0 runner    (1001) docker     (121)     5088 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspm.h
--rw-r--r--   0 runner    (1001) docker     (121)     1452 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspx.h
--rw-r--r--   0 runner    (1001) docker     (121)    99132 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspx01.c
--rw-r--r--   0 runner    (1001) docker     (121)   101682 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspx02.c
--rw-r--r--   0 runner    (1001) docker     (121)    45995 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpsql.c
--rw-r--r--   0 runner    (1001) docker     (121)     2147 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpsql.h
--rw-r--r--   0 runner    (1001) docker     (121)    16472 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpssx.h
--rw-r--r--   0 runner    (1001) docker     (121)    27891 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpssx01.c
--rw-r--r--   0 runner    (1001) docker     (121)    16835 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpssx02.c
--rw-r--r--   0 runner    (1001) docker     (121)     1382 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpstd.h
--rw-r--r--   0 runner    (1001) docker     (121)    24260 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glptsp.c
--rw-r--r--   0 runner    (1001) docker     (121)     4431 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/glpk/glptsp.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.722950 igraph-0.9.8/vendor/source/igraph/vendor/lapack/
--rw-r--r--   0 runner    (1001) docker     (121)     2990 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     3742 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dasum.c
--rw-r--r--   0 runner    (1001) docker     (121)     4216 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/daxpy.c
--rw-r--r--   0 runner    (1001) docker     (121)     4010 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dcopy.c
--rw-r--r--   0 runner    (1001) docker     (121)     4119 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/ddot.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/debug.h
--rw-r--r--   0 runner    (1001) docker     (121)     7921 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgebak.c
--rw-r--r--   0 runner    (1001) docker     (121)    11682 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgebal.c
--rw-r--r--   0 runner    (1001) docker     (121)    21161 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgeev.c
--rw-r--r--   0 runner    (1001) docker     (121)    28137 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgeevx.c
--rw-r--r--   0 runner    (1001) docker     (121)     7973 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgehd2.c
--rw-r--r--   0 runner    (1001) docker     (121)    13146 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgehrd.c
--rw-r--r--   0 runner    (1001) docker     (121)    12207 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgemm.c
--rw-r--r--   0 runner    (1001) docker     (121)     9267 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgemv.c
--rw-r--r--   0 runner    (1001) docker     (121)     6328 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgeqr2.c
--rw-r--r--   0 runner    (1001) docker     (121)     6410 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dger.c
--rw-r--r--   0 runner    (1001) docker     (121)     6308 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgesv.c
--rw-r--r--   0 runner    (1001) docker     (121)     7020 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetf2.c
--rw-r--r--   0 runner    (1001) docker     (121)     7982 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetrf.c
--rw-r--r--   0 runner    (1001) docker     (121)     7101 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetrs.c
--rw-r--r--   0 runner    (1001) docker     (121)    15147 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetv0.c
--rw-r--r--   0 runner    (1001) docker     (121)    21536 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dhseqr.c
--rw-r--r--   0 runner    (1001) docker     (121)     2626 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/disnan.c
--rw-r--r--   0 runner    (1001) docker     (121)     3710 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlabad.c
--rw-r--r--   0 runner    (1001) docker     (121)     8763 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlacn2.c
--rw-r--r--   0 runner    (1001) docker     (121)     5049 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlacpy.c
--rw-r--r--   0 runner    (1001) docker     (121)     6204 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dladiv.c
--rw-r--r--   0 runner    (1001) docker     (121)     5321 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlae2.c
--rw-r--r--   0 runner    (1001) docker     (121)    23898 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaebz.c
--rw-r--r--   0 runner    (1001) docker     (121)     6621 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaev2.c
--rw-r--r--   0 runner    (1001) docker     (121)    15327 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaexc.c
--rw-r--r--   0 runner    (1001) docker     (121)     8668 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlagtf.c
--rw-r--r--   0 runner    (1001) docker     (121)    11631 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlagts.c
--rw-r--r--   0 runner    (1001) docker     (121)    22224 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlahqr.c
--rw-r--r--   0 runner    (1001) docker     (121)    13186 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlahr2.c
--rw-r--r--   0 runner    (1001) docker     (121)     3289 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaisnan.c
--rw-r--r--   0 runner    (1001) docker     (121)    19239 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaln2.c
--rw-r--r--   0 runner    (1001) docker     (121)     5914 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlamch.c
--rw-r--r--   0 runner    (1001) docker     (121)     7688 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaneg.c
--rw-r--r--   0 runner    (1001) docker     (121)     6870 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlange.c
--rw-r--r--   0 runner    (1001) docker     (121)     6988 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlanhs.c
--rw-r--r--   0 runner    (1001) docker     (121)     6130 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlanst.c
--rw-r--r--   0 runner    (1001) docker     (121)     8372 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlansy.c
--rw-r--r--   0 runner    (1001) docker     (121)     8157 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlanv2.c
--rw-r--r--   0 runner    (1001) docker     (121)     2960 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlapy2.c
--rw-r--r--   0 runner    (1001) docker     (121)    29031 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr0.c
--rw-r--r--   0 runner    (1001) docker     (121)     5898 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr1.c
--rw-r--r--   0 runner    (1001) docker     (121)    25245 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr2.c
--rw-r--r--   0 runner    (1001) docker     (121)    26032 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr3.c
--rw-r--r--   0 runner    (1001) docker     (121)    28956 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr4.c
--rw-r--r--   0 runner    (1001) docker     (121)    37558 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr5.c
--rw-r--r--   0 runner    (1001) docker     (121)    20682 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqrb.c
--rw-r--r--   0 runner    (1001) docker     (121)    23470 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqtr.c
--rw-r--r--   0 runner    (1001) docker     (121)    15989 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlar1v.c
--rw-r--r--   0 runner    (1001) docker     (121)     7471 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarf.c
--rw-r--r--   0 runner    (1001) docker     (121)    23429 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarfb.c
--rw-r--r--   0 runner    (1001) docker     (121)     5735 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarfg.c
--rw-r--r--   0 runner    (1001) docker     (121)    11761 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarft.c
--rw-r--r--   0 runner    (1001) docker     (121)    19584 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarfx.c
--rw-r--r--   0 runner    (1001) docker     (121)     5306 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarnv.c
--rw-r--r--   0 runner    (1001) docker     (121)     6679 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarra.c
--rw-r--r--   0 runner    (1001) docker     (121)    13437 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrb.c
--rw-r--r--   0 runner    (1001) docker     (121)     6837 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrc.c
--rw-r--r--   0 runner    (1001) docker     (121)    29916 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrd.c
--rw-r--r--   0 runner    (1001) docker     (121)    33542 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarre.c
--rw-r--r--   0 runner    (1001) docker     (121)    16393 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrf.c
--rw-r--r--   0 runner    (1001) docker     (121)    11668 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrj.c
--rw-r--r--   0 runner    (1001) docker     (121)     7509 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrk.c
--rw-r--r--   0 runner    (1001) docker     (121)     6606 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrr.c
--rw-r--r--   0 runner    (1001) docker     (121)    41167 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrv.c
--rw-r--r--   0 runner    (1001) docker     (121)     6247 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlartg.c
--rw-r--r--   0 runner    (1001) docker     (121)     8417 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaruv.c
--rw-r--r--   0 runner    (1001) docker     (121)    10753 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlascl.c
--rw-r--r--   0 runner    (1001) docker     (121)     5885 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaset.c
--rw-r--r--   0 runner    (1001) docker     (121)    18174 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq2.c
--rw-r--r--   0 runner    (1001) docker     (121)    11879 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq3.c
--rw-r--r--   0 runner    (1001) docker     (121)    11356 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq4.c
--rw-r--r--   0 runner    (1001) docker     (121)    11929 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq5.c
--rw-r--r--   0 runner    (1001) docker     (121)     7287 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq6.c
--rw-r--r--   0 runner    (1001) docker     (121)    15381 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasr.c
--rw-r--r--   0 runner    (1001) docker     (121)     7319 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasrt.c
--rw-r--r--   0 runner    (1001) docker     (121)     4944 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlassq.c
--rw-r--r--   0 runner    (1001) docker     (121)     5888 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaswp.c
--rw-r--r--   0 runner    (1001) docker     (121)    16870 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasy2.c
--rw-r--r--   0 runner    (1001) docker     (121)    14552 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlatrd.c
--rw-r--r--   0 runner    (1001) docker     (121)    10860 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dmout.c
--rw-r--r--   0 runner    (1001) docker     (121)    33888 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnaitr.c
--rw-r--r--   0 runner    (1001) docker     (121)    27927 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnapps.c
--rw-r--r--   0 runner    (1001) docker     (121)    35771 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnaup2.c
--rw-r--r--   0 runner    (1001) docker     (121)    33787 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnaupd.c
--rw-r--r--   0 runner    (1001) docker     (121)     5252 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnconv.c
--rw-r--r--   0 runner    (1001) docker     (121)    12869 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dneigh.c
--rw-r--r--   0 runner    (1001) docker     (121)    48394 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dneupd.c
--rw-r--r--   0 runner    (1001) docker     (121)     9750 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dngets.c
--rw-r--r--   0 runner    (1001) docker     (121)     3660 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnrm2.c
--rw-r--r--   0 runner    (1001) docker     (121)     6441 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorg2r.c
--rw-r--r--   0 runner    (1001) docker     (121)     7789 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorghr.c
--rw-r--r--   0 runner    (1001) docker     (121)     9735 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorgqr.c
--rw-r--r--   0 runner    (1001) docker     (121)     8396 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorm2l.c
--rw-r--r--   0 runner    (1001) docker     (121)     8422 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorm2r.c
--rw-r--r--   0 runner    (1001) docker     (121)    10198 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormhr.c
--rw-r--r--   0 runner    (1001) docker     (121)    11521 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormql.c
--rw-r--r--   0 runner    (1001) docker     (121)    11486 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormqr.c
--rw-r--r--   0 runner    (1001) docker     (121)    11082 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormtr.c
--rw-r--r--   0 runner    (1001) docker     (121)     7828 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dpotf2.c
--rw-r--r--   0 runner    (1001) docker     (121)     8788 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dpotrf.c
--rw-r--r--   0 runner    (1001) docker     (121)     4017 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/drot.c
--rw-r--r--   0 runner    (1001) docker     (121)    33333 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsaitr.c
--rw-r--r--   0 runner    (1001) docker     (121)    22100 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsapps.c
--rw-r--r--   0 runner    (1001) docker     (121)    36189 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsaup2.c
--rw-r--r--   0 runner    (1001) docker     (121)    32658 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsaupd.c
--rw-r--r--   0 runner    (1001) docker     (121)     3742 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dscal.c
--rw-r--r--   0 runner    (1001) docker     (121)     4477 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsconv.c
--rw-r--r--   0 runner    (1001) docker     (121)     6655 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dseigt.c
--rw-r--r--   0 runner    (1001) docker     (121)     6362 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsesrt.c
--rw-r--r--   0 runner    (1001) docker     (121)    41086 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dseupd.c
--rw-r--r--   0 runner    (1001) docker     (121)     9074 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsgets.c
--rw-r--r--   0 runner    (1001) docker     (121)     9100 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsortc.c
--rw-r--r--   0 runner    (1001) docker     (121)     5616 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsortr.c
--rw-r--r--   0 runner    (1001) docker     (121)     2161 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstatn.c
--rw-r--r--   0 runner    (1001) docker     (121)     1850 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstats.c
--rw-r--r--   0 runner    (1001) docker     (121)    24381 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstebz.c
--rw-r--r--   0 runner    (1001) docker     (121)    15006 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstein.c
--rw-r--r--   0 runner    (1001) docker     (121)    28677 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstemr.c
--rw-r--r--   0 runner    (1001) docker     (121)    16716 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsteqr.c
--rw-r--r--   0 runner    (1001) docker     (121)    11328 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsterf.c
--rw-r--r--   0 runner    (1001) docker     (121)    17485 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstqrb.c
--rw-r--r--   0 runner    (1001) docker     (121)     4125 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dswap.c
--rw-r--r--   0 runner    (1001) docker     (121)    26741 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyevr.c
--rw-r--r--   0 runner    (1001) docker     (121)     9730 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsymv.c
--rw-r--r--   0 runner    (1001) docker     (121)     9005 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyr2.c
--rw-r--r--   0 runner    (1001) docker     (121)    13371 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyr2k.c
--rw-r--r--   0 runner    (1001) docker     (121)    11554 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyrk.c
--rw-r--r--   0 runner    (1001) docker     (121)    11785 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsytd2.c
--rw-r--r--   0 runner    (1001) docker     (121)    13607 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsytrd.c
--rw-r--r--   0 runner    (1001) docker     (121)    36112 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrevc.c
--rw-r--r--   0 runner    (1001) docker     (121)    12461 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrexc.c
--rw-r--r--   0 runner    (1001) docker     (121)    13242 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrmm.c
--rw-r--r--   0 runner    (1001) docker     (121)    10020 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrmv.c
--rw-r--r--   0 runner    (1001) docker     (121)    19928 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsen.c
--rw-r--r--   0 runner    (1001) docker     (121)    14048 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsm.c
--rw-r--r--   0 runner    (1001) docker     (121)    21767 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsna.c
--rw-r--r--   0 runner    (1001) docker     (121)    10003 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsv.c
--rw-r--r--   0 runner    (1001) docker     (121)    39010 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsyl.c
--rw-r--r--   0 runner    (1001) docker     (121)     7752 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/dvout.c
--rw-r--r--   0 runner    (1001) docker     (121)     1313 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/fortran_intrinsics.c
--rw-r--r--   0 runner    (1001) docker     (121)     3428 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/idamax.c
--rw-r--r--   0 runner    (1001) docker     (121)     4941 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/ieeeck.c
--rw-r--r--   0 runner    (1001) docker     (121)     3672 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/iladlc.c
--rw-r--r--   0 runner    (1001) docker     (121)     3650 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/iladlr.c
--rw-r--r--   0 runner    (1001) docker     (121)    21676 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/ilaenv.c
--rw-r--r--   0 runner    (1001) docker     (121)    12365 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/iparmq.c
--rw-r--r--   0 runner    (1001) docker     (121)     7666 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/ivout.c
--rw-r--r--   0 runner    (1001) docker     (121)      899 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/len_trim.c
--rw-r--r--   0 runner    (1001) docker     (121)     3677 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/lsame.c
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/second.c
--rw-r--r--   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/stat.h
--rw-r--r--   0 runner    (1001) docker     (121)     3687 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/lapack/xerbla.c
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.722950 igraph-0.9.8/vendor/source/igraph/vendor/mini-gmp/
--rw-r--r--   0 runner    (1001) docker     (121)      764 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/mini-gmp/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)    89688 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/mini-gmp/mini-gmp.c
--rw-r--r--   0 runner    (1001) docker     (121)    11548 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/mini-gmp/mini-gmp.h
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-28 20:11:04.726950 igraph-0.9.8/vendor/source/igraph/vendor/plfit/
--rw-r--r--   0 runner    (1001) docker     (121)      830 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (121)     3431 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/arithmetic_ansi.h
--rw-r--r--   0 runner    (1001) docker     (121)     8798 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/arithmetic_sse_double.h
--rw-r--r--   0 runner    (1001) docker     (121)     8853 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/arithmetic_sse_float.h
--rw-r--r--   0 runner    (1001) docker     (121)     2518 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/error.h
--rw-r--r--   0 runner    (1001) docker     (121)     3468 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/gss.c
--rw-r--r--   0 runner    (1001) docker     (121)     6060 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/gss.h
--rw-r--r--   0 runner    (1001) docker     (121)    21585 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/hzeta.c
--rw-r--r--   0 runner    (1001) docker     (121)     3007 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/hzeta.h
--rw-r--r--   0 runner    (1001) docker     (121)     1896 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/kolmogorov.c
--rw-r--r--   0 runner    (1001) docker     (121)     1250 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/kolmogorov.h
--rw-r--r--   0 runner    (1001) docker     (121)    41182 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/lbfgs.c
--rw-r--r--   0 runner    (1001) docker     (121)    31934 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/lbfgs.h
--rw-r--r--   0 runner    (1001) docker     (121)     2527 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/mt.c
--rw-r--r--   0 runner    (1001) docker     (121)     2753 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/mt.h
--rw-r--r--   0 runner    (1001) docker     (121)     1770 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/options.c
--rw-r--r--   0 runner    (1001) docker     (121)     1099 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/platform.c
--rw-r--r--   0 runner    (1001) docker     (121)     1588 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/platform.h
--rw-r--r--   0 runner    (1001) docker     (121)    42381 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/plfit.c
--rw-r--r--   0 runner    (1001) docker     (121)     4890 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/plfit.h
--rw-r--r--   0 runner    (1001) docker     (121)     2311 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/plfit_error.c
--rw-r--r--   0 runner    (1001) docker     (121)     5665 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/rbinom.c
--rw-r--r--   0 runner    (1001) docker     (121)     9331 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/sampling.c
--rw-r--r--   0 runner    (1001) docker     (121)     6195 2021-10-28 20:11:01.000000 igraph-0.9.8/vendor/source/igraph/vendor/plfit/sampling.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.715143 igraph-0.9.9/
+-rw-r--r--   0 runner    (1001) docker     (121)    17987 2022-01-10 13:49:34.000000 igraph-0.9.9/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (121)      117 2022-01-10 13:49:34.000000 igraph-0.9.9/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (121)     2381 2022-01-10 13:49:49.715143 igraph-0.9.9/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (121)     8735 2022-01-10 13:49:34.000000 igraph-0.9.9/README.md
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.399139 igraph-0.9.9/scripts/
+-rwxr-xr-x   0 runner    (1001) docker     (121)      127 2022-01-10 13:49:34.000000 igraph-0.9.9/scripts/igraph
+-rwxr-xr-x   0 runner    (1001) docker     (121)     2262 2022-01-10 13:49:34.000000 igraph-0.9.9/scripts/mkdoc.sh
+-rw-r--r--   0 runner    (1001) docker     (121)       38 2022-01-10 13:49:49.715143 igraph-0.9.9/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (121)    33822 2022-01-10 13:49:34.000000 igraph-0.9.9/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.395139 igraph-0.9.9/src/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.407139 igraph-0.9.9/src/_igraph/
+-rw-r--r--   0 runner    (1001) docker     (121)     8845 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/arpackobject.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1658 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/arpackobject.h
+-rw-r--r--   0 runner    (1001) docker     (121)    62691 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/attributes.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3872 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/attributes.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8553 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/bfsiter.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1696 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/bfsiter.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2493 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/common.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1915 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/common.h
+-rw-r--r--   0 runner    (1001) docker     (121)    96249 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/convert.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8346 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/convert.h
+-rw-r--r--   0 runner    (1001) docker     (121)    10203 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/dfsiter.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1686 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/dfsiter.h
+-rw-r--r--   0 runner    (1001) docker     (121)    23020 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/edgeobject.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2000 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/edgeobject.h
+-rw-r--r--   0 runner    (1001) docker     (121)    33011 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/edgeseqobject.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1951 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/edgeseqobject.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3170 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/error.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1594 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/error.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6575 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/filehandle.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1535 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/filehandle.h
+-rw-r--r--   0 runner    (1001) docker     (121)      176 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/force_cpp_linker.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)   622771 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/graphobject.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17462 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/graphobject.h
+-rw-r--r--   0 runner    (1001) docker     (121)    33748 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/igraphmodule.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2566 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/igraphmodule_api.h
+-rw-r--r--   0 runner    (1001) docker     (121)    16985 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/indexing.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1347 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/indexing.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8857 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/operators.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/operators.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1020 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/platform.h
+-rw-r--r--   0 runner    (1001) docker     (121)      974 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/preamble.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5116 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/pyhelpers.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1945 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/pyhelpers.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9645 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/random.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1035 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/random.h
+-rw-r--r--   0 runner    (1001) docker     (121)    29067 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/vertexobject.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2047 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/vertexobject.h
+-rw-r--r--   0 runner    (1001) docker     (121)    35870 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/vertexseqobject.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1998 2022-01-10 13:49:34.000000 igraph-0.9.9/src/_igraph/vertexseqobject.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.407139 igraph-0.9.9/src/igraph/
+-rw-r--r--   0 runner    (1001) docker     (121)   216084 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.411139 igraph-0.9.9/src/igraph/app/
+-rw-r--r--   0 runner    (1001) docker     (121)       32 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/app/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18426 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/app/shell.py
+-rw-r--r--   0 runner    (1001) docker     (121)    65054 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/clustering.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16795 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/configuration.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5754 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/cut.py
+-rw-r--r--   0 runner    (1001) docker     (121)    27699 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/datatypes.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.411139 igraph-0.9.9/src/igraph/drawing/
+-rw-r--r--   0 runner    (1001) docker     (121)    20926 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5074 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/baseclasses.py
+-rw-r--r--   0 runner    (1001) docker     (121)    92493 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/colors.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3923 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/coord.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18672 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/edge.py
+-rw-r--r--   0 runner    (1001) docker     (121)    56579 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/graph.py
+-rw-r--r--   0 runner    (1001) docker     (121)    13893 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/metamagic.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16210 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/shapes.py
+-rw-r--r--   0 runner    (1001) docker     (121)    13148 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/text.py
+-rw-r--r--   0 runner    (1001) docker     (121)    19491 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/utils.py
+-rw-r--r--   0 runner    (1001) docker     (121)     4428 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/drawing/vertex.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8066 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/formula.py
+-rw-r--r--   0 runner    (1001) docker     (121)    17021 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/layout.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6036 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/matching.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16874 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/operators.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.411139 igraph-0.9.9/src/igraph/remote/
+-rw-r--r--   0 runner    (1001) docker     (121)       69 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/remote/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10360 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/remote/gephi.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5704 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/sparse_matrix.py
+-rw-r--r--   0 runner    (1001) docker     (121)    22484 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/statistics.py
+-rw-r--r--   0 runner    (1001) docker     (121)    14308 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/summary.py
+-rw-r--r--   0 runner    (1001) docker     (121)    12161 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/utils.py
+-rw-r--r--   0 runner    (1001) docker     (121)       95 2022-01-10 13:49:34.000000 igraph-0.9.9/src/igraph/version.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.411139 igraph-0.9.9/src/igraph.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (121)     2381 2022-01-10 13:49:49.000000 igraph-0.9.9/src/igraph.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (121)   105578 2022-01-10 13:49:49.000000 igraph-0.9.9/src/igraph.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (121)        1 2022-01-10 13:49:49.000000 igraph-0.9.9/src/igraph.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (121)      222 2022-01-10 13:49:49.000000 igraph-0.9.9/src/igraph.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (121)        7 2022-01-10 13:49:49.000000 igraph-0.9.9/src/igraph.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.415139 igraph-0.9.9/tests/
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (121)     5939 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_atlas.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10535 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_attributes.py
+-rw-r--r--   0 runner    (1001) docker     (121)    29965 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_basic.py
+-rw-r--r--   0 runner    (1001) docker     (121)     9996 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_bipartite.py
+-rw-r--r--   0 runner    (1001) docker     (121)     8980 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_cliques.py
+-rw-r--r--   0 runner    (1001) docker     (121)     3873 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_colortests.py
+-rw-r--r--   0 runner    (1001) docker     (121)     6661 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_conversion.py
+-rw-r--r--   0 runner    (1001) docker     (121)    21218 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_decomposition.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16063 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_edgeseq.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10064 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_flow.py
+-rw-r--r--   0 runner    (1001) docker     (121)    23339 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_foreign.py
+-rw-r--r--   0 runner    (1001) docker     (121)     7516 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_games.py
+-rw-r--r--   0 runner    (1001) docker     (121)    18247 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_generators.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1487 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_homepage.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1890 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_indexing.py
+-rw-r--r--   0 runner    (1001) docker     (121)    14525 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_isomorphism.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1981 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_iterators.py
+-rw-r--r--   0 runner    (1001) docker     (121)    10782 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_layouts.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2927 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_matching.py
+-rw-r--r--   0 runner    (1001) docker     (121)    16080 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_operators.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1206 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_rng.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2624 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_separators.py
+-rw-r--r--   0 runner    (1001) docker     (121)     1491 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_spectral.py
+-rw-r--r--   0 runner    (1001) docker     (121)    35916 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_structural.py
+-rw-r--r--   0 runner    (1001) docker     (121)      666 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_unicode_issues.py
+-rw-r--r--   0 runner    (1001) docker     (121)    14074 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_vertexseq.py
+-rw-r--r--   0 runner    (1001) docker     (121)     2231 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/test_walks.py
+-rw-r--r--   0 runner    (1001) docker     (121)      999 2022-01-10 13:49:34.000000 igraph-0.9.9/tests/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.395139 igraph-0.9.9/vendor/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.395139 igraph-0.9.9/vendor/source/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.419139 igraph-0.9.9/vendor/source/igraph/
+-rw-r--r--   0 runner    (1001) docker     (121)      770 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.astylerc
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.419139 igraph-0.9.9/vendor/source/igraph/.azure/
+-rw-r--r--   0 runner    (1001) docker     (121)     3660 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.azure/build-win.yml
+-rw-r--r--   0 runner    (1001) docker     (121)     2171 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.azure/build.yml
+-rw-r--r--   0 runner    (1001) docker     (121)      207 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.editorconfig
+-rw-r--r--   0 runner    (1001) docker     (121)       51 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.git
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.419139 igraph-0.9.9/vendor/source/igraph/.github/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.419139 igraph-0.9.9/vendor/source/igraph/.github/ISSUE_TEMPLATE/
+-rw-r--r--   0 runner    (1001) docker     (121)      349 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/ISSUE_TEMPLATE/bug_report.md
+-rw-r--r--   0 runner    (1001) docker     (121)      130 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/ISSUE_TEMPLATE/config.yml
+-rw-r--r--   0 runner    (1001) docker     (121)      427 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/ISSUE_TEMPLATE/feature_request.md
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.419139 igraph-0.9.9/vendor/source/igraph/.github/codeql/
+-rw-r--r--   0 runner    (1001) docker     (121)      143 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/codeql/codeql-config.yml
+-rw-r--r--   0 runner    (1001) docker     (121)      721 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/stale.yml
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.419139 igraph-0.9.9/vendor/source/igraph/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (121)     2157 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/workflows/build-cmake.yml
+-rw-r--r--   0 runner    (1001) docker     (121)      989 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/workflows/codecov.yml
+-rw-r--r--   0 runner    (1001) docker     (121)     2259 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/workflows/codeql-analysis.yml
+-rw-r--r--   0 runner    (1001) docker     (121)      783 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.github/workflows/stimulus.yml
+-rw-r--r--   0 runner    (1001) docker     (121)       84 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (121)      408 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.pre-commit-config.yaml
+-rw-r--r--   0 runner    (1001) docker     (121)     3118 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.travis.yml
+-rw-r--r--   0 runner    (1001) docker     (121)      221 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/.zenodo.json
+-rw-r--r--   0 runner    (1001) docker     (121)     7763 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/ACKNOWLEDGEMENTS.md
+-rw-r--r--   0 runner    (1001) docker     (121)      192 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/AUTHORS
+-rw-r--r--   0 runner    (1001) docker     (121)    33807 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (121)     5123 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     8029 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/CODE_OF_CONDUCT.md
+-rw-r--r--   0 runner    (1001) docker     (121)    11235 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/CONTRIBUTING.md
+-rw-r--r--   0 runner    (1001) docker     (121)    18006 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/COPYING
+-rw-r--r--   0 runner    (1001) docker     (121)       57 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/ChangeLog
+-rw-r--r--   0 runner    (1001) docker     (121)        5 2022-01-10 13:49:49.000000 igraph-0.9.9/vendor/source/igraph/IGRAPH_VERSION
+-rw-r--r--   0 runner    (1001) docker     (121)      264 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/INSTALL
+-rw-r--r--   0 runner    (1001) docker     (121)      208 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/NEWS
+-rw-r--r--   0 runner    (1001) docker     (121)    62768 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/ONEWS
+-rw-r--r--   0 runner    (1001) docker     (121)     1014 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/README.md
+-rw-r--r--   0 runner    (1001) docker     (121)     1213 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/SUPPORT.md
+-rw-r--r--   0 runner    (1001) docker     (121)     2815 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/appveyor.yml
+-rw-r--r--   0 runner    (1001) docker     (121)     3927 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/azure-pipelines.yml
+-rw-r--r--   0 runner    (1001) docker     (121)      467 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/codecov.yml
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.427139 igraph-0.9.9/vendor/source/igraph/doc/
+-rw-r--r--   0 runner    (1001) docker     (121)     9202 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     1776 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/adjlist.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1860 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/arpack.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     4296 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/attributes.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     4907 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/basicigraph.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1921 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/bibdatabase.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     1115 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/bipartite.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)    19499 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/c-docbook.re
+-rw-r--r--   0 runner    (1001) docker     (121)     1574 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/cliques.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      365 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/coloring.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     2571 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/community.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      492 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/cycles.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      781 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/docbook.outlang
+-rwxr-xr-x   0 runner    (1001) docker     (121)    15992 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/doxrox.py
+-rw-r--r--   0 runner    (1001) docker     (121)      810 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/dqueue.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      511 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/embedding.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     2597 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/error.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)    22530 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/fdl.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     1706 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/flows.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1701 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/foreign.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     2880 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/generators.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)    19583 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/gpl.xml
+-rw-r--r--   0 runner    (1001) docker     (121)      596 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/graphlets.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)    12450 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/gtk-doc.xsl
+-rw-r--r--   0 runner    (1001) docker     (121)      657 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/heap.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1255 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/hrg.xxml
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.427139 igraph-0.9.9/vendor/source/igraph/doc/html/
+-rw-r--r--   0 runner    (1001) docker     (121)      654 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/html/home.png
+-rw-r--r--   0 runner    (1001) docker     (121)      459 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/html/left.png
+-rw-r--r--   0 runner    (1001) docker     (121)      472 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/html/right.png
+-rw-r--r--   0 runner    (1001) docker     (121)     5619 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/html/style.css
+-rw-r--r--   0 runner    (1001) docker     (121)      622 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/html/toggle.js
+-rw-r--r--   0 runner    (1001) docker     (121)      406 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/html/up.png
+-rw-r--r--   0 runner    (1001) docker     (121)     4725 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/igraph-docs.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     1684 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/igraph.3
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.427139 igraph-0.9.9/vendor/source/igraph/doc/igraphlogo/
+-rw-r--r--   0 runner    (1001) docker     (121)     6138 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/igraphlogo/igraph-white.svg.gz
+-rw-r--r--   0 runner    (1001) docker     (121)     6101 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/igraphlogo/igraph.svg.gz
+-rw-r--r--   0 runner    (1001) docker     (121)     1952 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/igraphlogo/igraph2.svg.gz
+-rw-r--r--   0 runner    (1001) docker     (121)    22122 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/installation.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     4684 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/introduction.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     2160 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/isomorphism.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     3620 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/iterators.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1961 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/layout.xxml
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.427139 igraph-0.9.9/vendor/source/igraph/doc/licenses/
+-rw-r--r--   0 runner    (1001) docker     (121)    21393 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-en.txt
+-rw-r--r--   0 runner    (1001) docker     (121)    22395 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-fr.txt
+-rw-r--r--   0 runner    (1001) docker     (121)    15220 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/licenses/gpl-2.0.txt
+-rw-r--r--   0 runner    (1001) docker     (121)    32473 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/licenses/gpl-3.0.txt
+-rw-r--r--   0 runner    (1001) docker     (121)    24478 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/licenses/lgpl-2.1.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     7652 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/licenses/lgpl-3.0.txt
+-rw-r--r--   0 runner    (1001) docker     (121)      430 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/licenses.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     4224 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/matrix.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      341 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/memory.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1096 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/motifs.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1373 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/nongraph.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1199 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/operators.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     4251 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/pmt.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     1143 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/progress.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      678 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/psumtree.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1785 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/random.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      710 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/scg.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      528 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/separators.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     4656 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/sparsemat.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     2098 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/sparsematrix.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      762 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/spatialgames.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      636 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/stack.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      852 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/status.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     8810 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/structural.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)      893 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/strvector.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1942 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/threading.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)    11080 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/tutorial.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     5618 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/vector.xxml
+-rw-r--r--   0 runner    (1001) docker     (121)     1680 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/version-greater-or-equal.xsl
+-rw-r--r--   0 runner    (1001) docker     (121)      781 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/doc/visitors.xxml
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.395139 igraph-0.9.9/vendor/source/igraph/etc/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.431139 igraph-0.9.9/vendor/source/igraph/etc/cmake/
+-rw-r--r--   0 runner    (1001) docker     (121)      619 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/BuildType.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      162 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/CTestCustom.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (121)      999 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/CheckTLSSupport.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)    28036 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/CodeCoverage.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2474 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/FindARPACK.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2445 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/FindCXSparse.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2046 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/FindGLPK.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      948 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/FindGMP.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2062 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/FindPLFIT.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     4904 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     1283 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (121)      959 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/JoinPaths.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     1681 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/PadString.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     1506 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/PreventInSourceBuilds.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      244 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/UseCCacheWhenInstalled.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     1567 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/benchmark_helpers.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     3637 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/compilers.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2490 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/cpack_install_script.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      336 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/create_igraph_version_file.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      169 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/debugging.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     5917 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/dependencies.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      257 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/features.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     1623 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/generate_tags_file.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      222 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/helpers.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      806 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/igraph-config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (121)      723 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/lto.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2322 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/packaging.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2913 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/pkgconfig_helpers.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     3137 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/run_legacy_test.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     3383 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/sanitizers.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     2803 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/summary.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     4813 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/test_helpers.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)      478 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/tls.cmake
+-rw-r--r--   0 runner    (1001) docker     (121)     3831 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/etc/cmake/version.cmake
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.395139 igraph-0.9.9/vendor/source/igraph/examples/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.467140 igraph-0.9.9/vendor/source/igraph/examples/simple/
+-rw-r--r--   0 runner    (1001) docker     (121)     1572 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/adjlist.c
+-rw-r--r--   0 runner    (1001) docker     (121)   408798 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/ak-4102.max
+-rw-r--r--   0 runner    (1001) docker     (121)    10668 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/assortativity.c
+-rw-r--r--   0 runner    (1001) docker     (121)       87 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/assortativity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3794 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/bellman_ford.c
+-rw-r--r--   0 runner    (1001) docker     (121)      546 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/bellman_ford.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1110 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/blas.c
+-rw-r--r--   0 runner    (1001) docker     (121)       32 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/blas.out
+-rw-r--r--   0 runner    (1001) docker     (121)    13304 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13273 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2428 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6761 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6883 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7407 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes3.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3161 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes4.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2496 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes4.out
+-rw-r--r--   0 runner    (1001) docker     (121)   144652 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/celegansneural.gml
+-rw-r--r--   0 runner    (1001) docker     (121)     5148 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/centralization.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5693 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cohesive_blocks.c
+-rw-r--r--   0 runner    (1001) docker     (121)      910 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/cohesive_blocks.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2410 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dijkstra.c
+-rw-r--r--   0 runner    (1001) docker     (121)      430 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dijkstra.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5129 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dominator_tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)      344 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dominator_tree.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1389 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dot.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1546 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dot.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3075 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dqueue.c
+-rw-r--r--   0 runner    (1001) docker     (121)        9 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/dqueue.out
+-rw-r--r--   0 runner    (1001) docker     (121)       92 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/edgelist1.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      105 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/edgelist2.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      145 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/edgelist3.dl
+-rw-r--r--   0 runner    (1001) docker     (121)       98 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/edgelist4.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      129 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/edgelist5.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      172 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/edgelist6.dl
+-rw-r--r--   0 runner    (1001) docker     (121)       44 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/edgelist7.dl
+-rw-r--r--   0 runner    (1001) docker     (121)     2422 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/eigenvector_centrality.c
+-rw-r--r--   0 runner    (1001) docker     (121)      803 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/eigenvector_centrality.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2077 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/even_tarjan.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3469 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/flow.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8346 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/flow2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      221 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/flow2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1419 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/foreign.c
+-rw-r--r--   0 runner    (1001) docker     (121)       72 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/foreign.out
+-rw-r--r--   0 runner    (1001) docker     (121)       65 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/fullmatrix1.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      116 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/fullmatrix2.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      116 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/fullmatrix3.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      149 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/fullmatrix4.dl
+-rw-r--r--   0 runner    (1001) docker     (121)     1405 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/gml.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4644 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/gml.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1029 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-default-attrs.xml
+-rw-r--r--   0 runner    (1001) docker     (121)    15944 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-hsa05010.xml
+-rw-r--r--   0 runner    (1001) docker     (121)      282 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-lenient.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     1100 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-malformed.xml
+-rw-r--r--   0 runner    (1001) docker     (121)      410 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-namespace.xml
+-rw-r--r--   0 runner    (1001) docker     (121)     5625 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/graphml.c
+-rw-r--r--   0 runner    (1001) docker     (121)      659 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/graphml.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2569 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_add_edges.c
+-rw-r--r--   0 runner    (1001) docker     (121)       75 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_add_edges.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1747 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_add_vertices.c
+-rw-r--r--   0 runner    (1001) docker     (121)      931 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_adjacency.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5776 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1149 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1543 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_atlas.c
+-rw-r--r--   0 runner    (1001) docker     (121)      115 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_atlas.out
+-rw-r--r--   0 runner    (1001) docker     (121)      610 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_average_path_length.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3760 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_barabasi_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3647 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_barabasi_game2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2698 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      293 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1930 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs_callback.c
+-rw-r--r--   0 runner    (1001) docker     (121)       54 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs_callback.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1559 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs_simple.c
+-rw-r--r--   0 runner    (1001) docker     (121)       66 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs_simple.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2726 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_biconnected_components.c
+-rw-r--r--   0 runner    (1001) docker     (121)       44 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_biconnected_components.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2145 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bipartite_create.c
+-rw-r--r--   0 runner    (1001) docker     (121)       32 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bipartite_create.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5730 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bipartite_projection.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_cliques.c
+-rw-r--r--   0 runner    (1001) docker     (121)      329 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_cliques.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1609 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_cocitation.c
+-rw-r--r--   0 runner    (1001) docker     (121)      115 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_cocitation.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1521 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_coloring.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7199 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1082 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.out
+-rw-r--r--   0 runner    (1001) docker     (121)     7640 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.c
+-rw-r--r--   0 runner    (1001) docker     (121)      731 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3482 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_fluid_communities.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_fluid_communities.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1801 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_label_propagation.c
+-rw-r--r--   0 runner    (1001) docker     (121)       50 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_label_propagation.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4112 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_leading_eigenvector.c
+-rw-r--r--   0 runner    (1001) docker     (121)      153 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_leading_eigenvector.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2877 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_leiden.c
+-rw-r--r--   0 runner    (1001) docker     (121)      317 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_leiden.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3783 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_multilevel.c
+-rw-r--r--   0 runner    (1001) docker     (121)      956 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_multilevel.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3967 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_optimal_modularity.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3132 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_complementer.c
+-rw-r--r--   0 runner    (1001) docker     (121)      348 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_complementer.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3589 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_compose.c
+-rw-r--r--   0 runner    (1001) docker     (121)       56 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_compose.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5480 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_convex_hull.c
+-rw-r--r--   0 runner    (1001) docker     (121)      485 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_convex_hull.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1513 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_copy.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2359 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_create.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1749 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_decompose.c
+-rw-r--r--   0 runner    (1001) docker     (121)       72 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_decompose.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6523 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_degree.c
+-rw-r--r--   0 runner    (1001) docker     (121)      115 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_degree.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2905 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_degree_sequence_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      140 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_degree_sequence_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2349 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_delete_edges.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2064 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_delete_vertices.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9972 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_deterministic_optimal_imitation.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1896 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_diameter.c
+-rw-r--r--   0 runner    (1001) docker     (121)       46 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_diameter.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4478 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_difference.c
+-rw-r--r--   0 runner    (1001) docker     (121)      201 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_difference.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2278 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_disjoint_union.c
+-rw-r--r--   0 runner    (1001) docker     (121)      134 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_disjoint_union.out
+-rw-r--r--   0 runner    (1001) docker     (121)      667 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_eccentricity.c
+-rw-r--r--   0 runner    (1001) docker     (121)       60 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_eccentricity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2017 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_empty.c
+-rw-r--r--   0 runner    (1001) docker     (121)      904 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_erdos_renyi_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2251 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_es_pairs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2675 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_feedback_arc_set.c
+-rw-r--r--   0 runner    (1001) docker     (121)       11 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_feedback_arc_set.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3714 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_feedback_arc_set_ip.c
+-rw-r--r--   0 runner    (1001) docker     (121)       22 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_feedback_arc_set_ip.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3545 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_fisher_yates_shuffle.c
+-rw-r--r--   0 runner    (1001) docker     (121)      485 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_free.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2312 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_full.c
+-rw-r--r--   0 runner    (1001) docker     (121)      265 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_full.out
+-rw-r--r--   0 runner    (1001) docker     (121)     7089 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_all_shortest_paths_dijkstra.c
+-rw-r--r--   0 runner    (1001) docker     (121)      147 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_all_shortest_paths_dijkstra.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4515 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_eid.c
+-rw-r--r--   0 runner    (1001) docker     (121)       38 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_eid.out
+-rw-r--r--   0 runner    (1001) docker     (121)     7365 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_eids.c
+-rw-r--r--   0 runner    (1001) docker     (121)       17 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_eids.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4149 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_shortest_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)       88 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_shortest_paths.out
+-rw-r--r--   0 runner    (1001) docker     (121)     7686 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_shortest_paths_dijkstra.c
+-rw-r--r--   0 runner    (1001) docker     (121)      116 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_shortest_paths_dijkstra.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1686 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_girth.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1410 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_grg_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)       51 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_grg_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2661 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_has_multiple.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2745 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_independent_sets.c
+-rw-r--r--   0 runner    (1001) docker     (121)      340 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_independent_sets.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4003 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_intersection.c
+-rw-r--r--   0 runner    (1001) docker     (121)       27 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_intersection.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1167 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_directed.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1727 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_loop.c
+-rw-r--r--   0 runner    (1001) docker     (121)       34 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_loop.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2251 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_minimal_separator.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1788 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_multiple.c
+-rw-r--r--   0 runner    (1001) docker     (121)       46 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_multiple.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2632 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_separator.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9989 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_isomorphic_vf2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2244 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_knn.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8046 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dgeev.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6902 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dgeevx.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4194 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dgesv.c
+-rw-r--r--   0 runner    (1001) docker     (121)       41 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dgesv.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6574 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dsyevr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6878 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_laplacian.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1040 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_laplacian.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1433 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_layout_reingold_tilford.c
+-rw-r--r--   0 runner    (1001) docker     (121)      231 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_layout_reingold_tilford.in
+-rw-r--r--   0 runner    (1001) docker     (121)     2196 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lcf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4708 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_maximal_cliques.c
+-rw-r--r--   0 runner    (1001) docker     (121)      528 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_maximal_cliques.out
+-rw-r--r--   0 runner    (1001) docker     (121)    10009 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_maximum_bipartite_matching.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3682 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_mincut.c
+-rw-r--r--   0 runner    (1001) docker     (121)      278 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_mincut.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1765 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimal_separators.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5541 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimum_size_separators.c
+-rw-r--r--   0 runner    (1001) docker     (121)      174 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimum_size_separators.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2513 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimum_spanning_tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)      264 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimum_spanning_tree.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1744 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_motifs_randesu.c
+-rw-r--r--   0 runner    (1001) docker     (121)      465 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_motifs_randesu.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2110 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_neighbors.c
+-rw-r--r--   0 runner    (1001) docker     (121)       19 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_neighbors.out
+-rw-r--r--   0 runner    (1001) docker     (121)      964 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_pagerank.c
+-rw-r--r--   0 runner    (1001) docker     (121)    22341 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_power_law_fit.c
+-rw-r--r--   0 runner    (1001) docker     (121)      655 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_power_law_fit.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1497 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_radius.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6305 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_random_sample.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2042 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_dl.c
+-rw-r--r--   0 runner    (1001) docker     (121)      619 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_dl.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1197 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11670 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.out
+-rw-r--r--   0 runner    (1001) docker     (121)       42 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_lgl-1.lgl
+-rw-r--r--   0 runner    (1001) docker     (121)       47 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_lgl-2.lgl
+-rw-r--r--   0 runner    (1001) docker     (121)       10 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_lgl-3.lgl
+-rw-r--r--   0 runner    (1001) docker     (121)     2329 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_lgl.c
+-rw-r--r--   0 runner    (1001) docker     (121)       48 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_lgl.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1794 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_reciprocity.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1459 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_ring.c
+-rw-r--r--   0 runner    (1001) docker     (121)       83 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_ring.out
+-rw-r--r--   0 runner    (1001) docker     (121)    11716 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_roulette_wheel_imitation.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2591 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2000 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2755 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping2.c
+-rw-r--r--   0 runner    (1001) docker     (121)       80 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3669 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping3.c
+-rw-r--r--   0 runner    (1001) docker     (121)       80 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping3.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3109 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping4.c
+-rw-r--r--   0 runner    (1001) docker     (121)       80 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping4.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3794 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1070 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4558 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1053 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4046 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.c
+-rw-r--r--   0 runner    (1001) docker     (121)      769 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6833 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_similarity.c
+-rw-r--r--   0 runner    (1001) docker     (121)      888 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_similarity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3149 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_simplify.c
+-rw-r--r--   0 runner    (1001) docker     (121)       40 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_simplify.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1090 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_small.c
+-rw-r--r--   0 runner    (1001) docker     (121)       20 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_small.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5478 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3684 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat.out
+-rw-r--r--   0 runner    (1001) docker     (121)     8527 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat3.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat3.out
+-rw-r--r--   0 runner    (1001) docker     (121)     8041 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat4.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat4.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2068 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat6.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2261 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat7.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6184 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat8.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1138 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_star.c
+-rw-r--r--   0 runner    (1001) docker     (121)       24 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_star.out
+-rw-r--r--   0 runner    (1001) docker     (121)     9772 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_stochastic_imitation.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6045 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_strvector.c
+-rw-r--r--   0 runner    (1001) docker     (121)      594 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_strvector.out
+-rw-r--r--   0 runner    (1001) docker     (121)     9432 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_subisomorphic_lad.c
+-rw-r--r--   0 runner    (1001) docker     (121)      310 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_subisomorphic_lad.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1692 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_to_undirected.c
+-rw-r--r--   0 runner    (1001) docker     (121)      241 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_to_undirected.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1575 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_topological_sorting.c
+-rw-r--r--   0 runner    (1001) docker     (121)       33 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_topological_sorting.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3093 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_transitivity.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1368 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)       44 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_tree.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4859 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_union.c
+-rw-r--r--   0 runner    (1001) docker     (121)      318 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_union.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1400 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vector_ptr_sort.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1204 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_version.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1875 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_nonadj.c
+-rw-r--r--   0 runner    (1001) docker     (121)       25 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_nonadj.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1431 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_seq.c
+-rw-r--r--   0 runner    (1001) docker     (121)       23 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_seq.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2324 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_vector.c
+-rw-r--r--   0 runner    (1001) docker     (121)       17 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_vector.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3017 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_weighted_adjacency.c
+-rw-r--r--   0 runner    (1001) docker     (121)      270 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_weighted_adjacency.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1151 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_write_graph_lgl.c
+-rw-r--r--   0 runner    (1001) docker     (121)      184 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_write_graph_lgl.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2539 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_write_graph_pajek.c
+-rw-r--r--   0 runner    (1001) docker     (121)      435 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_write_graph_pajek.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5002 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/iso_b03_m1000.A00
+-rw-r--r--   0 runner    (1001) docker     (121)     4194 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/karate.gml
+-rw-r--r--   0 runner    (1001) docker     (121)     1011 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/links.net
+-rw-r--r--   0 runner    (1001) docker     (121)       90 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/nodelist1.dl
+-rw-r--r--   0 runner    (1001) docker     (121)       98 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/nodelist2.dl
+-rw-r--r--   0 runner    (1001) docker     (121)      881 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/random_seed.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6006 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/scg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3686 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/scg.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1936 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/test.gxl
+-rw-r--r--   0 runner    (1001) docker     (121)     2431 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/walktrap.c
+-rw-r--r--   0 runner    (1001) docker     (121)      298 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/simple/walktrap.out
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.467140 igraph-0.9.9/vendor/source/igraph/examples/tutorial/
+-rw-r--r--   0 runner    (1001) docker     (121)      531 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/tutorial/tutorial1.c
+-rw-r--r--   0 runner    (1001) docker     (121)      985 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/tutorial/tutorial2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1865 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/examples/tutorial/tutorial3.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.467140 igraph-0.9.9/vendor/source/igraph/fuzzing/
+-rw-r--r--   0 runner    (1001) docker     (121)      202 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/fuzzing/README.md
+-rw-r--r--   0 runner    (1001) docker     (121)     2040 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/fuzzing/bliss_fuzzer.cpp
+-rwxr-xr-x   0 runner    (1001) docker     (121)      547 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/fuzzing/build.sh
+-rw-r--r--   0 runner    (1001) docker     (121)      944 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/fuzzing/edge_connectivity_fuzzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     1772 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/fuzzing/read_gml_fuzzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      948 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/fuzzing/vertex_connectivity_fuzzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     1394 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/fuzzing/vertex_separators_fuzzer.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      329 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/igraph.pc.in
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.479140 igraph-0.9.9/vendor/source/igraph/include/
+-rw-r--r--   0 runner    (1001) docker     (121)     2934 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8341 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_adjlist.h
+-rw-r--r--   0 runner    (1001) docker     (121)    14434 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_arpack.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1647 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_array.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2379 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_array_pmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)    35378 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_attributes.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4693 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_bipartite.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2759 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_blas.h
+-rw-r--r--   0 runner    (1001) docker     (121)    11747 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_centrality.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5945 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_cliques.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3160 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_cocitation.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1428 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_cohesive_blocks.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1501 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_coloring.h
+-rw-r--r--   0 runner    (1001) docker     (121)    14218 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_community.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5115 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_complex.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2698 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_components.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7100 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_constants.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4222 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_constructors.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2674 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_conversion.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3259 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_datatype.h
+-rw-r--r--   0 runner    (1001) docker     (121)      567 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_decls.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1998 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_dqueue.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2270 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_dqueue_pmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4901 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_eigen.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2983 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_embedding.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2259 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_epidemics.h
+-rw-r--r--   0 runner    (1001) docker     (121)    38397 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_error.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1376 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_eulerian.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7880 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_flow.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4423 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_foreign.h
+-rw-r--r--   0 runner    (1001) docker     (121)    13455 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_games.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2521 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_graphicality.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2023 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_graphlets.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2110 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_heap.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1735 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_heap_pmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4658 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_hrg.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5721 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_interface.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4901 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_interrupt.h
+-rw-r--r--   0 runner    (1001) docker     (121)    13233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_iterators.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4700 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_lapack.h
+-rw-r--r--   0 runner    (1001) docker     (121)    14482 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_layout.h
+-rw-r--r--   0 runner    (1001) docker     (121)      312 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_lsap.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2404 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_matching.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2905 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_matrix.h
+-rw-r--r--   0 runner    (1001) docker     (121)    13431 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_matrix_pmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1462 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_memory.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2883 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_microscopic_update.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1893 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_mixing.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4287 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_motifs.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1936 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_neighborhood.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4109 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_nongraph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4615 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_operators.h
+-rw-r--r--   0 runner    (1001) docker     (121)    10998 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_paths.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4130 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_pmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2288 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_pmt_off.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6926 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_progress.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1863 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_psumtree.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1324 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_qsort.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5226 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_random.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3100 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_scan.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7200 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_scg.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1888 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_separators.h
+-rw-r--r--   0 runner    (1001) docker     (121)    15198 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_sparsemat.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5509 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_spmatrix.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2084 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_stack.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1952 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_stack_pmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4285 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_statusbar.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7030 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_structural.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4095 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_strvector.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1471 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_threading.h.in
+-rw-r--r--   0 runner    (1001) docker     (121)    15355 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_topology.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3158 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_transitivity.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2407 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_types.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5830 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_vector.h
+-rw-r--r--   0 runner    (1001) docker     (121)    14747 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_vector_pmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4850 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_vector_ptr.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1063 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_vector_type.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1463 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_version.h.in
+-rw-r--r--   0 runner    (1001) docker     (121)     5404 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/include/igraph_visitor.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.479140 igraph-0.9.9/vendor/source/igraph/interfaces/
+-rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/interfaces/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)    67515 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/interfaces/functions.yaml
+-rw-r--r--   0 runner    (1001) docker     (121)    18920 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/interfaces/types.yaml
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.395139 igraph-0.9.9/vendor/source/igraph/msvc/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.479140 igraph-0.9.9/vendor/source/igraph/msvc/include/
+-rw-r--r--   0 runner    (1001) docker     (121)      222 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/msvc/include/unistd.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.479140 igraph-0.9.9/vendor/source/igraph/src/
+-rw-r--r--   0 runner    (1001) docker     (121)    12799 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.479140 igraph-0.9.9/vendor/source/igraph/src/centrality/
+-rw-r--r--   0 runner    (1001) docker     (121)    41555 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/betweenness.c
+-rw-r--r--   0 runner    (1001) docker     (121)    60895 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/centrality_other.c
+-rw-r--r--   0 runner    (1001) docker     (121)    23479 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/centralization.c
+-rw-r--r--   0 runner    (1001) docker     (121)    34324 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/closeness.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5272 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/coreness.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.483140 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/
+-rw-r--r--   0 runner    (1001) docker     (121)     1087 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)      202 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack.h
+-rw-r--r--   0 runner    (1001) docker     (121)    10028 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     1287 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)      533 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_csc.h
+-rw-r--r--   0 runner    (1001) docker     (121)      212 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_csr.h
+-rw-r--r--   0 runner    (1001) docker     (121)      230 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_edge_list.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4035 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_igraph_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      502 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_igraph_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2070 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      754 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)      333 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2445 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      858 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7168 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     1154 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4108 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      955 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)      173 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_result.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      573 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_result.h
+-rw-r--r--   0 runner    (1001) docker     (121)    30277 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_solver.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     6969 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_solver.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1421 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_utils.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)      972 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_utils.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4768 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     1517 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/centrality/prpack_internal.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.483140 igraph-0.9.9/vendor/source/igraph/src/cliques/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.487140 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/
+-rw-r--r--   0 runner    (1001) docker     (121)      644 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     2042 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/README
+-rw-r--r--   0 runner    (1001) docker     (121)    45839 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquer.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2281 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquer.h
+-rw-r--r--   0 runner    (1001) docker     (121)    16379 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquer_graph.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1930 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquerconf.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2043 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)      995 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/misc.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8965 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/reorder.c
+-rw-r--r--   0 runner    (1001) docker     (121)      980 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/reorder.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9396 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/set.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1264 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)    11062 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer_wrapper.c
+-rw-r--r--   0 runner    (1001) docker     (121)    43108 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/cliques.c
+-rw-r--r--   0 runner    (1001) docker     (121)    31594 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/glet.c
+-rw-r--r--   0 runner    (1001) docker     (121)    20237 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/maximal_cliques.c
+-rw-r--r--   0 runner    (1001) docker     (121)    14511 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/cliques/maximal_cliques_template.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.487140 igraph-0.9.9/vendor/source/igraph/src/community/
+-rw-r--r--   0 runner    (1001) docker     (121)    31186 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/community_misc.c
+-rw-r--r--   0 runner    (1001) docker     (121)    30166 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/edge_betweenness.c
+-rw-r--r--   0 runner    (1001) docker     (121)    44948 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/fast_modularity.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11627 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/fluid.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.487140 igraph-0.9.9/vendor/source/igraph/src/community/infomap/
+-rw-r--r--   0 runner    (1001) docker     (121)    12060 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap.cc
+-rw-r--r--   0 runner    (1001) docker     (121)    12951 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     2111 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.h
+-rw-r--r--   0 runner    (1001) docker     (121)    22807 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Greedy.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     2207 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Greedy.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2243 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Node.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     1386 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Node.h
+-rw-r--r--   0 runner    (1001) docker     (121)    17541 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/label_propagation.c
+-rw-r--r--   0 runner    (1001) docker     (121)    40693 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/leading_eigenvector.c
+-rw-r--r--   0 runner    (1001) docker     (121)    46262 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/leiden.c
+-rw-r--r--   0 runner    (1001) docker     (121)    28301 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/louvain.c
+-rw-r--r--   0 runner    (1001) docker     (121)    14989 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/modularity.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9617 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/optimal_modularity.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.491140 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/
+-rw-r--r--   0 runner    (1001) docker     (121)     6957 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetDataTypes.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)    24957 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetDataTypes.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9889 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetRoutines.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2523 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetRoutines.h
+-rw-r--r--   0 runner    (1001) docker     (121)    25976 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/clustertool.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)    85763 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/pottsmodel_2.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     7715 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/spinglass/pottsmodel_2.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.491140 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/
+-rw-r--r--   0 runner    (1001) docker     (121)     6743 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)    33480 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_communities.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     7048 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_communities.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6798 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     3608 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6741 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_heap.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     4499 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_heap.h
+-rw-r--r--   0 runner    (1001) docker     (121)      940 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/config.h.in
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.491140 igraph-0.9.9/vendor/source/igraph/src/connectivity/
+-rw-r--r--   0 runner    (1001) docker     (121)    21890 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/connectivity/cohesive_blocks.c
+-rw-r--r--   0 runner    (1001) docker     (121)    53385 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/connectivity/components.c
+-rw-r--r--   0 runner    (1001) docker     (121)    31726 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/connectivity/separators.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.491140 igraph-0.9.9/vendor/source/igraph/src/constructors/
+-rw-r--r--   0 runner    (1001) docker     (121)    23043 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/adjacency.c
+-rw-r--r--   0 runner    (1001) docker     (121)    96579 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/atlas-edges.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2818 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/atlas.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5033 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/basic_constructors.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3227 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/de_bruijn.c
+-rw-r--r--   0 runner    (1001) docker     (121)    21986 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/famous.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5499 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/full.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6187 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/kautz.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4654 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/lcf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5648 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/linegraph.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3619 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/prufer.c
+-rw-r--r--   0 runner    (1001) docker     (121)    18062 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/constructors/regular.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.499140 igraph-0.9.9/vendor/source/igraph/src/core/
+-rw-r--r--   0 runner    (1001) docker     (121)     1409 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/array.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2743 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/array.pmt
+-rw-r--r--   0 runner    (1001) docker     (121)     6083 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/buckets.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2784 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/buckets.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5771 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/cutheap.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2291 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/cutheap.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1495 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/dqueue.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9722 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/dqueue.pmt
+-rw-r--r--   0 runner    (1001) docker     (121)    13880 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/error.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2134 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/estack.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1789 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/estack.h
+-rw-r--r--   0 runner    (1001) docker     (121)      770 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/exceptions.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2581 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/fixed_vectorlist.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1663 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/fixed_vectorlist.h
+-rw-r--r--   0 runner    (1001) docker     (121)    10881 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/grid.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3022 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/grid.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4344 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/hashtable.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2216 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/hashtable.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1743 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/heap.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10034 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/heap.pmt
+-rw-r--r--   0 runner    (1001) docker     (121)    26670 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/indheap.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5941 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/indheap.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1468 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/interruption.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1873 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/interruption.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3403 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/marked_queue.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2866 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/marked_queue.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2361 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/math.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4945 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/matrix.c
+-rw-r--r--   0 runner    (1001) docker     (121)    49926 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/matrix.pmt
+-rw-r--r--   0 runner    (1001) docker     (121)     2467 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/memory.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4312 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/printing.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5917 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/progress.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8744 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/psumtree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8765 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/set.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2405 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/set.h
+-rw-r--r--   0 runner    (1001) docker     (121)   101936 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/sparsemat.c
+-rw-r--r--   0 runner    (1001) docker     (121)    33114 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/spmatrix.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2220 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/stack.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7602 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/stack.pmt
+-rw-r--r--   0 runner    (1001) docker     (121)     4426 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/statusbar.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17410 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/strvector.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12325 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/trie.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2509 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/trie.h
+-rw-r--r--   0 runner    (1001) docker     (121)    15482 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/vector.c
+-rw-r--r--   0 runner    (1001) docker     (121)    88277 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/vector.pmt
+-rw-r--r--   0 runner    (1001) docker     (121)    20849 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/core/vector_ptr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5308 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/f2c.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.503140 igraph-0.9.9/vendor/source/igraph/src/flow/
+-rw-r--r--   0 runner    (1001) docker     (121)    99451 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/flow/flow.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1529 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/flow/flow_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)    60182 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/flow/st-cuts.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.507140 igraph-0.9.9/vendor/source/igraph/src/games/
+-rw-r--r--   0 runner    (1001) docker     (121)    29700 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/barabasi.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7232 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/callaway_traits.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17781 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/citations.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10243 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/correlated.c
+-rw-r--r--   0 runner    (1001) docker     (121)    28461 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.507140 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/
+-rw-r--r--   0 runner    (1001) docker     (121)     2488 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2658 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4645 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_definitions.h
+-rw-r--r--   0 runner    (1001) docker     (121)    11754 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2477 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.h
+-rw-r--r--   0 runner    (1001) docker     (121)    33989 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     8107 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.h
+-rw-r--r--   0 runner    (1001) docker     (121)    68755 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)    11924 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8880 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_hash.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2895 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_header.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6818 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_mr-connected.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     8197 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     3022 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.h
+-rw-r--r--   0 runner    (1001) docker     (121)    14049 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_qsort.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7838 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     7459 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2343 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_vertex_cover.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9148 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/dotproduct.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10230 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/erdos_renyi.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6621 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/establishment.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9910 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/forestfire.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5346 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/grg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3302 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/growing_random.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5594 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/islands.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3501 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/k_regular.c
+-rw-r--r--   0 runner    (1001) docker     (121)    24849 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/preference.c
+-rw-r--r--   0 runner    (1001) docker     (121)    14459 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/recent_degree.c
+-rw-r--r--   0 runner    (1001) docker     (121)    23629 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/sbm.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17296 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/static_fitness.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6298 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3599 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/games/watts_strogatz.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.511140 igraph-0.9.9/vendor/source/igraph/src/graph/
+-rw-r--r--   0 runner    (1001) docker     (121)    39893 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/adjlist.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15689 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/attributes.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5893 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/attributes.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2104 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/basic_query.c
+-rw-r--r--   0 runner    (1001) docker     (121)   151977 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/cattributes.c
+-rw-r--r--   0 runner    (1001) docker     (121)    61374 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/iterators.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1496 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/neighbors.h
+-rw-r--r--   0 runner    (1001) docker     (121)    73133 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/type_indexededgelist.c
+-rw-r--r--   0 runner    (1001) docker     (121)    23996 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/graph/visitors.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.511140 igraph-0.9.9/vendor/source/igraph/src/hrg/
+-rw-r--r--   0 runner    (1001) docker     (121)    11754 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/hrg/dendro.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6130 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/hrg/graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5459 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/hrg/graph_simp.h
+-rw-r--r--   0 runner    (1001) docker     (121)    34483 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/hrg/hrg.cc
+-rw-r--r--   0 runner    (1001) docker     (121)   124948 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/hrg/hrg_types.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     6087 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/hrg/rbtree.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6953 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/hrg/splittree_eq.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.515140 igraph-0.9.9/vendor/source/igraph/src/internal/
+-rw-r--r--   0 runner    (1001) docker     (121)     5356 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/glpk_support.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5581 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/glpk_support.h
+-rw-r--r--   0 runner    (1001) docker     (121)      931 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/gmp_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1631 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/hacks.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1605 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/hacks.h
+-rw-r--r--   0 runner    (1001) docker     (121)    16067 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/lsap.c
+-rw-r--r--   0 runner    (1001) docker     (121)    29986 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/pstdint.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7133 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/qsort.c
+-rw-r--r--   0 runner    (1001) docker     (121)      217 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/qsort_r.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7962 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/internal/zeroin.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.519141 igraph-0.9.9/vendor/source/igraph/src/io/
+-rw-r--r--   0 runner    (1001) docker     (121)    11444 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/dimacs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1350 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/dl-header.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4481 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/dl-lexer.l
+-rw-r--r--   0 runner    (1001) docker     (121)     9944 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/dl-parser.y
+-rw-r--r--   0 runner    (1001) docker     (121)     5901 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/dl.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13291 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/dot.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5135 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/edgelist.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1332 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/gml-header.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3561 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/gml-lexer.l
+-rw-r--r--   0 runner    (1001) docker     (121)     8625 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/gml-parser.y
+-rw-r--r--   0 runner    (1001) docker     (121)     7801 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/gml-tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3237 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/gml-tree.h
+-rw-r--r--   0 runner    (1001) docker     (121)    32748 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/gml.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3717 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/graphdb.c
+-rw-r--r--   0 runner    (1001) docker     (121)    71156 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/graphml.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9969 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/leda.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1155 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/lgl-header.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2992 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/lgl-lexer.l
+-rw-r--r--   0 runner    (1001) docker     (121)     4305 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/lgl-parser.y
+-rw-r--r--   0 runner    (1001) docker     (121)    15690 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/lgl.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1137 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/ncol-header.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2960 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/ncol-lexer.l
+-rw-r--r--   0 runner    (1001) docker     (121)     4101 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/ncol-parser.y
+-rw-r--r--   0 runner    (1001) docker     (121)    14461 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/ncol.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1453 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/pajek-header.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6647 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/pajek-lexer.l
+-rw-r--r--   0 runner    (1001) docker     (121)    24603 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/pajek-parser.y
+-rw-r--r--   0 runner    (1001) docker     (121)    30263 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/io/pajek.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.523141 igraph-0.9.9/vendor/source/igraph/src/io/parsers/
+-rw-r--r--   0 runner    (1001) docker     (121)    68546 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-lexer.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17279 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-lexer.h
+-rw-r--r--   0 runner    (1001) docker     (121)    69128 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-parser.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3096 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-parser.h
+-rw-r--r--   0 runner    (1001) docker     (121)    62829 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-lexer.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17359 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-lexer.h
+-rw-r--r--   0 runner    (1001) docker     (121)    60940 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-parser.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3000 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-parser.h
+-rw-r--r--   0 runner    (1001) docker     (121)    61120 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-lexer.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17359 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-lexer.h
+-rw-r--r--   0 runner    (1001) docker     (121)    55751 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-parser.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2900 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-parser.h
+-rw-r--r--   0 runner    (1001) docker     (121)    61106 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-lexer.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17491 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-lexer.h
+-rw-r--r--   0 runner    (1001) docker     (121)    55327 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-parser.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2893 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-parser.h
+-rw-r--r--   0 runner    (1001) docker     (121)    78916 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-lexer.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17623 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-lexer.h
+-rw-r--r--   0 runner    (1001) docker     (121)    91653 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-parser.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3784 2022-01-05 07:45:33.000000 igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-parser.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.523141 igraph-0.9.9/vendor/source/igraph/src/isomorphism/
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.527141 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/
+-rw-r--r--   0 runner    (1001) docker     (121)     1131 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     2315 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/bignum.hh
+-rw-r--r--   0 runner    (1001) docker     (121)      864 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/defs.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     2513 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/defs.hh
+-rw-r--r--   0 runner    (1001) docker     (121)   148891 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/graph.cc
+-rw-r--r--   0 runner    (1001) docker     (121)    29652 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/graph.hh
+-rw-r--r--   0 runner    (1001) docker     (121)     2248 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/heap.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     2087 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/heap.hh
+-rw-r--r--   0 runner    (1001) docker     (121)     1267 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/igraph-changes.md
+-rw-r--r--   0 runner    (1001) docker     (121)     3317 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/kqueue.hh
+-rw-r--r--   0 runner    (1001) docker     (121)     3022 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/kstack.hh
+-rw-r--r--   0 runner    (1001) docker     (121)     3083 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/orbit.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     3092 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/orbit.hh
+-rw-r--r--   0 runner    (1001) docker     (121)    29783 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/partition.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     8323 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/partition.hh
+-rw-r--r--   0 runner    (1001) docker     (121)     3083 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/stats.hh
+-rw-r--r--   0 runner    (1001) docker     (121)     4439 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     1997 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.hh
+-rw-r--r--   0 runner    (1001) docker     (121)     1501 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/utils.cc
+-rw-r--r--   0 runner    (1001) docker     (121)     1297 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/utils.hh
+-rw-r--r--   0 runner    (1001) docker     (121)    21930 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss.cc
+-rw-r--r--   0 runner    (1001) docker     (121)   193428 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/isoclasses.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1616 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/isoclasses.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3987 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/isomorphism_misc.c
+-rw-r--r--   0 runner    (1001) docker     (121)    64777 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/lad.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7173 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/queries.c
+-rw-r--r--   0 runner    (1001) docker     (121)    76529 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/isomorphism/vf2.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.527141 igraph-0.9.9/vendor/source/igraph/src/layout/
+-rw-r--r--   0 runner    (1001) docker     (121)     6265 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/circular.c
+-rw-r--r--   0 runner    (1001) docker     (121)    19005 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/davidson_harel.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.531141 igraph-0.9.9/vendor/source/igraph/src/layout/drl/
+-rw-r--r--   0 runner    (1001) docker     (121)     9108 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2773 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid.h
+-rw-r--r--   0 runner    (1001) docker     (121)    10327 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid_3d.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2820 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid_3d.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2309 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_Node.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2327 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_Node_3d.h
+-rw-r--r--   0 runner    (1001) docker     (121)    41396 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     4913 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph.h
+-rw-r--r--   0 runner    (1001) docker     (121)    29053 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph_3d.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     4569 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph_3d.h
+-rw-r--r--   0 runner    (1001) docker     (121)    16844 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2978 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4658 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout_3d.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2974 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout_3d.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7354 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_parse.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)     2681 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_parse.h
+-rw-r--r--   0 runner    (1001) docker     (121)    28624 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/fruchterman_reingold.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9596 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/gem.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17302 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/graphopt.c
+-rw-r--r--   0 runner    (1001) docker     (121)    28434 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/kamada_kawai.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13672 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/large_graph.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3124 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/layout_bipartite.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3738 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/layout_grid.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2456 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/layout_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2780 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/layout_random.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11954 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/mds.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9893 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/merge_dla.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6678 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/merge_grid.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2302 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/merge_grid.h
+-rw-r--r--   0 runner    (1001) docker     (121)    39548 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/reingold_tilford.c
+-rw-r--r--   0 runner    (1001) docker     (121)    54236 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/layout/sugiyama.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.531141 igraph-0.9.9/vendor/source/igraph/src/linalg/
+-rw-r--r--   0 runner    (1001) docker     (121)    52242 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/linalg/arpack.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8931 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/linalg/arpack_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5031 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/linalg/blas.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3152 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/linalg/blas_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)    51310 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/linalg/eigen.c
+-rw-r--r--   0 runner    (1001) docker     (121)    35661 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/linalg/lapack.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6932 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/linalg/lapack_internal.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.531141 igraph-0.9.9/vendor/source/igraph/src/math/
+-rw-r--r--   0 runner    (1001) docker     (121)     7462 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/math/bfgs.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12037 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/math/complex.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10363 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/math/utils.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.535141 igraph-0.9.9/vendor/source/igraph/src/misc/
+-rw-r--r--   0 runner    (1001) docker     (121)    41796 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/bipartite.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16182 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/chordality.c
+-rw-r--r--   0 runner    (1001) docker     (121)    28969 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/cocitation.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5635 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/coloring.c
+-rw-r--r--   0 runner    (1001) docker     (121)    34809 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/conversion.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1016 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/conversion_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)    28165 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/degree_sequence.cpp
+-rw-r--r--   0 runner    (1001) docker     (121)    40281 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/embedding.c
+-rw-r--r--   0 runner    (1001) docker     (121)    25758 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/feedback_arc_set.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1365 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/feedback_arc_set.h
+-rw-r--r--   0 runner    (1001) docker     (121)    33818 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/graphicality.c
+-rw-r--r--   0 runner    (1001) docker     (121)    42594 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/matching.c
+-rw-r--r--   0 runner    (1001) docker     (121)    60098 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/microscopic_update.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10818 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/mixing.c
+-rw-r--r--   0 runner    (1001) docker     (121)    43785 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/motifs.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16665 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/other.c
+-rw-r--r--   0 runner    (1001) docker     (121)    31712 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/scan.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9441 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/sir.c
+-rw-r--r--   0 runner    (1001) docker     (121)    18696 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/misc/spanning_trees.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.539141 igraph-0.9.9/vendor/source/igraph/src/operators/
+-rw-r--r--   0 runner    (1001) docker     (121)     2079 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/add_edge.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3618 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/complementer.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4927 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/compose.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6227 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/connect_neighborhood.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5410 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/contract.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6429 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/difference.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6306 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/disjoint_union.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11820 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/intersection.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9312 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/misc_internal.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1596 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/misc_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3561 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/permute.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10829 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/rewire.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13618 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/rewire_edges.c
+-rw-r--r--   0 runner    (1001) docker     (121)      257 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/rewire_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5747 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/simplify.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17609 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/subgraph.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1235 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/subgraph.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9910 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/operators/union.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.539141 igraph-0.9.9/vendor/source/igraph/src/paths/
+-rw-r--r--   0 runner    (1001) docker     (121)    12155 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/all_shortest_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)    22910 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/bellman_ford.c
+-rw-r--r--   0 runner    (1001) docker     (121)    43461 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/dijkstra.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7446 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/distances.c
+-rw-r--r--   0 runner    (1001) docker     (121)    22639 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/eulerian.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5132 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/histogram.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7859 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/johnson.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10520 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/random_walk.c
+-rw-r--r--   0 runner    (1001) docker     (121)    46392 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/shortest_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6276 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/simple_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)    19743 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/paths/unweighted.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.543141 igraph-0.9.9/vendor/source/igraph/src/properties/
+-rw-r--r--   0 runner    (1001) docker     (121)    10821 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/basic_properties.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12399 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/constraint.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8628 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/convergence_degree.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10733 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/dag.c
+-rw-r--r--   0 runner    (1001) docker     (121)    18060 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/degrees.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7462 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/girth.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2823 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/loops.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12159 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/multiplicity.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17948 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/neighborhood.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1087 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/properties_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)    16328 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/spectral.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12114 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/trees.c
+-rw-r--r--   0 runner    (1001) docker     (121)    33812 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/triangles.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4125 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/triangles_template.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2951 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/properties/triangles_template1.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.543141 igraph-0.9.9/vendor/source/igraph/src/random/
+-rw-r--r--   0 runner    (1001) docker     (121)    74866 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/random/random.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.543141 igraph-0.9.9/vendor/source/igraph/src/scg/
+-rw-r--r--   0 runner    (1001) docker     (121)    94554 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/scg/scg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6253 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/scg/scg_approximate_methods.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2250 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/scg/scg_exact_scg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4970 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/scg/scg_headers.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3441 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/scg/scg_kmeans.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8033 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/scg/scg_optimal_method.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3076 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/scg/scg_utils.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2205 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/src/version.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.543141 igraph-0.9.9/vendor/source/igraph/tests/
+-rw-r--r--   0 runner    (1001) docker     (121)    16044 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.543141 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/
+-rw-r--r--   0 runner    (1001) docker     (121)     2109 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/bench.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2794 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_average_path_length_unweighted.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2958 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_betweenness.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5354 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_betweenness_weighted.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1374 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_cliques.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5396 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_closeness_weighted.c
+-rw-r--r--   0 runner    (1001) docker     (121)      887 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_coloring.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1099 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_decompose.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2176 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_maximal_cliques.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5148 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_pagerank.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6036 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_pagerank_weighted.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5343 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_power_law_fit.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3598 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_random_walk.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5498 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_transitivity.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.547141 igraph-0.9.9/vendor/source/igraph/tests/regression/
+-rw-r--r--   0 runner    (1001) docker     (121)     1606 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/bug-1033045.c
+-rw-r--r--   0 runner    (1001) docker     (121)       50 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/bug-1033045.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1445 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/bug-1149658.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5110 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/bug_1760.c
+-rw-r--r--   0 runner    (1001) docker     (121)      446 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/bug_1760.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1436 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/bug_1814.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1197 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/bug_1814.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1630 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/cattr_bool_bug.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2343 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/cattr_bool_bug.graphml
+-rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/cattr_bool_bug2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      419 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/cattr_bool_bug2.graphml
+-rw-r--r--   0 runner    (1001) docker     (121)     1029 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_layout_kamada_kawai_3d_bug_1462.c
+-rw-r--r--   0 runner    (1001) docker     (121)       37 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_layout_kamada_kawai_3d_bug_1462.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1650 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.c
+-rw-r--r--   0 runner    (1001) docker     (121)       66 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.in
+-rw-r--r--   0 runner    (1001) docker     (121)      224 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2041 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_read_graph_gml_invalid_inputs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2249 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_read_graph_graphml_invalid_inputs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3634 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid1.gml
+-rw-r--r--   0 runner    (1001) docker     (121)      818 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid1.graphml
+-rw-r--r--   0 runner    (1001) docker     (121)        6 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid2.gml
+-rw-r--r--   0 runner    (1001) docker     (121)     1122 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid2.graphml
+-rw-r--r--   0 runner    (1001) docker     (121)     1654 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid3.gml
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid3.graphml
+-rw-r--r--   0 runner    (1001) docker     (121)       10 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid4.gml
+-rw-r--r--   0 runner    (1001) docker     (121)       29 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid5.gml
+-rw-r--r--   0 runner    (1001) docker     (121)       45 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/regression/invalid6.gml
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.623142 igraph-0.9.9/vendor/source/igraph/tests/unit/
+-rw-r--r--   0 runner    (1001) docker     (121)     4785 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/2wheap.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7751 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/VF2-compat.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11292 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/adjlist.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7308 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/adjlist.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4665 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/all_shortest_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)      304 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/all_shortest_paths.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4292 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/bfs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      531 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/bfs.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2304 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/bfs_simple.c
+-rw-r--r--   0 runner    (1001) docker     (121)      209 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/bfs_simple.out
+-rw-r--r--   0 runner    (1001) docker     (121)      169 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/bipartite.net
+-rw-r--r--   0 runner    (1001) docker     (121)      914 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/bliss_automorphisms.c
+-rw-r--r--   0 runner    (1001) docker     (121)      162 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/bliss_automorphisms.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6903 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/cattributes5.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7420 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/cattributes5.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3951 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/community_label_propagation.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/community_label_propagation.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2014 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/community_label_propagation2.c
+-rw-r--r--   0 runner    (1001) docker     (121)       46 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/community_label_propagation2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2441 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/community_label_propagation3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7007 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/community_leiden.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1390 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/community_leiden.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1361 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/cutheap.c
+-rw-r--r--   0 runner    (1001) docker     (121)       21 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/cutheap.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3186 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/d_indheap.c
+-rw-r--r--   0 runner    (1001) docker     (121)       98 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/d_indheap.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2095 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/dgemv.c
+-rw-r--r--   0 runner    (1001) docker     (121)      650 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/dgemv.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4336 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/edge_selectors.c
+-rw-r--r--   0 runner    (1001) docker     (121)      297 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/edge_selectors.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4656 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/efficiency.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2768 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/efficiency.out
+-rw-r--r--   0 runner    (1001) docker     (121)     9010 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/erdos_renyi_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1973 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/error_macros.c
+-rw-r--r--   0 runner    (1001) docker     (121)      111 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/error_macros.out
+-rw-r--r--   0 runner    (1001) docker     (121)      542 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/fatal_handler.c
+-rw-r--r--   0 runner    (1001) docker     (121)       40 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/fatal_handler.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2109 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/full.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1569 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/full.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3348 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/global_transitivity.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/global_transitivity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2302 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/glpk_error.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4873 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/harmonic_centrality.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1255 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/harmonic_centrality.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4437 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/hashtable.c
+-rw-r--r--   0 runner    (1001) docker     (121)      162 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/hashtable.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4849 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/heap.c
+-rw-r--r--   0 runner    (1001) docker     (121)      772 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/heap.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1374 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adhesion.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2209 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1011 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2022 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adjacent_triangles.c
+-rw-r--r--   0 runner    (1001) docker     (121)      381 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adjacent_triangles.out
+-rw-r--r--   0 runner    (1001) docker     (121)    13369 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_all_st_cuts.c
+-rw-r--r--   0 runner    (1001) docker     (121)      886 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_all_st_cuts.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6964 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_almost_equals.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2137 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_are_connected.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7041 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.c
+-rw-r--r--   0 runner    (1001) docker     (121)      662 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4485 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2826 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2127 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_array.c
+-rw-r--r--   0 runner    (1001) docker     (121)      502 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_array.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2373 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_attribute_combination_remove.c
+-rw-r--r--   0 runner    (1001) docker     (121)      307 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_attribute_combination_remove.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2543 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length.c
+-rw-r--r--   0 runner    (1001) docker     (121)      832 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3502 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.c
+-rw-r--r--   0 runner    (1001) docker     (121)      731 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6428 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      594 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)    10952 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_betweenness.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1559 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_betweenness.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1190 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_bipartite_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      938 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_bridges.c
+-rw-r--r--   0 runner    (1001) docker     (121)        8 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_bridges.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4173 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_callaway_traits_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4922 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_cited_type_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      523 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_cited_type_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3519 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_citing_cited_type_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      137 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_citing_cited_type_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1769 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_clique_size_hist.c
+-rw-r--r--   0 runner    (1001) docker     (121)      204 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_clique_size_hist.out
+-rw-r--r--   0 runner    (1001) docker     (121)    11054 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_closeness.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3610 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_closeness.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1380 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_cohesion.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13228 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_community_infomap.c
+-rw-r--r--   0 runner    (1001) docker     (121)      892 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_community_infomap.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3690 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_community_leading_eigenvector2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      197 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_community_leading_eigenvector2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4107 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_compare_communities.c
+-rw-r--r--   0 runner    (1001) docker     (121)      644 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_compare_communities.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6314 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_complex.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1688 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_convergence_degree.c
+-rw-r--r--   0 runner    (1001) docker     (121)      111 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_convergence_degree.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1408 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_correlated_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      804 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_count_multiple.c
+-rw-r--r--   0 runner    (1001) docker     (121)       32 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_count_multiple.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2238 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_decompose_strong.c
+-rw-r--r--   0 runner    (1001) docker     (121)       52 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_decompose_strong.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6465 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_degree_sequence_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4267 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_density.c
+-rw-r--r--   0 runner    (1001) docker     (121)      185 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_density.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1982 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_diversity.c
+-rw-r--r--   0 runner    (1001) docker     (121)      113 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_diversity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2003 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_dyad_census.c
+-rw-r--r--   0 runner    (1001) docker     (121)      271 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_dyad_census.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2630 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eccentricity.c
+-rw-r--r--   0 runner    (1001) docker     (121)      263 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eccentricity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     7037 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_edge_betweenness.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1653 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_edge_betweenness.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1116 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_edge_disjoint_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4813 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix.c
+-rw-r--r--   0 runner    (1001) docker     (121)      125 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3832 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      131 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3193 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix3.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix3.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3295 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix4.c
+-rw-r--r--   0 runner    (1001) docker     (121)      308 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix4.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4124 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric.c
+-rw-r--r--   0 runner    (1001) docker     (121)      192 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4195 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric_arpack.c
+-rw-r--r--   0 runner    (1001) docker     (121)      166 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric_arpack.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2182 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_es_path.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3584 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_establishment_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5749 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eulerian_cycle.c
+-rw-r--r--   0 runner    (1001) docker     (121)      246 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eulerian_cycle.out
+-rw-r--r--   0 runner    (1001) docker     (121)    14892 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eulerian_path.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1056 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eulerian_path.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2797 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_extended_chordal_ring.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2729 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_forest_fire_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      354 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_forest_fire_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1227 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_from_prufer.c
+-rw-r--r--   0 runner    (1001) docker     (121)      163 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_from_prufer.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2147 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_full_citation.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2248 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1623 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1827 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_all_simple_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)      298 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_all_simple_paths.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2780 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_incidence.c
+-rw-r--r--   0 runner    (1001) docker     (121)      527 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_incidence.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5147 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      990 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3143 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_shortest_paths2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      166 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_shortest_paths2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     9585 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_shortest_paths_bellman_ford.c
+-rw-r--r--   0 runner    (1001) docker     (121)      278 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_shortest_paths_bellman_ford.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5982 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1059 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     8497 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_gomory_hu_tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1243 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_grg_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2262 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_growing_random_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2384 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_hrg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3347 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_hrg2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3217 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_hrg3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5288 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_incident.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1294 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_incident.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2822 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_layout_sphere.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5310 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_neighbors.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1301 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_neighbors.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3282 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_induced_subgraph.c
+-rw-r--r--   0 runner    (1001) docker     (121)      108 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_induced_subgraph.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2014 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_induced_subgraph_map.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1904 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_intersection2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      103 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_intersection2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1507 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_bigraphical.c
+-rw-r--r--   0 runner    (1001) docker     (121)      275 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_bigraphical.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1334 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_bipartite.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3434 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_chordal.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1162 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_chordal.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1976 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_connected.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8067 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_eulerian.c
+-rw-r--r--   0 runner    (1001) docker     (121)      136 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_eulerian.out
+-rw-r--r--   0 runner    (1001) docker     (121)     7859 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_graphical.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2863 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_graphical.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2211 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_mutual.c
+-rw-r--r--   0 runner    (1001) docker     (121)      170 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_mutual.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2602 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_same_graph.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3315 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4764 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1051 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6261 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_k_regular_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      312 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_k_regular_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2333 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_kautz.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2530 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgehrd.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgehrd.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2472 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.c
+-rw-r--r--   0 runner    (1001) docker     (121)      657 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4907 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      997 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3867 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lastcit_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      137 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lastcit_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6768 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lattice.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4662 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_bipartite.c
+-rw-r--r--   0 runner    (1001) docker     (121)      961 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_bipartite.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3591 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_davidson_harel.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3446 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_drl.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5396 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_fruchterman_reingold.c
+-rw-r--r--   0 runner    (1001) docker     (121)      434 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_fruchterman_reingold.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4718 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_graphopt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      506 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_graphopt.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1996 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_grid.c
+-rw-r--r--   0 runner    (1001) docker     (121)      506 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_grid.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1739 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_lgl.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2962 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_mds.c
+-rw-r--r--   0 runner    (1001) docker     (121)      175 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_mds.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2501 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_merge.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2778 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_merge2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      194 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_merge2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1417 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_merge3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1769 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_random_3d.c
+-rw-r--r--   0 runner    (1001) docker     (121)      375 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_random_3d.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4737 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.c
+-rw-r--r--   0 runner    (1001) docker     (121)      934 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1514 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_extended.c
+-rw-r--r--   0 runner    (1001) docker     (121)       16 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_extended.in
+-rw-r--r--   0 runner    (1001) docker     (121)     2180 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_star.c
+-rw-r--r--   0 runner    (1001) docker     (121)      532 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_star.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3545 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.c
+-rw-r--r--   0 runner    (1001) docker     (121)      552 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4151 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_le_community_to_membership.c
+-rw-r--r--   0 runner    (1001) docker     (121)      375 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_le_community_to_membership.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2492 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_linegraph.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1827 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_list_triangles.c
+-rw-r--r--   0 runner    (1001) docker     (121)      180 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_list_triangles.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3388 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.c
+-rw-r--r--   0 runner    (1001) docker     (121)      531 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.out
+-rw-r--r--   0 runner    (1001) docker     (121)     9243 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_transitivity.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1783 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_transitivity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2888 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques2.c
+-rw-r--r--   0 runner    (1001) docker     (121)       66 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2087 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1199 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3055 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.c
+-rw-r--r--   0 runner    (1001) docker     (121)      744 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1720 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.c
+-rw-r--r--   0 runner    (1001) docker     (121)      198 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4771 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_modularity.c
+-rw-r--r--   0 runner    (1001) docker     (121)      486 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_modularity.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4966 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_modularity_matrix.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1735 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_modularity_matrix.out
+-rw-r--r--   0 runner    (1001) docker     (121)     8675 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_moran_process.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2370 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu.c
+-rw-r--r--   0 runner    (1001) docker     (121)      967 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4166 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.c
+-rw-r--r--   0 runner    (1001) docker     (121)      599 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2871 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.c
+-rw-r--r--   0 runner    (1001) docker     (121)      356 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3754 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood.c
+-rw-r--r--   0 runner    (1001) docker     (121)      743 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4045 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1679 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3528 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_size.c
+-rw-r--r--   0 runner    (1001) docker     (121)      571 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_size.out
+-rw-r--r--   0 runner    (1001) docker     (121)    14696 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_pagerank.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2232 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_pagerank.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6316 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_preference_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      918 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_progress_handler_stderr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6028 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_psumtree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1608 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_qsort.c
+-rw-r--r--   0 runner    (1001) docker     (121)      290 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_qsort.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1923 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_qsort_r.c
+-rw-r--r--   0 runner    (1001) docker     (121)      291 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_qsort_r.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1790 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_random_walk.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4395 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8144 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4500 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      519 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3202 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_recent_degree_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      232 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_recent_degree_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2096 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_residual_graph.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3316 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rewire.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3701 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rewire_directed_edges.c
+-rw-r--r--   0 runner    (1001) docker     (121)       76 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rewire_directed_edges.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1097 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rng_get_exp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9057 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rng_get_exp.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1700 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rng_get_integer.c
+-rw-r--r--   0 runner    (1001) docker     (121)      118 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rng_get_integer.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2180 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_running_mean.c
+-rw-r--r--   0 runner    (1001) docker     (121)      187 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_running_mean.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4942 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sbm_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1057 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sbm_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1490 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_set_progress_handler.c
+-rw-r--r--   0 runner    (1001) docker     (121)      162 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_set_progress_handler.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3254 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.c
+-rw-r--r--   0 runner    (1001) docker     (121)      730 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3730 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      514 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2881 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sir.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1396 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sir.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2195 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_solve_lsap.c
+-rw-r--r--   0 runner    (1001) docker     (121)      109 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_solve_lsap.out
+-rw-r--r--   0 runner    (1001) docker     (121)     8010 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat2.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat2.out
+-rw-r--r--   0 runner    (1001) docker     (121)    12979 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat5.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2255 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat5.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2667 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat9.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2462 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_droptol.c
+-rw-r--r--   0 runner    (1001) docker     (121)      349 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_droptol.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2918 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_fkeep.c
+-rw-r--r--   0 runner    (1001) docker     (121)      316 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_fkeep.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3001 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_getelements_sorted.c
+-rw-r--r--   0 runner    (1001) docker     (121)      268 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_getelements_sorted.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2005 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_is_symmetric.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2153 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_iterator_idx.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5613 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.c
+-rw-r--r--   0 runner    (1001) docker     (121)      864 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2650 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_nonzero_storage.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1582 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_view.c
+-rw-r--r--   0 runner    (1001) docker     (121)       94 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_view.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6906 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.c
+-rw-r--r--   0 runner    (1001) docker     (121)      669 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3373 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_split_join_distance.c
+-rw-r--r--   0 runner    (1001) docker     (121)      284 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_split_join_distance.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1813 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_spmatrix_add_col_values.c
+-rw-r--r--   0 runner    (1001) docker     (121)      381 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_spmatrix_add_col_values.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1117 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_st_edge_connectivity.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2071 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_st_mincut.c
+-rw-r--r--   0 runner    (1001) docker     (121)       50 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_st_mincut.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1263 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_st_mincut_value.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3436 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_static_power_law_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      253 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_static_power_law_game.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2614 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_subcomponent.c
+-rw-r--r--   0 runner    (1001) docker     (121)      460 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_subcomponent.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2257 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_subisomorphic.c
+-rw-r--r--   0 runner    (1001) docker     (121)      996 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_to_directed.c
+-rw-r--r--   0 runner    (1001) docker     (121)      329 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_to_directed.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4748 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_to_prufer.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1667 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitive_closure_dag.c
+-rw-r--r--   0 runner    (1001) docker     (121)       36 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitive_closure_dag.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2887 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitivity_avglocal_undirected.c
+-rw-r--r--   0 runner    (1001) docker     (121)      219 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitivity_avglocal_undirected.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5625 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.c
+-rw-r--r--   0 runner    (1001) docker     (121)      914 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1286 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vector_floor.c
+-rw-r--r--   0 runner    (1001) docker     (121)       67 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vector_floor.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1876 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vector_lex_cmp.c
+-rw-r--r--   0 runner    (1001) docker     (121)      311 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vector_lex_cmp.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1124 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vertex_disjoint_paths.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6496 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_weighted_cliques.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2459 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_weighted_cliques.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2079 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_write_graph_dimacs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      206 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_write_graph_dimacs.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3580 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_write_graph_leda.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1013 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_write_graph_leda.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5630 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/inclist.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3858 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/inclist.out
+-rw-r--r--   0 runner    (1001) docker     (121)      783 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/input.dl
+-rw-r--r--   0 runner    (1001) docker     (121)     2179 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/isoclasses.c
+-rw-r--r--   0 runner    (1001) docker     (121)       38 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/isoclasses.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4840 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/isoclasses2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7684 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/isomorphism_test.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/isomorphism_test.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2352 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/levc-stress.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1905 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/lineendings.c
+-rw-r--r--   0 runner    (1001) docker     (121)      228 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/lineendings.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1796 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/marked_queue.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4528 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/matrix.c
+-rw-r--r--   0 runner    (1001) docker     (121)      861 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/matrix.out
+-rw-r--r--   0 runner    (1001) docker     (121)     9087 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/matrix2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3908 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/matrix2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1337 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/matrix3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2447 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/maximal_cliques_callback.c
+-rw-r--r--   0 runner    (1001) docker     (121)      450 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/maximal_cliques_hist.c
+-rw-r--r--   0 runner    (1001) docker     (121)        6 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/maximal_cliques_hist.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1136 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/mt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1587 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek.c
+-rw-r--r--   0 runner    (1001) docker     (121)      516 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek1.net
+-rw-r--r--   0 runner    (1001) docker     (121)     1540 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      516 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek2.net
+-rw-r--r--   0 runner    (1001) docker     (121)       27 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek2.out
+-rw-r--r--   0 runner    (1001) docker     (121)      537 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek3.net
+-rw-r--r--   0 runner    (1001) docker     (121)      536 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek4.net
+-rw-r--r--   0 runner    (1001) docker     (121)      518 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek5.net
+-rw-r--r--   0 runner    (1001) docker     (121)      517 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek6.net
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bip.net
+-rw-r--r--   0 runner    (1001) docker     (121)      249 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bip2.net
+-rw-r--r--   0 runner    (1001) docker     (121)     1469 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bipartite.c
+-rw-r--r--   0 runner    (1001) docker     (121)      126 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bipartite.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3571 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bipartite2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2314 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bipartite2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3118 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_signed.c
+-rw-r--r--   0 runner    (1001) docker     (121)      364 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_signed.net
+-rw-r--r--   0 runner    (1001) docker     (121)     1435 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_signed.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2480 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/random_spanning_tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6181 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/ring.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1924 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/rng_init_destroy_max_min_name_set_default.c
+-rw-r--r--   0 runner    (1001) docker     (121)      142 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/rng_init_destroy_max_min_name_set_default.out
+-rw-r--r--   0 runner    (1001) docker     (121)      463 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/rng_reproducibility.c
+-rw-r--r--   0 runner    (1001) docker     (121)      475 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/rng_reproducibility.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5523 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/scg2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1872 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/scg2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     4474 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/scg3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1945 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/scg3.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2165 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/set.c
+-rw-r--r--   0 runner    (1001) docker     (121)       55 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/set.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1625 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/simplify_and_colorize.c
+-rw-r--r--   0 runner    (1001) docker     (121)      519 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/simplify_and_colorize.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2506 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/single_target_shortest_path.c
+-rw-r--r--   0 runner    (1001) docker     (121)       43 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/single_target_shortest_path.out
+-rw-r--r--   0 runner    (1001) docker     (121)     5982 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/spinglass.c
+-rw-r--r--   0 runner    (1001) docker     (121)      232 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/spinglass.out
+-rw-r--r--   0 runner    (1001) docker     (121)     6267 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1669 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1787 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix_clear.c
+-rw-r--r--   0 runner    (1001) docker     (121)      649 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix_clear.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2346 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/stack.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2236 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/strvector_set2_remove_print.c
+-rw-r--r--   0 runner    (1001) docker     (121)      287 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/strvector_set2_remove_print.out
+-rw-r--r--   0 runner    (1001) docker     (121)    13794 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/test_utilities.inc
+-rw-r--r--   0 runner    (1001) docker     (121)     1500 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/tls1.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7442 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/tls2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      606 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/tls2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     2602 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/topological_sorting.c
+-rw-r--r--   0 runner    (1001) docker     (121)       40 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/topological_sorting.out
+-rw-r--r--   0 runner    (1001) docker     (121)      903 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)      464 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/tree.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3403 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/tree_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)      980 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/triad_census.c
+-rw-r--r--   0 runner    (1001) docker     (121)       79 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/triad_census.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3871 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/trie.c
+-rw-r--r--   0 runner    (1001) docker     (121)      336 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/trie.out
+-rw-r--r--   0 runner    (1001) docker     (121)    12137 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vector.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1670 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vector.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3625 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vector2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      294 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vector2.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1652 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vector3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8264 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vector_ptr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2975 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vertex_selectors.c
+-rw-r--r--   0 runner    (1001) docker     (121)      291 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/vertex_selectors.out
+-rw-r--r--   0 runner    (1001) docker     (121)     3998 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/watts_strogatz_game.c
+-rw-r--r--   0 runner    (1001) docker     (121)    79087 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/wikti_en_V_syn.elist
+-rw-r--r--   0 runner    (1001) docker     (121)     1013 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tests/unit/zero_allocs.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.623142 igraph-0.9.9/vendor/source/igraph/tools/
+-rw-r--r--   0 runner    (1001) docker     (121)     2198 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/arpack-sed.txt
+-rwxr-xr-x   0 runner    (1001) docker     (121)     2001 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/bump_version.sh
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.623142 igraph-0.9.9/vendor/source/igraph/tools/isoclasses/
+-rw-r--r--   0 runner    (1001) docker     (121)     2453 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/isoclasses/isoclasses.m
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.623142 igraph-0.9.9/vendor/source/igraph/tools/lapack/
+-rwxr-xr-x   0 runner    (1001) docker     (121)     1151 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/CompletePolish
+-rw-r--r--   0 runner    (1001) docker     (121)      299 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/Makefile
+-rw-r--r--   0 runner    (1001) docker     (121)      336 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/comment.l
+-rw-r--r--   0 runner    (1001) docker     (121)       79 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/delete.sed
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.623142 igraph-0.9.9/vendor/source/igraph/tools/lapack/extra/
+-rw-r--r--   0 runner    (1001) docker     (121)      270 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/extra/len_trim.f
+-rwxr-xr-x   0 runner    (1001) docker     (121)     4947 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/getlapack.sh
+-rw-r--r--   0 runner    (1001) docker     (121)     4789 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/lapack.patch
+-rw-r--r--   0 runner    (1001) docker     (121)     1370 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/lenscrub.l
+-rw-r--r--   0 runner    (1001) docker     (121)    29859 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/mt.patch
+-rw-r--r--   0 runner    (1001) docker     (121)      638 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/lapack/split.sed
+-rwxr-xr-x   0 runner    (1001) docker     (121)      749 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/tools/removeexamples.py
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.623142 igraph-0.9.9/vendor/source/igraph/vendor/
+-rw-r--r--   0 runner    (1001) docker     (121)      142 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.631142 igraph-0.9.9/vendor/source/igraph/vendor/cs/
+-rw-r--r--   0 runner    (1001) docker     (121)     1884 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)      893 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/License.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     7783 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/SuiteSparse_config.h
+-rw-r--r--   0 runner    (1001) docker     (121)    32854 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1419 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_add.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16514 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_amd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2877 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_chol.c
+-rw-r--r--   0 runner    (1001) docker     (121)      869 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_cholsol.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1005 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_compress.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2883 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_counts.c
+-rw-r--r--   0 runner    (1001) docker     (121)      579 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_cumsum.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1645 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_dfs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6422 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_dmperm.c
+-rw-r--r--   0 runner    (1001) docker     (121)      252 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_droptol.c
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_dropzeros.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1405 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_dupl.c
+-rw-r--r--   0 runner    (1001) docker     (121)      459 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_entry.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1118 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_ereach.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1375 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_etree.c
+-rw-r--r--   0 runner    (1001) docker     (121)      961 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_fkeep.c
+-rw-r--r--   0 runner    (1001) docker     (121)      438 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_gaxpy.c
+-rw-r--r--   0 runner    (1001) docker     (121)      605 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_happly.c
+-rw-r--r--   0 runner    (1001) docker     (121)      866 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_house.c
+-rw-r--r--   0 runner    (1001) docker     (121)      332 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_ipvec.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1039 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_leaf.c
+-rw-r--r--   0 runner    (1001) docker     (121)      755 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_load.c
+-rw-r--r--   0 runner    (1001) docker     (121)      522 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_lsolve.c
+-rw-r--r--   0 runner    (1001) docker     (121)      547 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_ltsolve.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4129 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_lu.c
+-rw-r--r--   0 runner    (1001) docker     (121)      873 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_lusol.c
+-rw-r--r--   0 runner    (1001) docker     (121)      902 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_malloc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4507 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_maxtrans.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1577 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_multiply.c
+-rw-r--r--   0 runner    (1001) docker     (121)      479 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_norm.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1047 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_permute.c
+-rw-r--r--   0 runner    (1001) docker     (121)      482 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_pinv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1091 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_post.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1854 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_print.c
+-rw-r--r--   0 runner    (1001) docker     (121)      331 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_pvec.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3527 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_qr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1883 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_qrsol.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1018 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_randperm.c
+-rw-r--r--   0 runner    (1001) docker     (121)      697 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_reach.c
+-rw-r--r--   0 runner    (1001) docker     (121)      901 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_scatter.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1892 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_scc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1167 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_schol.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1386 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_spsolve.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3834 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_sqr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1783 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_symperm.c
+-rw-r--r--   0 runner    (1001) docker     (121)      941 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_tdfs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1053 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_transpose.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2106 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_updown.c
+-rw-r--r--   0 runner    (1001) docker     (121)      529 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_usolve.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4196 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_util.c
+-rw-r--r--   0 runner    (1001) docker     (121)      548 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_utsolve.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.651142 igraph-0.9.9/vendor/source/igraph/vendor/f2c/
+-rw-r--r--   0 runner    (1001) docker     (121)     5018 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     1212 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/Notice
+-rw-r--r--   0 runner    (1001) docker     (121)    16876 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/README
+-rw-r--r--   0 runner    (1001) docker     (121)      304 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/abort_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5534 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/arithchk.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1328 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/backspac.c
+-rw-r--r--   0 runner    (1001) docker     (121)      280 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_abs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      366 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_cos.c
+-rw-r--r--   0 runner    (1001) docker     (121)      952 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_div.c
+-rw-r--r--   0 runner    (1001) docker     (121)      361 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_exp.c
+-rw-r--r--   0 runner    (1001) docker     (121)      396 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_log.c
+-rw-r--r--   0 runner    (1001) docker     (121)      362 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_sin.c
+-rw-r--r--   0 runner    (1001) docker     (121)      617 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_sqrt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      494 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/cabs.c
+-rw-r--r--   0 runner    (1001) docker     (121)   134980 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/changes
+-rw-r--r--   0 runner    (1001) docker     (121)     1393 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/close.c
+-rw-r--r--   0 runner    (1001) docker     (121)      125 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/comptry.bat
+-rw-r--r--   0 runner    (1001) docker     (121)       40 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/ctype.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1139 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/ctype.h
+-rw-r--r--   0 runner    (1001) docker     (121)      218 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_abs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_acos.c
+-rw-r--r--   0 runner    (1001) docker     (121)      245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_asin.c
+-rw-r--r--   0 runner    (1001) docker     (121)      245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_atan.c
+-rw-r--r--   0 runner    (1001) docker     (121)      271 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_atn2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      255 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_cnjg.c
+-rw-r--r--   0 runner    (1001) docker     (121)      241 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_cos.c
+-rw-r--r--   0 runner    (1001) docker     (121)      245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_cosh.c
+-rw-r--r--   0 runner    (1001) docker     (121)      232 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_dim.c
+-rw-r--r--   0 runner    (1001) docker     (121)      241 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_exp.c
+-rw-r--r--   0 runner    (1001) docker     (121)      201 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_imag.c
+-rw-r--r--   0 runner    (1001) docker     (121)      269 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_int.c
+-rw-r--r--   0 runner    (1001) docker     (121)      291 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_lg10.c
+-rw-r--r--   0 runner    (1001) docker     (121)      241 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_log.c
+-rw-r--r--   0 runner    (1001) docker     (121)      688 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_mod.c
+-rw-r--r--   0 runner    (1001) docker     (121)      281 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_nint.c
+-rw-r--r--   0 runner    (1001) docker     (121)      207 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_prod.c
+-rw-r--r--   0 runner    (1001) docker     (121)      266 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_sign.c
+-rw-r--r--   0 runner    (1001) docker     (121)      241 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_sin.c
+-rw-r--r--   0 runner    (1001) docker     (121)      245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_sinh.c
+-rw-r--r--   0 runner    (1001) docker     (121)      245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_sqrt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      241 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_tan.c
+-rw-r--r--   0 runner    (1001) docker     (121)      245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_tanh.c
+-rw-r--r--   0 runner    (1001) docker     (121)      217 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/derf_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      220 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/derfc_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2624 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/dfe.c
+-rw-r--r--   0 runner    (1001) docker     (121)      471 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/dolio.c
+-rw-r--r--   0 runner    (1001) docker     (121)      972 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/dtime_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1624 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/due.c
+-rw-r--r--   0 runner    (1001) docker     (121)       32 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/dummy.c
+-rw-r--r--   0 runner    (1001) docker     (121)      521 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/ef1asc_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      427 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/ef1cmc_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2838 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/endfile.c
+-rw-r--r--   0 runner    (1001) docker     (121)      248 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/erf_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      251 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/erfc_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6442 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/err.c
+-rw-r--r--   0 runner    (1001) docker     (121)      839 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/etime_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      543 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/exit_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5373 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/f2c.h0
+-rw-r--r--   0 runner    (1001) docker     (121)     6060 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/f2ch.add
+-rw-r--r--   0 runner    (1001) docker     (121)      684 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/f77_aloc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4933 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/f77vers.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2939 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/fio.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8566 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/fmt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2006 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/fmt.h
+-rw-r--r--   0 runner    (1001) docker     (121)      865 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/fmtlib.c
+-rw-r--r--   0 runner    (1001) docker     (121)      665 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/fp.h
+-rw-r--r--   0 runner    (1001) docker     (121)      900 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/ftell_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      592 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/getarg_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1223 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/getenv_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      218 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_abs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      230 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_dim.c
+-rw-r--r--   0 runner    (1001) docker     (121)      294 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_dnnt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      442 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_indx.c
+-rw-r--r--   0 runner    (1001) docker     (121)      205 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_len.c
+-rw-r--r--   0 runner    (1001) docker     (121)      207 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_mod.c
+-rw-r--r--   0 runner    (1001) docker     (121)      281 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_nint.c
+-rw-r--r--   0 runner    (1001) docker     (121)      266 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/h_sign.c
+-rw-r--r--   0 runner    (1001) docker     (121)      346 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/hl_ge.c
+-rw-r--r--   0 runner    (1001) docker     (121)      345 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/hl_gt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      346 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/hl_le.c
+-rw-r--r--   0 runner    (1001) docker     (121)      345 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/hl_lt.c
+-rw-r--r--   0 runner    (1001) docker     (121)    18128 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i77vers.c
+-rw-r--r--   0 runner    (1001) docker     (121)      214 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_abs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      225 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_dim.c
+-rw-r--r--   0 runner    (1001) docker     (121)      291 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_dnnt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      430 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_indx.c
+-rw-r--r--   0 runner    (1001) docker     (121)      203 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_len.c
+-rw-r--r--   0 runner    (1001) docker     (121)      211 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_mod.c
+-rw-r--r--   0 runner    (1001) docker     (121)      278 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_nint.c
+-rw-r--r--   0 runner    (1001) docker     (121)      260 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/i_sign.c
+-rw-r--r--   0 runner    (1001) docker     (121)      196 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/iargc_.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2639 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/iio.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1125 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/ilnw.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2732 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/inquire.c
+-rw-r--r--   0 runner    (1001) docker     (121)      334 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/l_ge.c
+-rw-r--r--   0 runner    (1001) docker     (121)      333 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/l_gt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      334 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/l_le.c
+-rw-r--r--   0 runner    (1001) docker     (121)      333 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/l_lt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1097 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/lbitbits.c
+-rw-r--r--   0 runner    (1001) docker     (121)      258 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/lbitshft.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1594 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/libf2c.lbc
+-rw-r--r--   0 runner    (1001) docker     (121)     2051 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/libf2c.sy
+-rw-r--r--   0 runner    (1001) docker     (121)     1564 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/lio.h
+-rw-r--r--   0 runner    (1001) docker     (121)    14635 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/lread.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4616 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/lwrite.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2230 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/main.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2990 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.sy
+-rw-r--r--   0 runner    (1001) docker     (121)     7371 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.u
+-rw-r--r--   0 runner    (1001) docker     (121)     2954 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.vc
+-rw-r--r--   0 runner    (1001) docker     (121)     2936 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.wat
+-rw-r--r--   0 runner    (1001) docker     (121)       50 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/math.hvc
+-rw-r--r--   0 runner    (1001) docker     (121)     5174 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/mkfile.plan9
+-rw-r--r--   0 runner    (1001) docker     (121)     5701 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/open.c
+-rw-r--r--   0 runner    (1001) docker     (121)      424 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_ci.c
+-rw-r--r--   0 runner    (1001) docker     (121)      276 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_dd.c
+-rw-r--r--   0 runner    (1001) docker     (121)      448 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_di.c
+-rw-r--r--   0 runner    (1001) docker     (121)      489 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_hh.c
+-rw-r--r--   0 runner    (1001) docker     (121)      488 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_ii.c
+-rw-r--r--   0 runner    (1001) docker     (121)      436 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_ri.c
+-rw-r--r--   0 runner    (1001) docker     (121)      851 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_zi.c
+-rw-r--r--   0 runner    (1001) docker     (121)      549 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_zz.c
+-rw-r--r--   0 runner    (1001) docker     (121)      206 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_abs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_acos.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_asin.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_atan.c
+-rw-r--r--   0 runner    (1001) docker     (121)      253 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_atn2.c
+-rw-r--r--   0 runner    (1001) docker     (121)      247 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_cnjg.c
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_cos.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_cosh.c
+-rw-r--r--   0 runner    (1001) docker     (121)      214 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_dim.c
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_exp.c
+-rw-r--r--   0 runner    (1001) docker     (121)      197 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_imag.c
+-rw-r--r--   0 runner    (1001) docker     (121)      257 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_int.c
+-rw-r--r--   0 runner    (1001) docker     (121)      279 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_lg10.c
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_log.c
+-rw-r--r--   0 runner    (1001) docker     (121)      678 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_mod.c
+-rw-r--r--   0 runner    (1001) docker     (121)      269 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_nint.c
+-rw-r--r--   0 runner    (1001) docker     (121)      248 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_sign.c
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_sin.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_sinh.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_sqrt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      229 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_tan.c
+-rw-r--r--   0 runner    (1001) docker     (121)      233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_tanh.c
+-rw-r--r--   0 runner    (1001) docker     (121)      718 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/rawio.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8925 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/rdfmt.c
+-rw-r--r--   0 runner    (1001) docker     (121)      475 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/rewind.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1492 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/rsfe.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1785 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/rsli.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11512 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/rsne.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1458 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_cat.c
+-rw-r--r--   0 runner    (1001) docker     (121)      722 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_cmp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1024 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_copy.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1617 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_paus.c
+-rw-r--r--   0 runner    (1001) docker     (121)      759 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_rnge.c
+-rw-r--r--   0 runner    (1001) docker     (121)      762 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_stop.c
+-rw-r--r--   0 runner    (1001) docker     (121)      181 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/scomptry.bat
+-rw-r--r--   0 runner    (1001) docker     (121)      828 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/sfe.c
+-rw-r--r--   0 runner    (1001) docker     (121)      689 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/sig_die.c
+-rw-r--r--   0 runner    (1001) docker     (121)      842 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/signal1.h
+-rw-r--r--   0 runner    (1001) docker     (121)      842 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/signal1.h0
+-rw-r--r--   0 runner    (1001) docker     (121)      299 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/signal_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      330 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/signbit.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1865 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/sue.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1405 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/sysdep1.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1252 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/sysdep1.h0
+-rw-r--r--   0 runner    (1001) docker     (121)      652 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/system_.c
+-rw-r--r--   0 runner    (1001) docker     (121)      390 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/typesize.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/uio.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11215 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/uninit.c
+-rw-r--r--   0 runner    (1001) docker     (121)      972 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/util.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4747 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/wref.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7506 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/wrtfmt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1280 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/wsfe.c
+-rw-r--r--   0 runner    (1001) docker     (121)      697 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/wsle.c
+-rw-r--r--   0 runner    (1001) docker     (121)      479 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/wsne.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3945 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/xsum0.out
+-rw-r--r--   0 runner    (1001) docker     (121)     1174 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/xwsne.c
+-rw-r--r--   0 runner    (1001) docker     (121)      268 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_abs.c
+-rw-r--r--   0 runner    (1001) docker     (121)      363 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_cos.c
+-rw-r--r--   0 runner    (1001) docker     (121)      913 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_div.c
+-rw-r--r--   0 runner    (1001) docker     (121)      357 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_exp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2729 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_log.c
+-rw-r--r--   0 runner    (1001) docker     (121)      359 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_sin.c
+-rw-r--r--   0 runner    (1001) docker     (121)      581 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_sqrt.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.651142 igraph-0.9.9/vendor/source/igraph/vendor/glpk/
+-rw-r--r--   0 runner    (1001) docker     (121)     4157 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)    35147 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/COPYING
+-rw-r--r--   0 runner    (1001) docker     (121)     1234 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/README
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.655142 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/
+-rw-r--r--   0 runner    (1001) docker     (121)    26517 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/COPYING
+-rw-r--r--   0 runner    (1001) docker     (121)     2447 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/README
+-rw-r--r--   0 runner    (1001) docker     (121)     1726 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6691 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_1.c
+-rw-r--r--   0 runner    (1001) docker     (121)    78135 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5889 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_aat.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1985 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_control.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1403 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_defaults.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6145 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_dump.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4526 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_info.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3175 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_internal.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6478 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_order.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4549 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_post_tree.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6937 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_postorder.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4223 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_preprocess.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3405 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_valid.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.659143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/
+-rw-r--r--   0 runner    (1001) docker     (121)     4967 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/advbas.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5650 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/asnhall.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3680 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/asnlp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5185 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/asnokalg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2324 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/ckasn.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2681 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/ckcnf.c
+-rw-r--r--   0 runner    (1001) docker     (121)    44655 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/cplex.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6233 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/cpp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8919 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/cpxbas.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15559 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/graph.c
+-rw-r--r--   0 runner    (1001) docker     (121)      514 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/gridgen.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9886 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/intfeas1.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4298 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/maxffalg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3945 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/maxflp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4191 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/mcflp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7392 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/mcfokalg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8688 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/mcfrelax.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5218 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/minisat1.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9112 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/mpl.c
+-rw-r--r--   0 runner    (1001) docker     (121)    48189 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/mps.c
+-rw-r--r--   0 runner    (1001) docker     (121)      511 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/netgen.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5313 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/npp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7515 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/pript.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6065 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prmip.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11159 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob.h
+-rw-r--r--   0 runner    (1001) docker     (121)    53012 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob1.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13379 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5117 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob3.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4510 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob4.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5611 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob5.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10951 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prrngs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8097 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prsol.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5889 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdasn.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5671 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdcc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4830 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdcnf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6663 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdipt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5822 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdmaxf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6936 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdmcf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6075 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdmip.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13744 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdprob.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8168 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rdsol.c
+-rw-r--r--   0 runner    (1001) docker     (121)      485 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/rmfgen.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3538 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/strong.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4259 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/topsort.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4151 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wcliqex.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5320 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/weak.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3487 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrasn.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3253 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrcc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2988 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrcnf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4573 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wript.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3424 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrmaxf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4201 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrmcf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4444 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrmip.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5793 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrprob.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6080 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wrsol.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.663143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/
+-rw-r--r--   0 runner    (1001) docker     (121)    20762 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/btf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8657 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/btf.h
+-rw-r--r--   0 runner    (1001) docker     (121)    14455 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/btfint.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2389 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/btfint.h
+-rw-r--r--   0 runner    (1001) docker     (121)    22954 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/fhv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4272 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/fhv.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5331 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/fhvint.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2519 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/fhvint.h
+-rw-r--r--   0 runner    (1001) docker     (121)    12523 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/ifu.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3621 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/ifu.h
+-rw-r--r--   0 runner    (1001) docker     (121)    25028 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/luf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8650 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/luf.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5749 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/lufint.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2376 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/lufint.h
+-rw-r--r--   0 runner    (1001) docker     (121)    16741 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/scf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7921 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/scf.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8013 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/scfint.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3002 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/scfint.h
+-rw-r--r--   0 runner    (1001) docker     (121)    56757 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/sgf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8316 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/sgf.h
+-rw-r--r--   0 runner    (1001) docker     (121)    19312 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/sva.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6551 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/sva.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.663143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/
+-rw-r--r--   0 runner    (1001) docker     (121)    26517 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/COPYING
+-rw-r--r--   0 runner    (1001) docker     (121)     4284 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/README
+-rw-r--r--   0 runner    (1001) docker     (121)   126972 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/colamd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2099 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/colamd.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.667143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/
+-rw-r--r--   0 runner    (1001) docker     (121)    14962 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/bfd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3240 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/bfd.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2515 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/bfx.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2130 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/bfx.h
+-rw-r--r--   0 runner    (1001) docker     (121)      420 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/draft.h
+-rw-r--r--   0 runner    (1001) docker     (121)    27779 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi06.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15432 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi07.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12322 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi08.c
+-rw-r--r--   0 runner    (1001) docker     (121)    25761 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi09.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10331 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi10.c
+-rw-r--r--   0 runner    (1001) docker     (121)    79236 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi12.c
+-rw-r--r--   0 runner    (1001) docker     (121)    22847 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi13.c
+-rw-r--r--   0 runner    (1001) docker     (121)    55006 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios01.c
+-rw-r--r--   0 runner    (1001) docker     (121)    26843 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios02.c
+-rw-r--r--   0 runner    (1001) docker     (121)    52610 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios03.c
+-rw-r--r--   0 runner    (1001) docker     (121)    18811 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios07.c
+-rw-r--r--   0 runner    (1001) docker     (121)    26146 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios09.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16507 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios11.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5692 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios12.c
+-rw-r--r--   0 runner    (1001) docker     (121)    38870 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpipm.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1194 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpipm.h
+-rw-r--r--   0 runner    (1001) docker     (121)    32859 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpmat.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7310 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpmat.h
+-rw-r--r--   0 runner    (1001) docker     (121)    15956 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpscl.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16731 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpssx.h
+-rw-r--r--   0 runner    (1001) docker     (121)    27661 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpssx01.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17816 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpssx02.c
+-rw-r--r--   0 runner    (1001) docker     (121)    20591 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/ios.h
+-rw-r--r--   0 runner    (1001) docker     (121)    38744 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/lux.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8626 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/lux.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.667143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/
+-rw-r--r--   0 runner    (1001) docker     (121)     8471 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/alloc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4363 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/dlsup.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9026 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/env.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8530 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/env.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5573 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/error.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2388 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/stdc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1880 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/stdc.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7513 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/stdout.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12006 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/stream.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3856 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/time.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3657 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/tls.c
+-rw-r--r--   0 runner    (1001) docker     (121)    39881 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/glpk.h
+-rw-r--r--   0 runner    (1001) docker     (121)      226 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/glpk_tls_config.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.671143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/
+-rw-r--r--   0 runner    (1001) docker     (121)    13633 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/cfg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4842 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/cfg.h
+-rw-r--r--   0 runner    (1001) docker     (121)    24753 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/cfg1.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2478 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/cfg2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4228 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/clqcut.c
+-rw-r--r--   0 runner    (1001) docker     (121)    29902 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/covgen.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12331 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/fpump.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10141 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/gmicut.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4831 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/gmigen.c
+-rw-r--r--   0 runner    (1001) docker     (121)    51191 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/mirgen.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7391 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/spv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2699 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/spv.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.671143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/minisat/
+-rw-r--r--   0 runner    (1001) docker     (121)     1072 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/minisat/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (121)      903 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/minisat/README
+-rw-r--r--   0 runner    (1001) docker     (121)    38455 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/minisat/minisat.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7294 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/minisat/minisat.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.675143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/
+-rw-r--r--   0 runner    (1001) docker     (121)    13039 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/avl.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2433 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/avl.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9450 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/bignum.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1332 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/bignum.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4507 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/dimacs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2475 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/dimacs.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7054 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/dmp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1893 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/dmp.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7378 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/ffalg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1201 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/ffalg.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5112 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/fp2rat.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3521 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/fvs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2436 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/fvs.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2667 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/gcd.c
+-rw-r--r--   0 runner    (1001) docker     (121)    19528 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/hbm.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4485 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/hbm.h
+-rw-r--r--   0 runner    (1001) docker     (121)     4073 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/jd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1225 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/jd.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9340 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/keller.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1244 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/keller.h
+-rw-r--r--   0 runner    (1001) docker     (121)    15018 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/ks.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1560 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/ks.h
+-rw-r--r--   0 runner    (1001) docker     (121)    10528 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mc13d.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1197 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mc13d.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9962 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mc21a.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1231 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mc21a.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1921 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/misc.h
+-rw-r--r--   0 runner    (1001) docker     (121)    22840 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mt1.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7294 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mt1.f
+-rw-r--r--   0 runner    (1001) docker     (121)     1226 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mt1.h
+-rw-r--r--   0 runner    (1001) docker     (121)    32277 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mygmp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6956 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mygmp.h
+-rw-r--r--   0 runner    (1001) docker     (121)    12548 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/okalg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1223 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/okalg.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3209 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/qmd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2081 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/qmd.h
+-rw-r--r--   0 runner    (1001) docker     (121)      576 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/relax4.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4001 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/relax4.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6204 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rgr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1178 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rgr.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6246 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rng.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2134 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rng.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2104 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rng1.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2003 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/round2n.c
+-rw-r--r--   0 runner    (1001) docker     (121)    24795 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/spm.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4948 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/spm.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2650 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/str2int.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3325 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/str2num.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1690 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/strspx.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1743 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/strtrim.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12192 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/triang.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1268 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/triang.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7512 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/wclique.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1204 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/wclique.h
+-rw-r--r--   0 runner    (1001) docker     (121)    11169 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/wclique1.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1242 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/wclique1.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.679143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/
+-rw-r--r--   0 runner    (1001) docker     (121)    89902 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl.h
+-rw-r--r--   0 runner    (1001) docker     (121)   175615 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl1.c
+-rw-r--r--   0 runner    (1001) docker     (121)    45343 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl2.c
+-rw-r--r--   0 runner    (1001) docker     (121)   216340 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl3.c
+-rw-r--r--   0 runner    (1001) docker     (121)    47068 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl4.c
+-rw-r--r--   0 runner    (1001) docker     (121)    22111 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl5.c
+-rw-r--r--   0 runner    (1001) docker     (121)    31909 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl6.c
+-rw-r--r--   0 runner    (1001) docker     (121)    46674 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mplsql.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1965 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mplsql.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.679143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/
+-rw-r--r--   0 runner    (1001) docker     (121)    22187 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp.h
+-rw-r--r--   0 runner    (1001) docker     (121)    29243 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp1.c
+-rw-r--r--   0 runner    (1001) docker     (121)    44068 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    98671 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp3.c
+-rw-r--r--   0 runner    (1001) docker     (121)    50401 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp4.c
+-rw-r--r--   0 runner    (1001) docker     (121)    26501 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp5.c
+-rw-r--r--   0 runner    (1001) docker     (121)    51335 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp6.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.679143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/proxy/
+-rw-r--r--   0 runner    (1001) docker     (121)     2095 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/proxy/main.c
+-rw-r--r--   0 runner    (1001) docker     (121)    34755 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/proxy/proxy.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1200 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/proxy/proxy.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3112 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/proxy/proxy1.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.683143 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/
+-rw-r--r--   0 runner    (1001) docker     (121)     1265 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/simplex.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8684 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxat.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2837 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxat.h
+-rw-r--r--   0 runner    (1001) docker     (121)    12588 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxchuzc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2946 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxchuzc.h
+-rw-r--r--   0 runner    (1001) docker     (121)    22803 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxchuzr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2800 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxchuzr.h
+-rw-r--r--   0 runner    (1001) docker     (121)    28040 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxlp.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8780 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxlp.h
+-rw-r--r--   0 runner    (1001) docker     (121)     9658 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxnt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3379 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxnt.h
+-rw-r--r--   0 runner    (1001) docker     (121)    60409 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxprim.c
+-rw-r--r--   0 runner    (1001) docker     (121)    23363 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxprob.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2147 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxprob.h
+-rw-r--r--   0 runner    (1001) docker     (121)    22236 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spychuzc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2910 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spychuzc.h
+-rw-r--r--   0 runner    (1001) docker     (121)    16188 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spychuzr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3373 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spychuzr.h
+-rw-r--r--   0 runner    (1001) docker     (121)    68475 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spydual.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.711143 igraph-0.9.9/vendor/source/igraph/vendor/lapack/
+-rw-r--r--   0 runner    (1001) docker     (121)     2990 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     3742 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dasum.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4216 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/daxpy.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4010 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dcopy.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4119 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/ddot.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/debug.h
+-rw-r--r--   0 runner    (1001) docker     (121)     7921 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgebak.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11682 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgebal.c
+-rw-r--r--   0 runner    (1001) docker     (121)    21161 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgeev.c
+-rw-r--r--   0 runner    (1001) docker     (121)    28137 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgeevx.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7973 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgehd2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13146 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgehrd.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12207 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgemm.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9267 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgemv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6328 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgeqr2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6410 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dger.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6308 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgesv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7020 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetf2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7982 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetrf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7101 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetrs.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15147 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetv0.c
+-rw-r--r--   0 runner    (1001) docker     (121)    21536 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dhseqr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2626 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/disnan.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3710 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlabad.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8763 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlacn2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5049 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlacpy.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6204 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dladiv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5321 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlae2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    23898 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaebz.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6621 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaev2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15327 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaexc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8668 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlagtf.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11631 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlagts.c
+-rw-r--r--   0 runner    (1001) docker     (121)    22224 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlahqr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13186 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlahr2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3289 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaisnan.c
+-rw-r--r--   0 runner    (1001) docker     (121)    19239 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaln2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5914 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlamch.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7688 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaneg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6870 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlange.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6988 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlanhs.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6130 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlanst.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8372 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlansy.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8157 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlanv2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2960 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlapy2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    29031 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr0.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5898 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr1.c
+-rw-r--r--   0 runner    (1001) docker     (121)    25245 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    26032 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr3.c
+-rw-r--r--   0 runner    (1001) docker     (121)    28956 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr4.c
+-rw-r--r--   0 runner    (1001) docker     (121)    37558 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr5.c
+-rw-r--r--   0 runner    (1001) docker     (121)    20682 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqrb.c
+-rw-r--r--   0 runner    (1001) docker     (121)    23470 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqtr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15989 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlar1v.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7471 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarf.c
+-rw-r--r--   0 runner    (1001) docker     (121)    23429 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarfb.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5735 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarfg.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11761 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarft.c
+-rw-r--r--   0 runner    (1001) docker     (121)    19584 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarfx.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5306 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarnv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6679 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarra.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13437 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrb.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6837 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrc.c
+-rw-r--r--   0 runner    (1001) docker     (121)    29916 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrd.c
+-rw-r--r--   0 runner    (1001) docker     (121)    33542 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarre.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16393 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrf.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11668 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrj.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7509 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrk.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6606 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    41167 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6247 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlartg.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8417 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaruv.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10753 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlascl.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5885 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaset.c
+-rw-r--r--   0 runner    (1001) docker     (121)    18174 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11879 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq3.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11356 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq4.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11929 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq5.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7287 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq6.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15381 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7319 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasrt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4944 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlassq.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5888 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaswp.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16870 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasy2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    14552 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlatrd.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10860 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dmout.c
+-rw-r--r--   0 runner    (1001) docker     (121)    33888 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnaitr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    27927 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnapps.c
+-rw-r--r--   0 runner    (1001) docker     (121)    35771 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnaup2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    33787 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnaupd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5252 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnconv.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12869 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dneigh.c
+-rw-r--r--   0 runner    (1001) docker     (121)    48394 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dneupd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9750 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dngets.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3660 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnrm2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6441 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorg2r.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7789 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorghr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9735 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorgqr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8396 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorm2l.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8422 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorm2r.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10198 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormhr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11521 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormql.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11486 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormqr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11082 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormtr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7828 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dpotf2.c
+-rw-r--r--   0 runner    (1001) docker     (121)     8788 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dpotrf.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4017 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/drot.c
+-rw-r--r--   0 runner    (1001) docker     (121)    33333 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsaitr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    22100 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsapps.c
+-rw-r--r--   0 runner    (1001) docker     (121)    36189 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsaup2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    32658 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsaupd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3742 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dscal.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4477 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsconv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6655 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dseigt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6362 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsesrt.c
+-rw-r--r--   0 runner    (1001) docker     (121)    41086 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dseupd.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9074 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsgets.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9100 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsortc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     5616 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsortr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2161 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstatn.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1850 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstats.c
+-rw-r--r--   0 runner    (1001) docker     (121)    24381 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstebz.c
+-rw-r--r--   0 runner    (1001) docker     (121)    15006 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstein.c
+-rw-r--r--   0 runner    (1001) docker     (121)    28677 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstemr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    16716 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsteqr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11328 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsterf.c
+-rw-r--r--   0 runner    (1001) docker     (121)    17485 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstqrb.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4125 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dswap.c
+-rw-r--r--   0 runner    (1001) docker     (121)    26741 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyevr.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9730 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsymv.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9005 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyr2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13371 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyr2k.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11554 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyrk.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11785 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsytd2.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13607 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsytrd.c
+-rw-r--r--   0 runner    (1001) docker     (121)    36112 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrevc.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12461 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrexc.c
+-rw-r--r--   0 runner    (1001) docker     (121)    13242 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrmm.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10020 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrmv.c
+-rw-r--r--   0 runner    (1001) docker     (121)    19928 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsen.c
+-rw-r--r--   0 runner    (1001) docker     (121)    14048 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsm.c
+-rw-r--r--   0 runner    (1001) docker     (121)    21767 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsna.c
+-rw-r--r--   0 runner    (1001) docker     (121)    10003 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsv.c
+-rw-r--r--   0 runner    (1001) docker     (121)    39010 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsyl.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7752 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/dvout.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1313 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/fortran_intrinsics.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3428 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/idamax.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4941 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/ieeeck.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3672 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/iladlc.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3650 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/iladlr.c
+-rw-r--r--   0 runner    (1001) docker     (121)    21676 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/ilaenv.c
+-rw-r--r--   0 runner    (1001) docker     (121)    12365 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/iparmq.c
+-rw-r--r--   0 runner    (1001) docker     (121)     7666 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/ivout.c
+-rw-r--r--   0 runner    (1001) docker     (121)      899 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/len_trim.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3677 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/lsame.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/second.c
+-rw-r--r--   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/stat.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3687 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/lapack/xerbla.c
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.711143 igraph-0.9.9/vendor/source/igraph/vendor/mini-gmp/
+-rw-r--r--   0 runner    (1001) docker     (121)      828 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/mini-gmp/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)    89746 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/mini-gmp/mini-gmp.c
+-rw-r--r--   0 runner    (1001) docker     (121)    11548 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/mini-gmp/mini-gmp.h
+drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-01-10 13:49:49.715143 igraph-0.9.9/vendor/source/igraph/vendor/plfit/
+-rw-r--r--   0 runner    (1001) docker     (121)      962 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (121)     3431 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/arithmetic_ansi.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8798 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/arithmetic_sse_double.h
+-rw-r--r--   0 runner    (1001) docker     (121)     8853 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/arithmetic_sse_float.h
+-rw-r--r--   0 runner    (1001) docker     (121)     3474 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/gss.c
+-rw-r--r--   0 runner    (1001) docker     (121)     6060 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/gss.h
+-rw-r--r--   0 runner    (1001) docker     (121)    21614 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/hzeta.c
+-rw-r--r--   0 runner    (1001) docker     (121)     3007 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/hzeta.h
+-rw-r--r--   0 runner    (1001) docker     (121)     1905 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/kolmogorov.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1250 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/kolmogorov.h
+-rw-r--r--   0 runner    (1001) docker     (121)    41204 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/lbfgs.c
+-rw-r--r--   0 runner    (1001) docker     (121)    31934 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/lbfgs.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2651 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/mt.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1776 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/options.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1099 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/platform.c
+-rw-r--r--   0 runner    (1001) docker     (121)     1588 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/platform.h
+-rw-r--r--   0 runner    (1001) docker     (121)    43281 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit.c
+-rw-r--r--   0 runner    (1001) docker     (121)     4851 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2067 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_error.c
+-rw-r--r--   0 runner    (1001) docker     (121)     2524 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_error.h
+-rw-r--r--   0 runner    (1001) docker     (121)     2874 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_mt.h
+-rw-r--r--   0 runner    (1001) docker     (121)     6255 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_sampling.h
+-rw-r--r--   0 runner    (1001) docker     (121)      967 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_version.h
+-rw-r--r--   0 runner    (1001) docker     (121)     5676 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/rbinom.c
+-rw-r--r--   0 runner    (1001) docker     (121)     9550 2022-01-10 13:49:46.000000 igraph-0.9.9/vendor/source/igraph/vendor/plfit/sampling.c
```

### Comparing `igraph-0.9.8/LICENSE` & `igraph-0.9.9/LICENSE`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/PKG-INFO` & `igraph-0.9.9/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: igraph
-Version: 0.9.8
+Version: 0.9.9
 Summary: High performance graph data structures and algorithms
 Home-page: https://igraph.org/python
 Author: Tamas Nepusz
 Author-email: ntamas@gmail.com
 License: GNU General Public License (GPL)
 Project-URL: Bug Tracker, https://github.com/igraph/python-igraph/issues
 Project-URL: Changelog, https://github.com/igraph/python-igraph/blob/master/CHANGELOG.md
```

### Comparing `igraph-0.9.8/README.md` & `igraph-0.9.9/README.md`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/igraph.egg-info/PKG-INFO` & `igraph-0.9.9/src/igraph.egg-info/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: igraph
-Version: 0.9.8
+Version: 0.9.9
 Summary: High performance graph data structures and algorithms
 Home-page: https://igraph.org/python
 Author: Tamas Nepusz
 Author-email: ntamas@gmail.com
 License: GNU General Public License (GPL)
 Project-URL: Bug Tracker, https://github.com/igraph/python-igraph/issues
 Project-URL: Changelog, https://github.com/igraph/python-igraph/blob/master/CHANGELOG.md
```

### Comparing `igraph-0.9.8/igraph.egg-info/SOURCES.txt` & `igraph-0.9.9/src/igraph.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,11 @@
 LICENSE
 MANIFEST.in
 README.md
 setup.py
-igraph.egg-info/PKG-INFO
-igraph.egg-info/SOURCES.txt
-igraph.egg-info/dependency_links.txt
-igraph.egg-info/requires.txt
-igraph.egg-info/top_level.txt
 scripts/igraph
 scripts/mkdoc.sh
 src/_igraph/arpackobject.c
 src/_igraph/arpackobject.h
 src/_igraph/attributes.c
 src/_igraph/attributes.h
 src/_igraph/bfsiter.c
@@ -58,14 +53,19 @@
 src/igraph/matching.py
 src/igraph/operators.py
 src/igraph/sparse_matrix.py
 src/igraph/statistics.py
 src/igraph/summary.py
 src/igraph/utils.py
 src/igraph/version.py
+src/igraph.egg-info/PKG-INFO
+src/igraph.egg-info/SOURCES.txt
+src/igraph.egg-info/dependency_links.txt
+src/igraph.egg-info/requires.txt
+src/igraph.egg-info/top_level.txt
 src/igraph/app/__init__.py
 src/igraph/app/shell.py
 src/igraph/drawing/__init__.py
 src/igraph/drawing/baseclasses.py
 src/igraph/drawing/colors.py
 src/igraph/drawing/coord.py
 src/igraph/drawing/edge.py
@@ -122,26 +122,30 @@
 vendor/source/igraph/COPYING
 vendor/source/igraph/ChangeLog
 vendor/source/igraph/IGRAPH_VERSION
 vendor/source/igraph/INSTALL
 vendor/source/igraph/NEWS
 vendor/source/igraph/ONEWS
 vendor/source/igraph/README.md
+vendor/source/igraph/SUPPORT.md
 vendor/source/igraph/appveyor.yml
 vendor/source/igraph/azure-pipelines.yml
 vendor/source/igraph/codecov.yml
 vendor/source/igraph/igraph.pc.in
 vendor/source/igraph/.azure/build-win.yml
 vendor/source/igraph/.azure/build.yml
 vendor/source/igraph/.github/stale.yml
 vendor/source/igraph/.github/ISSUE_TEMPLATE/bug_report.md
 vendor/source/igraph/.github/ISSUE_TEMPLATE/config.yml
 vendor/source/igraph/.github/ISSUE_TEMPLATE/feature_request.md
+vendor/source/igraph/.github/codeql/codeql-config.yml
 vendor/source/igraph/.github/workflows/build-cmake.yml
 vendor/source/igraph/.github/workflows/codecov.yml
+vendor/source/igraph/.github/workflows/codeql-analysis.yml
+vendor/source/igraph/.github/workflows/stimulus.yml
 vendor/source/igraph/doc/CMakeLists.txt
 vendor/source/igraph/doc/adjlist.xxml
 vendor/source/igraph/doc/arpack.xxml
 vendor/source/igraph/doc/attributes.xxml
 vendor/source/igraph/doc/basicigraph.xxml
 vendor/source/igraph/doc/bibdatabase.xml
 vendor/source/igraph/doc/bipartite.xxml
@@ -214,14 +218,15 @@
 vendor/source/igraph/etc/cmake/CTestCustom.cmake.in
 vendor/source/igraph/etc/cmake/CheckTLSSupport.cmake
 vendor/source/igraph/etc/cmake/CodeCoverage.cmake
 vendor/source/igraph/etc/cmake/FindARPACK.cmake
 vendor/source/igraph/etc/cmake/FindCXSparse.cmake
 vendor/source/igraph/etc/cmake/FindGLPK.cmake
 vendor/source/igraph/etc/cmake/FindGMP.cmake
+vendor/source/igraph/etc/cmake/FindPLFIT.cmake
 vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake
 vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake.in
 vendor/source/igraph/etc/cmake/JoinPaths.cmake
 vendor/source/igraph/etc/cmake/PadString.cmake
 vendor/source/igraph/etc/cmake/PreventInSourceBuilds.cmake
 vendor/source/igraph/etc/cmake/UseCCacheWhenInstalled.cmake
 vendor/source/igraph/etc/cmake/benchmark_helpers.cmake
@@ -516,16 +521,20 @@
 vendor/source/igraph/examples/simple/test.gxl
 vendor/source/igraph/examples/simple/walktrap.c
 vendor/source/igraph/examples/simple/walktrap.out
 vendor/source/igraph/examples/tutorial/tutorial1.c
 vendor/source/igraph/examples/tutorial/tutorial2.c
 vendor/source/igraph/examples/tutorial/tutorial3.c
 vendor/source/igraph/fuzzing/README.md
+vendor/source/igraph/fuzzing/bliss_fuzzer.cpp
 vendor/source/igraph/fuzzing/build.sh
-vendor/source/igraph/fuzzing/read_gml_fuzzer.c
+vendor/source/igraph/fuzzing/edge_connectivity_fuzzer.cpp
+vendor/source/igraph/fuzzing/read_gml_fuzzer.cpp
+vendor/source/igraph/fuzzing/vertex_connectivity_fuzzer.cpp
+vendor/source/igraph/fuzzing/vertex_separators_fuzzer.cpp
 vendor/source/igraph/include/igraph.h
 vendor/source/igraph/include/igraph_adjlist.h
 vendor/source/igraph/include/igraph_arpack.h
 vendor/source/igraph/include/igraph_array.h
 vendor/source/igraph/include/igraph_array_pmt.h
 vendor/source/igraph/include/igraph_attributes.h
 vendor/source/igraph/include/igraph_bipartite.h
@@ -597,14 +606,17 @@
 vendor/source/igraph/include/igraph_types.h
 vendor/source/igraph/include/igraph_vector.h
 vendor/source/igraph/include/igraph_vector_pmt.h
 vendor/source/igraph/include/igraph_vector_ptr.h
 vendor/source/igraph/include/igraph_vector_type.h
 vendor/source/igraph/include/igraph_version.h.in
 vendor/source/igraph/include/igraph_visitor.h
+vendor/source/igraph/interfaces/CMakeLists.txt
+vendor/source/igraph/interfaces/functions.yaml
+vendor/source/igraph/interfaces/types.yaml
 vendor/source/igraph/msvc/include/unistd.h
 vendor/source/igraph/src/CMakeLists.txt
 vendor/source/igraph/src/config.h.in
 vendor/source/igraph/src/f2c.h
 vendor/source/igraph/src/version.c
 vendor/source/igraph/src/centrality/betweenness.c
 vendor/source/igraph/src/centrality/centrality_other.c
@@ -999,14 +1011,15 @@
 vendor/source/igraph/src/scg/scg_exact_scg.c
 vendor/source/igraph/src/scg/scg_headers.h
 vendor/source/igraph/src/scg/scg_kmeans.c
 vendor/source/igraph/src/scg/scg_optimal_method.c
 vendor/source/igraph/src/scg/scg_utils.c
 vendor/source/igraph/tests/CMakeLists.txt
 vendor/source/igraph/tests/benchmarks/bench.h
+vendor/source/igraph/tests/benchmarks/igraph_average_path_length_unweighted.c
 vendor/source/igraph/tests/benchmarks/igraph_betweenness.c
 vendor/source/igraph/tests/benchmarks/igraph_betweenness_weighted.c
 vendor/source/igraph/tests/benchmarks/igraph_cliques.c
 vendor/source/igraph/tests/benchmarks/igraph_closeness_weighted.c
 vendor/source/igraph/tests/benchmarks/igraph_coloring.c
 vendor/source/igraph/tests/benchmarks/igraph_decompose.c
 vendor/source/igraph/tests/benchmarks/igraph_maximal_cliques.c
@@ -1028,19 +1041,24 @@
 vendor/source/igraph/tests/regression/cattr_bool_bug2.graphml
 vendor/source/igraph/tests/regression/igraph_layout_kamada_kawai_3d_bug_1462.c
 vendor/source/igraph/tests/regression/igraph_layout_kamada_kawai_3d_bug_1462.out
 vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.c
 vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.in
 vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.out
 vendor/source/igraph/tests/regression/igraph_read_graph_gml_invalid_inputs.c
+vendor/source/igraph/tests/regression/igraph_read_graph_graphml_invalid_inputs.c
 vendor/source/igraph/tests/regression/invalid1.gml
+vendor/source/igraph/tests/regression/invalid1.graphml
 vendor/source/igraph/tests/regression/invalid2.gml
+vendor/source/igraph/tests/regression/invalid2.graphml
 vendor/source/igraph/tests/regression/invalid3.gml
+vendor/source/igraph/tests/regression/invalid3.graphml
 vendor/source/igraph/tests/regression/invalid4.gml
 vendor/source/igraph/tests/regression/invalid5.gml
+vendor/source/igraph/tests/regression/invalid6.gml
 vendor/source/igraph/tests/unit/2wheap.c
 vendor/source/igraph/tests/unit/VF2-compat.c
 vendor/source/igraph/tests/unit/adjlist.c
 vendor/source/igraph/tests/unit/adjlist.out
 vendor/source/igraph/tests/unit/all_shortest_paths.c
 vendor/source/igraph/tests/unit/all_shortest_paths.out
 vendor/source/igraph/tests/unit/bfs.c
@@ -1050,14 +1068,17 @@
 vendor/source/igraph/tests/unit/bipartite.net
 vendor/source/igraph/tests/unit/bliss_automorphisms.c
 vendor/source/igraph/tests/unit/bliss_automorphisms.out
 vendor/source/igraph/tests/unit/cattributes5.c
 vendor/source/igraph/tests/unit/cattributes5.out
 vendor/source/igraph/tests/unit/community_label_propagation.c
 vendor/source/igraph/tests/unit/community_label_propagation.out
+vendor/source/igraph/tests/unit/community_label_propagation2.c
+vendor/source/igraph/tests/unit/community_label_propagation2.out
+vendor/source/igraph/tests/unit/community_label_propagation3.c
 vendor/source/igraph/tests/unit/community_leiden.c
 vendor/source/igraph/tests/unit/community_leiden.out
 vendor/source/igraph/tests/unit/cutheap.c
 vendor/source/igraph/tests/unit/cutheap.out
 vendor/source/igraph/tests/unit/d_indheap.c
 vendor/source/igraph/tests/unit/d_indheap.out
 vendor/source/igraph/tests/unit/dgemv.c
@@ -1085,14 +1106,15 @@
 vendor/source/igraph/tests/unit/igraph_adhesion.c
 vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.c
 vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.out
 vendor/source/igraph/tests/unit/igraph_adjacent_triangles.c
 vendor/source/igraph/tests/unit/igraph_adjacent_triangles.out
 vendor/source/igraph/tests/unit/igraph_all_st_cuts.c
 vendor/source/igraph/tests/unit/igraph_all_st_cuts.out
+vendor/source/igraph/tests/unit/igraph_almost_equals.c
 vendor/source/igraph/tests/unit/igraph_are_connected.c
 vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.c
 vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.out
 vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.c
 vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.out
 vendor/source/igraph/tests/unit/igraph_array.c
 vendor/source/igraph/tests/unit/igraph_array.out
@@ -1200,14 +1222,15 @@
 vendor/source/igraph/tests/unit/igraph_intersection2.c
 vendor/source/igraph/tests/unit/igraph_intersection2.out
 vendor/source/igraph/tests/unit/igraph_is_bigraphical.c
 vendor/source/igraph/tests/unit/igraph_is_bigraphical.out
 vendor/source/igraph/tests/unit/igraph_is_bipartite.c
 vendor/source/igraph/tests/unit/igraph_is_chordal.c
 vendor/source/igraph/tests/unit/igraph_is_chordal.out
+vendor/source/igraph/tests/unit/igraph_is_connected.c
 vendor/source/igraph/tests/unit/igraph_is_eulerian.c
 vendor/source/igraph/tests/unit/igraph_is_eulerian.out
 vendor/source/igraph/tests/unit/igraph_is_graphical.c
 vendor/source/igraph/tests/unit/igraph_is_graphical.out
 vendor/source/igraph/tests/unit/igraph_is_mutual.c
 vendor/source/igraph/tests/unit/igraph_is_mutual.out
 vendor/source/igraph/tests/unit/igraph_is_same_graph.c
@@ -1271,14 +1294,16 @@
 vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.c
 vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.out
 vendor/source/igraph/tests/unit/igraph_modularity.c
 vendor/source/igraph/tests/unit/igraph_modularity.out
 vendor/source/igraph/tests/unit/igraph_modularity_matrix.c
 vendor/source/igraph/tests/unit/igraph_modularity_matrix.out
 vendor/source/igraph/tests/unit/igraph_moran_process.c
+vendor/source/igraph/tests/unit/igraph_motifs_randesu.c
+vendor/source/igraph/tests/unit/igraph_motifs_randesu.out
 vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.c
 vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.out
 vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.c
 vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.out
 vendor/source/igraph/tests/unit/igraph_neighborhood.c
 vendor/source/igraph/tests/unit/igraph_neighborhood.out
 vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.c
@@ -1377,14 +1402,15 @@
 vendor/source/igraph/tests/unit/igraph_write_graph_leda.c
 vendor/source/igraph/tests/unit/igraph_write_graph_leda.out
 vendor/source/igraph/tests/unit/inclist.c
 vendor/source/igraph/tests/unit/inclist.out
 vendor/source/igraph/tests/unit/input.dl
 vendor/source/igraph/tests/unit/isoclasses.c
 vendor/source/igraph/tests/unit/isoclasses.out
+vendor/source/igraph/tests/unit/isoclasses2.c
 vendor/source/igraph/tests/unit/isomorphism_test.c
 vendor/source/igraph/tests/unit/isomorphism_test.out
 vendor/source/igraph/tests/unit/levc-stress.c
 vendor/source/igraph/tests/unit/lineendings.c
 vendor/source/igraph/tests/unit/lineendings.out
 vendor/source/igraph/tests/unit/marked_queue.c
 vendor/source/igraph/tests/unit/matrix.c
@@ -1461,16 +1487,16 @@
 vendor/source/igraph/tests/unit/vertex_selectors.c
 vendor/source/igraph/tests/unit/vertex_selectors.out
 vendor/source/igraph/tests/unit/watts_strogatz_game.c
 vendor/source/igraph/tests/unit/wikti_en_V_syn.elist
 vendor/source/igraph/tests/unit/zero_allocs.c
 vendor/source/igraph/tools/arpack-sed.txt
 vendor/source/igraph/tools/bump_version.sh
-vendor/source/igraph/tools/getglpk.sh
 vendor/source/igraph/tools/removeexamples.py
+vendor/source/igraph/tools/isoclasses/isoclasses.m
 vendor/source/igraph/tools/lapack/CompletePolish
 vendor/source/igraph/tools/lapack/Makefile
 vendor/source/igraph/tools/lapack/comment.l
 vendor/source/igraph/tools/lapack/delete.sed
 vendor/source/igraph/tools/lapack/getlapack.sh
 vendor/source/igraph/tools/lapack/lapack.patch
 vendor/source/igraph/tools/lapack/lenscrub.l
@@ -1716,140 +1742,16 @@
 vendor/source/igraph/vendor/f2c/z_exp.c
 vendor/source/igraph/vendor/f2c/z_log.c
 vendor/source/igraph/vendor/f2c/z_sin.c
 vendor/source/igraph/vendor/f2c/z_sqrt.c
 vendor/source/igraph/vendor/glpk/CMakeLists.txt
 vendor/source/igraph/vendor/glpk/COPYING
 vendor/source/igraph/vendor/glpk/README
-vendor/source/igraph/vendor/glpk/glpapi.h
-vendor/source/igraph/vendor/glpk/glpapi01.c
-vendor/source/igraph/vendor/glpk/glpapi02.c
-vendor/source/igraph/vendor/glpk/glpapi03.c
-vendor/source/igraph/vendor/glpk/glpapi04.c
-vendor/source/igraph/vendor/glpk/glpapi05.c
-vendor/source/igraph/vendor/glpk/glpapi06.c
-vendor/source/igraph/vendor/glpk/glpapi07.c
-vendor/source/igraph/vendor/glpk/glpapi08.c
-vendor/source/igraph/vendor/glpk/glpapi09.c
-vendor/source/igraph/vendor/glpk/glpapi10.c
-vendor/source/igraph/vendor/glpk/glpapi11.c
-vendor/source/igraph/vendor/glpk/glpapi12.c
-vendor/source/igraph/vendor/glpk/glpapi13.c
-vendor/source/igraph/vendor/glpk/glpapi14.c
-vendor/source/igraph/vendor/glpk/glpapi15.c
-vendor/source/igraph/vendor/glpk/glpapi16.c
-vendor/source/igraph/vendor/glpk/glpapi17.c
-vendor/source/igraph/vendor/glpk/glpapi18.c
-vendor/source/igraph/vendor/glpk/glpapi19.c
-vendor/source/igraph/vendor/glpk/glpavl.c
-vendor/source/igraph/vendor/glpk/glpavl.h
-vendor/source/igraph/vendor/glpk/glpbfd.c
-vendor/source/igraph/vendor/glpk/glpbfd.h
-vendor/source/igraph/vendor/glpk/glpbfx.c
-vendor/source/igraph/vendor/glpk/glpbfx.h
-vendor/source/igraph/vendor/glpk/glpcpx.c
-vendor/source/igraph/vendor/glpk/glpdmp.c
-vendor/source/igraph/vendor/glpk/glpdmp.h
-vendor/source/igraph/vendor/glpk/glpdmx.c
-vendor/source/igraph/vendor/glpk/glpenv.h
-vendor/source/igraph/vendor/glpk/glpenv01.c
-vendor/source/igraph/vendor/glpk/glpenv02.c
-vendor/source/igraph/vendor/glpk/glpenv03.c
-vendor/source/igraph/vendor/glpk/glpenv04.c
-vendor/source/igraph/vendor/glpk/glpenv05.c
-vendor/source/igraph/vendor/glpk/glpenv06.c
-vendor/source/igraph/vendor/glpk/glpenv07.c
-vendor/source/igraph/vendor/glpk/glpenv08.c
-vendor/source/igraph/vendor/glpk/glpfhv.c
-vendor/source/igraph/vendor/glpk/glpfhv.h
-vendor/source/igraph/vendor/glpk/glpgmp.c
-vendor/source/igraph/vendor/glpk/glpgmp.h
-vendor/source/igraph/vendor/glpk/glphbm.c
-vendor/source/igraph/vendor/glpk/glphbm.h
-vendor/source/igraph/vendor/glpk/glpini01.c
-vendor/source/igraph/vendor/glpk/glpini02.c
-vendor/source/igraph/vendor/glpk/glpios.h
-vendor/source/igraph/vendor/glpk/glpios01.c
-vendor/source/igraph/vendor/glpk/glpios02.c
-vendor/source/igraph/vendor/glpk/glpios03.c
-vendor/source/igraph/vendor/glpk/glpios04.c
-vendor/source/igraph/vendor/glpk/glpios05.c
-vendor/source/igraph/vendor/glpk/glpios06.c
-vendor/source/igraph/vendor/glpk/glpios07.c
-vendor/source/igraph/vendor/glpk/glpios08.c
-vendor/source/igraph/vendor/glpk/glpios09.c
-vendor/source/igraph/vendor/glpk/glpios10.c
-vendor/source/igraph/vendor/glpk/glpios11.c
-vendor/source/igraph/vendor/glpk/glpios12.c
-vendor/source/igraph/vendor/glpk/glpipm.c
-vendor/source/igraph/vendor/glpk/glpipm.h
 vendor/source/igraph/vendor/glpk/glpk.h
-vendor/source/igraph/vendor/glpk/glplib.h
-vendor/source/igraph/vendor/glpk/glplib01.c
-vendor/source/igraph/vendor/glpk/glplib02.c
-vendor/source/igraph/vendor/glpk/glplib03.c
-vendor/source/igraph/vendor/glpk/glplpf.c
-vendor/source/igraph/vendor/glpk/glplpf.h
-vendor/source/igraph/vendor/glpk/glplpx01.c
-vendor/source/igraph/vendor/glpk/glplpx02.c
-vendor/source/igraph/vendor/glpk/glplpx03.c
-vendor/source/igraph/vendor/glpk/glpluf.c
-vendor/source/igraph/vendor/glpk/glpluf.h
-vendor/source/igraph/vendor/glpk/glplux.c
-vendor/source/igraph/vendor/glpk/glplux.h
-vendor/source/igraph/vendor/glpk/glpmat.c
-vendor/source/igraph/vendor/glpk/glpmat.h
-vendor/source/igraph/vendor/glpk/glpmpl.h
-vendor/source/igraph/vendor/glpk/glpmpl01.c
-vendor/source/igraph/vendor/glpk/glpmpl02.c
-vendor/source/igraph/vendor/glpk/glpmpl03.c
-vendor/source/igraph/vendor/glpk/glpmpl04.c
-vendor/source/igraph/vendor/glpk/glpmpl05.c
-vendor/source/igraph/vendor/glpk/glpmpl06.c
-vendor/source/igraph/vendor/glpk/glpmps.c
-vendor/source/igraph/vendor/glpk/glpnet.h
-vendor/source/igraph/vendor/glpk/glpnet01.c
-vendor/source/igraph/vendor/glpk/glpnet02.c
-vendor/source/igraph/vendor/glpk/glpnet03.c
-vendor/source/igraph/vendor/glpk/glpnet04.c
-vendor/source/igraph/vendor/glpk/glpnet05.c
-vendor/source/igraph/vendor/glpk/glpnet06.c
-vendor/source/igraph/vendor/glpk/glpnet07.c
-vendor/source/igraph/vendor/glpk/glpnet08.c
-vendor/source/igraph/vendor/glpk/glpnet09.c
-vendor/source/igraph/vendor/glpk/glpnpp.h
-vendor/source/igraph/vendor/glpk/glpnpp01.c
-vendor/source/igraph/vendor/glpk/glpnpp02.c
-vendor/source/igraph/vendor/glpk/glpnpp03.c
-vendor/source/igraph/vendor/glpk/glpnpp04.c
-vendor/source/igraph/vendor/glpk/glpnpp05.c
-vendor/source/igraph/vendor/glpk/glpqmd.c
-vendor/source/igraph/vendor/glpk/glpqmd.h
-vendor/source/igraph/vendor/glpk/glprgr.c
-vendor/source/igraph/vendor/glpk/glprgr.h
-vendor/source/igraph/vendor/glpk/glprng.h
-vendor/source/igraph/vendor/glpk/glprng01.c
-vendor/source/igraph/vendor/glpk/glprng02.c
-vendor/source/igraph/vendor/glpk/glpscf.c
-vendor/source/igraph/vendor/glpk/glpscf.h
-vendor/source/igraph/vendor/glpk/glpscl.c
-vendor/source/igraph/vendor/glpk/glpsdf.c
-vendor/source/igraph/vendor/glpk/glpspm.c
-vendor/source/igraph/vendor/glpk/glpspm.h
-vendor/source/igraph/vendor/glpk/glpspx.h
-vendor/source/igraph/vendor/glpk/glpspx01.c
-vendor/source/igraph/vendor/glpk/glpspx02.c
-vendor/source/igraph/vendor/glpk/glpsql.c
-vendor/source/igraph/vendor/glpk/glpsql.h
-vendor/source/igraph/vendor/glpk/glpssx.h
-vendor/source/igraph/vendor/glpk/glpssx01.c
-vendor/source/igraph/vendor/glpk/glpssx02.c
-vendor/source/igraph/vendor/glpk/glpstd.h
-vendor/source/igraph/vendor/glpk/glptsp.c
-vendor/source/igraph/vendor/glpk/glptsp.h
+vendor/source/igraph/vendor/glpk/glpk_tls_config.h
 vendor/source/igraph/vendor/glpk/amd/COPYING
 vendor/source/igraph/vendor/glpk/amd/README
 vendor/source/igraph/vendor/glpk/amd/amd.h
 vendor/source/igraph/vendor/glpk/amd/amd_1.c
 vendor/source/igraph/vendor/glpk/amd/amd_2.c
 vendor/source/igraph/vendor/glpk/amd/amd_aat.c
 vendor/source/igraph/vendor/glpk/amd/amd_control.c
@@ -1858,18 +1760,247 @@
 vendor/source/igraph/vendor/glpk/amd/amd_info.c
 vendor/source/igraph/vendor/glpk/amd/amd_internal.h
 vendor/source/igraph/vendor/glpk/amd/amd_order.c
 vendor/source/igraph/vendor/glpk/amd/amd_post_tree.c
 vendor/source/igraph/vendor/glpk/amd/amd_postorder.c
 vendor/source/igraph/vendor/glpk/amd/amd_preprocess.c
 vendor/source/igraph/vendor/glpk/amd/amd_valid.c
+vendor/source/igraph/vendor/glpk/api/advbas.c
+vendor/source/igraph/vendor/glpk/api/asnhall.c
+vendor/source/igraph/vendor/glpk/api/asnlp.c
+vendor/source/igraph/vendor/glpk/api/asnokalg.c
+vendor/source/igraph/vendor/glpk/api/ckasn.c
+vendor/source/igraph/vendor/glpk/api/ckcnf.c
+vendor/source/igraph/vendor/glpk/api/cplex.c
+vendor/source/igraph/vendor/glpk/api/cpp.c
+vendor/source/igraph/vendor/glpk/api/cpxbas.c
+vendor/source/igraph/vendor/glpk/api/graph.c
+vendor/source/igraph/vendor/glpk/api/gridgen.c
+vendor/source/igraph/vendor/glpk/api/intfeas1.c
+vendor/source/igraph/vendor/glpk/api/maxffalg.c
+vendor/source/igraph/vendor/glpk/api/maxflp.c
+vendor/source/igraph/vendor/glpk/api/mcflp.c
+vendor/source/igraph/vendor/glpk/api/mcfokalg.c
+vendor/source/igraph/vendor/glpk/api/mcfrelax.c
+vendor/source/igraph/vendor/glpk/api/minisat1.c
+vendor/source/igraph/vendor/glpk/api/mpl.c
+vendor/source/igraph/vendor/glpk/api/mps.c
+vendor/source/igraph/vendor/glpk/api/netgen.c
+vendor/source/igraph/vendor/glpk/api/npp.c
+vendor/source/igraph/vendor/glpk/api/pript.c
+vendor/source/igraph/vendor/glpk/api/prmip.c
+vendor/source/igraph/vendor/glpk/api/prob.h
+vendor/source/igraph/vendor/glpk/api/prob1.c
+vendor/source/igraph/vendor/glpk/api/prob2.c
+vendor/source/igraph/vendor/glpk/api/prob3.c
+vendor/source/igraph/vendor/glpk/api/prob4.c
+vendor/source/igraph/vendor/glpk/api/prob5.c
+vendor/source/igraph/vendor/glpk/api/prrngs.c
+vendor/source/igraph/vendor/glpk/api/prsol.c
+vendor/source/igraph/vendor/glpk/api/rdasn.c
+vendor/source/igraph/vendor/glpk/api/rdcc.c
+vendor/source/igraph/vendor/glpk/api/rdcnf.c
+vendor/source/igraph/vendor/glpk/api/rdipt.c
+vendor/source/igraph/vendor/glpk/api/rdmaxf.c
+vendor/source/igraph/vendor/glpk/api/rdmcf.c
+vendor/source/igraph/vendor/glpk/api/rdmip.c
+vendor/source/igraph/vendor/glpk/api/rdprob.c
+vendor/source/igraph/vendor/glpk/api/rdsol.c
+vendor/source/igraph/vendor/glpk/api/rmfgen.c
+vendor/source/igraph/vendor/glpk/api/strong.c
+vendor/source/igraph/vendor/glpk/api/topsort.c
+vendor/source/igraph/vendor/glpk/api/wcliqex.c
+vendor/source/igraph/vendor/glpk/api/weak.c
+vendor/source/igraph/vendor/glpk/api/wrasn.c
+vendor/source/igraph/vendor/glpk/api/wrcc.c
+vendor/source/igraph/vendor/glpk/api/wrcnf.c
+vendor/source/igraph/vendor/glpk/api/wript.c
+vendor/source/igraph/vendor/glpk/api/wrmaxf.c
+vendor/source/igraph/vendor/glpk/api/wrmcf.c
+vendor/source/igraph/vendor/glpk/api/wrmip.c
+vendor/source/igraph/vendor/glpk/api/wrprob.c
+vendor/source/igraph/vendor/glpk/api/wrsol.c
+vendor/source/igraph/vendor/glpk/bflib/btf.c
+vendor/source/igraph/vendor/glpk/bflib/btf.h
+vendor/source/igraph/vendor/glpk/bflib/btfint.c
+vendor/source/igraph/vendor/glpk/bflib/btfint.h
+vendor/source/igraph/vendor/glpk/bflib/fhv.c
+vendor/source/igraph/vendor/glpk/bflib/fhv.h
+vendor/source/igraph/vendor/glpk/bflib/fhvint.c
+vendor/source/igraph/vendor/glpk/bflib/fhvint.h
+vendor/source/igraph/vendor/glpk/bflib/ifu.c
+vendor/source/igraph/vendor/glpk/bflib/ifu.h
+vendor/source/igraph/vendor/glpk/bflib/luf.c
+vendor/source/igraph/vendor/glpk/bflib/luf.h
+vendor/source/igraph/vendor/glpk/bflib/lufint.c
+vendor/source/igraph/vendor/glpk/bflib/lufint.h
+vendor/source/igraph/vendor/glpk/bflib/scf.c
+vendor/source/igraph/vendor/glpk/bflib/scf.h
+vendor/source/igraph/vendor/glpk/bflib/scfint.c
+vendor/source/igraph/vendor/glpk/bflib/scfint.h
+vendor/source/igraph/vendor/glpk/bflib/sgf.c
+vendor/source/igraph/vendor/glpk/bflib/sgf.h
+vendor/source/igraph/vendor/glpk/bflib/sva.c
+vendor/source/igraph/vendor/glpk/bflib/sva.h
 vendor/source/igraph/vendor/glpk/colamd/COPYING
 vendor/source/igraph/vendor/glpk/colamd/README
 vendor/source/igraph/vendor/glpk/colamd/colamd.c
 vendor/source/igraph/vendor/glpk/colamd/colamd.h
+vendor/source/igraph/vendor/glpk/draft/bfd.c
+vendor/source/igraph/vendor/glpk/draft/bfd.h
+vendor/source/igraph/vendor/glpk/draft/bfx.c
+vendor/source/igraph/vendor/glpk/draft/bfx.h
+vendor/source/igraph/vendor/glpk/draft/draft.h
+vendor/source/igraph/vendor/glpk/draft/glpapi06.c
+vendor/source/igraph/vendor/glpk/draft/glpapi07.c
+vendor/source/igraph/vendor/glpk/draft/glpapi08.c
+vendor/source/igraph/vendor/glpk/draft/glpapi09.c
+vendor/source/igraph/vendor/glpk/draft/glpapi10.c
+vendor/source/igraph/vendor/glpk/draft/glpapi12.c
+vendor/source/igraph/vendor/glpk/draft/glpapi13.c
+vendor/source/igraph/vendor/glpk/draft/glpios01.c
+vendor/source/igraph/vendor/glpk/draft/glpios02.c
+vendor/source/igraph/vendor/glpk/draft/glpios03.c
+vendor/source/igraph/vendor/glpk/draft/glpios07.c
+vendor/source/igraph/vendor/glpk/draft/glpios09.c
+vendor/source/igraph/vendor/glpk/draft/glpios11.c
+vendor/source/igraph/vendor/glpk/draft/glpios12.c
+vendor/source/igraph/vendor/glpk/draft/glpipm.c
+vendor/source/igraph/vendor/glpk/draft/glpipm.h
+vendor/source/igraph/vendor/glpk/draft/glpmat.c
+vendor/source/igraph/vendor/glpk/draft/glpmat.h
+vendor/source/igraph/vendor/glpk/draft/glpscl.c
+vendor/source/igraph/vendor/glpk/draft/glpssx.h
+vendor/source/igraph/vendor/glpk/draft/glpssx01.c
+vendor/source/igraph/vendor/glpk/draft/glpssx02.c
+vendor/source/igraph/vendor/glpk/draft/ios.h
+vendor/source/igraph/vendor/glpk/draft/lux.c
+vendor/source/igraph/vendor/glpk/draft/lux.h
+vendor/source/igraph/vendor/glpk/env/alloc.c
+vendor/source/igraph/vendor/glpk/env/dlsup.c
+vendor/source/igraph/vendor/glpk/env/env.c
+vendor/source/igraph/vendor/glpk/env/env.h
+vendor/source/igraph/vendor/glpk/env/error.c
+vendor/source/igraph/vendor/glpk/env/stdc.c
+vendor/source/igraph/vendor/glpk/env/stdc.h
+vendor/source/igraph/vendor/glpk/env/stdout.c
+vendor/source/igraph/vendor/glpk/env/stream.c
+vendor/source/igraph/vendor/glpk/env/time.c
+vendor/source/igraph/vendor/glpk/env/tls.c
+vendor/source/igraph/vendor/glpk/intopt/cfg.c
+vendor/source/igraph/vendor/glpk/intopt/cfg.h
+vendor/source/igraph/vendor/glpk/intopt/cfg1.c
+vendor/source/igraph/vendor/glpk/intopt/cfg2.c
+vendor/source/igraph/vendor/glpk/intopt/clqcut.c
+vendor/source/igraph/vendor/glpk/intopt/covgen.c
+vendor/source/igraph/vendor/glpk/intopt/fpump.c
+vendor/source/igraph/vendor/glpk/intopt/gmicut.c
+vendor/source/igraph/vendor/glpk/intopt/gmigen.c
+vendor/source/igraph/vendor/glpk/intopt/mirgen.c
+vendor/source/igraph/vendor/glpk/intopt/spv.c
+vendor/source/igraph/vendor/glpk/intopt/spv.h
+vendor/source/igraph/vendor/glpk/minisat/LICENSE
+vendor/source/igraph/vendor/glpk/minisat/README
+vendor/source/igraph/vendor/glpk/minisat/minisat.c
+vendor/source/igraph/vendor/glpk/minisat/minisat.h
+vendor/source/igraph/vendor/glpk/misc/avl.c
+vendor/source/igraph/vendor/glpk/misc/avl.h
+vendor/source/igraph/vendor/glpk/misc/bignum.c
+vendor/source/igraph/vendor/glpk/misc/bignum.h
+vendor/source/igraph/vendor/glpk/misc/dimacs.c
+vendor/source/igraph/vendor/glpk/misc/dimacs.h
+vendor/source/igraph/vendor/glpk/misc/dmp.c
+vendor/source/igraph/vendor/glpk/misc/dmp.h
+vendor/source/igraph/vendor/glpk/misc/ffalg.c
+vendor/source/igraph/vendor/glpk/misc/ffalg.h
+vendor/source/igraph/vendor/glpk/misc/fp2rat.c
+vendor/source/igraph/vendor/glpk/misc/fvs.c
+vendor/source/igraph/vendor/glpk/misc/fvs.h
+vendor/source/igraph/vendor/glpk/misc/gcd.c
+vendor/source/igraph/vendor/glpk/misc/hbm.c
+vendor/source/igraph/vendor/glpk/misc/hbm.h
+vendor/source/igraph/vendor/glpk/misc/jd.c
+vendor/source/igraph/vendor/glpk/misc/jd.h
+vendor/source/igraph/vendor/glpk/misc/keller.c
+vendor/source/igraph/vendor/glpk/misc/keller.h
+vendor/source/igraph/vendor/glpk/misc/ks.c
+vendor/source/igraph/vendor/glpk/misc/ks.h
+vendor/source/igraph/vendor/glpk/misc/mc13d.c
+vendor/source/igraph/vendor/glpk/misc/mc13d.h
+vendor/source/igraph/vendor/glpk/misc/mc21a.c
+vendor/source/igraph/vendor/glpk/misc/mc21a.h
+vendor/source/igraph/vendor/glpk/misc/misc.h
+vendor/source/igraph/vendor/glpk/misc/mt1.c
+vendor/source/igraph/vendor/glpk/misc/mt1.f
+vendor/source/igraph/vendor/glpk/misc/mt1.h
+vendor/source/igraph/vendor/glpk/misc/mygmp.c
+vendor/source/igraph/vendor/glpk/misc/mygmp.h
+vendor/source/igraph/vendor/glpk/misc/okalg.c
+vendor/source/igraph/vendor/glpk/misc/okalg.h
+vendor/source/igraph/vendor/glpk/misc/qmd.c
+vendor/source/igraph/vendor/glpk/misc/qmd.h
+vendor/source/igraph/vendor/glpk/misc/relax4.c
+vendor/source/igraph/vendor/glpk/misc/relax4.h
+vendor/source/igraph/vendor/glpk/misc/rgr.c
+vendor/source/igraph/vendor/glpk/misc/rgr.h
+vendor/source/igraph/vendor/glpk/misc/rng.c
+vendor/source/igraph/vendor/glpk/misc/rng.h
+vendor/source/igraph/vendor/glpk/misc/rng1.c
+vendor/source/igraph/vendor/glpk/misc/round2n.c
+vendor/source/igraph/vendor/glpk/misc/spm.c
+vendor/source/igraph/vendor/glpk/misc/spm.h
+vendor/source/igraph/vendor/glpk/misc/str2int.c
+vendor/source/igraph/vendor/glpk/misc/str2num.c
+vendor/source/igraph/vendor/glpk/misc/strspx.c
+vendor/source/igraph/vendor/glpk/misc/strtrim.c
+vendor/source/igraph/vendor/glpk/misc/triang.c
+vendor/source/igraph/vendor/glpk/misc/triang.h
+vendor/source/igraph/vendor/glpk/misc/wclique.c
+vendor/source/igraph/vendor/glpk/misc/wclique.h
+vendor/source/igraph/vendor/glpk/misc/wclique1.c
+vendor/source/igraph/vendor/glpk/misc/wclique1.h
+vendor/source/igraph/vendor/glpk/mpl/mpl.h
+vendor/source/igraph/vendor/glpk/mpl/mpl1.c
+vendor/source/igraph/vendor/glpk/mpl/mpl2.c
+vendor/source/igraph/vendor/glpk/mpl/mpl3.c
+vendor/source/igraph/vendor/glpk/mpl/mpl4.c
+vendor/source/igraph/vendor/glpk/mpl/mpl5.c
+vendor/source/igraph/vendor/glpk/mpl/mpl6.c
+vendor/source/igraph/vendor/glpk/mpl/mplsql.c
+vendor/source/igraph/vendor/glpk/mpl/mplsql.h
+vendor/source/igraph/vendor/glpk/npp/npp.h
+vendor/source/igraph/vendor/glpk/npp/npp1.c
+vendor/source/igraph/vendor/glpk/npp/npp2.c
+vendor/source/igraph/vendor/glpk/npp/npp3.c
+vendor/source/igraph/vendor/glpk/npp/npp4.c
+vendor/source/igraph/vendor/glpk/npp/npp5.c
+vendor/source/igraph/vendor/glpk/npp/npp6.c
+vendor/source/igraph/vendor/glpk/proxy/main.c
+vendor/source/igraph/vendor/glpk/proxy/proxy.c
+vendor/source/igraph/vendor/glpk/proxy/proxy.h
+vendor/source/igraph/vendor/glpk/proxy/proxy1.c
+vendor/source/igraph/vendor/glpk/simplex/simplex.h
+vendor/source/igraph/vendor/glpk/simplex/spxat.c
+vendor/source/igraph/vendor/glpk/simplex/spxat.h
+vendor/source/igraph/vendor/glpk/simplex/spxchuzc.c
+vendor/source/igraph/vendor/glpk/simplex/spxchuzc.h
+vendor/source/igraph/vendor/glpk/simplex/spxchuzr.c
+vendor/source/igraph/vendor/glpk/simplex/spxchuzr.h
+vendor/source/igraph/vendor/glpk/simplex/spxlp.c
+vendor/source/igraph/vendor/glpk/simplex/spxlp.h
+vendor/source/igraph/vendor/glpk/simplex/spxnt.c
+vendor/source/igraph/vendor/glpk/simplex/spxnt.h
+vendor/source/igraph/vendor/glpk/simplex/spxprim.c
+vendor/source/igraph/vendor/glpk/simplex/spxprob.c
+vendor/source/igraph/vendor/glpk/simplex/spxprob.h
+vendor/source/igraph/vendor/glpk/simplex/spychuzc.c
+vendor/source/igraph/vendor/glpk/simplex/spychuzc.h
+vendor/source/igraph/vendor/glpk/simplex/spychuzr.c
+vendor/source/igraph/vendor/glpk/simplex/spychuzr.h
+vendor/source/igraph/vendor/glpk/simplex/spydual.c
 vendor/source/igraph/vendor/lapack/CMakeLists.txt
 vendor/source/igraph/vendor/lapack/dasum.c
 vendor/source/igraph/vendor/lapack/daxpy.c
 vendor/source/igraph/vendor/lapack/dcopy.c
 vendor/source/igraph/vendor/lapack/ddot.c
 vendor/source/igraph/vendor/lapack/debug.h
 vendor/source/igraph/vendor/lapack/dgebak.c
@@ -2027,27 +2158,28 @@
 vendor/source/igraph/vendor/mini-gmp/CMakeLists.txt
 vendor/source/igraph/vendor/mini-gmp/mini-gmp.c
 vendor/source/igraph/vendor/mini-gmp/mini-gmp.h
 vendor/source/igraph/vendor/plfit/CMakeLists.txt
 vendor/source/igraph/vendor/plfit/arithmetic_ansi.h
 vendor/source/igraph/vendor/plfit/arithmetic_sse_double.h
 vendor/source/igraph/vendor/plfit/arithmetic_sse_float.h
-vendor/source/igraph/vendor/plfit/error.h
 vendor/source/igraph/vendor/plfit/gss.c
 vendor/source/igraph/vendor/plfit/gss.h
 vendor/source/igraph/vendor/plfit/hzeta.c
 vendor/source/igraph/vendor/plfit/hzeta.h
 vendor/source/igraph/vendor/plfit/kolmogorov.c
 vendor/source/igraph/vendor/plfit/kolmogorov.h
 vendor/source/igraph/vendor/plfit/lbfgs.c
 vendor/source/igraph/vendor/plfit/lbfgs.h
 vendor/source/igraph/vendor/plfit/mt.c
-vendor/source/igraph/vendor/plfit/mt.h
 vendor/source/igraph/vendor/plfit/options.c
 vendor/source/igraph/vendor/plfit/platform.c
 vendor/source/igraph/vendor/plfit/platform.h
 vendor/source/igraph/vendor/plfit/plfit.c
 vendor/source/igraph/vendor/plfit/plfit.h
 vendor/source/igraph/vendor/plfit/plfit_error.c
+vendor/source/igraph/vendor/plfit/plfit_error.h
+vendor/source/igraph/vendor/plfit/plfit_mt.h
+vendor/source/igraph/vendor/plfit/plfit_sampling.h
+vendor/source/igraph/vendor/plfit/plfit_version.h
 vendor/source/igraph/vendor/plfit/rbinom.c
-vendor/source/igraph/vendor/plfit/sampling.c
-vendor/source/igraph/vendor/plfit/sampling.h
+vendor/source/igraph/vendor/plfit/sampling.c
```

### Comparing `igraph-0.9.8/scripts/mkdoc.sh` & `igraph-0.9.9/scripts/mkdoc.sh`

 * *Files 10% similar despite different names*

```diff
@@ -22,14 +22,17 @@
 if [ ! -f ${PYDOCTOR} ]; then
   echo "PyDoctor not installed in the virtualenv of the project, exiting..."
   exit 1
 fi
 
 PWD=`pwd`
 
+echo "Patching PyDoctor..."
+$SCRIPTS_FOLDER/patch-pydoctor.sh ${ROOT_FOLDER} ${SCRIPTS_FOLDER}
+
 echo "Removing existing documentation..."
 rm -rf "${DOC_API_FOLDER}/html" "${DOC_API_FOLDER}/pdf"
 
 echo "Removing existing igraph and python-igraph eggs from virtualenv..."
 SITE_PACKAGES_DIR=`.venv/bin/python3 -c 'import sysconfig; print(sysconfig.get_paths()["purelib"])'`
 rm -rf "${SITE_PACKAGES_DIR}"/igraph*.egg
 rm -rf "${SITE_PACKAGES_DIR}"/igraph*.egg-link
```

### Comparing `igraph-0.9.8/setup.py` & `igraph-0.9.9/setup.py`

 * *Files 2% similar despite different names*

```diff
@@ -63,14 +63,15 @@
     static library with this name in the given `library_path`. `library_path`
     is automatically extended with common library directories on Linux and Mac
     OS X."""
 
     variants = ["lib{0}.a", "{0}.a", "{0}.lib", "lib{0}.lib"]
     if is_unix_like():
         extra_libdirs = [
+            "/opt/homebrew/lib",  # for newer Homebrew installations on macOS
             "/usr/local/lib64",
             "/usr/local/lib",
             "/usr/lib/x86_64-linux-gnu",
             "/usr/lib64",
             "/usr/lib",
             "/lib64",
             "/lib",
@@ -232,14 +233,17 @@
         for deps in "ARPACK BLAS CXSPARSE GLPK GMP LAPACK".split():
             args.append("-DIGRAPH_USE_INTERNAL_" + deps + "=ON")
 
         # -fPIC is needed on Linux so we can link to a static igraph lib from a
         # Python shared library
         args.append("-DCMAKE_POSITION_INDEPENDENT_CODE=ON")
 
+        # No need to build tests
+        args.append("-DBUILD_TESTING=OFF")
+
         # Add any extra CMake args from environment variables
         if "IGRAPH_CMAKE_EXTRA_ARGS" in os.environ:
             args.extend(shlex.split(os.environ["IGRAPH_CMAKE_EXTRA_ARGS"]))
 
         # Finally, add the source folder path
         args.append(str(build_to_source_folder))
 
@@ -819,25 +823,30 @@
         "Bug Tracker": "https://github.com/igraph/python-igraph/issues",
         "Changelog": "https://github.com/igraph/python-igraph/blob/master/CHANGELOG.md",
         "CI": "https://github.com/igraph/python-igraph/actions",
         "Documentation": "https://igraph.org/python/doc",
         "Source Code": "https://github.com/igraph/python-igraph",
     },
     ext_modules=[igraph_extension],
-    package_dir={"igraph": "src/igraph"},
+    package_dir={
+        # make sure to use the next line and not the more logical and restrictive
+        # "igraph": "src/igraph" because that one breaks 'setup.py develop'.
+        # See: https://github.com/igraph/python-igraph/issues/464
+        "": "src"
+    },
     packages=["igraph", "igraph.app", "igraph.drawing", "igraph.remote"],
     scripts=["scripts/igraph"],
     install_requires=["texttable>=1.6.2"],
     extras_require={
         "plotting": ["cairocffi>=1.2.0"],
         "test": [
             "networkx>=2.5",
             "pytest>=6.2.5",
             "numpy>=1.19.0; platform_python_implementation != 'PyPy'",
-            "pandas>=1.1.0,<1.3.1; platform_python_implementation != 'PyPy'",
+            "pandas>=1.1.0; platform_python_implementation != 'PyPy'",
             "scipy>=1.5.0; platform_python_implementation != 'PyPy'",
         ],
         "doc": [
             "Sphinx>=4.2.0",
             "sphinxbootstrap4theme>=0.6.0"
         ]
     },
```

### Comparing `igraph-0.9.8/src/_igraph/arpackobject.c` & `igraph-0.9.9/src/_igraph/arpackobject.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/arpackobject.h` & `igraph-0.9.9/src/_igraph/arpackobject.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/attributes.c` & `igraph-0.9.9/src/_igraph/attributes.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/attributes.h` & `igraph-0.9.9/src/_igraph/attributes.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/bfsiter.c` & `igraph-0.9.9/src/_igraph/bfsiter.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/bfsiter.h` & `igraph-0.9.9/src/_igraph/bfsiter.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/common.c` & `igraph-0.9.9/src/_igraph/common.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/common.h` & `igraph-0.9.9/src/_igraph/common.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/convert.c` & `igraph-0.9.9/src/_igraph/convert.c`

 * *Files 1% similar despite different names*

```diff
@@ -2507,15 +2507,15 @@
         Py_DECREF(num);
         return 1;
       }
       Py_DECREF(num);
     } else
       return 1;
   } else {
-    PyErr_SetString(PyExc_TypeError, "only numbers, strings or igraph.Vertex objects can be converted to vertex IDs");
+    PyErr_SetString(PyExc_TypeError, "only non-negative integers, strings or igraph.Vertex objects can be converted to vertex IDs");
     return 1;
   }
 
   if (*vid < 0) {
     PyErr_Format(PyExc_ValueError, "vertex IDs must be positive, got: %ld", (long)(*vid));
     return 1;
   }
@@ -2752,15 +2752,15 @@
     if (*eid < 0) {
       PyErr_Format(PyExc_ValueError, "no edge from vertex #%ld to #%ld",
           (long int)vid1, (long int)vid2);
       return 1;
     }
   } else {
     PyErr_SetString(PyExc_TypeError,
-        "only numbers, igraph.Edge objects or tuples of vertex IDs can be "
+        "only non-negative integers, igraph.Edge objects or tuples of vertex IDs can be "
         "converted to edge IDs");
     return 1;
   }
 
   if (*eid < 0) {
     PyErr_Format(PyExc_ValueError, "edge IDs must be positive, got: %ld", (long)(*eid));
     return 1;
```

### Comparing `igraph-0.9.8/src/_igraph/convert.h` & `igraph-0.9.9/src/_igraph/convert.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/dfsiter.c` & `igraph-0.9.9/src/_igraph/dfsiter.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/dfsiter.h` & `igraph-0.9.9/src/_igraph/dfsiter.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/edgeobject.c` & `igraph-0.9.9/src/_igraph/edgeobject.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/edgeobject.h` & `igraph-0.9.9/src/_igraph/edgeobject.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/edgeseqobject.c` & `igraph-0.9.9/src/_igraph/edgeseqobject.c`

 * *Files 3% similar despite different names*

```diff
@@ -327,23 +327,27 @@
   /* Handle integer indices according to the sequence protocol */
   if (PyIndex_Check(o)) {
     index = PyNumber_AsSsize_t(o, 0);
     return igraphmodule_EdgeSeq_sq_item(self, index);
   }
 
   /* Handle strings according to the mapping protocol */
-  if (PyBaseString_Check(o))
+  if (PyBaseString_Check(o)) {
     return igraphmodule_EdgeSeq_get_attribute_values(self, o);
+  }
 
   /* Handle iterables and slices by calling the select() method */
   if (PySlice_Check(o) || PyObject_HasAttrString(o, "__iter__")) {
     PyObject *result, *args;
-    args = Py_BuildValue("(O)", o);
-    if (!args)
+    args = PyTuple_Pack(1, o);
+
+    if (!args) {
       return NULL;
+    }
+
     result = igraphmodule_EdgeSeq_select(self, args);
     Py_DECREF(args);
     return result;
   }
 
   /* Handle everything else according to the mapping protocol */
   return igraphmodule_EdgeSeq_get_attribute_values(self, o);
@@ -555,61 +559,65 @@
  * \ingroup python_interface_edgeseq
  * \brief Selects a subset of the edge sequence based on some criteria
  */
 PyObject* igraphmodule_EdgeSeq_select(igraphmodule_EdgeSeqObject *self, PyObject *args) {
   igraphmodule_EdgeSeqObject *result;
   igraphmodule_GraphObject *gr;
   igraph_integer_t igraph_idx;
+  igraph_bool_t working_on_whole_graph = igraph_es_is_all(&self->es);
+  igraph_vector_t v, v2;
   long i, j, n, m;
 
-  gr=self->gref;
-  result=igraphmodule_EdgeSeq_copy(self);
+  gr = self->gref;
+  result = igraphmodule_EdgeSeq_copy(self);
   if (result == 0)
     return NULL;
 
   /* First, filter by positional arguments */
   n = PyTuple_Size(args);
-  for (i=0; i<n; i++) {
+  for (i = 0; i < n; i++) {
     PyObject *item = PyTuple_GET_ITEM(args, i);
     if (item == Py_None) {
       /* None means: select nothing */
       igraph_es_destroy(&result->es);
       igraph_es_none(&result->es);
       /* We can simply bail out here */
-      return (PyObject*)result;
+      return (PyObject*) result;
     } else if (PyCallable_Check(item)) {
       /* Call the callable for every edge in the current sequence to
        * determine what's up */
       igraph_bool_t was_excluded = 0;
       igraph_vector_t v;
 
       if (igraph_vector_init(&v, 0)) {
         igraphmodule_handle_igraph_error();
         return 0;
       }
 
       m = PySequence_Size((PyObject*)result);
-      for (j=0; j<m; j++) {
+      for (j = 0; j < m; j++) {
         PyObject *edge = PySequence_GetItem((PyObject*)result, j);
         PyObject *call_result;
         if (edge == 0) {
           Py_DECREF(result);
           igraph_vector_destroy(&v);
           return NULL;
         }
         call_result = PyObject_CallFunctionObjArgs(item, edge, NULL);
         if (call_result == 0) {
           Py_DECREF(edge); Py_DECREF(result);
           igraph_vector_destroy(&v);
           return NULL;
         }
-        if (PyObject_IsTrue(call_result))
+        if (PyObject_IsTrue(call_result)) {
           igraph_vector_push_back(&v,
             igraphmodule_Edge_get_index_long((igraphmodule_EdgeObject*)edge));
-        else was_excluded=1;
+        } else {
+          was_excluded = 1;
+        }
         Py_DECREF(call_result);
         Py_DECREF(edge);
       }
 
       if (was_excluded) {
         igraph_es_destroy(&result->es);
         if (igraph_es_vector_copy(&result->es, &v)) {
@@ -623,159 +631,199 @@
       igraph_vector_destroy(&v);
     } else if (PyLong_Check(item)) {
       /* Integers are treated specially: from now on, all remaining items
        * in the argument list must be integers and they will be used together
        * to restrict the edge set. Integers are interpreted as indices on the
        * edge set and NOT on the original, untouched edge sequence of the
        * graph */
-      igraph_vector_t v, v2;
       if (igraph_vector_init(&v, 0)) {
         igraphmodule_handle_igraph_error();
         return 0;
       }
-      if (igraph_vector_init(&v2, 0)) {
-        igraph_vector_destroy(&v);
-        igraphmodule_handle_igraph_error();
-        return 0;
-      }
-      if (igraph_es_as_vector(&gr->g, self->es, &v2)) {
-        igraph_vector_destroy(&v);
-        igraph_vector_destroy(&v2);
-        igraphmodule_handle_igraph_error();
-        return 0;
+
+      if (!working_on_whole_graph) {
+        /* Extract the current vertex sequence into a vector */
+        if (igraph_vector_init(&v2, 0)) {
+          igraph_vector_destroy(&v);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        if (igraph_es_as_vector(&gr->g, self->es, &v2)) {
+          igraph_vector_destroy(&v);
+          igraph_vector_destroy(&v2);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        m = igraph_vector_size(&v2);
+      } else {
+        /* v2 left uninitialized, we are not going to use it as it would
+         * simply contain integers from 0 to ecount(g)-1 */
+        m = igraph_ecount(&gr->g);
       }
-      m = igraph_vector_size(&v2);
-      for (; i<n; i++) {
+
+      for (; i < n; i++) {
         PyObject *item2 = PyTuple_GET_ITEM(args, i);
         long idx;
         if (!PyLong_Check(item2)) {
           Py_DECREF(result);
           PyErr_SetString(PyExc_TypeError, "edge indices expected");
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           return NULL;
         }
         idx = PyLong_AsLong(item2);
         if (idx >= m || idx < 0) {
           PyErr_SetString(PyExc_ValueError, "edge index out of range");
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           return NULL;
         }
-        if (igraph_vector_push_back(&v, VECTOR(v2)[idx])) {
+        if (igraph_vector_push_back(&v, working_on_whole_graph ? idx : VECTOR(v2)[idx])) {
           Py_DECREF(result);
           igraphmodule_handle_igraph_error();
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           return NULL;
         }
       }
-      igraph_vector_destroy(&v2);
+
+      if (!working_on_whole_graph) {
+        igraph_vector_destroy(&v2);
+      }
+
       igraph_es_destroy(&result->es);
+
       if (igraph_es_vector_copy(&result->es, &v)) {
         Py_DECREF(result);
         igraphmodule_handle_igraph_error();
         igraph_vector_destroy(&v);
         return NULL;
       }
+
       igraph_vector_destroy(&v);
     } else {
       /* Iterators and everything that was not handled directly */
       PyObject *iter, *item2;
-      igraph_vector_t v, v2;
 
       /* Allocate stuff */
       if (igraph_vector_init(&v, 0)) {
         igraphmodule_handle_igraph_error();
         return 0;
       }
-      if (igraph_vector_init(&v2, 0)) {
-        igraph_vector_destroy(&v);
-        igraphmodule_handle_igraph_error();
-        return 0;
-      }
-      if (igraph_es_as_vector(&gr->g, self->es, &v2)) {
-        igraph_vector_destroy(&v);
-        igraph_vector_destroy(&v2);
-        igraphmodule_handle_igraph_error();
-        return 0;
+      if (!working_on_whole_graph) {
+        /* Extract the current vertex sequence into a vector */
+        if (igraph_vector_init(&v2, 0)) {
+          igraph_vector_destroy(&v);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        if (igraph_es_as_vector(&gr->g, self->es, &v2)) {
+          igraph_vector_destroy(&v);
+          igraph_vector_destroy(&v2);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        m = igraph_vector_size(&v2);
+      } else {
+        /* v2 left uninitialized, we are not going to use it as it would
+         * simply contain integers from 0 to ecount(g)-1 */
+        m = igraph_ecount(&gr->g);
       }
-      m = igraph_vector_size(&v2);
 
       /* Create an appropriate iterator */
       if (PySlice_Check(item)) {
         /* Create an iterator from the slice (which is not iterable by default )*/
         Py_ssize_t start, stop, step, sl;
         PyObject* range;
         igraph_bool_t ok;
 
-        ok = (PySlice_GetIndicesEx(item, igraph_vector_size(&v2), &start, &stop, &step, &sl) == 0);
+        ok = (PySlice_GetIndicesEx(item, m, &start, &stop, &step, &sl) == 0);
         if (ok) {
           range = igraphmodule_PyRange_create(start, stop, step);
           ok = (range != 0);
         }
         if (ok) {
           iter = PyObject_GetIter(range);
           Py_DECREF(range);
           ok = (iter != 0);
         }
         if (!ok) {
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           PyErr_SetString(PyExc_TypeError, "error while converting slice to iterator");
           Py_DECREF(result);
           return 0;
         }
       } else {
         /* Simply create the iterator corresponding to the object */
         iter = PyObject_GetIter(item);
       }
 
       /* Did we manage to get an iterator? */
       if (iter == 0) {
         igraph_vector_destroy(&v);
-        igraph_vector_destroy(&v2);
+        if (!working_on_whole_graph) {
+          igraph_vector_destroy(&v2);
+        }
         PyErr_SetString(PyExc_TypeError, "invalid edge filter among positional arguments");
         Py_DECREF(result);
         return 0;
       }
       /* Do the iteration */
-      while ((item2=PyIter_Next(iter)) != 0) {
+      while ((item2 = PyIter_Next(iter)) != 0) {
         if (igraphmodule_PyObject_to_integer_t(item2, &igraph_idx)) {
           /* We simply ignore elements that we don't know */
           Py_DECREF(item2);
         } else {
           Py_DECREF(item2);
           if (igraph_idx >= m || igraph_idx < 0) {
             PyErr_SetString(PyExc_ValueError, "edge index out of range");
             Py_DECREF(result);
             Py_DECREF(iter);
             igraph_vector_destroy(&v);
-            igraph_vector_destroy(&v2);
+            if (!working_on_whole_graph) {
+              igraph_vector_destroy(&v2);
+            }
             return NULL;
           }
-          if (igraph_vector_push_back(&v, VECTOR(v2)[(long int) igraph_idx])) {
+          if (igraph_vector_push_back(&v, working_on_whole_graph ? igraph_idx : VECTOR(v2)[(long int) igraph_idx])) {
             Py_DECREF(result);
             Py_DECREF(iter);
             igraphmodule_handle_igraph_error();
             igraph_vector_destroy(&v);
-            igraph_vector_destroy(&v2);
+            if (!working_on_whole_graph) {
+              igraph_vector_destroy(&v2);
+            }
             return NULL;
           }
         }
       }
+
       /* Deallocate stuff */
-      igraph_vector_destroy(&v2);
+      if (!working_on_whole_graph) {
+        igraph_vector_destroy(&v2);
+      }
+
       Py_DECREF(iter);
       if (PyErr_Occurred()) {
         igraph_vector_destroy(&v);
         Py_DECREF(result);
         return 0;
       }
+
       igraph_es_destroy(&result->es);
+
       if (igraph_es_vector_copy(&result->es, &v)) {
         Py_DECREF(result);
         igraphmodule_handle_igraph_error();
         igraph_vector_destroy(&v);
         return NULL;
       }
       igraph_vector_destroy(&v);
```

### Comparing `igraph-0.9.8/src/_igraph/edgeseqobject.h` & `igraph-0.9.9/src/_igraph/edgeseqobject.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/error.c` & `igraph-0.9.9/src/_igraph/error.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/error.h` & `igraph-0.9.9/src/_igraph/error.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/filehandle.c` & `igraph-0.9.9/src/_igraph/filehandle.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/filehandle.h` & `igraph-0.9.9/src/_igraph/filehandle.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/graphobject.c` & `igraph-0.9.9/src/_igraph/graphobject.c`

 * *Files 1% similar despite different names*

```diff
@@ -381,29 +381,25 @@
 /** \ingroup python_interface_graph
  * \brief Returns the number of vertices in an \c igraph.Graph object.
  * \return the number of vertices as a \c PyObject
  * \sa igraph_vcount
  */
 PyObject *igraphmodule_Graph_vcount(igraphmodule_GraphObject * self)
 {
-  PyObject *result;
-  result = Py_BuildValue("l", (long)igraph_vcount(&self->g));
-  return result;
+  return PyLong_FromLong(igraph_vcount(&self->g));
 }
 
 /** \ingroup python_interface_graph
  * \brief Returns the number of edges in an \c igraph.Graph object.
  * \return the number of edges as a \c PyObject
  * \sa igraph_ecount
  */
 PyObject *igraphmodule_Graph_ecount(igraphmodule_GraphObject * self)
 {
-  PyObject *result;
-  result = Py_BuildValue("l", (long)igraph_ecount(&self->g));
-  return result;
+  return PyLong_FromLong(igraph_ecount(&self->g));
 }
 
 /** \ingroup python_interface_graph
  * \brief Checks whether an \c igraph.Graph object is a DAG.
  * \return \c True if the graph is directed, \c False otherwise.
  * \sa igraph_is_dag
  */
@@ -934,15 +930,15 @@
     return NULL;
 
   if (igraph_density(&self->g, &result, PyObject_IsTrue(loops))) {
     igraphmodule_handle_igraph_error();
     return NULL;
   }
 
-  return Py_BuildValue("d", (double)result);
+  return PyFloat_FromDouble(result);
 }
 
 /** \ingroup python_interface_graph
  * \brief The maximum degree of some vertices in an \c igraph.Graph
  * \return the maxium degree as a Python object
  * \sa igraph_maxdegree
  */
@@ -1315,15 +1311,15 @@
     return NULL;
 
   if (igraph_reciprocity(&self->g, &result, PyObject_IsTrue(ignore_loops), mode)) {
     igraphmodule_handle_igraph_error();
     return NULL;
   }
 
-  return Py_BuildValue("d", (double)result);
+  return PyFloat_FromDouble(result);
 }
 
 /** \ingroup python_interface_graph
  * \brief The successors of a given vertex in an \c igraph.Graph
  * This method accepts a single vertex ID as a parameter, and returns the
  * successors of the given vertex in the form of an integer list. It
  * is equivalent to calling \c igraph.Graph.neighbors with \c type=OUT
@@ -1479,15 +1475,15 @@
   if (igraphmodule_PyObject_to_vid(v2, &idx2, &self->g))
     return NULL;
 
   if (igraph_get_eid(&self->g, &result, idx1, idx2,
         PyObject_IsTrue(directed), PyObject_IsTrue(error)))
     return igraphmodule_handle_igraph_error();
 
-  return Py_BuildValue("l", (long)result);
+  return PyLong_FromLong(result);
 }
 
 /** \ingroup python_interface_graph
  * \brief Returns the IDs of some edges between some vertices
  * \sa igraph_get_eids
  */
 PyObject *igraphmodule_Graph_get_eids(igraphmodule_GraphObject * self,
@@ -3696,15 +3692,15 @@
   }
 
   if (ret) {
     igraphmodule_handle_igraph_error();
     return NULL;
   }
 
-  return Py_BuildValue("d", (double)(res));
+  return PyFloat_FromDouble(res);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates the assortativity coefficient
  * \sa igraph_assortativity
  */
 PyObject *igraphmodule_Graph_assortativity(igraphmodule_GraphObject *self, PyObject *args, PyObject *kwds)
@@ -3731,15 +3727,15 @@
   if (types2) { igraph_vector_destroy(types2); free(types2); }
 
   if (ret) {
     igraphmodule_handle_igraph_error();
     return NULL;
   }
 
-  return Py_BuildValue("d", (double)(res));
+  return PyFloat_FromDouble(res);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates the assortativity coefficient for degrees
  * \sa igraph_assortativity_degree
  */
 PyObject *igraphmodule_Graph_assortativity_degree(igraphmodule_GraphObject *self, PyObject *args, PyObject *kwds)
@@ -3752,15 +3748,15 @@
     return NULL;
 
   if (igraph_assortativity_degree(&self->g, &res, PyObject_IsTrue(directed))) {
     igraphmodule_handle_igraph_error();
     return NULL;
   }
 
-  return Py_BuildValue("d", (double)(res));
+  return PyFloat_FromDouble(res);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates Kleinberg's authority scores of the vertices in the graph
  * \sa igraph_authority_score
  */
 PyObject *igraphmodule_Graph_authority_score(
@@ -4816,15 +4812,15 @@
  * \return the edge connectivity
  * \sa igraph_edge_connectivity, igraph_st_edge_connectivity
  */
 PyObject *igraphmodule_Graph_edge_connectivity(igraphmodule_GraphObject *self,
         PyObject *args, PyObject *kwds) {
   static char *kwlist[] = { "source", "target", "checks", NULL };
   PyObject *checks = Py_True;
-  long int source = -1, target = -1, result;
+  long int source = -1, target = -1;
   igraph_integer_t res;
 
   if (!PyArg_ParseTupleAndKeywords(args, kwds, "|llO", kwlist,
       &source, &target, &checks))
     return NULL;
 
   if (source < 0 && target < 0) {
@@ -4836,20 +4832,18 @@
     if (igraph_st_edge_connectivity(&self->g, &res, (igraph_integer_t) source,
           (igraph_integer_t) target)) {
       igraphmodule_handle_igraph_error();
       return NULL;
     }
   } else {
   PyErr_SetString(PyExc_ValueError, "if source or target is given, the other one must also be specified");
-  return NULL;
+    return NULL;
   }
 
-  result = res;
-
-  return Py_BuildValue("l", result);
+  return PyLong_FromLong(res);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates the eigenvector centralities of the vertices in the graph
  * \sa igraph_eigenvector_centrality
  */
 PyObject *igraphmodule_Graph_eigenvector_centrality(
@@ -6231,59 +6225,57 @@
  */
 PyObject *igraphmodule_Graph_transitivity_undirected(igraphmodule_GraphObject
                                                      * self, PyObject * args,
                                                      PyObject * kwds)
 {
   static char *kwlist[] = { "mode", NULL };
   igraph_real_t res;
-  PyObject *r, *mode_o = Py_None;
+  PyObject *mode_o = Py_None;
   igraph_transitivity_mode_t mode = IGRAPH_TRANSITIVITY_NAN;
 
   if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O", kwlist, &mode_o))
     return NULL;
 
   if (igraphmodule_PyObject_to_transitivity_mode_t(mode_o, &mode))
     return NULL;
 
 
   if (igraph_transitivity_undirected(&self->g, &res, mode)) {
     igraphmodule_handle_igraph_error();
     return NULL;
   }
 
-  r = Py_BuildValue("d", (double)(res));
-  return r;
+  return PyFloat_FromDouble(res);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates the average of vertex transitivities over the graph
  * \sa igraph_transitivity_avglocal_undirected
  */
 PyObject *igraphmodule_Graph_transitivity_avglocal_undirected(igraphmodule_GraphObject
                                                               * self, PyObject * args,
                                                               PyObject * kwds)
 {
   static char *kwlist[] = { "mode", NULL };
   igraph_real_t res;
-  PyObject *r, *mode_o = Py_None;
+  PyObject *mode_o = Py_None;
   igraph_transitivity_mode_t mode = IGRAPH_TRANSITIVITY_NAN;
 
   if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O", kwlist, &mode_o))
     return NULL;
 
   if (igraphmodule_PyObject_to_transitivity_mode_t(mode_o, &mode))
     return NULL;
 
   if (igraph_transitivity_avglocal_undirected(&self->g, &res, mode)) {
     igraphmodule_handle_igraph_error();
     return NULL;
   }
 
-  r = Py_BuildValue("d", (double)(res));
-  return r;
+  return PyFloat_FromDouble(res);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates the local transitivity of given vertices
  * \return the transitivities in a list
  * \sa igraph_transitivity_local_undirected
  */
@@ -6405,15 +6397,15 @@
  * \return the vertex connectivity
  * \sa igraph_vertex_connectivity, igraph_st_vertex_connectivity
  */
 PyObject *igraphmodule_Graph_vertex_connectivity(igraphmodule_GraphObject *self,
         PyObject *args, PyObject *kwds) {
   static char *kwlist[] = { "source", "target", "checks", "neighbors", NULL };
   PyObject *checks = Py_True, *neis = Py_None;
-  long int source = -1, target = -1, result;
+  long int source = -1, target = -1;
   igraph_integer_t res;
   igraph_vconn_nei_t neighbors = IGRAPH_VCONN_NEI_ERROR;
 
   if (!PyArg_ParseTupleAndKeywords(args, kwds, "|llOO", kwlist,
       &source, &target, &checks, &neis))
     return NULL;
 
@@ -6431,18 +6423,19 @@
       return NULL;
     }
   } else {
     PyErr_SetString(PyExc_ValueError, "if source or target is given, the other one must also be specified");
     return NULL;
   }
 
-  if (!IGRAPH_FINITE(res)) return Py_BuildValue("d", (double)res);
+  if (!IGRAPH_FINITE(res)) {
+    return PyFloat_FromDouble(res);
+  }
 
-  result = (long)res;
-  return Py_BuildValue("l", result);
+  return PyLong_FromLong(res);
 }
 
 /**********************************************************************
  * Bipartite graphs                                                   *
  **********************************************************************/
 
 /** \ingroup python_interface_graph
@@ -9299,15 +9292,15 @@
   }
 
   if (color1) { igraph_vector_int_destroy(color1); free(color1); }
   if (color2) { igraph_vector_int_destroy(color2); free(color2); }
   if (edge_color1) { igraph_vector_int_destroy(edge_color1); free(edge_color1); }
   if (edge_color2) { igraph_vector_int_destroy(edge_color2); free(edge_color2); }
 
-  return Py_BuildValue("l", (long)result);
+  return PyLong_FromLong(result);
 }
 
 /** \ingroup python_interface_graph
  * \brief Returns all isomorphisms of two given graphs
  *
  * The actual code is almost the same as igraphmodule_Graph_get_subisomorphisms.
  * Make sure you correct bugs in both interfaces if applicable!
@@ -9636,15 +9629,15 @@
   }
 
   if (color1) { igraph_vector_int_destroy(color1); free(color1); }
   if (color2) { igraph_vector_int_destroy(color2); free(color2); }
   if (edge_color1) { igraph_vector_int_destroy(edge_color1); free(edge_color1); }
   if (edge_color2) { igraph_vector_int_destroy(edge_color2); free(edge_color2); }
 
-  return Py_BuildValue("l", (long)result);
+  return PyLong_FromLong(result);
 }
 
 /** \ingroup python_interface_graph
  * \brief Returns all subisomorphisms of two given graphs
  *
  * The actual code is almost the same as igraphmodule_Graph_get_isomorphisms.
  * Make sure you correct bugs in both interfaces if applicable!
@@ -10330,15 +10323,16 @@
   if (igraph_maxflow_value(&self->g, &result, v1, v2, &capacity_vector,
                &stats)) {
     igraph_vector_destroy(&capacity_vector);
     return igraphmodule_handle_igraph_error();
   }
 
   igraph_vector_destroy(&capacity_vector);
-  return Py_BuildValue("d", (double)result);
+
+  return PyFloat_FromDouble(result);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates the maximum flow of the graph
  */
 PyObject *igraphmodule_Graph_maxflow(igraphmodule_GraphObject * self,
                                      PyObject * args, PyObject * kwds)
@@ -10610,15 +10604,16 @@
     if (igraph_st_mincut_value(&self->g, &result, v1, v2, &capacity_vector)) {
       igraph_vector_destroy(&capacity_vector);
       return igraphmodule_handle_igraph_error();
     }
   }
 
   igraph_vector_destroy(&capacity_vector);
-  return Py_BuildValue("d", (double)result);
+
+  return PyFloat_FromDouble(result);
 }
 
 /** \ingroup python_interface_graph
  * \brief Calculates a minimum cut in a graph
  */
 PyObject *igraphmodule_Graph_mincut(igraphmodule_GraphObject * self,
                                     PyObject * args, PyObject * kwds)
@@ -11511,15 +11506,15 @@
   }
 
   igraph_vector_destroy(&membership);
   if (weights) {
     igraph_vector_destroy(weights); free(weights);
   }
 
-  return Py_BuildValue("d", (double)modularity);
+  return PyFloat_FromDouble(modularity);
 }
 
 /**
  * Newman's edge betweenness method
  */
 PyObject *igraphmodule_Graph_community_edge_betweenness(igraphmodule_GraphObject *self, PyObject *args, PyObject *kwds) {
   static char *kwlist[] = { "directed", "weights", NULL };
@@ -14954,19 +14949,23 @@
    "@param mode: specifies which edges to consider when builing the tree.\n"
    "  If it is C{OUT} then only the outgoing, if it is C{IN} then only the\n"
    "  incoming edges of a parent are considered. If it is C{ALL} then all\n"
    "  edges are used (this was the behaviour in igraph 0.5 and before).\n"
    "  This parameter also influences how the root vertices are calculated\n"
    "  if they are not given. See the I{root} parameter.\n"
    "@param root: the index of the root vertex or root vertices.\n"
-   "  if this is a non-empty vector then the supplied vertex IDs are\n"
+   "  If this is a non-empty vector then the supplied vertex IDs are\n"
    "  used as the roots of the trees (or a single tree if the graph is\n"
-   "  connected. If this is C{None} or an empty list, the root vertices\n"
-   "  are automatically calculated based on topological sorting,\n"
-   "  performed with the opposite of the I{mode} argument.\n"
+   "  connected). If this is C{None} or an empty list, the root vertices\n"
+   "  are automatically calculated in such a way so that all other vertices\n"
+   "  would be reachable from them. Currently, automatic root selection\n"
+   "  prefers low eccentricity vertices in small graphs (fewer than 500\n"
+   "  vertices) and high degree vertices in large graphs. This heuristic\n"
+   "  may change in future versions. Specify roots manually for a consistent\n"
+   "  output.\n"
    "@param rootlevel: this argument is useful when drawing forests which are\n"
    "  not trees. It specifies the level of the root vertices for every tree\n"
    "  in the forest.\n"
    "@return: the calculated layout.\n\n"
    "@see: layout_reingold_tilford_circular\n"
    "@newfield ref: Reference\n"
    "@ref: EM Reingold, JS Tilford: I{Tidier Drawings of Trees.}\n"
@@ -15168,15 +15167,15 @@
    "GraphDB is a binary format, used in the graph database for\n"
    "isomorphism testing (see U{http://amalfi.dis.unina.it/graph/}).\n\n"
    "@param f: the name of the file or a Python file handle\n"
    "@param directed: whether the generated graph should be directed.\n"},
   /* interface to igraph_read_graph_graphml */
   {"Read_GraphML", (PyCFunction) igraphmodule_Graph_Read_GraphML,
    METH_VARARGS | METH_KEYWORDS | METH_CLASS,
-   "Read_GraphML(f, directed=True, index=0)\n--\n\n"
+   "Read_GraphML(f, index=0)\n--\n\n"
    "Reads a GraphML format file and creates a graph based on it.\n\n"
    "@param f: the name of the file or a Python file handle\n"
    "@param index: if the GraphML file contains multiple graphs,\n"
    "  specifies the one that should be loaded. Graph indices\n"
    "  start from zero, so if you want to load the first graph,\n"
    "  specify 0 here.\n"},
   /* interface to igraph_read_graph_gml */
```

### Comparing `igraph-0.9.8/src/_igraph/graphobject.h` & `igraph-0.9.9/src/_igraph/graphobject.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/igraphmodule.c` & `igraph-0.9.9/src/_igraph/igraphmodule.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/igraphmodule_api.h` & `igraph-0.9.9/src/_igraph/igraphmodule_api.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/indexing.c` & `igraph-0.9.9/src/_igraph/indexing.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/indexing.h` & `igraph-0.9.9/src/_igraph/indexing.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/operators.c` & `igraph-0.9.9/src/_igraph/operators.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/operators.h` & `igraph-0.9.9/src/_igraph/operators.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/platform.h` & `igraph-0.9.9/src/_igraph/platform.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/preamble.h` & `igraph-0.9.9/src/_igraph/preamble.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/pyhelpers.c` & `igraph-0.9.9/src/_igraph/pyhelpers.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/pyhelpers.h` & `igraph-0.9.9/src/_igraph/pyhelpers.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/random.c` & `igraph-0.9.9/src/_igraph/random.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/random.h` & `igraph-0.9.9/src/_igraph/random.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/vertexobject.c` & `igraph-0.9.9/src/_igraph/vertexobject.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/vertexobject.h` & `igraph-0.9.9/src/_igraph/vertexobject.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/_igraph/vertexseqobject.c` & `igraph-0.9.9/src/_igraph/vertexseqobject.c`

 * *Files 5% similar despite different names*

```diff
@@ -313,24 +313,27 @@
   /* Handle integer indices according to the sequence protocol */
   if (PyIndex_Check(o)) {
     index = PyNumber_AsSsize_t(o, 0);
     return igraphmodule_VertexSeq_sq_item(self, index);
   }
 
   /* Handle strings according to the mapping protocol */
-  if (PyBaseString_Check(o))
+  if (PyBaseString_Check(o)) {
     return igraphmodule_VertexSeq_get_attribute_values(self, o);
+  }
 
   /* Handle iterables and slices by calling the select() method */
   if (PySlice_Check(o) || PyObject_HasAttrString(o, "__iter__")) {
     PyObject *result, *args;
-    args = Py_BuildValue("(O)", o);
+    args = PyTuple_Pack(1, o);
 
-    if (!args)
+    if (!args) {
       return NULL;
+    }
+
     result = igraphmodule_VertexSeq_select(self, args);
     Py_DECREF(args);
     return result;
   }
 
   /* Handle everything else according to the mapping protocol */
   return igraphmodule_VertexSeq_get_attribute_values(self, o);
@@ -581,63 +584,66 @@
  * \brief Selects a subset of the vertex sequence based on some criteria
  */
 PyObject* igraphmodule_VertexSeq_select(igraphmodule_VertexSeqObject *self,
   PyObject *args) {
   igraphmodule_VertexSeqObject *result;
   igraphmodule_GraphObject *gr;
   igraph_integer_t igraph_idx;
+  igraph_bool_t working_on_whole_graph = igraph_vs_is_all(&self->vs);
+  igraph_vector_t v, v2;
   long i, j, n, m;
 
-  gr=self->gref;
-  result=igraphmodule_VertexSeq_copy(self);
-  if (result==0)
+  gr = self->gref;
+  result = igraphmodule_VertexSeq_copy(self);
+  if (result == 0)
     return NULL;
 
   /* First, filter by positional arguments */
   n = PyTuple_Size(args);
-
-  for (i=0; i<n; i++) {
+  for (i = 0; i < n; i++) {
     PyObject *item = PyTuple_GET_ITEM(args, i);
 
     if (item == Py_None) {
       /* None means: select nothing */
       igraph_vs_destroy(&result->vs);
       igraph_vs_none(&result->vs);
       /* We can simply bail out here */
-      return (PyObject*)result;
+      return (PyObject*) result;
     } else if (PyCallable_Check(item)) {
       /* Call the callable for every vertex in the current sequence to
        * determine what's up */
       igraph_bool_t was_excluded = 0;
       igraph_vector_t v;
 
       if (igraph_vector_init(&v, 0)) {
         igraphmodule_handle_igraph_error();
         return 0;
       }
 
       m = PySequence_Size((PyObject*)result);
-      for (j=0; j<m; j++) {
+      for (j = 0; j < m; j++) {
         PyObject *vertex = PySequence_GetItem((PyObject*)result, j);
         PyObject *call_result;
         if (vertex == 0) {
           Py_DECREF(result);
           igraph_vector_destroy(&v);
           return NULL;
         }
         call_result = PyObject_CallFunctionObjArgs(item, vertex, NULL);
         if (call_result == 0) {
           Py_DECREF(vertex); Py_DECREF(result);
           igraph_vector_destroy(&v);
           return NULL;
         }
-        if (PyObject_IsTrue(call_result))
+        if (PyObject_IsTrue(call_result)) {
           igraph_vector_push_back(&v,
             igraphmodule_Vertex_get_index_long((igraphmodule_VertexObject*)vertex));
-        else was_excluded=1;
+        } else {
+          was_excluded = 1;
+        }
         Py_DECREF(call_result);
         Py_DECREF(vertex);
       }
 
       if (was_excluded) {
         igraph_vs_destroy(&result->vs);
         if (igraph_vs_vector_copy(&result->vs, &v)) {
@@ -651,168 +657,211 @@
       igraph_vector_destroy(&v);
     } else if (PyLong_Check(item)) {
       /* Integers are treated specially: from now on, all remaining items
        * in the argument list must be integers and they will be used together
        * to restrict the vertex set. Integers are interpreted as indices on the
        * vertex set and NOT on the original, untouched vertex sequence of the
        * graph */
-      igraph_vector_t v, v2;
       if (igraph_vector_init(&v, 0)) {
         igraphmodule_handle_igraph_error();
         return 0;
       }
-      if (igraph_vector_init(&v2, 0)) {
-        igraph_vector_destroy(&v);
-        igraphmodule_handle_igraph_error();
-        return 0;
-      }
-      if (igraph_vs_as_vector(&gr->g, self->vs, &v2)) {
-        igraph_vector_destroy(&v);
-        igraph_vector_destroy(&v2);
-        igraphmodule_handle_igraph_error();
-        return 0;
+
+      if (!working_on_whole_graph) {
+        /* Extract the current vertex sequence into a vector */
+        if (igraph_vector_init(&v2, 0)) {
+          igraph_vector_destroy(&v);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        if (igraph_vs_as_vector(&gr->g, self->vs, &v2)) {
+          igraph_vector_destroy(&v);
+          igraph_vector_destroy(&v2);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        m = igraph_vector_size(&v2);
+      } else {
+        /* v2 left uninitialized, we are not going to use it as it would
+         * simply contain integers from 0 to vcount(g)-1 */
+        m = igraph_vcount(&gr->g);
       }
-      m = igraph_vector_size(&v2);
-      for (; i<n; i++) {
+
+      for (; i < n; i++) {
         PyObject *item2 = PyTuple_GET_ITEM(args, i);
         long idx;
         if (!PyLong_Check(item2)) {
           Py_DECREF(result);
           PyErr_SetString(PyExc_TypeError, "vertex indices expected");
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           return NULL;
         }
         idx = PyLong_AsLong(item2);
         if (idx >= m || idx < 0) {
           PyErr_SetString(PyExc_ValueError, "vertex index out of range");
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           return NULL;
         }
-        if (igraph_vector_push_back(&v, VECTOR(v2)[idx])) {
+        if (igraph_vector_push_back(&v, working_on_whole_graph ? idx : VECTOR(v2)[idx])) {
           Py_DECREF(result);
           igraphmodule_handle_igraph_error();
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           return NULL;
         }
       }
-      igraph_vector_destroy(&v2);
+
+      if (!working_on_whole_graph) {
+        igraph_vector_destroy(&v2);
+      }
+
       igraph_vs_destroy(&result->vs);
+
       if (igraph_vs_vector_copy(&result->vs, &v)) {
         Py_DECREF(result);
         igraphmodule_handle_igraph_error();
         igraph_vector_destroy(&v);
         return NULL;
       }
+
       igraph_vector_destroy(&v);
     } else {
       /* Iterators, slices and everything that was not handled directly */
       PyObject *iter=0, *item2;
-      igraph_vector_t v, v2;
 
       /* Allocate stuff */
       if (igraph_vector_init(&v, 0)) {
         igraphmodule_handle_igraph_error();
         Py_DECREF(result);
         return 0;
       }
-      if (igraph_vector_init(&v2, 0)) {
-        igraph_vector_destroy(&v);
-        Py_DECREF(result);
-        igraphmodule_handle_igraph_error();
-        return 0;
-      }
-      if (igraph_vs_as_vector(&gr->g, self->vs, &v2)) {
-        igraph_vector_destroy(&v);
-        igraph_vector_destroy(&v2);
-        Py_DECREF(result);
-        igraphmodule_handle_igraph_error();
-        return 0;
+
+      if (!working_on_whole_graph) {
+        /* Extract the current vertex sequence into a vector */
+        if (igraph_vector_init(&v2, 0)) {
+          igraph_vector_destroy(&v);
+          Py_DECREF(result);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        if (igraph_vs_as_vector(&gr->g, self->vs, &v2)) {
+          igraph_vector_destroy(&v);
+          igraph_vector_destroy(&v2);
+          Py_DECREF(result);
+          igraphmodule_handle_igraph_error();
+          return 0;
+        }
+        m = igraph_vector_size(&v2);
+      } else {
+        /* v2 left uninitialized, we are not going to use it as it would
+         * simply contain integers from 0 to vcount(g)-1 */
+        m = igraph_vcount(&gr->g);
       }
-      m = igraph_vector_size(&v2);
 
       /* Create an appropriate iterator */
       if (PySlice_Check(item)) {
         /* Create an iterator from the slice (which is not iterable by default) */
         Py_ssize_t start, stop, step, sl;
         PyObject* range;
         igraph_bool_t ok;
 
-        ok = (PySlice_GetIndicesEx(item, igraph_vector_size(&v2), &start, &stop, &step, &sl) == 0);
+        ok = (PySlice_GetIndicesEx(item, m, &start, &stop, &step, &sl) == 0);
         if (ok) {
           range = igraphmodule_PyRange_create(start, stop, step);
           ok = (range != 0);
         }
         if (ok) {
           iter = PyObject_GetIter(range);
           Py_DECREF(range);
           ok = (iter != 0);
         }
         if (!ok) {
           igraph_vector_destroy(&v);
-          igraph_vector_destroy(&v2);
+          if (!working_on_whole_graph) {
+            igraph_vector_destroy(&v2);
+          }
           PyErr_SetString(PyExc_TypeError, "error while converting slice to iterator");
           Py_DECREF(result);
           return 0;
         }
       } else {
         /* Simply create the iterator corresponding to the object */
         iter = PyObject_GetIter(item);
       }
 
       /* Did we manage to get an iterator? */
       if (iter == 0) {
         igraph_vector_destroy(&v);
-        igraph_vector_destroy(&v2);
+        if (!working_on_whole_graph) {
+          igraph_vector_destroy(&v2);
+        }
         PyErr_SetString(PyExc_TypeError, "invalid vertex filter among positional arguments");
         Py_DECREF(result);
         return 0;
       }
+
       /* Do the iteration */
-      while ((item2=PyIter_Next(iter)) != 0) {
+      while ((item2 = PyIter_Next(iter)) != 0) {
         if (igraphmodule_PyObject_to_integer_t(item2, &igraph_idx)) {
           /* We simply ignore elements that we don't know */
           Py_DECREF(item2);
         } else {
           Py_DECREF(item2);
           if (igraph_idx >= m || igraph_idx < 0) {
             PyErr_SetString(PyExc_ValueError, "vertex index out of range");
             Py_DECREF(result);
             Py_DECREF(iter);
             igraph_vector_destroy(&v);
-            igraph_vector_destroy(&v2);
+            if (!working_on_whole_graph) {
+              igraph_vector_destroy(&v2);
+            }
             return NULL;
           }
-          if (igraph_vector_push_back(&v, VECTOR(v2)[(long int) igraph_idx])) {
+          if (igraph_vector_push_back(&v, working_on_whole_graph ? igraph_idx : VECTOR(v2)[(long int) igraph_idx])) {
             Py_DECREF(result);
             Py_DECREF(iter);
             igraphmodule_handle_igraph_error();
             igraph_vector_destroy(&v);
-            igraph_vector_destroy(&v2);
+            if (!working_on_whole_graph) {
+              igraph_vector_destroy(&v2);
+            }
             return NULL;
           }
         }
       }
+
       /* Deallocate stuff */
-      igraph_vector_destroy(&v2);
+      if (!working_on_whole_graph) {
+        igraph_vector_destroy(&v2);
+      }
+
       Py_DECREF(iter);
       if (PyErr_Occurred()) {
         igraph_vector_destroy(&v);
         Py_DECREF(result);
         return 0;
       }
+
       igraph_vs_destroy(&result->vs);
+
       if (igraph_vs_vector_copy(&result->vs, &v)) {
         Py_DECREF(result);
         igraphmodule_handle_igraph_error();
         igraph_vector_destroy(&v);
         return NULL;
       }
+
       igraph_vector_destroy(&v);
     }
   }
 
   return (PyObject*)result;
 }
```

### Comparing `igraph-0.9.8/src/_igraph/vertexseqobject.h` & `igraph-0.9.9/src/_igraph/vertexseqobject.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/__init__.py` & `igraph-0.9.9/src/igraph/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -2296,27 +2296,27 @@
         graph, source, target, cap = super().Read_DIMACS(f, directed)
         graph.es["capacity"] = cap
         graph["source"] = source
         graph["target"] = target
         return graph
 
     @classmethod
-    def Read_GraphMLz(cls, f, directed=True, index=0):
+    def Read_GraphMLz(cls, f, index=0):
         """Reads a graph from a zipped GraphML file.
 
         @param f: the name of the file
         @param index: if the GraphML file contains multiple graphs,
           specified the one that should be loaded. Graph indices
           start from zero, so if you want to load the first graph,
           specify 0 here.
         @return: the loaded graph object"""
         with named_temporary_file() as tmpfile:
             with open(tmpfile, "wb") as outf:
                 copyfileobj(gzip.GzipFile(f, "rb"), outf)
-            return cls.Read_GraphML(tmpfile, directed=directed, index=index)
+            return cls.Read_GraphML(tmpfile, index=index)
 
     def write_pickle(self, fname=None, version=-1):
         """Saves the graph in Python pickled format
 
         @param fname: the name of the file or a stream to save to. If
           C{None}, saves the graph to a string and returns the string.
         @param version: pickle protocol version to be used. If -1, uses
@@ -2645,16 +2645,16 @@
         for eidx, edge in enumerate(self.es):
             vidxs = edge.tuple
             x1 = layout[vidxs[0]][0]
             y1 = layout[vidxs[0]][1]
             x2 = layout[vidxs[1]][0]
             y2 = layout[vidxs[1]][1]
             angle = math.atan2(y2 - y1, x2 - x1)
-            x2 = x2 - vertex_size * math.cos(angle)
-            y2 = y2 - vertex_size * math.sin(angle)
+            x2 -= vertex_size * math.cos(angle)
+            y2 -= vertex_size * math.sin(angle)
 
             print("<path", file=f)
             print(
                 '    style="fill:none;stroke:{0};stroke-width:{2};'
                 'stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;'
                 'stroke-opacity:1;stroke-dasharray:none{1}"'.format(
                     edge_colors[eidx],
@@ -4539,15 +4539,15 @@
             "eq": operator.eq,
             "ne": operator.ne,
             "in": lambda a, b: a in b,
             "notin": lambda a, b: a not in b,
         }
         for keyword, value in kwds.items():
             if "_" not in keyword or keyword.rindex("_") == 0:
-                keyword = keyword + "_eq"
+                keyword += "_eq"
             attr, _, op = keyword.rpartition("_")
             try:
                 func = operators[op]
             except KeyError:
                 # No such operator, assume that it's part of the attribute name
                 attr, op, func = keyword, "eq", operators["eq"]
 
@@ -4843,15 +4843,15 @@
         # others; for instance, we have optimized code paths for _source and
         # _target in directed and undirected graphs if es.is_all() is True;
         # these should be executed first. This matters only if there are
         # multiple keyword arguments and es.is_all() is True.
 
         for keyword, value in kwds.items():
             if "_" not in keyword or keyword.rindex("_") == 0:
-                keyword = keyword + "_eq"
+                keyword += "_eq"
             pos = keyword.rindex("_")
             attr, op = keyword[0:pos], keyword[pos + 1 :]
             try:
                 func = operators[op]
             except KeyError:
                 # No such operator, assume that it's part of the attribute name
                 attr, op, func = keyword, "eq", operators["eq"]
@@ -5285,8 +5285,12 @@
     return graph.write(filename, *args, **kwds)
 
 
 save = write
 
 
 config = init_configuration()
+"""The main configuration object of igraph. Use this object to modify igraph's
+behaviour, typically when used in interactive mode.
+"""
+
 del construct_graph_from_formula
```

### Comparing `igraph-0.9.8/src/igraph/app/shell.py` & `igraph-0.9.9/src/igraph/app/shell.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/clustering.py` & `igraph-0.9.9/src/igraph/clustering.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/configuration.py` & `igraph-0.9.9/src/igraph/configuration.py`

 * *Files 1% similar despite different names*

```diff
@@ -84,14 +84,22 @@
         # Unknown system
         return ""
 
 
 class Configuration:
     """Class representing igraph configuration details.
 
+    Note that there is one primary instance of this class, which is used by
+    igraph itself to retrieve configuration parameters when needed. You can
+    access this instance with the L{instance()} method. You I{may} construct
+    other instances by invoking the constructor directly, but these instances
+    will I{not} affect igraph's behaviour. If you are interested in configuring
+    igraph, use L{igraph.config} to get hold of the singleton instance and then
+    modify it.
+
     General ideas
     =============
 
     The configuration of igraph is stored in the form of name-value pairs.
     This object provides an interface to the configuration data using the
     syntax known from dict:
```

### Comparing `igraph-0.9.8/src/igraph/cut.py` & `igraph-0.9.9/src/igraph/cut.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/datatypes.py` & `igraph-0.9.9/src/igraph/datatypes.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/__init__.py` & `igraph-0.9.9/src/igraph/drawing/__init__.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/baseclasses.py` & `igraph-0.9.9/src/igraph/drawing/baseclasses.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/colors.py` & `igraph-0.9.9/src/igraph/drawing/colors.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/coord.py` & `igraph-0.9.9/src/igraph/drawing/coord.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/edge.py` & `igraph-0.9.9/src/igraph/drawing/edge.py`

 * *Files 7% similar despite different names*

```diff
@@ -10,20 +10,19 @@
     "LightToDarkEdgeDrawer",
     "TaperedEdgeDrawer",
 )
 
 from igraph.drawing.colors import clamp
 from igraph.drawing.metamagic import AttributeCollectorBase
 from igraph.drawing.text import TextAlignment
-from igraph.drawing.utils import find_cairo
+from igraph.drawing.utils import evaluate_cubic_bezier_curve, find_cairo, get_bezier_control_points_for_curved_edge
 from math import atan2, cos, pi, sin, sqrt
 
 cairo = find_cairo()
 
-
 class AbstractEdgeDrawer:
     """Abstract edge drawer object from which all concrete edge drawer
     implementations are derived."""
 
     def __init__(self, context, palette):
         """Constructs the edge drawer.
 
@@ -116,20 +115,17 @@
         ctx = self.context
         ctx.set_source_rgba(*edge.color)
         ctx.set_line_width(edge.width)
         ctx.move_to(*src_vertex.position)
 
         if edge.curved:
             (x1, y1), (x2, y2) = src_vertex.position, dest_vertex.position
-            aux1 = (2 * x1 + x2) / 3.0 - edge.curved * 0.5 * (y2 - y1), (
-                2 * y1 + y2
-            ) / 3.0 + edge.curved * 0.5 * (x2 - x1)
-            aux2 = (x1 + 2 * x2) / 3.0 - edge.curved * 0.5 * (y2 - y1), (
-                y1 + 2 * y2
-            ) / 3.0 + edge.curved * 0.5 * (x2 - x1)
+
+            aux1, aux2 = get_bezier_control_points_for_curved_edge(x1, y1, x2, y2, edge['curved'])
+
             ctx.curve_to(aux1[0], aux1[1], aux2[0], aux2[1], *dest_vertex.position)
         else:
             ctx.line_to(*dest_vertex.position)
 
         ctx.stroke()
 
     def get_label_position(self, edge, src_vertex, dest_vertex):
@@ -154,19 +150,25 @@
         dy = dest_vertex.position[1] - src_vertex.position[1]
         if dx != 0 or dy != 0:
             # Note that we use -dy because the Y axis points downwards
             angle = atan2(-dy, dx) % (2 * pi)
         else:
             angle = None
 
+
         # Determine the midpoint
-        pos = (
-            (src_vertex.position[0] + dest_vertex.position[0]) / 2.0,
-            (src_vertex.position[1] + dest_vertex.position[1]) / 2,
-        )
+        if edge['curved']:
+            (x1, y1), (x2, y2) = src_vertex.position, dest_vertex.position
+            aux1, aux2 = get_bezier_control_points_for_curved_edge(x1, y1, x2, y2, edge['curved'])
+            pos = evaluate_cubic_bezier_curve(x1, y1, *aux1, *aux2, x2, y2, .5)
+        else:
+            pos = (
+                (src_vertex.position[0] + dest_vertex.position[0]) / 2.0,
+                (src_vertex.position[1] + dest_vertex.position[1]) / 2,
+            )
 
         # Determine the alignment based on the angle
         pi4 = pi / 4
         if angle is None:
             halign, valign = TextAlignment.CENTER, TextAlignment.CENTER
         else:
             index = int((angle / pi4) % 8)
@@ -269,20 +271,15 @@
         # Draw the edge
         ctx.set_source_rgba(*edge.color)
         ctx.set_line_width(edge.width)
         ctx.move_to(x1, y1)
 
         if edge.curved:
             # Calculate the curve
-            aux1 = (2 * x1 + x2) / 3.0 - edge.curved * 0.5 * (y2 - y1), (
-                2 * y1 + y2
-            ) / 3.0 + edge.curved * 0.5 * (x2 - x1)
-            aux2 = (x1 + 2 * x2) / 3.0 - edge.curved * 0.5 * (y2 - y1), (
-                y1 + 2 * y2
-            ) / 3.0 + edge.curved * 0.5 * (x2 - x1)
+            aux1, aux2 = get_bezier_control_points_for_curved_edge(x1, x2, y1, y2, edge.curved)
 
             # Coordinates of the control points of the Bezier curve
             xc1, yc1 = aux1
             xc2, yc2 = aux2
 
             # Determine where the edge intersects the circumference of the
             # vertex shape: Tip of the arrow
```

### Comparing `igraph-0.9.8/src/igraph/drawing/graph.py` & `igraph-0.9.9/src/igraph/drawing/graph.py`

 * *Files 1% similar despite different names*

```diff
@@ -989,15 +989,15 @@
         # Deferred import to avoid a cycle in the import graph
         from igraph.clustering import VertexClustering, VertexCover
 
         def shrink_vertex(ax, aux, vcoord, vsize_squared):
             """Shrink edge by vertex size"""
             aux_display, vcoord_display = ax.transData.transform([aux, vcoord])
             d = sqrt(((aux_display - vcoord_display) ** 2).sum())
-            fr = sqrt(vsize_squared) / d
+            fr = sqrt(vsize_squared) / d if d > 0 else 0
             end_display = vcoord_display + fr * (aux_display - vcoord_display)
             end = ax.transData.inverted().transform(end_display)
             return end
 
         def callback_factory(ax, vcoord, vsizes, arrows):
             def callback_edge_offset(event):
                 for arrow, src, tgt in arrows:
@@ -1174,18 +1174,27 @@
 
         # Vertex labels
         if label is not None:
             for i, lab in enumerate(label):
                 xi, yi = x[i], y[i]
                 ax.text(xi, yi, lab, fontsize=label_size)
 
-        dx = max(x) - min(x)
-        dy = max(y) - min(y)
-        ax.set_xlim(min(x) - 0.05 * dx, max(x) + 0.05 * dx)
-        ax.set_ylim(min(y) - 0.05 * dy, max(y) + 0.05 * dy)
+        # Find the X and Y range of coordinates; use a minimum range even if there
+        # is only one vertex to avoid singularities and division by zero later
+        dx, dy = max(x) - min(x), max(y) - min(y)
+        if dx <= 0:
+            dx = 1
+            ax.set_xlim(min(x) - dx / 2, max(x) + dx / 2)
+        else:
+            ax.set_xlim(min(x) - 0.05 * dx, max(x) + 0.05 * dx)
+        if dy <= 0:
+            dy = 1
+            ax.set_ylim(min(y) - dy / 2, max(y) + dy / 2)
+        else:
+            ax.set_ylim(min(y) - 0.05 * dy, max(y) + 0.05 * dy)
 
         # Edge properties
         ne = graph.ecount()
         ec = kwds.get("edge_color", "black")
         edge_width = kwds.get("edge_width", 1)
         arrow_width = kwds.get("edge_arrow_width", 2)
         arrow_length = kwds.get("edge_arrow_size", 4)
```

### Comparing `igraph-0.9.8/src/igraph/drawing/metamagic.py` & `igraph-0.9.9/src/igraph/drawing/metamagic.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/shapes.py` & `igraph-0.9.9/src/igraph/drawing/shapes.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/text.py` & `igraph-0.9.9/src/igraph/drawing/text.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/drawing/utils.py` & `igraph-0.9.9/src/igraph/drawing/utils.py`

 * *Files 6% similar despite different names*

```diff
@@ -595,7 +595,43 @@
         """Constructs a point from polar coordinates.
 
         `radius` is the distance of the point from the origin; `angle` is the
         angle between the X axis and the vector pointing to the point from
         the origin.
         """
         return cls(radius * cos(angle), radius * sin(angle))
+
+
+def evaluate_cubic_bezier_curve(x0, y0, x1, y1, x2, y2, x3, y3, t):
+    """Evaluates the Bezier curve from point (x0,y0) to (x3,y3) via control points
+    (x1,y1) and (x2,y2) with parameter t.
+    """
+    xt = (
+        (1.0 - t) ** 3 * x0
+        + 3.0 * t * (1.0 - t) ** 2 * x1
+        + 3.0 * t ** 2 * (1.0 - t) * x2
+        + t ** 3 * x3
+    )
+    yt = (
+        (1.0 - t) ** 3 * y0
+        + 3.0 * t * (1.0 - t) ** 2 * y1
+        + 3.0 * t ** 2 * (1.0 - t) * y2
+        + t ** 3 * y3
+    )
+    return xt, yt
+
+
+def get_bezier_control_points_for_curved_edge(x1, y1, x2, y2, curvature):
+    """Helper function that calculates the Bezier control points for a
+    curved edge that goes from (x1, y1) to (x2, y2).
+    """
+    aux1 = (2 * x1 + x2) / 3.0 - curvature * 0.5 * (y2 - y1), (
+        2 * y1 + y2
+    ) / 3.0 + curvature * 0.5 * (x2 - x1)
+   
+    aux2 = (x1 + 2 * x2) / 3.0 - curvature * 0.5 * (y2 - y1), (
+        y1 + 2 * y2
+    ) / 3.0 + curvature * 0.5 * (x2 - x1)
+   
+    return aux1, aux2
+
+
```

### Comparing `igraph-0.9.8/src/igraph/drawing/vertex.py` & `igraph-0.9.9/src/igraph/drawing/vertex.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/formula.py` & `igraph-0.9.9/src/igraph/formula.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/layout.py` & `igraph-0.9.9/src/igraph/layout.py`

 * *Files 1% similar despite different names*

```diff
@@ -185,15 +185,15 @@
         scaling = kwds.get("scale") or args
         if isinstance(scaling, (int, float)):
             scaling = [scaling]
         if len(scaling) == 0:
             raise ValueError("scaling factor must be given")
         elif len(scaling) == 1:
             if type(scaling[0]) == int or type(scaling[0]) == float:
-                scaling = scaling * self._dim
+                scaling *= self._dim
             else:
                 scaling = scaling[0]
         if len(scaling) != self._dim:
             raise ValueError("scaling factor list must have %d elements" % self._dim)
 
         for idx, row in enumerate(self._coords):
             self._coords[idx] = [
```

### Comparing `igraph-0.9.8/src/igraph/matching.py` & `igraph-0.9.9/src/igraph/matching.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/operators.py` & `igraph-0.9.9/src/igraph/operators.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/remote/gephi.py` & `igraph-0.9.9/src/igraph/remote/gephi.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/sparse_matrix.py` & `igraph-0.9.9/src/igraph/sparse_matrix.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/statistics.py` & `igraph-0.9.9/src/igraph/statistics.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/summary.py` & `igraph-0.9.9/src/igraph/summary.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/src/igraph/utils.py` & `igraph-0.9.9/src/igraph/utils.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_atlas.py` & `igraph-0.9.9/tests/test_atlas.py`

 * *Files 6% similar despite different names*

```diff
@@ -34,17 +34,14 @@
     def testEigenvectorCentrality(self):
         # Temporarily turn off the warning handler because g.evcent() will print
         # a warning for DAGs
         warnings.simplefilter("ignore")
 
         try:
             for idx, g in enumerate(self.__class__.graphs):
-                if idx in self.__class__.skip_graphs:
-                    # Skip this graph; it causes lots of problems and I don't know why
-                    continue
 
                 try:
                     ec, eval = g.evcent(return_eigenvalue=True)
                 except Exception as ex:
                     self.assertTrue(
                         False,
                         msg="Eigenvector centrality threw exception for graph #%d: %s"
@@ -152,22 +149,26 @@
                 min(sc) >= 0,
                 msg="Minimum authority score is less than 0 for graph #%d" % idx,
             )
 
 
 class GraphAtlasTests(unittest.TestCase, AtlasTestBase):
     graphs = [Graph.Atlas(i) for i in range(1253)]
-    skip_graphs = set([180])
 
+# Skip some problematic graphs
+GraphAtlasTests.graphs = [g for idx, g in enumerate(GraphAtlasTests.graphs) if idx not in set([70, 180])]
+print(len(GraphAtlasTests.graphs))
 
 class IsoclassTests(unittest.TestCase, AtlasTestBase):
     graphs = [Graph.Isoclass(3, i, directed=True) for i in range(16)] + [
         Graph.Isoclass(4, i, directed=True) for i in range(218)
     ]
-    skip_graphs = set([136])
+
+# Skip some problematic graphs
+IsoclassTests.graphs = [g for idx, g in enumerate(IsoclassTests.graphs) if idx not in set([136])]
 
 
 def suite():
     atlas_suite = unittest.makeSuite(GraphAtlasTests)
     isoclass_suite = unittest.makeSuite(IsoclassTests)
     return unittest.TestSuite([atlas_suite, isoclass_suite])
```

### Comparing `igraph-0.9.8/tests/test_attributes.py` & `igraph-0.9.9/tests/test_attributes.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_basic.py` & `igraph-0.9.9/tests/test_basic.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_bipartite.py` & `igraph-0.9.9/tests/test_bipartite.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_cliques.py` & `igraph-0.9.9/tests/test_cliques.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_colortests.py` & `igraph-0.9.9/tests/test_colortests.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_conversion.py` & `igraph-0.9.9/tests/test_conversion.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_decomposition.py` & `igraph-0.9.9/tests/test_decomposition.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_edgeseq.py` & `igraph-0.9.9/tests/test_edgeseq.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_flow.py` & `igraph-0.9.9/tests/test_flow.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_foreign.py` & `igraph-0.9.9/tests/test_foreign.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+import gzip
 import io
 import unittest
 import warnings
 
 from igraph import Graph, InternalError
 
 from .utils import temporary_file
@@ -18,14 +19,59 @@
 
 try:
     import pandas as pd
 except ImportError:
     pd = None
 
 
+GRAPHML_EXAMPLE_FILE = """\
+<?xml version="1.0" encoding="UTF-8"?>
+<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
+        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
+        http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
+<!-- Created by igraph -->
+<key id="v_name" for="node" attr.name="name" attr.type="string"/>
+<graph id="G" edgedefault="undirected">
+    <node id="n0">
+    <data key="v_name">a</data>
+    </node>
+    <node id="n1">
+    <data key="v_name">b</data>
+    </node>
+    <node id="n2">
+    <data key="v_name">c</data>
+    </node>
+    <node id="n3">
+    <data key="v_name">d</data>
+    </node>
+    <node id="n4">
+    <data key="v_name">e</data>
+    </node>
+    <node id="n5">
+    <data key="v_name">f</data>
+    </node>
+    <edge source="n0" target="n1">
+    </edge>
+    <edge source="n0" target="n2">
+    </edge>
+    <edge source="n0" target="n3">
+    </edge>
+    <edge source="n1" target="n2">
+    </edge>
+    <edge source="n3" target="n4">
+    </edge>
+    <edge source="n3" target="n5">
+    </edge>
+    <edge source="n4" target="n5">
+    </edge>
+</graph>
+</graphml>
+"""
+
 class ForeignTests(unittest.TestCase):
     def testDIMACS(self):
         with temporary_file(
             """\
         c
         c        This is a simple example file to demonstrate the
         c     DIMACS input file format for minimum-cost flow problems.
@@ -298,73 +344,41 @@
                 and g.is_directed()
                 and g.es["weight"] == [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2]
             )
 
             g.write_adjacency(tmpfname)
 
     def testGraphML(self):
-        with temporary_file(
-            """\
-            <?xml version="1.0" encoding="UTF-8"?>
-            <graphml xmlns="http://graphml.graphdrawing.org/xmlns"
-                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-                    xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns
-                    http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
-            <!-- Created by igraph -->
-            <key id="v_name" for="node" attr.name="name" attr.type="string"/>
-            <graph id="G" edgedefault="undirected">
-                <node id="n0">
-                <data key="v_name">a</data>
-                </node>
-                <node id="n1">
-                <data key="v_name">b</data>
-                </node>
-                <node id="n2">
-                <data key="v_name">c</data>
-                </node>
-                <node id="n3">
-                <data key="v_name">d</data>
-                </node>
-                <node id="n4">
-                <data key="v_name">e</data>
-                </node>
-                <node id="n5">
-                <data key="v_name">f</data>
-                </node>
-                <edge source="n0" target="n1">
-                </edge>
-                <edge source="n0" target="n2">
-                </edge>
-                <edge source="n0" target="n3">
-                </edge>
-                <edge source="n1" target="n2">
-                </edge>
-                <edge source="n3" target="n4">
-                </edge>
-                <edge source="n3" target="n5">
-                </edge>
-                <edge source="n4" target="n5">
-                </edge>
-            </graph>
-            </graphml>
-        """
-        ) as tmpfname:
+        with temporary_file(GRAPHML_EXAMPLE_FILE) as tmpfname:
             try:
                 g = Graph.Read_GraphML(tmpfname)
             except NotImplementedError as e:
                 self.skipTest(str(e))
 
             self.assertTrue(isinstance(g, Graph))
             self.assertEqual(g.vcount(), 6)
             self.assertEqual(g.ecount(), 7)
             self.assertFalse(g.is_directed())
             self.assertTrue("name" in g.vertex_attributes())
 
             g.write_graphml(tmpfname)
 
+    def testGraphMLz(self):
+        with temporary_file(gzip.compress(GRAPHML_EXAMPLE_FILE.encode("utf-8"))) as tmpfname:
+            try:
+                g = Graph.Read_GraphMLz(tmpfname)
+            except NotImplementedError as e:
+                self.skipTest(str(e))
+
+            self.assertTrue(isinstance(g, Graph))
+            self.assertEqual(g.vcount(), 6)
+            self.assertEqual(g.ecount(), 7)
+            self.assertFalse(g.is_directed())
+            self.assertTrue("name" in g.vertex_attributes())
+
     def testPickle(self):
         pickle = [
             128,
             2,
             99,
             105,
             103,
```

### Comparing `igraph-0.9.8/tests/test_games.py` & `igraph-0.9.9/tests/test_games.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_generators.py` & `igraph-0.9.9/tests/test_generators.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_homepage.py` & `igraph-0.9.9/tests/test_homepage.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_indexing.py` & `igraph-0.9.9/tests/test_indexing.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_isomorphism.py` & `igraph-0.9.9/tests/test_isomorphism.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_iterators.py` & `igraph-0.9.9/tests/test_iterators.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_layouts.py` & `igraph-0.9.9/tests/test_layouts.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_matching.py` & `igraph-0.9.9/tests/test_matching.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_operators.py` & `igraph-0.9.9/tests/test_operators.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_rng.py` & `igraph-0.9.9/tests/test_rng.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_separators.py` & `igraph-0.9.9/tests/test_separators.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_spectral.py` & `igraph-0.9.9/tests/test_spectral.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_structural.py` & `igraph-0.9.9/tests/test_structural.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_unicode_issues.py` & `igraph-0.9.9/tests/test_unicode_issues.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_vertexseq.py` & `igraph-0.9.9/tests/test_vertexseq.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/test_walks.py` & `igraph-0.9.9/tests/test_walks.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/tests/utils.py` & `igraph-0.9.9/tests/utils.py`

 * *Files 20% similar despite different names*

```diff
@@ -26,11 +26,17 @@
         if hasattr(content, "encode") and not binary:
             tmpf.write(dedent(content).encode("utf8"))
         else:
             tmpf.write(content)
 
     tmpf.close()
     yield tmpfname
-    os.unlink(tmpfname)
+    try:
+        os.unlink(tmpfname)
+    except Exception:
+        # ignore exceptions; it happens sometimes on Windows in the CI environment
+        # that it cannot remove the temporary file because another process (?) is
+        # using it...
+        pass
 
 
 is_pypy = platform.python_implementation() == "PyPy"
```

### Comparing `igraph-0.9.8/vendor/source/igraph/.astylerc` & `igraph-0.9.9/vendor/source/igraph/.astylerc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/.azure/build-win.yml` & `igraph-0.9.9/vendor/source/igraph/.azure/build-win.yml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/.azure/build.yml` & `igraph-0.9.9/vendor/source/igraph/.azure/build.yml`

 * *Files 2% similar despite different names*

```diff
@@ -67,12 +67,12 @@
       key: 'ccache | "$(Agent.OS)"'
       path: $(CCACHE_DIR)
     displayName: Ccache
 
   - task: CMake@1
     displayName: Build
     inputs:
-      cmakeArgs: '--build . --target build_tests'
+      cmakeArgs: '--build . --target build_tests --target build_benchmarks'
 
   # TODO: use -j `nproc` on Linux , -j `sysctl -n hw.ncpu` on Darwin
   - script: cd build && ctest -j 4 --output-on-failure ${{ parameters.extra_ctest_args }} --timeout 60
     displayName: Test
```

### Comparing `igraph-0.9.8/vendor/source/igraph/.github/stale.yml` & `igraph-0.9.9/vendor/source/igraph/.github/stale.yml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/.github/workflows/build-cmake.yml` & `igraph-0.9.9/vendor/source/igraph/.github/workflows/build-cmake.yml`

 * *Files 14% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 jobs:
   build:
     runs-on: windows-latest
     strategy:
       fail-fast: false
       matrix:
         arch: ['i686', 'x86_64', 'ucrt-x86_64']
-        shared_libs: ['ON', 'OFF']
+        shared_libs: ['shared', 'static']
         include:
           - arch: i686
             msystem: MINGW32
           - arch: x86_64
             msystem: MINGW64
           - arch: ucrt-x86_64
             msystem: UCRT64
@@ -42,15 +42,15 @@
         with:
           fetch-depth: 0
 
       - name: Configuration
         run: |
           mkdir -p build-${{ matrix.arch }}
           cd build-${{ matrix.arch }}
-          cmake .. -GNinja -DBUILD_SHARED_LIBS=${{ matrix.shared_libs }} -DIGRAPH_GLPK_SUPPORT=ON -DIGRAPH_GRAPHML_SUPPORT=ON -DIGRAPH_ENABLE_TLS=ON -DIGRAPH_VERIFY_FINALLY_STACK=ON -DBLA_VENDOR=Generic -DIGRAPH_PRINT_ARITH_HEADER=ON
+          cmake .. -GNinja -DBUILD_SHARED_LIBS=${{ matrix.shared_libs == 'shared' && 'ON' || 'OFF' }} -DIGRAPH_GLPK_SUPPORT=ON -DIGRAPH_GRAPHML_SUPPORT=ON -DIGRAPH_ENABLE_TLS=ON -DIGRAPH_VERIFY_FINALLY_STACK=ON -DBLA_VENDOR=Generic -DIGRAPH_PRINT_ARITH_HEADER=ON -DIGRAPH_USE_INTERNAL_GLPK=ON
 
       - name: Build
         run: cmake --build . --target build_tests
         working-directory: build-${{ matrix.arch }}
       - name: Test
         run: ctest -j $(nproc) --output-on-failure --timeout 180
         working-directory: build-${{ matrix.arch }}
```

### Comparing `igraph-0.9.8/vendor/source/igraph/.github/workflows/codecov.yml` & `igraph-0.9.9/vendor/source/igraph/.github/workflows/codecov.yml`

 * *Files 10% similar despite different names*

```diff
@@ -9,15 +9,16 @@
   build:
     runs-on: ubuntu-latest
 
     steps:
     - name: Install dependencies
       run: sudo apt-get install lcov libglpk-dev libarpack2-dev
 
-    - uses: actions/checkout@v2
+    - name: Checkout
+      uses: actions/checkout@v2
       with:
         fetch-depth: 0
 
     - name: Create build environment
       run: cmake -E make_directory ${{github.workspace}}/build
 
     - name: Configure
```

### Comparing `igraph-0.9.8/vendor/source/igraph/.travis.yml` & `igraph-0.9.9/vendor/source/igraph/.travis.yml`

 * *Files 4% similar despite different names*

```diff
@@ -45,15 +45,15 @@
     - name: cmake
       confinement: classic
 
 # configuration (running cmake) is in before_script
 # if this phase fails, the build stops immediately
 before_script:
   - mkdir build && cd build
-  - cmake .. -DIGRAPH_USE_INTERNAL_BLAS=ON -DIGRAPH_USE_INTERNAL_LAPACK=ON -DIGRAPH_USE_INTERNAL_ARPACK=ON -DIGRAPH_USE_INTERNAL_GLPK=ON -DIGRAPH_USE_INTERNAL_CXSPARSE=ON -DIGRAPH_USE_INTERNAL_GMP=ON -DIGRAPH_VERIFY_FINALLY_STACK=ON -DCMAKE_BUILD_TYPE=Debug -DIGRAPH_ENABLE_LTO=AUTO -DIGRAPH_PRINT_ARITH_HEADER=ON -DUSE_SANITIZER=Address\;Undefined
+  - cmake .. -DIGRAPH_USE_INTERNAL_BLAS=ON -DIGRAPH_USE_INTERNAL_LAPACK=ON -DIGRAPH_USE_INTERNAL_ARPACK=ON -DIGRAPH_USE_INTERNAL_GLPK=ON -DIGRAPH_USE_INTERNAL_CXSPARSE=ON -DIGRAPH_USE_INTERNAL_GMP=ON -DIGRAPH_VERIFY_FINALLY_STACK=ON -DCMAKE_BUILD_TYPE=Debug -DIGRAPH_PRINT_ARITH_HEADER=ON -DUSE_SANITIZER=Address\;Undefined
 
 # building and testing is in script
 # use && to ensure that ctest is not run if the build failed
 script:
   - cmake --build . --target build_tests && ctest --output-on-failure
 
 after_failure:
@@ -69,15 +69,15 @@
       arch: arm64-graviton2 # faster than arm64
 
     - name: "Linux arm64 external"
       os: linux
       arch: arm64-graviton2 # faster than arm64
       before_script:
         - mkdir build && cd build
-        - cmake .. -DIGRAPH_USE_INTERNAL_BLAS=OFF -DIGRAPH_USE_INTERNAL_LAPACK=OFF -DIGRAPH_USE_INTERNAL_ARPACK=OFF -DIGRAPH_USE_INTERNAL_GLPK=OFF -DIGRAPH_USE_INTERNAL_CXSPARSE=OFF -DIGRAPH_USE_INTERNAL_GMP=OFF -DIGRAPH_VERIFY_FINALLY_STACK=ON -DBLA_VENDOR=OpenBLAS -DCMAKE_BUILD_TYPE=Debug -DIGRAPH_ENABLE_LTO=AUTO -DIGRAPH_PRINT_ARITH_HEADER=ON -DUSE_SANITIZER=Address\;Undefined
+        - cmake .. -DIGRAPH_USE_INTERNAL_BLAS=OFF -DIGRAPH_USE_INTERNAL_LAPACK=OFF -DIGRAPH_USE_INTERNAL_ARPACK=OFF -DIGRAPH_USE_INTERNAL_GLPK=OFF -DIGRAPH_USE_INTERNAL_CXSPARSE=OFF -DIGRAPH_USE_INTERNAL_GMP=OFF -DIGRAPH_VERIFY_FINALLY_STACK=ON -DBLA_VENDOR=OpenBLAS -DCMAKE_BUILD_TYPE=Debug -DIGRAPH_PRINT_ARITH_HEADER=ON -DUSE_SANITIZER=Address\;Undefined
 
     - name: "Linux ppc64"
       os: linux
       dist: focal # Snap fails with ppc64 on earlier Ubuntu.
       arch: ppc64le
 
     - name: "Linux s390x"
```

### Comparing `igraph-0.9.8/vendor/source/igraph/ACKNOWLEDGEMENTS.md` & `igraph-0.9.9/vendor/source/igraph/ACKNOWLEDGEMENTS.md`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/CHANGELOG.md` & `igraph-0.9.9/vendor/source/igraph/CHANGELOG.md`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,54 @@
 # igraph C library changelog
 
-## [Unreleased]
+## [0.9.6] - 2022-01-05
+
+### Changed
+
+ - Isomorphism class functions (`igraph_isoclass()`, `igraph_isoclass_subgraph()`,
+   `igraph_isoclass_create`) and motif finder functions (`igraph_motifs_randesu()`,
+   `igraph_motifs_randesu_estimate()`, `igraph_motifs_randesu_callback()`) now
+   support undirected (sub)graphs of sizes 5 and 6. Previsouly only sizes 3 and 4
+   were supported.
+
+### Fixed
+
+ - igraph would not build with MinGW when using the vendored GLPK and enabling TLS.
+ - Removed some uses of `abort()` from vendored libraries, which could unexpectedly
+   shut down the host language of igraph's high-level interfaces.
+ - `igraph_community_label_propagation()` no longer leaves any vertices unlabeled
+   when they were not reachable from any labeled ones, i.e. the returned membership
+   vector is guaranteed not to contain negative values (#1853).
+ - The Kamada-Kawai layout is now interruptible.
+ - The Fruchterman-Reingold layout is now interruptible.
+ - Fixed a bug in `igraph_cmp_epsilon()` that resulted in incorrect results for
+   edge betweenness calculations in certain rare cases with x87 floating point
+   math when LTO was also enabled (#1894).
+ - Weighted clique related functions now fall back to the unweighted variants
+   when a null vertex weight vector is given to them.
+ - `igraph_erdos_renyi_game_(gnm|gnp)` would not produce self-loops for the singleton
+   graph.
+ - Fixed a bug in `igraph_local_efficiency()` that sometimes erroneously
+   reported zero as the local efficiency of a vertex in directed graphs.
+ - `igraph_vector_update()` (and its type-specific variants) did not check for
+   memory allocation failure.
+ - Fixed a potential crash in the GraphML reader that would be triggered by some
+   invalid GraphML files.
+
+### Other
+
+ - `igraph_is_tree()` has improved performance and memory usage.
+ - `igraph_is_connected()` has improved performance when checking weak connectedness.
+ - Improved error handling in `igraph_maximal_cliques()` and related functions.
+ - The build system now checks that GLPK is of a compatible version (4.57 or later).
+ - The vendored `plfit` package was updated to 0.9.3.
+ - You can now build igraph with an external `plfit` instead of the vendored one.
+ - Documentation improvements.
+
+## [0.9.5] - 2021-11-11
 
 ### Fixed
 
  - `igraph_reindex_membership()` does not allow negative membership indices any more.
 
  - `igraph_rewire_directed_edges()` now generates multigraphs when edge directions
    are ignored, to make it consistent with the directed case.
@@ -13,14 +57,39 @@
    tree instead of the cut tree (#1810).
 
  - Fixed a bug in the `IGRAPH_TO_UNDIRECTED_COLLAPSE` mode of
    `igraph_to_undirected()` that provided an incorrect merge vector to the
    attribute handler, leading to problems when edge attributes were merged
    using an attribute combination (#1814).
 
+ - Fixed the behaviour of the `IGRAPH_ENABLE_LTO` option when it was set to
+   `AUTO`; earlier versions had a bug where `AUTO` simply checked whether LTO
+   is supported but then did not use LTO even if it was supported.
+
+ - When using igraph from a CMake project, it is now checked that the project has
+   the C++ language enabled. This is necessary for linking to igraph with CMake.
+
+### Other
+
+ - Improved the root selection method for disconnected graphs in the
+   Reingold-Tilford layout (#1836). The new root selection method provides
+   niceer results if the graph is not a tree, although it is still recommended
+   to use the Sugiyama layout instead, unless the input graph is _almost_ a
+   tree, in which case Reingold-Tilfold may still be preferred.
+
+ - `igraph_decompose()` is now much faster for large graphs containing many
+   isolates or small components (#960).
+
+ - `igraph_largest_cliques()` and `igraph_clique_number()` were re-written to
+   use `igraph_maximal_cliques_callback()` so they are much faster now (#804).
+
+ - The vendored GLPK has been upgraded to GLPK 5.0.
+
+ - Documentation improvements.
+
 ## [0.9.4] - 2021-05-31
 
 ### Changed
 
  - Unweighted transitivity (i.e. clustering coefficient) calculations now ignore multi-edges and edge directions instead of rejecting multigraphs and directed graphs.
  - `igraph_transitivity_barrat()` now returns an error code if the input graph has multiple edges (which is not handled correctly by the implementation yet).
 
@@ -446,15 +515,16 @@
 ### Other
 
  - The [Bliss isomorphism library](http://www.tcs.hut.fi/Software/bliss/) was updated to version 0.73. This version adds support for vertex colored and directed graphs.
  - igraph now uses the high-performance [Cliquer library](https://users.aalto.fi/~pat/cliquer.html) to find (non-maximal) cliques
  - Provide proper support for Windows, using `__declspec(dllexport)` and `__declspec(dllimport)` for `DLL`s and static usage by using `#define IGRAPH_STATIC 1`.
  - Provided integer versions of `dqueue` and `stack` data types.
 
-[Unreleased]: https://github.com/igraph/igraph/compare/0.9.4..HEAD
+[Unreleased]: https://github.com/igraph/igraph/compare/0.9.5..HEAD
+[0.9.5]: https://github.com/igraph/igraph/compare/0.9.4...0.9.5
 [0.9.4]: https://github.com/igraph/igraph/compare/0.9.3...0.9.4
 [0.9.3]: https://github.com/igraph/igraph/compare/0.9.2...0.9.3
 [0.9.2]: https://github.com/igraph/igraph/compare/0.9.1...0.9.2
 [0.9.1]: https://github.com/igraph/igraph/compare/0.9.0...0.9.1
 [0.9.0]: https://github.com/igraph/igraph/compare/0.8.5...0.9.0
 [0.8.5]: https://github.com/igraph/igraph/compare/0.8.4...0.8.5
 [0.8.4]: https://github.com/igraph/igraph/compare/0.8.3...0.8.4
```

### Comparing `igraph-0.9.8/vendor/source/igraph/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/CMakeLists.txt`

 * *Files 11% similar despite different names*

```diff
@@ -68,27 +68,32 @@
 include(dependencies)
 find_dependencies()
 
 # Run compile-time checks, generate config.h and igraph_threading.h
 include(CheckSymbolExists)
 
 # First we check for some functions and symbols
+set(CMAKE_REQUIRED_LIBRARIES_SAVE ${CMAKE_REQUIRED_LIBRARIES})
+if(NEED_LINKING_AGAINST_LIBM)
+  list(APPEND CMAKE_REQUIRED_LIBRARIES m)
+endif()
 check_symbol_exists(expm1 math.h HAVE_EXPM1)
 check_symbol_exists(fmin math.h HAVE_FMIN)
 check_symbol_exists(finite math.h HAVE_FINITE)
 check_symbol_exists(isfinite math.h HAVE_ISFINITE)
 check_symbol_exists(log2 math.h HAVE_LOG2)
 check_symbol_exists(log1p math.h HAVE_LOG1P)
 check_symbol_exists(rint math.h HAVE_RINT)
 check_symbol_exists(rintf math.h HAVE_RINTF)
 check_symbol_exists(round math.h HAVE_ROUND)
 check_symbol_exists(stpcpy string.h HAVE_STPCPY)
 check_symbol_exists(strcasecmp strings.h HAVE_STRCASECMP)
 check_symbol_exists(strdup string.h HAVE_STRDUP)
 check_symbol_exists(_stricmp string.h HAVE__STRICMP)
+set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_SAVE})
 
 # Check for code coverage support
 option(IGRAPH_ENABLE_CODE_COVERAGE "Enable code coverage calculation" OFF)
 if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME AND IGRAPH_ENABLE_CODE_COVERAGE)
   include(CodeCoverage)
   append_coverage_compiler_flags()
   setup_target_for_coverage_lcov(
@@ -122,14 +127,15 @@
   )
 endif()
 
 # Traverse subdirectories. vendor/ should come first because code in
 # src/CMakeLists.txt depends on targets in vendor/
 add_subdirectory(vendor)
 add_subdirectory(src)
+add_subdirectory(interfaces)
 if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME AND BUILD_TESTING)
   add_subdirectory(tests)
 endif()
 if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
   add_subdirectory(doc)
 endif()
```

### Comparing `igraph-0.9.8/vendor/source/igraph/CODE_OF_CONDUCT.md` & `igraph-0.9.9/vendor/source/igraph/CODE_OF_CONDUCT.md`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/CONTRIBUTING.md` & `igraph-0.9.9/vendor/source/igraph/CONTRIBUTING.md`

 * *Files 18% similar despite different names*

```diff
@@ -1,39 +1,45 @@
 # Contributing to this project
 
-Please take a moment to review this document in order to make the contribution
-process easy and effective for everyone involved.
-
-Following these guidelines helps to communicate that you respect the time of
-the developers managing and developing this open source project. In return,
-they should reciprocate that respect in addressing your issue or assessing
-patches and features.
-
+Thank you for being interested in contributing to `igraph`! We need the help of
+volunteers to keep the package going, so every little bit is welcome. You can help out
+the project in several different ways.
+
+This repository only hosts the C code of the `igraph` project. Even if you are not so
+experienced with C, you can contribute in a number of ways:
+
+1. Respond to user questions on our [support forum](https://igraph.discourse.group/).
+2. Correct or improve our [documentation](https://igraph.org/c/html/latest/).
+3. Go over [open issues](https://github.com/igraph/igraph/issues):
+   - Are some older issues still relevant in the most recent version? If not, write a
+     comment to the issue stating that you feel that the issue is not relevant any more.
+   - Can you reproduce some of the bugs that are reported? If so, write a comment to
+     the issue stating that this is still a problem in version X.
+   - Some [issues point out problems with the documentation](https://github.com/igraph/igraph/labels/documentation);
+     perhaps you could help correct these?
+   - Some [issues require clarifying a mathematical problem, or some literature research](https://github.com/igraph/igraph/labels/theory), 
+     before any programming can begin. Can you contribute through your theoretical expertise?
+   - Looking to contribute code? Take a look at some [good first issues](https://github.com/igraph/igraph/labels/good%20first%20issue).
 
 ## Using the issue tracker
 
-The issue tracker is the preferred channel for [bug reports](#bugs),
-[features requests](#features) and [submitting pull
-requests](#pull-requests), but please respect the following restrictions:
-
-* Please **do not** use the issue tracker for personal support requests (use
-  our [igraph support forum](https://igraph.discourse.group)).
+- The issue tracker is the preferred channel for [bug reports](#bugs),
+  [feature requests](#features) and [submitting pull requests](#pull-requests).
 
-* Please **do not** derail or troll issues. Keep the discussion on topic and
-  respect the opinions of others.
-
-Please also take a look at our [tips on writing igraph code](#tips) before
-getting your hands dirty.
+- Do you have a question? Please use our [igraph support forum](https://igraph.discourse.group)
+  for support requests.
 
+- Please keep the discussion on topic and respect the opinions of others, and
+  adhere to our [Code of Conduct](https://igraph.org/code-of-conduct.html).
 
 <a name="bugs"></a>
 ## Bug reports
 
 A bug is a _demonstrable problem_ that is caused by the code in the repository.
-Good bug reports are extremely helpful - thank you!
+Good bug reports are extremely helpful &mdash; thank you for reporting!
 
 Guidelines for bug reports:
 
 1. **Make sure that the bug is in the C code of igraph and not in one of the
    higher level interfaces** &mdash; if you are using igraph from R, Python
    or Mathematica, consider submitting your issue in
    [igraph/rigraph](https://github.com/igraph/rigraph/issues/new),
@@ -48,18 +54,18 @@
 
 3. **Check if the issue has been fixed** &mdash; try to reproduce it using the
    latest `master` or development branch in the repository.
 
 4. **Isolate the problem** &mdash; create a [short, self-contained, correct
    example](http://sscce.org/).
 
-A good bug report shouldn't leave others needing to chase you up for more
-information. Please try to be as detailed as possible in your report. What is
-your environment? What steps will reproduce the issue? What would you expect to
-be the outcome? All these details will help people to fix any potential bugs.
+Please try to be as detailed as possible in your report and provide all
+necessary information. What is your environment? What steps will reproduce the
+issue? What would you expect to be the outcome? All these details will help us
+to fix any potential bugs.
 
 Example:
 
 > Short and descriptive example bug report title
 >
 > A summary of the issue and the compiler/OS environment in which it occurs. If
 > suitable, include the steps required to reproduce the bug.
@@ -75,37 +81,39 @@
 > causing the bug, and potential solutions (and your opinions on their
 > merits).
 
 
 <a name="features"></a>
 ## Feature requests
 
-Feature requests are welcome. But take a moment to find out whether your idea
-fits with the scope and aims of the project. It's up to *you* to make a strong
-case to convince the project's developers of the merits of this feature. Please
-provide as much detail and context as possible.
-
+Feature requests are always welcome. First, take a moment to find out whether your
+idea fits with the scope and aims of the project. Please provide as much detail
+and context as possible, and where possible, references to relevant literature.
+Having said that, implementing new features can be quite time consuming, and as
+such they might not be implemented quickly. In addition, the development team
+might decide not to implement a certain feature. It is up to you to make a case
+to convince the project's developers of the merits of this feature.
 
 <a name="pull-requests"></a>
 ## Pull requests
 
-Good pull requests - patches, improvements, new features - are a fantastic
-help. They should remain focused in scope and avoid containing unrelated
-commits.
+Good pull requests - patches, improvements, new features - are a fantastic help.
+They should remain focused in scope and avoid containing unrelated commits.
+Please also take a look at our [tips on writing igraph code](#tips) before
+getting your hands dirty.
 
 **Please ask first** before embarking on any significant pull request (e.g.
 implementing features, refactoring code, porting to a different language),
 otherwise you risk spending a lot of time working on something that the
 project's developers might not want to merge into the project.
 
 Please adhere to the coding conventions used throughout a project (indentation,
 accurate comments, etc.) and any other requirements (such as test coverage).
 
-Follow this process if you'd like your work considered for inclusion in the
-project:
+Follow the following steps if you would like to make a new pull request:
 
 1. [Fork](http://help.github.com/fork-a-repo/) the project, clone your fork,
    and configure the remotes:
 
    ```bash
    # Clone your fork of the repo into the current directory
    git clone https://github.com/<your-username>/<repo-name>
@@ -128,70 +136,106 @@
 3. Create a new topic branch (off the targeted branch, see
    [branching](#branching) section) to contain your feature, change, or fix:
 
    ```bash
    git checkout -b <topic-branch-name>
    ```
 
-4. Commit your changes in logical chunks. Please adhere to these [git commit
-   message guidelines](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)
-   or your code is unlikely be merged into the main project. Use Git's
-   [interactive rebase](https://help.github.com/articles/interactive-rebase)
-   feature to tidy up your commits before making them public.
+4. Please commit your changes in logical chunks, and try to provide clear commit
+   messages. It helps us during the review process if we can follow your thought
+   process during the implementation. If you hit a dead end, use `git revert`
+   to revert your commits or just go back to an earlier commit with `git checkout`
+   and continue your work from there.
 
-5. We have a handy [checklist for new igraph
-   functions](https://github.com/igraph/igraph/wiki/Checklist-for-new-(and-old)-functions).
+5. We have a [checklist for new igraph functions](https://github.com/igraph/igraph/wiki/Checklist-for-new-(and-old)-functions).
    If you have added any new functions to igraph, please go through the
    checklist to ensure that your functions play nicely with the rest of the
    library.
 
-6. Locally merge (or rebase) the upstream development branch into your topic branch:
+6. Make sure that your PR is based off the latest code and locally merge (or
+   rebase) the upstream development branch into your topic branch:
 
    ```bash
    git pull [--rebase] upstream <dev-branch>
    ```
+   
+   Rebasing is preferable over merging as you do not need to deal with merge
+   conflicts; however, if you already have many commits, merging the upstream
+   development branch may be faster.
 
-7. Push your topic branch up to your fork:
+7. WHen your topic branch is up-to-date with the upstream development branch, you can
+   push your topic branch up to your fork:
 
    ```bash
    git push origin <topic-branch-name>
    ```
 
 8. [Open a pull request](https://help.github.com/articles/using-pull-requests/)
     with a clear title and description.
 
-**IMPORTANT**: By submitting a pull request, you agree to allow the project owner to
-license your work under the same license as that used by the project.
+**IMPORTANT**: By submitting a pull request, you agree to allow the project
+owner to license your work under the same license as that used by the project,
+see also [Legal Stuff](#legal).
 
 <a name="branching"></a>
 ### Branching
 
-`igraph` is committed to [semantic versioning](https://semver.org/). We are currently still in the development release (0.x), which in principle is a mark that the public API is not yet stable. Regardless, we try to maintain semantic versioning also for the development releases. We do so as follows. Any released minor version (0.x.z) will be API backwards-compatible with any previous release of the *same* minor version (0.x.y, with y < z). This means that *if* there is an API incompatible change, we will increase the minor version. For example, release 0.8.1 is API backwards-compatible with release 0.8.0, while release 0.9.0 is API incompatible with version 0.8.1. Note that this only concerns the *public* API, internal functions may change also within a minor version.
-
-There will always be two versions of `igraph`: the most recent released version, and the next upcoming minor release, which is by definition not yet released. The most recent release version is in the `master` branch, while the next upcoming minor release is in the `develop` branch. If you make a change that is API incompatible with the most recent release, it **must** be merged to the `develop` branch. If the change is API backwards-compatible, it **can** be merged to the `master` branch. It is possible that you build on recent improvements in the `develop` branch, in which case your change should of course target the `develop` branch. If you only add new functionality, but do not change anything of the existing API, this should be backwards-compatible, and can be merged in the `master` branch.
-
-When you make a new pull request, please specify the correct target branch. The maintainers of `igraph` may decide to retarget your pull request to the correct branch. Retargeting you pull request may result in merge conflicts, so it is always good to decide **before** starting to work on something whether you should start from the `master` branch or from the `develop` branch. In most cases, changes in the `master` branch will also be merged to the `develop` branch by the maintainers.
+`igraph` is committed to [semantic versioning](https://semver.org/). We are
+currently still in the development release (0.x), which in principle is a mark
+that the public API is not yet stable. Regardless, we try to maintain semantic
+versioning also for the development releases. We do so as follows. Any released
+minor version (0.x.z) will be API backwards-compatible with any previous release
+of the *same* minor version (0.x.y, with y < z). This means that *if* there is
+an API incompatible change, we will increase the minor version. For example,
+release 0.8.1 is API backwards-compatible with release 0.8.0, while release
+0.9.0 might be API incompatible with version 0.8.1. Note that this only concerns
+the *public* API, internal functions may change also within a minor version.
+
+There will always be two versions of `igraph`: the most recent released version,
+and the next upcoming minor release, which is by definition not yet released.
+The most recent release version is in the `master` branch, while the next
+upcoming minor release is in the `develop` branch. If you make a change that is
+API incompatible with the most recent release, it **must** be merged to
+the `develop` branch. If the change is API backwards-compatible, it **can** be
+merged to the `master` branch. It is possible that you build on recent
+improvements in the `develop` branch, in which case your change should of course
+target the `develop` branch. If you only add new functionality, but do not
+change anything of the existing API, this should be backwards-compatible, and
+can be merged in the `master` branch.
+
+When you make a new pull request, please specify the correct target branch. The
+maintainers of `igraph` may decide to retarget your pull request to the correct
+branch. Retargeting you pull request may result in merge conflicts, so it is
+always good to decide **before** starting to work on something whether you
+should start from the `master` branch or from the `develop` branch. In most
+cases, changes in the `master` branch will also be merged to the `develop`
+branch by the maintainers.
+
+If you are unsure about the branch to target, open an issue about your proposed
+feature and we can discuss the appropriate target branch in the issue before
+you send a PR.
 
 <a name="tips"></a>
 ## Writing igraph Code
 
 [Some tips on writing igraph code](https://github.com/igraph/igraph/wiki/Tips-on-writing-igraph-code).
 
 ## Ask Us!
 
 In general, if you are not sure about something, please ask! You can
 open an issue on GitHub, open a thread in our
 [igraph support forum](https://igraph.discourse.group), or write to
 [@ntamas](https://github.com/ntamas), [@vtraag](https://github.com/vtraag),
-[@szhorvat](https://github.com/szhorvat) or
+[@szhorvat](https://github.com/szhorvat), [@iosonofabio](https://github.com/iosonofabio) or
 [@gaborcsardi](https://github.com/gaborcsardi).
-We prefer the igraph support forum, because then others can learn from it
+We prefer open communication channels, because others can then learn from it
 too.
 
+<a name="legal"></a>
 ## Legal Stuff
 
 This is a pain to deal with, but we can't avoid it, unfortunately.
 
-So, igraph is licensed under the "General Public License (GPL) version 2, or
+`igraph` is licensed under the "General Public License (GPL) version 2, or
 later". The igraph manual is licensed under the "GNU Free Documentation
 License". By submitting a patch or pull request, you agree to allow the project
 owner to license your work under the same license as that used by the project.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/COPYING` & `igraph-0.9.9/vendor/source/igraph/COPYING`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/ONEWS` & `igraph-0.9.9/vendor/source/igraph/ONEWS`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/README.md` & `igraph-0.9.9/vendor/source/igraph/README.md`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/appveyor.yml` & `igraph-0.9.9/vendor/source/igraph/appveyor.yml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/azure-pipelines.yml` & `igraph-0.9.9/vendor/source/igraph/azure-pipelines.yml`

 * *Files 3% similar despite different names*

```diff
@@ -10,15 +10,15 @@
     steps:
       - script: sudo apt-get install ninja-build ccache -y
         displayName: Install dependencies
 
       - template: .azure/build.yml
         parameters:
           build_type: Debug
-          extra_cmake_args: '-DUSE_SANITIZER=Address\;Undefined -DCMAKE_C_FLAGS="-Og" -DCMAKE_CXX_FLAGS="-Og'
+          extra_cmake_args: '-DUSE_SANITIZER=Address\;Undefined -DCMAKE_C_FLAGS="-Og" -DCMAKE_CXX_FLAGS="-Og"'
 
   - job: linux_static_external
     steps:
       - script: sudo apt-get install ninja-build ccache libgmp-dev libglpk-dev libarpack2-dev libopenblas-dev -y
         displayName: Install dependencies
 
       - template: .azure/build.yml
@@ -65,15 +65,15 @@
         parameters:
           extra_cmake_args: '-DCMAKE_C_FLAGS="-mfpmath=387" -DCMAKE_CXX_FLAGS="-mfpmath=387"'
 
   - job: linux_alpine
     steps:
       # https://github.com/alpinelinux/alpine-chroot-install
       - bash: |
-          wget https://raw.githubusercontent.com/alpinelinux/alpine-chroot-install/v0.12.1/alpine-chroot-install && echo '5571ad4d17d14bb09ad23a75060f05553786e564  alpine-chroot-install' | sha1sum -c || exit 1
+          wget https://raw.githubusercontent.com/alpinelinux/alpine-chroot-install/v0.13.2/alpine-chroot-install && echo '60c7e0b5d82e21d1a549fc9a46ba3b36688c09dc  alpine-chroot-install' | sha1sum -c || exit 1
           alpine() { /alpine/enter-chroot -u "$USER" "$@"; }
           sudo sh alpine-chroot-install -p 'build-base linux-headers git cmake ninja bison flex gmp-dev'
           mkdir build && cd build
           alpine cmake .. -GNinja -DIGRAPH_USE_INTERNAL_BLAS=1 -DIGRAPH_USE_INTERNAL_LAPACK=1 -DIGRAPH_USE_INTERNAL_ARPACK=1 -DIGRAPH_USE_INTERNAL_GLPK=1 -DIGRAPH_USE_INTERNAL_CXSPARSE=1 -DIGRAPH_USE_INTERNAL_GMP=1 -DIGRAPH_ENABLE_TLS=1 -DIGRAPH_VERIFY_FINALLY_STACK=1
           alpine cmake --build . --target build_tests
           alpine ctest -j `nproc` --output-on-failure
```

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/doc/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/adjlist.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/adjlist.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/arpack.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/arpack.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/attributes.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/attributes.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/basicigraph.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/basicigraph.xxml`

 * *Files 14% similar despite different names*

#### Comparing `igraph-0.9.8/vendor/source/igraph/doc/basicigraph.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/basicigraph.xxml`

```diff
@@ -10,86 +10,105 @@
     <title>The igraph data model</title>
     <para>The igraph library can handle directed and
 undirected graphs. The igraph graphs are multisets
 of ordered (if directed) or unordered (if undirected) labeled pairs.
 The labels of the pairs plus the number of vertices always starts with
 zero and ends with the number of edges minus one. In addition to that
 a table of metadata is also attached to every graph, its most
-important entries are the number of vertices in the graph and whether
+important entries being the number of vertices in the graph and whether
 the graph is directed or undirected.</para>
     <para>
       Like the edges, the igraph vertices are also
 labeled by numbers between zero and the number of vertices minus one.
 So, to summarize, a directed graph can be imagined like this:
       <informalexample>
         <programlisting>( vertices: 6,
     directed: yes,
     {
      (0,2),
      (2,2),
-     (2,3),
+     (3,2),
      (3,3),
      (3,4),
      (3,4),
+     (4,3),
      (4,1)
     }
   )</programlisting>
       </informalexample>
       Here the edges are ordered pairs or vertex ids, and the graph is a multiset
-of edges plus some meta-data.
+of edges plus some metadata.
     </para>
     <para>
       An undirected graph is like this:
       <informalexample>
         <programlisting>( vertices: 6,
     directed: no,
     {
-     {0,2},
-     {2},
-     {2,3},
-     {3},
-     {3,4},
-     {3,4},
-     {4,1}
+     (0,2),
+     (2,2),
+     (2,3),
+     (3,3),
+     (3,4),
+     (3,4),
+     (3,4),
+     (1,4)
     }
   )</programlisting>
       </informalexample>
-      Here an edge is a set of one or two vertex ids, two for most of the
-time, except for loop edges. A graph is a multiset of edges plus meta data,
-just like in the directed case.
+      Here, an edge is an unordered pair of two vertex ids. A graph is a multiset
+of edges plus metadata, just like in the directed case.
     </para>
     <para>
-      It is possible to convert a directed graph to an undirected one,
+      It is possible to convert between directed and undirected graphs,
 see the
       <link linkend="igraph_to_directed">
         <function>igraph_to_directed()</function>
       </link>
       and
       <link linkend="igraph_to_undirected">
         <function>igraph_to_undirected()</function>
       </link>
       functions.
     </para>
     <para>
-      Note that igraph has some limited support for
-graphs with multiple edges. The support means that multiple edges can
-be stored in igraph graphs, but for most functions
-(like
-      <link linkend="igraph_betweenness">
-        <function>igraph_betweenness()</function>
-      </link>
-      ) it is not checked
-that they work well on graphs with multiple edges.
-To eliminate multiple edges from a graph, you can use
+      igraph aims to robustly support multigraphs, i.e. graphs which
+have more than one edge between some pairs of vertices, as well as
+graphs with self-loops. Most functions which do not support such graphs
+will check their input and issue an error if it is not valid. Those
+rare functions which do not perform this check clearly indicate this
+in their documentation. To eliminate multiple edges from a graph, you can use
       <link linkend="igraph_simplify">
         <function>igraph_simplify()</function>
       </link>
       .
     </para>
   </section>
+  <section id="igraph-functions">
+    <title>About igraph functions</title>
+    <para>
+      igraph has a simple and consistent interface. Most functions check
+their input for validity and display an informative error message
+when something goes wrong. In order to support this, the majority of functions
+return an error code. In basic usage, this code can be ignored, as the
+default behaviour is to abort the program immediately upon error. See
+      <link linkend="igraph-Error">the section on error handling</link>
+      for 
+more information on this topic.
+    </para>
+    <para>
+      Results are typically returned through
+      <emphasis>output arguments</emphasis>
+      ,
+i.e. pointers to a data structure into which the result will be written.
+In almost all cases, this data structure is expected to be pre-initialized.
+A few simple functions communicate their result directly through their return
+value—these functions can never encounter an error.
+    </para>
+  </section>
   <section id="basic-interface">
     <title>The basic interface</title>
     <!-- doxrox-include about_basic_interface -->
     <section id="graph-constructors-and-destructors">
       <title>Graph constructors and destructors</title>
       <!-- doxrox-include igraph_empty -->
       <!-- doxrox-include igraph_empty_attrs -->
```

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/bibdatabase.xml` & `igraph-0.9.9/vendor/source/igraph/doc/bibdatabase.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/bipartite.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/bipartite.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/c-docbook.re` & `igraph-0.9.9/vendor/source/igraph/doc/c-docbook.re`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/cliques.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/cliques.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/community.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/community.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/docbook.outlang` & `igraph-0.9.9/vendor/source/igraph/doc/docbook.outlang`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/doxrox.py` & `igraph-0.9.9/vendor/source/igraph/doc/doxrox.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/dqueue.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/dqueue.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/error.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/error.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/fdl.xml` & `igraph-0.9.9/vendor/source/igraph/doc/fdl.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/flows.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/flows.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/foreign.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/foreign.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/generators.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/generators.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/gpl.xml` & `igraph-0.9.9/vendor/source/igraph/doc/gpl.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/graphlets.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/graphlets.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/gtk-doc.xsl` & `igraph-0.9.9/vendor/source/igraph/doc/gtk-doc.xsl`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/heap.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/heap.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/hrg.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/hrg.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/html/home.png` & `igraph-0.9.9/vendor/source/igraph/doc/html/home.png`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/html/style.css` & `igraph-0.9.9/vendor/source/igraph/doc/html/style.css`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/html/toggle.js` & `igraph-0.9.9/vendor/source/igraph/doc/html/toggle.js`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/igraph-docs.xml` & `igraph-0.9.9/vendor/source/igraph/doc/igraph-docs.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/igraph.3` & `igraph-0.9.9/vendor/source/igraph/doc/igraph.3`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/igraphlogo/igraph-white.svg.gz` & `igraph-0.9.9/vendor/source/igraph/doc/igraphlogo/igraph-white.svg.gz`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/igraphlogo/igraph.svg.gz` & `igraph-0.9.9/vendor/source/igraph/doc/igraphlogo/igraph.svg.gz`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/igraphlogo/igraph2.svg.gz` & `igraph-0.9.9/vendor/source/igraph/doc/igraphlogo/igraph2.svg.gz`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/installation.xml` & `igraph-0.9.9/vendor/source/igraph/doc/installation.xml`

 * *Files 1% similar despite different names*

#### Comparing `igraph-0.9.8/vendor/source/igraph/doc/installation.xml` & `igraph-0.9.9/vendor/source/igraph/doc/installation.xml`

```diff
@@ -42,14 +42,15 @@
           (the bundled
         alternative is Mini-GMP)
         </para>
       </listitem>
       <listitem>
         <para>
           <ulink url="https://www.gnu.org/software/glpk/">GLPK</ulink>
+          (version 4.57 or later)
         </para>
       </listitem>
       <listitem>
         <para>
           <ulink url="https://www.caam.rice.edu/software/ARPACK/">ARPACK</ulink>
         </para>
       </listitem>
@@ -278,15 +279,17 @@
             .
           </para>
         </section>
       </section>
       <section id="igraph-Installation-msys2">
         <title>MSYS2</title>
         <para>
-          MSYS2 can be installed from www.msys2.org. After installing MSYS2,
+          MSYS2 can be installed from
+          <ulink url="https://www.msys2.org/">msys2.org</ulink>
+          . After installing MSYS2,
         ensure that it is up to date by opening a terminal and running
           <literal>pacman -Syuu</literal>
           .
         </para>
         <para>The instructions below assume that you want to compile for a 64-bit
         target.</para>
         <para>
```

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/introduction.xml` & `igraph-0.9.9/vendor/source/igraph/doc/introduction.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/isomorphism.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/isomorphism.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/iterators.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/iterators.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/layout.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/layout.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-en.txt` & `igraph-0.9.9/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-en.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-fr.txt` & `igraph-0.9.9/vendor/source/igraph/doc/licenses/Licence_CeCILL-B_V1-fr.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/licenses/gpl-2.0.txt` & `igraph-0.9.9/vendor/source/igraph/doc/licenses/gpl-2.0.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/licenses/gpl-3.0.txt` & `igraph-0.9.9/vendor/source/igraph/doc/licenses/gpl-3.0.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/licenses/lgpl-2.1.txt` & `igraph-0.9.9/vendor/source/igraph/doc/licenses/lgpl-2.1.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/licenses/lgpl-3.0.txt` & `igraph-0.9.9/vendor/source/igraph/doc/licenses/lgpl-3.0.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/matrix.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/matrix.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/motifs.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/motifs.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/nongraph.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/nongraph.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/operators.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/operators.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/pmt.xml` & `igraph-0.9.9/vendor/source/igraph/doc/pmt.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/progress.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/progress.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/psumtree.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/psumtree.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/random.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/random.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/scg.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/scg.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/separators.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/separators.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/sparsemat.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/sparsemat.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/sparsematrix.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/sparsematrix.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/spatialgames.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/spatialgames.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/stack.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/stack.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/status.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/status.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/structural.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/structural.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/strvector.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/strvector.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/threading.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/threading.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/tutorial.xml` & `igraph-0.9.9/vendor/source/igraph/doc/tutorial.xml`

 * *Files 3% similar despite different names*

#### Comparing `igraph-0.9.8/vendor/source/igraph/doc/tutorial.xml` & `igraph-0.9.9/vendor/source/igraph/doc/tutorial.xml`

```diff
@@ -56,15 +56,15 @@
 necessary compilation flags on all operating systems. Many IDEs support
 CMake, and can work with CMake projects directly. To create a CMake project
 for this example program, create a file name
         <filename>CMakeLists.txt</filename>
         with the
 following contents:
         <programlisting>cmake_minimum_required(VERSION 3.16)
-project(igraph_test C)
+project(igraph_test)
 
 find_package(igraph REQUIRED)
 
 add_executable(igraph_test igraph_test.c)
 target_link_libraries(igraph_test PUBLIC igraph::igraph)</programlisting>
       </para>
       <para>
@@ -85,14 +85,22 @@
         <option>CMAKE_INSTALL_PREFIX</option>
         when compiling igraph.
       </para>
       <para>
         If configuration has succeeded, build the program using
         <programlisting>cmake --build .</programlisting>
       </para>
+      <note>
+        <title>C++ has to be enabled in igraph projects</title>
+        <para>Parts of igraph are implemented in C++; therefore, any CMake target that
+depends on igraph should use the C++ linker. Furthermore, OpenMP support in
+igraph works correctly only if C++ is enabled in the CMake project. The script
+that finds igraph on the host machine will throw an error if C++ support is
+not enabled in the CMake project.</para>
+      </note>
     </section>
     <section id="tut-lesson-1-compiling-without-cmake">
       <title>Compiling without CMake</title>
       <para>
         On most Unix-like systems, the default C compiler is called
         <command>cc</command>
         .
```

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/vector.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/vector.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/version-greater-or-equal.xsl` & `igraph-0.9.9/vendor/source/igraph/doc/version-greater-or-equal.xsl`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/doc/visitors.xxml` & `igraph-0.9.9/vendor/source/igraph/doc/visitors.xxml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/BuildType.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/BuildType.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/CheckTLSSupport.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/CheckTLSSupport.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/CodeCoverage.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/CodeCoverage.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/FindARPACK.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/FindARPACK.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/FindCXSparse.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/FindCXSparse.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/FindGMP.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/FindGMP.cmake`

 * *Files 12% similar despite different names*

```diff
@@ -5,29 +5,32 @@
 #
 # This file is distributed under the MIT License. See
 # http://www.opensource.org/licenses/mit-license.php for terms and conditions.
 #
 # Some modifications made by Tamas Nepusz to ensure that the module fits better
 # with the de facto conventions of FindXXX.cmake scripts
 
-set(GMP_PREFIX "" CACHE PATH "Path to GMP prefix")
+find_path(GMP_INCLUDE_DIR 
+  NAMES gmp.h
+)
 
-find_path(GMP_INCLUDE_DIR gmp.h PATHS ${GMP_PREFIX}/include /usr/include /usr/local/include)
-find_library(GMP_LIBRARY gmp PATHS ${GMP_PREFIX}/lib /usr/lib /usr/local/lib)
+find_library(GMP_LIBRARY
+  NAMES gmp
+)
 
 # behave like a CMake module is supposed to behave
 include(FindPackageHandleStandardArgs)
 find_package_handle_standard_args(
   "GMP"
   DEFAULT_MSG
   GMP_LIBRARY
   GMP_INCLUDE_DIR
 )
 
 # hide the introduced cmake cached variables in cmake GUIs
-mark_as_advanced(GMP_PREFIX)
 mark_as_advanced(GMP_INCLUDE_DIR)
 mark_as_advanced(GMP_LIBRARY)
 
 if(GMP_FOUND)
   set(GMP_LIBRARIES ${GMP_LIBRARY})
+  set(GMP_INCLUDE_DIRS ${GMP_INCLUDE_DIR})
 endif()
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake.in` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/GetGitRevisionDescription.cmake.in`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/JoinPaths.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/JoinPaths.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/PadString.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/PadString.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/PreventInSourceBuilds.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/PreventInSourceBuilds.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/benchmark_helpers.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/benchmark_helpers.cmake`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,30 @@
 include(CMakeParseArguments)
 
 function(add_benchmark NAME NAMESPACE)
   set(TARGET_NAME ${NAMESPACE}_${NAME})
 
   add_executable(${TARGET_NAME} EXCLUDE_FROM_ALL ${PROJECT_SOURCE_DIR}/tests/benchmarks/${NAME}.c)
+  use_all_warnings(${TARGET_NAME})
   add_dependencies(build_benchmarks ${TARGET_NAME})
   target_link_libraries(${TARGET_NAME} PRIVATE igraph)
 
   if (NOT BUILD_SHARED_LIBS)
     # Add a compiler definition required to compile igraph in static mode
     target_compile_definitions(${TARGET_NAME} PRIVATE IGRAPH_STATIC)
   endif()
 
+  # Some benchmarks include plfit_sampling.h from plfit. The following ensures
+  # that the correct version is included, depending on whether plfit is vendored
+  target_include_directories(
+    ${TARGET_NAME} PRIVATE
+    $<$<BOOL:${PLFIT_IS_VENDORED}>:$<TARGET_PROPERTY:plfit_vendored,INCLUDE_DIRECTORIES>>
+    $<$<BOOL:${PLFIT_INCLUDE_DIR}>:${PLFIT_INCLUDE_DIR}>
+  )
+
   if (MSVC)
     # Add MSVC-specific include path for some headers that are missing on Windows
     target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/msvc/include)
   endif()
 
   add_custom_command(
     TARGET benchmark
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/compilers.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/compilers.cmake`

 * *Files 9% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 if(MSVC)
   add_compile_options(/FS)
   add_compile_definitions(_CRT_SECURE_NO_WARNINGS) # necessary to compile for UWP
 endif()
 
 if (NOT MSVC)
   check_c_compiler_flag("-Wno-varargs" COMPILER_SUPPORTS_NO_VARARGS_FLAG)
+  check_c_compiler_flag("-Wno-unknown-warning-option" COMPILER_SUPPORTS_NO_UNKNOWN_WARNING_OPTION_FLAG)
 endif()
 
 set(
   IGRAPH_WARNINGS_AS_ERRORS ON CACHE BOOL
   "Treat warnings as errors with GCC-like compilers"
 )
 
@@ -27,17 +28,19 @@
       /wd4701 # potentially uninitialized local variable
     )
   else()
     target_compile_options(${TARGET_NAME} PRIVATE
       # GCC-style compilers:
       $<$<C_COMPILER_ID:GCC,Clang,AppleClang,Intel>:
         $<$<BOOL:${IGRAPH_WARNINGS_AS_ERRORS}>:-Werror>
-        -Wall -Wextra -pedantic -Wno-unused-function -Wno-unused-parameter -Wno-sign-compare
+        -Wall -Wextra -pedantic
+        -Wno-unused-function -Wno-unused-parameter -Wno-sign-compare
       >
       $<$<BOOL:${COMPILER_SUPPORTS_NO_VARARGS_FLAG}>:-Wno-varargs>
+      $<$<BOOL:${COMPILER_SUPPORTS_NO_UNKNOWN_WARNING_OPTION_FLAG}>:-Wno-unknown-warning-option>
       # Intel compiler:
       $<$<C_COMPILER_ID:Intel>:
         # disable #279: controlling expression is constant; affecting assert(condition && "message")
         # disable #188: enumerated type mixed with another type; affecting IGRAPH_CHECK
         # disable #592: variable "var" is used before its value is set; affecting IGRAPH_UNUSED
         -wd279 -wd188 -wd592 -diag-disable=remark
       >
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/cpack_install_script.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/cpack_install_script.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/dependencies.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/dependencies.cmake`

 * *Files 6% similar despite different names*

```diff
@@ -3,70 +3,78 @@
 include(CheckSymbolExists)
 
 # The threading library is not needed for igraph itself, but might be needed
 # for tests
 include(FindThreads)
 
 macro(find_dependencies)
-  # Declare the list of dependencies that _may_ be vendored and those that may not
-  set(VENDORABLE_DEPENDENCIES BLAS CXSparse GLPK LAPACK ARPACK GMP)
-  set(NONVENDORABLE_DEPENDENCIES GLPK OpenMP)
+  # Declare the list of dependencies that _may_ be vendored
+  set(VENDORABLE_DEPENDENCIES BLAS CXSparse GLPK LAPACK ARPACK GMP PLFIT)
+
+  # Declare optional dependencies associated with IGRAPH_..._SUPPORT flags
+  # Note that GLPK is both vendorable and optional
+  set(OPTIONAL_DEPENDENCIES GLPK OpenMP)
 
   # Declare configuration options for dependencies
   tristate(IGRAPH_USE_INTERNAL_GMP "Compile igraph with internal Mini-GMP" AUTO)
   tristate(IGRAPH_USE_INTERNAL_ARPACK "Compile igraph with internal ARPACK" AUTO)
   tristate(IGRAPH_USE_INTERNAL_BLAS "Compile igraph with internal BLAS" AUTO)
   tristate(IGRAPH_USE_INTERNAL_CXSPARSE "Compile igraph with internal CXSparse" AUTO)
   tristate(IGRAPH_USE_INTERNAL_GLPK "Compile igraph with internal GLPK" AUTO)
   tristate(IGRAPH_USE_INTERNAL_LAPACK "Compile igraph with internal LAPACK" AUTO)
+  tristate(IGRAPH_USE_INTERNAL_PLFIT "Compile igraph with internal plfit" AUTO)
 
   # Declare dependencies
   set(REQUIRED_DEPENDENCIES "")
   set(OPTIONAL_DEPENDENCIES FLEX BISON OpenMP)
   set(VENDORED_DEPENDENCIES "")
 
+  # Declare minimum supported version for some dependencies
+  set(GLPK_VERSION_MIN "4.57") # 4.57 is the first version providing glp_on_error()
+  set(PLFIT_VERSION_MIN "0.9.3")
+
   # Extend dependencies depending on whether we will be using the vendored
   # copies or not
   foreach(DEPENDENCY ${VENDORABLE_DEPENDENCIES})
     string(TOUPPER "${DEPENDENCY}" LIBNAME_UPPER)
 
     if(IGRAPH_USE_INTERNAL_${LIBNAME_UPPER} STREQUAL "AUTO")
-      find_package(${DEPENDENCY})
+      find_package(${DEPENDENCY} ${${DEPENDENCY}_VERSION_MIN} QUIET)
       if(${LIBNAME_UPPER}_FOUND)
         set(IGRAPH_USE_INTERNAL_${LIBNAME_UPPER} OFF)
       else()
         set(IGRAPH_USE_INTERNAL_${LIBNAME_UPPER} ON)
       endif()
     endif()
 
     if(IGRAPH_USE_INTERNAL_${LIBNAME_UPPER})
       list(APPEND VENDORED_DEPENDENCIES ${DEPENDENCY})
     else()
       list(APPEND REQUIRED_DEPENDENCIES ${DEPENDENCY})
     endif()
   endforeach()
 
-  # For nonvendorable dependencies, figure out whether we should attempt to
+  # For optional dependencies, figure out whether we should attempt to
   # link to them based on the value of the IGRAPH_..._SUPPORT option
-  foreach(DEPENDENCY ${NONVENDORABLE_DEPENDENCIES})
+  foreach(DEPENDENCY ${OPTIONAL_DEPENDENCIES})
     string(TOUPPER "${DEPENDENCY}" LIBNAME_UPPER)
 
     if(IGRAPH_${LIBNAME_UPPER}_SUPPORT STREQUAL "AUTO")
-      find_package(${DEPENDENCY})
+      find_package(${DEPENDENCY} ${${DEPENDENCY}_VERSION_MIN} QUIET)
       if(${LIBNAME_UPPER}_FOUND)
         set(IGRAPH_${LIBNAME_UPPER}_SUPPORT ON)
       else()
         set(IGRAPH_${LIBNAME_UPPER}_SUPPORT OFF)
       endif()
     endif()
   endforeach()
 
   # GraphML support is treated separately because the library name is different
   if(IGRAPH_GRAPHML_SUPPORT STREQUAL "AUTO")
-    find_package(LibXml2)
+    find_package(LibXml2 QUIET)
     if(LibXml2_FOUND)
       set(IGRAPH_GRAPHML_SUPPORT ON)
     else()
       set(IGRAPH_GRAPHML_SUPPORT OFF)
     endif()
   endif()
 
@@ -100,15 +108,15 @@
         set(NEED_THIS_DEPENDENCY YES)
       elseif(IGRAPH_${LIBNAME_UPPER}_SUPPORT)
         set(NEED_THIS_DEPENDENCY YES)
       endif()
     endif()
 
     if(NEED_THIS_DEPENDENCY AND NOT DEFINED ${DEPENDENCY}_FOUND)
-      find_package(${DEPENDENCY})
+      find_package(${DEPENDENCY} ${${DEPENDENCY}_VERSION_MIN})
     endif()
   endforeach()
 
   # Override libraries of vendored dependencies even if they were somehow
   # detected above
   foreach(DEPENDENCY ${VENDORED_DEPENDENCIES})
     string(TOUPPER "${DEPENDENCY}" LIBNAME_UPPER)
@@ -140,15 +148,15 @@
         set(NEED_LINKING_AGAINST_LIBM True CACHE BOOL "" FORCE)
       else()
         message(FATAL_ERROR "Failed to figure out how to link to the math library on this platform")
       endif()
       set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_SAVE})
     endif()
     unset(SINH_FUNCTION_EXISTS CACHE)
-	set(CMAKE_REQUIRED_QUIET ${CMAKE_REQUIRED_QUIET_SAVE})
+    set(CMAKE_REQUIRED_QUIET ${CMAKE_REQUIRED_QUIET_SAVE})
   endif()
 
   if(NEED_LINKING_AGAINST_LIBM)
     find_library(MATH_LIBRARY m)
   endif()
 
   mark_as_advanced(MATH_LIBRARY)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/generate_tags_file.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/generate_tags_file.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/lto.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/lto.cmake`

 * *Files 10% similar despite different names*

```diff
@@ -6,14 +6,17 @@
 
 if(IGRAPH_ENABLE_LTO)
   # this matches both ON and AUTO
   check_ipo_supported(RESULT IPO_SUPPORTED OUTPUT IPO_NOT_SUPPORTED_REASON)
   if(IGRAPH_ENABLE_LTO STREQUAL "AUTO")
     # autodetection
     set(IGRAPH_ENABLE_LTO ${IPO_SUPPORTED})
+    if(IPO_SUPPORTED)
+      set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
+    endif()
   elseif(IPO_SUPPORTED)
     # user wanted LTO and the compiler supports it
     set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)
   else()
     # user wanted LTO and the compiler does not support it
     message(FATAL_ERROR "Link-time optimization not supported on this compiler")
   endif()
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/packaging.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/packaging.cmake`

 * *Files 3% similar despite different names*

```diff
@@ -38,14 +38,15 @@
 # declare full directories here, not individual files.
 set(
     CPACK_SOURCE_INSTALLED_DIRECTORIES
     "${CMAKE_SOURCE_DIR}/doc;/doc"
     "${CMAKE_SOURCE_DIR}/etc/cmake;/etc/cmake"
     "${CMAKE_SOURCE_DIR}/examples;/examples"
     "${CMAKE_SOURCE_DIR}/include;/include"
+    "${CMAKE_SOURCE_DIR}/interfaces;/interfaces"
     "${CMAKE_SOURCE_DIR}/msvc/include;/msvc/include"
     "${CMAKE_SOURCE_DIR}/src;/src"
     "${CMAKE_SOURCE_DIR}/tests;/tests"
     "${CMAKE_SOURCE_DIR}/vendor;/vendor"
 )
 
 # CPack is pretty dumb as it can only copy full directories (sans the ignored
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/pkgconfig_helpers.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/pkgconfig_helpers.cmake`

 * *Files 8% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 # Helper functions for generating a nicely formatted igraph.pc file from
 # igraph.pc.in
 
 include(JoinPaths)
+include(CheckCXXSymbolExists)
 
 # Converts the name of a library file (or framework on macOS) into an
 # appropriate linker flag (-lsomething or -framework something.framework).
 # Returns the input intact if its extension does not look like a shared or
 # static library extension.
 function(convert_library_file_to_flags output_variable input)
   get_filename_component(input_filename ${input} NAME_WE)
@@ -22,20 +23,22 @@
 
 if(MATH_LIBRARY)
   set(PKGCONFIG_LIBS_PRIVATE "-lm")
 else()
   set(PKGCONFIG_LIBS_PRIVATE "")
 endif()
 
-if(APPLE)
-  # All recent macOS distributions use libc++
-  set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -lc++")
-elseif(NOT MSVC)
-  # Most Linux distributions and MSYS use libstdc++
-  set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -lstdc++")
+if(NOT MSVC)
+  check_cxx_symbol_exists(_LIBCPP_VERSION "vector" USING_LIBCXX)
+  check_cxx_symbol_exists(__GLIBCXX__ "vector" USING_LIBSTDCXX)
+  if(USING_LIBCXX)
+    set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -lc++")
+  elseif(USING_LIBSTDCXX)
+    set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -lstdc++")
+  endif()
 endif()
 
 if(IGRAPH_GRAPHML_SUPPORT)
   set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -lxml2 -lz")
 endif()
 if(NOT IGRAPH_USE_INTERNAL_GMP)
   set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -lgmp")
@@ -51,14 +54,17 @@
 endif()
 if(NOT IGRAPH_USE_INTERNAL_LAPACK)
   set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -llapack")
 endif()
 if(NOT IGRAPH_USE_INTERNAL_ARPACK)
   set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -larpack")
 endif()
+if(NOT IGRAPH_USE_INTERNAL_PLFIT)
+  set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} -lplfit")
+endif()
 if(IGRAPH_OPENMP_SUPPORT AND OpenMP_FOUND)
   foreach(CURRENT_LIB ${OpenMP_C_LIB_NAMES})
     convert_library_file_to_flags(CURRENT_LIB "${OpenMP_${CURRENT_LIB}_LIBRARY}")
     set(PKGCONFIG_LIBS_PRIVATE "${PKGCONFIG_LIBS_PRIVATE} ${CURRENT_LIB}")
   endforeach()
 endif()
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/run_legacy_test.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/run_legacy_test.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/sanitizers.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/sanitizers.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/summary.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/summary.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/test_helpers.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/test_helpers.cmake`

 * *Files 7% similar despite different names*

```diff
@@ -6,26 +6,35 @@
 endif()
 
 function(add_legacy_test FOLDER NAME NAMESPACE)
   set(TARGET_NAME ${NAMESPACE}_${NAME})
   set(TEST_NAME "${NAMESPACE}::${NAME}")
 
   add_executable(${TARGET_NAME} EXCLUDE_FROM_ALL ${PROJECT_SOURCE_DIR}/${FOLDER}/${NAME}.c)
+  use_all_warnings(${TARGET_NAME})
   add_dependencies(build_tests ${TARGET_NAME})
   target_link_libraries(${TARGET_NAME} PRIVATE igraph)
 
   if (NOT BUILD_SHARED_LIBS)
     # Add a compiler definition required to compile igraph in static mode
     target_compile_definitions(${TARGET_NAME} PRIVATE IGRAPH_STATIC)
   endif()
 
   # Some tests depend on internal igraph headers so we also have to add src/
   # to the include path even though it's not part of the public API
   target_include_directories(
-    ${TARGET_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/src ${CMAKE_SOURCE_DIR}/vendor ${CMAKE_BINARY_DIR}/src
+    ${TARGET_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/src ${CMAKE_BINARY_DIR}/src
+  )
+
+  # Some tests include cs.h from CXSparse. The following ensures that the
+  # correct version is included, depending on whether CXSparse is vendored
+  target_include_directories(
+    ${TARGET_NAME} PRIVATE
+    $<$<BOOL:${CXSPARSE_IS_VENDORED}>:$<TARGET_PROPERTY:cxsparse_vendored,INCLUDE_DIRECTORIES>>
+    $<$<BOOL:${CXSPARSE_INCLUDE_DIRS}>:${CXSPARSE_INCLUDE_DIRS}>
   )
 
   if (MSVC)
     # Add MSVC-specific include path for some headers that are missing on Windows
     target_include_directories(${TARGET_NAME} PRIVATE ${CMAKE_SOURCE_DIR}/msvc/include)
   endif()
```

### Comparing `igraph-0.9.8/vendor/source/igraph/etc/cmake/version.cmake` & `igraph-0.9.9/vendor/source/igraph/etc/cmake/version.cmake`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/adjlist.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/adjlist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/ak-4102.max` & `igraph-0.9.9/vendor/source/igraph/examples/simple/ak-4102.max`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/assortativity.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/assortativity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/bellman_ford.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/bellman_ford.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/bellman_ford.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/bellman_ford.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/blas.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/blas.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes2.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes2.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes3.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes3.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes3.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes4.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes4.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cattributes4.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cattributes4.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/celegansneural.gml` & `igraph-0.9.9/vendor/source/igraph/examples/simple/celegansneural.gml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/centralization.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/centralization.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cohesive_blocks.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cohesive_blocks.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/cohesive_blocks.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/cohesive_blocks.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/dijkstra.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/dijkstra.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/dominator_tree.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/dominator_tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/dot.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/dot.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/dot.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/dot.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/dqueue.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/dqueue.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/eigenvector_centrality.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/eigenvector_centrality.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/even_tarjan.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/even_tarjan.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/flow.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/flow.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/flow2.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/flow2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/foreign.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/foreign.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/gml.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/gml.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/gml.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/gml.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-default-attrs.xml` & `igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-default-attrs.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-hsa05010.xml` & `igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-hsa05010.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/graphml-malformed.xml` & `igraph-0.9.9/vendor/source/igraph/examples/simple/graphml-malformed.xml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/graphml.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/graphml.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/graphml.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/graphml.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_add_edges.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_add_edges.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_add_vertices.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_add_vertices.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_adjacency.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_adjacency.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_all_st_mincuts.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_atlas.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_atlas.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_average_path_length.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_average_path_length.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_barabasi_game.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_barabasi_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_barabasi_game2.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_barabasi_game2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs_callback.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs_callback.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bfs_simple.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bfs_simple.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_biconnected_components.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_biconnected_components.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bipartite_create.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bipartite_create.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_bipartite_projection.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_bipartite_projection.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_cliques.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_cliques.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_cocitation.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_cocitation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_coloring.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_coloring.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_edge_betweenness.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_fastgreedy.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_fluid_communities.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_fluid_communities.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_label_propagation.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_label_propagation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_leading_eigenvector.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_leading_eigenvector.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_leiden.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_leiden.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_multilevel.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_multilevel.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_multilevel.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_multilevel.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_community_optimal_modularity.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_community_optimal_modularity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_complementer.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_complementer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_compose.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_compose.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_convex_hull.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_convex_hull.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_copy.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_copy.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_create.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_create.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_decompose.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_decompose.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_degree.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_degree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_degree_sequence_game.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_degree_sequence_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_delete_edges.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_delete_edges.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_delete_vertices.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_delete_vertices.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_deterministic_optimal_imitation.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_deterministic_optimal_imitation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_diameter.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_diameter.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_difference.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_difference.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_disjoint_union.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_disjoint_union.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_eccentricity.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_eccentricity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_empty.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_empty.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_erdos_renyi_game.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_erdos_renyi_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_es_pairs.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_es_pairs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_feedback_arc_set.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_feedback_arc_set.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_feedback_arc_set_ip.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_feedback_arc_set_ip.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_fisher_yates_shuffle.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_fisher_yates_shuffle.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_full.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_full.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_all_shortest_paths_dijkstra.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_all_shortest_paths_dijkstra.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_eid.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_eid.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_eids.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_eids.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_shortest_paths.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_shortest_paths.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_get_shortest_paths_dijkstra.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_get_shortest_paths_dijkstra.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_girth.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_girth.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_grg_game.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_grg_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_has_multiple.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_has_multiple.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_independent_sets.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_independent_sets.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_intersection.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_intersection.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_directed.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_directed.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_loop.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_loop.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_minimal_separator.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_minimal_separator.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_multiple.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_multiple.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_is_separator.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_is_separator.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_isomorphic_vf2.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_isomorphic_vf2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_knn.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_knn.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dgeev.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dgeev.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dgeevx.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dgeevx.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dgesv.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dgesv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lapack_dsyevr.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lapack_dsyevr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_laplacian.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_laplacian.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_laplacian.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_laplacian.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_layout_reingold_tilford.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_layout_reingold_tilford.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_lcf.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_lcf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_maximal_cliques.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_maximal_cliques.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_maximal_cliques.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_maximal_cliques.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_maximum_bipartite_matching.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_maximum_bipartite_matching.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_mincut.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_mincut.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimal_separators.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimal_separators.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimum_size_separators.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimum_size_separators.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_minimum_spanning_tree.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_minimum_spanning_tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_motifs_randesu.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_qsort_r.c`

 * *Files 17% similar despite different names*

```diff
@@ -1,73 +1,72 @@
 /* -*- mode: C -*-  */
 /*
    IGraph library.
-   Copyright (C) 2006-2012  Gabor Csardi <csardi.gabor@gmail.com>
-   334 Harvard st, Cambridge MA, 02139 USA
+   Copyright (C) 2011-2012  Gabor Csardi <csardi.gabor@gmail.com>
+   334 Harvard st, Cambridge, MA 02139, USA
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc.,  51 Franklin Street, Fifth Floor, Boston, MA
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
 #include <igraph.h>
 
-void print_vector(igraph_vector_t *v) {
-    long int i, n = igraph_vector_size(v);
-    igraph_real_t sum = 0.0;
-    for (i = 0; i < n; i++) {
-        if (!igraph_is_nan(VECTOR(*v)[i])) {
-            sum += VECTOR(*v)[i];
-        }
-    }
-    for (i = 0; i < n; i++) {
-        igraph_real_printf(VECTOR(*v)[i] / sum);
-        printf(" ");
+#include "test_utilities.inc"
+
+int comp(void *extra, const void *a, const void *b) {
+    igraph_vector_t *v = (igraph_vector_t*) extra;
+    int *aa = (int*) a;
+    int *bb = (int*) b;
+    igraph_real_t aaa = VECTOR(*v)[*aa];
+    igraph_real_t bbb = VECTOR(*v)[*bb];
+
+    if (aaa < bbb) {
+        return -1;
+    } else if (aaa > bbb) {
+        return 1;
     }
-    printf("\n");
-}
 
-igraph_bool_t print_motif(const igraph_t *graph, igraph_vector_t *vids,
-                          int isoclass, void* extra) {
-    printf("Class %d: ", isoclass);
-    igraph_vector_print(vids);
     return 0;
 }
 
-
 int main() {
+    const int len = 100;
+    igraph_vector_t v;
+    igraph_vector_int_t idx;
+    int i;
+
+    igraph_rng_seed(igraph_rng_default(), 42);
+    igraph_vector_init(&v, len);
+    igraph_vector_int_init(&idx, len);
+    for (i = 0; i < len; i++) {
+        VECTOR(v)[i] = i;
+        VECTOR(idx)[i] = i;
+    }
+    igraph_vector_shuffle(&v);
+
+    igraph_qsort_r(VECTOR(idx), len, sizeof(VECTOR(idx)[0]), (void*) &v, comp);
+
+    for (i = 0; i < len; i++) {
+        printf("%g ", VECTOR(v)[ VECTOR(idx)[i] ]);
+    }
+    printf("\n");
+
+    igraph_vector_int_destroy(&idx);
+    igraph_vector_destroy(&v);
 
-    igraph_t g;
-    igraph_vector_t hist;
-    igraph_vector_t cp_3, cp_4;
-
-    igraph_vector_init_real(&cp_3, 3, 0.0, 0.0, 0.0);
-    igraph_vector_init_real(&cp_4, 4, 0.0, 0.0, 0.0, 0.0);
-
-    igraph_ring(&g, 1000, IGRAPH_DIRECTED, 1, 1);
-    igraph_vector_init(&hist, 0);
-    igraph_motifs_randesu(&g, &hist, 3, &cp_3);
-    print_vector(&hist);
-    igraph_destroy(&g);
-    igraph_vector_destroy(&hist);
-
-    igraph_famous(&g, "bull");
-    igraph_motifs_randesu_callback(&g, 3, &cp_3, &print_motif, 0);
-    igraph_motifs_randesu_callback(&g, 4, &cp_4, &print_motif, 0);
-    igraph_destroy(&g);
+    VERIFY_FINALLY_STACK();
 
-    igraph_vector_destroy(&cp_3);
-    igraph_vector_destroy(&cp_4);
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_neighbors.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_neighbors.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_pagerank.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_pagerank.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_power_law_fit.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_power_law_fit.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_power_law_fit.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_power_law_fit.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_radius.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_radius.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_random_sample.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_random_sample.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_dl.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_dl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_dl.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_dl.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_graphdb.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_read_graph_lgl.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_read_graph_lgl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_reciprocity.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_reciprocity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_ring.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_ring.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_roulette_wheel_imitation.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_roulette_wheel_imitation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping2.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping3.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_grouping4.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_grouping4.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_scg_semiprojectors3.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_similarity.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_similarity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_similarity.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_similarity.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_simplify.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_simplify.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_small.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_small.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat3.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat3.c`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
 #define NCOMPLEX  /* to make it compile with MSVC on Windows */
 
-#include <cs/cs.h>
+#include <cs.h>
 #include <igraph.h>
 
 int permute(const igraph_matrix_t *M,
             const igraph_vector_int_t *p,
             const igraph_vector_int_t *q,
             igraph_matrix_t *res) {
```

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat4.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat4.c`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
 #define NCOMPLEX  /* to make it compile with MSVC on Windows */
 
-#include <cs/cs.h>
+#include <cs.h>
 #include <igraph.h>
 
 igraph_bool_t check_solution(const igraph_sparsemat_t *A,
                              const igraph_vector_t *x,
                              const igraph_vector_t *b) {
 
     long int dim = igraph_vector_size(x);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat6.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat6.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat7.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat7.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_sparsemat8.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_sparsemat8.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_star.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_star.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_stochastic_imitation.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_stochastic_imitation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_strvector.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_strvector.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_strvector.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_strvector.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_subisomorphic_lad.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat5.c`

 * *Files 24% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 /* -*- mode: C -*-  */
 /*
    IGraph library.
-   Copyright (C) 2012  Gabor Csardi <csardi.gabor@gmail.com>
-   334 Harvard street, Cambridge, MA 02139 USA
+   Copyright (C) 2009-2012  Gabor Csardi <csardi.gabor@gmail.com>
+   334 Harvard st, Cambridge MA, 02139 USA
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -19,430 +19,376 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
 #include <igraph.h>
 
+#include "test_utilities.inc"
 
-/* This test counts motifs using LAD and compares the results with
- * the RANDESU motif finder */
-void test_motifs() {
-    igraph_t graph;
-    igraph_vector_t randesu_counts, lad_counts;
-    igraph_vector_t cut_prob;
-    int i, n;
-    igraph_bool_t equal;
-    igraph_integer_t vcount;
+#define EPS 1e-13
 
-    igraph_rng_seed(igraph_rng_default(), 42);
 
-    igraph_erdos_renyi_game_gnm(&graph, 40, 400, /* directed = */ 1, /* loops = */ 0);
-    vcount = igraph_vcount(&graph);
+/* Generic test for 1x1 matrices */
+void test_1x1(igraph_real_t value) {
+    igraph_sparsemat_t A, B;
+    igraph_matrix_t values, vectors;
+    igraph_vector_t values2;
+    igraph_arpack_options_t options;
+
+    igraph_arpack_options_init(&options);
+
+    igraph_sparsemat_init(&A, 1, 1, 1);
+    igraph_sparsemat_entry(&A, 0, 0, value);
+    igraph_sparsemat_compress(&A, &B);
+    igraph_sparsemat_destroy(&A);
+
+    igraph_matrix_init(&values, 0, 0);
+    igraph_matrix_init(&vectors, 0, 0);
+    options.mode = 1;
+    igraph_sparsemat_arpack_rnsolve(&B, &options, /*storage=*/ 0,
+                                    &values, &vectors);
+    printf("rnsolve:\n  - eigenvalues:\n");
+    print_matrix(&values);
+    printf("  - eigenvectors:\n");
+    print_matrix(&vectors);
+    igraph_matrix_destroy(&values);
+    igraph_matrix_destroy(&vectors);
+
+    igraph_vector_init(&values2, 0);
+    igraph_matrix_init(&vectors, 0, 0);
+    options.mode = 1;
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values2, &vectors, IGRAPH_SPARSEMAT_SOLVE_LU);
+    printf("rssolve:\n  - eigenvalues:\n");
+    print_vector(&values2);
+    printf("  - eigenvectors:\n");
+    print_matrix(&vectors);
+    igraph_vector_destroy(&values2);
+    igraph_matrix_destroy(&vectors);
 
-    /* 3-motifs */
-
-    n = 16; /* there are 16 size-3 directed graphs */
-
-    igraph_vector_init(&lad_counts, n);
-
-    for (i = 0; i < n; i++) {
-        igraph_t pattern;
-        igraph_vector_ptr_t maps;
-        igraph_integer_t nAutomorphisms;
-
-        igraph_isoclass_create(&pattern, 3, i, /* directed = */ 1);
-        igraph_vector_ptr_init(&maps, 0);
-
-        igraph_subisomorphic_lad(&pattern, &graph, NULL, NULL, NULL, &maps, /* induced = */ 1, 0);
-
-        igraph_count_subisomorphisms_vf2(&pattern, &pattern, NULL, NULL, NULL, NULL, &nAutomorphisms, NULL, NULL, NULL);
-
-        VECTOR(lad_counts)[i] = igraph_vector_ptr_size(&maps) / nAutomorphisms;
-
-        IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&maps, igraph_vector_destroy);
-        igraph_vector_ptr_destroy_all(&maps);
-
-        igraph_destroy(&pattern);
-    }
-
-    igraph_vector_init(&cut_prob, 3);
-    igraph_vector_init(&randesu_counts, 0);
-    igraph_motifs_randesu(&graph, &randesu_counts, 3, &cut_prob);
-
-    equal = 1 /* true */;
-    for (i = 0; i < n; i++) {
-        if (igraph_is_nan(VECTOR(randesu_counts)[i])) {
-            continue;
-        }
-        if (VECTOR(randesu_counts)[i] != VECTOR(lad_counts)[i]) {
-            equal = 0;
-            break;
-        }
-    }
-
-    if (! equal) {
-        printf("LAD directed 3-motif count does not agree with RANDESU.\n");
-    }
-
-    if (igraph_vector_sum(&lad_counts) != vcount * (vcount - 1) * (vcount - 2) / 6) {
-        printf("Total 3-vertex directed subgraph count is incorrect.\n");
-    }
-
-    igraph_vector_destroy(&randesu_counts);
-    igraph_vector_destroy(&lad_counts);
-    igraph_vector_destroy(&cut_prob);
-
-    /* 4-motifs */
-
-    n = 218; /* there are 218 size-4 directed graphs */
-
-    igraph_vector_init(&lad_counts, n);
-
-    for (i = 0; i < n; i++) {
-        igraph_t pattern;
-        igraph_vector_ptr_t maps;
-        igraph_integer_t nAutomorphisms;
-
-        igraph_isoclass_create(&pattern, 4, i, /* directed = */ 1);
-        igraph_vector_ptr_init(&maps, 0);
-
-        igraph_subisomorphic_lad(&pattern, &graph, NULL, NULL, NULL, &maps, /* induced = */ 1, 0);
-
-        igraph_count_subisomorphisms_vf2(&pattern, &pattern, NULL, NULL, NULL, NULL, &nAutomorphisms, NULL, NULL, NULL);
-
-        VECTOR(lad_counts)[i] = igraph_vector_ptr_size(&maps) / nAutomorphisms;
-
-        IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&maps, igraph_vector_destroy);
-        igraph_vector_ptr_destroy_all(&maps);
-
-        igraph_destroy(&pattern);
-    }
-
-    igraph_vector_init(&cut_prob, 4);
-    igraph_vector_init(&randesu_counts, 0);
-    igraph_motifs_randesu(&graph, &randesu_counts, 4, &cut_prob);
-
-    equal = 1 /* true */;
-    for (i = 0; i < n; i++) {
-        if (igraph_is_nan(VECTOR(randesu_counts)[i])) {
-            continue;
-        }
-        if (VECTOR(randesu_counts)[i] != VECTOR(lad_counts)[i]) {
-            equal = 0;
-            break;
-        }
-    }
-
-    if (! equal) {
-        printf("LAD directed 4-motif count does not agree with RANDESU.\n");
-    }
-
-    if (igraph_vector_sum(&lad_counts) != vcount * (vcount - 1) * (vcount - 2) * (vcount - 3) / 24) {
-        printf("Total 4-vertex directed subgraph count is incorrect.\n");
-    }
-
-    igraph_vector_destroy(&randesu_counts);
-    igraph_vector_destroy(&lad_counts);
-    igraph_vector_destroy(&cut_prob);
-
-    igraph_destroy(&graph);
+    igraph_sparsemat_destroy(&B);
 }
 
-
-void test_motifs_undirected() {
-    igraph_t graph;
-    igraph_vector_t randesu_counts, lad_counts;
-    igraph_vector_t cut_prob;
-    int i, n;
-    igraph_bool_t equal;
-    igraph_integer_t vcount;
-
-    igraph_rng_seed(igraph_rng_default(), 42);
-
-    igraph_erdos_renyi_game_gnm(&graph, 20, 100, /* directed = */ 0, /* loops = */ 0);
-    vcount = igraph_vcount(&graph);
-
-    /* 3-motifs */
-
-    n = 4; /* there are 4 size-3 undirected graphs */
-
-    igraph_vector_init(&lad_counts, n);
-
-    for (i = 0; i < n; i++) {
-        igraph_t pattern;
-        igraph_vector_ptr_t maps;
-        igraph_integer_t nAutomorphisms;
-
-        igraph_isoclass_create(&pattern, 3, i, /* directed = */ 0);
-        igraph_vector_ptr_init(&maps, 0);
-
-        igraph_subisomorphic_lad(&pattern, &graph, NULL, NULL, NULL, &maps, /* induced = */ 1, 0);
-
-        igraph_count_subisomorphisms_vf2(&pattern, &pattern, NULL, NULL, NULL, NULL, &nAutomorphisms, NULL, NULL, NULL);
-
-        VECTOR(lad_counts)[i] = igraph_vector_ptr_size(&maps) / nAutomorphisms;
-
-        IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&maps, igraph_vector_destroy);
-        igraph_vector_ptr_destroy_all(&maps);
-
-        igraph_destroy(&pattern);
-    }
-
-    igraph_vector_init(&cut_prob, 3);
-    igraph_vector_init(&randesu_counts, 0);
-    igraph_motifs_randesu(&graph, &randesu_counts, 3, &cut_prob);
-
-    equal = 1 /* true */;
-    for (i = 0; i < n; i++) {
-        if (igraph_is_nan(VECTOR(randesu_counts)[i])) {
-            continue;
-        }
-        if (VECTOR(randesu_counts)[i] != VECTOR(lad_counts)[i]) {
-            equal = 0;
-            break;
-        }
-    }
-
-    if (! equal) {
-        printf("LAD undirected 3-motif count does not agree with RANDESU.\n");
-    }
-
-    if (igraph_vector_sum(&lad_counts) != vcount * (vcount - 1) * (vcount - 2) / 6) {
-        printf("Total 3-vertex undirected subgraph count is incorrect.\n");
+/* Generic test for 2x2 matrices */
+void test_2x2(igraph_real_t a, igraph_real_t b, igraph_real_t c, igraph_real_t d) {
+    igraph_sparsemat_t A, B;
+    igraph_matrix_t values, vectors;
+    igraph_vector_t values2;
+    igraph_arpack_options_t options;
+
+    igraph_arpack_options_init(&options);
+    options.mode = 1;
+    options.nev = 2;
+
+    igraph_sparsemat_init(&A, 2, 2, 4);
+    igraph_sparsemat_entry(&A, 0, 0, a);
+    igraph_sparsemat_entry(&A, 0, 1, b);
+    igraph_sparsemat_entry(&A, 1, 0, c);
+    igraph_sparsemat_entry(&A, 1, 1, d);
+    igraph_sparsemat_compress(&A, &B);
+    igraph_sparsemat_destroy(&A);
+
+    igraph_matrix_init(&values, 0, 0);
+    igraph_matrix_init(&vectors, 0, 0);
+    igraph_sparsemat_arpack_rnsolve(&B, &options, /*storage=*/ 0,
+                                    &values, &vectors);
+    printf("rnsolve:\n  - eigenvalues:\n");
+    print_matrix(&values);
+    printf("  - eigenvectors:\n");
+    print_matrix(&vectors);
+    igraph_matrix_destroy(&values);
+    igraph_matrix_destroy(&vectors);
+
+    if (b == c) {
+        igraph_vector_init(&values2, 0);
+        igraph_matrix_init(&vectors, 0, 0);
+        igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                        &values2, &vectors, IGRAPH_SPARSEMAT_SOLVE_QR);
+        printf("rssolve:\n  - eigenvalues:\n");
+        print_vector(&values2);
+        printf("  - eigenvectors:\n");
+        print_matrix(&vectors);
+        igraph_vector_destroy(&values2);
+        igraph_matrix_destroy(&vectors);
     }
 
-    igraph_vector_destroy(&randesu_counts);
-    igraph_vector_destroy(&lad_counts);
-    igraph_vector_destroy(&cut_prob);
-
-    /* 4-motifs */
-
-    n = 11; /* there are 11 size-4 undirected graphs */
-
-    igraph_vector_init(&lad_counts, n);
-
-    for (i = 0; i < n; i++) {
-        igraph_t pattern;
-        igraph_vector_ptr_t maps;
-        igraph_integer_t nAutomorphisms;
-
-        igraph_isoclass_create(&pattern, 4, i, /* directed = */ 0);
-        igraph_vector_ptr_init(&maps, 0);
-
-        igraph_subisomorphic_lad(&pattern, &graph, NULL, NULL, NULL, &maps, /* induced = */ 1, 0);
-
-        igraph_count_subisomorphisms_vf2(&pattern, &pattern, NULL, NULL, NULL, NULL, &nAutomorphisms, NULL, NULL, NULL);
-
-        VECTOR(lad_counts)[i] = igraph_vector_ptr_size(&maps) / nAutomorphisms;
-
-        IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&maps, igraph_vector_destroy);
-        igraph_vector_ptr_destroy_all(&maps);
-
-        igraph_destroy(&pattern);
-    }
-
-    igraph_vector_init(&cut_prob, 4);
-    igraph_vector_init(&randesu_counts, 0);
-    igraph_motifs_randesu(&graph, &randesu_counts, 4, &cut_prob);
-
-    equal = 1 /* true */;
-    for (i = 0; i < n; i++) {
-        if (igraph_is_nan(VECTOR(randesu_counts)[i])) {
-            continue;
-        }
-        if (VECTOR(randesu_counts)[i] != VECTOR(lad_counts)[i]) {
-            equal = 0;
-            break;
-        }
-    }
-
-    if (! equal) {
-        printf("LAD undirected 4-motif count does not agree with RANDESU.\n");
-    }
-
-    if (igraph_vector_sum(&lad_counts) != vcount * (vcount - 1) * (vcount - 2) * (vcount - 3) / 24) {
-        printf("Total 4-vertex undirected subgraph count is incorrect.\n");
-    }
-
-    igraph_vector_destroy(&randesu_counts);
-    igraph_vector_destroy(&lad_counts);
-    igraph_vector_destroy(&cut_prob);
-
-    igraph_destroy(&graph);
+    igraph_sparsemat_destroy(&B);
 }
 
-
 int main() {
-    igraph_t target, pattern;
-    igraph_bool_t iso;
-    igraph_vector_t map;
-    igraph_vector_ptr_t maps;
-    int i, n, result;
-    int domainsvec[] = { 0, 2, 8, -1,
-                         4, 5, 6, 7, -1,
-                         1, 3, 5, 6, 7, 8, -1,
-                         0, 2, 8, -1,
-                         1, 3, 7, 8, -1, -2
-                       };
-    igraph_vector_ptr_t domains;
-    igraph_vector_t *v = 0;
-
-    igraph_small(&target, 9, IGRAPH_UNDIRECTED,
-                 0, 1, 0, 4, 0, 6,
-                 1, 0, 1, 4, 1, 2,
-                 2, 1, 2, 3,
-                 3, 2, 3, 4, 3, 5, 3, 7, 3, 8,
-                 4, 0, 4, 1, 4, 3, 4, 5, 4, 6,
-                 5, 6, 5, 4, 5, 3, 5, 8,
-                 6, 0, 6, 4, 6, 5,
-                 7, 3, 7, 8,
-                 8, 5, 8, 3, 8, 7,
-                 -1);
-    igraph_simplify(&target, /*multiple=*/ 1, /*loops=*/ 0, /*edge_comb=*/ 0);
 
-    igraph_small(&pattern, 5, IGRAPH_UNDIRECTED,
-                 0, 1, 0, 4,
-                 1, 0, 1, 4, 1, 2,
-                 2, 1, 2, 3,
-                 3, 2, 3, 4,
-                 4, 3, 4, 1, 4, 0,
+    igraph_sparsemat_t A, B;
+    igraph_matrix_t vectors, values2;
+    igraph_vector_t values;
+    long int i;
+    igraph_arpack_options_t options;
+    igraph_real_t min, max;
+    igraph_t g1, g2, g3;
+
+    /***********************************************************************/
+
+    /* Identity matrix */
+    printf("== Identity matrix ==\n");
+#define DIM 10
+    igraph_sparsemat_init(&A, DIM, DIM, DIM);
+    for (i = 0; i < DIM; i++) {
+        igraph_sparsemat_entry(&A, i, i, 1.0);
+    }
+    igraph_sparsemat_compress(&A, &B);
+    igraph_sparsemat_destroy(&A);
+
+    igraph_vector_init(&values, 0);
+    igraph_arpack_options_init(&options);
+
+    options.mode = 1;
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, /*vectors=*/ 0, /*solvemethod=*/0);
+    IGRAPH_ASSERT(VECTOR(values)[0] == 1.0);
+
+    options.mode = 3;
+    options.sigma = 2;
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, /*vectors=*/ 0,
+                                    IGRAPH_SPARSEMAT_SOLVE_LU);
+    IGRAPH_ASSERT(VECTOR(values)[0] == 1.0);
+
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, /*vectors=*/ 0,
+                                    IGRAPH_SPARSEMAT_SOLVE_QR);
+    IGRAPH_ASSERT(VECTOR(values)[0] == 1.0);
+
+    igraph_vector_destroy(&values);
+    igraph_sparsemat_destroy(&B);
+
+#undef DIM
+
+    /***********************************************************************/
+
+    /* Diagonal matrix */
+    printf("\n== Diagonal matrix ==\n");
+#define DIM 10
+    igraph_sparsemat_init(&A, DIM, DIM, DIM);
+    for (i = 0; i < DIM; i++) {
+        igraph_sparsemat_entry(&A, i, i, i + 1.0);
+    }
+    igraph_sparsemat_compress(&A, &B);
+    igraph_sparsemat_destroy(&A);
+
+    igraph_vector_init(&values, 0);
+    igraph_matrix_init(&vectors, 0, 0);
+
+    /* Regular mode */
+    options.mode = 1;
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, /*vectors=*/ &vectors,
+                                    /*solvemethod=*/ 0);
+    if ( fabs(VECTOR(values)[0] - DIM) > EPS ) {
+        printf("Regular: VECTOR(values)[0] numerical precision is only %g, should be %g",
+               fabs((double)VECTOR(values)[0] - DIM), EPS);
+        abort();
+    }
+
+    IGRAPH_ASSERT( fabs(fabs(MATRIX(vectors, DIM - 1, 0)) - 1.0) < EPS);
+
+    MATRIX(vectors, DIM - 1, 0) = 0.0;
+    igraph_matrix_minmax(&vectors, &min, &max);
+    IGRAPH_ASSERT(fabs(min) < EPS);
+    IGRAPH_ASSERT(fabs(max) < EPS);
+
+    /* Shift and invert mode */
+    options.mode = 3;
+    options.sigma = 11;
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, /*vectors=*/ &vectors,
+                                    IGRAPH_SPARSEMAT_SOLVE_LU);
+    if ( fabs(VECTOR(values)[0] - DIM) > EPS ) {
+        printf("Shift and invert, LU: VECTOR(values)[0] numerical precision is only %g, should be %g",
+               fabs((double)VECTOR(values)[0] - DIM), EPS);
+        abort();
+    }
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, /*vectors=*/ &vectors,
+                                    IGRAPH_SPARSEMAT_SOLVE_QR);
+    if ( fabs(VECTOR(values)[0] - DIM) > EPS ) {
+        printf("Shift and invert, QR: VECTOR(values)[0] numerical precision is only %g, should be %g",
+               fabs((double)VECTOR(values)[0] - DIM), EPS);
+        abort();
+    }
+
+    IGRAPH_ASSERT( fabs(fabs(MATRIX(vectors, DIM - 1, 0)) - 1.0) < EPS);
+
+    MATRIX(vectors, DIM - 1, 0) = 0.0;
+    igraph_matrix_minmax(&vectors, &min, &max);
+    IGRAPH_ASSERT(fabs(min) < EPS);
+    IGRAPH_ASSERT(fabs(max) < EPS);
+
+    igraph_vector_destroy(&values);
+    igraph_matrix_destroy(&vectors);
+    igraph_sparsemat_destroy(&B);
+#undef DIM
+
+    /***********************************************************************/
+
+    /* A tree, plus a ring */
+    printf("\n== A tree, plus a ring ==\n");
+#define DIM 10
+    igraph_tree(&g1, DIM, /*children=*/ 2, IGRAPH_TREE_UNDIRECTED);
+    igraph_ring(&g2, DIM, IGRAPH_UNDIRECTED, /*mutual=*/ 0, /*circular=*/ 1);
+    igraph_union(&g3, &g1, &g2, /*edge_map1=*/ 0, /*edge_map1=*/ 0);
+    igraph_destroy(&g1);
+    igraph_destroy(&g2);
+
+    igraph_get_sparsemat(&g3, &A);
+    igraph_destroy(&g3);
+    igraph_sparsemat_compress(&A, &B);
+    igraph_sparsemat_destroy(&A);
+
+    igraph_vector_init(&values, 0);
+    igraph_matrix_init(&vectors, 0, 0);
+
+    /* Regular mode */
+    options.mode = 1;
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, &vectors, /*solvemethod=*/ 0);
+
+    if (MATRIX(vectors, 0, 0) < 0.0) {
+        igraph_matrix_scale(&vectors, -1.0);
+    }
+
+    printf("\nRegular:\n");
+    printf("Eigenvalues:\n");
+    print_vector(&values);
+    printf("Eigenvectors:\n");
+    print_matrix(&vectors);
+
+    /* Shift and invert mode */
+    options.mode = 3;
+    options.sigma = VECTOR(values)[0] * 1.1;
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, &vectors,
+                                    IGRAPH_SPARSEMAT_SOLVE_LU);
+
+    if (MATRIX(vectors, 0, 0) < 0.0) {
+        igraph_matrix_scale(&vectors, -1.0);
+    }
+    printf("\nShift and invert, LU:\n");
+    printf("Eigenvalues:\n");
+    print_vector(&values);
+    printf("Eigenvectors:\n");
+    print_matrix(&vectors);
+
+    igraph_sparsemat_arpack_rssolve(&B, &options, /*storage=*/ 0,
+                                    &values, &vectors,
+                                    IGRAPH_SPARSEMAT_SOLVE_QR);
+    if (MATRIX(vectors, 0, 0) < 0.0) {
+        igraph_matrix_scale(&vectors, -1.0);
+    }
+    printf("\nShift and invert, QR:\n");
+    printf("Eigenvalues:\n");
+    print_vector(&values);
+    printf("Eigenvectors:\n");
+    print_matrix(&vectors);
+
+    igraph_vector_destroy(&values);
+    igraph_matrix_destroy(&vectors);
+    igraph_sparsemat_destroy(&B);
+#undef DIM
+
+
+    /***********************************************************************/
+
+    /* A directed tree and a directed, mutual ring */
+    printf("\n== A directed tree and a directed, mutual ring ==\n");
+#define DIM 10
+    igraph_tree(&g1, DIM, /*children=*/ 2, IGRAPH_TREE_OUT);
+    igraph_ring(&g2, DIM, IGRAPH_DIRECTED, /*mutual=*/ 1, /*circular=*/ 1);
+    igraph_union(&g3, &g1, &g2, /*edge_map1=*/ 0, /*edge_map2=*/ 0);
+    igraph_destroy(&g1);
+    igraph_destroy(&g2);
+
+    igraph_get_sparsemat(&g3, &A);
+    igraph_destroy(&g3);
+    igraph_sparsemat_compress(&A, &B);
+    igraph_sparsemat_destroy(&A);
+
+    igraph_matrix_init(&values2, 0, 0);
+    igraph_matrix_init(&vectors, 0, 0);
+
+    /* Regular mode */
+    options.mode = 1;
+    igraph_sparsemat_arpack_rnsolve(&B, &options, /*storage=*/ 0,
+                                    &values2, &vectors);
+
+    if (MATRIX(vectors, 0, 0) < 0.0) {
+        igraph_matrix_scale(&vectors, -1.0);
+    }
+
+    printf("\nRegular:\n");
+    printf("Eigenvalues:\n");
+    print_matrix(&values2);
+    printf("Eigenvectors:\n");
+    print_matrix(&vectors);
+
+    igraph_matrix_destroy(&values2);
+    igraph_matrix_destroy(&vectors);
+    igraph_sparsemat_destroy(&B);
+#undef DIM
+
+    /***********************************************************************/
+
+    /* A small test graph */
+    printf("\n== A small test graph ==\n");
+
+    igraph_small(&g1, 11, IGRAPH_DIRECTED,
+                 0, 1, 1, 3, 1, 8, 2, 10, 3, 6, 3, 10, 4, 2, 5, 4,
+                 6, 1, 6, 4, 7, 9, 8, 5, 8, 7, 9, 8, 10, 0,
                  -1);
-    igraph_simplify(&pattern, /*multiple=*/ 1, /*loops=*/ 0, /*edge_comb=*/ 0);
-
-    igraph_vector_init(&map, 0);
-    igraph_vector_ptr_init(&maps, 0);
-
-    igraph_subisomorphic_lad(&pattern, &target, /*domains=*/ 0, &iso, &map,
-                             &maps, /*induced=*/ 0, /*time_limit=*/ 0);
-
-    if (!iso) {
-        return 1;
-    }
-    igraph_vector_print(&map);
-    n = igraph_vector_ptr_size(&maps);
-    for (i = 0; i < n; i++) {
-        igraph_vector_t *v = VECTOR(maps)[i];
-        igraph_vector_print(v);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
-
-    printf("---------\n");
-
-    igraph_subisomorphic_lad(&pattern, &target, /*domains=*/ 0, &iso, &map,
-                             &maps, /*induced=*/ 1, /*time_limit=*/ 0);
-
-    if (!iso) {
-        return 2;
-    }
-    igraph_vector_print(&map);
-    n = igraph_vector_ptr_size(&maps);
-    for (i = 0; i < n; i++) {
-        igraph_vector_t *v = VECTOR(maps)[i];
-        igraph_vector_print(v);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
-
-    printf("---------\n");
-
-    igraph_vector_ptr_init(&domains, 0);
-    i = 0;
-    while (1) {
-        if (domainsvec[i] == -2) {
-            break;
-        } else if (domainsvec[i] == -1) {
-            igraph_vector_ptr_push_back(&domains, v);
-            v = 0;
-        } else {
-            if (!v) {
-                v = (igraph_vector_t *) malloc(sizeof(igraph_vector_t));
-                igraph_vector_init(v, 0);
-            }
-            igraph_vector_push_back(v, domainsvec[i]);
-        }
-        i++;
-    }
-
-    igraph_subisomorphic_lad(&pattern, &target, &domains, &iso, &map, &maps,
-                             /*induced=*/ 0, /*time_limit=*/ 0);
-
-    if (!iso) {
-        return 3;
-    }
-    igraph_vector_print(&map);
-    n = igraph_vector_ptr_size(&maps);
-    for (i = 0; i < n; i++) {
-        igraph_vector_t *v = VECTOR(maps)[i];
-        igraph_vector_print(v);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
-
-    n = igraph_vector_ptr_size(&domains);
-    for (i = 0; i < n; i++) {
-        igraph_vector_t *v = VECTOR(domains)[i];
-        igraph_vector_destroy(v);
-        free(v);
-    }
-
-    igraph_vector_ptr_destroy(&domains);
-    igraph_vector_destroy(&map);
-    igraph_vector_ptr_destroy(&maps);
-
-    igraph_destroy(&pattern);
-    igraph_destroy(&target);
-
-    printf("---------\n");
-
-    igraph_vector_init(&map, 0);
-    igraph_vector_ptr_init(&maps, 0);
-
-    igraph_small(&target, 9, IGRAPH_UNDIRECTED,
-                 0, 1, 0, 4, 0, 6,
-                 1, 0, 1, 4, 1, 2,
-                 2, 1, 2, 3,
-                 3, 2, 3, 4, 3, 5, 3, 7, 3, 8,
-                 4, 0, 4, 1, 4, 3, 4, 5, 4, 6,
-                 5, 6, 5, 4, 5, 3, 5, 8,
-                 6, 0, 6, 4, 6, 5,
-                 7, 3, 7, 8,
-                 8, 5, 8, 3, 8, 7,
-                 -1);
-    igraph_simplify(&target, /*multiple=*/ 1, /*loops=*/ 0, /*edge_comb=*/ 0);
-
-    igraph_small(&pattern, 0, IGRAPH_DIRECTED, -1);
-    igraph_set_error_handler(igraph_error_handler_ignore);
-    result = igraph_subisomorphic_lad(&pattern, &target, /*domains=*/ 0,
-                                      &iso, &map, &maps, /*induced=*/ 0,
-                                      /*time_limit=*/ 0);
-    igraph_set_error_handler(igraph_error_handler_abort);
-    if (result != IGRAPH_EINVAL) {
-        return 4;
-    }
-    igraph_destroy(&pattern);
-
-    igraph_small(&pattern, 0, IGRAPH_UNDIRECTED, -1);
-    igraph_subisomorphic_lad(&pattern, &target, /*domains=*/ 0, &iso, &map, &maps,
-                             /*induced=*/ 0, /*time_limit=*/ 0);
-    if (!iso) {
-        return 5;
-    }
-    if (igraph_vector_size(&map) != 0) {
-        return 6;
-    }
-    if (igraph_vector_ptr_size(&maps) != 0) {
-        return 7;
-    }
-
-    igraph_destroy(&pattern);
-    igraph_destroy(&target);
 
-    igraph_vector_destroy(&map);
-    igraph_vector_ptr_destroy(&maps);
+    igraph_get_sparsemat(&g1, &A);
+    igraph_destroy(&g1);
+    igraph_sparsemat_compress(&A, &B);
+    igraph_sparsemat_destroy(&A);
+
+    igraph_matrix_init(&values2, 0, 0);
+    igraph_matrix_init(&vectors, 0, 0);
+
+    /* Regular mode */
+    options.mode = 1;
+    igraph_sparsemat_arpack_rnsolve(&B, &options, /*storage=*/ 0,
+                                    &values2, &vectors);
+
+    if (MATRIX(vectors, 0, 0) < 0.0) {
+        igraph_matrix_scale(&vectors, -1.0);
+    }
+
+    printf("\nRegular:\n");
+    printf("Eigenvalues:\n");
+    print_matrix(&values2);
+    printf("Eigenvectors:\n");
+    print_matrix(&vectors);
+
+    igraph_matrix_destroy(&values2);
+    igraph_matrix_destroy(&vectors);
+    igraph_sparsemat_destroy(&B);
+
+    /***********************************************************************/
+
+    /* Testing the special case solver for 1x1 matrices */
+    printf("\n== Testing the special case solver for 1x1 matrices ==\n");
+    test_1x1(2);
+    test_1x1(0);
+    test_1x1(-3);
+
+    /***********************************************************************/
+
+    /* Testing the special case solver for 2x2 matrices */
+    printf("\n== Testing the special case solver for 2x2 matrices ==\n");
+    test_2x2(1, 2, 2, 4);      /* symmetric */
+    test_2x2(1, 2, 3, 4);      /* non-symmetric, real eigenvalues */
+    test_2x2(1, -5, 10, 4);    /* non-symmetric, complex eigenvalues */
+    test_2x2(0, 0, 0, 0);      /* symmetric, pathological */
 
-    test_motifs();
-    test_motifs_undirected();
+    VERIFY_FINALLY_STACK();
 
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_to_undirected.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_to_undirected.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_topological_sorting.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_topological_sorting.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_transitivity.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_transitivity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_tree.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_union.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_union.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vector_ptr_sort.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vector_ptr_sort.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_version.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_version.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_nonadj.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_nonadj.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_seq.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_seq.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_vs_vector.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_vs_vector.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_weighted_adjacency.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_weighted_adjacency.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_write_graph_lgl.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_write_graph_lgl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/igraph_write_graph_pajek.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/igraph_write_graph_pajek.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/iso_b03_m1000.A00` & `igraph-0.9.9/vendor/source/igraph/examples/simple/iso_b03_m1000.A00`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/karate.gml` & `igraph-0.9.9/vendor/source/igraph/examples/simple/karate.gml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/links.net` & `igraph-0.9.9/vendor/source/igraph/examples/simple/links.net`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/random_seed.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/random_seed.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/scg.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/scg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/scg.out` & `igraph-0.9.9/vendor/source/igraph/examples/simple/scg.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/test.gxl` & `igraph-0.9.9/vendor/source/igraph/examples/simple/test.gxl`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/simple/walktrap.c` & `igraph-0.9.9/vendor/source/igraph/examples/simple/walktrap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/tutorial/tutorial1.c` & `igraph-0.9.9/vendor/source/igraph/examples/tutorial/tutorial1.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/tutorial/tutorial2.c` & `igraph-0.9.9/vendor/source/igraph/examples/tutorial/tutorial2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/examples/tutorial/tutorial3.c` & `igraph-0.9.9/vendor/source/igraph/examples/tutorial/tutorial3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/fuzzing/read_gml_fuzzer.c` & `igraph-0.9.9/vendor/source/igraph/fuzzing/read_gml_fuzzer.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -14,23 +14,23 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 */
 
-#include <stdint.h>
-#include <string.h>
-#include <stdlib.h>
 #include "igraph.h"
-#include <stdio.h>
+#include <cstdint>
+#include <cstring>
+#include <cstdlib>
+#include <cstdio>
 
 extern "C"
-int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size){
-    if(size<5) return 0;
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+    if (size < 5) return 0;
 
     igraph_set_error_handler(igraph_error_handler_ignore);
 
     // Create input file
     char filename[256];
     sprintf(filename, "/tmp/libfuzzer.gml");
     FILE *fp = fopen(filename, "wb");
@@ -49,14 +49,14 @@
     // Do the fuzzing
     igraph_t g;
     if (igraph_read_graph_gml(&g, ifile) == IGRAPH_SUCCESS) {
         // Clean up
         igraph_destroy(&g);
     }
 
-    // no need to call igraph_destroy() if igraph_raed_graph_gml() returns an
+    // no need to call igraph_destroy() if igraph_read_graph_gml() returns an
     // error code as we don't have a valid graph object in that case
 
     fclose(ifile);
     remove(filename);
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_adjlist.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_adjlist.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_arpack.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_arpack.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_array.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_array.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_array_pmt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_array_pmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_attributes.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_attributes.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_bipartite.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_bipartite.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_blas.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_blas.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_centrality.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_centrality.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_cliques.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_cliques.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_cocitation.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_cocitation.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_cohesive_blocks.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_cohesive_blocks.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_coloring.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_coloring.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_community.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_community.h`

 * *Files 0% similar despite different names*

```diff
@@ -212,15 +212,15 @@
                                                      igraph_vector_t *membership,
                                                      igraph_real_t *modularity);
 
 IGRAPH_EXPORT int igraph_community_label_propagation(const igraph_t *graph,
                                                      igraph_vector_t *membership,
                                                      const igraph_vector_t *weights,
                                                      const igraph_vector_t *initial,
-                                                     igraph_vector_bool_t *fixed,
+                                                     const igraph_vector_bool_t *fixed,
                                                      igraph_real_t *modularity);
 
 IGRAPH_EXPORT int igraph_community_multilevel(const igraph_t *graph,
                                               const igraph_vector_t *weights,
                                               const igraph_real_t resolution,
                                               igraph_vector_t *membership,
                                               igraph_matrix_t *memberships,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_complex.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_complex.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_components.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_components.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_constants.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_constants.h`

 * *Files 6% similar despite different names*

```diff
@@ -48,14 +48,18 @@
 
 typedef enum { IGRAPH_MINIMUM = 0, IGRAPH_MAXIMUM = 1 } igraph_optimal_t;
 
 typedef enum { IGRAPH_OUT = 1, IGRAPH_IN = 2, IGRAPH_ALL = 3,
                IGRAPH_TOTAL = 3
              } igraph_neimode_t;
 
+/* Reverse IGRAPH_OUT to IGRAPH_IN and vice versa. Leave other values alone. */
+#define IGRAPH_REVERSE_MODE(mode) \
+    ((mode) == IGRAPH_IN ? IGRAPH_OUT : ((mode) == IGRAPH_OUT ? IGRAPH_IN : (mode)))
+
 typedef enum { IGRAPH_WEAK = 1, IGRAPH_STRONG = 2 } igraph_connectedness_t;
 
 typedef enum { IGRAPH_RECIPROCITY_DEFAULT = 0,
                IGRAPH_RECIPROCITY_RATIO = 1
              } igraph_reciprocity_t;
 
 typedef enum { IGRAPH_ADJ_DIRECTED = 0,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_constructors.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_constructors.h`

 * *Files 2% similar despite different names*

```diff
@@ -37,17 +37,17 @@
 /* Constructors, deterministic                        */
 /* -------------------------------------------------- */
 
 IGRAPH_EXPORT int igraph_create(igraph_t *graph, const igraph_vector_t *edges, igraph_integer_t n,
                                 igraph_bool_t directed);
 IGRAPH_EXPORT int igraph_small(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed,
                                ...);
-IGRAPH_EXPORT int igraph_adjacency(igraph_t *graph, igraph_matrix_t *adjmatrix,
+IGRAPH_EXPORT int igraph_adjacency(igraph_t *graph, const igraph_matrix_t *adjmatrix,
                                    igraph_adjacency_t mode);
-IGRAPH_EXPORT int igraph_weighted_adjacency(igraph_t *graph, igraph_matrix_t *adjmatrix,
+IGRAPH_EXPORT int igraph_weighted_adjacency(igraph_t *graph, const igraph_matrix_t *adjmatrix,
                                             igraph_adjacency_t mode, const char* attr,
                                             igraph_bool_t loops);
 IGRAPH_EXPORT int igraph_star(igraph_t *graph, igraph_integer_t n, igraph_star_mode_t mode,
                               igraph_integer_t center);
 IGRAPH_EXPORT int igraph_lattice(igraph_t *graph, const igraph_vector_t *dimvector, igraph_integer_t nei,
                                  igraph_bool_t directed, igraph_bool_t mutual, igraph_bool_t circular);
 IGRAPH_EXPORT int igraph_ring(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_conversion.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_conversion.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_datatype.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_datatype.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_decls.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_decls.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_dqueue.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_dqueue.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_dqueue_pmt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_dqueue_pmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_eigen.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_eigen.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_embedding.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_embedding.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_epidemics.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_epidemics.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_error.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_error.h`

 * *Files 1% similar despite different names*

```diff
@@ -132,15 +132,17 @@
  * error handler which calls the <function>error()</function>
  * function, as required by R, while the Python interface has an error
  * handler which raises an exception according to the Python way.
  * </para>
  * <para>
  * If you want to write an error handler, your error handler should
  * call \ref IGRAPH_FINALLY_FREE() to deallocate all temporary memory to
- * prevent memory leaks.
+ * prevent memory leaks. Note that this may invalidate the error message
+ * buffer \p reason passed to the error handler. Do not access it after
+ * having called \ref IGRAPH_FINALLY_FREE().
  * </para>
  */
 
 /**
  * \section error_handling_internals Error handling internals
  *
  * <para>
@@ -218,15 +220,15 @@
  * \param reason Textual description of the error.
  * \param file The source file in which the error is noticed.
  * \param line The number of the line in the source file which triggered
  *   the error
  * \param igraph_errno The \a igraph error code.
  */
 
-typedef void igraph_error_handler_t (const char * reason, const char * file,
+typedef void igraph_error_handler_t (const char *reason, const char *file,
                                      int line, int igraph_errno);
 
 /**
  * \var igraph_error_handler_abort
  * \brief Abort program in case of error.
  *
  * The default error handler, prints an error message and aborts the
@@ -447,14 +449,19 @@
 
 #define IGRAPH_ERROR(reason, igraph_errno) \
     do { \
         igraph_error (reason, IGRAPH_FILE_BASENAME, __LINE__, igraph_errno) ; \
         return igraph_errno ; \
     } while (0)
 
+#define IGRAPH_ERROR_NO_RETURN(reason, igraph_errno) \
+    do { \
+        igraph_error (reason, IGRAPH_FILE_BASENAME, __LINE__, igraph_errno) ; \
+    } while (0)
+
 /**
  * \function igraph_error
  * \brief Triggers an error.
  *
  * \a igraph functions usually call this function (most often via the
  * \ref IGRAPH_ERROR macro) if they notice an error.
  * It calls the currently installed error handler function with the
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_eulerian.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_eulerian.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_flow.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_flow.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_foreign.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_foreign.h`

 * *Files 0% similar despite different names*

```diff
@@ -37,15 +37,15 @@
 /* -------------------------------------------------- */
 /* Read and write foreign formats                     */
 /* -------------------------------------------------- */
 
 IGRAPH_EXPORT int igraph_read_graph_edgelist(igraph_t *graph, FILE *instream,
                                              igraph_integer_t n, igraph_bool_t directed);
 IGRAPH_EXPORT int igraph_read_graph_ncol(igraph_t *graph, FILE *instream,
-                                         igraph_strvector_t *predefnames, igraph_bool_t names,
+                                         const igraph_strvector_t *predefnames, igraph_bool_t names,
                                          igraph_add_weights_t weights, igraph_bool_t directed);
 IGRAPH_EXPORT int igraph_read_graph_lgl(igraph_t *graph, FILE *instream,
                                         igraph_bool_t names, igraph_add_weights_t weights,
                                         igraph_bool_t directed);
 IGRAPH_EXPORT int igraph_read_graph_pajek(igraph_t *graph, FILE *instream);
 IGRAPH_EXPORT int igraph_read_graph_graphml(igraph_t *graph, FILE *instream,
                                             int index);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_games.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_games.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_graphicality.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_graphicality.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_graphlets.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_graphlets.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_heap.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_heap.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_heap_pmt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_heap_pmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_hrg.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_hrg.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_interface.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_interface.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_interrupt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_interrupt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_iterators.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_iterators.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_lapack.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_lapack.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_layout.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_layout.h`

 * *Files 1% similar despite different names*

```diff
@@ -222,26 +222,26 @@
                IGRAPH_LAYOUT_DRL_FINAL
              } igraph_layout_drl_default_t;
 
 IGRAPH_EXPORT int igraph_layout_drl_options_init(igraph_layout_drl_options_t *options,
                                                  igraph_layout_drl_default_t templ);
 IGRAPH_EXPORT int igraph_layout_drl(const igraph_t *graph, igraph_matrix_t *res,
                                     igraph_bool_t use_seed,
-                                    igraph_layout_drl_options_t *options,
+                                    const igraph_layout_drl_options_t *options,
                                     const igraph_vector_t *weights,
                                     const igraph_vector_bool_t *fixed);
 
 IGRAPH_EXPORT int igraph_layout_drl_3d(const igraph_t *graph, igraph_matrix_t *res,
                                        igraph_bool_t use_seed,
-                                       igraph_layout_drl_options_t *options,
+                                       const igraph_layout_drl_options_t *options,
                                        const igraph_vector_t *weights,
                                        const igraph_vector_bool_t *fixed);
 
-IGRAPH_EXPORT int igraph_layout_merge_dla(igraph_vector_ptr_t *graphs,
-                                          igraph_vector_ptr_t *coords,
+IGRAPH_EXPORT int igraph_layout_merge_dla(const igraph_vector_ptr_t *graphs,
+                                          const igraph_vector_ptr_t *coords,
                                           igraph_matrix_t *res);
 
 IGRAPH_EXPORT int igraph_layout_gem(const igraph_t *graph, igraph_matrix_t *res,
                                     igraph_bool_t use_seed, igraph_integer_t maxiter,
                                     igraph_real_t temp_max, igraph_real_t temp_min,
                                     igraph_real_t temp_init);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_matching.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_matching.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_matrix.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_matrix.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_matrix_pmt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_matrix_pmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_memory.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_memory.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_microscopic_update.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_microscopic_update.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_mixing.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_mixing.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_motifs.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_motifs.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_neighborhood.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_neighborhood.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_nongraph.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_nongraph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_operators.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_operators.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_paths.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_paths.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_pmt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_pmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_pmt_off.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_pmt_off.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_progress.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_progress.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_psumtree.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_psumtree.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_qsort.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_qsort.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_random.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_random.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_scan.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_scan.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_scg.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_scg.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_separators.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_separators.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_sparsemat.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_sparsemat.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_spmatrix.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_spmatrix.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_stack.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_stack.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_stack_pmt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_stack_pmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_statusbar.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_statusbar.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_structural.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_structural.h`

 * *Files 0% similar despite different names*

```diff
@@ -40,25 +40,25 @@
 /* Basic query functions                              */
 /* -------------------------------------------------- */
 
 IGRAPH_EXPORT int igraph_are_connected(const igraph_t *graph, igraph_integer_t v1, igraph_integer_t v2, igraph_bool_t *res);
 IGRAPH_EXPORT int igraph_count_multiple(const igraph_t *graph, igraph_vector_t *res, igraph_es_t es);
 IGRAPH_EXPORT int igraph_density(const igraph_t *graph, igraph_real_t *res,
                                  igraph_bool_t loops);
-IGRAPH_EXPORT int igraph_diversity(igraph_t *graph, const igraph_vector_t *weights,
+IGRAPH_EXPORT int igraph_diversity(const igraph_t *graph, const igraph_vector_t *weights,
                                    igraph_vector_t *res, const igraph_vs_t vs);
 IGRAPH_EXPORT int igraph_girth(const igraph_t *graph, igraph_integer_t *girth,
                                igraph_vector_t *circle);
 IGRAPH_EXPORT int igraph_has_loop(const igraph_t *graph, igraph_bool_t *res);
 IGRAPH_EXPORT int igraph_has_multiple(const igraph_t *graph, igraph_bool_t *res);
 IGRAPH_EXPORT int igraph_is_loop(const igraph_t *graph, igraph_vector_bool_t *res,
                                  igraph_es_t es);
 IGRAPH_EXPORT int igraph_is_multiple(const igraph_t *graph, igraph_vector_bool_t *res,
                                      igraph_es_t es);
-IGRAPH_EXPORT int igraph_is_mutual(igraph_t *graph, igraph_vector_bool_t *res, igraph_es_t es);
+IGRAPH_EXPORT int igraph_is_mutual(const igraph_t *graph, igraph_vector_bool_t *res, igraph_es_t es);
 IGRAPH_EXPORT int igraph_is_simple(const igraph_t *graph, igraph_bool_t *res);
 IGRAPH_EXPORT int igraph_is_tree(const igraph_t *graph, igraph_bool_t *res, igraph_integer_t *root, igraph_neimode_t mode);
 IGRAPH_EXPORT int igraph_maxdegree(const igraph_t *graph, igraph_integer_t *res,
                                    igraph_vs_t vids, igraph_neimode_t mode,
                                    igraph_bool_t loops);
 IGRAPH_EXPORT int igraph_reciprocity(const igraph_t *graph, igraph_real_t *res,
                                      igraph_bool_t ignore_loops,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_strvector.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_strvector.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_threading.h.in` & `igraph-0.9.9/vendor/source/igraph/include/igraph_threading.h.in`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_topology.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_topology.h`

 * *Files 0% similar despite different names*

```diff
@@ -268,15 +268,15 @@
 IGRAPH_EXPORT int igraph_automorphism_group(const igraph_t *graph, const igraph_vector_int_t *colors, igraph_vector_ptr_t *generators,
                                             igraph_bliss_sh_t sh, igraph_bliss_info_t *info);
 
 /* Functions for 3-4 graphs */
 IGRAPH_EXPORT int igraph_isomorphic_34(const igraph_t *graph1, const igraph_t *graph2,
                                        igraph_bool_t *iso);
 IGRAPH_EXPORT int igraph_isoclass(const igraph_t *graph, igraph_integer_t *isoclass);
-IGRAPH_EXPORT int igraph_isoclass_subgraph(const igraph_t *graph, igraph_vector_t *vids,
+IGRAPH_EXPORT int igraph_isoclass_subgraph(const igraph_t *graph, const igraph_vector_t *vids,
                                            igraph_integer_t *isoclass);
 IGRAPH_EXPORT int igraph_isoclass_create(igraph_t *graph, igraph_integer_t size,
                                          igraph_integer_t number, igraph_bool_t directed);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_transitivity.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_transitivity.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_types.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_types.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_vector.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_vector.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_vector_pmt.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_vector_pmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_vector_ptr.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_vector_ptr.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_vector_type.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_vector_type.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_version.h.in` & `igraph-0.9.9/vendor/source/igraph/include/igraph_version.h.in`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/include/igraph_visitor.h` & `igraph-0.9.9/vendor/source/igraph/include/igraph_visitor.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/src/CMakeLists.txt`

 * *Files 2% similar despite different names*

```diff
@@ -287,14 +287,15 @@
   $<IF:$<OR:$<BOOL:${ARPACK_IS_VENDORED}>,$<BOOL:${BLAS_IS_VENDORED}>,$<BOOL:${LAPACK_IS_VENDORED}>>,$<TARGET_OBJECTS:f2c_vendored>,>
   $<IF:$<BOOL:${ARPACK_IS_VENDORED}>,$<TARGET_OBJECTS:arpack_vendored>,>
   $<IF:$<BOOL:${BLAS_IS_VENDORED}>,$<TARGET_OBJECTS:blas_vendored>,>
   $<IF:$<BOOL:${CXSPARSE_IS_VENDORED}>,$<TARGET_OBJECTS:cxsparse_vendored>,>
   $<IF:$<BOOL:${GLPK_IS_VENDORED}>,$<TARGET_OBJECTS:glpk_vendored>,>
   $<IF:$<BOOL:${GMP_IS_VENDORED}>,$<TARGET_OBJECTS:gmp_vendored>,>
   $<IF:$<BOOL:${LAPACK_IS_VENDORED}>,$<TARGET_OBJECTS:lapack_vendored>,>
+  $<IF:$<BOOL:${PLFIT_IS_VENDORED}>,$<TARGET_OBJECTS:plfit_vendored>,>
 )
 
 # Set soname for the library
 set_target_properties(igraph PROPERTIES VERSION "0.0.0")
 set_target_properties(igraph PROPERTIES SOVERSION 0)
 
 # Add extra compiler definitions if needed
@@ -323,20 +324,22 @@
   ${CMAKE_CURRENT_BINARY_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${PROJECT_SOURCE_DIR}/vendor
 
   # Vendored library include paths
   $<$<BOOL:${CXSPARSE_IS_VENDORED}>:$<TARGET_PROPERTY:cxsparse_vendored,INCLUDE_DIRECTORIES>>
   $<$<BOOL:${GLPK_IS_VENDORED}>:$<TARGET_PROPERTY:glpk_vendored,INCLUDE_DIRECTORIES>>
+  $<$<BOOL:${PLFIT_IS_VENDORED}>:$<TARGET_PROPERTY:plfit_vendored,INCLUDE_DIRECTORIES>>
 
   # Include paths for dependencies
   $<$<BOOL:${CXSPARSE_INCLUDE_DIRS}>:${CXSPARSE_INCLUDE_DIRS}>
   $<$<BOOL:${GLPK_INCLUDE_DIR}>:${GLPK_INCLUDE_DIR}>
   $<$<BOOL:${GMP_INCLUDE_DIR}>:${GMP_INCLUDE_DIR}>
   $<$<BOOL:${LIBXML2_INCLUDE_DIRS}>:${LIBXML2_INCLUDE_DIRS}>
+  $<$<BOOL:${PLFIT_INCLUDE_DIRS}>:${PLFIT_INCLUDE_DIRS}>
 )
 
 if(MATH_LIBRARY)
   target_link_libraries(igraph PUBLIC ${MATH_LIBRARY})
 endif()
 
 if(ARPACK_LIBRARIES)
@@ -363,19 +366,23 @@
   target_link_libraries(igraph PUBLIC ${LAPACK_LIBRARIES})
 endif()
 
 if(LIBXML2_LIBRARIES)
   target_link_libraries(igraph PUBLIC ${LIBXML2_LIBRARIES})
 endif()
 
+if(PLFIT_LIBRARIES)
+  target_link_libraries(igraph PUBLIC ${PLFIT_LIBRARIES})
+endif()
+
 # Link igraph statically to some of the libraries from the subdirectories
 target_link_libraries(
   igraph
   PRIVATE
-  bliss cliquer plfit prpack
+  bliss cliquer prpack
 )
 
 # Disable complex number support for CXSparse because:
 #   - It is necessary to compile with MSVC
 #   - igraph does not need complex number support from CXSparse on any platform
 # This is needed here (in addition to the cxsparse_vendored target) because
 # igraph may be compiled with an external CXSparse.
@@ -423,15 +430,15 @@
   ${PROJECT_BINARY_DIR}/igraph-config-version.cmake
   VERSION ${PACKAGE_VERSION_BASE}
   COMPATIBILITY SameMinorVersion
 )
 
 # Define how to install the library
 install(
-  TARGETS igraph bliss cliquer plfit prpack
+  TARGETS igraph bliss cliquer prpack
   EXPORT igraph_targets
   LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
   ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
   RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
   INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
 )
 install(
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/betweenness.c` & `igraph-0.9.9/vendor/source/igraph/src/centrality/betweenness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/centrality_other.c` & `igraph-0.9.9/vendor/source/igraph/src/centrality/centrality_other.c`

 * *Files 1% similar despite different names*

```diff
@@ -489,14 +489,21 @@
  * neighbors. In practice, the centralities are determined by calculating the
  * eigenvector corresponding to the largest positive eigenvalue of the
  * adjacency matrix. In the undirected case, this function considers
  * the diagonal entries of the adjacency matrix to be \em twice the number of
  * self-loops on the corresponding vertex.
  *
  * </para><para>
+ * In the weighted case, the eigenvector centrality of a vertex is proportional
+ * to the weighted sum of centralities of its neighbours, i.e.
+ * <code>c_i = sum_j w_ij c_j</code>, where <code>w_ij</code> is the weight
+ * of the edge connecting vertices \c i and \c j. The weights of parallel edges
+ * are added up.
+ *
+ * </para><para>
  * The centrality scores returned by igraph can be normalized
  * (using the \p scale parameter) such that the largest eigenvector centrality
  * score is 1 (with one exception, see below).
  *
  * </para><para>
  * In the directed case, the left eigenvector of the adjacency matrix is
  * calculated. In other words, the centrality of a vertex is proportional
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/centralization.c` & `igraph-0.9.9/vendor/source/igraph/src/centrality/centralization.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/closeness.c` & `igraph-0.9.9/vendor/source/igraph/src/centrality/closeness.c`

 * *Files 1% similar despite different names*

```diff
@@ -71,15 +71,15 @@
  * \param res The result of the computation, a vector containing the
  *        closeness centrality scores for the given vertices.
  * \param reachable_count If not \c NULL, this vector will contain the number of
  *        vertices reachable from each vertex for which the closeness is calculated
  *        (not including that vertex).
  * \param all_reachable Pointer to a Boolean. If not \c NULL, it indicates if all
  *        vertices of the graph were reachable from each vertex in \p vids.
- *        If false, the graph is non-connected If true, and the graph is undirected,
+ *        If false, the graph is non-connected. If true, and the graph is undirected,
  *        or if the graph is directed and \p vids contains all vertices, then the
  *        graph is connected.
  * \param vids The vertices for which the closeness centrality will be computed.
  * \param mode The type of shortest paths to be used for the
  *        calculation in directed graphs. Possible values:
  *        \clist
  *        \cli IGRAPH_OUT
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/coreness.c` & `igraph-0.9.9/vendor/source/igraph/src/centrality/coreness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_base_graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_csc.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_csc.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_igraph_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_igraph_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_ge_graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_gs_graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_scc_graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_preprocessed_schur_graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_result.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_result.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_solver.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_solver.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_solver.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_solver.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_utils.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_utils.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack/prpack_utils.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack/prpack_utils.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack.cpp` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/centrality/prpack_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/centrality/prpack_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/README` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/README`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquer.c` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquer.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquer.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquer_graph.c` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquer_graph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/cliquerconf.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/cliquerconf.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/graph.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/misc.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/misc.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/reorder.c` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/reorder.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/reorder.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/reorder.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer/set.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer/set.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliquer_wrapper.c` & `igraph-0.9.9/vendor/source/igraph/src/cliques/cliquer_wrapper.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/cliques.c` & `igraph-0.9.9/vendor/source/igraph/src/connectivity/components.c`

 * *Files 16% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 /* -*- mode: C -*-  */
 /*
    IGraph library.
-   Copyright (C) 2005-2012  Gabor Csardi <csardi.gabor@gmail.com>
+   Copyright (C) 2003-2012  Gabor Csardi <csardi.gabor@gmail.com>
    334 Harvard street, Cambridge, MA 02139 USA
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
@@ -17,1391 +17,1407 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
-#include "igraph_cliques.h"
+#include "igraph_components.h"
 
-#include "igraph_error.h"
-#include "igraph_memory.h"
-#include "igraph_constants.h"
 #include "igraph_adjlist.h"
+#include "igraph_dqueue.h"
 #include "igraph_interface.h"
+#include "igraph_memory.h"
+#include "igraph_operators.h"
 #include "igraph_progress.h"
 #include "igraph_stack.h"
+#include "igraph_structural.h"
+#include "igraph_vector.h"
 
-#include "cliques/cliquer_internal.h"
 #include "core/interruption.h"
-#include "core/set.h"
+#include "operators/subgraph.h"
 
-#include <string.h>    /* memset */
+#include <limits.h>
 
-static void igraph_i_cliques_free_res(igraph_vector_ptr_t *res) {
-    long i, n;
+static int igraph_i_clusters_weak(const igraph_t *graph, igraph_vector_t *membership,
+                                  igraph_vector_t *csize, igraph_integer_t *no);
 
-    n = igraph_vector_ptr_size(res);
-    for (i = 0; i < n; i++) {
-        if (VECTOR(*res)[i] != 0) {
-            igraph_vector_destroy(VECTOR(*res)[i]);
-            igraph_free(VECTOR(*res)[i]);
-        }
+static int igraph_i_clusters_strong(const igraph_t *graph, igraph_vector_t *membership,
+                                    igraph_vector_t *csize, igraph_integer_t *no);
+
+/**
+ * \ingroup structural
+ * \function igraph_clusters
+ * \brief Calculates the (weakly or strongly) connected components in a graph.
+ *
+ * \param graph The graph object to analyze.
+ * \param membership First half of the result will be stored here. For
+ *        every vertex the id of its component is given. The vector
+ *        has to be preinitialized and will be resized. Alternatively
+ *        this argument can be \c NULL, in which case it is ignored.
+ * \param csize The second half of the result. For every component it
+ *        gives its size, the order is defined by the component ids.
+ *        The vector has to be preinitialized and will be resized.
+ *        Alternatively this argument can be \c NULL, in which
+ *        case it is ignored.
+ * \param no Pointer to an integer, if not \c NULL then the number of
+ *        clusters will be stored here.
+ * \param mode For directed graph this specifies whether to calculate
+ *        weakly or strongly connected components. Possible values:
+ *        \c IGRAPH_WEAK,
+ *        \c IGRAPH_STRONG. This argument is
+ *        ignored for undirected graphs.
+ * \return Error code:
+ *         \c IGRAPH_EINVAL: invalid mode argument.
+ *
+ * Time complexity: O(|V|+|E|),
+ * |V| and
+ * |E| are the number of vertices and
+ * edges in the graph.
+ */
+
+int igraph_clusters(const igraph_t *graph, igraph_vector_t *membership,
+                    igraph_vector_t *csize, igraph_integer_t *no,
+                    igraph_connectedness_t mode) {
+    if (mode == IGRAPH_WEAK || !igraph_is_directed(graph)) {
+        return igraph_i_clusters_weak(graph, membership, csize, no);
+    } else if (mode == IGRAPH_STRONG) {
+        return igraph_i_clusters_strong(graph, membership, csize, no);
     }
-    igraph_vector_ptr_clear(res);
+
+    IGRAPH_ERROR("Cannot calculate clusters", IGRAPH_EINVAL);
 }
 
-static int igraph_i_find_k_cliques(
-        const igraph_t *graph,
-        long int size,
-        const igraph_real_t *member_storage,
-        igraph_real_t **new_member_storage,
-        long int old_clique_count,
-        long int *clique_count,
-        igraph_vector_t *neis,
-        igraph_bool_t independent_vertices) {
-
-    long int j, k, l, m, n, new_member_storage_size;
-    const igraph_real_t *c1, *c2;
-    igraph_real_t v1, v2;
-    igraph_bool_t ok;
-
-    /* Allocate the storage */
-    *new_member_storage = IGRAPH_REALLOC(*new_member_storage,
-                                         (size_t) (size * old_clique_count),
-                                         igraph_real_t);
-    if (*new_member_storage == 0) {
-        IGRAPH_ERROR("cliques failed", IGRAPH_ENOMEM);
-    }
-    new_member_storage_size = size * old_clique_count;
-    IGRAPH_FINALLY(igraph_free, *new_member_storage);
-
-    m = n = 0;
-
-    /* Now consider all pairs of i-1-cliques and see if they can be merged */
-    for (j = 0; j < old_clique_count; j++) {
-        for (k = j + 1; k < old_clique_count; k++) {
-            IGRAPH_ALLOW_INTERRUPTION();
+static int igraph_i_clusters_weak(const igraph_t *graph, igraph_vector_t *membership,
+                                  igraph_vector_t *csize, igraph_integer_t *no) {
 
-            /* Since cliques are represented by their vertex indices in increasing
-             * order, two cliques can be merged iff they have exactly the same
-             * indices excluding one AND there is an edge between the two different
-             * vertices */
-            c1 = member_storage + j * (size - 1);
-            c2 = member_storage + k * (size - 1);
-            /* Find the longest prefixes of c1 and c2 that are equal */
-            for (l = 0; l < size - 1 && c1[l] == c2[l]; l++) {
-                (*new_member_storage)[m++] = c1[l];
-            }
-            /* Now, if l == size-1, the two vectors are totally equal.
-            This is a bug */
-            if (l == size - 1) {
-                IGRAPH_WARNING("possible bug in igraph_cliques");
-                m = n;
-            } else {
-                /* Assuming that j<k, c1[l] is always less than c2[l], since cliques
-                 * are ordered alphabetically. Now add c1[l] and store c2[l] in a
-                 * dummy variable */
-                (*new_member_storage)[m++] = c1[l];
-                v1 = c1[l];
-                v2 = c2[l];
-                l++;
-                /* Copy the remaining part of the two vectors. Every member pair
-                 * found in the remaining parts satisfies the following:
-                 * 1. If they are equal, they should be added.
-                 * 2. If they are not equal, the smaller must be equal to the
-                 *    one stored in the dummy variable. If not, the two vectors
-                 *    differ in more than one place. The larger will be stored in
-                 *    the dummy variable again.
-                 */
-                ok = 1;
-                for (; l < size - 1; l++) {
-                    if (c1[l] == c2[l]) {
-                        (*new_member_storage)[m++] = c1[l];
-                        ok = 0;
-                    } else if (ok) {
-                        if (c1[l] < c2[l]) {
-                            if (c1[l] == v1) {
-                                (*new_member_storage)[m++] = c1[l];
-                                v2 = c2[l];
-                            } else {
-                                break;
-                            }
-                        } else {
-                            if (ok && c2[l] == v1) {
-                                (*new_member_storage)[m++] = c2[l];
-                                v2 = c1[l];
-                            } else {
-                                break;
-                            }
-                        }
-                    } else {
-                        break;
-                    }
-                }
-                /* Now, if l != size-1, the two vectors had a difference in more than
-                 * one place, so the whole clique is invalid. */
-                if (l != size - 1) {
-                    /* Step back in new_member_storage */
-                    m = n;
-                } else {
-                    /* v1 and v2 are the two different vertices. Check for an edge
-                     * if we are looking for cliques and check for the absence of an
-                     * edge if we are looking for independent vertex sets */
-                    IGRAPH_CHECK(igraph_neighbors(graph, neis, (igraph_integer_t) v1,
-                                                  IGRAPH_ALL));
-                    l = igraph_vector_search(neis, 0, v2, 0);
-                    if ((l && !independent_vertices) || (!l && independent_vertices)) {
-                        /* Found a new clique, step forward in new_member_storage */
-                        if (m == n || v2 > (*new_member_storage)[m - 1]) {
-                            (*new_member_storage)[m++] = v2;
-                            n = m;
-                        } else {
-                            m = n;
-                        }
-                    } else {
-                        m = n;
-                    }
+    long int no_of_nodes = igraph_vcount(graph);
+    char *already_added;
+    long int first_node, act_cluster_size = 0, no_of_clusters = 1;
+
+    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
+
+    long int i;
+    igraph_vector_t neis = IGRAPH_VECTOR_NULL;
+
+    already_added = IGRAPH_CALLOC(no_of_nodes, char);
+    if (already_added == 0) {
+        IGRAPH_ERROR("Cannot calculate clusters", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, already_added);
+
+    IGRAPH_DQUEUE_INIT_FINALLY(&q, no_of_nodes > 100000 ? 10000 : no_of_nodes / 10);
+    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
+
+    /* Memory for result, csize is dynamically allocated */
+    if (membership) {
+        IGRAPH_CHECK(igraph_vector_resize(membership, no_of_nodes));
+    }
+    if (csize) {
+        igraph_vector_clear(csize);
+    }
+
+    /* The algorithm */
+
+    for (first_node = 0; first_node < no_of_nodes; ++first_node) {
+        if (already_added[first_node] == 1) {
+            continue;
+        }
+        IGRAPH_ALLOW_INTERRUPTION();
+
+        already_added[first_node] = 1;
+        act_cluster_size = 1;
+        if (membership) {
+            VECTOR(*membership)[first_node] = no_of_clusters - 1;
+        }
+        IGRAPH_CHECK(igraph_dqueue_push(&q, first_node));
+
+        while ( !igraph_dqueue_empty(&q) ) {
+            long int act_node = (long int) igraph_dqueue_pop(&q);
+            IGRAPH_CHECK(igraph_neighbors(graph, &neis,
+                                          (igraph_integer_t) act_node, IGRAPH_ALL));
+            for (i = 0; i < igraph_vector_size(&neis); i++) {
+                long int neighbor = (long int) VECTOR(neis)[i];
+                if (already_added[neighbor] == 1) {
+                    continue;
                 }
-                /* See if new_member_storage is full. If so, reallocate */
-                if (m == new_member_storage_size) {
-                    IGRAPH_FINALLY_CLEAN(1);
-                    *new_member_storage = IGRAPH_REALLOC(*new_member_storage,
-                                                         (size_t) new_member_storage_size * 2,
-                                                         igraph_real_t);
-                    if (*new_member_storage == 0) {
-                        IGRAPH_ERROR("cliques failed", IGRAPH_ENOMEM);
-                    }
-                    new_member_storage_size *= 2;
-                    IGRAPH_FINALLY(igraph_free, *new_member_storage);
+                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+                already_added[neighbor] = 1;
+                act_cluster_size++;
+                if (membership) {
+                    VECTOR(*membership)[neighbor] = no_of_clusters - 1;
                 }
             }
         }
+        no_of_clusters++;
+        if (csize) {
+            IGRAPH_CHECK(igraph_vector_push_back(csize, act_cluster_size));
+        }
     }
 
-    /* Calculate how many cliques have we found */
-    *clique_count = n / size;
+    /* Cleaning up */
+
+    if (no) {
+        *no = (igraph_integer_t) no_of_clusters - 1;
+    }
+
+    IGRAPH_FREE(already_added);
+    igraph_dqueue_destroy(&q);
+    igraph_vector_destroy(&neis);
+    IGRAPH_FINALLY_CLEAN(3);
 
-    IGRAPH_FINALLY_CLEAN(1);
     return 0;
 }
 
-/* Internal function for calculating cliques or independent vertex sets.
- * They are practically the same except that the complementer of the graph
- * should be used in the latter case.
- */
-static int igraph_i_cliques(const igraph_t *graph, igraph_vector_ptr_t *res,
-                            igraph_integer_t min_size, igraph_integer_t max_size,
-                            igraph_bool_t independent_vertices) {
+static int igraph_i_clusters_strong(const igraph_t *graph, igraph_vector_t *membership,
+                                    igraph_vector_t *csize, igraph_integer_t *no) {
 
-    igraph_integer_t no_of_nodes;
-    igraph_vector_t neis;
-    igraph_real_t *member_storage = 0, *new_member_storage, *c1;
-    long int i, j, k, clique_count, old_clique_count;
+    long int no_of_nodes = igraph_vcount(graph);
+    igraph_vector_t next_nei = IGRAPH_VECTOR_NULL;
 
-    if (igraph_is_directed(graph)) {
-        IGRAPH_WARNING("directionality of edges is ignored for directed graphs");
-    }
+    long int i, n, num_seen;
+    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
 
-    no_of_nodes = igraph_vcount(graph);
+    long int no_of_clusters = 1;
+    long int act_cluster_size;
 
-    if (min_size < 0) {
-        min_size = 0;
-    }
-    if (max_size > no_of_nodes || max_size <= 0) {
-        max_size = no_of_nodes;
-    }
+    igraph_vector_t out = IGRAPH_VECTOR_NULL;
+    const igraph_vector_int_t* tmp;
 
-    igraph_vector_ptr_clear(res);
+    igraph_adjlist_t adjlist;
 
-    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
-    IGRAPH_FINALLY(igraph_i_cliques_free_res, res);
+    /* The result */
+
+    IGRAPH_VECTOR_INIT_FINALLY(&next_nei, no_of_nodes);
+    IGRAPH_VECTOR_INIT_FINALLY(&out, 0);
+    IGRAPH_DQUEUE_INIT_FINALLY(&q, 100);
 
-    /* Will be resized later, if needed. */
-    member_storage = IGRAPH_CALLOC(1, igraph_real_t);
-    if (member_storage == 0) {
-        IGRAPH_ERROR("cliques failed", IGRAPH_ENOMEM);
+    if (membership) {
+        IGRAPH_CHECK(igraph_vector_resize(membership, no_of_nodes));
     }
-    IGRAPH_FINALLY(igraph_free, member_storage);
+    IGRAPH_CHECK(igraph_vector_reserve(&out, no_of_nodes));
 
-    /* Find all 1-cliques: every vertex will be a clique */
-    new_member_storage = IGRAPH_CALLOC(no_of_nodes, igraph_real_t);
-    if (new_member_storage == 0) {
-        IGRAPH_ERROR("cliques failed", IGRAPH_ENOMEM);
+    igraph_vector_null(&out);
+    if (csize) {
+        igraph_vector_clear(csize);
     }
-    IGRAPH_FINALLY(igraph_free, new_member_storage);
 
+    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
+    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
+
+    num_seen = 0;
     for (i = 0; i < no_of_nodes; i++) {
-        new_member_storage[i] = i;
-    }
-    clique_count = no_of_nodes;
-    old_clique_count = 0;
+        IGRAPH_ALLOW_INTERRUPTION();
 
-    /* Add size 1 cliques if requested */
-    if (min_size <= 1) {
-        IGRAPH_CHECK(igraph_vector_ptr_resize(res, no_of_nodes));
-        igraph_vector_ptr_null(res);
-        for (i = 0; i < no_of_nodes; i++) {
-            igraph_vector_t *p = IGRAPH_CALLOC(1, igraph_vector_t);
-            if (p == 0) {
-                IGRAPH_ERROR("cliques failed", IGRAPH_ENOMEM);
-            }
-            IGRAPH_FINALLY(igraph_free, p);
-            IGRAPH_CHECK(igraph_vector_init(p, 1));
-            VECTOR(*p)[0] = i;
-            VECTOR(*res)[i] = p;
-            IGRAPH_FINALLY_CLEAN(1);
+        tmp = igraph_adjlist_get(&adjlist, i);
+        if (VECTOR(next_nei)[i] > igraph_vector_int_size(tmp)) {
+            continue;
         }
-    }
 
-    for (i = 2; i <= max_size && clique_count > 1; i++) {
+        IGRAPH_CHECK(igraph_dqueue_push(&q, i));
+        while (!igraph_dqueue_empty(&q)) {
+            long int act_node = (long int) igraph_dqueue_back(&q);
+            tmp = igraph_adjlist_get(&adjlist, act_node);
+            if (VECTOR(next_nei)[act_node] == 0) {
+                /* this is the first time we've met this vertex */
+                VECTOR(next_nei)[act_node]++;
+            } else if (VECTOR(next_nei)[act_node] <= igraph_vector_int_size(tmp)) {
+                /* we've already met this vertex but it has more children */
+                long int neighbor = (long int) VECTOR(*tmp)[(long int)
+                                    VECTOR(next_nei)[act_node] - 1];
+                if (VECTOR(next_nei)[neighbor] == 0) {
+                    IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+                }
+                VECTOR(next_nei)[act_node]++;
+            } else {
+                /* we've met this vertex and it has no more children */
+                IGRAPH_CHECK(igraph_vector_push_back(&out, act_node));
+                igraph_dqueue_pop_back(&q);
+                num_seen++;
+
+                if (num_seen % 10000 == 0) {
+                    /* time to report progress and allow the user to interrupt */
+                    IGRAPH_PROGRESS("Strongly connected components: ",
+                                    num_seen * 50.0 / no_of_nodes, NULL);
+                    IGRAPH_ALLOW_INTERRUPTION();
+                }
+            }
+        } /* while q */
+    }  /* for */
+
+    IGRAPH_PROGRESS("Strongly connected components: ", 50.0, NULL);
 
-        /* Here new_member_storage contains the cliques found in the previous
-           iteration. Save this into member_storage, might be needed later  */
+    igraph_adjlist_destroy(&adjlist);
+    IGRAPH_FINALLY_CLEAN(1);
 
-        c1 = member_storage;
-        member_storage = new_member_storage;
-        new_member_storage = c1;
-        old_clique_count = clique_count;
+    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_IN, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
+    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
 
-        IGRAPH_ALLOW_INTERRUPTION();
+    /* OK, we've the 'out' values for the nodes, let's use them in
+       decreasing order with the help of a heap */
 
-        /* Calculate the cliques */
+    igraph_vector_null(&next_nei);             /* mark already added vertices */
+    num_seen = 0;
 
-        IGRAPH_FINALLY_CLEAN(2);
-        IGRAPH_CHECK(igraph_i_find_k_cliques(graph, i, member_storage,
-                                             &new_member_storage,
-                                             old_clique_count,
-                                             &clique_count,
-                                             &neis,
-                                             independent_vertices));
-        IGRAPH_FINALLY(igraph_free, member_storage);
-        IGRAPH_FINALLY(igraph_free, new_member_storage);
-
-        /* Add the cliques just found to the result if requested */
-        if (i >= min_size && i <= max_size) {
-            for (j = 0, k = 0; j < clique_count; j++, k += i) {
-                igraph_vector_t *p = IGRAPH_CALLOC(1, igraph_vector_t);
-                if (p == 0) {
-                    IGRAPH_ERROR("cliques failed", IGRAPH_ENOMEM);
+    while (!igraph_vector_empty(&out)) {
+        long int grandfather = (long int) igraph_vector_pop_back(&out);
+
+        if (VECTOR(next_nei)[grandfather] != 0) {
+            continue;
+        }
+        VECTOR(next_nei)[grandfather] = 1;
+        act_cluster_size = 1;
+        if (membership) {
+            VECTOR(*membership)[grandfather] = no_of_clusters - 1;
+        }
+        IGRAPH_CHECK(igraph_dqueue_push(&q, grandfather));
+
+        num_seen++;
+        if (num_seen % 10000 == 0) {
+            /* time to report progress and allow the user to interrupt */
+            IGRAPH_PROGRESS("Strongly connected components: ",
+                            50.0 + num_seen * 50.0 / no_of_nodes, NULL);
+            IGRAPH_ALLOW_INTERRUPTION();
+        }
+
+        while (!igraph_dqueue_empty(&q)) {
+            long int act_node = (long int) igraph_dqueue_pop_back(&q);
+            tmp = igraph_adjlist_get(&adjlist, act_node);
+            n = igraph_vector_int_size(tmp);
+            for (i = 0; i < n; i++) {
+                long int neighbor = (long int) VECTOR(*tmp)[i];
+                if (VECTOR(next_nei)[neighbor] != 0) {
+                    continue;
+                }
+                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+                VECTOR(next_nei)[neighbor] = 1;
+                act_cluster_size++;
+                if (membership) {
+                    VECTOR(*membership)[neighbor] = no_of_clusters - 1;
+                }
+
+                num_seen++;
+                if (num_seen % 10000 == 0) {
+                    /* time to report progress and allow the user to interrupt */
+                    IGRAPH_PROGRESS("Strongly connected components: ",
+                                    50.0 + num_seen * 50.0 / no_of_nodes, NULL);
+                    IGRAPH_ALLOW_INTERRUPTION();
                 }
-                IGRAPH_FINALLY(igraph_free, p);
-                IGRAPH_CHECK(igraph_vector_init_copy(p, &new_member_storage[k], i));
-                IGRAPH_FINALLY(igraph_vector_destroy, p);
-                IGRAPH_CHECK(igraph_vector_ptr_push_back(res, p));
-                IGRAPH_FINALLY_CLEAN(2);
             }
         }
 
-    } /* i <= max_size && clique_count != 0 */
+        no_of_clusters++;
+        if (csize) {
+            IGRAPH_CHECK(igraph_vector_push_back(csize, act_cluster_size));
+        }
+    }
 
-    igraph_free(member_storage);
-    igraph_free(new_member_storage);
-    igraph_vector_destroy(&neis);
-    IGRAPH_FINALLY_CLEAN(4); /* 3 here, +1 is igraph_i_cliques_free_res */
+    IGRAPH_PROGRESS("Strongly connected components: ", 100.0, NULL);
 
-    return 0;
-}
+    if (no) {
+        *no = (igraph_integer_t) no_of_clusters - 1;
+    }
 
-/**
- * \function igraph_cliques
- * \brief Finds all or some cliques in a graph.
- *
- * </para><para>
- * Cliques are fully connected subgraphs of a graph.
- *
- * </para><para>
- * If you are only interested in the size of the largest clique in the graph,
- * use \ref igraph_clique_number() instead.
- *
- * </para><para>The current implementation of this function
- * uses version 1.21 of the Cliquer library by Sampo Niskanen and
- * Patric R. J. Östergård, http://users.aalto.fi/~pat/cliquer.html
- *
- * \param graph The input graph.
- * \param res Pointer to a pointer vector, the result will be stored
- *   here, i.e. \p res will contain pointers to \ref igraph_vector_t
- *   objects which contain the indices of vertices involved in a clique.
- *   The pointer vector will be resized if needed but note that the
- *   objects in the pointer vector will not be freed.
- * \param min_size Integer giving the minimum size of the cliques to be
- *   returned. If negative or zero, no lower bound will be used.
- * \param max_size Integer giving the maximum size of the cliques to be
- *   returned. If negative or zero, no upper bound will be used.
- * \return Error code.
- *
- * \sa \ref igraph_largest_cliques() and \ref igraph_clique_number().
- *
- * Time complexity: Exponential
- *
- * \example examples/simple/igraph_cliques.c
- */
-int igraph_cliques(const igraph_t *graph, igraph_vector_ptr_t *res,
-                   igraph_integer_t min_size, igraph_integer_t max_size) {
-    return igraph_i_cliquer_cliques(graph, res, min_size, max_size);
-}
+    /* Clean up, return */
 
+    igraph_adjlist_destroy(&adjlist);
+    igraph_vector_destroy(&out);
+    igraph_dqueue_destroy(&q);
+    igraph_vector_destroy(&next_nei);
+    IGRAPH_FINALLY_CLEAN(4);
 
-/**
- * \function igraph_clique_size_hist
- * \brief Counts cliques of each size in the graph.
- *
- * </para><para>
- * Cliques are fully connected subgraphs of a graph.
- *
- * </para><para>The current implementation of this function
- * uses version 1.21 of the Cliquer library by Sampo Niskanen and
- * Patric R. J. Östergård, http://users.aalto.fi/~pat/cliquer.html
- *
- * \param graph The input graph.
- * \param hist Pointer to an initialized vector. The result will be stored
- * here. The first element will store the number of size-1 cliques, the second
- * element the number of size-2 cliques, etc.  For cliques smaller than \p min_size,
- * zero counts will be returned.
- * \param min_size Integer giving the minimum size of the cliques to be
- *   returned. If negative or zero, no lower bound will be used.
- * \param max_size Integer giving the maximum size of the cliques to be
- *   returned. If negative or zero, no upper bound will be used.
- * \return Error code.
- *
- * \sa \ref igraph_cliques() and \ref igraph_cliques_callback()
- *
- * Time complexity: Exponential
- *
- */
-int igraph_clique_size_hist(const igraph_t *graph, igraph_vector_t *hist,
-                            igraph_integer_t min_size, igraph_integer_t max_size) {
-    return igraph_i_cliquer_histogram(graph, hist, min_size, max_size);
+    return 0;
 }
 
+static int igraph_is_connected_weak(const igraph_t *graph, igraph_bool_t *res);
 
 /**
- * \function igraph_cliques_callback
- * \brief Calls a function for each clique in the graph.
+ * \ingroup structural
+ * \function igraph_is_connected
+ * \brief Decides whether the graph is (weakly or strongly) connected.
+ *
+ * A graph is considered connected when any of its vertices is reachable
+ * from any other. A directed graph with this property is called
+ * \em strongly connected. A directed graph that would be connected when
+ * ignoring the directions of its edges is called \em weakly connected.
  *
  * </para><para>
- * Cliques are fully connected subgraphs of a graph. This function
- * enumerates all cliques within the given size range and calls
- * \p cliquehandler_fn for each of them. The cliques are passed to the
- * callback function as a pointer to an \ref igraph_vector_t.  Destroying and
- * freeing this vector is left up to the user.  Use \ref igraph_vector_destroy()
- * to destroy it first, then free it using \ref igraph_free().
- *
- * </para><para>The current implementation of this function
- * uses version 1.21 of the Cliquer library by Sampo Niskanen and
- * Patric R. J. Östergård, http://users.aalto.fi/~pat/cliquer.html
- *
- * \param graph The input graph.
- * \param min_size Integer giving the minimum size of the cliques to be
- *   returned. If negative or zero, no lower bound will be used.
- * \param max_size Integer giving the maximum size of the cliques to be
- *   returned. If negative or zero, no upper bound will be used.
- * \param cliquehandler_fn Callback function to be called for each clique.
- * See also \ref igraph_clique_handler_t.
- * \param arg Extra argument to supply to \p cliquehandler_fn.
- * \return Error code.
- *
- * \sa \ref igraph_cliques()
- *
- * Time complexity: Exponential
- *
+ * A graph with zero vertices (i.e. the null graph) is \em not connected by
+ * definition. This behaviour changed in igraph 0.9; earlier versions assumed
+ * that the null graph is connected. See the following issue on Github for the
+ * argument that led us to change the definition:
+ * https://github.com/igraph/igraph/issues/1538
+ *
+ * \param graph The graph object to analyze.
+ * \param res Pointer to a logical variable, the result will be stored
+ *        here.
+ * \param mode For a directed graph this specifies whether to calculate
+ *        weak or strong connectedness. Possible values:
+ *        \c IGRAPH_WEAK,
+ *        \c IGRAPH_STRONG. This argument is
+ *        ignored for undirected graphs.
+ * \return Error code:
+ *        \c IGRAPH_EINVAL: invalid mode argument.
+ *
+ * Time complexity: O(|V|+|E|), the
+ * number of vertices
+ * plus the number of edges in the graph.
  */
-int igraph_cliques_callback(const igraph_t *graph,
-                            igraph_integer_t min_size, igraph_integer_t max_size,
-                            igraph_clique_handler_t *cliquehandler_fn, void *arg) {
-    return igraph_i_cliquer_callback(graph, min_size, max_size, cliquehandler_fn, arg);
-}
 
+int igraph_is_connected(const igraph_t *graph, igraph_bool_t *res,
+                        igraph_connectedness_t mode) {
 
-/**
- * \function igraph_weighted_cliques
- * \brief Finds all cliques in a given weight range in a vertex weighted graph.
- *
- * </para><para>
- * Cliques are fully connected subgraphs of a graph.
- * The weight of a clique is the sum of the weights
- * of individual vertices within the clique.
- *
- * </para><para>The current implementation of this function
- * uses version 1.21 of the Cliquer library by Sampo Niskanen and
- * Patric R. J. Östergård, http://users.aalto.fi/~pat/cliquer.html
- *
- * Only positive integer vertex weights are supported.
- *
- * \param graph The input graph.
- * \param vertex_weights A vector of vertex weights. The current implementation
- *   will truncate all weights to their integer parts.
- * \param res Pointer to a pointer vector, the result will be stored
- *   here, i.e. \p res will contain pointers to \ref igraph_vector_t
- *   objects which contain the indices of vertices involved in a clique.
- *   The pointer vector will be resized if needed but note that the
- *   objects in the pointer vector will not be freed.
- * \param min_weight Integer giving the minimum weight of the cliques to be
- *   returned. If negative or zero, no lower bound will be used.
- * \param max_weight Integer giving the maximum weight of the cliques to be
- *   returned. If negative or zero, no upper bound will be used.
- * \param maximal If true, only maximal cliques will be returned
- * \return Error code.
- *
- * \sa \ref igraph_cliques(), \ref igraph_maximal_cliques()
- *
- * Time complexity: Exponential
- *
- */
-int igraph_weighted_cliques(const igraph_t *graph,
-                            const igraph_vector_t *vertex_weights, igraph_vector_ptr_t *res,
-                            igraph_real_t min_weight, igraph_real_t max_weight, igraph_bool_t maximal) {
-    return igraph_i_weighted_cliques(graph, vertex_weights, res, min_weight, max_weight, maximal);
-}
+    long int no_of_nodes = igraph_vcount(graph);
 
+    if (no_of_nodes == 0) {
+        /* Changed in igraph 0.9; see https://github.com/igraph/igraph/issues/1538
+         * for the reasoning behind the change */
+        *res = 0;
+        return IGRAPH_SUCCESS;
+    }
 
-/**
- * \function igraph_largest_weighted_cliques
- * \brief Finds the largest weight clique(s) in a graph.
- *
- * </para><para>
- * Finds the clique(s) having the largest weight in the graph.
- *
- * </para><para>The current implementation of this function
- * uses version 1.21 of the Cliquer library by Sampo Niskanen and
- * Patric R. J. Östergård, http://users.aalto.fi/~pat/cliquer.html
- *
- * Only positive integer vertex weights are supported.
- *
- * \param graph The input graph.
- * \param vertex_weights A vector of vertex weights. The current implementation
- *   will truncate all weights to their integer parts.
- * \param res Pointer to a pointer vector, the result will be stored
- *   here, i.e. \p res will contain pointers to \ref igraph_vector_t
- *   objects which contain the indices of vertices involved in a clique.
- *   The pointer vector will be resized if needed but note that the
- *   objects in the pointer vector will not be freed.
- * \return Error code.
- *
- * \sa \ref igraph_weighted_cliques(), \ref igraph_weighted_clique_number(), \ref igraph_largest_cliques()
- *
- * Time complexity: TODO
- */
-int igraph_largest_weighted_cliques(const igraph_t *graph,
-                                    const igraph_vector_t *vertex_weights, igraph_vector_ptr_t *res) {
-    return igraph_i_largest_weighted_cliques(graph, vertex_weights, res);
-}
+    if (no_of_nodes == 1) {
+        *res = 1;
+        return IGRAPH_SUCCESS;
+    }
 
+    if (mode == IGRAPH_WEAK || !igraph_is_directed(graph)) {
+        return igraph_is_connected_weak(graph, res);
+    } else if (mode == IGRAPH_STRONG) {
+        int retval;
+        igraph_integer_t no;
+
+        /* A strongly connected graph has at least as many edges as vertices,
+         * except for the singleton graph, which is handled above. */
+        if (igraph_ecount(graph) < no_of_nodes) {
+            *res = 0;
+            return IGRAPH_SUCCESS;
+        }
 
-/**
- * \function igraph_weighted_clique_number
- * \brief Finds the weight of the largest weight clique in the graph.
- *
- * </para><para>The current implementation of this function
- * uses version 1.21 of the Cliquer library by Sampo Niskanen and
- * Patric R. J. Östergård, http://users.aalto.fi/~pat/cliquer.html
- *
- * Only positive integer vertex weights are supported.
- *
- * \param graph The input graph.
- * \param vertex_weights A vector of vertex weights. The current implementation
- *   will truncate all weights to their integer parts.
- * \param res The largest weight will be returned to the \c igraph_real_t
- *   pointed to by this variable.
- * \return Error code.
- *
- * \sa \ref igraph_weighted_cliques(), \ref igraph_largest_weighted_cliques(), \ref igraph_clique_number()
- *
- * Time complexity: TODO
- *
- */
-int igraph_weighted_clique_number(const igraph_t *graph,
-                                  const igraph_vector_t *vertex_weights, igraph_real_t *res) {
-    return igraph_i_weighted_clique_number(graph, vertex_weights, res);
+        retval = igraph_i_clusters_strong(graph, NULL, NULL, &no);
+        *res = (no == 1);
+        return retval;
+    }
+
+    IGRAPH_ERROR("Invalid connectedness mode.", IGRAPH_EINVAL);
 }
 
-typedef int(*igraph_i_maximal_clique_func_t)(const igraph_vector_t*, void*, igraph_bool_t*);
-typedef struct {
-    igraph_vector_ptr_t* result;
-    igraph_integer_t min_size;
-    igraph_integer_t max_size;
-} igraph_i_maximal_clique_data_t;
-
-static int igraph_i_maximal_cliques(const igraph_t *graph, igraph_i_maximal_clique_func_t func, void* data);
-
-static int igraph_i_maximal_or_largest_cliques_or_indsets(
-        const igraph_t *graph,
-        igraph_vector_ptr_t *res,
-        igraph_integer_t *clique_number,
-        igraph_bool_t keep_only_largest,
-        igraph_bool_t complementer);
+static int igraph_is_connected_weak(const igraph_t *graph, igraph_bool_t *res) {
 
-/**
- * \function igraph_independent_vertex_sets
- * \brief Finds all independent vertex sets in a graph.
- *
- * </para><para>
- * A vertex set is considered independent if there are no edges between
- * them.
- *
- * </para><para>
- * If you are interested in the size of the largest independent vertex set,
- * use \ref igraph_independence_number() instead.
- *
- * </para><para>
- * The current implementation was ported to igraph from the Very Nauty Graph
- * Library by Keith Briggs and uses the algorithm from the paper
- * S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm
- * for generating all the maximal independent sets. SIAM J Computing,
- * 6:505--517, 1977.
- *
- * \param graph The input graph.
- * \param res Pointer to a pointer vector, the result will be stored
- *   here, i.e. \p res will contain pointers to \ref igraph_vector_t
- *   objects which contain the indices of vertices involved in an independent
- *   vertex set. The pointer vector will be resized if needed but note that the
- *   objects in the pointer vector will not be freed.
- * \param min_size Integer giving the minimum size of the sets to be
- *   returned. If negative or zero, no lower bound will be used.
- * \param max_size Integer giving the maximum size of the sets to be
- *   returned. If negative or zero, no upper bound will be used.
- * \return Error code.
- *
- * \sa \ref igraph_largest_independent_vertex_sets(),
- * \ref igraph_independence_number().
- *
- * Time complexity: TODO
- *
- * \example examples/simple/igraph_independent_sets.c
- */
-int igraph_independent_vertex_sets(const igraph_t *graph,
-                                   igraph_vector_ptr_t *res,
-                                   igraph_integer_t min_size,
-                                   igraph_integer_t max_size) {
-    return igraph_i_cliques(graph, res, min_size, max_size, 1);
-}
+    long int no_of_nodes = igraph_vcount(graph), no_of_edges = igraph_ecount(graph);
+    long int added_count;
+    char *already_added;
+    igraph_vector_t neis = IGRAPH_VECTOR_NULL;
+    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
 
-/**
- * \function igraph_largest_independent_vertex_sets
- * \brief Finds the largest independent vertex set(s) in a graph.
- *
- * </para><para>
- * An independent vertex set is largest if there is no other
- * independent vertex set with more vertices in the graph.
- *
- * </para><para>
- * The current implementation was ported to igraph from the Very Nauty Graph
- * Library by Keith Briggs and uses the algorithm from the paper
- * S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm
- * for generating all the maximal independent sets. SIAM J Computing,
- * 6:505--517, 1977.
- *
- * \param graph The input graph.
- * \param res Pointer to a pointer vector, the result will be stored
- *     here. It will be resized as needed.
- * \return Error code.
- *
- * \sa \ref igraph_independent_vertex_sets(), \ref
- * igraph_maximal_independent_vertex_sets().
- *
- * Time complexity: TODO
- */
+    /* By convention, the null graph is not considered connected.
+     * See https://github.com/igraph/igraph/issues/1538 */
+    if (no_of_nodes == 0) {
+        *res = 0;
+        return IGRAPH_SUCCESS;
+    }
 
-int igraph_largest_independent_vertex_sets(const igraph_t *graph,
-        igraph_vector_ptr_t *res) {
-    return igraph_i_maximal_or_largest_cliques_or_indsets(graph, res, 0, 1, 0);
-}
+    /* A connected graph has at least |V| - 1 edges. */
+    if (no_of_edges < no_of_nodes - 1) {
+        *res = 0;
+        return IGRAPH_SUCCESS;
+    }
 
-typedef struct igraph_i_max_ind_vsets_data_t {
-    igraph_integer_t matrix_size;
-    igraph_adjlist_t adj_list;         /* Adjacency list of the graph */
-    igraph_vector_t deg;                 /* Degrees of individual nodes */
-    igraph_set_t* buckets;               /* Bucket array */
-    /* The IS value for each node. Still to be explained :) */
-    igraph_integer_t* IS;
-    igraph_integer_t largest_set_size;   /* Size of the largest set encountered */
-    igraph_bool_t keep_only_largest;     /* True if we keep only the largest sets */
-} igraph_i_max_ind_vsets_data_t;
-
-static int igraph_i_maximal_independent_vertex_sets_backtrack(
-        const igraph_t *graph,
-        igraph_vector_ptr_t *res,
-        igraph_i_max_ind_vsets_data_t *clqdata,
-        igraph_integer_t level) {
-    long int v1, v2, v3, c, j, k;
-    igraph_vector_int_t *neis1, *neis2;
-    igraph_bool_t f;
-    igraph_integer_t j1;
-    long int it_state;
-
-    IGRAPH_ALLOW_INTERRUPTION();
-
-    if (level >= clqdata->matrix_size - 1) {
-        igraph_integer_t size = 0;
-        if (res) {
-            igraph_vector_t *vec;
-            vec = IGRAPH_CALLOC(1, igraph_vector_t);
-            if (vec == 0) {
-                IGRAPH_ERROR("igraph_i_maximal_independent_vertex_sets failed", IGRAPH_ENOMEM);
-            }
-            IGRAPH_VECTOR_INIT_FINALLY(vec, 0);
-            for (v1 = 0; v1 < clqdata->matrix_size; v1++)
-                if (clqdata->IS[v1] == 0) {
-                    IGRAPH_CHECK(igraph_vector_push_back(vec, v1));
-                }
-            size = (igraph_integer_t) igraph_vector_size(vec);
-            if (!clqdata->keep_only_largest) {
-                IGRAPH_CHECK(igraph_vector_ptr_push_back(res, vec));
-            } else {
-                if (size > clqdata->largest_set_size) {
-                    /* We are keeping only the largest sets, and we've found one that's
-                     * larger than all previous sets, so we have to clear the list */
-                    j = igraph_vector_ptr_size(res);
-                    for (v1 = 0; v1 < j; v1++) {
-                        igraph_vector_destroy(VECTOR(*res)[v1]);
-                        free(VECTOR(*res)[v1]);
-                    }
-                    igraph_vector_ptr_clear(res);
-                    IGRAPH_CHECK(igraph_vector_ptr_push_back(res, vec));
-                } else if (size == clqdata->largest_set_size) {
-                    IGRAPH_CHECK(igraph_vector_ptr_push_back(res, vec));
-                } else {
-                    igraph_vector_destroy(vec);
-                    free(vec);
-                }
-            }
-            IGRAPH_FINALLY_CLEAN(1);
-        } else {
-            for (v1 = 0, size = 0; v1 < clqdata->matrix_size; v1++)
-                if (clqdata->IS[v1] == 0) {
-                    size++;
-                }
-        }
-        if (size > clqdata->largest_set_size) {
-            clqdata->largest_set_size = size;
-        }
-    } else {
-        v1 = level + 1;
-        /* Count the number of vertices with an index less than v1 that have
-         * an IS value of zero */
-        neis1 = igraph_adjlist_get(&clqdata->adj_list, v1);
-        c = 0;
-        j = 0;
-        while (j < VECTOR(clqdata->deg)[v1] &&
-               (v2 = (long int) VECTOR(*neis1)[j]) <= level) {
-            if (clqdata->IS[v2] == 0) {
-                c++;
-            }
-            j++;
-        }
+    already_added = IGRAPH_CALLOC(no_of_nodes, char);
+    if (already_added == 0) {
+        IGRAPH_ERROR("Weak connectedness check failed.", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, already_added);
 
-        if (c == 0) {
-            /* If there are no such nodes... */
-            j = 0;
-            while (j < VECTOR(clqdata->deg)[v1] &&
-                   (v2 = (long int) VECTOR(*neis1)[j]) <= level) {
-                clqdata->IS[v2]++;
-                j++;
-            }
-            IGRAPH_CHECK(igraph_i_maximal_independent_vertex_sets_backtrack(graph, res, clqdata, (igraph_integer_t) v1));
-            j = 0;
-            while (j < VECTOR(clqdata->deg)[v1] &&
-                   (v2 = (long int) VECTOR(*neis1)[j]) <= level) {
-                clqdata->IS[v2]--;
-                j++;
-            }
-        } else {
-            /* If there are such nodes, store the count in the IS value of v1 */
-            clqdata->IS[v1] = (igraph_integer_t) c;
-            IGRAPH_CHECK(igraph_i_maximal_independent_vertex_sets_backtrack(graph, res, clqdata, (igraph_integer_t) v1));
-            clqdata->IS[v1] = 0;
-
-            f = 1;
-            j = 0;
-            while (j < VECTOR(clqdata->deg)[v1] &&
-                   (v2 = (long int) VECTOR(*neis1)[j]) <= level) {
-                if (clqdata->IS[v2] == 0) {
-                    IGRAPH_CHECK(igraph_set_add(&clqdata->buckets[v1],
-                                                (igraph_integer_t) j));
-                    neis2 = igraph_adjlist_get(&clqdata->adj_list, v2);
-                    k = 0;
-                    while (k < VECTOR(clqdata->deg)[v2] &&
-                           (v3 = (long int) VECTOR(*neis2)[k]) <= level) {
-                        clqdata->IS[v3]--;
-                        if (clqdata->IS[v3] == 0) {
-                            f = 0;
-                        }
-                        k++;
-                    }
-                }
-                clqdata->IS[v2]++;
-                j++;
-            }
+    IGRAPH_DQUEUE_INIT_FINALLY(&q, 10);
+    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
 
-            if (f) {
-                IGRAPH_CHECK(igraph_i_maximal_independent_vertex_sets_backtrack(graph, res, clqdata, (igraph_integer_t) v1));
-            }
+    /* Try to find at least two clusters */
+    already_added[0] = 1;
+    IGRAPH_CHECK(igraph_dqueue_push(&q, 0));
+
+    added_count = 1;
+    while ( !igraph_dqueue_empty(&q)) {
+        IGRAPH_ALLOW_INTERRUPTION();
 
-            j = 0;
-            while (j < VECTOR(clqdata->deg)[v1] &&
-                   (v2 = (long int) VECTOR(*neis1)[j]) <= level) {
-                clqdata->IS[v2]--;
-                j++;
+        long int actnode = (long int) igraph_dqueue_pop(&q);
+
+        IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) actnode, IGRAPH_ALL));
+        long int nei_count = igraph_vector_size(&neis);
+
+        for (long int i = 0; i < nei_count; i++) {
+            long int neighbor = (long int) VECTOR(neis)[i];
+            if (already_added[neighbor]) {
+                continue;
             }
 
-            it_state = 0;
-            while (igraph_set_iterate(&clqdata->buckets[v1], &it_state, &j1)) {
-                j = (long)j1;
-                v2 = (long int) VECTOR(*neis1)[j];
-                neis2 = igraph_adjlist_get(&clqdata->adj_list, v2);
-                k = 0;
-                while (k < VECTOR(clqdata->deg)[v2] &&
-                       (v3 = (long int) VECTOR(*neis2)[k]) <= level) {
-                    clqdata->IS[v3]++;
-                    k++;
-                }
+            IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+            added_count++;
+            already_added[neighbor] = 1;
+
+            if (added_count == no_of_nodes) {
+                /* We have already reached all nodes: the graph is connected.
+                 * We can stop the traversal now. */
+                igraph_dqueue_clear(&q);
+                break;
             }
-            igraph_set_clear(&clqdata->buckets[v1]);
         }
     }
 
-    return 0;
-}
+    /* Connected? */
+    *res = (added_count == no_of_nodes);
 
-static void igraph_i_free_set_array(igraph_set_t* array) {
-    long int i = 0;
-    while (igraph_set_inited(array + i)) {
-        igraph_set_destroy(array + i);
-        i++;
-    }
-    IGRAPH_FREE(array);
+    IGRAPH_FREE(already_added);
+    igraph_dqueue_destroy(&q);
+    igraph_vector_destroy(&neis);
+    IGRAPH_FINALLY_CLEAN(3);
+
+    return IGRAPH_SUCCESS;
 }
 
 /**
- * \function igraph_maximal_independent_vertex_sets
- * \brief Finds all maximal independent vertex sets of a graph.
+ * \function igraph_decompose_destroy
+ * \brief Free the memory allocated by \ref igraph_decompose().
  *
- * </para><para>
- * A maximal independent vertex set is an independent vertex set which
- * can't be extended any more by adding a new vertex to it.
+ * This function destroys and frees all <type>igraph_t</type>
+ * objects held in \p complist. However, it does not destroy
+ * \p complist itself, as it was not allocated by \ref igraph_decompose().
+ * Use \ref igraph_vector_ptr_destroy() to destroy \p complist.
  *
- * </para><para>
- * The algorithm used here is based on the following paper:
- * S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm for
- * generating all the maximal independent sets. SIAM J Computing,
- * 6:505--517, 1977.
+ * \param complist The list of graph components, as returned by
+ *        \ref igraph_decompose().
  *
- * </para><para>
- * The implementation was originally written by Kevin O'Neill and modified
- * by K M Briggs in the Very Nauty Graph Library. I simply re-wrote it to
- * use igraph's data structures.
+ * Time complexity: O(c), c is the number of components.
+ */
+
+void igraph_decompose_destroy(igraph_vector_ptr_t *complist) {
+    long int i;
+    for (i = 0; i < igraph_vector_ptr_size(complist); i++) {
+        if (VECTOR(*complist)[i] != 0) {
+            igraph_destroy(VECTOR(*complist)[i]);
+            igraph_free(VECTOR(*complist)[i]);
+        }
+    }
+}
+
+static int igraph_i_decompose_weak(const igraph_t *graph,
+                                   igraph_vector_ptr_t *components,
+                                   long int maxcompno, long int minelements);
+
+static int igraph_i_decompose_strong(const igraph_t *graph,
+                                     igraph_vector_ptr_t *components,
+                                     long int maxcompno, long int minelements);
+
+/**
+ * \function igraph_decompose
+ * \brief Decompose a graph into connected components.
  *
- * </para><para>
- * If you are interested in the size of the largest independent vertex set,
- * use \ref igraph_independence_number() instead.
+ * Create separate graph for each component of a graph. Note that the
+ * vertex ids in the new graphs will be different than in the original
+ * graph. (Except if there is only one component in the original graph.)
+ *
+ * \param graph The original graph.
+ * \param components This pointer vector will contain pointers to the
+ *   subcomponent graphs. It should be initialized before calling this
+ *   function and will be resized to hold the graphs. Don't forget to
+ *   call \ref igraph_destroy() and \ref igraph_free() on the elements of
+ *   this pointer vector to free unneeded memory. Alternatively, you can
+ *   simply call \ref igraph_decompose_destroy() that does this for you.
+ * \param mode Either \c IGRAPH_WEAK or \c IGRAPH_STRONG for weakly
+ *    and strongly connected components respectively.
+ * \param maxcompno The maximum number of components to return. The
+ *    first \p maxcompno components will be returned (which hold at
+ *    least \p minelements vertices, see the next parameter), the
+ *    others will be ignored. Supply -1 here if you don't want to limit
+ *    the number of components.
+ * \param minelements The minimum number of vertices a component
+ *    should contain in order to place it in the \p components
+ *    vector. Eg. supply 2 here to ignore isolated vertices.
+ * \return Error code, \c IGRAPH_ENOMEM if there is not enough memory
+ *   to perform the operation.
  *
- * \param graph The input graph.
- * \param res Pointer to a pointer vector, the result will be stored
- *   here, i.e. \p res will contain pointers to \ref igraph_vector_t
- *   objects which contain the indices of vertices involved in an independent
- *   vertex set. The pointer vector will be resized if needed but note that the
- *   objects in the pointer vector will not be freed.
- * \return Error code.
+ * Added in version 0.2.</para><para>
  *
- * \sa \ref igraph_maximal_cliques(), \ref
- * igraph_independence_number()
+ * Time complexity: O(|V|+|E|), the number of vertices plus the number
+ * of edges.
  *
- * Time complexity: TODO.
+ * \example examples/simple/igraph_decompose.c
  */
-int igraph_maximal_independent_vertex_sets(const igraph_t *graph,
-        igraph_vector_ptr_t *res) {
-    igraph_i_max_ind_vsets_data_t clqdata;
-    igraph_integer_t no_of_nodes = (igraph_integer_t) igraph_vcount(graph), i;
 
-    if (igraph_is_directed(graph)) {
-        IGRAPH_WARNING("directionality of edges is ignored for directed graphs");
-    }
-
-    clqdata.matrix_size = no_of_nodes;
-    clqdata.keep_only_largest = 0;
+int igraph_decompose(const igraph_t *graph, igraph_vector_ptr_t *components,
+                     igraph_connectedness_t mode,
+                     long int maxcompno, long int minelements) {
+    if (mode == IGRAPH_WEAK || !igraph_is_directed(graph)) {
+        return igraph_i_decompose_weak(graph, components, maxcompno, minelements);
+    } else if (mode == IGRAPH_STRONG) {
+        return igraph_i_decompose_strong(graph, components, maxcompno, minelements);
+    }
+
+    IGRAPH_ERROR("Cannot decompose graph", IGRAPH_EINVAL);
+}
+
+static int igraph_i_decompose_weak(const igraph_t *graph,
+                                   igraph_vector_ptr_t *components,
+                                   long int maxcompno, long int minelements) {
+
+    long int actstart;
+    long int no_of_nodes = igraph_vcount(graph);
+    long int resco = 0;   /* number of graphs created so far */
+    char *already_added;
+    igraph_dqueue_t q;
+    igraph_vector_t verts;
+    igraph_vector_t neis;
+    igraph_vector_t vids_old2new;
+    long int i;
+    igraph_t *newg;
 
-    IGRAPH_CHECK(igraph_adjlist_init(
-        graph, &clqdata.adj_list, IGRAPH_ALL, IGRAPH_LOOPS_TWICE, IGRAPH_MULTIPLE
-    ));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &clqdata.adj_list);
 
-    clqdata.IS = IGRAPH_CALLOC(no_of_nodes, igraph_integer_t);
-    if (clqdata.IS == 0) {
-        IGRAPH_ERROR("igraph_maximal_independent_vertex_sets failed", IGRAPH_ENOMEM);
+    if (maxcompno < 0) {
+        maxcompno = LONG_MAX;
     }
-    IGRAPH_FINALLY(igraph_free, clqdata.IS);
 
-    IGRAPH_VECTOR_INIT_FINALLY(&clqdata.deg, no_of_nodes);
-    for (i = 0; i < no_of_nodes; i++) {
-        VECTOR(clqdata.deg)[i] = igraph_vector_int_size(igraph_adjlist_get(&clqdata.adj_list, i));
-    }
+    igraph_vector_ptr_clear(components);
+    IGRAPH_FINALLY(igraph_decompose_destroy, components);
 
-    clqdata.buckets = IGRAPH_CALLOC(no_of_nodes + 1, igraph_set_t);
-    if (clqdata.buckets == 0) {
-        IGRAPH_ERROR("igraph_maximal_independent_vertex_sets failed", IGRAPH_ENOMEM);
+    /* already_added keeps track of what nodes made it into a graph already */
+    already_added = IGRAPH_CALLOC(no_of_nodes, char);
+    if (already_added == 0) {
+        IGRAPH_ERROR("Cannot decompose graph", IGRAPH_ENOMEM);
     }
-    IGRAPH_FINALLY(igraph_i_free_set_array, clqdata.buckets);
+    IGRAPH_FINALLY(igraph_free, already_added);
 
-    for (i = 0; i < no_of_nodes; i++) {
-        IGRAPH_CHECK(igraph_set_init(&clqdata.buckets[i], 0));
-    }
+    IGRAPH_CHECK(igraph_dqueue_init(&q, 100));
+    IGRAPH_FINALLY(igraph_dqueue_destroy, &q);
+    IGRAPH_VECTOR_INIT_FINALLY(&verts, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&vids_old2new, no_of_nodes);
 
-    igraph_vector_ptr_clear(res);
+    /* vids_old2new would have been created internally in igraph_induced_subgraph(),
+       but it is slow if the graph is large and consists of many small components,
+       so we create it once here and then re-use it */
 
-    /* Do the show */
-    clqdata.largest_set_size = 0;
-    IGRAPH_CHECK(igraph_i_maximal_independent_vertex_sets_backtrack(graph, res, &clqdata, 0));
+    /* add a node and its neighbors at once, recursively
+       then switch to next node that has not been added already */
+    for (actstart = 0; resco < maxcompno && actstart < no_of_nodes; actstart++) {
+
+        if (already_added[actstart]) {
+            continue;
+        }
+        IGRAPH_ALLOW_INTERRUPTION();
+
+        igraph_vector_clear(&verts);
+
+        /* add the node itself */
+        already_added[actstart] = 1;
+        IGRAPH_CHECK(igraph_vector_push_back(&verts, actstart));
+        IGRAPH_CHECK(igraph_dqueue_push(&q, actstart));
+
+        /* add the neighbors, recursively */
+        while (!igraph_dqueue_empty(&q) ) {
+            /* pop from the queue of this component */
+            long int actvert = (long int) igraph_dqueue_pop(&q);
+            IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) actvert,
+                                          IGRAPH_ALL));
+            /* iterate over the neighbors */
+            for (i = 0; i < igraph_vector_size(&neis); i++) {
+                long int neighbor = (long int) VECTOR(neis)[i];
+                if (already_added[neighbor] == 1) {
+                    continue;
+                }
+                /* add neighbor */
+                already_added[neighbor] = 1;
+
+                /* recursion: append neighbor to the queues */
+                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+                IGRAPH_CHECK(igraph_vector_push_back(&verts, neighbor));
+            }
+        }
+
+        /* ok, we have a component */
+        if (igraph_vector_size(&verts) < minelements) {
+            continue;
+        }
+
+        newg = IGRAPH_CALLOC(1, igraph_t);
+        if (newg == 0) {
+            IGRAPH_ERROR("Cannot decompose graph", IGRAPH_ENOMEM);
+        }
+        IGRAPH_CHECK(igraph_vector_ptr_push_back(components, newg));
+        IGRAPH_CHECK(igraph_i_induced_subgraph_map(
+            graph, newg, igraph_vss_vector(&verts),
+            IGRAPH_SUBGRAPH_AUTO, &vids_old2new,
+            /* invmap = */ 0, /* map_is_prepared = */ 1
+        ));
+        resco++;
+
+        /* vids_old2new does not have to be cleaned up here; since we are doing
+         * weak decomposition, each vertex will appear in only one of the
+         * connected components so we won't ever touch an item in vids_old2new
+         * if it was already set to a non-zero value in a previous component */
+
+    } /* for actstart++ */
+
+    igraph_vector_destroy(&vids_old2new);
+    igraph_vector_destroy(&neis);
+    igraph_vector_destroy(&verts);
+    igraph_dqueue_destroy(&q);
+    IGRAPH_FREE(already_added);
+    IGRAPH_FINALLY_CLEAN(6);  /* + components */
 
-    /* Cleanup */
-    for (i = 0; i < no_of_nodes; i++) {
-        igraph_set_destroy(&clqdata.buckets[i]);
-    }
-    igraph_adjlist_destroy(&clqdata.adj_list);
-    igraph_vector_destroy(&clqdata.deg);
-    igraph_free(clqdata.IS);
-    igraph_free(clqdata.buckets);
-    IGRAPH_FINALLY_CLEAN(4);
     return 0;
 }
 
-/**
- * \function igraph_independence_number
- * \brief Finds the independence number of the graph.
- *
- * </para><para>
- * The independence number of a graph is the cardinality of the largest
- * independent vertex set.
- *
- * </para><para>
- * The current implementation was ported to igraph from the Very Nauty Graph
- * Library by Keith Briggs and uses the algorithm from the paper
- * S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm
- * for generating all the maximal independent sets. SIAM J Computing,
- * 6:505--517, 1977.
- *
- * \param graph The input graph.
- * \param no The independence number will be returned to the \c
- *   igraph_integer_t pointed by this variable.
- * \return Error code.
- *
- * \sa \ref igraph_independent_vertex_sets().
- *
- * Time complexity: TODO.
- */
-int igraph_independence_number(const igraph_t *graph, igraph_integer_t *no) {
-    igraph_i_max_ind_vsets_data_t clqdata;
-    igraph_integer_t no_of_nodes = (igraph_integer_t) igraph_vcount(graph), i;
+static int igraph_i_decompose_strong(const igraph_t *graph,
+                                     igraph_vector_ptr_t *components,
+                                     long int maxcompno, long int minelements) {
 
-    if (igraph_is_directed(graph)) {
-        IGRAPH_WARNING("directionality of edges is ignored for directed graphs");
-    }
 
-    clqdata.matrix_size = no_of_nodes;
-    clqdata.keep_only_largest = 0;
+    long int no_of_nodes = igraph_vcount(graph);
 
-    IGRAPH_CHECK(igraph_adjlist_init(
-        graph, &clqdata.adj_list, IGRAPH_ALL, IGRAPH_LOOPS_TWICE, IGRAPH_MULTIPLE
-    ));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &clqdata.adj_list);
+    /* this is a heap used twice for checking what nodes have
+     * been counted already */
+    igraph_vector_t next_nei = IGRAPH_VECTOR_NULL;
 
-    clqdata.IS = IGRAPH_CALLOC(no_of_nodes, igraph_integer_t);
-    if (clqdata.IS == 0) {
-        IGRAPH_ERROR("igraph_independence_number failed", IGRAPH_ENOMEM);
-    }
-    IGRAPH_FINALLY(igraph_free, clqdata.IS);
+    long int i, n, num_seen;
+    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
 
-    IGRAPH_VECTOR_INIT_FINALLY(&clqdata.deg, no_of_nodes);
-    for (i = 0; i < no_of_nodes; i++) {
-        VECTOR(clqdata.deg)[i] = igraph_vector_int_size(igraph_adjlist_get(&clqdata.adj_list, i));
-    }
+    long int no_of_clusters = 0;
+    long int act_cluster_size;
 
-    clqdata.buckets = IGRAPH_CALLOC(no_of_nodes + 1, igraph_set_t);
-    if (clqdata.buckets == 0) {
-        IGRAPH_ERROR("igraph_independence_number failed", IGRAPH_ENOMEM);
-    }
-    IGRAPH_FINALLY(igraph_i_free_set_array, clqdata.buckets);
+    igraph_vector_t out = IGRAPH_VECTOR_NULL;
+    const igraph_vector_int_t* tmp;
 
-    for (i = 0; i < no_of_nodes; i++) {
-        IGRAPH_CHECK(igraph_set_init(&clqdata.buckets[i], 0));
+    igraph_adjlist_t adjlist;
+    igraph_vector_t verts;
+    igraph_vector_t vids_old2new;
+    igraph_t *newg;
+
+    if (maxcompno < 0) {
+        maxcompno = LONG_MAX;
     }
 
-    /* Do the show */
-    clqdata.largest_set_size = 0;
-    IGRAPH_CHECK(igraph_i_maximal_independent_vertex_sets_backtrack(graph, 0, &clqdata, 0));
-    *no = clqdata.largest_set_size;
+    igraph_vector_ptr_clear(components);
+    IGRAPH_FINALLY(igraph_decompose_destroy, components);
+
+    /* The result */
+
+    IGRAPH_VECTOR_INIT_FINALLY(&vids_old2new, no_of_nodes);
+    IGRAPH_VECTOR_INIT_FINALLY(&verts, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&next_nei, no_of_nodes);
+    IGRAPH_VECTOR_INIT_FINALLY(&out, 0);
+    IGRAPH_DQUEUE_INIT_FINALLY(&q, 100);
+
+    IGRAPH_CHECK(igraph_vector_reserve(&out, no_of_nodes));
+
+    igraph_vector_null(&out);
+
+    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
+    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
 
-    /* Cleanup */
+    /* vids_old2new would have been created internally in igraph_induced_subgraph(),
+       but it is slow if the graph is large and consists of many small components,
+       so we create it once here and then re-use it */
+
+    /* number of components seen */
+    num_seen = 0;
+    /* populate the 'out' vector by browsing a node and following up
+       all its neighbors recursively, then switching to the next
+       unassigned node */
     for (i = 0; i < no_of_nodes; i++) {
-        igraph_set_destroy(&clqdata.buckets[i]);
-    }
-    igraph_adjlist_destroy(&clqdata.adj_list);
-    igraph_vector_destroy(&clqdata.deg);
-    igraph_free(clqdata.IS);
-    igraph_free(clqdata.buckets);
-    IGRAPH_FINALLY_CLEAN(4);
+        IGRAPH_ALLOW_INTERRUPTION();
 
-    return 0;
-}
+        /* get all the 'out' neighbors of this node
+         * NOTE: next_nei is initialized [0, 0, ...] */
+        tmp = igraph_adjlist_get(&adjlist, i);
+        if (VECTOR(next_nei)[i] > igraph_vector_int_size(tmp)) {
+            continue;
+        }
 
-/*************************************************************************/
-/* MAXIMAL CLIQUES, LARGEST CLIQUES                                      */
-/*************************************************************************/
-
-static int igraph_i_maximal_cliques_store_max_size(const igraph_vector_t* clique, void* data,
-                                                   igraph_bool_t* cont) {
-    igraph_integer_t* result = (igraph_integer_t*)data;
-    IGRAPH_UNUSED(cont);
-    if (*result < igraph_vector_size(clique)) {
-        *result = (igraph_integer_t) igraph_vector_size(clique);
-    }
-    return IGRAPH_SUCCESS;
-}
+        /* add this node to the queue for this component */
+        IGRAPH_CHECK(igraph_dqueue_push(&q, i));
 
-/*
-static int igraph_i_maximal_cliques_store(const igraph_vector_t* clique, void* data, igraph_bool_t* cont) {
-    igraph_vector_ptr_t* result = (igraph_vector_ptr_t*)data;
-    igraph_vector_t* vec;
-
-    IGRAPH_UNUSED(cont);
-    vec = IGRAPH_CALLOC(1, igraph_vector_t);
-    if (vec == 0) {
-        IGRAPH_ERROR("cannot allocate memory for storing next clique", IGRAPH_ENOMEM);
-    }
+        /* consume the tree from this node ("root") recursively
+         * until there is no more */
+        while (!igraph_dqueue_empty(&q)) {
+            /* this looks up but does NOT consume the queue */
+            long int act_node = (long int) igraph_dqueue_back(&q);
+
+            /* get all neighbors of this node */
+            tmp = igraph_adjlist_get(&adjlist, act_node);
+            if (VECTOR(next_nei)[act_node] == 0) {
+                /* this is the first time we've met this vertex,
+                     * because next_nei is initialized [0, 0, ...] */
+                VECTOR(next_nei)[act_node]++;
+                /* back to the queue, same vertex is up again */
+
+            } else if (VECTOR(next_nei)[act_node] <= igraph_vector_int_size(tmp)) {
+                /* we've already met this vertex but it has more children */
+                long int neighbor = (long int) VECTOR(*tmp)[(long int)
+                                    VECTOR(next_nei)[act_node] - 1];
+                if (VECTOR(next_nei)[neighbor] == 0) {
+                    /* add the root of the other children to the queue */
+                    IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+                }
+                VECTOR(next_nei)[act_node]++;
+            } else {
+                /* we've met this vertex and it has no more children */
+                IGRAPH_CHECK(igraph_vector_push_back(&out, act_node));
+                /* this consumes the queue, since there's nowhere to go */
+                igraph_dqueue_pop_back(&q);
+                num_seen++;
+
+                if (num_seen % 10000 == 0) {
+                    /* time to report progress and allow the user to interrupt */
+                    IGRAPH_PROGRESS("Strongly connected components: ",
+                                    num_seen * 50.0 / no_of_nodes, NULL);
+                    IGRAPH_ALLOW_INTERRUPTION();
+                }
+            }
+        } /* while q */
+    }  /* for */
 
-    IGRAPH_CHECK(igraph_vector_copy(vec, clique));
-    IGRAPH_CHECK(igraph_vector_ptr_push_back(result, vec));
+    IGRAPH_PROGRESS("Strongly connected components: ", 50.0, NULL);
 
-    return IGRAPH_SUCCESS;
-}
+    igraph_adjlist_destroy(&adjlist);
+    IGRAPH_FINALLY_CLEAN(1);
 
-static int igraph_i_maximal_cliques_store_size_check(const igraph_vector_t* clique, void* data_, igraph_bool_t* cont) {
-    igraph_i_maximal_clique_data_t* data = (igraph_i_maximal_clique_data_t*)data_;
-    igraph_vector_t* vec;
-    igraph_integer_t size = (igraph_integer_t) igraph_vector_size(clique);
+    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_IN, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
+    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
 
-    IGRAPH_UNUSED(cont);
-    if (size < data->min_size || size > data->max_size) {
-        return IGRAPH_SUCCESS;
-    }
+    /* OK, we've the 'out' values for the nodes, let's use them in
+     * decreasing order with the help of the next_nei heap */
 
-    vec = IGRAPH_CALLOC(1, igraph_vector_t);
-    if (vec == 0) {
-        IGRAPH_ERROR("cannot allocate memory for storing next clique", IGRAPH_ENOMEM);
-    }
+    igraph_vector_null(&next_nei);             /* mark already added vertices */
 
-    IGRAPH_CHECK(igraph_vector_copy(vec, clique));
-    IGRAPH_CHECK(igraph_vector_ptr_push_back(data->result, vec));
+    /* number of components built */
+    num_seen = 0;
+    while (!igraph_vector_empty(&out) && no_of_clusters < maxcompno) {
+        /* consume the vector from the last element */
+        long int grandfather = (long int) igraph_vector_pop_back(&out);
+
+        /* been here, done that
+         * NOTE: next_nei is initialized as [0, 0, ...] */
+        if (VECTOR(next_nei)[grandfather] != 0) {
+            continue;
+        }
 
-    return IGRAPH_SUCCESS;
-}
-*/
+        /* collect all the members of this component */
+        igraph_vector_clear(&verts);
 
-static int igraph_i_largest_cliques_store(const igraph_vector_t* clique, void* data, igraph_bool_t* cont) {
-    igraph_vector_ptr_t* result = (igraph_vector_ptr_t*)data;
-    igraph_vector_t* vec;
-    long int i, n;
-
-    IGRAPH_UNUSED(cont);
-    /* Is the current clique at least as large as the others that we have found? */
-    if (!igraph_vector_ptr_empty(result)) {
-        n = igraph_vector_size(clique);
-        if (n < igraph_vector_size(VECTOR(*result)[0])) {
-            return IGRAPH_SUCCESS;
+        /* this node is gone for any future components */
+        VECTOR(next_nei)[grandfather] = 1;
+        act_cluster_size = 1;
+
+        /* add to component */
+        IGRAPH_CHECK(igraph_vector_push_back(&verts, grandfather));
+        IGRAPH_CHECK(igraph_dqueue_push(&q, grandfather));
+
+        num_seen++;
+        if (num_seen % 10000 == 0) {
+            /* time to report progress and allow the user to interrupt */
+            IGRAPH_PROGRESS("Strongly connected components: ",
+                            50.0 + num_seen * 50.0 / no_of_nodes, NULL);
+            IGRAPH_ALLOW_INTERRUPTION();
         }
 
-        if (n > igraph_vector_size(VECTOR(*result)[0])) {
-            for (i = 0; i < igraph_vector_ptr_size(result); i++) {
-                igraph_vector_destroy(VECTOR(*result)[i]);
+        while (!igraph_dqueue_empty(&q)) {
+            /* consume the queue from this node */
+            long int act_node = (long int) igraph_dqueue_pop_back(&q);
+            tmp = igraph_adjlist_get(&adjlist, act_node);
+            n = igraph_vector_int_size(tmp);
+            for (i = 0; i < n; i++) {
+                long int neighbor = (long int) VECTOR(*tmp)[i];
+                if (VECTOR(next_nei)[neighbor] != 0) {
+                    continue;
+                }
+                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+                VECTOR(next_nei)[neighbor] = 1;
+                act_cluster_size++;
+
+                /* add to component */
+                IGRAPH_CHECK(igraph_vector_push_back(&verts, neighbor));
+
+                num_seen++;
+                if (num_seen % 10000 == 0) {
+                    /* time to report progress and allow the user to interrupt */
+                    IGRAPH_PROGRESS("Strongly connected components: ",
+                                    50.0 + num_seen * 50.0 / no_of_nodes, NULL);
+                    IGRAPH_ALLOW_INTERRUPTION();
+                }
             }
-            igraph_vector_ptr_free_all(result);
-            igraph_vector_ptr_resize(result, 0);
         }
-    }
 
-    vec = IGRAPH_CALLOC(1, igraph_vector_t);
-    if (vec == 0) {
-        IGRAPH_ERROR("cannot allocate memory for storing next clique", IGRAPH_ENOMEM);
+        /* ok, we have a component */
+        if (igraph_vector_size(&verts) < minelements) {
+            continue;
+        }
+
+        newg = IGRAPH_CALLOC(1, igraph_t);
+        if (newg == 0) {
+            IGRAPH_ERROR("Cannot decompose graph", IGRAPH_ENOMEM);
+        }
+        IGRAPH_CHECK(igraph_vector_ptr_push_back(components, newg));
+        IGRAPH_CHECK(igraph_i_induced_subgraph_map(
+            graph, newg, igraph_vss_vector(&verts),
+            IGRAPH_SUBGRAPH_AUTO, &vids_old2new,
+            /* invmap = */ 0, /* map_is_prepared = */ 1
+        ));
+
+        /* vids_old2new has to be cleaned up here because a vertex may appear
+         * in multiple strongly connected components. Simply calling
+         * igraph_vector_fill() would be an O(n) operation where n is the number
+         * of vertices in the large graph so we cannot do that; we have to
+         * iterate over 'verts' instead */
+        n = igraph_vector_size(&verts);
+        for (i = 0; i < n; i++) {
+            VECTOR(vids_old2new)[(igraph_integer_t) VECTOR(verts)[i]] = 0;
+        }
+
+        no_of_clusters++;
     }
 
-    IGRAPH_CHECK(igraph_vector_copy(vec, clique));
-    IGRAPH_CHECK(igraph_vector_ptr_push_back(result, vec));
+    IGRAPH_PROGRESS("Strongly connected components: ", 100.0, NULL);
+
+    /* Clean up, return */
+
+    igraph_vector_destroy(&vids_old2new);
+    igraph_vector_destroy(&verts);
+    igraph_adjlist_destroy(&adjlist);
+    igraph_vector_destroy(&out);
+    igraph_dqueue_destroy(&q);
+    igraph_vector_destroy(&next_nei);
+    IGRAPH_FINALLY_CLEAN(7);  /* + components */
+
+    return 0;
 
-    return IGRAPH_SUCCESS;
 }
 
 /**
- * \function igraph_largest_cliques
- * \brief Finds the largest clique(s) in a graph.
- *
- * </para><para>
- * A clique is largest (quite intuitively) if there is no other clique
- * in the graph which contains more vertices.
- *
- * </para><para>
- * Note that this is not necessarily the same as a maximal clique,
- * i.e. the largest cliques are always maximal but a maximal clique is
- * not always largest.
- *
- * </para><para>The current implementation of this function searches
- * for maximal cliques using \ref igraph_maximal_cliques() and drops
- * those that are not the largest.
- *
- * </para><para>The implementation of this function changed between
- * igraph 0.5 and 0.6, so the order of the cliques and the order of
- * vertices within the cliques will almost surely be different between
- * these two versions.
+ * \function igraph_articulation_points
+ * Find the articulation points in a graph.
  *
+ * A vertex is an articulation point if its removal increases
+ * the number of connected components in the graph.
  * \param graph The input graph.
- * \param res Pointer to an initialized pointer vector, the result
- *        will be stored here. It will be resized as needed. Note that
- *        vertices of a clique may be returned in arbitrary order.
+ * \param res Pointer to an initialized vector, the
+ *    articulation points will be stored here.
  * \return Error code.
  *
- * \sa \ref igraph_cliques(), \ref igraph_maximal_cliques()
+ * Time complexity: O(|V|+|E|), linear in the number of vertices and edges.
  *
- * Time complexity: O(3^(|V|/3)) worst case.
+ * \sa \ref igraph_biconnected_components(), \ref igraph_clusters(), \ref igraph_bridges()
  */
 
-int igraph_largest_cliques(const igraph_t *graph, igraph_vector_ptr_t *res) {
-    igraph_vector_ptr_clear(res);
-    IGRAPH_FINALLY(igraph_i_cliques_free_res, res);
-    IGRAPH_CHECK(igraph_i_maximal_cliques(graph, &igraph_i_largest_cliques_store, (void*)res));
-    IGRAPH_FINALLY_CLEAN(1);
-    return IGRAPH_SUCCESS;
+int igraph_articulation_points(const igraph_t *graph,
+                               igraph_vector_t *res) {
+
+    igraph_integer_t no;
+    return igraph_biconnected_components(graph, &no, 0, 0, 0, res);
+}
+
+void igraph_i_free_vectorlist(igraph_vector_ptr_t *list);
+
+void igraph_i_free_vectorlist(igraph_vector_ptr_t *list) {
+    long int i, n = igraph_vector_ptr_size(list);
+    for (i = 0; i < n; i++) {
+        igraph_vector_t *v = VECTOR(*list)[i];
+        if (v) {
+            igraph_vector_destroy(v);
+            IGRAPH_FREE(v);
+        }
+    }
+    igraph_vector_ptr_destroy(list);
 }
 
 /**
- * \function igraph_clique_number
- * \brief Finds the clique number of the graph.
+ * \function igraph_biconnected_components
+ * Calculate biconnected components
+ *
+ * A graph is biconnected if the removal of any single vertex (and
+ * its incident edges) does not disconnect it.
  *
  * </para><para>
- * The clique number of a graph is the size of the largest clique.
+ * A biconnected component of a graph is a maximal biconnected
+ * subgraph of it. The biconnected components of a graph can be given
+ * by the partition of its edges: every edge is a member of exactly
+ * one biconnected component. Note that this is not true for
+ * vertices: the same vertex can be part of many biconnected
+ * components.
+ *
+ * </para><para>
+ * Somewhat arbitrarily, igraph does not consider components containing
+ * a single vertex only as being biconnected. Isolated vertices will
+ * not be part of any of the biconnected components.
  *
  * \param graph The input graph.
- * \param no The clique number will be returned to the \c igraph_integer_t
- *   pointed by this variable.
+ * \param no The number of biconnected components will be stored here.
+ * \param tree_edges If not a NULL pointer, then the found components
+ *     are stored here, in a list of vectors. Every vector in the list
+ *     is a biconnected component, represented by its edges. More precisely,
+ *     a spanning tree of the biconnected component is returned.
+ *     Note you'll have to
+ *     destroy each vector first by calling \ref igraph_vector_destroy()
+ *     and then \ref igraph_free() on it, plus you need to call
+ *     \ref igraph_vector_ptr_destroy() on the list to regain all
+ *     allocated memory.
+ * \param component_edges If not a NULL pointer, then the edges of the
+ *     biconnected components are stored here, in the same form as for
+ *     \c tree_edges.
+ * \param components If not a NULL pointer, then the vertices of the
+ *     biconnected components are stored here, in the same format as
+ *     for the previous two arguments.
+ * \param articulation_points If not a NULL pointer, then the
+ *     articulation points of the graph are stored in this vector.
+ *     A vertex is an articulation point if its removal increases the
+ *     number of (weakly) connected components in the graph.
  * \return Error code.
  *
- * \sa \ref igraph_cliques(), \ref igraph_largest_cliques().
+ * Time complexity: O(|V|+|E|), linear in the number of vertices and
+ * edges, but only if you do not calculate \c components and
+ * \c component_edges. If you calculate \c components, then it is
+ * quadratic in the number of vertices. If you calculate \c
+ * component_edges as well, then it is cubic in the number of
+ * vertices.
+ *
+ * \sa \ref igraph_articulation_points(), \ref igraph_clusters().
  *
- * Time complexity: O(3^(|V|/3)) worst case.
+ * \example examples/simple/igraph_biconnected_components.c
  */
-int igraph_clique_number(const igraph_t *graph, igraph_integer_t *no) {
-    *no = 0;
-    return igraph_i_maximal_cliques(graph, &igraph_i_maximal_cliques_store_max_size, (void*)no);
-}
 
-typedef struct {
-    igraph_vector_int_t cand;
-    igraph_vector_int_t fini;
-    igraph_vector_int_t cand_filtered;
-} igraph_i_maximal_cliques_stack_frame;
-
-static void igraph_i_maximal_cliques_stack_frame_destroy(igraph_i_maximal_cliques_stack_frame *frame) {
-    igraph_vector_int_destroy(&frame->cand);
-    igraph_vector_int_destroy(&frame->fini);
-    igraph_vector_int_destroy(&frame->cand_filtered);
-}
-
-static void igraph_i_maximal_cliques_stack_destroy(igraph_stack_ptr_t *stack) {
-    igraph_i_maximal_cliques_stack_frame *frame;
-
-    while (!igraph_stack_ptr_empty(stack)) {
-        frame = (igraph_i_maximal_cliques_stack_frame*)igraph_stack_ptr_pop(stack);
-        igraph_i_maximal_cliques_stack_frame_destroy(frame);
-        free(frame);
+int igraph_biconnected_components(const igraph_t *graph,
+                                  igraph_integer_t *no,
+                                  igraph_vector_ptr_t *tree_edges,
+                                  igraph_vector_ptr_t *component_edges,
+                                  igraph_vector_ptr_t *components,
+                                  igraph_vector_t *articulation_points) {
+
+    long int no_of_nodes = igraph_vcount(graph);
+    igraph_vector_long_t nextptr;
+    igraph_vector_long_t num, low;
+    igraph_vector_bool_t found;
+    igraph_vector_int_t *adjedges;
+    igraph_stack_t path;
+    igraph_vector_t edgestack;
+    igraph_inclist_t inclist;
+    long int i, counter, rootdfs = 0;
+    igraph_vector_long_t vertex_added;
+    long int comps = 0;
+    igraph_vector_ptr_t *mycomponents = components, vcomponents;
+
+    IGRAPH_CHECK(igraph_vector_long_init(&nextptr, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &nextptr);
+    IGRAPH_CHECK(igraph_vector_long_init(&num, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &num);
+    IGRAPH_CHECK(igraph_vector_long_init(&low, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &low);
+    IGRAPH_CHECK(igraph_vector_bool_init(&found, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_bool_destroy, &found);
+
+    IGRAPH_CHECK(igraph_stack_init(&path, 100));
+    IGRAPH_FINALLY(igraph_stack_destroy, &path);
+    IGRAPH_VECTOR_INIT_FINALLY(&edgestack, 0);
+    IGRAPH_CHECK(igraph_vector_reserve(&edgestack, 100));
+
+    IGRAPH_CHECK(igraph_inclist_init(graph, &inclist, IGRAPH_ALL, IGRAPH_LOOPS_TWICE));
+    IGRAPH_FINALLY(igraph_inclist_destroy, &inclist);
+
+    IGRAPH_CHECK(igraph_vector_long_init(&vertex_added, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &vertex_added);
+
+    if (no) {
+        *no = 0;
+    }
+    if (tree_edges) {
+        igraph_vector_ptr_clear(tree_edges);
+    }
+    if (components) {
+        igraph_vector_ptr_clear(components);
+    }
+    if (component_edges) {
+        igraph_vector_ptr_clear(component_edges);
+    }
+    if (articulation_points) {
+        igraph_vector_clear(articulation_points);
+    }
+    if (component_edges && !components) {
+        mycomponents = &vcomponents;
+        IGRAPH_CHECK(igraph_vector_ptr_init(mycomponents, 0));
+        IGRAPH_FINALLY(igraph_i_free_vectorlist, mycomponents);
     }
 
-    igraph_stack_ptr_destroy(stack);
-}
+    for (i = 0; i < no_of_nodes; i++) {
 
-static int igraph_i_maximal_cliques(const igraph_t *graph, igraph_i_maximal_clique_func_t func, void* data) {
-    int directed = igraph_is_directed(graph);
-    long int i, j, k, l;
-    igraph_integer_t no_of_nodes, nodes_to_check, nodes_done;
-    igraph_integer_t best_cand = 0, best_cand_degree = 0, best_fini_cand_degree;
-    igraph_adjlist_t adj_list;
-    igraph_stack_ptr_t stack;
-    igraph_i_maximal_cliques_stack_frame frame, *new_frame_ptr;
-    igraph_vector_t clique;
-    igraph_vector_int_t new_cand, new_fini, cn, best_cand_nbrs,
-                        best_fini_cand_nbrs;
-    igraph_bool_t cont = 1;
-    igraph_bool_t found;
+        if (VECTOR(low)[i] != 0) {
+            continue;    /* already visited */
+        }
 
-    if (directed) {
-        IGRAPH_WARNING("directionality of edges is ignored for directed graphs");
-    }
+        IGRAPH_ALLOW_INTERRUPTION();
 
-    no_of_nodes = igraph_vcount(graph);
-    if (no_of_nodes == 0) {
-        return IGRAPH_SUCCESS;
-    }
+        IGRAPH_CHECK(igraph_stack_push(&path, i));
+        counter = 1;
+        rootdfs = 0;
+        VECTOR(low)[i] = VECTOR(num)[i] = counter++;
+        while (!igraph_stack_empty(&path)) {
+            long int n;
+            long int act = (long int) igraph_stack_top(&path);
+            long int actnext = VECTOR(nextptr)[act];
+
+            adjedges = igraph_inclist_get(&inclist, act);
+            n = igraph_vector_int_size(adjedges);
+            if (actnext < n) {
+                /* Step down (maybe) */
+                long int edge = (long int) VECTOR(*adjedges)[actnext];
+                long int nei = IGRAPH_OTHER(graph, edge, act);
+                if (VECTOR(low)[nei] == 0) {
+                    if (act == i) {
+                        rootdfs++;
+                    }
+                    IGRAPH_CHECK(igraph_vector_push_back(&edgestack, edge));
+                    IGRAPH_CHECK(igraph_stack_push(&path, nei));
+                    VECTOR(low)[nei] = VECTOR(num)[nei] = counter++;
+                } else {
+                    /* Update low value if needed */
+                    if (VECTOR(num)[nei] < VECTOR(low)[act]) {
+                        VECTOR(low)[act] = VECTOR(num)[nei];
+                    }
+                }
+                VECTOR(nextptr)[act] += 1;
+            } else {
+                /* Step up */
+                igraph_stack_pop(&path);
+                if (!igraph_stack_empty(&path)) {
+                    long int prev = (long int) igraph_stack_top(&path);
+                    /* Update LOW value if needed */
+                    if (VECTOR(low)[act] < VECTOR(low)[prev]) {
+                        VECTOR(low)[prev] = VECTOR(low)[act];
+                    }
+                    /* Check for articulation point */
+                    if (VECTOR(low)[act] >= VECTOR(num)[prev]) {
+                        if (articulation_points && !VECTOR(found)[prev]
+                            && prev != i /* the root */) {
+                            IGRAPH_CHECK(igraph_vector_push_back(articulation_points, prev));
+                            VECTOR(found)[prev] = 1;
+                        }
+                        if (no) {
+                            *no += 1;
+                        }
 
-    /* Construct an adjacency list representation */
-    IGRAPH_CHECK(igraph_adjlist_init(
-        graph, &adj_list, IGRAPH_ALL, IGRAPH_NO_LOOPS, IGRAPH_NO_MULTIPLE
-    ));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &adj_list);
-    igraph_adjlist_sort(&adj_list);
-
-    /* Initialize stack */
-    IGRAPH_CHECK(igraph_stack_ptr_init(&stack, 0));
-    IGRAPH_FINALLY(igraph_i_maximal_cliques_stack_destroy, &stack);
-
-    /* Create the initial (empty) clique */
-    IGRAPH_VECTOR_INIT_FINALLY(&clique, 0);
-
-    /* Initialize new_cand, new_fini, cn, best_cand_nbrs and best_fini_cand_nbrs (will be used later) */
-    igraph_vector_int_init(&new_cand, 0);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &new_cand);
-    igraph_vector_int_init(&new_fini, 0);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &new_fini);
-    igraph_vector_int_init(&cn, 0);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &cn);
-    igraph_vector_int_init(&best_cand_nbrs, 0);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &best_cand_nbrs);
-    igraph_vector_int_init(&best_fini_cand_nbrs, 0);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &best_fini_cand_nbrs);
-
-    /* Find the vertex with the highest degree */
-    best_cand = 0; best_cand_degree = (igraph_integer_t) igraph_vector_int_size(igraph_adjlist_get(&adj_list, 0));
-    for (i = 1; i < no_of_nodes; i++) {
-        j = igraph_vector_int_size(igraph_adjlist_get(&adj_list, i));
-        if (j > best_cand_degree) {
-            best_cand = (igraph_integer_t) i;
-            best_cand_degree = (igraph_integer_t) j;
-        }
-    }
+                        /*------------------------------------*/
+                        /* Record the biconnected component just found */
+                        if (tree_edges || mycomponents) {
+                            igraph_vector_t *v = 0, *v2 = 0;
+                            comps++;
+                            if (tree_edges) {
+                                v = IGRAPH_CALLOC(1, igraph_vector_t);
+                                if (!v) {
+                                    IGRAPH_ERROR("Out of memory", IGRAPH_ENOMEM);
+                                }
+                                IGRAPH_CHECK(igraph_vector_init(v, 0));
+                                IGRAPH_FINALLY(igraph_vector_destroy, v);
+                            }
+                            if (mycomponents) {
+                                v2 = IGRAPH_CALLOC(1, igraph_vector_t);
+                                if (!v2) {
+                                    IGRAPH_ERROR("Out of memory", IGRAPH_ENOMEM);
+                                }
+                                IGRAPH_CHECK(igraph_vector_init(v2, 0));
+                                IGRAPH_FINALLY(igraph_vector_destroy, v2);
+                            }
 
-    /* Create the initial stack frame */
-    IGRAPH_CHECK(igraph_vector_int_init_seq(&frame.cand, 0, no_of_nodes - 1));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &frame.cand);
-    IGRAPH_CHECK(igraph_vector_int_init(&frame.fini, 0));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &frame.fini);
-    IGRAPH_CHECK(igraph_vector_int_init(&frame.cand_filtered, 0));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &frame.cand_filtered);
-    IGRAPH_CHECK(igraph_vector_int_difference_sorted(&frame.cand,
-                 igraph_adjlist_get(&adj_list, best_cand), &frame.cand_filtered));
-    IGRAPH_FINALLY_CLEAN(3);
-    IGRAPH_FINALLY(igraph_i_maximal_cliques_stack_frame_destroy, &frame);
+                            while (!igraph_vector_empty(&edgestack)) {
+                                long int e = (long int) igraph_vector_pop_back(&edgestack);
+                                long int from = IGRAPH_FROM(graph, e);
+                                long int to = IGRAPH_TO(graph, e);
+                                if (tree_edges) {
+                                    IGRAPH_CHECK(igraph_vector_push_back(v, e));
+                                }
+                                if (mycomponents) {
+                                    if (VECTOR(vertex_added)[from] != comps) {
+                                        VECTOR(vertex_added)[from] = comps;
+                                        IGRAPH_CHECK(igraph_vector_push_back(v2, from));
+                                    }
+                                    if (VECTOR(vertex_added)[to] != comps) {
+                                        VECTOR(vertex_added)[to] = comps;
+                                        IGRAPH_CHECK(igraph_vector_push_back(v2, to));
+                                    }
+                                }
+                                if (from == prev || to == prev) {
+                                    break;
+                                }
+                            }
 
-    /* TODO: frame.cand and frame.fini should be a set instead of a vector */
+                            if (mycomponents) {
+                                IGRAPH_CHECK(igraph_vector_ptr_push_back(mycomponents, v2));
+                                IGRAPH_FINALLY_CLEAN(1);
+                            }
+                            if (tree_edges) {
+                                IGRAPH_CHECK(igraph_vector_ptr_push_back(tree_edges, v));
+                                IGRAPH_FINALLY_CLEAN(1);
+                            }
+                            if (component_edges) {
+                                igraph_vector_t *nodes = VECTOR(*mycomponents)[comps - 1];
+                                igraph_vector_t *vv = IGRAPH_CALLOC(1, igraph_vector_t);
+                                long int ii, no_vert = igraph_vector_size(nodes);
+                                if (!vv) {
+                                    IGRAPH_ERROR("Out of memory", IGRAPH_ENOMEM);
+                                }
+                                IGRAPH_CHECK(igraph_vector_init(vv, 0));
+                                IGRAPH_FINALLY(igraph_vector_destroy, vv);
+                                for (ii = 0; ii < no_vert; ii++) {
+                                    long int vert = (long int) VECTOR(*nodes)[ii];
+                                    igraph_vector_int_t *edges = igraph_inclist_get(&inclist,
+                                                                 vert);
+                                    long int j, nn = igraph_vector_int_size(edges);
+                                    for (j = 0; j < nn; j++) {
+                                        long int e = (long int) VECTOR(*edges)[j];
+                                        long int nei = IGRAPH_OTHER(graph, e, vert);
+                                        if (VECTOR(vertex_added)[nei] == comps && nei < vert) {
+                                            IGRAPH_CHECK(igraph_vector_push_back(vv, e));
+                                        }
+                                    }
+                                }
+                                IGRAPH_CHECK(igraph_vector_ptr_push_back(component_edges, vv));
+                                IGRAPH_FINALLY_CLEAN(1);
+                            }
+                        } /* record component if requested */
+                        /*------------------------------------*/
 
-    /* Main loop starts here */
-    nodes_to_check = (igraph_integer_t) igraph_vector_int_size(&frame.cand_filtered); nodes_done = 0;
-    while (!igraph_vector_int_empty(&frame.cand_filtered) || !igraph_stack_ptr_empty(&stack)) {
-        if (igraph_vector_int_empty(&frame.cand_filtered)) {
-            /* No candidates left to check in this stack frame, pop out the previous stack frame */
-            igraph_i_maximal_cliques_stack_frame *newframe = igraph_stack_ptr_pop(&stack);
-            igraph_i_maximal_cliques_stack_frame_destroy(&frame);
-            frame = *newframe;
-            free(newframe);
-
-            if (igraph_stack_ptr_size(&stack) == 1) {
-                /* We will be using the next candidate node in the next iteration, so we can increase
-                 * nodes_done by 1 */
-                nodes_done++;
+                    }
+                } /* !igraph_stack_empty(&path) */
             }
 
-            /* For efficiency reasons, we only check for interruption and show progress here */
-            IGRAPH_PROGRESS("Maximal cliques: ", 100.0 * nodes_done / nodes_to_check, NULL);
-            IGRAPH_ALLOW_INTERRUPTION();
+        } /* !igraph_stack_empty(&path) */
 
-            igraph_vector_pop_back(&clique);
-            continue;
+        if (articulation_points && rootdfs >= 2) {
+            IGRAPH_CHECK(igraph_vector_push_back(articulation_points, i));
         }
 
-        /* Try the next node in the clique */
-        i = (long int) igraph_vector_int_pop_back(&frame.cand_filtered);
-        IGRAPH_CHECK(igraph_vector_push_back(&clique, i));
-
-        /* Remove the node from the candidate list */
-        found = igraph_vector_int_binsearch(&frame.cand, i, &j); IGRAPH_ASSERT(found);
-        igraph_vector_int_remove(&frame.cand, j);
-
-        /* Add the node to the finished list */
-        found = igraph_vector_int_binsearch(&frame.fini, i, &j); IGRAPH_ASSERT(!found);
-        IGRAPH_CHECK(igraph_vector_int_insert(&frame.fini, j, i));
-
-        /* Create new_cand and new_fini */
-        IGRAPH_CHECK(igraph_vector_int_intersect_sorted(&frame.cand, igraph_adjlist_get(&adj_list, i), &new_cand));
-        IGRAPH_CHECK(igraph_vector_int_intersect_sorted(&frame.fini, igraph_adjlist_get(&adj_list, i), &new_fini));
-
-        /* Do we have anything more to search? */
-        if (igraph_vector_int_empty(&new_cand)) {
-            if (igraph_vector_int_empty(&new_fini)) {
-                /* We have a maximal clique here */
-                IGRAPH_CHECK(func(&clique, data, &cont));
-                if (!cont) {
-                    /* The callback function requested to stop the search */
-                    break;
-                }
-            }
-            igraph_vector_pop_back(&clique);
-            continue;
-        }
-        if (igraph_vector_int_empty(&new_fini) &&
-            igraph_vector_int_size(&new_cand) == 1) {
-            /* Shortcut: only one node left */
-            IGRAPH_CHECK(igraph_vector_push_back(&clique, VECTOR(new_cand)[0]));
-            IGRAPH_CHECK(func(&clique, data, &cont));
-            if (!cont) {
-                /* The callback function requested to stop the search */
-                break;
-            }
-            igraph_vector_pop_back(&clique);
-            igraph_vector_pop_back(&clique);
-            continue;
-        }
+    } /* i < no_of_nodes */
 
-        /* Find the next best candidate node in new_fini */
-        l = igraph_vector_int_size(&new_cand);
-        best_cand_degree = -1;
-        j = igraph_vector_int_size(&new_fini);
-        for (i = 0; i < j; i++) {
-            k = (long int)VECTOR(new_fini)[i];
-            IGRAPH_CHECK(igraph_vector_int_intersect_sorted(&new_cand, igraph_adjlist_get(&adj_list, k), &cn));
-            if (igraph_vector_int_size(&cn) > best_cand_degree) {
-                best_cand_degree = (igraph_integer_t) igraph_vector_int_size(&cn);
-                IGRAPH_CHECK(igraph_vector_int_update(&best_fini_cand_nbrs, &cn));
-                if (best_cand_degree == l) {
-                    /* Cool, we surely have the best candidate node here as best_cand_degree can't get any better */
-                    break;
-                }
-            }
-        }
-        /* Shortcut here: we don't have to examine new_cand */
-        if (best_cand_degree == l) {
-            igraph_vector_pop_back(&clique);
-            continue;
-        }
-        /* Still finding best candidate node */
-        best_fini_cand_degree = best_cand_degree;
-        best_cand_degree = -1;
-        j = igraph_vector_int_size(&new_cand);
-        l = l - 1;
-        for (i = 0; i < j; i++) {
-            k = (long int)VECTOR(new_cand)[i];
-            IGRAPH_CHECK(igraph_vector_int_intersect_sorted(&new_cand, igraph_adjlist_get(&adj_list, k), &cn));
-            if (igraph_vector_int_size(&cn) > best_cand_degree) {
-                best_cand_degree = (igraph_integer_t) igraph_vector_int_size(&cn);
-                IGRAPH_CHECK(igraph_vector_int_update(&best_cand_nbrs, &cn));
-                if (best_cand_degree == l) {
-                    /* Cool, we surely have the best candidate node here as best_cand_degree can't get any better */
-                    break;
-                }
+    if (mycomponents != components) {
+        igraph_i_free_vectorlist(mycomponents);
+        IGRAPH_FINALLY_CLEAN(1);
+    }
+
+    igraph_vector_long_destroy(&vertex_added);
+    igraph_inclist_destroy(&inclist);
+    igraph_vector_destroy(&edgestack);
+    igraph_stack_destroy(&path);
+    igraph_vector_bool_destroy(&found);
+    igraph_vector_long_destroy(&low);
+    igraph_vector_long_destroy(&num);
+    igraph_vector_long_destroy(&nextptr);
+    IGRAPH_FINALLY_CLEAN(8);
+
+    return 0;
+}
+
+
+/* igraph_bridges -- find all bridges in the graph */
+/* The algorithm is based on https://www.geeksforgeeks.org/bridge-in-a-graph/
+   but instead of keeping track of the parent of each vertex in the DFS tree
+   we keep track of its incoming edge. This is necessary to support multigraphs. */
+
+static int igraph_i_bridges_rec(
+        const igraph_t *graph, const igraph_inclist_t *il, igraph_integer_t u,
+        igraph_integer_t *time, igraph_vector_t *bridges, igraph_vector_bool_t *visited,
+        igraph_vector_int_t *disc, igraph_vector_int_t *low, igraph_vector_int_t *incoming_edge)
+{
+    igraph_vector_int_t *incedges;
+    long nc; /* neighbour count */
+    long i;
+
+    VECTOR(*visited)[u] = 1;
+
+    *time += 1;
+
+    VECTOR(*disc)[u] = *time;
+    VECTOR(*low)[u] = *time;
+
+    incedges = igraph_inclist_get(il, u);
+    nc = igraph_vector_int_size(incedges);
+    for (i = 0; i < nc; ++i) {
+        long edge = (long) VECTOR(*incedges)[i];
+        igraph_integer_t v = IGRAPH_TO(graph, edge) == u ? IGRAPH_FROM(graph, edge) : IGRAPH_TO(graph, edge);
+
+        if (! VECTOR(*visited)[v]) {
+            VECTOR(*incoming_edge)[v] = edge;
+            IGRAPH_CHECK(igraph_i_bridges_rec(graph, il, v, time, bridges, visited, disc, low, incoming_edge));
+
+            VECTOR(*low)[u] = VECTOR(*low)[u] < VECTOR(*low)[v] ? VECTOR(*low)[u] : VECTOR(*low)[v];
+
+            if (VECTOR(*low)[v] > VECTOR(*disc)[u]) {
+                IGRAPH_CHECK(igraph_vector_push_back(bridges, edge));
             }
+        } else if (edge != VECTOR(*incoming_edge)[u]) {
+            VECTOR(*low)[u] = VECTOR(*low)[u] < VECTOR(*disc)[v] ? VECTOR(*low)[u] : VECTOR(*disc)[v];
         }
+    }
 
-        /* Create a new stack frame in case we back out later */
-        new_frame_ptr = IGRAPH_CALLOC(1, igraph_i_maximal_cliques_stack_frame);
-        if (new_frame_ptr == 0) {
-            IGRAPH_ERROR("cannot allocate new stack frame", IGRAPH_ENOMEM);
-        }
-        IGRAPH_FINALLY(igraph_free, new_frame_ptr);
-        *new_frame_ptr = frame;
-        memset(&frame, 0, sizeof(frame));
-        IGRAPH_CHECK(igraph_stack_ptr_push(&stack, new_frame_ptr));
-        IGRAPH_FINALLY_CLEAN(1);  /* ownership of new_frame_ptr taken by the stack */
-        /* Ownership of the current frame and its vectors (frame.cand, frame.done, frame.cand_filtered)
-         * is taken by the stack from now on. Vectors in frame must be re-initialized with new_cand,
-         * new_fini and stuff. The old frame.cand and frame.fini won't be leaked because they are
-         * managed by the stack now. */
-        frame.cand = new_cand;
-        frame.fini = new_fini;
-        IGRAPH_CHECK(igraph_vector_int_init(&new_cand, 0));
-        IGRAPH_CHECK(igraph_vector_int_init(&new_fini, 0));
-        IGRAPH_CHECK(igraph_vector_int_init(&frame.cand_filtered, 0));
-
-        /* Adjust frame.cand_filtered */
-        if (best_cand_degree < best_fini_cand_degree) {
-            IGRAPH_CHECK(igraph_vector_int_difference_sorted(&frame.cand, &best_fini_cand_nbrs, &frame.cand_filtered));
-        } else {
-            IGRAPH_CHECK(igraph_vector_int_difference_sorted(&frame.cand, &best_cand_nbrs, &frame.cand_filtered));
-        }
+    return IGRAPH_SUCCESS;
+}
+
+/**
+ * \function igraph_bridges
+ * Find all bridges in a graph.
+ *
+ * An edge is a bridge if its removal increases the number of (weakly)
+ * connected components in the graph.
+ *
+ * \param graph The input graph.
+ * \param res Pointer to an initialized vector, the
+ *    bridges will be stored here as edge indices.
+ * \return Error code.
+ *
+ * Time complexity: O(|V|+|E|), linear in the number of vertices and edges.
+ *
+ * \sa \ref igraph_articulation_points(), \ref igraph_biconnected_components(), \ref igraph_clusters()
+ */
+
+int igraph_bridges(const igraph_t *graph, igraph_vector_t *bridges) {
+    igraph_inclist_t il;
+    igraph_vector_bool_t visited;
+    igraph_vector_int_t disc, low;
+    igraph_vector_int_t incoming_edge;
+    long n;
+    long i;
+    igraph_integer_t time;
+
+    n = igraph_vcount(graph);
+
+    IGRAPH_CHECK(igraph_inclist_init(graph, &il, IGRAPH_ALL, IGRAPH_LOOPS_TWICE));
+    IGRAPH_FINALLY(igraph_inclist_destroy, &il);
+
+    IGRAPH_CHECK(igraph_vector_bool_init(&visited, n));
+    IGRAPH_FINALLY(igraph_vector_bool_destroy, &visited);
+
+    IGRAPH_CHECK(igraph_vector_int_init(&disc, n));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &disc);
+
+    IGRAPH_CHECK(igraph_vector_int_init(&low, n));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &low);
+
+    IGRAPH_CHECK(igraph_vector_int_init(&incoming_edge, n));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &incoming_edge);
+    for (i = 0; i < n; ++i) {
+        VECTOR(incoming_edge)[i] = -1;
     }
 
-    IGRAPH_PROGRESS("Maximal cliques: ", 100.0, NULL);
-
-    igraph_adjlist_destroy(&adj_list);
-    igraph_vector_destroy(&clique);
-    igraph_vector_int_destroy(&new_cand);
-    igraph_vector_int_destroy(&new_fini);
-    igraph_vector_int_destroy(&cn);
-    igraph_vector_int_destroy(&best_cand_nbrs);
-    igraph_vector_int_destroy(&best_fini_cand_nbrs);
-    igraph_i_maximal_cliques_stack_frame_destroy(&frame);
-    igraph_i_maximal_cliques_stack_destroy(&stack);
-    IGRAPH_FINALLY_CLEAN(9);
+    igraph_vector_clear(bridges);
+
+    time = 0;
+    for (i = 0; i < n; ++i)
+        if (! VECTOR(visited)[i]) {
+            IGRAPH_CHECK(igraph_i_bridges_rec(graph, &il, i, &time, bridges, &visited, &disc, &low, &incoming_edge));
+        }
+
+    igraph_vector_int_destroy(&incoming_edge);
+    igraph_vector_int_destroy(&low);
+    igraph_vector_int_destroy(&disc);
+    igraph_vector_bool_destroy(&visited);
+    igraph_inclist_destroy(&il);
+    IGRAPH_FINALLY_CLEAN(5);
 
     return IGRAPH_SUCCESS;
 }
 
-static int igraph_i_maximal_or_largest_cliques_or_indsets(const igraph_t *graph,
-        igraph_vector_ptr_t *res,
-        igraph_integer_t *clique_number,
-        igraph_bool_t keep_only_largest,
-        igraph_bool_t complementer) {
-    igraph_i_max_ind_vsets_data_t clqdata;
-    igraph_integer_t no_of_nodes = (igraph_integer_t) igraph_vcount(graph), i;
-
-    if (igraph_is_directed(graph)) {
-        IGRAPH_WARNING("directionality of edges is ignored for directed graphs");
-    }
-
-    clqdata.matrix_size = no_of_nodes;
-    clqdata.keep_only_largest = keep_only_largest;
-
-    if (complementer) {
-        IGRAPH_CHECK(igraph_adjlist_init_complementer(graph, &clqdata.adj_list, IGRAPH_ALL, 0));
-    } else {
-        IGRAPH_CHECK(igraph_adjlist_init(
-            graph, &clqdata.adj_list, IGRAPH_ALL, IGRAPH_LOOPS_TWICE, IGRAPH_MULTIPLE
-        ));
-    }
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &clqdata.adj_list);
+/**
+ * \ingroup structural
+ * \function igraph_subcomponent
+ * \brief The vertices in the same component as a given vertex.
+ *
+ * \param graph The graph object.
+ * \param res The result, vector with the ids of the vertices in the
+ *        same component.
+ * \param vertex The id of the vertex of which the component is
+ *        searched.
+ * \param mode Type of the component for directed graphs, possible
+ *        values:
+ *        \clist
+ *        \cli IGRAPH_OUT
+ *          the set of vertices reachable \em from the
+ *          \p vertex,
+ *        \cli IGRAPH_IN
+ *          the set of vertices from which the
+ *          \p vertex is reachable.
+ *        \cli IGRAPH_ALL
+ *          the graph is considered as an
+ *          undirected graph. Note that this is \em not the same
+ *          as the union of the previous two.
+ *        \endclist
+ * \return Error code:
+ *        \clist
+ *        \cli IGRAPH_ENOMEM
+ *          not enough memory for temporary data.
+ *        \cli IGRAPH_EINVVID
+ *           \p vertex is an invalid vertex id
+ *        \cli IGRAPH_EINVMODE
+ *           invalid mode argument passed.
+ *        \endclist
+ *
+ * Time complexity: O(|V|+|E|),
+ * |V| and
+ * |E| are the number of vertices and
+ * edges in the graph.
+ *
+ * \sa \ref igraph_induced_subgraph() if you want a graph object consisting only
+ * a given set of vertices and the edges between them.
+ */
+int igraph_subcomponent(const igraph_t *graph, igraph_vector_t *res, igraph_real_t vertex,
+                        igraph_neimode_t mode) {
 
-    clqdata.IS = IGRAPH_CALLOC(no_of_nodes, igraph_integer_t);
-    if (clqdata.IS == 0) {
-        IGRAPH_ERROR("igraph_i_maximal_or_largest_cliques_or_indsets failed", IGRAPH_ENOMEM);
-    }
-    IGRAPH_FINALLY(igraph_free, clqdata.IS);
+    long int no_of_nodes = igraph_vcount(graph);
+    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
+    char *already_added;
+    long int i, vsize;
+    igraph_vector_t tmp = IGRAPH_VECTOR_NULL;
 
-    IGRAPH_VECTOR_INIT_FINALLY(&clqdata.deg, no_of_nodes);
-    for (i = 0; i < no_of_nodes; i++) {
-        VECTOR(clqdata.deg)[i] = igraph_vector_int_size(igraph_adjlist_get(&clqdata.adj_list, i));
+    if (!IGRAPH_FINITE(vertex) || vertex < 0 || vertex >= no_of_nodes) {
+        IGRAPH_ERROR("Vertex id out of range.", IGRAPH_EINVVID);
     }
-
-    clqdata.buckets = IGRAPH_CALLOC(no_of_nodes + 1, igraph_set_t);
-    if (clqdata.buckets == 0) {
-        IGRAPH_ERROR("igraph_maximal_or_largest_cliques_or_indsets failed", IGRAPH_ENOMEM);
+    if (mode != IGRAPH_OUT && mode != IGRAPH_IN &&
+        mode != IGRAPH_ALL) {
+        IGRAPH_ERROR("Invalid mode argument.", IGRAPH_EINVMODE);
     }
-    IGRAPH_FINALLY(igraph_i_free_set_array, clqdata.buckets);
 
-    for (i = 0; i < no_of_nodes; i++) {
-        IGRAPH_CHECK(igraph_set_init(&clqdata.buckets[i], 0));
+    already_added = IGRAPH_CALLOC(no_of_nodes, char);
+    if (already_added == 0) {
+        IGRAPH_ERROR("Subcomponent failed.", IGRAPH_ENOMEM);
     }
+    IGRAPH_FINALLY(igraph_free, already_added);
 
-    if (res) {
-        igraph_vector_ptr_clear(res);
-    }
+    igraph_vector_clear(res);
 
-    /* Do the show */
-    clqdata.largest_set_size = 0;
-    IGRAPH_CHECK(igraph_i_maximal_independent_vertex_sets_backtrack(graph, res, &clqdata, 0));
+    IGRAPH_VECTOR_INIT_FINALLY(&tmp, 0);
+    IGRAPH_DQUEUE_INIT_FINALLY(&q, 100);
 
-    /* Cleanup */
-    for (i = 0; i < no_of_nodes; i++) {
-        igraph_set_destroy(&clqdata.buckets[i]);
-    }
-    igraph_adjlist_destroy(&clqdata.adj_list);
-    igraph_vector_destroy(&clqdata.deg);
-    igraph_free(clqdata.IS);
-    igraph_free(clqdata.buckets);
-    IGRAPH_FINALLY_CLEAN(4);
+    IGRAPH_CHECK(igraph_dqueue_push(&q, vertex));
+    IGRAPH_CHECK(igraph_vector_push_back(res, vertex));
+    already_added[(long int)vertex] = 1;
+
+    while (!igraph_dqueue_empty(&q)) {
+        long int actnode = (long int) igraph_dqueue_pop(&q);
+
+        IGRAPH_ALLOW_INTERRUPTION();
+
+        IGRAPH_CHECK(igraph_neighbors(graph, &tmp, (igraph_integer_t) actnode,
+                                      mode));
+        vsize = igraph_vector_size(&tmp);
+        for (i = 0; i < vsize; i++) {
+            long int neighbor = (long int) VECTOR(tmp)[i];
 
-    if (clique_number) {
-        *clique_number = clqdata.largest_set_size;
+            if (already_added[neighbor]) {
+                continue;
+            }
+            already_added[neighbor] = 1;
+            IGRAPH_CHECK(igraph_vector_push_back(res, neighbor));
+            IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+        }
     }
-    return 0;
+
+    igraph_dqueue_destroy(&q);
+    igraph_vector_destroy(&tmp);
+    IGRAPH_FREE(already_added);
+    IGRAPH_FINALLY_CLEAN(3);
+
+    return IGRAPH_SUCCESS;
 }
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/glet.c` & `igraph-0.9.9/vendor/source/igraph/src/cliques/glet.c`

 * *Files 0% similar despite different names*

```diff
@@ -557,15 +557,15 @@
         IGRAPH_ERROR("Graphlet functions require weighted graphs", IGRAPH_EINVAL);
     }
 
     if (igraph_vector_size(weights) != no_of_edges) {
         IGRAPH_ERROR("Invalid weight vector length", IGRAPH_EINVAL);
     }
 
-    igraph_is_simple(graph, &simple);
+    IGRAPH_CHECK(igraph_is_simple(graph, &simple));
     if (!simple) {
         IGRAPH_ERROR("Graphlets work on simple graphs only", IGRAPH_EINVAL);
     }
 
     minthr = igraph_vector_min(weights);
     igraph_vector_ptr_clear(cliques);
     igraph_vector_clear(thresholds);
@@ -609,15 +609,15 @@
     }
     if (startMu && igraph_vector_size(Mu) != no_cliques) {
         IGRAPH_ERROR("Invalid start coefficient vector size", IGRAPH_EINVAL);
     }
     if (niter < 0) {
         IGRAPH_ERROR("Number of iterations must be non-negative", IGRAPH_EINVAL);
     }
-    igraph_is_simple(graph, &simple);
+    IGRAPH_CHECK(igraph_is_simple(graph, &simple));
     if (!simple) {
         IGRAPH_ERROR("Graphlets work on simple graphs only", IGRAPH_EINVAL);
     }
 
     if (!startMu) {
         igraph_vector_resize(Mu, no_cliques);
         igraph_vector_fill(Mu, 1);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/maximal_cliques.c` & `igraph-0.9.9/vendor/source/igraph/src/cliques/maximal_cliques.c`

 * *Files 2% similar despite different names*

```diff
@@ -140,15 +140,16 @@
                     *avnei = *pp;
                     *pp = tmp;
                 }
                 pp++;
             }
         }
     }
-    return 0;
+
+    return IGRAPH_SUCCESS;
 }
 
 static int igraph_i_maximal_cliques_select_pivot(
         const igraph_vector_int_t *PX,
         int PS, int PE, int XS, int XE,
         const igraph_vector_int_t *pos,
         const igraph_adjlist_t *adjlist,
@@ -186,15 +187,15 @@
         }
         if ((j = pp - avp) > usize) {
             *pivot = av;
             usize = j;
         }
     }
 
-    igraph_vector_int_push_back(nextv, -1);
+    IGRAPH_CHECK(igraph_vector_int_push_back(nextv, -1));
     pivotvectneis = igraph_adjlist_get(adjlist, *pivot);
     pivotvectlen = igraph_vector_int_size(pivotvectneis);
 
     for (j = PS; j <= PE; j++) {
         int vcand = VECTOR(*PX)[j];
         igraph_bool_t nei = 0;
         int k = 0;
@@ -206,19 +207,19 @@
             }
             if (unv == vcand) {
                 nei = 1;
                 break;
             }
         }
         if (!nei) {
-            igraph_vector_int_push_back(nextv, vcand);
+            IGRAPH_CHECK(igraph_vector_int_push_back(nextv, vcand));
         }
     }
 
-    return 0;
+    return IGRAPH_SUCCESS;
 }
 
 #define SWAP(p1,p2) do {            \
         int v1=VECTOR(*PX)[p1];         \
         int v2=VECTOR(*PX)[p2];         \
         VECTOR(*PX)[p1] = v2;           \
         VECTOR(*PX)[p2] = v1;           \
@@ -246,17 +247,17 @@
             SWAP(vneipos - 1, *newPS);
         } else if (vneipos >= sXS && vneipos <= sXE) {
             (*newXE)++;
             SWAP(vneipos - 1, *newXE);
         }
     }
 
-    igraph_vector_int_push_back(R, mynextv);
+    IGRAPH_CHECK(igraph_vector_int_push_back(R, mynextv));
 
-    return 0;
+    return IGRAPH_SUCCESS;
 }
 
 #undef SWAP
 
 static int igraph_i_maximal_cliques_PX(igraph_vector_int_t *PX, int PS, int *PE,
                                        int *XS, int XE, igraph_vector_int_t *pos,
                                        igraph_adjlist_t *adjlist, int v,
@@ -270,17 +271,17 @@
     IGRAPH_UNUSED(adjlist);
 
     VECTOR(*PX)[vpos] = tmp;
     VECTOR(*PX)[*PE] = v;
     VECTOR(*pos)[v] = (*PE) + 1;
     VECTOR(*pos)[tmp] = vpos + 1;
     (*PE)--; (*XS)--;
-    igraph_vector_int_push_back(H, v);
+    IGRAPH_CHECK(igraph_vector_int_push_back(H, v));
 
-    return 0;
+    return IGRAPH_SUCCESS;
 }
 
 static int igraph_i_maximal_cliques_up(igraph_vector_int_t *PX, int PS, int PE,
                                        int XS, int XE, igraph_vector_int_t *pos,
                                        igraph_adjlist_t *adjlist,
                                        igraph_vector_int_t *R,
                                        igraph_vector_int_t *H) {
@@ -449,15 +450,16 @@
  * \param graph The input graph.
  * \param subset Pointer to an \c  igraph_vector_int_t containing the
  *   subset of initial vertices
  * \param res Pointer to an \c igraph_ptr_t; the cliques will be
  *   stored here
  * \param no Pointer to an \c igraph_integer_t; the number of maximal
  *   cliques will be stored here.
- * \param outfile Pointer to the output file, it should be writable.
+ * \param outfile Pointer to an output file or \c NULL.
+ *   When not \c NULL, the file should be writable.
  * \param min_size Integer giving the minimum size of the cliques to be
  *   returned. If negative or zero, no lower bound will be used.
  * \param max_size Integer giving the maximum size of the cliques to be
  *   returned. If negative or zero, no upper bound will be used.
  * \return Error code.
  *
  * \sa \ref igraph_maximal_cliques().
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/cliques/maximal_cliques_template.h` & `igraph-0.9.9/vendor/source/igraph/src/cliques/maximal_cliques_template.h`

 * *Files 18% similar despite different names*

```diff
@@ -196,55 +196,57 @@
     RESTYPE,
     igraph_vector_int_t *nextv,
     igraph_vector_int_t *H,
     int min_size, int max_size) {
 
     int err;
 
-    igraph_vector_int_push_back(H, -1); /* boundary */
+    IGRAPH_CHECK(igraph_vector_int_push_back(H, -1)); /* boundary */
 
     if (PS > PE && XS > XE) {
         /* Found a maximum clique, report it */
         int clsize = igraph_vector_int_size(R);
         if (min_size <= clsize && (clsize <= max_size || max_size <= 0)) {
             RECORD;
         }
     } else if (PS <= PE) {
         /* Select a pivot element */
         int pivot, mynextv;
-        igraph_i_maximal_cliques_select_pivot(PX, PS, PE, XS, XE, pos,
-                                              adjlist, &pivot, nextv,
-                                              oldPS, oldXE);
+        IGRAPH_CHECK(igraph_i_maximal_cliques_select_pivot(
+            PX, PS, PE, XS, XE, pos, adjlist, &pivot, nextv, oldPS, oldXE
+        ));
         while ((mynextv = igraph_vector_int_pop_back(nextv)) != -1) {
             int newPS, newXE;
 
             /* Going down, prepare */
-            igraph_i_maximal_cliques_down(PX, PS, PE, XS, XE, pos, adjlist,
-                                          mynextv, R, &newPS, &newXE);
+            IGRAPH_CHECK(igraph_i_maximal_cliques_down(
+                PX, PS, PE, XS, XE, pos, adjlist, mynextv, R, &newPS, &newXE
+            ));
             /* Recursive call */
             err = FUNCTION(igraph_i_maximal_cliques_bk, SUFFIX)(
                       PX, newPS, PE, XS, newXE, PS, XE, R,
                       pos, adjlist, RESNAME, nextv, H,
                       min_size, max_size);
 
             if (err == IGRAPH_STOP) {
                 return err;
             } else {
                 IGRAPH_CHECK(err);
             }
             /* Putting v from P to X */
             if (igraph_vector_int_tail(nextv) != -1) {
-                igraph_i_maximal_cliques_PX(PX, PS, &PE, &XS, XE, pos, adjlist,
-                                            mynextv, H);
+                IGRAPH_CHECK(igraph_i_maximal_cliques_PX(
+                    PX, PS, &PE, &XS, XE, pos, adjlist, mynextv, H
+                ));
             }
         }
     }
 
     /* Putting back vertices from X to P, see notes in H */
-    igraph_i_maximal_cliques_up(PX, PS, PE, XS, XE, pos, adjlist, R, H);
+    IGRAPH_CHECK(igraph_i_maximal_cliques_up(PX, PS, PE, XS, XE, pos, adjlist, R, H));
 
     return 0;
 }
 
 int FUNCTION(igraph_maximal_cliques, SUFFIX)(
     const igraph_t *graph,
     RESTYPE,
@@ -263,46 +265,38 @@
     IGRAPH_UNUSED(nn);
 
     if (igraph_is_directed(graph)) {
         IGRAPH_WARNING("Edge directions are ignored for maximal clique "
                        "calculation");
     }
 
-    igraph_vector_init(&order, no_of_nodes);
-    IGRAPH_FINALLY(igraph_vector_destroy, &order);
-    igraph_vector_int_init(&rank, no_of_nodes);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &rank);
-    igraph_vector_init(&coreness, no_of_nodes);
-    igraph_coreness(graph, &coreness, /*mode=*/ IGRAPH_ALL);
-    IGRAPH_FINALLY(igraph_vector_destroy, &coreness);
-    igraph_vector_qsort_ind(&coreness, &order, /*descending=*/ 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&order, no_of_nodes);
+    IGRAPH_VECTOR_INT_INIT_FINALLY(&rank, no_of_nodes);
+    IGRAPH_VECTOR_INIT_FINALLY(&coreness, no_of_nodes);
+    IGRAPH_CHECK(igraph_coreness(graph, &coreness, /*mode=*/ IGRAPH_ALL));
+    IGRAPH_CHECK(igraph_vector_qsort_ind(&coreness, &order, /*descending=*/ 0));
     for (ii = 0; ii < no_of_nodes; ii++) {
         int v = VECTOR(order)[ii];
         VECTOR(rank)[v] = ii;
     }
 
     igraph_vector_destroy(&coreness);
     IGRAPH_FINALLY_CLEAN(1);
 
     igraph_adjlist_init(graph, &adjlist, IGRAPH_ALL, IGRAPH_NO_LOOPS, IGRAPH_NO_MULTIPLE);
     IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
 
     igraph_adjlist_init(graph, &fulladjlist, IGRAPH_ALL, IGRAPH_NO_LOOPS, IGRAPH_NO_MULTIPLE);
     IGRAPH_FINALLY(igraph_adjlist_destroy, &fulladjlist);
 
-    igraph_vector_int_init(&PX, 20);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &PX);
-    igraph_vector_int_init(&R,  20);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &R);
-    igraph_vector_int_init(&H, 100);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &H);
-    igraph_vector_int_init(&pos, no_of_nodes);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &pos);
-    igraph_vector_int_init(&nextv, 100);
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &nextv);
+    IGRAPH_VECTOR_INT_INIT_FINALLY(&PX, 20);
+    IGRAPH_VECTOR_INT_INIT_FINALLY(&R,  20);
+    IGRAPH_VECTOR_INT_INIT_FINALLY(&H, 100);
+    IGRAPH_VECTOR_INT_INIT_FINALLY(&pos, no_of_nodes);
+    IGRAPH_VECTOR_INT_INIT_FINALLY(&nextv, 100);
 
     FINALLY;
 
     FOR_LOOP_OVER_VERTICES {
         int v;
         int vrank;
         igraph_vector_int_t *vneis;
@@ -322,19 +316,19 @@
         if (pg <= 0) {
             IGRAPH_PROGRESS("Maximal cliques: ", pgc++, NULL);
             pg = pgreset;
         }
 
         IGRAPH_ALLOW_INTERRUPTION();
 
-        igraph_vector_int_resize(&PX, vdeg);
-        igraph_vector_int_resize(&R, 1);
-        igraph_vector_int_resize(&H, 1);
+        IGRAPH_CHECK(igraph_vector_int_resize(&PX, vdeg));
+        IGRAPH_CHECK(igraph_vector_int_resize(&R, 1));
+        IGRAPH_CHECK(igraph_vector_int_resize(&H, 1));
         igraph_vector_int_null(&pos); /* TODO: makes it quadratic? */
-        igraph_vector_int_resize(&nextv, 1);
+        IGRAPH_CHECK(igraph_vector_int_resize(&nextv, 1));
 
         VECTOR(H)[0] = -1;      /* marks the end of the recursion */
         VECTOR(nextv)[0] = -1;
 
         /* ================================================================*/
         /* P <- G(v[i]) intersect { v[i+1], ..., v[n-1] }
            X <- G(v[i]) intersect { v[0], ..., v[i-1] } */
@@ -354,34 +348,37 @@
         }
 
         PE = Pptr - 1; XS = Xptr + 1; /* end of P, start of X in PX */
 
         /* Create an adjacency list that is specific to the
            v vertex. It only contains 'v' and its neighbors. Moreover, we
            only deal with the vertices in P and X (and R). */
-        igraph_vector_int_update(igraph_adjlist_get(&adjlist, v),
-                                 igraph_adjlist_get(&fulladjlist, v));
+        IGRAPH_CHECK(igraph_vector_int_update(
+            igraph_adjlist_get(&adjlist, v),
+            igraph_adjlist_get(&fulladjlist, v)
+        ));
         for (j = 0; j <= vdeg - 1; j++) {
             int vv = VECTOR(PX)[j];
             igraph_vector_int_t *fadj = igraph_adjlist_get(&fulladjlist, vv);
             igraph_vector_int_t *radj = igraph_adjlist_get(&adjlist, vv);
             int k, fn = igraph_vector_int_size(fadj);
             igraph_vector_int_clear(radj);
             for (k = 0; k < fn; k++) {
                 int nei = VECTOR(*fadj)[k];
                 int neipos = VECTOR(pos)[nei] - 1;
                 if (neipos >= PS && neipos <= XE) {
-                    igraph_vector_int_push_back(radj, nei);
+                    IGRAPH_CHECK(igraph_vector_int_push_back(radj, nei));
                 }
             }
         }
 
         /* Reorder the adjacency lists, according to P and X. */
-        igraph_i_maximal_cliques_reorder_adjlists(&PX, PS, PE, XS, XE, &pos,
-                &adjlist);
+        IGRAPH_CHECK(igraph_i_maximal_cliques_reorder_adjlists(
+            &PX, PS, PE, XS, XE, &pos, &adjlist
+        ));
 
         err = FUNCTION(igraph_i_maximal_cliques_bk, SUFFIX)(
                 &PX, PS, PE, XS, XE, PS, XE, &R, &pos,
                 &adjlist, RESNAME, &nextv, &H, min_size,
                 max_size);
         if (err == IGRAPH_STOP) {
             break;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/community_misc.c` & `igraph-0.9.9/vendor/source/igraph/src/community/community_misc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/edge_betweenness.c` & `igraph-0.9.9/vendor/source/igraph/src/community/edge_betweenness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/fast_modularity.c` & `igraph-0.9.9/vendor/source/igraph/src/community/fast_modularity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/fluid.c` & `igraph-0.9.9/vendor/source/igraph/src/community/fluid.c`

 * *Files 1% similar despite different names*

```diff
@@ -91,19 +91,19 @@
     if ((long int) no_of_communities < 1) {
         IGRAPH_ERROR("Number of requested communities must be greater than zero.", IGRAPH_EINVAL);
     }
     if ((long int) no_of_communities > no_of_nodes) {
         IGRAPH_ERROR("Number of requested communities must not be greater than the number of nodes.",
                      IGRAPH_EINVAL);
     }
-    igraph_is_simple(graph, &res);
+    IGRAPH_CHECK(igraph_is_simple(graph, &res));
     if (!res) {
         IGRAPH_ERROR("Fluid community detection supports only simple graphs.", IGRAPH_EINVAL);
     }
-    igraph_is_connected(graph, &res, IGRAPH_WEAK);
+    IGRAPH_CHECK(igraph_is_connected(graph, &res, IGRAPH_WEAK));
     if (!res) {
         IGRAPH_ERROR("Fluid community detection supports only connected graphs.", IGRAPH_EINVAL);
     }
     if (igraph_is_directed(graph)) {
         IGRAPH_WARNING("Edge directions are ignored by fluid community detection.");
     }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap.cc` & `igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.cc` & `igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.h` & `igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_FlowGraph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Greedy.cc` & `igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Greedy.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Greedy.h` & `igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Greedy.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Node.cc` & `igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Node.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/infomap/infomap_Node.h` & `igraph-0.9.9/vendor/source/igraph/src/community/infomap/infomap_Node.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/label_propagation.c` & `igraph-0.9.9/vendor/source/igraph/src/games/recent_degree.c`

 * *Files 18% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 /* -*- mode: C -*-  */
 /* vim:set ts=4 sw=4 sts=4 et: */
 /*
    IGraph library.
-   Copyright (C) 2007-2020 The igraph development team
+   Copyright (C) 2003-2021 The igraph development team
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -17,302 +17,356 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
-#include "igraph_community.h"
+#include "igraph_games.h"
 
-#include "igraph_adjlist.h"
-#include "igraph_interface.h"
+#include "igraph_constructors.h"
+#include "igraph_dqueue.h"
+#include "igraph_psumtree.h"
 #include "igraph_random.h"
+#include "igraph_interface.h"
 
 /**
- * \ingroup communities
- * \function igraph_community_label_propagation
- * \brief Community detection based on label propagation.
- *
- * This function implements the community detection method described in:
- * Raghavan, U.N. and Albert, R. and Kumara, S.: Near linear time algorithm
- * to detect community structures in large-scale networks. Phys Rev E
- * 76, 036106. (2007). This version extends the original method by
- * the ability to take edge weights into consideration and also
- * by allowing some labels to be fixed.
- *
- * </para><para>
- * Weights are taken into account as follows: when the new label of node
- * \c i is determined, the algorithm iterates over all edges incident on
- * node \c i and calculate the total weight of edges leading to other
- * nodes with label 0, 1, 2, ..., \c k - 1 (where \c k is the number of possible
- * labels). The new label of node \c i will then be the label whose edges
- * (among the ones incident on node \c i) have the highest total weight.
+ * \function igraph_recent_degree_game
+ * \brief Stochastic graph generator based on the number of incident edges a node has gained recently.
  *
- * \param graph The input graph, should be undirected to make sense.
- * \param membership The membership vector, the result is returned here.
- *    For each vertex it gives the ID of its community (label).
- * \param weights The weight vector, it should contain a positive
- *    weight for all the edges.
- * \param initial The initial state. If NULL, every vertex will have
- *   a different label at the beginning. Otherwise it must be a vector
- *   with an entry for each vertex. Non-negative values denote different
- *   labels, negative entries denote vertices without labels.
- * \param fixed Boolean vector denoting which labels are fixed. Of course
- *   this makes sense only if you provided an initial state, otherwise
- *   this element will be ignored. Also note that vertices without labels
- *   cannot be fixed. If they are, this vector will be modified to
- *   make it consistent with \p initial.
- * \param modularity If not a null pointer, then it must be a pointer
- *   to a real number. The modularity score of the detected community
- *   structure is stored here.
+ * \param graph Pointer to an uninitialized graph object.
+ * \param nodes The number of vertices in the graph, this is the same as
+ *        the number of time steps.
+ * \param power The exponent, the probability that a node gains a
+ *        new edge is proportional to the number of edges it has
+ *        gained recently (in the last \p window time steps) to \p
+ *        power.
+ * \param time_window Integer constant, the size of the time window to use
+ *        to count the number of recent edges.
+ * \param m Integer constant, the number of edges to add per time
+ *        step if the \p outseq parameter is a null pointer or a
+ *        zero-length vector.
+ * \param outseq The number of edges to add in each time step. This
+ *        argument is ignored if it is a null pointer or a zero length
+ *        vector. In this case the constant \p m parameter is used.
+ * \param outpref Logical constant, if true the edges originated by a
+ *        vertex also count as recent incident edges.
+ *        For most applications it is reasonable to set it to false.
+ * \param zero_appeal Constant giving the attractiveness of the
+ *        vertices which haven't gained any edge recently.
+ * \param directed Logical constant, whether to generate a directed
+ *        graph.
  * \return Error code.
  *
- * Time complexity: O(m+n)
+ * Time complexity: O(|V|*log(|V|)+|E|), |V| is the number of
+ * vertices, |E| is the number of edges in the graph.
  *
- * \example examples/simple/igraph_community_label_propagation.c
  */
-int igraph_community_label_propagation(const igraph_t *graph,
-                                       igraph_vector_t *membership,
-                                       const igraph_vector_t *weights,
-                                       const igraph_vector_t *initial,
-                                       igraph_vector_bool_t *fixed,
-                                       igraph_real_t *modularity) {
-    long int no_of_nodes = igraph_vcount(graph);
-    long int no_of_edges = igraph_ecount(graph);
-    long int no_of_not_fixed_nodes = no_of_nodes;
-    long int i, j, k;
-    igraph_adjlist_t al;
-    igraph_inclist_t il;
-    igraph_bool_t running = 1;
-
-    igraph_vector_t label_counters, dominant_labels, nonzero_labels, node_order;
-
-    /* The implementation uses a trick to avoid negative array indexing:
-     * elements of the membership vector are increased by 1 at the start
-     * of the algorithm; this to allow us to denote unlabeled vertices
-     * (if any) by zeroes. The membership vector is shifted back in the end
-     */
-
-    /* Do some initial checks */
-    if (fixed && igraph_vector_bool_size(fixed) != no_of_nodes) {
-        IGRAPH_ERROR("Fixed labeling vector length must agree with number of nodes.", IGRAPH_EINVAL);
-    }
-    if (weights) {
-        if (igraph_vector_size(weights) != no_of_edges) {
-            IGRAPH_ERROR("Length of weight vector must agree with number of edges.", IGRAPH_EINVAL);
-        }
-        if (no_of_edges > 0) {
-            igraph_real_t minweight = igraph_vector_min(weights);
-            if (minweight < 0) {
-                IGRAPH_ERROR("Weights must not be negative.", IGRAPH_EINVAL);
-            }
-            if (igraph_is_nan(minweight)) {
-                IGRAPH_ERROR("Weights must not be NaN.", IGRAPH_EINVAL);
-            }
-        }
+int igraph_recent_degree_game(igraph_t *graph, igraph_integer_t nodes,
+                              igraph_real_t power,
+                              igraph_integer_t time_window,
+                              igraph_integer_t m,
+                              const igraph_vector_t *outseq,
+                              igraph_bool_t outpref,
+                              igraph_real_t zero_appeal,
+                              igraph_bool_t directed) {
+
+    long int no_of_nodes = nodes;
+    long int no_of_neighbors = 0;
+    long int no_of_edges;
+    igraph_vector_t edges;
+    long int i, j;
+    igraph_psumtree_t sumtree;
+    long int edgeptr = 0;
+    igraph_vector_t degree;
+    igraph_dqueue_t history;
+    igraph_bool_t have_outseq = outseq && igraph_vector_size(outseq) > 0;
+
+    if (no_of_nodes < 0) {
+        IGRAPH_ERRORF("Number of vertices cannot be negative, got %ld.", IGRAPH_EINVAL, no_of_nodes);
+    }
+    if (have_outseq && igraph_vector_size(outseq) != no_of_nodes) {
+        IGRAPH_ERRORF("Out-degree sequence is specified, but its length (%ld) does not equal the number of nodes (%ld).",
+                      IGRAPH_EINVAL, (long) igraph_vector_size(outseq), no_of_nodes);
+    }
+    if (!have_outseq && m < 0) {
+        IGRAPH_ERRORF("Numer of edges per step cannot be negative, got %" IGRAPH_PRId ".",
+                       IGRAPH_EINVAL, m);
     }
-    if (fixed && !initial) {
-        IGRAPH_WARNING("Ignoring fixed vertices as no initial labeling given.");
+    if (time_window < 0) {
+        IGRAPH_ERRORF("Time window cannot be negative, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, time_window);
+    }
+    if (zero_appeal < 0) {
+        IGRAPH_ERRORF("The zero appeal cannot be negative, got %g.", IGRAPH_EINVAL, zero_appeal);
     }
 
-    IGRAPH_CHECK(igraph_vector_resize(membership, no_of_nodes));
+    if (nodes == 0) {
+        igraph_empty(graph, 0, directed);
+        return IGRAPH_SUCCESS;
+    }
 
-    if (initial) {
-        if (igraph_vector_size(initial) != no_of_nodes) {
-            IGRAPH_ERROR("Initial labeling vector length must agree with number of nodes.", IGRAPH_EINVAL);
-        }
-        /* Check if the labels used are valid, initialize membership vector */
-        for (i = 0; i < no_of_nodes; i++) {
-            if (VECTOR(*initial)[i] < 0) {
-                VECTOR(*membership)[i] = 0;
-            } else {
-                VECTOR(*membership)[i] = floor(VECTOR(*initial)[i]) + 1;
-            }
+    if (!have_outseq) {
+        no_of_neighbors = m;
+        no_of_edges = (no_of_nodes - 1) * no_of_neighbors;
+    } else {
+        long int outseq_len = igraph_vector_size(outseq);
+        no_of_edges = 0;
+        for (i = 1; i < outseq_len; i++) {
+            no_of_edges += VECTOR(*outseq)[i];
         }
-        if (fixed) {
-            for (i = 0; i < no_of_nodes; i++) {
-                if (VECTOR(*fixed)[i]) {
-                    if (VECTOR(*membership)[i] == 0) {
-                        IGRAPH_WARNING("Fixed nodes cannot be unlabeled, ignoring them.");
-                        VECTOR(*fixed)[i] = 0;
-                    } else {
-                        no_of_not_fixed_nodes--;
-                    }
-                }
+    }
+
+    IGRAPH_VECTOR_INIT_FINALLY(&edges, no_of_edges * 2);
+    IGRAPH_CHECK(igraph_psumtree_init(&sumtree, no_of_nodes));
+    IGRAPH_FINALLY(igraph_psumtree_destroy, &sumtree);
+    IGRAPH_VECTOR_INIT_FINALLY(&degree, no_of_nodes);
+    IGRAPH_CHECK(igraph_dqueue_init(&history,
+                                    1.5 * time_window * no_of_edges / no_of_nodes + 10));
+    IGRAPH_FINALLY(igraph_dqueue_destroy, &history);
+
+    RNG_BEGIN();
+
+    /* first node */
+    IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_appeal));
+    igraph_dqueue_push(&history, -1);
+
+    /* and the rest */
+    for (i = 1; i < no_of_nodes; i++) {
+        igraph_real_t sum;
+        long int to;
+        if (have_outseq) {
+            no_of_neighbors = (long int) VECTOR(*outseq)[i];
+        }
+
+        if (i >= time_window) {
+            while ((j = (long int) igraph_dqueue_pop(&history)) != -1) {
+                VECTOR(degree)[j] -= 1;
+                IGRAPH_CHECK(igraph_psumtree_update(&sumtree, j, pow(VECTOR(degree)[j], power) + zero_appeal));
             }
         }
 
-        i = (long int) igraph_vector_max(membership);
-        if (i > no_of_nodes) {
-            IGRAPH_ERROR("Elements of the initial labeling vector must be between 0 and |V|-1.", IGRAPH_EINVAL);
-        }
-        if (i <= 0) {
-            IGRAPH_ERROR("At least one vertex must be labeled in the initial labeling.", IGRAPH_EINVAL);
-        }
-    } else {
-        for (i = 0; i < no_of_nodes; i++) {
-            VECTOR(*membership)[i] = i + 1;
+        sum = igraph_psumtree_sum(&sumtree);
+        for (j = 0; j < no_of_neighbors; j++) {
+            igraph_psumtree_search(&sumtree, &to, RNG_UNIF(0, sum));
+            VECTOR(degree)[to]++;
+            VECTOR(edges)[edgeptr++] = i;
+            VECTOR(edges)[edgeptr++] = to;
+            igraph_dqueue_push(&history, to);
+        }
+        igraph_dqueue_push(&history, -1);
+
+        /* update probabilities */
+        for (j = 0; j < no_of_neighbors; j++) {
+            long int nn = (long int) VECTOR(edges)[edgeptr - 2 * j - 1];
+            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, nn, pow(VECTOR(degree)[nn], power) + zero_appeal));
+        }
+        if (outpref) {
+            VECTOR(degree)[i] += no_of_neighbors;
+            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, i, pow(VECTOR(degree)[i], power) + zero_appeal));
+        } else {
+            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, i, zero_appeal));
         }
     }
 
-    /* Create an adjacency/incidence list representation for efficiency.
-     * For the unweighted case, the adjacency list is enough. For the
-     * weighted case, we need the incidence list */
-    if (weights) {
-        IGRAPH_CHECK(igraph_inclist_init(graph, &il, IGRAPH_IN, IGRAPH_LOOPS_ONCE));
-        IGRAPH_FINALLY(igraph_inclist_destroy, &il);
-    } else {
-        IGRAPH_CHECK(igraph_adjlist_init(graph, &al, IGRAPH_IN, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-        IGRAPH_FINALLY(igraph_adjlist_destroy, &al);
+    RNG_END();
+
+    igraph_dqueue_destroy(&history);
+    igraph_psumtree_destroy(&sumtree);
+    igraph_vector_destroy(&degree);
+    IGRAPH_FINALLY_CLEAN(3);
+
+    IGRAPH_CHECK(igraph_create(graph, &edges, nodes, directed));
+    igraph_vector_destroy(&edges);
+    IGRAPH_FINALLY_CLEAN(1);
+
+    return 0;
+}
+
+/**
+ * \function igraph_recent_degree_aging_game
+ * \brief Preferential attachment based on the number of edges gained recently, with aging of vertices.
+ *
+ * </para><para>
+ * This game is very similar to \ref igraph_barabasi_aging_game(),
+ * except that instead of the total number of incident edges the
+ * number of edges gained in the last \p time_window time steps are
+ * counted.
+ *
+ * </para><para>The degree dependent part of the attractiveness is
+ * given by k to the power of \p pa_exp plus \p zero_appeal; the age
+ * dependent part is l to the power to \p aging_exp.
+ * k is the number of edges gained in the last \p time_window time
+ * steps, l is the age of the vertex.
+ * \param graph Pointer to an uninitialized graph object.
+ * \param nodes The number of vertices in the graph.
+ * \param m The number of edges to add in each time step. If the \p
+ *        outseq argument is not a null vector or a zero-length vector
+ *        then it is ignored.
+ * \param outseq Vector giving the number of edges to add in each time
+ *        step. If it is a null pointer or a zero-length vector then
+ *        it is ignored and the \p m argument is used.
+ * \param outpref Logical constant, if true the edges initiated by a
+ *        vertex are also counted. Normally it is false.
+ * \param pa_exp The exponent for the preferential attachment.
+ * \param aging_exp The exponent for the aging, normally it is
+ *        negative: old vertices gain edges with less probability.
+ * \param aging_bins Integer constant, the number of age bins to use.
+ * \param time_window The time window to use to count the number of
+ *        incident edges for the vertices.
+ * \param zero_appeal The degree dependent part of the attractiveness
+ *        for zero degree vertices.
+ * \param directed Logical constant, whether to create a directed
+ *        graph.
+ * \return Error code.
+ *
+ * Time complexity: O((|V|+|V|/aging_bins)*log(|V|)+|E|). |V| is the number
+ * of vertices, |E| the number of edges.
+ */
+int igraph_recent_degree_aging_game(igraph_t *graph,
+                                    igraph_integer_t nodes,
+                                    igraph_integer_t m,
+                                    const igraph_vector_t *outseq,
+                                    igraph_bool_t outpref,
+                                    igraph_real_t pa_exp,
+                                    igraph_real_t aging_exp,
+                                    igraph_integer_t aging_bins,
+                                    igraph_integer_t time_window,
+                                    igraph_real_t zero_appeal,
+                                    igraph_bool_t directed) {
+
+    long int no_of_nodes = nodes;
+    long int no_of_neighbors;
+    long int binwidth;
+    long int no_of_edges;
+    igraph_vector_t edges;
+    long int i, j, k;
+    igraph_psumtree_t sumtree;
+    long int edgeptr = 0;
+    igraph_vector_t degree;
+    igraph_dqueue_t history;
+    igraph_bool_t have_outseq = outseq && igraph_vector_size(outseq) > 0;
+
+    if (no_of_nodes == 0) {
+        igraph_empty(graph, 0, directed);
+        return IGRAPH_SUCCESS;
+    }
+    if (no_of_nodes < 0) {
+        IGRAPH_ERRORF("Number of nodes should not be negative, got %ld.", IGRAPH_EINVAL, no_of_nodes);
+    }
+    if (have_outseq && igraph_vector_size(outseq) != no_of_nodes) {
+        IGRAPH_ERRORF("Out-degree sequence is specified, but its length (%ld) does not equal the number of nodes (%ld).",
+                      IGRAPH_EINVAL, (long) igraph_vector_size(outseq), no_of_nodes);
+    }
+    if (!have_outseq && m < 0) {
+        IGRAPH_ERRORF("Numer of edges per step cannot be negative, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, m);
+    }
+    if (aging_bins <= 0) {
+        IGRAPH_ERRORF("Aging bins should be positive, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, aging_bins);
+    }
+    if (time_window < 0) {
+        IGRAPH_ERRORF("Time window cannot be negative, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, time_window);
+    }
+    if (zero_appeal < 0) {
+        IGRAPH_ERRORF("The zero appeal cannot be negative, got %g.", IGRAPH_EINVAL, zero_appeal);
     }
 
-    /* Create storage space for counting distinct labels and dominant ones */
-    IGRAPH_VECTOR_INIT_FINALLY(&label_counters, no_of_nodes + 1);
-    IGRAPH_VECTOR_INIT_FINALLY(&dominant_labels, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&nonzero_labels, 0);
-    IGRAPH_CHECK(igraph_vector_reserve(&dominant_labels, 2));
-
-    /* Initialize node ordering vector with only the not fixed nodes */
-    if (fixed) {
-        IGRAPH_VECTOR_INIT_FINALLY(&node_order, no_of_not_fixed_nodes);
-        for (i = 0, j = 0; i < no_of_nodes; i++) {
-            if (!VECTOR(*fixed)[i]) {
-                VECTOR(node_order)[j] = i;
-                j++;
-            }
-        }
+    if (!have_outseq) {
+        no_of_neighbors = m;
+        no_of_edges = (no_of_nodes - 1) * no_of_neighbors;
     } else {
-        IGRAPH_CHECK(igraph_vector_init_seq(&node_order, 0, no_of_nodes - 1));
-        IGRAPH_FINALLY(igraph_vector_destroy, &node_order);
+        long int outseq_len = igraph_vector_size(outseq);
+        no_of_edges = 0;
+        for (i = 1; i < outseq_len; i++) {
+            no_of_edges += VECTOR(*outseq)[i];
+        }
     }
 
-    running = 1;
-    while (running) {
-        long int v1, num_neis;
-        igraph_real_t max_count;
-        igraph_vector_int_t *neis;
-        igraph_vector_int_t *ineis;
-        igraph_bool_t was_zero;
-
-        running = 0;
-
-        /* Shuffle the node ordering vector */
-        IGRAPH_CHECK(igraph_vector_shuffle(&node_order));
-
-        RNG_BEGIN();
-        /* In the prescribed order, loop over the vertices and reassign labels */
-        for (i = 0; i < no_of_not_fixed_nodes; i++) {
-            v1 = (long int) VECTOR(node_order)[i];
-
-            /* Count the weights corresponding to different labels */
-            igraph_vector_clear(&dominant_labels);
-            igraph_vector_clear(&nonzero_labels);
-            max_count = 0.0;
-            if (weights) {
-                ineis = igraph_inclist_get(&il, v1);
-                num_neis = igraph_vector_int_size(ineis);
-                for (j = 0; j < num_neis; j++) {
-                    k = (long int) VECTOR(*membership)[
-                    (long)IGRAPH_OTHER(graph, VECTOR(*ineis)[j], v1) ];
-                    if (k == 0) {
-                        continue;    /* skip if it has no label yet */
-                    }
-                    was_zero = (VECTOR(label_counters)[k] == 0);
-                    VECTOR(label_counters)[k] += VECTOR(*weights)[(long)VECTOR(*ineis)[j]];
-                    if (was_zero && VECTOR(label_counters)[k] != 0) {
-                        /* counter just became nonzero */
-                        IGRAPH_CHECK(igraph_vector_push_back(&nonzero_labels, k));
-                    }
-                    if (max_count < VECTOR(label_counters)[k]) {
-                        max_count = VECTOR(label_counters)[k];
-                        IGRAPH_CHECK(igraph_vector_resize(&dominant_labels, 1));
-                        VECTOR(dominant_labels)[0] = k;
-                    } else if (max_count == VECTOR(label_counters)[k]) {
-                        IGRAPH_CHECK(igraph_vector_push_back(&dominant_labels, k));
-                    }
-                }
-            } else {
-                neis = igraph_adjlist_get(&al, v1);
-                num_neis = igraph_vector_int_size(neis);
-                for (j = 0; j < num_neis; j++) {
-                    k = (long int) VECTOR(*membership)[(long)VECTOR(*neis)[j]];
-                    if (k == 0) {
-                        continue;    /* skip if it has no label yet */
-                    }
-                    VECTOR(label_counters)[k]++;
-                    if (VECTOR(label_counters)[k] == 1) {
-                        /* counter just became nonzero */
-                        IGRAPH_CHECK(igraph_vector_push_back(&nonzero_labels, k));
-                    }
-                    if (max_count < VECTOR(label_counters)[k]) {
-                        max_count = VECTOR(label_counters)[k];
-                        IGRAPH_CHECK(igraph_vector_resize(&dominant_labels, 1));
-                        VECTOR(dominant_labels)[0] = k;
-                    } else if (max_count == VECTOR(label_counters)[k]) {
-                        IGRAPH_CHECK(igraph_vector_push_back(&dominant_labels, k));
-                    }
-                }
-            }
+    binwidth = nodes / aging_bins + 1;
 
-            if (igraph_vector_size(&dominant_labels) > 0) {
-                /* Select randomly from the dominant labels */
-                k = RNG_INTEGER(0, igraph_vector_size(&dominant_labels) - 1);
-                k = (long int) VECTOR(dominant_labels)[k];
-                /* Check if the _current_ label of the node is also dominant */
-                if (VECTOR(label_counters)[(long)VECTOR(*membership)[v1]] != max_count) {
-                    /* Nope, we need at least one more iteration */
-                    running = 1;
-                }
-                VECTOR(*membership)[v1] = k;
-            }
-
-            /* Clear the nonzero elements in label_counters */
-            num_neis = igraph_vector_size(&nonzero_labels);
-            for (j = 0; j < num_neis; j++) {
-                VECTOR(label_counters)[(long int)VECTOR(nonzero_labels)[j]] = 0;
+    IGRAPH_VECTOR_INIT_FINALLY(&edges, no_of_edges * 2);
+    IGRAPH_CHECK(igraph_psumtree_init(&sumtree, no_of_nodes));
+    IGRAPH_FINALLY(igraph_psumtree_destroy, &sumtree);
+    IGRAPH_VECTOR_INIT_FINALLY(&degree, no_of_nodes);
+    IGRAPH_CHECK(igraph_dqueue_init(&history,
+                                    1.5 * time_window * no_of_edges / no_of_nodes + 10));
+    IGRAPH_FINALLY(igraph_dqueue_destroy, &history);
+
+    RNG_BEGIN();
+
+    /* first node */
+    IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_appeal));
+    igraph_dqueue_push(&history, -1);
+
+    /* and the rest */
+    for (i = 1; i < no_of_nodes; i++) {
+        igraph_real_t sum;
+        long int to;
+
+        if (have_outseq) {
+            no_of_neighbors = (long int) VECTOR(*outseq)[i];
+        }
+
+        if (i >= time_window) {
+            while ((j = (long int) igraph_dqueue_pop(&history)) != -1) {
+                long int age = (i - j) / binwidth;
+                VECTOR(degree)[j] -= 1;
+                IGRAPH_CHECK(igraph_psumtree_update(
+                    &sumtree, j,
+                    (pow(VECTOR(degree)[j], pa_exp) + zero_appeal) * pow(age + 1, aging_exp)
+                ));
             }
         }
-        RNG_END();
-    }
 
-    /* Shift back the membership vector, permute labels in increasing order */
-    /* We recycle label_counters here :) */
-    igraph_vector_fill(&label_counters, -1);
-    j = 0;
-    for (i = 0; i < no_of_nodes; i++) {
-        k = (long)VECTOR(*membership)[i] - 1;
-        if (k >= 0) {
-            if (VECTOR(label_counters)[k] == -1) {
-                /* We have seen this label for the first time */
-                VECTOR(label_counters)[k] = j;
-                k = j;
-                j++;
-            } else {
-                k = (long int) VECTOR(label_counters)[k];
-            }
+        sum = igraph_psumtree_sum(&sumtree);
+        for (j = 0; j < no_of_neighbors; j++) {
+            igraph_psumtree_search(&sumtree, &to, RNG_UNIF(0, sum));
+            VECTOR(degree)[to]++;
+            VECTOR(edges)[edgeptr++] = i;
+            VECTOR(edges)[edgeptr++] = to;
+            igraph_dqueue_push(&history, to);
+        }
+        igraph_dqueue_push(&history, -1);
+
+        /* update probabilities */
+        for (j = 0; j < no_of_neighbors; j++) {
+            long int n = (long int) VECTOR(edges)[edgeptr - 2 * j - 1];
+            long int age = (i - n) / binwidth;
+            IGRAPH_CHECK(igraph_psumtree_update(
+                &sumtree, n,
+                (pow(VECTOR(degree)[n], pa_exp) + zero_appeal) * pow(age + 1, aging_exp)
+            ));
+        }
+        if (outpref) {
+            VECTOR(degree)[i] += no_of_neighbors;
+            IGRAPH_CHECK(igraph_psumtree_update(
+                &sumtree, i,
+                pow(VECTOR(degree)[i], pa_exp) + zero_appeal
+            ));
         } else {
-            /* This is an unlabeled vertex */
+            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, i, zero_appeal));
         }
-        VECTOR(*membership)[i] = k;
-    }
 
-    if (weights) {
-        igraph_inclist_destroy(&il);
-    } else {
-        igraph_adjlist_destroy(&al);
+        /* aging */
+        for (k = 1; binwidth * k <= i; k++) {
+            long int shnode = i - binwidth * k;
+            long int deg = (long int) VECTOR(degree)[shnode];
+            long int age = (i - shnode) / binwidth;
+            IGRAPH_CHECK(igraph_psumtree_update(
+                &sumtree, shnode,
+                (pow(deg, pa_exp) + zero_appeal) * pow(age + 2, aging_exp)
+            ));
+        }
     }
-    IGRAPH_FINALLY_CLEAN(1);
 
-    if (modularity) {
-      IGRAPH_CHECK(igraph_modularity(graph, membership, weights,
-                                     /* resolution */ 1,
-                                     /* directed */ 1, modularity));
-    }
+    RNG_END();
+
+    igraph_dqueue_destroy(&history);
+    igraph_vector_destroy(&degree);
+    igraph_psumtree_destroy(&sumtree);
+    IGRAPH_FINALLY_CLEAN(3);
 
-    igraph_vector_destroy(&node_order);
-    igraph_vector_destroy(&label_counters);
-    igraph_vector_destroy(&dominant_labels);
-    igraph_vector_destroy(&nonzero_labels);
-    IGRAPH_FINALLY_CLEAN(4);
+    IGRAPH_CHECK(igraph_create(graph, &edges, nodes, directed));
+    igraph_vector_destroy(&edges);
+    IGRAPH_FINALLY_CLEAN(1);
 
-    return IGRAPH_SUCCESS;
+    return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/leading_eigenvector.c` & `igraph-0.9.9/vendor/source/igraph/src/community/leading_eigenvector.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/leiden.c` & `igraph-0.9.9/vendor/source/igraph/src/community/leiden.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/louvain.c` & `igraph-0.9.9/vendor/source/igraph/src/community/louvain.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/modularity.c` & `igraph-0.9.9/vendor/source/igraph/src/community/modularity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/optimal_modularity.c` & `igraph-0.9.9/vendor/source/igraph/src/community/optimal_modularity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetDataTypes.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetDataTypes.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -36,17 +36,14 @@
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-    #include <config.h>
-#endif
 
 #include "NetDataTypes.h"
 #include <cstring>
 
 //#################################################################################
 //###############################################################################
 //Constructor
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetDataTypes.h` & `igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetDataTypes.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetRoutines.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetRoutines.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/spinglass/NetRoutines.h` & `igraph-0.9.9/vendor/source/igraph/src/community/spinglass/NetRoutines.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/spinglass/clustertool.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/spinglass/clustertool.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -37,18 +37,14 @@
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
 
-#ifdef HAVE_CONFIG_H
-    #include <config.h>
-#endif
-
 #include "NetDataTypes.h"
 #include "NetRoutines.h"
 #include "pottsmodel_2.h"
 
 #include "igraph_community.h"
 #include "igraph_error.h"
 #include "igraph_random.h"
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/spinglass/pottsmodel_2.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/spinglass/pottsmodel_2.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -118,14 +118,17 @@
     DLList_Iter<NNode*> iter;
     DLList_Iter<NLink*> l_iter;
     NNode *n_cur;
     NLink *l_cur;
     double sum_weight;
     double av_k_squared = 0.0;
     double av_k = 0.0;
+    IGRAPH_UNUSED(av_k_squared); /* We mark it as unused to prevent warnings about unused-but-set-variables. */
+    IGRAPH_UNUSED(av_k);         /* We mark it as unused to prevent warnings about unused-but-set-variables. */
+
 //   printf("Assigning initial configuration...\n");
     // initialize colorfield
     for (unsigned int i = 0; i <= q; i++) {
         color_field[i] = 0.0;
     }
     //
     total_degree_sum = 0.0;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/spinglass/pottsmodel_2.h` & `igraph-0.9.9/vendor/source/igraph/src/community/spinglass/pottsmodel_2.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_communities.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_communities.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_communities.h` & `igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_communities.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_graph.h` & `igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_heap.cpp` & `igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_heap.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/community/walktrap/walktrap_heap.h` & `igraph-0.9.9/vendor/source/igraph/src/community/walktrap/walktrap_heap.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/config.h.in` & `igraph-0.9.9/vendor/source/igraph/src/config.h.in`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/connectivity/cohesive_blocks.c` & `igraph-0.9.9/vendor/source/igraph/src/connectivity/cohesive_blocks.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/connectivity/components.c` & `igraph-0.9.9/vendor/source/igraph/src/flow/st-cuts.c`

 * *Files 18% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 /* -*- mode: C -*-  */
 /*
    IGraph library.
-   Copyright (C) 2003-2012  Gabor Csardi <csardi.gabor@gmail.com>
+   Copyright (C) 2010-2012  Gabor Csardi <csardi.gabor@gmail.com>
    334 Harvard street, Cambridge, MA 02139 USA
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
@@ -17,1381 +17,1576 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
-#include "igraph_components.h"
+#include "igraph_flow.h"
 
 #include "igraph_adjlist.h"
-#include "igraph_dqueue.h"
+#include "igraph_constants.h"
+#include "igraph_constructors.h"
+#include "igraph_components.h"
+#include "igraph_error.h"
 #include "igraph_interface.h"
 #include "igraph_memory.h"
 #include "igraph_operators.h"
-#include "igraph_progress.h"
 #include "igraph_stack.h"
-#include "igraph_structural.h"
-#include "igraph_vector.h"
-
-#include "core/interruption.h"
-#include "operators/subgraph.h"
-
-#include <limits.h>
-
-static int igraph_i_clusters_weak(const igraph_t *graph, igraph_vector_t *membership,
-                                  igraph_vector_t *csize, igraph_integer_t *no);
+#include "igraph_visitor.h"
 
-static int igraph_i_clusters_strong(const igraph_t *graph, igraph_vector_t *membership,
-                                    igraph_vector_t *csize, igraph_integer_t *no);
+#include "core/math.h"
+#include "core/estack.h"
+#include "core/marked_queue.h"
+#include "graph/attributes.h"
+#include "flow/flow_internal.h"
+
+typedef int igraph_provan_shier_pivot_t(const igraph_t *graph,
+                                        const igraph_marked_queue_t *S,
+                                        const igraph_estack_t *T,
+                                        long int source,
+                                        long int target,
+                                        long int *v,
+                                        igraph_vector_t *Isv,
+                                        void *arg);
 
 /**
- * \ingroup structural
- * \function igraph_clusters
- * \brief Calculates the (weakly or strongly) connected components in a graph.
+ * \function igraph_even_tarjan_reduction
+ * Even-Tarjan reduction of a graph
  *
- * \param graph The graph object to analyze.
- * \param membership First half of the result will be stored here. For
- *        every vertex the id of its component is given. The vector
- *        has to be preinitialized and will be resized. Alternatively
- *        this argument can be \c NULL, in which case it is ignored.
- * \param csize The second half of the result. For every component it
- *        gives its size, the order is defined by the component ids.
- *        The vector has to be preinitialized and will be resized.
- *        Alternatively this argument can be \c NULL, in which
- *        case it is ignored.
- * \param no Pointer to an integer, if not \c NULL then the number of
- *        clusters will be stored here.
- * \param mode For directed graph this specifies whether to calculate
- *        weakly or strongly connected components. Possible values:
- *        \c IGRAPH_WEAK,
- *        \c IGRAPH_STRONG. This argument is
- *        ignored for undirected graphs.
- * \return Error code:
- *         \c IGRAPH_EINVAL: invalid mode argument.
+ * A digraph is created with twice as many vertices and edges. For each
+ * original vertex i, two vertices i'= i and i'' = i' + n are created,
+ * with a directed edge from i' to i''. For each original directed edge
+ * from i to j, two new edges are created, from i' to j'' and from i''
+ * to j'.
+ *
+ * </para><para>This reduction is used in the paper (observation 2):
+ * Arkady Kanevsky: Finding all minimum-size separating vertex sets in
+ * a graph, Networks 23, 533--541, 1993.
+ *
+ * </para><para>The original paper where this reduction was conceived is
+ * Shimon Even and R. Endre Tarjan: Network Flow and Testing Graph
+ * Connectivity, SIAM J. Comput., 4(4), 507–518.
+ *
+ * \param graph A graph. Although directness is not checked, this function
+ *        is commonly used only on directed graphs.
+ * \param graphbar Pointer to a new directed graph that will contain the
+ *        reduction, with twice as many vertices and edges.
+ * \param capacity Pointer to an initialized vector or a null pointer. If
+ *        not a null pointer, then it will be filled the capacity from
+ *        the reduction: the first |E| elements are 1, the remaining |E|
+ *        are equal to |V| (which is used to mean infinity).
+ * \return Error code.
+ *
+ * Time complexity: O(|E|+|V|).
  *
- * Time complexity: O(|V|+|E|),
- * |V| and
- * |E| are the number of vertices and
- * edges in the graph.
+ * \example examples/simple/even_tarjan.c
  */
 
-int igraph_clusters(const igraph_t *graph, igraph_vector_t *membership,
-                    igraph_vector_t *csize, igraph_integer_t *no,
-                    igraph_connectedness_t mode) {
-    if (mode == IGRAPH_WEAK || !igraph_is_directed(graph)) {
-        return igraph_i_clusters_weak(graph, membership, csize, no);
-    } else if (mode == IGRAPH_STRONG) {
-        return igraph_i_clusters_strong(graph, membership, csize, no);
-    }
-
-    IGRAPH_ERROR("Cannot calculate clusters", IGRAPH_EINVAL);
-}
-
-static int igraph_i_clusters_weak(const igraph_t *graph, igraph_vector_t *membership,
-                                  igraph_vector_t *csize, igraph_integer_t *no) {
+int igraph_even_tarjan_reduction(const igraph_t *graph, igraph_t *graphbar,
+                                 igraph_vector_t *capacity) {
 
     long int no_of_nodes = igraph_vcount(graph);
-    char *already_added;
-    long int first_node, act_cluster_size = 0, no_of_clusters = 1;
+    long int no_of_edges = igraph_ecount(graph);
 
-    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
+    long int new_no_of_nodes = no_of_nodes * 2;
+    long int new_no_of_edges = no_of_nodes + no_of_edges * 2;
 
+    igraph_vector_t edges;
+    long int edgeptr = 0, capptr = 0;
     long int i;
-    igraph_vector_t neis = IGRAPH_VECTOR_NULL;
 
-    already_added = IGRAPH_CALLOC(no_of_nodes, char);
-    if (already_added == 0) {
-        IGRAPH_ERROR("Cannot calculate clusters", IGRAPH_ENOMEM);
-    }
-    IGRAPH_FINALLY(igraph_free, already_added);
+    IGRAPH_VECTOR_INIT_FINALLY(&edges, new_no_of_edges * 2);
 
-    IGRAPH_DQUEUE_INIT_FINALLY(&q, no_of_nodes > 100000 ? 10000 : no_of_nodes / 10);
-    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
-
-    /* Memory for result, csize is dynamically allocated */
-    if (membership) {
-        IGRAPH_CHECK(igraph_vector_resize(membership, no_of_nodes));
-    }
-    if (csize) {
-        igraph_vector_clear(csize);
+    if (capacity) {
+        IGRAPH_CHECK(igraph_vector_resize(capacity, new_no_of_edges));
     }
 
-    /* The algorithm */
+    /* Every vertex 'i' is replaced by two vertices, i' and i'' */
+    /* id[i'] := id[i] ; id[i''] := id[i] + no_of_nodes */
 
-    for (first_node = 0; first_node < no_of_nodes; ++first_node) {
-        if (already_added[first_node] == 1) {
-            continue;
+    /* One edge for each original vertex, for i, we add (i',i'') */
+    for (i = 0; i < no_of_nodes; i++) {
+        VECTOR(edges)[edgeptr++] = i;
+        VECTOR(edges)[edgeptr++] = i + no_of_nodes;
+        if (capacity) {
+            VECTOR(*capacity)[capptr++] = 1.0;
         }
-        IGRAPH_ALLOW_INTERRUPTION();
+    }
 
-        already_added[first_node] = 1;
-        act_cluster_size = 1;
-        if (membership) {
-            VECTOR(*membership)[first_node] = no_of_clusters - 1;
-        }
-        IGRAPH_CHECK(igraph_dqueue_push(&q, first_node));
-
-        while ( !igraph_dqueue_empty(&q) ) {
-            long int act_node = (long int) igraph_dqueue_pop(&q);
-            IGRAPH_CHECK(igraph_neighbors(graph, &neis,
-                                          (igraph_integer_t) act_node, IGRAPH_ALL));
-            for (i = 0; i < igraph_vector_size(&neis); i++) {
-                long int neighbor = (long int) VECTOR(neis)[i];
-                if (already_added[neighbor] == 1) {
-                    continue;
-                }
-                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
-                already_added[neighbor] = 1;
-                act_cluster_size++;
-                if (membership) {
-                    VECTOR(*membership)[neighbor] = no_of_clusters - 1;
-                }
-            }
-        }
-        no_of_clusters++;
-        if (csize) {
-            IGRAPH_CHECK(igraph_vector_push_back(csize, act_cluster_size));
+    /* Two news edges for each original edge
+       (from,to) becomes (from'',to'), (to'',from') */
+    for (i = 0; i < no_of_edges; i++) {
+        long int from = IGRAPH_FROM(graph, i);
+        long int to = IGRAPH_TO(graph, i);
+        VECTOR(edges)[edgeptr++] = from + no_of_nodes;
+        VECTOR(edges)[edgeptr++] = to;
+        VECTOR(edges)[edgeptr++] = to + no_of_nodes;
+        VECTOR(edges)[edgeptr++] = from;
+        if (capacity) {
+            VECTOR(*capacity)[capptr++] = no_of_nodes; /* TODO: should be Inf */
+            VECTOR(*capacity)[capptr++] = no_of_nodes; /* TODO: should be Inf */
         }
     }
 
-    /* Cleaning up */
+    IGRAPH_CHECK(igraph_create(graphbar, &edges, (igraph_integer_t)
+                               new_no_of_nodes, IGRAPH_DIRECTED));
 
-    if (no) {
-        *no = (igraph_integer_t) no_of_clusters - 1;
-    }
-
-    IGRAPH_FREE(already_added);
-    igraph_dqueue_destroy(&q);
-    igraph_vector_destroy(&neis);
-    IGRAPH_FINALLY_CLEAN(3);
+    igraph_vector_destroy(&edges);
+    IGRAPH_FINALLY_CLEAN(1);
 
     return 0;
 }
 
-static int igraph_i_clusters_strong(const igraph_t *graph, igraph_vector_t *membership,
-                                    igraph_vector_t *csize, igraph_integer_t *no) {
+static int igraph_i_residual_graph(const igraph_t *graph,
+                                   const igraph_vector_t *capacity,
+                                   igraph_t *residual,
+                                   igraph_vector_t *residual_capacity,
+                                   const igraph_vector_t *flow,
+                                   igraph_vector_t *tmp) {
 
     long int no_of_nodes = igraph_vcount(graph);
-    igraph_vector_t next_nei = IGRAPH_VECTOR_NULL;
-
-    long int i, n, num_seen;
-    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
+    long int no_of_edges = igraph_ecount(graph);
+    long int i, no_new_edges = 0;
+    long int edgeptr = 0, capptr = 0;
+
+    for (i = 0; i < no_of_edges; i++) {
+        if (VECTOR(*flow)[i] < VECTOR(*capacity)[i]) {
+            no_new_edges++;
+        }
+    }
 
-    long int no_of_clusters = 1;
-    long int act_cluster_size;
+    IGRAPH_CHECK(igraph_vector_resize(tmp, no_new_edges * 2));
+    if (residual_capacity) {
+        IGRAPH_CHECK(igraph_vector_resize(residual_capacity, no_new_edges));
+    }
+
+    for (i = 0; i < no_of_edges; i++) {
+        igraph_real_t c = VECTOR(*capacity)[i] - VECTOR(*flow)[i];
+        if (c > 0) {
+            long int from = IGRAPH_FROM(graph, i);
+            long int to = IGRAPH_TO(graph, i);
+            VECTOR(*tmp)[edgeptr++] = from;
+            VECTOR(*tmp)[edgeptr++] = to;
+            if (residual_capacity) {
+                VECTOR(*residual_capacity)[capptr++] = c;
+            }
+        }
+    }
 
-    igraph_vector_t out = IGRAPH_VECTOR_NULL;
-    const igraph_vector_int_t* tmp;
+    IGRAPH_CHECK(igraph_create(residual, tmp, (igraph_integer_t) no_of_nodes,
+                               IGRAPH_DIRECTED));
 
-    igraph_adjlist_t adjlist;
+    return 0;
+}
 
-    /* The result */
+int igraph_residual_graph(const igraph_t *graph,
+                          const igraph_vector_t *capacity,
+                          igraph_t *residual,
+                          igraph_vector_t *residual_capacity,
+                          const igraph_vector_t *flow) {
 
-    IGRAPH_VECTOR_INIT_FINALLY(&next_nei, no_of_nodes);
-    IGRAPH_VECTOR_INIT_FINALLY(&out, 0);
-    IGRAPH_DQUEUE_INIT_FINALLY(&q, 100);
+    igraph_vector_t tmp;
+    long int no_of_edges = igraph_ecount(graph);
 
-    if (membership) {
-        IGRAPH_CHECK(igraph_vector_resize(membership, no_of_nodes));
+    if (igraph_vector_size(capacity) != no_of_edges) {
+        IGRAPH_ERROR("Invalid `capacity' vector size", IGRAPH_EINVAL);
     }
-    IGRAPH_CHECK(igraph_vector_reserve(&out, no_of_nodes));
-
-    igraph_vector_null(&out);
-    if (csize) {
-        igraph_vector_clear(csize);
+    if (igraph_vector_size(flow) != no_of_edges) {
+        IGRAPH_ERROR("Invalid `flow' vector size", IGRAPH_EINVAL);
     }
 
-    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
-
-    num_seen = 0;
-    for (i = 0; i < no_of_nodes; i++) {
-        IGRAPH_ALLOW_INTERRUPTION();
-
-        tmp = igraph_adjlist_get(&adjlist, i);
-        if (VECTOR(next_nei)[i] > igraph_vector_int_size(tmp)) {
-            continue;
-        }
-
-        IGRAPH_CHECK(igraph_dqueue_push(&q, i));
-        while (!igraph_dqueue_empty(&q)) {
-            long int act_node = (long int) igraph_dqueue_back(&q);
-            tmp = igraph_adjlist_get(&adjlist, act_node);
-            if (VECTOR(next_nei)[act_node] == 0) {
-                /* this is the first time we've met this vertex */
-                VECTOR(next_nei)[act_node]++;
-            } else if (VECTOR(next_nei)[act_node] <= igraph_vector_int_size(tmp)) {
-                /* we've already met this vertex but it has more children */
-                long int neighbor = (long int) VECTOR(*tmp)[(long int)
-                                    VECTOR(next_nei)[act_node] - 1];
-                if (VECTOR(next_nei)[neighbor] == 0) {
-                    IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
-                }
-                VECTOR(next_nei)[act_node]++;
-            } else {
-                /* we've met this vertex and it has no more children */
-                IGRAPH_CHECK(igraph_vector_push_back(&out, act_node));
-                igraph_dqueue_pop_back(&q);
-                num_seen++;
-
-                if (num_seen % 10000 == 0) {
-                    /* time to report progress and allow the user to interrupt */
-                    IGRAPH_PROGRESS("Strongly connected components: ",
-                                    num_seen * 50.0 / no_of_nodes, NULL);
-                    IGRAPH_ALLOW_INTERRUPTION();
-                }
-            }
-        } /* while q */
-    }  /* for */
+    IGRAPH_VECTOR_INIT_FINALLY(&tmp, 0);
 
-    IGRAPH_PROGRESS("Strongly connected components: ", 50.0, NULL);
+    IGRAPH_CHECK(igraph_i_residual_graph(graph, capacity, residual,
+                                         residual_capacity, flow, &tmp));
 
-    igraph_adjlist_destroy(&adjlist);
+    igraph_vector_destroy(&tmp);
     IGRAPH_FINALLY_CLEAN(1);
 
-    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_IN, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
-
-    /* OK, we've the 'out' values for the nodes, let's use them in
-       decreasing order with the help of a heap */
+    return 0;
+}
 
-    igraph_vector_null(&next_nei);             /* mark already added vertices */
-    num_seen = 0;
+static int igraph_i_reverse_residual_graph(const igraph_t *graph,
+                                           const igraph_vector_t *capacity,
+                                           igraph_t *residual,
+                                           const igraph_vector_t *flow,
+                                           igraph_vector_t *tmp) {
 
-    while (!igraph_vector_empty(&out)) {
-        long int grandfather = (long int) igraph_vector_pop_back(&out);
-
-        if (VECTOR(next_nei)[grandfather] != 0) {
-            continue;
-        }
-        VECTOR(next_nei)[grandfather] = 1;
-        act_cluster_size = 1;
-        if (membership) {
-            VECTOR(*membership)[grandfather] = no_of_clusters - 1;
-        }
-        IGRAPH_CHECK(igraph_dqueue_push(&q, grandfather));
-
-        num_seen++;
-        if (num_seen % 10000 == 0) {
-            /* time to report progress and allow the user to interrupt */
-            IGRAPH_PROGRESS("Strongly connected components: ",
-                            50.0 + num_seen * 50.0 / no_of_nodes, NULL);
-            IGRAPH_ALLOW_INTERRUPTION();
-        }
-
-        while (!igraph_dqueue_empty(&q)) {
-            long int act_node = (long int) igraph_dqueue_pop_back(&q);
-            tmp = igraph_adjlist_get(&adjlist, act_node);
-            n = igraph_vector_int_size(tmp);
-            for (i = 0; i < n; i++) {
-                long int neighbor = (long int) VECTOR(*tmp)[i];
-                if (VECTOR(next_nei)[neighbor] != 0) {
-                    continue;
-                }
-                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
-                VECTOR(next_nei)[neighbor] = 1;
-                act_cluster_size++;
-                if (membership) {
-                    VECTOR(*membership)[neighbor] = no_of_clusters - 1;
-                }
+    long int no_of_nodes = igraph_vcount(graph);
+    long int no_of_edges = igraph_ecount(graph);
+    long int i, no_new_edges = 0;
+    long int edgeptr = 0;
 
-                num_seen++;
-                if (num_seen % 10000 == 0) {
-                    /* time to report progress and allow the user to interrupt */
-                    IGRAPH_PROGRESS("Strongly connected components: ",
-                                    50.0 + num_seen * 50.0 / no_of_nodes, NULL);
-                    IGRAPH_ALLOW_INTERRUPTION();
-                }
-            }
+    for (i = 0; i < no_of_edges; i++) {
+        igraph_real_t cap = capacity ? VECTOR(*capacity)[i] : 1.0;
+        if (VECTOR(*flow)[i] > 0) {
+            no_new_edges++;
         }
+        if (VECTOR(*flow)[i] < cap) {
+            no_new_edges++;
+        }
+    }
 
-        no_of_clusters++;
-        if (csize) {
-            IGRAPH_CHECK(igraph_vector_push_back(csize, act_cluster_size));
+    IGRAPH_CHECK(igraph_vector_resize(tmp, no_new_edges * 2));
+
+    for (i = 0; i < no_of_edges; i++) {
+        long int from = IGRAPH_FROM(graph, i);
+        long int to = IGRAPH_TO(graph, i);
+        igraph_real_t cap = capacity ? VECTOR(*capacity)[i] : 1.0;
+        if (VECTOR(*flow)[i] > 0) {
+            VECTOR(*tmp)[edgeptr++] = from;
+            VECTOR(*tmp)[edgeptr++] = to;
+        }
+        if (VECTOR(*flow)[i] < cap) {
+            VECTOR(*tmp)[edgeptr++] = to;
+            VECTOR(*tmp)[edgeptr++] = from;
         }
     }
 
-    IGRAPH_PROGRESS("Strongly connected components: ", 100.0, NULL);
+    IGRAPH_CHECK(igraph_create(residual, tmp, (igraph_integer_t) no_of_nodes,
+                               IGRAPH_DIRECTED));
+
+    return 0;
+}
 
-    if (no) {
-        *no = (igraph_integer_t) no_of_clusters - 1;
+int igraph_reverse_residual_graph(const igraph_t *graph,
+                                  const igraph_vector_t *capacity,
+                                  igraph_t *residual,
+                                  const igraph_vector_t *flow) {
+    igraph_vector_t tmp;
+    long int no_of_edges = igraph_ecount(graph);
+
+    if (capacity && igraph_vector_size(capacity) != no_of_edges) {
+        IGRAPH_ERROR("Invalid `capacity' vector size", IGRAPH_EINVAL);
+    }
+    if (igraph_vector_size(flow) != no_of_edges) {
+        IGRAPH_ERROR("Invalid `flow' vector size", IGRAPH_EINVAL);
     }
+    IGRAPH_VECTOR_INIT_FINALLY(&tmp, 0);
 
-    /* Clean up, return */
+    IGRAPH_CHECK(igraph_i_reverse_residual_graph(graph, capacity, residual,
+                 flow, &tmp));
 
-    igraph_adjlist_destroy(&adjlist);
-    igraph_vector_destroy(&out);
-    igraph_dqueue_destroy(&q);
-    igraph_vector_destroy(&next_nei);
-    IGRAPH_FINALLY_CLEAN(4);
+    igraph_vector_destroy(&tmp);
+    IGRAPH_FINALLY_CLEAN(1);
 
     return 0;
 }
 
-int igraph_is_connected_weak(const igraph_t *graph, igraph_bool_t *res);
+typedef struct igraph_i_dbucket_t {
+    igraph_vector_long_t head;
+    igraph_vector_long_t next;
+} igraph_i_dbucket_t;
+
+static int igraph_i_dbucket_init(igraph_i_dbucket_t *buck, long int size) {
+    IGRAPH_CHECK(igraph_vector_long_init(&buck->head, size));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &buck->head);
+    IGRAPH_CHECK(igraph_vector_long_init(&buck->next, size));
+    IGRAPH_FINALLY_CLEAN(1);
+    return 0;
+}
 
-/**
- * \ingroup structural
- * \function igraph_is_connected
- * \brief Decides whether the graph is (weakly or strongly) connected.
- *
- * A graph with zero vertices (i.e. the null graph) is \em not connected by
- * definition. This behaviour changed in igraph 0.9; earlier versions assumed
- * that the null graph is connected. See the following issue on Github for the
- * argument that led us to change the definition:
- * https://github.com/igraph/igraph/issues/1538
- *
- * \param graph The graph object to analyze.
- * \param res Pointer to a logical variable, the result will be stored
- *        here.
- * \param mode For a directed graph this specifies whether to calculate
- *        weak or strong connectedness. Possible values:
- *        \c IGRAPH_WEAK,
- *        \c IGRAPH_STRONG. This argument is
- *        ignored for undirected graphs.
- * \return Error code:
- *        \c IGRAPH_EINVAL: invalid mode argument.
- *
- * Time complexity: O(|V|+|E|), the
- * number of vertices
- * plus the number of edges in the graph.
- */
+static void igraph_i_dbucket_destroy(igraph_i_dbucket_t *buck) {
+    igraph_vector_long_destroy(&buck->head);
+    igraph_vector_long_destroy(&buck->next);
+}
 
-int igraph_is_connected(const igraph_t *graph, igraph_bool_t *res,
-                        igraph_connectedness_t mode) {
-    if (igraph_vcount(graph) == 0) {
-        /* Changed in igraph 0.9; see https://github.com/igraph/igraph/issues/1538
-         * for the reasoning behind the change */
-        *res = 0;
-        return IGRAPH_SUCCESS;
-    }
-
-    if (mode == IGRAPH_WEAK || !igraph_is_directed(graph)) {
-        return igraph_is_connected_weak(graph, res);
-    } else if (mode == IGRAPH_STRONG) {
-        int retval;
-        igraph_integer_t no;
-        retval = igraph_i_clusters_strong(graph, 0, 0, &no);
-        *res = (no == 1);
-        return retval;
-    }
+static int igraph_i_dbucket_insert(igraph_i_dbucket_t *buck, long int bid,
+                                   long int elem) {
+    /* Note: we can do this, since elem is not in any buckets */
+    VECTOR(buck->next)[elem] = VECTOR(buck->head)[bid];
+    VECTOR(buck->head)[bid] = elem + 1;
+    return 0;
+}
 
-    IGRAPH_ERROR("mode argument", IGRAPH_EINVAL);
+static long int igraph_i_dbucket_empty(const igraph_i_dbucket_t *buck,
+                                       long int bid) {
+    return VECTOR(buck->head)[bid] == 0;
 }
 
-/**
- * \ingroup structural
- * \function igraph_is_connected_weak
- * \brief Query whether the graph is weakly connected.
- *
- * A graph with zero vertices (i.e. the null graph) is weakly connected by
- * definition. A directed graph is weakly connected if its undirected version
- * is connected. In the case of undirected graphs, weakly connected and
- * connected are equivalent.
- *
- * \param graph The graph object to analyze.
- * \param res Pointer to a logical variable; the result will be stored here.
- * \return Error code:
- *        \c IGRAPH_ENOMEM: unable to allocate requested memory.
- *
- * Time complexity: O(|V|+|E|), the number of vertices plus the number of
- * edges in the graph.
- */
+static long int igraph_i_dbucket_delete(igraph_i_dbucket_t *buck, long int bid) {
+    long int elem = VECTOR(buck->head)[bid] - 1;
+    VECTOR(buck->head)[bid] = VECTOR(buck->next)[elem];
+    return elem;
+}
 
-int igraph_is_connected_weak(const igraph_t *graph, igraph_bool_t *res) {
+static int igraph_i_dominator_LINK(long int v, long int w,
+                                   igraph_vector_long_t *ancestor) {
+    VECTOR(*ancestor)[w] = v + 1;
+    return 0;
+}
 
-    long int no_of_nodes = igraph_vcount(graph);
-    char *already_added;
-    igraph_vector_t neis = IGRAPH_VECTOR_NULL;
-    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
+/* TODO: don't always reallocate path */
 
-    long int i, j;
+static int igraph_i_dominator_COMPRESS(long int v,
+                                       igraph_vector_long_t *ancestor,
+                                       igraph_vector_long_t *label,
+                                       igraph_vector_long_t *semi) {
+    igraph_stack_long_t path;
+    long int w = v;
+    long int top, pretop;
 
-    if (no_of_nodes == 0) {
-        *res = 1;
-        return IGRAPH_SUCCESS;
-    }
+    IGRAPH_CHECK(igraph_stack_long_init(&path, 10));
+    IGRAPH_FINALLY(igraph_stack_long_destroy, &path);
 
-    already_added = IGRAPH_CALLOC(no_of_nodes, char);
-    if (already_added == 0) {
-        IGRAPH_ERROR("is connected (weak) failed", IGRAPH_ENOMEM);
+    while (VECTOR(*ancestor)[w] != 0) {
+        IGRAPH_CHECK(igraph_stack_long_push(&path, w));
+        w = VECTOR(*ancestor)[w] - 1;
     }
-    IGRAPH_FINALLY(igraph_free, already_added);
 
-    IGRAPH_DQUEUE_INIT_FINALLY(&q, 10);
-    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
+    top = igraph_stack_long_pop(&path);
+    while (!igraph_stack_long_empty(&path)) {
+        pretop = igraph_stack_long_pop(&path);
 
-    /* Try to find at least two clusters */
-    already_added[0] = 1;
-    IGRAPH_CHECK(igraph_dqueue_push(&q, 0));
-
-    j = 1;
-    while ( !igraph_dqueue_empty(&q)) {
-        long int actnode = (long int) igraph_dqueue_pop(&q);
-        IGRAPH_ALLOW_INTERRUPTION();
-        IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) actnode,
-                                      IGRAPH_ALL));
-        for (i = 0; i < igraph_vector_size(&neis); i++) {
-            long int neighbor = (long int) VECTOR(neis)[i];
-            if (already_added[neighbor] != 0) {
-                continue;
-            }
-            IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
-            j++;
-            already_added[neighbor]++;
+        if (VECTOR(*semi)[VECTOR(*label)[top]] <
+            VECTOR(*semi)[VECTOR(*label)[pretop]]) {
+            VECTOR(*label)[pretop] = VECTOR(*label)[top];
         }
-    }
+        VECTOR(*ancestor)[pretop] = VECTOR(*ancestor)[top];
 
-    /* Connected? */
-    *res = (j == no_of_nodes);
+        top = pretop;
+    }
 
-    IGRAPH_FREE(already_added);
-    igraph_dqueue_destroy(&q);
-    igraph_vector_destroy(&neis);
-    IGRAPH_FINALLY_CLEAN(3);
+    igraph_stack_long_destroy(&path);
+    IGRAPH_FINALLY_CLEAN(1);
 
     return 0;
 }
 
-/**
- * \function igraph_decompose_destroy
- * \brief Free the memory allocated by \ref igraph_decompose().
- *
- * \param complist The list of graph components, as returned by
- *        \ref igraph_decompose().
- *
- * Time complexity: O(c), c is the number of components.
- */
-
-void igraph_decompose_destroy(igraph_vector_ptr_t *complist) {
-    long int i;
-    for (i = 0; i < igraph_vector_ptr_size(complist); i++) {
-        if (VECTOR(*complist)[i] != 0) {
-            igraph_destroy(VECTOR(*complist)[i]);
-            igraph_free(VECTOR(*complist)[i]);
-        }
+static long int igraph_i_dominator_EVAL(long int v,
+                                        igraph_vector_long_t *ancestor,
+                                        igraph_vector_long_t *label,
+                                        igraph_vector_long_t *semi) {
+    if (VECTOR(*ancestor)[v] == 0) {
+        return v;
+    } else {
+        igraph_i_dominator_COMPRESS(v, ancestor, label, semi);
+        return VECTOR(*label)[v];
     }
 }
 
-static int igraph_i_decompose_weak(const igraph_t *graph,
-                                   igraph_vector_ptr_t *components,
-                                   long int maxcompno, long int minelements);
-
-static int igraph_i_decompose_strong(const igraph_t *graph,
-                                     igraph_vector_ptr_t *components,
-                                     long int maxcompno, long int minelements);
+/* TODO: implement the faster version. */
 
 /**
- * \function igraph_decompose
- * \brief Decompose a graph into connected components.
- *
- * Create separate graph for each component of a graph. Note that the
- * vertex ids in the new graphs will be different than in the original
- * graph. (Except if there is only one component in the original graph.)
- *
- * \param graph The original graph.
- * \param components This pointer vector will contain pointers to the
- *   subcomponent graphs. It should be initialized before calling this
- *   function and will be resized to hold the graphs. Don't forget to
- *   call \ref igraph_destroy() and \ref igraph_free() on the elements of
- *   this pointer vector to free unneeded memory. Alternatively, you can
- *   simply call \ref igraph_decompose_destroy() that does this for you.
- * \param mode Either \c IGRAPH_WEAK or \c IGRAPH_STRONG for weakly
- *    and strongly connected components respectively.
- * \param maxcompno The maximum number of components to return. The
- *    first \p maxcompno components will be returned (which hold at
- *    least \p minelements vertices, see the next parameter), the
- *    others will be ignored. Supply -1 here if you don't want to limit
- *    the number of components.
- * \param minelements The minimum number of vertices a component
- *    should contain in order to place it in the \p components
- *    vector. Eg. supply 2 here to ignore isolated vertices.
- * \return Error code, \c IGRAPH_ENOMEM if there is not enough memory
- *   to perform the operation.
+ * \function igraph_dominator_tree
+ * Calculates the dominator tree of a flowgraph
  *
- * Added in version 0.2.</para><para>
+ * A flowgraph is a directed graph with a distinguished start (or
+ * root) vertex r, such that for any vertex v, there is a path from r
+ * to v. A vertex v dominates another vertex w (not equal to v), if
+ * every path from r to w contains v. Vertex v is the immediate
+ * dominator or w, v=idom(w), if v dominates w and every other
+ * dominator of w dominates v. The edges {(idom(w), w)| w is not r}
+ * form a directed tree, rooted at r, called the dominator tree of the
+ * graph. Vertex v dominates vertex w if and only if v is an ancestor
+ * of w in the dominator tree.
+ *
+ * </para><para>This function implements the Lengauer-Tarjan algorithm
+ * to construct the dominator tree of a directed graph. For details
+ * please see Thomas Lengauer, Robert Endre Tarjan: A fast algorithm
+ * for finding dominators in a flowgraph, ACM Transactions on
+ * Programming Languages and Systems (TOPLAS) I/1, 121--141, 1979.
+ *
+ * \param graph A directed graph. If it is not a flowgraph, and it
+ *        contains some vertices not reachable from the root vertex,
+ *        then these vertices will be collected in the \c leftout
+ *        vector.
+ * \param root The id of the root (or source) vertex, this will be the
+ *        root of the tree.
+ * \param dom Pointer to an initialized vector or a null pointer. If
+ *        not a null pointer, then the immediate dominator of each
+ *        vertex will be stored here. For vertices that are not
+ *        reachable from the root, NaN is stored here. For
+ *        the root vertex itself, -1 is added.
+ * \param domtree Pointer to an uninitialized igraph_t, or NULL. If
+ *        not a null pointer, then the dominator tree is returned
+ *        here. The graph contains the vertices that are unreachable
+ *        from the root (if any), these will be isolates.
+ * \param leftout Pointer to an initialized vector object, or NULL. If
+ *        not NULL, then the ids of the vertices that are unreachable
+ *        from the root vertex (and thus not part of the dominator
+ *        tree) are stored here.
+ * \param mode Constant, must be \c IGRAPH_IN or \c IGRAPH_OUT. If it
+ *        is \c IGRAPH_IN, then all directions are considered as
+ *        opposite to the original one in the input graph.
+ * \return Error code.
  *
- * Time complexity: O(|V|+|E|), the number of vertices plus the number
- * of edges.
+ * Time complexity: very close to O(|E|+|V|), linear in the number of
+ * edges and vertices. More precisely, it is O(|V|+|E|alpha(|E|,|V|)),
+ * where alpha(|E|,|V|) is a functional inverse of Ackermann's
+ * function.
  *
- * \example examples/simple/igraph_decompose.c
+ * \example examples/simple/dominator_tree.c
  */
 
-int igraph_decompose(const igraph_t *graph, igraph_vector_ptr_t *components,
-                     igraph_connectedness_t mode,
-                     long int maxcompno, long int minelements) {
-    if (mode == IGRAPH_WEAK || !igraph_is_directed(graph)) {
-        return igraph_i_decompose_weak(graph, components, maxcompno, minelements);
-    } else if (mode == IGRAPH_STRONG) {
-        return igraph_i_decompose_strong(graph, components, maxcompno, minelements);
-    }
+int igraph_dominator_tree(const igraph_t *graph,
+                          igraph_integer_t root,
+                          igraph_vector_t *dom,
+                          igraph_t *domtree,
+                          igraph_vector_t *leftout,
+                          igraph_neimode_t mode) {
 
-    IGRAPH_ERROR("Cannot decompose graph", IGRAPH_EINVAL);
-}
+    long int no_of_nodes = igraph_vcount(graph);
 
-static int igraph_i_decompose_weak(const igraph_t *graph,
-                                   igraph_vector_ptr_t *components,
-                                   long int maxcompno, long int minelements) {
+    igraph_adjlist_t succ, pred;
+    igraph_vector_t parent;
+    igraph_vector_long_t semi;    /* +1 always */
+    igraph_vector_t vertex;   /* +1 always */
+    igraph_i_dbucket_t bucket;
+    igraph_vector_long_t ancestor;
+    igraph_vector_long_t label;
+
+    igraph_neimode_t invmode = mode == IGRAPH_IN ? IGRAPH_OUT : IGRAPH_IN;
 
-    long int actstart;
-    long int no_of_nodes = igraph_vcount(graph);
-    long int resco = 0;   /* number of graphs created so far */
-    char *already_added;
-    igraph_dqueue_t q;
-    igraph_vector_t verts;
-    igraph_vector_t neis;
-    igraph_vector_t vids_old2new;
     long int i;
-    igraph_t *newg;
 
+    igraph_vector_t vdom, *mydom = dom;
 
-    if (maxcompno < 0) {
-        maxcompno = LONG_MAX;
-    }
+    long int component_size = 0;
 
-    igraph_vector_ptr_clear(components);
-    IGRAPH_FINALLY(igraph_decompose_destroy, components);
+    if (root < 0 || root >= no_of_nodes) {
+        IGRAPH_ERROR("Invalid root vertex id for dominator tree",
+                     IGRAPH_EINVAL);
+    }
+
+    if (!igraph_is_directed(graph)) {
+        IGRAPH_ERROR("Dominator tree of an undirected graph requested",
+                     IGRAPH_EINVAL);
+    }
+
+    if (mode == IGRAPH_ALL) {
+        IGRAPH_ERROR("Invalid neighbor mode for dominator tree",
+                     IGRAPH_EINVAL);
+    }
+
+    if (dom) {
+        IGRAPH_CHECK(igraph_vector_resize(dom, no_of_nodes));
+    } else {
+        mydom = &vdom;
+        IGRAPH_VECTOR_INIT_FINALLY(mydom, no_of_nodes);
+    }
+    igraph_vector_fill(mydom, IGRAPH_NAN);
+
+    IGRAPH_CHECK(igraph_vector_init(&parent, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_destroy, &parent);
+    IGRAPH_CHECK(igraph_vector_long_init(&semi, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &semi);
+    IGRAPH_CHECK(igraph_vector_init(&vertex, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_destroy, &vertex);
+    IGRAPH_CHECK(igraph_vector_long_init(&ancestor, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &ancestor);
+    IGRAPH_CHECK(igraph_vector_long_init_seq(&label, 0, no_of_nodes - 1));
+    IGRAPH_FINALLY(igraph_vector_long_destroy, &label);
+    IGRAPH_CHECK(igraph_adjlist_init(graph, &succ, mode, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
+    IGRAPH_FINALLY(igraph_adjlist_destroy, &succ);
+    IGRAPH_CHECK(igraph_adjlist_init(graph, &pred, invmode, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
+    IGRAPH_FINALLY(igraph_adjlist_destroy, &pred);
+    IGRAPH_CHECK(igraph_i_dbucket_init(&bucket, no_of_nodes));
+    IGRAPH_FINALLY(igraph_i_dbucket_destroy, &bucket);
+
+    /* DFS first, to set semi, vertex and parent, step 1 */
+
+    IGRAPH_CHECK(igraph_dfs(graph, root, mode, /*unreachable=*/ 0,
+                            /*order=*/ &vertex,
+                            /*order_out=*/ 0, /*father=*/ &parent,
+                            /*dist=*/ 0, /*in_callback=*/ 0,
+                            /*out_callback=*/ 0, /*extra=*/ 0));
 
-    /* already_added keeps track of what nodes made it into a graph already */
-    already_added = IGRAPH_CALLOC(no_of_nodes, char);
-    if (already_added == 0) {
-        IGRAPH_ERROR("Cannot decompose graph", IGRAPH_ENOMEM);
+    for (i = 0; i < no_of_nodes; i++) {
+        if (IGRAPH_FINITE(VECTOR(vertex)[i])) {
+            long int t = (long int) VECTOR(vertex)[i];
+            VECTOR(semi)[t] = component_size + 1;
+            VECTOR(vertex)[component_size] = t + 1;
+            component_size++;
+        }
+    }
+    if (leftout) {
+        long int n = no_of_nodes - component_size;
+        long int p = 0, j;
+        IGRAPH_CHECK(igraph_vector_resize(leftout, n));
+        for (j = 0; j < no_of_nodes && p < n; j++) {
+            if (!IGRAPH_FINITE(VECTOR(parent)[j])) {
+                VECTOR(*leftout)[p++] = j;
+            }
+        }
     }
-    IGRAPH_FINALLY(igraph_free, already_added);
 
-    IGRAPH_CHECK(igraph_dqueue_init(&q, 100));
-    IGRAPH_FINALLY(igraph_dqueue_destroy, &q);
-    IGRAPH_VECTOR_INIT_FINALLY(&verts, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&vids_old2new, no_of_nodes);
+    /* We need to go over 'pred' because it should contain only the
+       edges towards the target vertex. */
+    for (i = 0; i < no_of_nodes; i++) {
+        igraph_vector_int_t *v = igraph_adjlist_get(&pred, i);
+        long int j, n = igraph_vector_int_size(v);
+        for (j = 0; j < n; ) {
+            long int v2 = (long int) VECTOR(*v)[j];
+            if (IGRAPH_FINITE(VECTOR(parent)[v2])) {
+                j++;
+            } else {
+                VECTOR(*v)[j] = VECTOR(*v)[n - 1];
+                igraph_vector_int_pop_back(v);
+                n--;
+            }
+        }
+    }
 
-    /* vids_old2new would have been created internally in igraph_induced_subgraph(),
-       but it is slow if the graph is large and consists of many small components,
-       so we create it once here and then re-use it */
-
-    /* add a node and its neighbors at once, recursively
-       then switch to next node that has not been added already */
-    for (actstart = 0; resco < maxcompno && actstart < no_of_nodes; actstart++) {
-
-        if (already_added[actstart]) {
-            continue;
-        }
-        IGRAPH_ALLOW_INTERRUPTION();
-
-        igraph_vector_clear(&verts);
-
-        /* add the node itself */
-        already_added[actstart] = 1;
-        IGRAPH_CHECK(igraph_vector_push_back(&verts, actstart));
-        IGRAPH_CHECK(igraph_dqueue_push(&q, actstart));
-
-        /* add the neighbors, recursively */
-        while (!igraph_dqueue_empty(&q) ) {
-            /* pop from the queue of this component */
-            long int actvert = (long int) igraph_dqueue_pop(&q);
-            IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) actvert,
-                                          IGRAPH_ALL));
-            /* iterate over the neighbors */
-            for (i = 0; i < igraph_vector_size(&neis); i++) {
-                long int neighbor = (long int) VECTOR(neis)[i];
-                if (already_added[neighbor] == 1) {
-                    continue;
-                }
-                /* add neighbor */
-                already_added[neighbor] = 1;
+    /* Now comes the main algorithm, steps 2 & 3 */
 
-                /* recursion: append neighbor to the queues */
-                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
-                IGRAPH_CHECK(igraph_vector_push_back(&verts, neighbor));
+    for (i = component_size - 1; i > 0; i--) {
+        long int w = (long int) VECTOR(vertex)[i] - 1;
+        igraph_vector_int_t *predw = igraph_adjlist_get(&pred, w);
+        long int j, n = igraph_vector_int_size(predw);
+        for (j = 0; j < n; j++) {
+            long int v = (long int) VECTOR(*predw)[j];
+            long int u = igraph_i_dominator_EVAL(v, &ancestor, &label, &semi);
+            if (VECTOR(semi)[u] < VECTOR(semi)[w]) {
+                VECTOR(semi)[w] = VECTOR(semi)[u];
             }
         }
-
-        /* ok, we have a component */
-        if (igraph_vector_size(&verts) < minelements) {
-            continue;
+        igraph_i_dbucket_insert(&bucket, (long int)
+                                VECTOR(vertex)[ VECTOR(semi)[w] - 1 ] - 1, w);
+        igraph_i_dominator_LINK((long int) VECTOR(parent)[w], w, &ancestor);
+        while (!igraph_i_dbucket_empty(&bucket, (long int) VECTOR(parent)[w])) {
+            long int v = igraph_i_dbucket_delete(&bucket, (long int) VECTOR(parent)[w]);
+            long int u = igraph_i_dominator_EVAL(v, &ancestor, &label, &semi);
+            VECTOR(*mydom)[v] = VECTOR(semi)[u] < VECTOR(semi)[v] ? u :
+                                VECTOR(parent)[w];
         }
+    }
 
-        newg = IGRAPH_CALLOC(1, igraph_t);
-        if (newg == 0) {
-            IGRAPH_ERROR("Cannot decompose graph", IGRAPH_ENOMEM);
-        }
-        IGRAPH_CHECK(igraph_vector_ptr_push_back(components, newg));
-        IGRAPH_CHECK(igraph_i_induced_subgraph_map(
-            graph, newg, igraph_vss_vector(&verts),
-            IGRAPH_SUBGRAPH_AUTO, &vids_old2new,
-            /* invmap = */ 0, /* map_is_prepared = */ 1
-        ));
-        resco++;
+    /* Finally, step 4 */
+
+    for (i = 1; i < component_size; i++) {
+        long int w = (long int) VECTOR(vertex)[i] - 1;
+        if (VECTOR(*mydom)[w] != VECTOR(vertex)[VECTOR(semi)[w] - 1] - 1) {
+            VECTOR(*mydom)[w] = VECTOR(*mydom)[(long int)VECTOR(*mydom)[w]];
+        }
+    }
+    VECTOR(*mydom)[(long int)root] = -1;
+
+    igraph_i_dbucket_destroy(&bucket);
+    igraph_adjlist_destroy(&pred);
+    igraph_adjlist_destroy(&succ);
+    igraph_vector_long_destroy(&label);
+    igraph_vector_long_destroy(&ancestor);
+    igraph_vector_destroy(&vertex);
+    igraph_vector_long_destroy(&semi);
+    igraph_vector_destroy(&parent);
+    IGRAPH_FINALLY_CLEAN(8);
 
-        /* vids_old2new does not have to be cleaned up here; since we are doing
-         * weak decomposition, each vertex will appear in only one of the
-         * connected components so we won't ever touch an item in vids_old2new
-         * if it was already set to a non-zero value in a previous component */
+    if (domtree) {
+        igraph_vector_t edges;
+        long int ptr = 0;
+        IGRAPH_VECTOR_INIT_FINALLY(&edges, component_size * 2 - 2);
+        for (i = 0; i < no_of_nodes; i++) {
+            if (i != root && IGRAPH_FINITE(VECTOR(*mydom)[i])) {
+                if (mode == IGRAPH_OUT) {
+                    VECTOR(edges)[ptr++] = VECTOR(*mydom)[i];
+                    VECTOR(edges)[ptr++] = i;
+                } else {
+                    VECTOR(edges)[ptr++] = i;
+                    VECTOR(edges)[ptr++] = VECTOR(*mydom)[i];
+                }
+            }
+        }
+        IGRAPH_CHECK(igraph_create(domtree, &edges, (igraph_integer_t) no_of_nodes,
+                                   IGRAPH_DIRECTED));
+        igraph_vector_destroy(&edges);
+        IGRAPH_FINALLY_CLEAN(1);
 
-    } /* for actstart++ */
+        IGRAPH_I_ATTRIBUTE_DESTROY(domtree);
+        IGRAPH_I_ATTRIBUTE_COPY(domtree, graph, /*graph=*/ 1, /*vertex=*/ 1,
+                                /*edge=*/ 0);
+    }
 
-    igraph_vector_destroy(&vids_old2new);
-    igraph_vector_destroy(&neis);
-    igraph_vector_destroy(&verts);
-    igraph_dqueue_destroy(&q);
-    IGRAPH_FREE(already_added);
-    IGRAPH_FINALLY_CLEAN(6);  /* + components */
+    if (!dom) {
+        igraph_vector_destroy(&vdom);
+        IGRAPH_FINALLY_CLEAN(1);
+    }
 
     return 0;
 }
 
-static int igraph_i_decompose_strong(const igraph_t *graph,
-                                     igraph_vector_ptr_t *components,
-                                     long int maxcompno, long int minelements) {
+typedef struct igraph_i_all_st_cuts_minimal_dfs_data_t {
+    igraph_stack_t *stack;
+    igraph_vector_bool_t *nomark;
+    const igraph_vector_bool_t *GammaX;
+    long int root;
+    const igraph_vector_t *map;
+} igraph_i_all_st_cuts_minimal_dfs_data_t;
+
+static igraph_bool_t igraph_i_all_st_cuts_minimal_dfs_incb(
+        const igraph_t *graph,
+        igraph_integer_t vid,
+        igraph_integer_t dist,
+        void *extra) {
+
+    igraph_i_all_st_cuts_minimal_dfs_data_t *data = extra;
+    igraph_stack_t *stack = data->stack;
+    igraph_vector_bool_t *nomark = data->nomark;
+    const igraph_vector_bool_t *GammaX = data->GammaX;
+    const igraph_vector_t *map = data->map;
+    long int realvid = (long int) VECTOR(*map)[(long int)vid];
+
+    IGRAPH_UNUSED(graph); IGRAPH_UNUSED(dist);
+
+    if (VECTOR(*GammaX)[(long int)realvid]) {
+        if (!igraph_stack_empty(stack)) {
+            long int top = (long int) igraph_stack_top(stack);
+            VECTOR(*nomark)[top] = 1; /* we just found a smaller one */
+        }
+        igraph_stack_push(stack, realvid); /* TODO: error check */
+    }
+
+    return 0;
+}
 
+static igraph_bool_t igraph_i_all_st_cuts_minimal_dfs_otcb(
+        const igraph_t *graph,
+        igraph_integer_t vid,
+        igraph_integer_t dist,
+        void *extra) {
+    igraph_i_all_st_cuts_minimal_dfs_data_t *data = extra;
+    igraph_stack_t *stack = data->stack;
+    const igraph_vector_t *map = data->map;
+    long int realvid = (long int) VECTOR(*map)[(long int)vid];
+
+    IGRAPH_UNUSED(graph); IGRAPH_UNUSED(dist);
+
+    if (!igraph_stack_empty(stack) &&
+        igraph_stack_top(stack) == realvid) {
+        igraph_stack_pop(stack);
+    }
 
-    long int no_of_nodes = igraph_vcount(graph);
+    return 0;
+}
 
-    /* this is a heap used twice for checking what nodes have
-     * been counted already */
-    igraph_vector_t next_nei = IGRAPH_VECTOR_NULL;
+static int igraph_i_all_st_cuts_minimal(const igraph_t *graph,
+                                        const igraph_t *domtree,
+                                        long int root,
+                                        const igraph_marked_queue_t *X,
+                                        const igraph_vector_bool_t *GammaX,
+                                        const igraph_vector_t *invmap,
+                                        igraph_vector_t *minimal) {
 
-    long int i, n, num_seen;
-    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
+    long int no_of_nodes = igraph_vcount(graph);
+    igraph_stack_t stack;
+    igraph_vector_bool_t nomark;
+    igraph_i_all_st_cuts_minimal_dfs_data_t data;
+    long int i;
 
-    long int no_of_clusters = 0;
-    long int act_cluster_size;
+    IGRAPH_UNUSED(X);
 
-    igraph_vector_t out = IGRAPH_VECTOR_NULL;
-    const igraph_vector_int_t* tmp;
+    IGRAPH_CHECK(igraph_stack_init(&stack, 10));
+    IGRAPH_FINALLY(igraph_stack_destroy, &stack);
+    IGRAPH_CHECK(igraph_vector_bool_init(&nomark, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_bool_destroy, &nomark);
+
+    data.stack = &stack;
+    data.nomark = &nomark;
+    data.GammaX = GammaX;
+    data.root = root;
+    data.map = invmap;
+
+    /* We mark all GammaX elements as minimal first.
+       TODO: actually, we could just use GammaX to return the minimal
+       elements. */
+    for (i = 0; i < no_of_nodes; i++) {
+        VECTOR(nomark)[i] = VECTOR(*GammaX)[i] == 0 ? 1 : 0;
+    }
 
-    igraph_adjlist_t adjlist;
-    igraph_vector_t verts;
-    igraph_vector_t vids_old2new;
-    igraph_t *newg;
+    /* We do a reverse DFS from root. If, along a path we find a GammaX
+       vertex after (=below) another GammaX vertex, we mark the higher
+       one as non-minimal. */
+
+    IGRAPH_CHECK(igraph_dfs(domtree, (igraph_integer_t) root, IGRAPH_IN,
+                            /*unreachable=*/ 0, /*order=*/ 0,
+                            /*order_out=*/ 0, /*father=*/ 0,
+                            /*dist=*/ 0, /*in_callback=*/
+                            igraph_i_all_st_cuts_minimal_dfs_incb,
+                            /*out_callback=*/
+                            igraph_i_all_st_cuts_minimal_dfs_otcb,
+                            /*extra=*/ &data));
 
-    if (maxcompno < 0) {
-        maxcompno = LONG_MAX;
+    igraph_vector_clear(minimal);
+    for (i = 0; i < no_of_nodes; i++) {
+        if (!VECTOR(nomark)[i]) {
+            IGRAPH_CHECK(igraph_vector_push_back(minimal, i));
+        }
     }
 
-    igraph_vector_ptr_clear(components);
-    IGRAPH_FINALLY(igraph_decompose_destroy, components);
+    igraph_vector_bool_destroy(&nomark);
+    igraph_stack_destroy(&stack);
+    IGRAPH_FINALLY_CLEAN(2);
 
-    /* The result */
+    return 0;
+}
 
-    IGRAPH_VECTOR_INIT_FINALLY(&vids_old2new, no_of_nodes);
-    IGRAPH_VECTOR_INIT_FINALLY(&verts, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&next_nei, no_of_nodes);
-    IGRAPH_VECTOR_INIT_FINALLY(&out, 0);
-    IGRAPH_DQUEUE_INIT_FINALLY(&q, 100);
+/* not 'static' because used in igraph_all_st_cuts.c test program */
+int igraph_i_all_st_cuts_pivot(const igraph_t *graph,
+                               const igraph_marked_queue_t *S,
+                               const igraph_estack_t *T,
+                               long int source,
+                               long int target,
+                               long int *v,
+                               igraph_vector_t *Isv,
+                               void *arg) {
 
-    IGRAPH_CHECK(igraph_vector_reserve(&out, no_of_nodes));
+    long int no_of_nodes = igraph_vcount(graph);
+    igraph_t Sbar;
+    igraph_vector_t Sbar_map, Sbar_invmap;
+    igraph_vector_t keep;
+    igraph_t domtree;
+    igraph_vector_t leftout;
+    long int i, nomin, n;
+    long int root;
+    igraph_vector_t M;
+    igraph_vector_bool_t GammaS;
+    igraph_vector_t Nuv;
+    igraph_vector_t Isv_min;
+    igraph_vector_t GammaS_vec;
+    long int Sbar_size;
+
+    IGRAPH_UNUSED(arg);
+
+    /* We need to create the graph induced by Sbar */
+    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_map, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_invmap, 0);
 
-    igraph_vector_null(&out);
+    IGRAPH_VECTOR_INIT_FINALLY(&keep, 0);
+    for (i = 0; i < no_of_nodes; i++) {
+        if (!igraph_marked_queue_iselement(S, i)) {
+            IGRAPH_CHECK(igraph_vector_push_back(&keep, i));
+        }
+    }
+    Sbar_size = igraph_vector_size(&keep);
 
-    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
+    IGRAPH_CHECK(igraph_induced_subgraph_map(graph, &Sbar,
+                 igraph_vss_vector(&keep),
+                 IGRAPH_SUBGRAPH_AUTO,
+                 /* map= */ &Sbar_map,
+                 /* invmap= */ &Sbar_invmap));
+    igraph_vector_destroy(&keep);
+    IGRAPH_FINALLY_CLEAN(1);
+    IGRAPH_FINALLY(igraph_destroy, &Sbar);
 
-    /* vids_old2new would have been created internally in igraph_induced_subgraph(),
-       but it is slow if the graph is large and consists of many small components,
-       so we create it once here and then re-use it */
+    root = (long int) VECTOR(Sbar_map)[target] - 1;
 
-    /* number of components seen */
-    num_seen = 0;
-    /* populate the 'out' vector by browsing a node and following up
-       all its neighbors recursively, then switching to the next
-       unassigned node */
-    for (i = 0; i < no_of_nodes; i++) {
-        IGRAPH_ALLOW_INTERRUPTION();
+    /* -------------------------------------------------------------*/
+    /* Construct the dominator tree of Sbar */
 
-        /* get all the 'out' neighbors of this node
-         * NOTE: next_nei is initialized [0, 0, ...] */
-        tmp = igraph_adjlist_get(&adjlist, i);
-        if (VECTOR(next_nei)[i] > igraph_vector_int_size(tmp)) {
-            continue;
-        }
-
-        /* add this node to the queue for this component */
-        IGRAPH_CHECK(igraph_dqueue_push(&q, i));
-
-        /* consume the tree from this node ("root") recursively
-         * until there is no more */
-        while (!igraph_dqueue_empty(&q)) {
-            /* this looks up but does NOT consume the queue */
-            long int act_node = (long int) igraph_dqueue_back(&q);
-
-            /* get all neighbors of this node */
-            tmp = igraph_adjlist_get(&adjlist, act_node);
-            if (VECTOR(next_nei)[act_node] == 0) {
-                /* this is the first time we've met this vertex,
-                     * because next_nei is initialized [0, 0, ...] */
-                VECTOR(next_nei)[act_node]++;
-                /* back to the queue, same vertex is up again */
-
-            } else if (VECTOR(next_nei)[act_node] <= igraph_vector_int_size(tmp)) {
-                /* we've already met this vertex but it has more children */
-                long int neighbor = (long int) VECTOR(*tmp)[(long int)
-                                    VECTOR(next_nei)[act_node] - 1];
-                if (VECTOR(next_nei)[neighbor] == 0) {
-                    /* add the root of the other children to the queue */
-                    IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
-                }
-                VECTOR(next_nei)[act_node]++;
-            } else {
-                /* we've met this vertex and it has no more children */
-                IGRAPH_CHECK(igraph_vector_push_back(&out, act_node));
-                /* this consumes the queue, since there's nowhere to go */
-                igraph_dqueue_pop_back(&q);
-                num_seen++;
-
-                if (num_seen % 10000 == 0) {
-                    /* time to report progress and allow the user to interrupt */
-                    IGRAPH_PROGRESS("Strongly connected components: ",
-                                    num_seen * 50.0 / no_of_nodes, NULL);
-                    IGRAPH_ALLOW_INTERRUPTION();
+    IGRAPH_VECTOR_INIT_FINALLY(&leftout, 0);
+    IGRAPH_CHECK(igraph_dominator_tree(&Sbar, (igraph_integer_t) root,
+                                       /*dom=*/ 0, &domtree,
+                                       &leftout, IGRAPH_IN));
+    IGRAPH_FINALLY(igraph_destroy, &domtree);
+
+    /* -------------------------------------------------------------*/
+    /* Identify the set M of minimal elements of Gamma(S) with respect
+       to the dominator relation. */
+
+    /* First we create GammaS */
+    /* TODO: use the adjacency list, instead of neighbors() */
+    IGRAPH_CHECK(igraph_vector_bool_init(&GammaS, no_of_nodes));
+    IGRAPH_FINALLY(igraph_vector_bool_destroy, &GammaS);
+    if (igraph_marked_queue_size(S) == 0) {
+        VECTOR(GammaS)[(long int) VECTOR(Sbar_map)[source] - 1] = 1;
+    } else {
+        for (i = 0; i < no_of_nodes; i++) {
+            if (igraph_marked_queue_iselement(S, i)) {
+                igraph_vector_t neis;
+                long int j;
+                IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
+                IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) i,
+                                              IGRAPH_OUT));
+                n = igraph_vector_size(&neis);
+                for (j = 0; j < n; j++) {
+                    long int nei = (long int) VECTOR(neis)[j];
+                    if (!igraph_marked_queue_iselement(S, nei)) {
+                        VECTOR(GammaS)[nei] = 1;
+                    }
                 }
+                igraph_vector_destroy(&neis);
+                IGRAPH_FINALLY_CLEAN(1);
             }
-        } /* while q */
-    }  /* for */
-
-    IGRAPH_PROGRESS("Strongly connected components: ", 50.0, NULL);
+        }
+    }
 
-    igraph_adjlist_destroy(&adjlist);
-    IGRAPH_FINALLY_CLEAN(1);
+    /* Relabel left out vertices (set K in Provan & Shier) to
+       correspond to node labelling of graph instead of SBar.
+       At the same time ensure that GammaS is a proper subset of
+       L, where L are the nodes in the dominator tree. */
+    n = igraph_vector_size(&leftout);
+    for (i = 0; i < n; i++) {
+        VECTOR(leftout)[i] = VECTOR(Sbar_invmap)[(long int)VECTOR(leftout)[i]];
+        VECTOR(GammaS)[(long int)VECTOR(leftout)[i]] = 0;
+    }
 
-    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, IGRAPH_IN, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);
+    IGRAPH_VECTOR_INIT_FINALLY(&M, 0);
+    if (igraph_ecount(&domtree) > 0) {
+        IGRAPH_CHECK(igraph_i_all_st_cuts_minimal(graph, &domtree, root, S,
+                     &GammaS, &Sbar_invmap, &M));
+    }
 
-    /* OK, we've the 'out' values for the nodes, let's use them in
-     * decreasing order with the help of the next_nei heap */
+    igraph_vector_clear(Isv);
+    IGRAPH_VECTOR_INIT_FINALLY(&Nuv, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&Isv_min, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&GammaS_vec, 0);
+    for (i = 0; i < no_of_nodes; i++) {
+        if (VECTOR(GammaS)[i]) {
+            IGRAPH_CHECK(igraph_vector_push_back(&GammaS_vec, i));
+        }
+    }
 
-    igraph_vector_null(&next_nei);             /* mark already added vertices */
+    nomin = igraph_vector_size(&M);
+    for (i = 0; i < nomin; i++) {
+        /* -------------------------------------------------------------*/
+        /* For each v in M find the set Nu(v)=dom(Sbar, v)-K
+           Nu(v) contains all vertices that are dominated by v, for every
+           v, this is a subtree of the dominator tree, rooted at v. The
+           different subtrees are disjoint. */
+        long int min = (long int) VECTOR(Sbar_map)[(long int) VECTOR(M)[i] ] - 1;
+        long int nuvsize, isvlen, j;
+        IGRAPH_CHECK(igraph_dfs(&domtree, (igraph_integer_t) min, IGRAPH_IN,
+                                /*unreachable=*/ 0, /*order=*/ &Nuv,
+                                /*order_out=*/ 0, /*father=*/ 0, /*dist=*/ 0,
+                                /*in_callback=*/ 0, /*out_callback=*/ 0,
+                                /*extra=*/ 0));
+        /* Remove the NAN values from the end of the vector */
+        for (nuvsize = 0; nuvsize < Sbar_size; nuvsize++) {
+            igraph_real_t t = VECTOR(Nuv)[nuvsize];
+            if (IGRAPH_FINITE(t)) {
+                VECTOR(Nuv)[nuvsize] = VECTOR(Sbar_invmap)[(long int) t];
+            } else {
+                break;
+            }
+        }
+        igraph_vector_resize(&Nuv, nuvsize);
 
-    /* number of components built */
-    num_seen = 0;
-    while (!igraph_vector_empty(&out) && no_of_clusters < maxcompno) {
-        /* consume the vector from the last element */
-        long int grandfather = (long int) igraph_vector_pop_back(&out);
-
-        /* been here, done that
-         * NOTE: next_nei is initialized as [0, 0, ...] */
-        if (VECTOR(next_nei)[grandfather] != 0) {
-            continue;
-        }
-
-        /* collect all the members of this component */
-        igraph_vector_clear(&verts);
-
-        /* this node is gone for any future components */
-        VECTOR(next_nei)[grandfather] = 1;
-        act_cluster_size = 1;
-
-        /* add to component */
-        IGRAPH_CHECK(igraph_vector_push_back(&verts, grandfather));
-        IGRAPH_CHECK(igraph_dqueue_push(&q, grandfather));
-
-        num_seen++;
-        if (num_seen % 10000 == 0) {
-            /* time to report progress and allow the user to interrupt */
-            IGRAPH_PROGRESS("Strongly connected components: ",
-                            50.0 + num_seen * 50.0 / no_of_nodes, NULL);
-            IGRAPH_ALLOW_INTERRUPTION();
-        }
-
-        while (!igraph_dqueue_empty(&q)) {
-            /* consume the queue from this node */
-            long int act_node = (long int) igraph_dqueue_pop_back(&q);
-            tmp = igraph_adjlist_get(&adjlist, act_node);
-            n = igraph_vector_int_size(tmp);
-            for (i = 0; i < n; i++) {
-                long int neighbor = (long int) VECTOR(*tmp)[i];
-                if (VECTOR(next_nei)[neighbor] != 0) {
-                    continue;
-                }
-                IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
-                VECTOR(next_nei)[neighbor] = 1;
-                act_cluster_size++;
-
-                /* add to component */
-                IGRAPH_CHECK(igraph_vector_push_back(&verts, neighbor));
-
-                num_seen++;
-                if (num_seen % 10000 == 0) {
-                    /* time to report progress and allow the user to interrupt */
-                    IGRAPH_PROGRESS("Strongly connected components: ",
-                                    50.0 + num_seen * 50.0 / no_of_nodes, NULL);
-                    IGRAPH_ALLOW_INTERRUPTION();
-                }
+        /* -------------------------------------------------------------*/
+        /* By a BFS search of <Nu(v)> determine I(S,v)-K.
+           I(S,v) contains all vertices that are in Nu(v) and that are
+           reachable from Gamma(S) via a path in Nu(v). */
+        IGRAPH_CHECK(igraph_bfs(graph, /*root=*/ -1, /*roots=*/ &GammaS_vec,
+                                /*mode=*/ IGRAPH_OUT, /*unreachable=*/ 0,
+                                /*restricted=*/ &Nuv,
+                                /*order=*/ &Isv_min, /*rank=*/ 0,
+                                /*father=*/ 0, /*pred=*/ 0, /*succ=*/ 0,
+                                /*dist=*/ 0, /*callback=*/ 0, /*extra=*/ 0));
+        for (isvlen = 0; isvlen < no_of_nodes; isvlen++) {
+            if (!IGRAPH_FINITE(VECTOR(Isv_min)[isvlen])) {
+                break;
             }
         }
+        igraph_vector_resize(&Isv_min, isvlen);
 
-        /* ok, we have a component */
-        if (igraph_vector_size(&verts) < minelements) {
-            continue;
-        }
-
-        newg = IGRAPH_CALLOC(1, igraph_t);
-        if (newg == 0) {
-            IGRAPH_ERROR("Cannot decompose graph", IGRAPH_ENOMEM);
-        }
-        IGRAPH_CHECK(igraph_vector_ptr_push_back(components, newg));
-        IGRAPH_CHECK(igraph_i_induced_subgraph_map(
-            graph, newg, igraph_vss_vector(&verts),
-            IGRAPH_SUBGRAPH_AUTO, &vids_old2new,
-            /* invmap = */ 0, /* map_is_prepared = */ 1
-        ));
-
-        /* vids_old2new has to be cleaned up here because a vertex may appear
-         * in multiple strongly connected components. Simply calling
-         * igraph_vector_fill() would be an O(n) operation where n is the number
-         * of vertices in the large graph so we cannot do that; we have to
-         * iterate over 'verts' instead */
-        n = igraph_vector_size(&verts);
-        for (i = 0; i < n; i++) {
-            VECTOR(vids_old2new)[(igraph_integer_t) VECTOR(verts)[i]] = 0;
+        /* -------------------------------------------------------------*/
+        /* For each c in M check whether Isv-K is included in Tbar. If
+           such a v is found, compute Isv={x|v[Nu(v) U K]x} and return v and
+           Isv; otherwise return Isv={}. */
+        for (j = 0; j < isvlen; j++) {
+            long int u = (long int) VECTOR(Isv_min)[j];
+            if (igraph_estack_iselement(T, u) || u == target) {
+                break;
+            }
         }
+        /* We might have found one */
+        if (j == isvlen) {
+            *v = (long int) VECTOR(M)[i];
+            /* Calculate real Isv */
+            IGRAPH_CHECK(igraph_vector_append(&Nuv, &leftout));
+            IGRAPH_CHECK(igraph_bfs(graph, /*root=*/ (igraph_integer_t) *v,
+                                    /*roots=*/ 0, /*mode=*/ IGRAPH_OUT,
+                                    /*unreachable=*/ 0, /*restricted=*/ &Nuv,
+                                    /*order=*/ &Isv_min, /*rank=*/ 0,
+                                    /*father=*/ 0, /*pred=*/ 0, /*succ=*/ 0,
+                                    /*dist=*/ 0, /*callback=*/ 0, /*extra=*/ 0));
+            for (isvlen = 0; isvlen < no_of_nodes; isvlen++) {
+                if (!IGRAPH_FINITE(VECTOR(Isv_min)[isvlen])) {
+                    break;
+                }
+            }
+            igraph_vector_resize(&Isv_min, isvlen);
+            igraph_vector_update(Isv, &Isv_min);
 
-        no_of_clusters++;
+            break;
+        }
     }
 
-    IGRAPH_PROGRESS("Strongly connected components: ", 100.0, NULL);
-
-    /* Clean up, return */
+    igraph_vector_destroy(&GammaS_vec);
+    igraph_vector_destroy(&Isv_min);
+    igraph_vector_destroy(&Nuv);
+    IGRAPH_FINALLY_CLEAN(3);
 
-    igraph_vector_destroy(&vids_old2new);
-    igraph_vector_destroy(&verts);
-    igraph_adjlist_destroy(&adjlist);
-    igraph_vector_destroy(&out);
-    igraph_dqueue_destroy(&q);
-    igraph_vector_destroy(&next_nei);
-    IGRAPH_FINALLY_CLEAN(7);  /* + components */
+    igraph_vector_destroy(&M);
+    igraph_vector_bool_destroy(&GammaS);
+    igraph_destroy(&domtree);
+    igraph_vector_destroy(&leftout);
+    igraph_destroy(&Sbar);
+    igraph_vector_destroy(&Sbar_map);
+    igraph_vector_destroy(&Sbar_invmap);
+    IGRAPH_FINALLY_CLEAN(7);
 
     return 0;
-
 }
 
-/**
- * \function igraph_articulation_points
- * Find the articulation points in a graph.
- *
- * A vertex is an articulation point if its removal increases
- * the number of connected components in the graph.
- * \param graph The input graph.
- * \param res Pointer to an initialized vector, the
- *    articulation points will be stored here.
- * \return Error code.
- *
- * Time complexity: O(|V|+|E|), linear in the number of vertices and edges.
- *
- * \sa \ref igraph_biconnected_components(), \ref igraph_clusters(), \ref igraph_bridges()
- */
+/* TODO: This is a temporary recursive version, without proper error
+   handling */
 
-int igraph_articulation_points(const igraph_t *graph,
-                               igraph_vector_t *res) {
+int igraph_provan_shier_list(const igraph_t *graph,
+                             igraph_marked_queue_t *S,
+                             igraph_estack_t *T,
+                             long int source,
+                             long int target,
+                             igraph_vector_ptr_t *result,
+                             igraph_provan_shier_pivot_t *pivot,
+                             void *pivot_arg) {
 
-    igraph_integer_t no;
-    return igraph_biconnected_components(graph, &no, 0, 0, 0, res);
-}
+    long int no_of_nodes = igraph_vcount(graph);
+    igraph_vector_t Isv;
+    long int v = 0;
+    long int i, n;
+
+    igraph_vector_init(&Isv, 0);
+
+    pivot(graph, S, T, source, target, &v, &Isv, pivot_arg);
+    if (igraph_vector_size(&Isv) == 0) {
+        if (igraph_marked_queue_size(S) != 0 &&
+            igraph_marked_queue_size(S) != no_of_nodes) {
+            igraph_vector_t *vec = IGRAPH_CALLOC(1, igraph_vector_t);
+            igraph_vector_init(vec, igraph_marked_queue_size(S));
+            igraph_marked_queue_as_vector(S, vec);
+            IGRAPH_CHECK(igraph_vector_ptr_push_back(result, vec));
+        }
+    } else {
+        /* Put v into T */
+        igraph_estack_push(T, v);
+
+        /* Go down left in the search tree */
+        igraph_provan_shier_list(graph, S, T, source, target,
+                                 result, pivot, pivot_arg);
+
+        /* Take out v from T */
+        igraph_estack_pop(T);
+
+        /* Add Isv to S */
+        igraph_marked_queue_start_batch(S);
+        n = igraph_vector_size(&Isv);
+        for (i = 0; i < n; i++) {
+            if (!igraph_marked_queue_iselement(S, (long int) VECTOR(Isv)[i])) {
+                igraph_marked_queue_push(S, (long int) VECTOR(Isv)[i]);
+            }
+        }
 
-void igraph_i_free_vectorlist(igraph_vector_ptr_t *list);
+        /* Go down right in the search tree */
 
-void igraph_i_free_vectorlist(igraph_vector_ptr_t *list) {
-    long int i, n = igraph_vector_ptr_size(list);
-    for (i = 0; i < n; i++) {
-        igraph_vector_t *v = VECTOR(*list)[i];
-        if (v) {
-            igraph_vector_destroy(v);
-            IGRAPH_FREE(v);
-        }
+        igraph_provan_shier_list(graph, S, T, source, target,
+                                 result, pivot, pivot_arg);
+
+        /* Take out Isv from S */
+        igraph_marked_queue_pop_back_batch(S);
     }
-    igraph_vector_ptr_destroy(list);
+
+    igraph_vector_destroy(&Isv);
+
+    return 0;
 }
 
 /**
- * \function igraph_biconnected_components
- * Calculate biconnected components
+ * \function igraph_all_st_cuts
+ * List all edge-cuts between two vertices in a directed graph
  *
- * A graph is biconnected if the removal of any single vertex (and
- * its incident edges) does not disconnect it.
- *
- * </para><para>
- * A biconnected component of a graph is a maximal biconnected
- * subgraph of it. The biconnected components of a graph can be given
- * by the partition of its edges: every edge is a member of exactly
- * one biconnected component. Note that this is not true for
- * vertices: the same vertex can be part of many biconnected
- * components.
- *
- * </para><para>
- * Somewhat arbitrarily, igraph does not consider components containing
- * a single vertex only as being biconnected. Isolated vertices will
- * not be part of any of the biconnected components.
- *
- * \param graph The input graph.
- * \param no The number of biconnected components will be stored here.
- * \param tree_edges If not a NULL pointer, then the found components
- *     are stored here, in a list of vectors. Every vector in the list
- *     is a biconnected component, represented by its edges. More precisely,
- *     a spanning tree of the biconnected component is returned.
- *     Note you'll have to
- *     destroy each vector first by calling \ref igraph_vector_destroy()
- *     and then \ref igraph_free() on it, plus you need to call
- *     \ref igraph_vector_ptr_destroy() on the list to regain all
- *     allocated memory.
- * \param component_edges If not a NULL pointer, then the edges of the
- *     biconnected components are stored here, in the same form as for
- *     \c tree_edges.
- * \param components If not a NULL pointer, then the vertices of the
- *     biconnected components are stored here, in the same format as
- *     for the previous two arguments.
- * \param articulation_points If not a NULL pointer, then the
- *     articulation points of the graph are stored in this vector.
- *     A vertex is an articulation point if its removal increases the
- *     number of (weakly) connected components in the graph.
+ * This function lists all edge-cuts between a source and a target
+ * vertex. Every cut is listed exactly once. The implemented algorithm
+ * is described in JS Provan and DR Shier: A Paradigm for listing
+ * (s,t)-cuts in graphs, Algorithmica 15, 351--372, 1996.
+ *
+ * \param graph The input graph, is must be directed.
+ * \param cuts An initialized pointer vector, the cuts are stored
+ *        here. It is a list of pointers to igraph_vector_t
+ *        objects. Each vector will contain the ids of the edges in
+ *        the cut. This argument is ignored if it is a null pointer.
+ *        To free all memory allocated for \c cuts, you need call
+ *        \ref igraph_vector_destroy() and then \ref igraph_free() on
+ *        each element, before destroying the pointer vector itself.
+ * \param partition1s An initialized pointer vector, the list of
+ *        vertex sets, generating the actual edge cuts, are stored
+ *        here. Each vector contains a set of vertex ids. If X is such
+ *        a set, then all edges going from X to the complement of X
+ *        form an (s,t) edge-cut in the graph. This argument is
+ *        ignored if it is a null pointer.
+ *        To free all memory allocated for \c partition1s, you need call
+ *        \ref igraph_vector_destroy() and then \ref igraph_free() on
+ *        each element, before destroying the pointer vector itself.
+ * \param source The id of the source vertex.
+ * \param target The id of the target vertex.
  * \return Error code.
  *
- * Time complexity: O(|V|+|E|), linear in the number of vertices and
- * edges, but only if you do not calculate \c components and
- * \c component_edges. If you calculate \c components, then it is
- * quadratic in the number of vertices. If you calculate \c
- * component_edges as well, then it is cubic in the number of
- * vertices.
- *
- * \sa \ref igraph_articulation_points(), \ref igraph_clusters().
- *
- * \example examples/simple/igraph_biconnected_components.c
+ * Time complexity: O(n(|V|+|E|)), where |V| is the number of
+ * vertices, |E| is the number of edges, and n is the number of cuts.
  */
 
-int igraph_biconnected_components(const igraph_t *graph,
-                                  igraph_integer_t *no,
-                                  igraph_vector_ptr_t *tree_edges,
-                                  igraph_vector_ptr_t *component_edges,
-                                  igraph_vector_ptr_t *components,
-                                  igraph_vector_t *articulation_points) {
+int igraph_all_st_cuts(const igraph_t *graph,
+                       igraph_vector_ptr_t *cuts,
+                       igraph_vector_ptr_t *partition1s,
+                       igraph_integer_t source,
+                       igraph_integer_t target) {
+
+    /* S is a special stack, in which elements are pushed in batches.
+       It is then possible to remove the whole batch in one step.
+
+       T is a stack with an is-element operation.
+       Every element is included at most once.
+    */
 
     long int no_of_nodes = igraph_vcount(graph);
-    igraph_vector_long_t nextptr;
-    igraph_vector_long_t num, low;
-    igraph_vector_bool_t found;
-    igraph_vector_int_t *adjedges;
-    igraph_stack_t path;
-    igraph_vector_t edgestack;
-    igraph_inclist_t inclist;
-    long int i, counter, rootdfs = 0;
-    igraph_vector_long_t vertex_added;
-    long int comps = 0;
-    igraph_vector_ptr_t *mycomponents = components, vcomponents;
-
-    IGRAPH_CHECK(igraph_vector_long_init(&nextptr, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &nextptr);
-    IGRAPH_CHECK(igraph_vector_long_init(&num, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &num);
-    IGRAPH_CHECK(igraph_vector_long_init(&low, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &low);
-    IGRAPH_CHECK(igraph_vector_bool_init(&found, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_bool_destroy, &found);
-
-    IGRAPH_CHECK(igraph_stack_init(&path, 100));
-    IGRAPH_FINALLY(igraph_stack_destroy, &path);
-    IGRAPH_VECTOR_INIT_FINALLY(&edgestack, 0);
-    IGRAPH_CHECK(igraph_vector_reserve(&edgestack, 100));
-
-    IGRAPH_CHECK(igraph_inclist_init(graph, &inclist, IGRAPH_ALL, IGRAPH_LOOPS_TWICE));
-    IGRAPH_FINALLY(igraph_inclist_destroy, &inclist);
-
-    IGRAPH_CHECK(igraph_vector_long_init(&vertex_added, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &vertex_added);
-
-    if (no) {
-        *no = 0;
-    }
-    if (tree_edges) {
-        igraph_vector_ptr_clear(tree_edges);
-    }
-    if (components) {
-        igraph_vector_ptr_clear(components);
-    }
-    if (component_edges) {
-        igraph_vector_ptr_clear(component_edges);
-    }
-    if (articulation_points) {
-        igraph_vector_clear(articulation_points);
-    }
-    if (component_edges && !components) {
-        mycomponents = &vcomponents;
-        IGRAPH_CHECK(igraph_vector_ptr_init(mycomponents, 0));
-        IGRAPH_FINALLY(igraph_i_free_vectorlist, mycomponents);
-    }
-
-    for (i = 0; i < no_of_nodes; i++) {
-
-        if (VECTOR(low)[i] != 0) {
-            continue;    /* already visited */
-        }
-
-        IGRAPH_ALLOW_INTERRUPTION();
-
-        IGRAPH_CHECK(igraph_stack_push(&path, i));
-        counter = 1;
-        rootdfs = 0;
-        VECTOR(low)[i] = VECTOR(num)[i] = counter++;
-        while (!igraph_stack_empty(&path)) {
-            long int n;
-            long int act = (long int) igraph_stack_top(&path);
-            long int actnext = VECTOR(nextptr)[act];
-
-            adjedges = igraph_inclist_get(&inclist, act);
-            n = igraph_vector_int_size(adjedges);
-            if (actnext < n) {
-                /* Step down (maybe) */
-                long int edge = (long int) VECTOR(*adjedges)[actnext];
-                long int nei = IGRAPH_OTHER(graph, edge, act);
-                if (VECTOR(low)[nei] == 0) {
-                    if (act == i) {
-                        rootdfs++;
-                    }
-                    IGRAPH_CHECK(igraph_vector_push_back(&edgestack, edge));
-                    IGRAPH_CHECK(igraph_stack_push(&path, nei));
-                    VECTOR(low)[nei] = VECTOR(num)[nei] = counter++;
-                } else {
-                    /* Update low value if needed */
-                    if (VECTOR(num)[nei] < VECTOR(low)[act]) {
-                        VECTOR(low)[act] = VECTOR(num)[nei];
-                    }
+    long int no_of_edges = igraph_ecount(graph);
+    igraph_marked_queue_t S;
+    igraph_estack_t T;
+    igraph_vector_ptr_t *mypartition1s = partition1s, vpartition1s;
+    long int i, nocuts;
+
+    if (!igraph_is_directed(graph)) {
+        IGRAPH_ERROR("Listing all s-t cuts only implemented for "
+                     "directed graphs", IGRAPH_UNIMPLEMENTED);
+    }
+
+    if (!partition1s) {
+        mypartition1s = &vpartition1s;
+        IGRAPH_CHECK(igraph_vector_ptr_init(mypartition1s, 0));
+        IGRAPH_FINALLY(igraph_vector_ptr_destroy, mypartition1s);
+    } else {
+        igraph_vector_ptr_clear(mypartition1s);
+    }
+
+    IGRAPH_CHECK(igraph_marked_queue_init(&S, no_of_nodes));
+    IGRAPH_FINALLY(igraph_marked_queue_destroy, &S);
+    IGRAPH_CHECK(igraph_estack_init(&T, no_of_nodes, 0));
+    IGRAPH_FINALLY(igraph_estack_destroy, &T);
+
+    if (cuts)        {
+        igraph_vector_ptr_clear(cuts);
+    }
+
+    /* We call it with S={}, T={} */
+    IGRAPH_CHECK(igraph_provan_shier_list(graph, &S, &T,
+                                          source, target, mypartition1s,
+                                          igraph_i_all_st_cuts_pivot,
+                                          /*pivot_arg=*/ 0));
+
+    nocuts = igraph_vector_ptr_size(mypartition1s);
+
+    if (cuts) {
+        igraph_vector_long_t inS;
+        IGRAPH_CHECK(igraph_vector_long_init(&inS, no_of_nodes));
+        IGRAPH_FINALLY(igraph_vector_long_destroy, &inS);
+        IGRAPH_CHECK(igraph_vector_ptr_resize(cuts, nocuts));
+        for (i = 0; i < nocuts; i++) {
+            igraph_vector_t *cut;
+            igraph_vector_t *part = VECTOR(*mypartition1s)[i];
+            long int cutsize = 0;
+            long int j, partlen = igraph_vector_size(part);
+            /* Mark elements */
+            for (j = 0; j < partlen; j++) {
+                long int v = (long int) VECTOR(*part)[j];
+                VECTOR(inS)[v] = i + 1;
+            }
+            /* Check how many edges */
+            for (j = 0; j < no_of_edges; j++) {
+                long int from = IGRAPH_FROM(graph, j);
+                long int to = IGRAPH_TO(graph, j);
+                long int pfrom = VECTOR(inS)[from];
+                long int pto = VECTOR(inS)[to];
+                if (pfrom == i + 1 && pto != i + 1) {
+                    cutsize++;
                 }
-                VECTOR(nextptr)[act] += 1;
-            } else {
-                /* Step up */
-                igraph_stack_pop(&path);
-                if (!igraph_stack_empty(&path)) {
-                    long int prev = (long int) igraph_stack_top(&path);
-                    /* Update LOW value if needed */
-                    if (VECTOR(low)[act] < VECTOR(low)[prev]) {
-                        VECTOR(low)[prev] = VECTOR(low)[act];
-                    }
-                    /* Check for articulation point */
-                    if (VECTOR(low)[act] >= VECTOR(num)[prev]) {
-                        if (articulation_points && !VECTOR(found)[prev]
-                            && prev != i /* the root */) {
-                            IGRAPH_CHECK(igraph_vector_push_back(articulation_points, prev));
-                            VECTOR(found)[prev] = 1;
-                        }
-                        if (no) {
-                            *no += 1;
-                        }
-
-                        /*------------------------------------*/
-                        /* Record the biconnected component just found */
-                        if (tree_edges || mycomponents) {
-                            igraph_vector_t *v = 0, *v2 = 0;
-                            comps++;
-                            if (tree_edges) {
-                                v = IGRAPH_CALLOC(1, igraph_vector_t);
-                                if (!v) {
-                                    IGRAPH_ERROR("Out of memory", IGRAPH_ENOMEM);
-                                }
-                                IGRAPH_CHECK(igraph_vector_init(v, 0));
-                                IGRAPH_FINALLY(igraph_vector_destroy, v);
-                            }
-                            if (mycomponents) {
-                                v2 = IGRAPH_CALLOC(1, igraph_vector_t);
-                                if (!v2) {
-                                    IGRAPH_ERROR("Out of memory", IGRAPH_ENOMEM);
-                                }
-                                IGRAPH_CHECK(igraph_vector_init(v2, 0));
-                                IGRAPH_FINALLY(igraph_vector_destroy, v2);
-                            }
-
-                            while (!igraph_vector_empty(&edgestack)) {
-                                long int e = (long int) igraph_vector_pop_back(&edgestack);
-                                long int from = IGRAPH_FROM(graph, e);
-                                long int to = IGRAPH_TO(graph, e);
-                                if (tree_edges) {
-                                    IGRAPH_CHECK(igraph_vector_push_back(v, e));
-                                }
-                                if (mycomponents) {
-                                    if (VECTOR(vertex_added)[from] != comps) {
-                                        VECTOR(vertex_added)[from] = comps;
-                                        IGRAPH_CHECK(igraph_vector_push_back(v2, from));
-                                    }
-                                    if (VECTOR(vertex_added)[to] != comps) {
-                                        VECTOR(vertex_added)[to] = comps;
-                                        IGRAPH_CHECK(igraph_vector_push_back(v2, to));
-                                    }
-                                }
-                                if (from == prev || to == prev) {
-                                    break;
-                                }
-                            }
-
-                            if (mycomponents) {
-                                IGRAPH_CHECK(igraph_vector_ptr_push_back(mycomponents, v2));
-                                IGRAPH_FINALLY_CLEAN(1);
-                            }
-                            if (tree_edges) {
-                                IGRAPH_CHECK(igraph_vector_ptr_push_back(tree_edges, v));
-                                IGRAPH_FINALLY_CLEAN(1);
-                            }
-                            if (component_edges) {
-                                igraph_vector_t *nodes = VECTOR(*mycomponents)[comps - 1];
-                                igraph_vector_t *vv = IGRAPH_CALLOC(1, igraph_vector_t);
-                                long int ii, no_vert = igraph_vector_size(nodes);
-                                if (!vv) {
-                                    IGRAPH_ERROR("Out of memory", IGRAPH_ENOMEM);
-                                }
-                                IGRAPH_CHECK(igraph_vector_init(vv, 0));
-                                IGRAPH_FINALLY(igraph_vector_destroy, vv);
-                                for (ii = 0; ii < no_vert; ii++) {
-                                    long int vert = (long int) VECTOR(*nodes)[ii];
-                                    igraph_vector_int_t *edges = igraph_inclist_get(&inclist,
-                                                                 vert);
-                                    long int j, nn = igraph_vector_int_size(edges);
-                                    for (j = 0; j < nn; j++) {
-                                        long int e = (long int) VECTOR(*edges)[j];
-                                        long int nei = IGRAPH_OTHER(graph, e, vert);
-                                        if (VECTOR(vertex_added)[nei] == comps && nei < vert) {
-                                            IGRAPH_CHECK(igraph_vector_push_back(vv, e));
-                                        }
-                                    }
-                                }
-                                IGRAPH_CHECK(igraph_vector_ptr_push_back(component_edges, vv));
-                                IGRAPH_FINALLY_CLEAN(1);
-                            }
-                        } /* record component if requested */
-                        /*------------------------------------*/
-
-                    }
-                } /* !igraph_stack_empty(&path) */
             }
-
-        } /* !igraph_stack_empty(&path) */
-
-        if (articulation_points && rootdfs >= 2) {
-            IGRAPH_CHECK(igraph_vector_push_back(articulation_points, i));
+            /* Add the edges */
+            cut = IGRAPH_CALLOC(1, igraph_vector_t);
+            if (!cut) {
+                IGRAPH_ERROR("Cannot calculate s-t cuts", IGRAPH_ENOMEM);
+            }
+            IGRAPH_VECTOR_INIT_FINALLY(cut, cutsize);
+            cutsize = 0;
+            for (j = 0; j < no_of_edges; j++) {
+                long int from = IGRAPH_FROM(graph, j);
+                long int to = IGRAPH_TO(graph, j);
+                long int pfrom = VECTOR(inS)[from];
+                long int pto = VECTOR(inS)[to];
+                if ((pfrom == i + 1 && pto != i + 1)) {
+                    VECTOR(*cut)[cutsize++] = j;
+                }
+            }
+            VECTOR(*cuts)[i] = cut;
+            IGRAPH_FINALLY_CLEAN(1);
         }
 
-    } /* i < no_of_nodes */
-
-    if (mycomponents != components) {
-        igraph_i_free_vectorlist(mycomponents);
+        igraph_vector_long_destroy(&inS);
         IGRAPH_FINALLY_CLEAN(1);
     }
 
-    igraph_vector_long_destroy(&vertex_added);
-    igraph_inclist_destroy(&inclist);
-    igraph_vector_destroy(&edgestack);
-    igraph_stack_destroy(&path);
-    igraph_vector_bool_destroy(&found);
-    igraph_vector_long_destroy(&low);
-    igraph_vector_long_destroy(&num);
-    igraph_vector_long_destroy(&nextptr);
-    IGRAPH_FINALLY_CLEAN(8);
+    igraph_estack_destroy(&T);
+    igraph_marked_queue_destroy(&S);
+    IGRAPH_FINALLY_CLEAN(2);
+
+    if (!partition1s) {
+        for (i = 0; i < nocuts; i++) {
+            igraph_vector_t *cut = VECTOR(*mypartition1s)[i];
+            igraph_vector_destroy(cut);
+            igraph_free(cut);
+            VECTOR(*mypartition1s)[i] = 0;
+        }
+        igraph_vector_ptr_destroy(mypartition1s);
+        IGRAPH_FINALLY_CLEAN(1);
+    }
 
     return 0;
 }
 
+/* We need to find the minimal active elements of Sbar. I.e. all
+   active Sbar elements 'v', s.t. there is no other 'w' active Sbar
+   element from which 'v' is reachable. (Not necessarily through
+   active vertices.)
+
+   We calculate the in-degree of all vertices in Sbar first. Then we
+   look at the vertices with zero in-degree. If these are active,
+   then they are minimal. If they are are not active, then we remove
+   them from the graph, and check whether they resulted in more
+   zero-indegree vertices.
+*/
 
-/* igraph_bridges -- find all bridges in the graph */
-/* The algorithm is based on https://www.geeksforgeeks.org/bridge-in-a-graph/
-   but instead of keeping track of the parent of each vertex in the DFS tree
-   we keep track of its incoming edge. This is necessary to support multigraphs. */
-
-static int igraph_i_bridges_rec(
-        const igraph_t *graph, const igraph_inclist_t *il, igraph_integer_t u,
-        igraph_integer_t *time, igraph_vector_t *bridges, igraph_vector_bool_t *visited,
-        igraph_vector_int_t *disc, igraph_vector_int_t *low, igraph_vector_int_t *incoming_edge)
-{
-    igraph_vector_int_t *incedges;
-    long nc; /* neighbour count */
-    long i;
+static int igraph_i_all_st_mincuts_minimal(const igraph_t *Sbar,
+                                           const igraph_vector_bool_t *active,
+                                           const igraph_vector_t *invmap,
+                                           igraph_vector_t *minimal) {
+
+    long int no_of_nodes = igraph_vcount(Sbar);
+    igraph_vector_t indeg;
+    long int i, minsize;
+    igraph_vector_t neis;
 
-    VECTOR(*visited)[u] = 1;
+    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&indeg, no_of_nodes);
 
-    *time += 1;
+    IGRAPH_CHECK(igraph_degree(Sbar, &indeg, igraph_vss_all(),
+                               IGRAPH_IN, /*loops=*/ 1));
 
-    VECTOR(*disc)[u] = *time;
-    VECTOR(*low)[u] = *time;
+#define ACTIVE(x) (VECTOR(*active)[(long int)VECTOR(*invmap)[(x)]])
+#define ZEROIN(x) (VECTOR(indeg)[(x)]==0)
 
-    incedges = igraph_inclist_get(il, u);
-    nc = igraph_vector_int_size(incedges);
-    for (i = 0; i < nc; ++i) {
-        long edge = (long) VECTOR(*incedges)[i];
-        igraph_integer_t v = IGRAPH_TO(graph, edge) == u ? IGRAPH_FROM(graph, edge) : IGRAPH_TO(graph, edge);
+    for (i = 0; i < no_of_nodes; i++) {
+        if (!ACTIVE(i)) {
+            long int j, n;
+            IGRAPH_CHECK(igraph_neighbors(Sbar, &neis, (igraph_integer_t) i,
+                                          IGRAPH_OUT));
+            n = igraph_vector_size(&neis);
+            for (j = 0; j < n; j++) {
+                long int nei = (long int) VECTOR(neis)[j];
+                VECTOR(indeg)[nei] -= 1;
+            }
+        }
+    }
 
-        if (! VECTOR(*visited)[v]) {
-            VECTOR(*incoming_edge)[v] = edge;
-            IGRAPH_CHECK(igraph_i_bridges_rec(graph, il, v, time, bridges, visited, disc, low, incoming_edge));
+    for (minsize = 0, i = 0; i < no_of_nodes; i++) {
+        if (ACTIVE(i) && ZEROIN(i)) {
+            minsize++;
+        }
+    }
 
-            VECTOR(*low)[u] = VECTOR(*low)[u] < VECTOR(*low)[v] ? VECTOR(*low)[u] : VECTOR(*low)[v];
+    IGRAPH_CHECK(igraph_vector_resize(minimal, minsize));
 
-            if (VECTOR(*low)[v] > VECTOR(*disc)[u]) {
-                IGRAPH_CHECK(igraph_vector_push_back(bridges, edge));
-            }
-        } else if (edge != VECTOR(*incoming_edge)[u]) {
-            VECTOR(*low)[u] = VECTOR(*low)[u] < VECTOR(*disc)[v] ? VECTOR(*low)[u] : VECTOR(*disc)[v];
+    for (minsize = 0, i = 0; i < no_of_nodes; i++) {
+        if (ACTIVE(i) && ZEROIN(i)) {
+            VECTOR(*minimal)[minsize++] = i;
         }
     }
 
-    return IGRAPH_SUCCESS;
-}
-
-/**
- * \function igraph_bridges
- * Find all bridges in a graph.
- *
- * An edge is a bridge if its removal increases the number of (weakly)
- * connected components in the graph.
- *
- * \param graph The input graph.
- * \param res Pointer to an initialized vector, the
- *    bridges will be stored here as edge indices.
- * \return Error code.
- *
- * Time complexity: O(|V|+|E|), linear in the number of vertices and edges.
- *
- * \sa \ref igraph_articulation_points(), \ref igraph_biconnected_components(), \ref igraph_clusters()
- */
+#undef ACTIVE
+#undef ZEROIN
 
-int igraph_bridges(const igraph_t *graph, igraph_vector_t *bridges) {
-    igraph_inclist_t il;
-    igraph_vector_bool_t visited;
-    igraph_vector_int_t disc, low;
-    igraph_vector_int_t incoming_edge;
-    long n;
-    long i;
-    igraph_integer_t time;
+    igraph_vector_destroy(&indeg);
+    igraph_vector_destroy(&neis);
+    IGRAPH_FINALLY_CLEAN(2);
 
-    n = igraph_vcount(graph);
+    return 0;
+}
 
-    IGRAPH_CHECK(igraph_inclist_init(graph, &il, IGRAPH_ALL, IGRAPH_LOOPS_TWICE));
-    IGRAPH_FINALLY(igraph_inclist_destroy, &il);
+typedef struct igraph_i_all_st_mincuts_data_t {
+    const igraph_vector_bool_t *active;
+} igraph_i_all_st_mincuts_data_t;
+
+static int igraph_i_all_st_mincuts_pivot(const igraph_t *graph,
+                                         const igraph_marked_queue_t *S,
+                                         const igraph_estack_t *T,
+                                         long int source,
+                                         long int target,
+                                         long int *v,
+                                         igraph_vector_t *Isv,
+                                         void *arg) {
 
-    IGRAPH_CHECK(igraph_vector_bool_init(&visited, n));
-    IGRAPH_FINALLY(igraph_vector_bool_destroy, &visited);
+    igraph_i_all_st_mincuts_data_t *data = arg;
+    const igraph_vector_bool_t *active = data->active;
 
-    IGRAPH_CHECK(igraph_vector_int_init(&disc, n));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &disc);
+    long int no_of_nodes = igraph_vcount(graph);
+    long int i, j;
+    igraph_vector_t Sbar_map, Sbar_invmap;
+    igraph_vector_t keep;
+    igraph_t Sbar;
+    igraph_vector_t M;
+    long int nomin;
 
-    IGRAPH_CHECK(igraph_vector_int_init(&low, n));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &low);
+    IGRAPH_UNUSED(source); IGRAPH_UNUSED(target);
 
-    IGRAPH_CHECK(igraph_vector_int_init(&incoming_edge, n));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &incoming_edge);
-    for (i = 0; i < n; ++i) {
-        VECTOR(incoming_edge)[i] = -1;
+    if (igraph_marked_queue_size(S) == no_of_nodes) {
+        igraph_vector_clear(Isv);
+        return 0;
     }
 
-    igraph_vector_clear(bridges);
+    /* Create the graph induced by Sbar */
+    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_map, 0);
+    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_invmap, 0);
 
-    time = 0;
-    for (i = 0; i < n; ++i)
-        if (! VECTOR(visited)[i]) {
-            IGRAPH_CHECK(igraph_i_bridges_rec(graph, &il, i, &time, bridges, &visited, &disc, &low, &incoming_edge));
+    IGRAPH_VECTOR_INIT_FINALLY(&keep, 0);
+    for (i = 0; i < no_of_nodes; i++) {
+        if (!igraph_marked_queue_iselement(S, i)) {
+            IGRAPH_CHECK(igraph_vector_push_back(&keep, i));
+        }
+    }
+
+    /* TODO: it is not even necessary to create Sbar explicitly, we
+       just need to find the M elements efficiently. See the
+       Provan-Shier paper for details. */
+    IGRAPH_CHECK(igraph_induced_subgraph_map(graph, &Sbar,
+                 igraph_vss_vector(&keep),
+                 IGRAPH_SUBGRAPH_AUTO,
+                 /* map= */ &Sbar_map,
+                 /* invmap= */ &Sbar_invmap));
+    IGRAPH_FINALLY(igraph_destroy, &Sbar);
+
+    /* ------------------------------------------------------------- */
+    /* Identify the set M of minimal elements that are active */
+    IGRAPH_VECTOR_INIT_FINALLY(&M, 0);
+    IGRAPH_CHECK(igraph_i_all_st_mincuts_minimal(&Sbar, active,
+                 &Sbar_invmap, &M));
+
+    /* ------------------------------------------------------------- */
+    /* Now find a minimal element that is not in T */
+    igraph_vector_clear(Isv);
+    nomin = igraph_vector_size(&M);
+    for (i = 0; i < nomin; i++) {
+        long int min = (long int) VECTOR(Sbar_invmap)[ (long int) VECTOR(M)[i] ];
+        if (min != target)
+            if (!igraph_estack_iselement(T, min)) {
+                break;
+            }
+    }
+    if (i != nomin) {
+        /* OK, we found a pivot element. I(S,v) contains all elements
+           that can reach the pivot element */
+        igraph_vector_t Isv_min;
+        IGRAPH_VECTOR_INIT_FINALLY(&Isv_min, 0);
+        *v = (long int) VECTOR(Sbar_invmap)[ (long int) VECTOR(M)[i] ];
+        /* TODO: restricted == keep ? */
+        IGRAPH_CHECK(igraph_bfs(graph, /*root=*/ (igraph_integer_t) *v,/*roots=*/ 0,
+                                /*mode=*/ IGRAPH_IN, /*unreachable=*/ 0,
+                                /*restricted=*/ &keep, /*order=*/ &Isv_min,
+                                /*rank=*/ 0, /*father=*/ 0, /*pred=*/ 0,
+                                /*succ=*/ 0, /*dist=*/ 0, /*callback=*/ 0,
+                                /*extra=*/ 0));
+        for (j = 0; j < no_of_nodes; j++) {
+            igraph_real_t u = VECTOR(Isv_min)[j];
+            if (!IGRAPH_FINITE(u)) {
+                break;
+            }
+            if (!igraph_estack_iselement(T, u)) {
+                IGRAPH_CHECK(igraph_vector_push_back(Isv, u));
+            }
         }
+        igraph_vector_destroy(&Isv_min);
+        IGRAPH_FINALLY_CLEAN(1);
+    }
 
-    igraph_vector_int_destroy(&incoming_edge);
-    igraph_vector_int_destroy(&low);
-    igraph_vector_int_destroy(&disc);
-    igraph_vector_bool_destroy(&visited);
-    igraph_inclist_destroy(&il);
+    igraph_vector_destroy(&M);
+    igraph_destroy(&Sbar);
+    igraph_vector_destroy(&keep);
+    igraph_vector_destroy(&Sbar_invmap);
+    igraph_vector_destroy(&Sbar_map);
     IGRAPH_FINALLY_CLEAN(5);
 
-    return IGRAPH_SUCCESS;
+    return 0;
 }
 
 /**
- * \ingroup structural
- * \function igraph_subcomponent
- * \brief The vertices in the same component as a given vertex.
+ * \function igraph_all_st_mincuts
+ * All minimum s-t cuts of a directed graph
  *
- * \param graph The graph object.
- * \param res The result, vector with the ids of the vertices in the
- *        same component.
- * \param vertex The id of the vertex of which the component is
- *        searched.
- * \param mode Type of the component for directed graphs, possible
- *        values:
- *        \clist
- *        \cli IGRAPH_OUT
- *          the set of vertices reachable \em from the
- *          \p vertex,
- *        \cli IGRAPH_IN
- *          the set of vertices from which the
- *          \p vertex is reachable.
- *        \cli IGRAPH_ALL
- *          the graph is considered as an
- *          undirected graph. Note that this is \em not the same
- *          as the union of the previous two.
- *        \endclist
- * \return Error code:
- *        \clist
- *        \cli IGRAPH_ENOMEM
- *          not enough memory for temporary data.
- *        \cli IGRAPH_EINVVID
- *           \p vertex is an invalid vertex id
- *        \cli IGRAPH_EINVMODE
- *           invalid mode argument passed.
- *        \endclist
+ * This function lists all edge cuts between two vertices, in a directed graph,
+ * with minimum total capacity. Possibly, multiple cuts may have the same total
+ * capacity, although there is often only one minimum cut in weighted graphs.
+ * It is recommended to supply integer-values capacities. Otherwise, not all
+ * minimum cuts may be detected because of numerical roundoff errors.
+ * The implemented algorithm is described in JS Provan and DR
+ * Shier: A Paradigm for listing (s,t)-cuts in graphs, Algorithmica 15,
+ * 351--372, 1996.
+ *
+ * \param graph The input graph, it must be directed.
+ * \param value Pointer to a real number, the value of the minimum cut
+ *        is stored here, unless it is a null pointer.
+ * \param cuts An initialized pointer vector, the cuts are stored
+ *        here. It is a list of pointers to igraph_vector_t
+ *        objects. Each vector will contain the ids of the edges in
+ *        the cut. This argument is ignored if it is a null pointer.
+ *        To free all memory allocated for \c cuts, you need call
+ *        \ref igraph_vector_destroy() and then \ref igraph_free() on
+ *        each element, before destroying the pointer vector itself.
+ * \param partition1s An initialized pointer vector, the list of
+ *        vertex sets, generating the actual edge cuts, are stored
+ *        here. Each vector contains a set of vertex ids. If X is such
+ *        a set, then all edges going from X to the complement of X
+ *        form an (s,t) edge-cut in the graph. This argument is
+ *        ignored if it is a null pointer.
+ * \param source The id of the source vertex.
+ * \param target The id of the target vertex.
+ * \param capacity Vector of edge capacities. All capacities must be
+ *        strictly positive. If this is a null pointer, then all edges
+ *        are assumed to have capacity one.
+ * \return Error code.
  *
- * Time complexity: O(|V|+|E|),
- * |V| and
- * |E| are the number of vertices and
- * edges in the graph.
+ * Time complexity: O(n(|V|+|E|))+O(F), where |V| is the number of
+ * vertices, |E| is the number of edges, and n is the number of cuts;
+ * O(F) is the time complexity of the maximum flow algorithm, see \ref
+ * igraph_maxflow().
  *
- * \sa \ref igraph_induced_subgraph() if you want a graph object consisting only
- * a given set of vertices and the edges between them.
+ * \example examples/simple/igraph_all_st_mincuts.c
  */
-int igraph_subcomponent(const igraph_t *graph, igraph_vector_t *res, igraph_real_t vertex,
-                        igraph_neimode_t mode) {
 
-    long int no_of_nodes = igraph_vcount(graph);
-    igraph_dqueue_t q = IGRAPH_DQUEUE_NULL;
-    char *already_added;
-    long int i, vsize;
-    igraph_vector_t tmp = IGRAPH_VECTOR_NULL;
+int igraph_all_st_mincuts(const igraph_t *graph, igraph_real_t *value,
+                          igraph_vector_ptr_t *cuts,
+                          igraph_vector_ptr_t *partition1s,
+                          igraph_integer_t source,
+                          igraph_integer_t target,
+                          const igraph_vector_t *capacity) {
 
-    if (!IGRAPH_FINITE(vertex) || vertex < 0 || vertex >= no_of_nodes) {
-        IGRAPH_ERROR("Vertex id out of range.", IGRAPH_EINVVID);
+    long int no_of_nodes = igraph_vcount(graph);
+    long int no_of_edges = igraph_ecount(graph);
+    igraph_vector_t flow;
+    igraph_t residual;
+    igraph_vector_t NtoL;
+    long int newsource, newtarget;
+    igraph_marked_queue_t S;
+    igraph_estack_t T;
+    igraph_i_all_st_mincuts_data_t pivot_data;
+    igraph_vector_bool_t VE1bool;
+    igraph_vector_t VE1;
+    long int VE1size = 0;
+    long int i, nocuts;
+    igraph_integer_t proj_nodes;
+    igraph_vector_t revmap_ptr, revmap_next;
+    igraph_vector_ptr_t closedsets;
+    igraph_vector_ptr_t *mypartition1s = partition1s, vpartition1s;
+    igraph_maxflow_stats_t stats;
+
+    /* -------------------------------------------------------------------- */
+    /* Error checks */
+    if (!igraph_is_directed(graph)) {
+        IGRAPH_ERROR("S-t cuts can only be listed in directed graphs",
+                     IGRAPH_UNIMPLEMENTED);
+    }
+    if (source < 0 || source >= no_of_nodes) {
+        IGRAPH_ERROR("Invalid `source' vertex", IGRAPH_EINVAL);
+    }
+    if (target < 0 || target >= no_of_nodes) {
+        IGRAPH_ERROR("Invalid `target' vertex", IGRAPH_EINVAL);
+    }
+    if (source == target) {
+        IGRAPH_ERROR("`source' and 'target' are the same vertex", IGRAPH_EINVAL);
+    }
+    if (capacity != NULL && igraph_vector_min(capacity) <= 0)
+    {
+        IGRAPH_ERROR("Not all capacities are strictly positive.", IGRAPH_EINVAL);
+    }
+
+    if (!partition1s) {
+        mypartition1s = &vpartition1s;
+        IGRAPH_CHECK(igraph_vector_ptr_init(mypartition1s, 0));
+        IGRAPH_FINALLY(igraph_vector_ptr_destroy, mypartition1s);
+    }
+
+    /* -------------------------------------------------------------------- */
+    /* We need to calculate the maximum flow first */
+    IGRAPH_VECTOR_INIT_FINALLY(&flow, 0);
+    IGRAPH_CHECK(igraph_maxflow(graph, value, &flow, /*cut=*/ 0,
+                                /*partition1=*/ 0, /*partition2=*/ 0,
+                                /*source=*/ source, /*target=*/ target,
+                                capacity, &stats));
+
+    /* -------------------------------------------------------------------- */
+    /* Then we need the reverse residual graph */
+    IGRAPH_CHECK(igraph_reverse_residual_graph(graph, capacity, &residual,
+                 &flow));
+    IGRAPH_FINALLY(igraph_destroy, &residual);
+
+    /* -------------------------------------------------------------------- */
+    /* We shrink it to its strongly connected components */
+    IGRAPH_VECTOR_INIT_FINALLY(&NtoL, 0);
+    IGRAPH_CHECK(igraph_clusters(&residual, /*membership=*/ &NtoL,
+                                 /*csize=*/ 0, /*no=*/ &proj_nodes,
+                                 IGRAPH_STRONG));
+    IGRAPH_CHECK(igraph_contract_vertices(&residual, /*mapping=*/ &NtoL,
+                                          /*vertex_comb=*/ 0));
+    IGRAPH_CHECK(igraph_simplify(&residual, /*multiple=*/ 1, /*loops=*/ 1,
+                                 /*edge_comb=*/ 0));
+
+    newsource = (long int) VECTOR(NtoL)[(long int)source];
+    newtarget = (long int) VECTOR(NtoL)[(long int)target];
+
+    /* TODO: handle the newsource == newtarget case */
+
+    /* -------------------------------------------------------------------- */
+    /* Determine the active vertices in the projection */
+    IGRAPH_VECTOR_INIT_FINALLY(&VE1, 0);
+    IGRAPH_CHECK(igraph_vector_bool_init(&VE1bool, proj_nodes));
+    IGRAPH_FINALLY(igraph_vector_bool_destroy, &VE1bool);
+    for (i = 0; i < no_of_edges; i++) {
+        if (VECTOR(flow)[i] > 0) {
+            long int from = IGRAPH_FROM(graph, i);
+            long int to = IGRAPH_TO(graph, i);
+            long int pfrom = (long int) VECTOR(NtoL)[from];
+            long int pto = (long int) VECTOR(NtoL)[to];
+            if (!VECTOR(VE1bool)[pfrom]) {
+                VECTOR(VE1bool)[pfrom] = 1;
+                VE1size++;
+            }
+            if (!VECTOR(VE1bool)[pto]) {
+                VECTOR(VE1bool)[pto] = 1;
+                VE1size++;
+            }
+        }
     }
-    if (mode != IGRAPH_OUT && mode != IGRAPH_IN &&
-        mode != IGRAPH_ALL) {
-        IGRAPH_ERROR("Invalid mode argument.", IGRAPH_EINVMODE);
+    IGRAPH_CHECK(igraph_vector_reserve(&VE1, VE1size));
+    for (i = 0; i < proj_nodes; i++) {
+        if (VECTOR(VE1bool)[i]) {
+            igraph_vector_push_back(&VE1, i);
+        }
     }
 
-    already_added = IGRAPH_CALLOC(no_of_nodes, char);
-    if (already_added == 0) {
-        IGRAPH_ERROR("Subcomponent failed.", IGRAPH_ENOMEM);
+    if (cuts)        {
+        igraph_vector_ptr_clear(cuts);
+    }
+    if (partition1s) {
+        igraph_vector_ptr_clear(partition1s);
     }
-    IGRAPH_FINALLY(igraph_free, already_added);
 
-    igraph_vector_clear(res);
+    /* -------------------------------------------------------------------- */
+    /* Everything is ready, list the cuts, using the right PIVOT
+       function  */
+    IGRAPH_CHECK(igraph_marked_queue_init(&S, no_of_nodes));
+    IGRAPH_FINALLY(igraph_marked_queue_destroy, &S);
+    IGRAPH_CHECK(igraph_estack_init(&T, no_of_nodes, 0));
+    IGRAPH_FINALLY(igraph_estack_destroy, &T);
 
-    IGRAPH_VECTOR_INIT_FINALLY(&tmp, 0);
-    IGRAPH_DQUEUE_INIT_FINALLY(&q, 100);
+    pivot_data.active = &VE1bool;
 
-    IGRAPH_CHECK(igraph_dqueue_push(&q, vertex));
-    IGRAPH_CHECK(igraph_vector_push_back(res, vertex));
-    already_added[(long int)vertex] = 1;
+    IGRAPH_CHECK(igraph_vector_ptr_init(&closedsets, 0));
+    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &closedsets); /* TODO */
+    IGRAPH_CHECK(igraph_provan_shier_list(&residual, &S, &T,
+                                          newsource, newtarget, &closedsets,
+                                          igraph_i_all_st_mincuts_pivot,
+                                          &pivot_data));
 
-    while (!igraph_dqueue_empty(&q)) {
-        long int actnode = (long int) igraph_dqueue_pop(&q);
+    /* Convert the closed sets in the contracted graphs to cutsets in the
+       original graph */
+    IGRAPH_VECTOR_INIT_FINALLY(&revmap_ptr, igraph_vcount(&residual));
+    IGRAPH_VECTOR_INIT_FINALLY(&revmap_next, no_of_nodes);
+    for (i = 0; i < no_of_nodes; i++) {
+        long int id = (long int) VECTOR(NtoL)[i];
+        VECTOR(revmap_next)[i] = VECTOR(revmap_ptr)[id];
+        VECTOR(revmap_ptr)[id] = i + 1;
+    }
+
+    /* Create partitions in original graph */
+    nocuts = igraph_vector_ptr_size(&closedsets);
+    igraph_vector_ptr_clear(mypartition1s);
+    IGRAPH_CHECK(igraph_vector_ptr_reserve(mypartition1s, nocuts));
+    for (i = 0; i < nocuts; i++) {
+        igraph_vector_t *supercut = VECTOR(closedsets)[i];
+        long int j, supercutsize = igraph_vector_size(supercut);
+        igraph_vector_t *cut = IGRAPH_CALLOC(1, igraph_vector_t);
+        IGRAPH_VECTOR_INIT_FINALLY(cut, 0); /* TODO: better allocation */
+        for (j = 0; j < supercutsize; j++) {
+            long int vtx = (long int) VECTOR(*supercut)[j];
+            long int ovtx = (long int) VECTOR(revmap_ptr)[vtx];
+            while (ovtx != 0) {
+                ovtx--;
+                IGRAPH_CHECK(igraph_vector_push_back(cut, ovtx));
+                ovtx = (long int) VECTOR(revmap_next)[ovtx];
+            }
+        }
+        igraph_vector_ptr_push_back(mypartition1s, cut);
+        IGRAPH_FINALLY_CLEAN(1);
 
-        IGRAPH_ALLOW_INTERRUPTION();
+        igraph_vector_destroy(supercut);
+        igraph_free(supercut);
+        VECTOR(closedsets)[i] = 0;
+    }
 
-        IGRAPH_CHECK(igraph_neighbors(graph, &tmp, (igraph_integer_t) actnode,
-                                      mode));
-        vsize = igraph_vector_size(&tmp);
-        for (i = 0; i < vsize; i++) {
-            long int neighbor = (long int) VECTOR(tmp)[i];
+    igraph_vector_destroy(&revmap_next);
+    igraph_vector_destroy(&revmap_ptr);
+    igraph_vector_ptr_destroy(&closedsets);
+    IGRAPH_FINALLY_CLEAN(3);
 
-            if (already_added[neighbor]) {
-                continue;
+    /* Create cuts in original graph */
+    if (cuts) {
+        igraph_vector_long_t memb;
+        IGRAPH_CHECK(igraph_vector_long_init(&memb, no_of_nodes));
+        IGRAPH_FINALLY(igraph_vector_long_destroy, &memb);
+        IGRAPH_CHECK(igraph_vector_ptr_resize(cuts, nocuts));
+        for (i = 0; i < nocuts; i++) {
+            igraph_vector_t *part = VECTOR(*mypartition1s)[i];
+            long int j, n = igraph_vector_size(part);
+            igraph_vector_t *v;
+            v = IGRAPH_CALLOC(1, igraph_vector_t);
+            if (!v) {
+                IGRAPH_ERROR("Cannot list minimum s-t cuts", IGRAPH_ENOMEM);
+            }
+            IGRAPH_VECTOR_INIT_FINALLY(v, 0);
+            for (j = 0; j < n; j++) {
+                long int vtx = (long int) VECTOR(*part)[j];
+                VECTOR(memb)[vtx] = i + 1;
+            }
+            for (j = 0; j < no_of_edges; j++) {
+                if (VECTOR(flow)[j] > 0) {
+                    long int from = IGRAPH_FROM(graph, j);
+                    long int to = IGRAPH_TO(graph, j);
+                    if (VECTOR(memb)[from] == i + 1 && VECTOR(memb)[to] != i + 1) {
+                        IGRAPH_CHECK(igraph_vector_push_back(v, j)); /* TODO: allocation */
+                    }
+                }
             }
-            already_added[neighbor] = 1;
-            IGRAPH_CHECK(igraph_vector_push_back(res, neighbor));
-            IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
+            VECTOR(*cuts)[i] = v;
+            IGRAPH_FINALLY_CLEAN(1);
         }
+        igraph_vector_long_destroy(&memb);
+        IGRAPH_FINALLY_CLEAN(1);
     }
 
-    igraph_dqueue_destroy(&q);
-    igraph_vector_destroy(&tmp);
-    IGRAPH_FREE(already_added);
-    IGRAPH_FINALLY_CLEAN(3);
+    igraph_estack_destroy(&T);
+    igraph_marked_queue_destroy(&S);
+    igraph_vector_bool_destroy(&VE1bool);
+    igraph_vector_destroy(&VE1);
+    igraph_vector_destroy(&NtoL);
+    igraph_destroy(&residual);
+    igraph_vector_destroy(&flow);
+    IGRAPH_FINALLY_CLEAN(7);
+
+    if (!partition1s) {
+        for (i = 0; i < nocuts; i++) {
+            igraph_vector_t *cut = VECTOR(*mypartition1s)[i];
+            igraph_vector_destroy(cut);
+            igraph_free(cut);
+            VECTOR(*mypartition1s)[i] = 0;
+        }
+        igraph_vector_ptr_destroy(mypartition1s);
+        IGRAPH_FINALLY_CLEAN(1);
+    }
 
-    return IGRAPH_SUCCESS;
+    return 0;
 }
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/connectivity/separators.c` & `igraph-0.9.9/vendor/source/igraph/src/connectivity/separators.c`

 * *Files 0% similar despite different names*

```diff
@@ -786,16 +786,16 @@
             long int ii = (long int) VECTOR(X)[i];
             igraph_real_t phivalue;
             igraph_bool_t conn;
 
             if (ii == j) {
                 continue;    /* the same vertex */
             }
-            igraph_are_connected(&graph_copy, (igraph_integer_t) ii,
-                                 (igraph_integer_t) j, &conn);
+            IGRAPH_CHECK(igraph_are_connected(&graph_copy, (igraph_integer_t) ii,
+                                 (igraph_integer_t) j, &conn));
             if (conn) {
                 continue;    /* they are connected */
             }
 
             /* --------------------------------------------------------------- */
             /* 4 Compute a maximum flow phi in Gbar from x[i] to v[j].
             If |phi|=k, then */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/adjacency.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/adjacency.c`

 * *Files 2% similar despite different names*

```diff
@@ -22,26 +22,26 @@
 
 #include "igraph_constructors.h"
 
 #include "igraph_adjlist.h"
 #include "igraph_attributes.h"
 #include "igraph_interface.h"
 
-static int igraph_i_adjacency_directed(igraph_matrix_t *adjmatrix,
+static int igraph_i_adjacency_directed(const igraph_matrix_t *adjmatrix,
                                        igraph_vector_t *edges);
-static int igraph_i_adjacency_max(igraph_matrix_t *adjmatrix,
+static int igraph_i_adjacency_max(const igraph_matrix_t *adjmatrix,
                                   igraph_vector_t *edges);
-static int igraph_i_adjacency_upper(igraph_matrix_t *adjmatrix,
+static int igraph_i_adjacency_upper(const igraph_matrix_t *adjmatrix,
                                     igraph_vector_t *edges);
-static int igraph_i_adjacency_lower(igraph_matrix_t *adjmatrix,
+static int igraph_i_adjacency_lower(const igraph_matrix_t *adjmatrix,
                                     igraph_vector_t *edges);
-static int igraph_i_adjacency_min(igraph_matrix_t *adjmatrix,
+static int igraph_i_adjacency_min(const igraph_matrix_t *adjmatrix,
                                   igraph_vector_t *edges);
 
-static int igraph_i_adjacency_directed(igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
+static int igraph_i_adjacency_directed(const igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
 
     long int no_of_nodes = igraph_matrix_nrow(adjmatrix);
     long int i, j, k;
 
     for (i = 0; i < no_of_nodes; i++) {
         for (j = 0; j < no_of_nodes; j++) {
             long int M = (long int) MATRIX(*adjmatrix, i, j);
@@ -51,15 +51,15 @@
             }
         }
     }
 
     return 0;
 }
 
-static int igraph_i_adjacency_max(igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
+static int igraph_i_adjacency_max(const igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
 
     long int no_of_nodes = igraph_matrix_nrow(adjmatrix);
     long int i, j, k;
 
     for (i = 0; i < no_of_nodes; i++) {
         for (j = i; j < no_of_nodes; j++) {
             long int M1 = (long int) MATRIX(*adjmatrix, i, j);
@@ -73,15 +73,15 @@
             }
         }
     }
 
     return 0;
 }
 
-static int igraph_i_adjacency_upper(igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
+static int igraph_i_adjacency_upper(const igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
 
     long int no_of_nodes = igraph_matrix_nrow(adjmatrix);
     long int i, j, k;
 
     for (i = 0; i < no_of_nodes; i++) {
         for (j = i; j < no_of_nodes; j++) {
             long int M = (long int) MATRIX(*adjmatrix, i, j);
@@ -90,15 +90,15 @@
                 IGRAPH_CHECK(igraph_vector_push_back(edges, j));
             }
         }
     }
     return 0;
 }
 
-static int igraph_i_adjacency_lower(igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
+static int igraph_i_adjacency_lower(const igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
 
     long int no_of_nodes = igraph_matrix_nrow(adjmatrix);
     long int i, j, k;
 
     for (i = 0; i < no_of_nodes; i++) {
         for (j = 0; j <= i; j++) {
             long int M = (long int) MATRIX(*adjmatrix, i, j);
@@ -107,15 +107,15 @@
                 IGRAPH_CHECK(igraph_vector_push_back(edges, j));
             }
         }
     }
     return 0;
 }
 
-static int igraph_i_adjacency_min(igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
+static int igraph_i_adjacency_min(const igraph_matrix_t *adjmatrix, igraph_vector_t *edges) {
 
     long int no_of_nodes = igraph_matrix_nrow(adjmatrix);
     long int i, j, k;
 
     for (i = 0; i < no_of_nodes; i++) {
         for (j = i; j < no_of_nodes; j++) {
             long int M1 = (long int) MATRIX(*adjmatrix, i, j);
@@ -188,15 +188,15 @@
  *         \c IGRAPH_NONSQUARE: non-square matrix.
  *
  * Time complexity: O(|V||V|),
  * |V| is the number of vertices in the graph.
  *
  * \example examples/simple/igraph_adjacency.c
  */
-int igraph_adjacency(igraph_t *graph, igraph_matrix_t *adjmatrix,
+int igraph_adjacency(igraph_t *graph, const igraph_matrix_t *adjmatrix,
                      igraph_adjacency_t mode) {
 
     igraph_vector_t edges = IGRAPH_VECTOR_NULL;
     long int no_of_nodes;
 
     /* Some checks */
     if (igraph_matrix_nrow(adjmatrix) != igraph_matrix_ncol(adjmatrix)) {
@@ -498,15 +498,15 @@
  *         \c IGRAPH_NONSQUARE: non-square matrix.
  *
  * Time complexity: O(|V||V|),
  * |V| is the number of vertices in the graph.
  *
  * \example examples/simple/igraph_weighted_adjacency.c
  */
-int igraph_weighted_adjacency(igraph_t *graph, igraph_matrix_t *adjmatrix,
+int igraph_weighted_adjacency(igraph_t *graph, const igraph_matrix_t *adjmatrix,
                               igraph_adjacency_t mode, const char* attr,
                               igraph_bool_t loops) {
 
     igraph_vector_t edges = IGRAPH_VECTOR_NULL;
     igraph_vector_t weights = IGRAPH_VECTOR_NULL;
     const char* default_attr = "weight";
     igraph_vector_ptr_t attr_vec;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/atlas-edges.h` & `igraph-0.9.9/vendor/source/igraph/src/constructors/atlas-edges.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/atlas.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/atlas.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/basic_constructors.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/basic_constructors.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/de_bruijn.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/de_bruijn.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/famous.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/famous.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/full.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/full.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/kautz.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/kautz.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/lcf.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/lcf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/linegraph.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/linegraph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/prufer.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/prufer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/constructors/regular.c` & `igraph-0.9.9/vendor/source/igraph/src/constructors/regular.c`

 * *Files 4% similar despite different names*

```diff
@@ -275,60 +275,78 @@
 
     return 0;
 }
 
 /**
  * \ingroup generators
  * \function igraph_ring
- * \brief Creates a \em ring graph, a one dimensional lattice.
+ * \brief Creates a \em cycle graph or a \em path graph.
  *
- * An undirected (circular) ring on n vertices is commonly known in graph
- * theory as the cycle graph C_n.
+ * A circular ring on \c n vertices is commonly known in graph
+ * theory as the cycle graph, and often denoted by <code>C_n</code>.
+ * Removing a single edge from the cycle graph <code>C_n</code> results
+ * in the path graph <code>P_n</code>. This function can generate both.
+ *
+ * </para><para>
+ * This function is a convenience wrapper for the one-dimensional case of
+ * \ref igraph_lattice().
  *
  * \param graph Pointer to an uninitialized graph object.
- * \param n The number of vertices in the ring.
- * \param directed Logical, whether to create a directed ring.
- * \param mutual Logical, whether to create mutual edges in a directed
- *        ring. It is ignored for undirected graphs.
- * \param circular Logical, if false, the ring will be open (this is
- *        not a real \em ring actually).
+ * \param n The number of vertices in the graph.
+ * \param directed Logical, whether to create a directed graph.
+ *        All edges will be oriented in the same direction along
+ *        the cycle or path.
+ * \param mutual Logical, whether to create mutual edges in directed
+ *        graphs. It is ignored for undirected graphs.
+ * \param circular Logical, whether to create a closed ring (a cycle)
+ *        or an open path.
  * \return Error code:
  *         \c IGRAPH_EINVAL: invalid number of vertices.
  *
- * Time complexity: O(|V|), the
- * number of vertices in the graph.
+ * Time complexity: O(|V|), the number of vertices in the graph.
  *
  * \sa \ref igraph_lattice() for generating more general lattices.
  *
  * \example examples/simple/igraph_ring.c
  */
 int igraph_ring(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed,
                 igraph_bool_t mutual, igraph_bool_t circular) {
 
     igraph_vector_t v = IGRAPH_VECTOR_NULL;
 
     if (n < 0) {
-        IGRAPH_ERROR("negative number of vertices", IGRAPH_EINVAL);
+        IGRAPH_ERRORF("The number of vertices must be non-negative, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, n);
     }
 
     IGRAPH_VECTOR_INIT_FINALLY(&v, 1);
     VECTOR(v)[0] = n;
 
     IGRAPH_CHECK(igraph_lattice(graph, &v, 1, directed, mutual, circular));
-    igraph_vector_destroy(&v);
 
+    igraph_vector_destroy(&v);
     IGRAPH_FINALLY_CLEAN(1);
-    return 0;
+
+    return IGRAPH_SUCCESS;
 }
 
 /**
  * \ingroup generators
  * \function igraph_tree
  * \brief Creates a tree in which almost all vertices have the same number of children.
  *
+ * To obtain a completely symmetric tree with \c l layers, where each
+ * vertex has precisely \p children descendants, use
+ * <code>n = (children^(l+1) - 1) / (children - 1)</code>.
+ * Such trees are often called <code>k</code>-ary trees, where \c k refers
+ * to the number of children.
+ *
+ * </para><para>
+ * Note that for <code>n=0</code>, the null graph is returned,
+ * which is not considered to be a tree by \ref igraph_is_tree().
+ *
  * \param graph Pointer to an uninitialized graph object.
  * \param n Integer, the number of vertices in the graph.
  * \param children Integer, the number of children of a vertex in the
  *        tree.
  * \param type Constant, gives whether to create a directed tree, and
  *        if this is the case, also its orientation. Possible values:
  *        \clist
@@ -358,20 +376,23 @@
                 igraph_tree_mode_t type) {
 
     igraph_vector_t edges = IGRAPH_VECTOR_NULL;
     long int i, j;
     long int idx = 0;
     long int to = 1;
 
-    if (n < 0 || children <= 0) {
-        IGRAPH_ERROR("Invalid number of vertices or children", IGRAPH_EINVAL);
+    if (n < 0) {
+        IGRAPH_ERROR("Number of vertices cannot be negative.", IGRAPH_EINVAL);
+    }
+    if (children <= 0) {
+        IGRAPH_ERROR("Number of children must be positive.", IGRAPH_EINVAL);
     }
     if (type != IGRAPH_TREE_OUT && type != IGRAPH_TREE_IN &&
         type != IGRAPH_TREE_UNDIRECTED) {
-        IGRAPH_ERROR("Invalid mode argument", IGRAPH_EINVMODE);
+        IGRAPH_ERROR("Invalid tree orientation type.", IGRAPH_EINVMODE);
     }
 
     IGRAPH_VECTOR_INIT_FINALLY(&edges, 2 * (n - 1));
 
     i = 0;
     if (type == IGRAPH_TREE_OUT) {
         while (idx < 2 * (n - 1)) {
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/array.c` & `igraph-0.9.9/vendor/source/igraph/src/core/array.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/array.pmt` & `igraph-0.9.9/vendor/source/igraph/src/core/array.pmt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/buckets.c` & `igraph-0.9.9/vendor/source/igraph/src/core/buckets.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/buckets.h` & `igraph-0.9.9/vendor/source/igraph/src/core/buckets.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/cutheap.c` & `igraph-0.9.9/vendor/source/igraph/src/core/cutheap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/cutheap.h` & `igraph-0.9.9/vendor/source/igraph/src/core/cutheap.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/dqueue.c` & `igraph-0.9.9/vendor/source/igraph/src/core/dqueue.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/dqueue.pmt` & `igraph-0.9.9/vendor/source/igraph/src/core/dqueue.pmt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/error.c` & `igraph-0.9.9/vendor/source/igraph/src/core/error.c`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -208,17 +208,17 @@
 
     IGRAPH_FINALLY_FREE();
 }
 
 #ifndef USING_R
 void igraph_error_handler_printignore(const char *reason, const char *file,
                                       int line, int igraph_errno) {
-    IGRAPH_FINALLY_FREE();
     fprintf(stderr, "Error at %s:%i : %s - %s.\n",
             file, line, reason, igraph_strerror(igraph_errno));
+    IGRAPH_FINALLY_FREE();
 }
 #endif
 
 igraph_error_handler_t *igraph_set_error_handler(igraph_error_handler_t *new_handler) {
     igraph_error_handler_t *previous_handler = igraph_i_error_handler;
     igraph_i_error_handler = new_handler;
     return previous_handler;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/estack.c` & `igraph-0.9.9/vendor/source/igraph/src/core/estack.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/estack.h` & `igraph-0.9.9/vendor/source/igraph/src/core/estack.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/exceptions.h` & `igraph-0.9.9/vendor/source/igraph/src/core/exceptions.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/fixed_vectorlist.c` & `igraph-0.9.9/vendor/source/igraph/src/core/fixed_vectorlist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/fixed_vectorlist.h` & `igraph-0.9.9/vendor/source/igraph/src/core/fixed_vectorlist.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/grid.c` & `igraph-0.9.9/vendor/source/igraph/src/core/grid.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/grid.h` & `igraph-0.9.9/vendor/source/igraph/src/core/grid.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/hashtable.c` & `igraph-0.9.9/vendor/source/igraph/src/core/hashtable.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/hashtable.h` & `igraph-0.9.9/vendor/source/igraph/src/core/hashtable.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/heap.c` & `igraph-0.9.9/vendor/source/igraph/src/core/heap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/heap.pmt` & `igraph-0.9.9/vendor/source/igraph/src/core/heap.pmt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/indheap.c` & `igraph-0.9.9/vendor/source/igraph/src/core/indheap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/indheap.h` & `igraph-0.9.9/vendor/source/igraph/src/core/indheap.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/interruption.c` & `igraph-0.9.9/vendor/source/igraph/src/core/interruption.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/interruption.h` & `igraph-0.9.9/vendor/source/igraph/src/core/interruption.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/marked_queue.c` & `igraph-0.9.9/vendor/source/igraph/src/core/marked_queue.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/marked_queue.h` & `igraph-0.9.9/vendor/source/igraph/src/core/marked_queue.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/math.h` & `igraph-0.9.9/vendor/source/igraph/src/core/math.h`

 * *Files 3% similar despite different names*

```diff
@@ -76,13 +76,13 @@
     #define M_SQRT2 1.4142135623730950488016887
 #endif
 #ifndef M_LN_SQRT_2PI
     #define M_LN_SQRT_2PI   0.918938533204672741780329736406 /* log(sqrt(2*pi))
     == log(2*pi)/2 */
 #endif
 
-int igraph_almost_equals(double a, double b, double eps);
-int igraph_cmp_epsilon(double a, double b, double eps);
+IGRAPH_PRIVATE_EXPORT int igraph_almost_equals(double a, double b, double eps);
+IGRAPH_PRIVATE_EXPORT int igraph_cmp_epsilon(double a, double b, double eps);
 
 __END_DECLS
 
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/matrix.c` & `igraph-0.9.9/vendor/source/igraph/src/core/matrix.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/matrix.pmt` & `igraph-0.9.9/vendor/source/igraph/src/core/matrix.pmt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/memory.c` & `igraph-0.9.9/vendor/source/igraph/src/core/memory.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/printing.c` & `igraph-0.9.9/vendor/source/igraph/src/core/printing.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/progress.c` & `igraph-0.9.9/vendor/source/igraph/src/core/progress.c`

 * *Files 1% similar despite different names*

```diff
@@ -128,15 +128,15 @@
     fputs(message, stderr);
     fprintf(stderr, "%.1f percent ready.\n", percent);
     return IGRAPH_SUCCESS;
 }
 #endif
 
 /**
- * \function igraph_set_progress_handler.
+ * \function igraph_set_progress_handler
  * \brief Install a progress handler, or remove the current handler.
  *
  * There is a single simple predefined progress handler:
  * \ref igraph_progress_handler_stderr().
  * \param new_handler Pointer to a function of type
  *     \ref igraph_progress_handler_t, the progress handler function to
  *     install. To uninstall the current progress handler, this argument
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/psumtree.c` & `igraph-0.9.9/vendor/source/igraph/src/core/psumtree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/set.c` & `igraph-0.9.9/vendor/source/igraph/src/core/set.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/set.h` & `igraph-0.9.9/vendor/source/igraph/src/core/set.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/sparsemat.c` & `igraph-0.9.9/vendor/source/igraph/src/core/sparsemat.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/spmatrix.c` & `igraph-0.9.9/vendor/source/igraph/src/core/spmatrix.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/stack.c` & `igraph-0.9.9/vendor/source/igraph/src/core/stack.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/stack.pmt` & `igraph-0.9.9/vendor/source/igraph/src/core/stack.pmt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/statusbar.c` & `igraph-0.9.9/vendor/source/igraph/src/core/statusbar.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/strvector.c` & `igraph-0.9.9/vendor/source/igraph/src/core/strvector.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/trie.c` & `igraph-0.9.9/vendor/source/igraph/src/core/trie.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/trie.h` & `igraph-0.9.9/vendor/source/igraph/src/core/trie.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/vector.c` & `igraph-0.9.9/vendor/source/igraph/src/core/vector.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/vector.pmt` & `igraph-0.9.9/vendor/source/igraph/src/core/vector.pmt`

 * *Files 0% similar despite different names*

```diff
@@ -2258,15 +2258,15 @@
  *
  * Time complexity: O(n), the number of elements in \p from.
  */
 
 int FUNCTION(igraph_vector, update)(TYPE(igraph_vector) *to,
                                     const TYPE(igraph_vector) *from) {
     size_t n = (size_t) FUNCTION(igraph_vector, size)(from);
-    FUNCTION(igraph_vector, resize)(to, (long) n);
+    IGRAPH_CHECK(FUNCTION(igraph_vector, resize)(to, (long) n));
     memcpy(to->stor_begin, from->stor_begin, sizeof(BASE)*n);
     return 0;
 }
 
 /**
  * \function igraph_vector_swap
  * \brief Swap elements of two vectors.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/core/vector_ptr.c` & `igraph-0.9.9/vendor/source/igraph/src/core/vector_ptr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/f2c.h` & `igraph-0.9.9/vendor/source/igraph/src/f2c.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/flow/flow.c` & `igraph-0.9.9/vendor/source/igraph/src/flow/flow.c`

 * *Files 0% similar despite different names*

```diff
@@ -2283,15 +2283,15 @@
     igraph_bool_t conn;
 
     if (source == target) {
         IGRAPH_ERROR("The source==target case is not implemented",
                      IGRAPH_UNIMPLEMENTED);
     }
 
-    igraph_are_connected(graph, source, target, &conn);
+    IGRAPH_CHECK(igraph_are_connected(graph, source, target, &conn));
     if (conn) {
         /* We need to remove every (possibly directed) edge between source
            and target and calculate the disjoint paths on the new
            graph. Finally we add 1 for the removed connection(s).  */
         igraph_es_t es;
         igraph_vector_t v;
         igraph_t newgraph;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/flow/flow_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/flow/flow_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/flow/st-cuts.c` & `igraph-0.9.9/vendor/source/igraph/src/graph/iterators.c`

 * *Files 22% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 /* -*- mode: C -*-  */
 /*
    IGraph library.
-   Copyright (C) 2010-2012  Gabor Csardi <csardi.gabor@gmail.com>
+   Copyright (C) 2005-2012  Gabor Csardi <csardi.gabor@gmail.com>
    334 Harvard street, Cambridge, MA 02139 USA
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
@@ -17,1576 +17,1916 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
-#include "igraph_flow.h"
-
-#include "igraph_adjlist.h"
-#include "igraph_constants.h"
-#include "igraph_constructors.h"
-#include "igraph_components.h"
-#include "igraph_error.h"
-#include "igraph_interface.h"
+#include "igraph_iterators.h"
 #include "igraph_memory.h"
-#include "igraph_operators.h"
-#include "igraph_stack.h"
-#include "igraph_visitor.h"
-
-#include "core/math.h"
-#include "core/estack.h"
-#include "core/marked_queue.h"
-#include "graph/attributes.h"
-#include "flow/flow_internal.h"
-
-typedef int igraph_provan_shier_pivot_t(const igraph_t *graph,
-                                        const igraph_marked_queue_t *S,
-                                        const igraph_estack_t *T,
-                                        long int source,
-                                        long int target,
-                                        long int *v,
-                                        igraph_vector_t *Isv,
-                                        void *arg);
-
-/**
- * \function igraph_even_tarjan_reduction
- * Even-Tarjan reduction of a graph
- *
- * A digraph is created with twice as many vertices and edges. For each
- * original vertex i, two vertices i'= i and i'' = i' + n are created,
- * with a directed edge from i' to i''. For each original directed edge
- * from i to j, two new edges are created, from i' to j'' and from i''
- * to j'.
- *
- * </para><para>This reduction is used in the paper (observation 2):
- * Arkady Kanevsky: Finding all minimum-size separating vertex sets in
- * a graph, Networks 23, 533--541, 1993.
- *
- * </para><para>The original paper where this reduction was conceived is
- * Shimon Even and R. Endre Tarjan: Network Flow and Testing Graph
- * Connectivity, SIAM J. Comput., 4(4), 507–518.
- *
- * \param graph A graph. Although directness is not checked, this function
- *        is commonly used only on directed graphs.
- * \param graphbar Pointer to a new directed graph that will contain the
- *        reduction, with twice as many vertices and edges.
- * \param capacity Pointer to an initialized vector or a null pointer. If
- *        not a null pointer, then it will be filled the capacity from
- *        the reduction: the first |E| elements are 1, the remaining |E|
- *        are equal to |V| (which is used to mean infinity).
+#include "igraph_interface.h"
+
+#include <string.h>
+#include <stdarg.h>
+
+/**
+ * \section about_iterators About selectors, iterators
+ *
+ * <para>Everything about vertices and vertex selectors also applies
+ * to edges and edge selectors unless explicitly noted otherwise.</para>
+ *
+ * <para>The vertex (and edge) selector notion was introduced in igraph 0.2.
+ * It is a way to reference a sequence of vertices or edges
+ * independently of the graph.</para>
+ *
+ * <para>While this might sound quite mysterious, it is actually very
+ * simple. For example, all vertices of a graph can be selected by
+ * \ref igraph_vs_all() and the graph independence means that
+ * \ref igraph_vs_all() is not parametrized by a graph object. That is,
+ * \ref igraph_vs_all() is the general \em concept of selecting all vertices
+ * of a graph. A vertex selector is then a way to specify the class of vertices
+ * to be visited. The selector might specify that all vertices of a graph or
+ * all the neighbours of a vertex are to be visited. A vertex selector is a
+ * way of saying that you want to visit a bunch of vertices, as opposed to a
+ * vertex iterator which is a concrete plan for visiting each of the
+ * chosen vertices of a specific graph.</para>
+ *
+ * <para>To determine the actual vertex IDs implied by a vertex selector, you
+ * need to apply the concept of selecting vertices to a specific graph object.
+ * This can be accomplished by instantiating a vertex iterator using a
+ * specific vertex selection concept and a specific graph object. The notion
+ * of vertex iterators can be thought of in the following way. Given a
+ * specific graph object and the class of vertices to be visited, a vertex
+ * iterator is a road map, plan or route for how to visit the chosen
+ * vertices.</para>
+ *
+ * <para>Some vertex selectors have \em immediate versions. These have the
+ * prefix \c igraph_vss instead of \c igraph_vs, e.g. \ref igraph_vss_all()
+ * instead of \ref igraph_vs_all(). The immediate versions are to be used in
+ * the parameter list of the igraph functions, such as \ref igraph_degree().
+ * These functions are not associated with any \type igraph_vs_t object, so
+ * they have no separate constructors and destructors
+ * (destroy functions).</para>
+ */
+
+/**
+ * \section about_vertex_selectors
+ *
+ * <para>Vertex selectors are created by vertex selector constructors,
+ * can be instantiated with \ref igraph_vit_create(), and are
+ * destroyed with \ref igraph_vs_destroy().</para>
+ */
+
+/**
+ * \function igraph_vs_all
+ * \brief Vertex set, all vertices of a graph.
+ *
+ * \param vs Pointer to an uninitialized \type igraph_vs_t object.
  * \return Error code.
+ * \sa \ref igraph_vss_all(), \ref igraph_vs_destroy()
  *
- * Time complexity: O(|E|+|V|).
+ * This selector includes all vertices of a given graph in
+ * increasing vertex id order.
  *
- * \example examples/simple/even_tarjan.c
+ * </para><para>
+ * Time complexity: O(1).
  */
 
-int igraph_even_tarjan_reduction(const igraph_t *graph, igraph_t *graphbar,
-                                 igraph_vector_t *capacity) {
+int igraph_vs_all(igraph_vs_t *vs) {
+    vs->type = IGRAPH_VS_ALL;
+    return 0;
+}
 
-    long int no_of_nodes = igraph_vcount(graph);
-    long int no_of_edges = igraph_ecount(graph);
+/**
+ * \function igraph_vss_all
+ * \brief All vertices of a graph (immediate version).
+ *
+ * Immediate vertex selector for all vertices in a graph. It can
+ * be used conveniently when some vertex property (e.g. betweenness,
+ * degree, etc.) should be calculated for all vertices.
+ *
+ * \return A vertex selector for all vertices in a graph.
+ * \sa \ref igraph_vs_all()
+ *
+ * Time complexity: O(1).
+ */
 
-    long int new_no_of_nodes = no_of_nodes * 2;
-    long int new_no_of_edges = no_of_nodes + no_of_edges * 2;
+igraph_vs_t igraph_vss_all(void) {
+    igraph_vs_t allvs;
+    allvs.type = IGRAPH_VS_ALL;
+    return allvs;
+}
 
-    igraph_vector_t edges;
-    long int edgeptr = 0, capptr = 0;
-    long int i;
+/**
+ * \function igraph_vs_adj
+ * \brief Adjacent vertices of a vertex.
+ *
+ * All neighboring vertices of a given vertex are selected by this
+ * selector. The \c mode argument controls the type of the neighboring
+ * vertices to be selected. The vertices are visited in increasing vertex
+ * ID order, as of igraph version 0.4.
+ *
+ * \param vs Pointer to an uninitialized vertex selector object.
+ * \param vid Vertex ID, the center of the neighborhood.
+ * \param mode Decides the type of the neighborhood for directed
+ *        graphs. This parameter is ignored for undirected graphs.
+ *        Possible values:
+ *        \clist
+ *        \cli IGRAPH_OUT
+ *          All vertices to which there is a directed edge from \c vid. That
+ *          is, all the out-neighbors of \c vid.
+ *        \cli IGRAPH_IN
+ *          All vertices from which there is a directed edge to \c vid. In
+ *          other words, all the in-neighbors of \c vid.
+ *        \cli IGRAPH_ALL
+ *          All vertices to which or from which there is a directed edge
+ *          from/to \c vid. That is, all the neighbors of \c vid considered
+ *          as if the graph is undirected.
+ *        \endclist
+ * \return Error code.
+ * \sa \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(1).
+ */
 
-    IGRAPH_VECTOR_INIT_FINALLY(&edges, new_no_of_edges * 2);
+int igraph_vs_adj(igraph_vs_t *vs,
+                  igraph_integer_t vid, igraph_neimode_t mode) {
+    vs->type = IGRAPH_VS_ADJ;
+    vs->data.adj.vid = vid;
+    vs->data.adj.mode = mode;
+    return 0;
+}
 
-    if (capacity) {
-        IGRAPH_CHECK(igraph_vector_resize(capacity, new_no_of_edges));
-    }
+/**
+ * \function igraph_vs_nonadj
+ * \brief Non-adjacent vertices of a vertex.
+ *
+ * All non-neighboring vertices of a given vertex. The \p mode
+ * argument controls the type of neighboring vertices \em not to
+ * select. Instead of selecting immediate neighbors of \c vid as is done by
+ * \ref igraph_vs_adj(), the current function selects vertices that are \em not
+ * immediate neighbors of \c vid.
+ *
+ * \param vs Pointer to an uninitialized vertex selector object.
+ * \param vid Vertex ID, the \quote center \endquote of the
+ *        non-neighborhood.
+ * \param mode The type of neighborhood not to select in directed
+ *        graphs. Possible values:
+ *        \clist
+ *        \cli IGRAPH_OUT
+ *          All vertices will be selected except those to which there is a
+ *          directed edge from \c vid. That is, we select all vertices
+ *          excluding the out-neighbors of \c vid.
+ *        \cli IGRAPH_IN
+ *          All vertices will be selected except those from which there is a
+ *          directed edge to \c vid. In other words, we select all vertices
+ *          but the in-neighbors of \c vid.
+ *        \cli IGRAPH_ALL
+ *          All vertices will be selected except those from or to which there
+ *          is a directed edge to or from \c vid. That is, we select all
+ *          vertices of \c vid except for its immediate neighbors.
+ *        \endclist
+ * \return Error code.
+ * \sa \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(1).
+ *
+ * \example examples/simple/igraph_vs_nonadj.c
+ */
 
-    /* Every vertex 'i' is replaced by two vertices, i' and i'' */
-    /* id[i'] := id[i] ; id[i''] := id[i] + no_of_nodes */
+int igraph_vs_nonadj(igraph_vs_t *vs, igraph_integer_t vid,
+                     igraph_neimode_t mode) {
+    vs->type = IGRAPH_VS_NONADJ;
+    vs->data.adj.vid = vid;
+    vs->data.adj.mode = mode;
+    return 0;
+}
 
-    /* One edge for each original vertex, for i, we add (i',i'') */
-    for (i = 0; i < no_of_nodes; i++) {
-        VECTOR(edges)[edgeptr++] = i;
-        VECTOR(edges)[edgeptr++] = i + no_of_nodes;
-        if (capacity) {
-            VECTOR(*capacity)[capptr++] = 1.0;
-        }
-    }
+/**
+ * \function igraph_vs_none
+ * \brief Empty vertex set.
+ *
+ * Creates an empty vertex selector.
+ *
+ * \param vs Pointer to an uninitialized vertex selector object.
+ * \return Error code.
+ * \sa \ref igraph_vss_none(), \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(1).
+ */
 
-    /* Two news edges for each original edge
-       (from,to) becomes (from'',to'), (to'',from') */
-    for (i = 0; i < no_of_edges; i++) {
-        long int from = IGRAPH_FROM(graph, i);
-        long int to = IGRAPH_TO(graph, i);
-        VECTOR(edges)[edgeptr++] = from + no_of_nodes;
-        VECTOR(edges)[edgeptr++] = to;
-        VECTOR(edges)[edgeptr++] = to + no_of_nodes;
-        VECTOR(edges)[edgeptr++] = from;
-        if (capacity) {
-            VECTOR(*capacity)[capptr++] = no_of_nodes; /* TODO: should be Inf */
-            VECTOR(*capacity)[capptr++] = no_of_nodes; /* TODO: should be Inf */
-        }
-    }
+int igraph_vs_none(igraph_vs_t *vs) {
+    vs->type = IGRAPH_VS_NONE;
+    return 0;
+}
 
-    IGRAPH_CHECK(igraph_create(graphbar, &edges, (igraph_integer_t)
-                               new_no_of_nodes, IGRAPH_DIRECTED));
+/**
+ * \function igraph_vss_none
+ * \brief Empty vertex set (immediate version).
+ *
+ * The immediate version of the empty vertex selector.
+ *
+ * \return An empty vertex selector.
+ * \sa \ref igraph_vs_none()
+ *
+ * Time complexity: O(1).
+ */
 
-    igraph_vector_destroy(&edges);
-    IGRAPH_FINALLY_CLEAN(1);
+igraph_vs_t igraph_vss_none(void) {
+    igraph_vs_t nonevs;
+    nonevs.type = IGRAPH_VS_NONE;
+    return nonevs;
+}
+
+/**
+ * \function igraph_vs_1
+ * \brief Vertex set with a single vertex.
+ *
+ * This vertex selector selects a single vertex.
+ *
+ * \param vs Pointer to an uninitialized vertex selector object.
+ * \param vid The vertex id to be selected.
+ * \return Error Code.
+ * \sa \ref igraph_vss_1(), \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(1).
+ */
 
+int igraph_vs_1(igraph_vs_t *vs, igraph_integer_t vid) {
+    vs->type = IGRAPH_VS_1;
+    vs->data.vid = vid;
     return 0;
 }
 
-static int igraph_i_residual_graph(const igraph_t *graph,
-                                   const igraph_vector_t *capacity,
-                                   igraph_t *residual,
-                                   igraph_vector_t *residual_capacity,
-                                   const igraph_vector_t *flow,
-                                   igraph_vector_t *tmp) {
+/**
+ * \function igraph_vss_1
+ * \brief Vertex set with a single vertex (immediate version).
+ *
+ * The immediate version of the single-vertex selector.
+ *
+ * \param vid The vertex to be selected.
+ * \return A vertex selector containing a single vertex.
+ * \sa \ref igraph_vs_1()
+ *
+ * Time complexity: O(1).
+ */
 
-    long int no_of_nodes = igraph_vcount(graph);
-    long int no_of_edges = igraph_ecount(graph);
-    long int i, no_new_edges = 0;
-    long int edgeptr = 0, capptr = 0;
+igraph_vs_t igraph_vss_1(igraph_integer_t vid) {
+    igraph_vs_t onevs;
+    onevs.type = IGRAPH_VS_1;
+    onevs.data.vid = vid;
+    return onevs;
+}
+
+/**
+ * \function igraph_vs_vector
+ * \brief Vertex set based on a vector.
+ *
+ * This function makes it possible to handle a \type vector_t
+ * temporarily as a vertex selector. The vertex selector should be
+ * thought of like a \em view to the vector. If you make changes to
+ * the vector that also affects the vertex selector. Destroying the
+ * vertex selector does not destroy the vector. (Of course.) Do not
+ * destroy the vector before destroying the vertex selector, or you
+ * might get strange behavior.
+ *
+ * \param vs Pointer to an uninitialized vertex selector.
+ * \param v Pointer to a \type igraph_vector_t object.
+ * \return Error code.
+ * \sa \ref igraph_vss_vector(), \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(1).
+ *
+ * \example examples/simple/igraph_vs_vector.c
+ */
+
+int igraph_vs_vector(igraph_vs_t *vs,
+                     const igraph_vector_t *v) {
+    vs->type = IGRAPH_VS_VECTORPTR;
+    vs->data.vecptr = v;
+    return 0;
+}
+
+/**
+ * \function igraph_vss_vector
+ * \brief Vertex set based on a vector (immediate version).
+ *
+ * This is the immediate version of \ref igraph_vs_vector.
+ *
+ * \param v Pointer to a \type igraph_vector_t object.
+ * \return A vertex selector object containing the vertices in the
+ *         vector.
+ * \sa \ref igraph_vs_vector()
+ *
+ * Time complexity: O(1).
+ */
+
+igraph_vs_t igraph_vss_vector(const igraph_vector_t *v) {
+    igraph_vs_t vecvs;
+    vecvs.type = IGRAPH_VS_VECTORPTR;
+    vecvs.data.vecptr = v;
+    return vecvs;
+}
+
+/**
+ * \function igraph_vs_vector_small
+ * \brief Create a vertex set by giving its elements.
+ *
+ * This function can be used to create a vertex selector with a couple
+ * of vertices. Do not forget to include a <code>-1</code> after the
+ * last vertex id. The behavior of the function is undefined if you
+ * don't use a <code>-1</code> properly.
+ *
+ * </para><para>
+ * Note that the vertex ids supplied will be parsed as
+ * <code>int</code>'s so you cannot supply arbitrarily large (too
+ * large for int) vertex ids here.
+ *
+ * \param vs Pointer to an uninitialized vertex selector object.
+ * \param ... Additional parameters, these will be the vertex ids to
+ *        be included in the vertex selector. Supply a <code>-1</code>
+ *        after the last vertex id.
+ * \return Error code.
+ * \sa \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(n), the number of vertex ids supplied.
+ */
 
-    for (i = 0; i < no_of_edges; i++) {
-        if (VECTOR(*flow)[i] < VECTOR(*capacity)[i]) {
-            no_new_edges++;
+int igraph_vs_vector_small(igraph_vs_t *vs, ...) {
+    va_list ap;
+    long int i, n = 0;
+    vs->type = IGRAPH_VS_VECTOR;
+    vs->data.vecptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (vs->data.vecptr == 0) {
+        IGRAPH_ERROR("Cannot create vertex selector", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)vs->data.vecptr);
+
+    va_start(ap, vs);
+    while (1) {
+        int num = va_arg(ap, int);
+        if (num == -1) {
+            break;
         }
+        n++;
     }
+    va_end(ap);
+
+    IGRAPH_VECTOR_INIT_FINALLY((igraph_vector_t*)vs->data.vecptr, n);
 
-    IGRAPH_CHECK(igraph_vector_resize(tmp, no_new_edges * 2));
-    if (residual_capacity) {
-        IGRAPH_CHECK(igraph_vector_resize(residual_capacity, no_new_edges));
+    va_start(ap, vs);
+    for (i = 0; i < n; i++) {
+        VECTOR(*vs->data.vecptr)[i] = (igraph_real_t) va_arg(ap, int);
     }
+    va_end(ap);
 
-    for (i = 0; i < no_of_edges; i++) {
-        igraph_real_t c = VECTOR(*capacity)[i] - VECTOR(*flow)[i];
-        if (c > 0) {
-            long int from = IGRAPH_FROM(graph, i);
-            long int to = IGRAPH_TO(graph, i);
-            VECTOR(*tmp)[edgeptr++] = from;
-            VECTOR(*tmp)[edgeptr++] = to;
-            if (residual_capacity) {
-                VECTOR(*residual_capacity)[capptr++] = c;
-            }
-        }
+    IGRAPH_FINALLY_CLEAN(2);
+    return 0;
+}
+
+/**
+ * \function igraph_vs_vector_copy
+ * \brief Vertex set based on a vector, with copying.
+ *
+ * This function makes it possible to handle a \type vector_t
+ * permanently as a vertex selector. The vertex selector creates a
+ * copy of the original vector, so the vector can safely be destroyed
+ * after creating the vertex selector. Changing the original vector
+ * will not affect the vertex selector. The vertex selector is
+ * responsible for deleting the copy made by itself.
+ *
+ * \param vs Pointer to an uninitialized vertex selector.
+ * \param v Pointer to a \type igraph_vector_t object.
+ * \return Error code.
+ * \sa \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(1).
+ */
+
+int igraph_vs_vector_copy(igraph_vs_t *vs,
+                          const igraph_vector_t *v) {
+    vs->type = IGRAPH_VS_VECTOR;
+    vs->data.vecptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (vs->data.vecptr == 0) {
+        IGRAPH_ERROR("Cannot create vertex selector", IGRAPH_ENOMEM);
     }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)vs->data.vecptr);
+    IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*)vs->data.vecptr, v));
+    IGRAPH_FINALLY_CLEAN(1);
+    return 0;
+}
 
-    IGRAPH_CHECK(igraph_create(residual, tmp, (igraph_integer_t) no_of_nodes,
-                               IGRAPH_DIRECTED));
+/**
+ * \function igraph_vs_seq
+ * \brief Vertex set, an interval of vertices.
+ *
+ * Creates a vertex selector containing all vertices with vertex id
+ * equal to or bigger than \c from and equal to or smaller than \c
+ * to.
+ *
+ * \param vs Pointer to an uninitialized vertex selector object.
+ * \param from The first vertex id to be included in the vertex
+ *        selector.
+ * \param to The last vertex id to be included in the vertex
+ *        selector.
+ * \return Error code.
+ * \sa \ref igraph_vss_seq(), \ref igraph_vs_destroy()
+ *
+ * Time complexity: O(1).
+ *
+ * \example examples/simple/igraph_vs_seq.c
+ */
 
+int igraph_vs_seq(igraph_vs_t *vs,
+                  igraph_integer_t from, igraph_integer_t to) {
+    vs->type = IGRAPH_VS_SEQ;
+    vs->data.seq.from = from;
+    vs->data.seq.to = to + 1;
     return 0;
 }
 
-int igraph_residual_graph(const igraph_t *graph,
-                          const igraph_vector_t *capacity,
-                          igraph_t *residual,
-                          igraph_vector_t *residual_capacity,
-                          const igraph_vector_t *flow) {
+/**
+ * \function igraph_vss_seq
+ * \brief An interval of vertices (immediate version).
+ *
+ * The immediate version of \ref igraph_vs_seq().
+ *
+ * \param from The first vertex id to be included in the vertex
+ *        selector.
+ * \param to The last vertex id to be included in the vertex
+ *        selector.
+ * \return Error code.
+ * \sa \ref igraph_vs_seq()
+ *
+ * Time complexity: O(1).
+ */
+
+igraph_vs_t igraph_vss_seq(igraph_integer_t from, igraph_integer_t to) {
+    igraph_vs_t vs;
+    vs.type = IGRAPH_VS_SEQ;
+    vs.data.seq.from = from;
+    vs.data.seq.to = to + 1;
+    return vs;
+}
 
-    igraph_vector_t tmp;
-    long int no_of_edges = igraph_ecount(graph);
+/**
+ * \function igraph_vs_destroy
+ * \brief Destroy a vertex set.
+ *
+ * This function should be called for all vertex selectors when they
+ * are not needed. The memory allocated for the vertex selector will
+ * be deallocated. Do not call this function on vertex selectors
+ * created with the immediate versions of the vertex selector
+ * constructors (starting with <code>igraph_vss</code>).
+ *
+ * \param vs Pointer to a vertex selector object.
+ *
+ * Time complexity: operating system dependent, usually O(1).
+ */
 
-    if (igraph_vector_size(capacity) != no_of_edges) {
-        IGRAPH_ERROR("Invalid `capacity' vector size", IGRAPH_EINVAL);
-    }
-    if (igraph_vector_size(flow) != no_of_edges) {
-        IGRAPH_ERROR("Invalid `flow' vector size", IGRAPH_EINVAL);
+void igraph_vs_destroy(igraph_vs_t *vs) {
+    switch (vs->type) {
+    case IGRAPH_VS_ALL:
+    case IGRAPH_VS_ADJ:
+    case IGRAPH_VS_NONE:
+    case IGRAPH_VS_1:
+    case IGRAPH_VS_VECTORPTR:
+    case IGRAPH_VS_SEQ:
+    case IGRAPH_VS_NONADJ:
+        break;
+    case IGRAPH_VS_VECTOR:
+        igraph_vector_destroy((igraph_vector_t*)vs->data.vecptr);
+        IGRAPH_FREE(vs->data.vecptr);
+        break;
+    default:
+        break;
     }
+}
 
-    IGRAPH_VECTOR_INIT_FINALLY(&tmp, 0);
+/**
+ * \function igraph_vs_is_all
+ * \brief Check whether all vertices are included.
+ *
+ * This function checks whether the vertex selector object was created
+ * by \ref igraph_vs_all() or \ref igraph_vss_all(). Note that the
+ * vertex selector might contain all vertices in a given graph but if
+ * it wasn't created by the two constructors mentioned here the return
+ * value will be FALSE.
+ *
+ * \param vs Pointer to a vertex selector object.
+ * \return TRUE (1) if the vertex selector contains all vertices and
+ *         FALSE (0) otherwise.
+ *
+ * Time complexity: O(1).
+ */
+
+igraph_bool_t igraph_vs_is_all(const igraph_vs_t *vs) {
+    return vs->type == IGRAPH_VS_ALL;
+}
 
-    IGRAPH_CHECK(igraph_i_residual_graph(graph, capacity, residual,
-                                         residual_capacity, flow, &tmp));
+int igraph_vs_as_vector(const igraph_t *graph, igraph_vs_t vs,
+                        igraph_vector_t *v) {
+    igraph_vit_t vit;
 
-    igraph_vector_destroy(&tmp);
-    IGRAPH_FINALLY_CLEAN(1);
+    IGRAPH_CHECK(igraph_vit_create(graph, vs, &vit));
+    IGRAPH_FINALLY(igraph_vit_destroy, &vit);
+    IGRAPH_CHECK(igraph_vit_as_vector(&vit, v));
 
+    igraph_vit_destroy(&vit);
+    IGRAPH_FINALLY_CLEAN(1);
     return 0;
 }
 
-static int igraph_i_reverse_residual_graph(const igraph_t *graph,
-                                           const igraph_vector_t *capacity,
-                                           igraph_t *residual,
-                                           const igraph_vector_t *flow,
-                                           igraph_vector_t *tmp) {
+/**
+ * \function igraph_vs_copy
+ * \brief Creates a copy of a vertex selector.
+ * \param src The selector being copied.
+ * \param dest An uninitialized selector that will contain the copy.
+ */
+int igraph_vs_copy(igraph_vs_t* dest, const igraph_vs_t* src) {
+    memcpy(dest, src, sizeof(igraph_vs_t));
+    switch (dest->type) {
+    case IGRAPH_VS_VECTOR:
+        dest->data.vecptr = IGRAPH_CALLOC(1, igraph_vector_t);
+        if (!dest->data.vecptr) {
+            IGRAPH_ERROR("Cannot copy vertex selector", IGRAPH_ENOMEM);
+        }
+        IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*)dest->data.vecptr,
+                                        (igraph_vector_t*)src->data.vecptr));
+        break;
+    }
+    return 0;
+}
 
-    long int no_of_nodes = igraph_vcount(graph);
-    long int no_of_edges = igraph_ecount(graph);
-    long int i, no_new_edges = 0;
-    long int edgeptr = 0;
+/**
+ * \function igraph_vs_type
+ * \brief Returns the type of the vertex selector.
+ */
+int igraph_vs_type(const igraph_vs_t *vs) {
+    return vs->type;
+}
 
-    for (i = 0; i < no_of_edges; i++) {
-        igraph_real_t cap = capacity ? VECTOR(*capacity)[i] : 1.0;
-        if (VECTOR(*flow)[i] > 0) {
-            no_new_edges++;
-        }
-        if (VECTOR(*flow)[i] < cap) {
-            no_new_edges++;
+/**
+ * \function igraph_vs_size
+ * \brief Returns the size of the vertex selector.
+ *
+ * The size of the vertex selector is the number of vertices it will
+ * yield when it is iterated over.
+ *
+ * \param graph The graph over which we will iterate.
+ * \param result The result will be returned here.
+ */
+int igraph_vs_size(const igraph_t *graph, const igraph_vs_t *vs,
+                   igraph_integer_t *result) {
+    igraph_vector_t vec;
+    igraph_bool_t *seen;
+    long i;
+
+    switch (vs->type) {
+    case IGRAPH_VS_NONE:
+        *result = 0; return 0;
+
+    case IGRAPH_VS_1:
+        *result = 0;
+        if (vs->data.vid < igraph_vcount(graph) && vs->data.vid >= 0) {
+            *result = 1;
         }
+        return 0;
+
+    case IGRAPH_VS_SEQ:
+        *result = vs->data.seq.to - vs->data.seq.from;
+        return 0;
+
+    case IGRAPH_VS_ALL:
+        *result = igraph_vcount(graph); return 0;
+
+    case IGRAPH_VS_ADJ:
+        IGRAPH_VECTOR_INIT_FINALLY(&vec, 0);
+        IGRAPH_CHECK(igraph_neighbors(graph, &vec, vs->data.adj.vid, vs->data.adj.mode));
+        *result = (igraph_integer_t) igraph_vector_size(&vec);
+        igraph_vector_destroy(&vec);
+        IGRAPH_FINALLY_CLEAN(1);
+        return 0;
+
+    case IGRAPH_VS_NONADJ:
+        IGRAPH_VECTOR_INIT_FINALLY(&vec, 0);
+        IGRAPH_CHECK(igraph_neighbors(graph, &vec, vs->data.adj.vid, vs->data.adj.mode));
+        *result = igraph_vcount(graph);
+        seen = IGRAPH_CALLOC(*result, igraph_bool_t);
+        if (seen == 0) {
+            IGRAPH_ERROR("Cannot calculate selector length", IGRAPH_ENOMEM);
+        }
+        IGRAPH_FINALLY(igraph_free, seen);
+        for (i = 0; i < igraph_vector_size(&vec); i++) {
+            if (!seen[(long int)VECTOR(vec)[i]]) {
+                (*result)--;
+                seen[(long int)VECTOR(vec)[i]] = 1;
+            }
+        }
+        igraph_free(seen);
+        igraph_vector_destroy(&vec);
+        IGRAPH_FINALLY_CLEAN(2);
+        return 0;
+
+    case IGRAPH_VS_VECTOR:
+    case IGRAPH_VS_VECTORPTR:
+        *result = (igraph_integer_t) igraph_vector_size((igraph_vector_t*)vs->data.vecptr);
+        return 0;
     }
 
-    IGRAPH_CHECK(igraph_vector_resize(tmp, no_new_edges * 2));
+    IGRAPH_ERROR("Cannot calculate selector length, invalid selector type",
+                 IGRAPH_EINVAL);
+}
+
+/***************************************************/
 
-    for (i = 0; i < no_of_edges; i++) {
-        long int from = IGRAPH_FROM(graph, i);
-        long int to = IGRAPH_TO(graph, i);
-        igraph_real_t cap = capacity ? VECTOR(*capacity)[i] : 1.0;
-        if (VECTOR(*flow)[i] > 0) {
-            VECTOR(*tmp)[edgeptr++] = from;
-            VECTOR(*tmp)[edgeptr++] = to;
+/**
+ * \function igraph_vit_create
+ * \brief Creates a vertex iterator from a vertex selector.
+ *
+ * This function instantiates a vertex selector object with a given
+ * graph. This is the step when the actual vertex ids are created from
+ * the \em logical notion of the vertex selector based on the graph.
+ * E.g. a vertex selector created with \ref igraph_vs_all() contains
+ * knowledge that \em all vertices are included in a (yet indefinite)
+ * graph. When instantiating it a vertex iterator object is created,
+ * this contains the actual vertex ids in the graph supplied as a
+ * parameter.
+ *
+ * </para><para>
+ * The same vertex selector object can be used to instantiate any
+ * number vertex iterators.
+ *
+ * \param graph An \type igraph_t object, a graph.
+ * \param vs A vertex selector object.
+ * \param vit Pointer to an uninitialized vertex iterator object.
+ * \return Error code.
+ * \sa \ref igraph_vit_destroy().
+ *
+ * Time complexity: it depends on the vertex selector type. O(1) for
+ * vertex selectors created with \ref igraph_vs_all(), \ref
+ * igraph_vs_none(), \ref igraph_vs_1, \ref igraph_vs_vector, \ref
+ * igraph_vs_seq(), \ref igraph_vs_vector(), \ref
+ * igraph_vs_vector_small(). O(d) for \ref igraph_vs_adj(), d is the
+ * number of vertex ids to be included in the iterator. O(|V|) for
+ * \ref igraph_vs_nonadj(), |V| is the number of vertices in the graph.
+ */
+
+int igraph_vit_create(const igraph_t *graph,
+                      igraph_vs_t vs, igraph_vit_t *vit) {
+    igraph_vector_t vec;
+    igraph_bool_t *seen;
+    long int i, j, n;
+
+    switch (vs.type) {
+    case IGRAPH_VS_ALL:
+        vit->type = IGRAPH_VIT_SEQ;
+        vit->pos = 0;
+        vit->start = 0;
+        vit->end = igraph_vcount(graph);
+        break;
+    case IGRAPH_VS_ADJ:
+        vit->type = IGRAPH_VIT_VECTOR;
+        vit->pos = 0;
+        vit->start = 0;
+        vit->vec = IGRAPH_CALLOC(1, igraph_vector_t);
+        if (vit->vec == 0) {
+            IGRAPH_ERROR("Cannot create iterator", IGRAPH_ENOMEM);
+        }
+        IGRAPH_FINALLY(igraph_free, (igraph_vector_t*) vit->vec);
+        IGRAPH_VECTOR_INIT_FINALLY((igraph_vector_t*)vit->vec, 0);
+        IGRAPH_CHECK(igraph_neighbors(graph, (igraph_vector_t*)vit->vec,
+                                      vs.data.adj.vid, vs.data.adj.mode));
+        vit->end = igraph_vector_size(vit->vec);
+        IGRAPH_FINALLY_CLEAN(2);
+        break;
+    case IGRAPH_VS_NONADJ:
+        vit->type = IGRAPH_VIT_VECTOR;
+        vit->pos = 0;
+        vit->start = 0;
+        vit->vec = IGRAPH_CALLOC(1, igraph_vector_t);
+        if (vit->vec == 0) {
+            IGRAPH_ERROR("Cannot create iterator", IGRAPH_ENOMEM);
+        }
+        IGRAPH_FINALLY(igraph_free, (igraph_vector_t*) vit->vec);
+        IGRAPH_VECTOR_INIT_FINALLY((igraph_vector_t *) vit->vec, 0);
+        IGRAPH_VECTOR_INIT_FINALLY(&vec, 0);
+        IGRAPH_CHECK(igraph_neighbors(graph, &vec,
+                                      vs.data.adj.vid, vs.data.adj.mode));
+        n = igraph_vcount(graph);
+        seen = IGRAPH_CALLOC(n, igraph_bool_t);
+        if (seen == 0) {
+            IGRAPH_ERROR("Cannot create iterator", IGRAPH_ENOMEM);
+        }
+        IGRAPH_FINALLY(igraph_free, seen);
+        for (i = 0; i < igraph_vector_size(&vec); i++) {
+            if (! seen [ (long int) VECTOR(vec)[i] ] ) {
+                n--;
+                seen[ (long int) VECTOR(vec)[i] ] = 1;
+            }
         }
-        if (VECTOR(*flow)[i] < cap) {
-            VECTOR(*tmp)[edgeptr++] = to;
-            VECTOR(*tmp)[edgeptr++] = from;
+        IGRAPH_CHECK(igraph_vector_resize((igraph_vector_t*)vit->vec, n));
+        for (i = 0, j = 0; j < n; i++) {
+            if (!seen[i]) {
+                VECTOR(*vit->vec)[j++] = i;
+            }
         }
-    }
-
-    IGRAPH_CHECK(igraph_create(residual, tmp, (igraph_integer_t) no_of_nodes,
-                               IGRAPH_DIRECTED));
 
+        IGRAPH_FREE(seen);
+        igraph_vector_destroy(&vec);
+        vit->end = n;
+        IGRAPH_FINALLY_CLEAN(4);
+        break;
+    case IGRAPH_VS_NONE:
+        vit->type = IGRAPH_VIT_SEQ;
+        vit->pos = 0;
+        vit->start = 0;
+        vit->end = 0;
+        break;
+    case IGRAPH_VS_1:
+        vit->type = IGRAPH_VIT_SEQ;
+        vit->pos = vs.data.vid;
+        vit->start = vs.data.vid;
+        vit->end = vs.data.vid + 1;
+        if (vit->pos >= igraph_vcount(graph)) {
+            IGRAPH_ERROR("Cannot create iterator, invalid vertex id", IGRAPH_EINVVID);
+        }
+        break;
+    case IGRAPH_VS_VECTORPTR:
+    case IGRAPH_VS_VECTOR:
+        vit->type = IGRAPH_VIT_VECTORPTR;
+        vit->pos = 0;
+        vit->start = 0;
+        vit->vec = vs.data.vecptr;
+        vit->end = igraph_vector_size(vit->vec);
+        if (!igraph_vector_isininterval(vit->vec, 0, igraph_vcount(graph) - 1)) {
+            IGRAPH_ERROR("Cannot create iterator, invalid vertex id", IGRAPH_EINVVID);
+        }
+        break;
+    case IGRAPH_VS_SEQ:
+        vit->type = IGRAPH_VIT_SEQ;
+        vit->pos = vs.data.seq.from;
+        vit->start = vs.data.seq.from;
+        vit->end = vs.data.seq.to;
+        break;
+    default:
+        IGRAPH_ERROR("Cannot create iterator, invalid selector", IGRAPH_EINVAL);
+        break;
+    }
     return 0;
 }
 
-int igraph_reverse_residual_graph(const igraph_t *graph,
-                                  const igraph_vector_t *capacity,
-                                  igraph_t *residual,
-                                  const igraph_vector_t *flow) {
-    igraph_vector_t tmp;
-    long int no_of_edges = igraph_ecount(graph);
+/**
+ * \function igraph_vit_destroy
+ * \brief Destroys a vertex iterator.
+ *
+ * </para><para>
+ * Deallocates memory allocated for a vertex iterator.
+ *
+ * \param vit Pointer to an initialized vertex iterator object.
+ * \sa \ref igraph_vit_create()
+ *
+ * Time complexity: operating system dependent, usually O(1).
+ */
 
-    if (capacity && igraph_vector_size(capacity) != no_of_edges) {
-        IGRAPH_ERROR("Invalid `capacity' vector size", IGRAPH_EINVAL);
-    }
-    if (igraph_vector_size(flow) != no_of_edges) {
-        IGRAPH_ERROR("Invalid `flow' vector size", IGRAPH_EINVAL);
+void igraph_vit_destroy(const igraph_vit_t *vit) {
+    switch (vit->type) {
+    case IGRAPH_VIT_SEQ:
+    case IGRAPH_VIT_VECTORPTR:
+        break;
+    case IGRAPH_VIT_VECTOR:
+        igraph_vector_destroy((igraph_vector_t*)vit->vec);
+        igraph_free((igraph_vector_t*)vit->vec);
+        break;
+    default:
+        /*     IGRAPH_ERROR("Cannot destroy iterator, unknown type", IGRAPH_EINVAL); */
+        break;
     }
-    IGRAPH_VECTOR_INIT_FINALLY(&tmp, 0);
+}
 
-    IGRAPH_CHECK(igraph_i_reverse_residual_graph(graph, capacity, residual,
-                 flow, &tmp));
+int igraph_vit_as_vector(const igraph_vit_t *vit, igraph_vector_t *v) {
 
-    igraph_vector_destroy(&tmp);
-    IGRAPH_FINALLY_CLEAN(1);
+    long int i;
+
+    IGRAPH_CHECK(igraph_vector_resize(v, IGRAPH_VIT_SIZE(*vit)));
+
+    switch (vit->type) {
+    case IGRAPH_VIT_SEQ:
+        for (i = 0; i < IGRAPH_VIT_SIZE(*vit); i++) {
+            VECTOR(*v)[i] = vit->start + i;
+        }
+        break;
+    case IGRAPH_VIT_VECTOR:
+    case IGRAPH_VIT_VECTORPTR:
+        for (i = 0; i < IGRAPH_VIT_SIZE(*vit); i++) {
+            VECTOR(*v)[i] = VECTOR(*vit->vec)[i];
+        }
+        break;
+    default:
+        IGRAPH_ERROR("Cannot convert to vector, unknown iterator type",
+                     IGRAPH_EINVAL);
+        break;
+    }
 
     return 0;
 }
 
-typedef struct igraph_i_dbucket_t {
-    igraph_vector_long_t head;
-    igraph_vector_long_t next;
-} igraph_i_dbucket_t;
-
-static int igraph_i_dbucket_init(igraph_i_dbucket_t *buck, long int size) {
-    IGRAPH_CHECK(igraph_vector_long_init(&buck->head, size));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &buck->head);
-    IGRAPH_CHECK(igraph_vector_long_init(&buck->next, size));
-    IGRAPH_FINALLY_CLEAN(1);
+/*******************************************************/
+
+/**
+ * \function igraph_es_all
+ * \brief Edge set, all edges.
+ *
+ * \param es Pointer to an uninitialized edge selector object.
+ * \param order Constant giving the order in which the edges will be
+ *        included in the selector. Possible values:
+ *        \c IGRAPH_EDGEORDER_ID, edge id order.
+ *        \c IGRAPH_EDGEORDER_FROM, vertex id order, the id of the
+ *           \em source vertex counts for directed graphs. The order
+ *           of the incident edges of a given vertex is arbitrary.
+ *        \c IGRAPH_EDGEORDER_TO, vertex id order, the id of the \em
+ *           target vertex counts for directed graphs. The order
+ *           of the incident edges of a given vertex is arbitrary.
+ *        For undirected graph the latter two is the same.
+ * \return Error code.
+ * \sa \ref igraph_ess_all(), \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
+
+int igraph_es_all(igraph_es_t *es,
+                  igraph_edgeorder_type_t order) {
+    switch (order) {
+    case IGRAPH_EDGEORDER_ID:
+        es->type = IGRAPH_ES_ALL;
+        break;
+    case IGRAPH_EDGEORDER_FROM:
+        es->type = IGRAPH_ES_ALLFROM;
+        break;
+    case IGRAPH_EDGEORDER_TO:
+        es->type = IGRAPH_ES_ALLTO;
+        break;
+    default:
+        IGRAPH_ERROR("Invalid edge order, cannot create selector", IGRAPH_EINVAL);
+        break;
+    }
     return 0;
 }
 
-static void igraph_i_dbucket_destroy(igraph_i_dbucket_t *buck) {
-    igraph_vector_long_destroy(&buck->head);
-    igraph_vector_long_destroy(&buck->next);
+/**
+ * \function igraph_ess_all
+ * \brief Edge set, all edges (immediate version)
+ *
+ * The immediate version of the all-edges selector.
+ *
+ * \param order Constant giving the order of the edges in the edge
+ *        selector. See \ref igraph_es_all() for the possible values.
+ * \return The edge selector.
+ * \sa \ref igraph_es_all()
+ *
+ * Time complexity: O(1).
+ */
+
+igraph_es_t igraph_ess_all(igraph_edgeorder_type_t order) {
+    igraph_es_t es;
+    igraph_es_all(&es, order); /* cannot fail */
+    return es;
 }
 
-static int igraph_i_dbucket_insert(igraph_i_dbucket_t *buck, long int bid,
-                                   long int elem) {
-    /* Note: we can do this, since elem is not in any buckets */
-    VECTOR(buck->next)[elem] = VECTOR(buck->head)[bid];
-    VECTOR(buck->head)[bid] = elem + 1;
+/**
+ * \function igraph_es_incident
+ * \brief Edges incident on a given vertex.
+ *
+ * \param es Pointer to an uninitialized edge selector object.
+ * \param vid Vertex id, of which the incident edges will be
+ *        selected.
+ * \param mode Constant giving the type of the incident edges to
+ *        select. This is ignored for undirected graphs. Possible values:
+ *        \c IGRAPH_OUT, outgoing edges;
+ *        \c IGRAPH_IN, incoming edges;
+ *        \c IGRAPH_ALL, all edges.
+ * \return Error code.
+ * \sa \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
+
+int igraph_es_incident(igraph_es_t *es,
+                       igraph_integer_t vid, igraph_neimode_t mode) {
+    es->type = IGRAPH_ES_INCIDENT;
+    es->data.incident.vid = vid;
+    es->data.incident.mode = mode;
     return 0;
 }
 
-static long int igraph_i_dbucket_empty(const igraph_i_dbucket_t *buck,
-                                       long int bid) {
-    return VECTOR(buck->head)[bid] == 0;
+/**
+ * \function igraph_es_none
+ * \brief Empty edge selector.
+ *
+ * \param es Pointer to an uninitialized edge selector object to
+ * initialize.
+ * \return Error code.
+ * \sa \ref igraph_ess_none(), \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
+
+int igraph_es_none(igraph_es_t *es) {
+    es->type = IGRAPH_ES_NONE;
+    return 0;
 }
 
-static long int igraph_i_dbucket_delete(igraph_i_dbucket_t *buck, long int bid) {
-    long int elem = VECTOR(buck->head)[bid] - 1;
-    VECTOR(buck->head)[bid] = VECTOR(buck->next)[elem];
-    return elem;
+/**
+ * \function igraph_ess_none
+ * \brief Immediate empty edge selector.
+ *
+ * </para><para>
+ * Immediate version of the empty edge selector.
+ *
+ * \return Initialized empty edge selector.
+ * \sa \ref igraph_es_none()
+ *
+ * Time complexity: O(1).
+ */
+
+igraph_es_t igraph_ess_none(void) {
+    igraph_es_t es;
+    es.type = IGRAPH_ES_NONE;
+    return es;
 }
 
-static int igraph_i_dominator_LINK(long int v, long int w,
-                                   igraph_vector_long_t *ancestor) {
-    VECTOR(*ancestor)[w] = v + 1;
+/**
+ * \function igraph_es_1
+ * \brief Edge selector containing a single edge.
+ *
+ * \param es Pointer to an uninitialized edge selector object.
+ * \param eid Edge id of the edge to select.
+ * \return Error code.
+ * \sa \ref igraph_ess_1(), \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
+
+int igraph_es_1(igraph_es_t *es, igraph_integer_t eid) {
+    es->type = IGRAPH_ES_1;
+    es->data.eid = eid;
     return 0;
 }
 
-/* TODO: don't always reallocate path */
-
-static int igraph_i_dominator_COMPRESS(long int v,
-                                       igraph_vector_long_t *ancestor,
-                                       igraph_vector_long_t *label,
-                                       igraph_vector_long_t *semi) {
-    igraph_stack_long_t path;
-    long int w = v;
-    long int top, pretop;
+/**
+ * \function igraph_ess_1
+ * \brief Immediate version of the single edge edge selector.
+ *
+ * \param eid The id of the edge.
+ * \return The edge selector.
+ * \sa \ref igraph_es_1()
+ *
+ * Time complexity: O(1).
+ */
 
-    IGRAPH_CHECK(igraph_stack_long_init(&path, 10));
-    IGRAPH_FINALLY(igraph_stack_long_destroy, &path);
+igraph_es_t igraph_ess_1(igraph_integer_t eid) {
+    igraph_es_t es;
+    es.type = IGRAPH_ES_1;
+    es.data.eid = eid;
+    return es;
+}
 
-    while (VECTOR(*ancestor)[w] != 0) {
-        IGRAPH_CHECK(igraph_stack_long_push(&path, w));
-        w = VECTOR(*ancestor)[w] - 1;
-    }
+/**
+ * \function igraph_es_vector
+ * \brief Handle a vector as an edge selector.
+ *
+ * </para><para>
+ * Creates an edge selector which serves as a view to a vector
+ * containing edge ids. Do not destroy the vector before destroying
+ * the view.
+ *
+ * Many views can be created to the same vector.
+ *
+ * \param es Pointer to an uninitialized edge selector.
+ * \param v Vector containing edge ids.
+ * \return Error code.
+ * \sa \ref igraph_ess_vector(), \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
 
-    top = igraph_stack_long_pop(&path);
-    while (!igraph_stack_long_empty(&path)) {
-        pretop = igraph_stack_long_pop(&path);
+int igraph_es_vector(igraph_es_t *es,
+                     const igraph_vector_t *v) {
+    es->type = IGRAPH_ES_VECTORPTR;
+    es->data.vecptr = v;
+    return 0;
+}
 
-        if (VECTOR(*semi)[VECTOR(*label)[top]] <
-            VECTOR(*semi)[VECTOR(*label)[pretop]]) {
-            VECTOR(*label)[pretop] = VECTOR(*label)[top];
-        }
-        VECTOR(*ancestor)[pretop] = VECTOR(*ancestor)[top];
+/**
+ * \function igraph_es_vector_copy
+ * \brief Edge set, based on a vector, with copying.
+ *
+ *
+ * This function makes it possible to handle a \type vector_t
+ * permanently as an edge selector. The edge selector creates a
+ * copy of the original vector, so the vector can safely be destroyed
+ * after creating the edge selector. Changing the original vector
+ * will not affect the edge selector. The edge selector is
+ * responsible for deleting the copy made by itself.
+ *
+ * \param es Pointer to an uninitialized edge selector.
+ * \param v Pointer to a \type igraph_vector_t object.
+ * \return Error code.
+ * \sa \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
 
-        top = pretop;
+int igraph_es_vector_copy(igraph_es_t *es, const igraph_vector_t *v) {
+    es->type = IGRAPH_ES_VECTOR;
+    es->data.vecptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (es->data.vecptr == 0) {
+        IGRAPH_ERROR("Cannot create edge selector", IGRAPH_ENOMEM);
     }
-
-    igraph_stack_long_destroy(&path);
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)es->data.vecptr);
+    IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*)es->data.vecptr, v));
     IGRAPH_FINALLY_CLEAN(1);
-
     return 0;
 }
 
-static long int igraph_i_dominator_EVAL(long int v,
-                                        igraph_vector_long_t *ancestor,
-                                        igraph_vector_long_t *label,
-                                        igraph_vector_long_t *semi) {
-    if (VECTOR(*ancestor)[v] == 0) {
-        return v;
-    } else {
-        igraph_i_dominator_COMPRESS(v, ancestor, label, semi);
-        return VECTOR(*label)[v];
-    }
-}
+/**
+ * \function igraph_ess_vector
+ * \brief Immediate vector view edge selector.
+ *
+ * </para><para>
+ * This is the immediate version of the vector of edge ids edge
+ * selector.
+ *
+ * \param v The vector of edge ids.
+ * \return Edge selector, initialized.
+ * \sa \ref igraph_es_vector()
+ *
+ * Time complexity: O(1).
+ */
 
-/* TODO: implement the faster version. */
+igraph_es_t igraph_ess_vector(const igraph_vector_t *v) {
+    igraph_es_t es;
+    es.type = IGRAPH_ES_VECTORPTR;
+    es.data.vecptr = v;
+    return es;
+}
 
 /**
- * \function igraph_dominator_tree
- * Calculates the dominator tree of a flowgraph
- *
- * A flowgraph is a directed graph with a distinguished start (or
- * root) vertex r, such that for any vertex v, there is a path from r
- * to v. A vertex v dominates another vertex w (not equal to v), if
- * every path from r to w contains v. Vertex v is the immediate
- * dominator or w, v=idom(w), if v dominates w and every other
- * dominator of w dominates v. The edges {(idom(w), w)| w is not r}
- * form a directed tree, rooted at r, called the dominator tree of the
- * graph. Vertex v dominates vertex w if and only if v is an ancestor
- * of w in the dominator tree.
- *
- * </para><para>This function implements the Lengauer-Tarjan algorithm
- * to construct the dominator tree of a directed graph. For details
- * please see Thomas Lengauer, Robert Endre Tarjan: A fast algorithm
- * for finding dominators in a flowgraph, ACM Transactions on
- * Programming Languages and Systems (TOPLAS) I/1, 121--141, 1979.
- *
- * \param graph A directed graph. If it is not a flowgraph, and it
- *        contains some vertices not reachable from the root vertex,
- *        then these vertices will be collected in the \c leftout
- *        vector.
- * \param root The id of the root (or source) vertex, this will be the
- *        root of the tree.
- * \param dom Pointer to an initialized vector or a null pointer. If
- *        not a null pointer, then the immediate dominator of each
- *        vertex will be stored here. For vertices that are not
- *        reachable from the root, NaN is stored here. For
- *        the root vertex itself, -1 is added.
- * \param domtree Pointer to an uninitialized igraph_t, or NULL. If
- *        not a null pointer, then the dominator tree is returned
- *        here. The graph contains the vertices that are unreachable
- *        from the root (if any), these will be isolates.
- * \param leftout Pointer to an initialized vector object, or NULL. If
- *        not NULL, then the ids of the vertices that are unreachable
- *        from the root vertex (and thus not part of the dominator
- *        tree) are stored here.
- * \param mode Constant, must be \c IGRAPH_IN or \c IGRAPH_OUT. If it
- *        is \c IGRAPH_IN, then all directions are considered as
- *        opposite to the original one in the input graph.
- * \return Error code.
- *
- * Time complexity: very close to O(|E|+|V|), linear in the number of
- * edges and vertices. More precisely, it is O(|V|+|E|alpha(|E|,|V|)),
- * where alpha(|E|,|V|) is a functional inverse of Ackermann's
- * function.
- *
- * \example examples/simple/dominator_tree.c
- */
-
-int igraph_dominator_tree(const igraph_t *graph,
-                          igraph_integer_t root,
-                          igraph_vector_t *dom,
-                          igraph_t *domtree,
-                          igraph_vector_t *leftout,
-                          igraph_neimode_t mode) {
+ * \function igraph_es_fromto
+ * \brief Edge selector, all edges between two vertex sets.
+ *
+ * </para><para>
+ * This function is not implemented yet.
+ *
+ * \param es Pointer to an uninitialized edge selector.
+ * \param from Vertex selector, their outgoing edges will be
+ *        selected.
+ * \param to Vertex selector, their incoming edges will be selected
+ *        from the previous selection.
+ * \return Error code.
+ * \sa \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
 
-    long int no_of_nodes = igraph_vcount(graph);
+int igraph_es_fromto(igraph_es_t *es,
+                     igraph_vs_t from, igraph_vs_t to) {
 
-    igraph_adjlist_t succ, pred;
-    igraph_vector_t parent;
-    igraph_vector_long_t semi;    /* +1 always */
-    igraph_vector_t vertex;   /* +1 always */
-    igraph_i_dbucket_t bucket;
-    igraph_vector_long_t ancestor;
-    igraph_vector_long_t label;
+    IGRAPH_UNUSED(es); IGRAPH_UNUSED(from); IGRAPH_UNUSED(to);
+    IGRAPH_ERROR("igraph_es_fromto not implemented yet", IGRAPH_UNIMPLEMENTED);
+    /* TODO */
+}
 
-    igraph_neimode_t invmode = mode == IGRAPH_IN ? IGRAPH_OUT : IGRAPH_IN;
+/**
+ * \function igraph_es_seq
+ * \brief Edge selector, a sequence of edge ids.
+ *
+ * All edge ids between <code>from</code> and <code>to</code> will be
+ * included in the edge selection. This includes <code>from</code> and
+ * excludes <code>to</code>.
+ *
+ * \param es Pointer to an uninitialized edge selector object.
+ * \param from The first edge id to be included.
+ * \param to The last edge id to be included.
+ * \return Error code.
+ * \sa \ref igraph_ess_seq(), \ref igraph_es_destroy()
+ *
+ * Time complexity: O(1).
+ */
 
-    long int i;
+int igraph_es_seq(igraph_es_t *es,
+                  igraph_integer_t from, igraph_integer_t to) {
+    es->type = IGRAPH_ES_SEQ;
+    es->data.seq.from = from;
+    es->data.seq.to = to;
+    return 0;
+}
 
-    igraph_vector_t vdom, *mydom = dom;
+/**
+ * \function igraph_ess_seq
+ * \brief Immediate version of the sequence edge selector.
+ *
+ * \param from The first edge id to include.
+ * \param to The last edge id to include.
+ * \return The initialized edge selector.
+ * \sa \ref igraph_es_seq()
+ *
+ * Time complexity: O(1).
+ */
 
-    long int component_size = 0;
+igraph_es_t igraph_ess_seq(igraph_integer_t from, igraph_integer_t to) {
+    igraph_es_t es;
+    es.type = IGRAPH_ES_SEQ;
+    es.data.seq.from = from;
+    es.data.seq.to = to;
+    return es;
+}
 
-    if (root < 0 || root >= no_of_nodes) {
-        IGRAPH_ERROR("Invalid root vertex id for dominator tree",
-                     IGRAPH_EINVAL);
-    }
+/**
+ * \function igraph_es_pairs
+ * \brief Edge selector, multiple edges defined by their endpoints in a vector.
+ *
+ * The edges between the given pairs of vertices will be included in the
+ * edge selection. The vertex pairs must be defined in the vector <code>v</code>,
+ * the first element of the vector is the first vertex of the first edge
+ * to be selected, the second element is the second vertex of the first
+ * edge, the third element is the first vertex of the second edge and
+ * so on.
+ *
+ * \param es Pointer to an uninitialized edge selector object.
+ * \param v The vector containing the endpoints of the edges.
+ * \param directed Whether the graph is directed or not.
+ * \return Error code.
+ * \sa \ref igraph_es_pairs_small(), \ref igraph_es_destroy()
+ *
+ * Time complexity: O(n), the number of edges being selected.
+ *
+ * \example examples/simple/igraph_es_pairs.c
+ */
 
-    if (!igraph_is_directed(graph)) {
-        IGRAPH_ERROR("Dominator tree of an undirected graph requested",
-                     IGRAPH_EINVAL);
+int igraph_es_pairs(igraph_es_t *es, const igraph_vector_t *v,
+                    igraph_bool_t directed) {
+    es->type = IGRAPH_ES_PAIRS;
+    es->data.path.mode = directed;
+    es->data.path.ptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (es->data.path.ptr == 0) {
+        IGRAPH_ERROR("Cannot create edge selector", IGRAPH_ENOMEM);
     }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*) es->data.path.ptr);
 
-    if (mode == IGRAPH_ALL) {
-        IGRAPH_ERROR("Invalid neighbor mode for dominator tree",
-                     IGRAPH_EINVAL);
-    }
+    IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*) es->data.path.ptr, v));
 
-    if (dom) {
-        IGRAPH_CHECK(igraph_vector_resize(dom, no_of_nodes));
-    } else {
-        mydom = &vdom;
-        IGRAPH_VECTOR_INIT_FINALLY(mydom, no_of_nodes);
-    }
-    igraph_vector_fill(mydom, IGRAPH_NAN);
+    IGRAPH_FINALLY_CLEAN(1);
+    return 0;
+}
 
-    IGRAPH_CHECK(igraph_vector_init(&parent, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_destroy, &parent);
-    IGRAPH_CHECK(igraph_vector_long_init(&semi, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &semi);
-    IGRAPH_CHECK(igraph_vector_init(&vertex, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_destroy, &vertex);
-    IGRAPH_CHECK(igraph_vector_long_init(&ancestor, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &ancestor);
-    IGRAPH_CHECK(igraph_vector_long_init_seq(&label, 0, no_of_nodes - 1));
-    IGRAPH_FINALLY(igraph_vector_long_destroy, &label);
-    IGRAPH_CHECK(igraph_adjlist_init(graph, &succ, mode, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &succ);
-    IGRAPH_CHECK(igraph_adjlist_init(graph, &pred, invmode, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &pred);
-    IGRAPH_CHECK(igraph_i_dbucket_init(&bucket, no_of_nodes));
-    IGRAPH_FINALLY(igraph_i_dbucket_destroy, &bucket);
-
-    /* DFS first, to set semi, vertex and parent, step 1 */
-
-    IGRAPH_CHECK(igraph_dfs(graph, root, mode, /*unreachable=*/ 0,
-                            /*order=*/ &vertex,
-                            /*order_out=*/ 0, /*father=*/ &parent,
-                            /*dist=*/ 0, /*in_callback=*/ 0,
-                            /*out_callback=*/ 0, /*extra=*/ 0));
-
-    for (i = 0; i < no_of_nodes; i++) {
-        if (IGRAPH_FINITE(VECTOR(vertex)[i])) {
-            long int t = (long int) VECTOR(vertex)[i];
-            VECTOR(semi)[t] = component_size + 1;
-            VECTOR(vertex)[component_size] = t + 1;
-            component_size++;
-        }
-    }
-    if (leftout) {
-        long int n = no_of_nodes - component_size;
-        long int p = 0, j;
-        IGRAPH_CHECK(igraph_vector_resize(leftout, n));
-        for (j = 0; j < no_of_nodes && p < n; j++) {
-            if (!IGRAPH_FINITE(VECTOR(parent)[j])) {
-                VECTOR(*leftout)[p++] = j;
-            }
-        }
-    }
+/**
+ * \function igraph_es_pairs_small
+ * \brief Edge selector, multiple edges defined by their endpoints as arguments.
+ *
+ * The edges between the given pairs of vertices will be included in the
+ * edge selection. The vertex pairs must be given as the arguments of the
+ * function call, the third argument is the first vertex of the first edge,
+ * the fourth argument is the second vertex of the first edge, the fifth
+ * is the first vertex of the second edge and so on. The last element of the
+ * argument list must be -1 to denote the end of the argument list.
+ *
+ * \param es Pointer to an uninitialized edge selector object.
+ * \param directed Whether the graph is directed or not.
+ * \return Error code.
+ * \sa \ref igraph_es_pairs(), \ref igraph_es_destroy()
+ *
+ * Time complexity: O(n), the number of edges being selected.
+ */
 
-    /* We need to go over 'pred' because it should contain only the
-       edges towards the target vertex. */
-    for (i = 0; i < no_of_nodes; i++) {
-        igraph_vector_int_t *v = igraph_adjlist_get(&pred, i);
-        long int j, n = igraph_vector_int_size(v);
-        for (j = 0; j < n; ) {
-            long int v2 = (long int) VECTOR(*v)[j];
-            if (IGRAPH_FINITE(VECTOR(parent)[v2])) {
-                j++;
-            } else {
-                VECTOR(*v)[j] = VECTOR(*v)[n - 1];
-                igraph_vector_int_pop_back(v);
-                n--;
-            }
+int igraph_es_pairs_small(igraph_es_t *es, igraph_bool_t directed, ...) {
+    va_list ap;
+    long int i, n = 0;
+    es->type = IGRAPH_ES_PAIRS;
+    es->data.path.mode = directed;
+    es->data.path.ptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (es->data.path.ptr == 0) {
+        IGRAPH_ERROR("Cannot create edge selector", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)es->data.path.ptr);
+
+    va_start(ap, directed);
+    while (1) {
+        int num = va_arg(ap, int);
+        if (num == -1) {
+            break;
         }
+        n++;
     }
+    va_end(ap);
 
-    /* Now comes the main algorithm, steps 2 & 3 */
+    IGRAPH_VECTOR_INIT_FINALLY( (igraph_vector_t*) es->data.path.ptr, n);
 
-    for (i = component_size - 1; i > 0; i--) {
-        long int w = (long int) VECTOR(vertex)[i] - 1;
-        igraph_vector_int_t *predw = igraph_adjlist_get(&pred, w);
-        long int j, n = igraph_vector_int_size(predw);
-        for (j = 0; j < n; j++) {
-            long int v = (long int) VECTOR(*predw)[j];
-            long int u = igraph_i_dominator_EVAL(v, &ancestor, &label, &semi);
-            if (VECTOR(semi)[u] < VECTOR(semi)[w]) {
-                VECTOR(semi)[w] = VECTOR(semi)[u];
-            }
-        }
-        igraph_i_dbucket_insert(&bucket, (long int)
-                                VECTOR(vertex)[ VECTOR(semi)[w] - 1 ] - 1, w);
-        igraph_i_dominator_LINK((long int) VECTOR(parent)[w], w, &ancestor);
-        while (!igraph_i_dbucket_empty(&bucket, (long int) VECTOR(parent)[w])) {
-            long int v = igraph_i_dbucket_delete(&bucket, (long int) VECTOR(parent)[w]);
-            long int u = igraph_i_dominator_EVAL(v, &ancestor, &label, &semi);
-            VECTOR(*mydom)[v] = VECTOR(semi)[u] < VECTOR(semi)[v] ? u :
-                                VECTOR(parent)[w];
-        }
+    va_start(ap, directed);
+    for (i = 0; i < n; i++) {
+        VECTOR(*es->data.path.ptr)[i] = (igraph_real_t) va_arg(ap, int);
     }
+    va_end(ap);
 
-    /* Finally, step 4 */
-
-    for (i = 1; i < component_size; i++) {
-        long int w = (long int) VECTOR(vertex)[i] - 1;
-        if (VECTOR(*mydom)[w] != VECTOR(vertex)[VECTOR(semi)[w] - 1] - 1) {
-            VECTOR(*mydom)[w] = VECTOR(*mydom)[(long int)VECTOR(*mydom)[w]];
-        }
-    }
-    VECTOR(*mydom)[(long int)root] = -1;
-
-    igraph_i_dbucket_destroy(&bucket);
-    igraph_adjlist_destroy(&pred);
-    igraph_adjlist_destroy(&succ);
-    igraph_vector_long_destroy(&label);
-    igraph_vector_long_destroy(&ancestor);
-    igraph_vector_destroy(&vertex);
-    igraph_vector_long_destroy(&semi);
-    igraph_vector_destroy(&parent);
-    IGRAPH_FINALLY_CLEAN(8);
-
-    if (domtree) {
-        igraph_vector_t edges;
-        long int ptr = 0;
-        IGRAPH_VECTOR_INIT_FINALLY(&edges, component_size * 2 - 2);
-        for (i = 0; i < no_of_nodes; i++) {
-            if (i != root && IGRAPH_FINITE(VECTOR(*mydom)[i])) {
-                if (mode == IGRAPH_OUT) {
-                    VECTOR(edges)[ptr++] = VECTOR(*mydom)[i];
-                    VECTOR(edges)[ptr++] = i;
-                } else {
-                    VECTOR(edges)[ptr++] = i;
-                    VECTOR(edges)[ptr++] = VECTOR(*mydom)[i];
-                }
-            }
-        }
-        IGRAPH_CHECK(igraph_create(domtree, &edges, (igraph_integer_t) no_of_nodes,
-                                   IGRAPH_DIRECTED));
-        igraph_vector_destroy(&edges);
-        IGRAPH_FINALLY_CLEAN(1);
+    IGRAPH_FINALLY_CLEAN(2);
+    return 0;
+}
 
-        IGRAPH_I_ATTRIBUTE_DESTROY(domtree);
-        IGRAPH_I_ATTRIBUTE_COPY(domtree, graph, /*graph=*/ 1, /*vertex=*/ 1,
-                                /*edge=*/ 0);
+int igraph_es_multipairs(igraph_es_t *es, const igraph_vector_t *v,
+                         igraph_bool_t directed) {
+    es->type = IGRAPH_ES_MULTIPAIRS;
+    es->data.path.mode = directed;
+    es->data.path.ptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (es->data.path.ptr == 0) {
+        IGRAPH_ERROR("Cannot create edge selector", IGRAPH_ENOMEM);
     }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*) es->data.path.ptr);
 
-    if (!dom) {
-        igraph_vector_destroy(&vdom);
-        IGRAPH_FINALLY_CLEAN(1);
-    }
+    IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*) es->data.path.ptr, v));
 
+    IGRAPH_FINALLY_CLEAN(1);
     return 0;
 }
 
-typedef struct igraph_i_all_st_cuts_minimal_dfs_data_t {
-    igraph_stack_t *stack;
-    igraph_vector_bool_t *nomark;
-    const igraph_vector_bool_t *GammaX;
-    long int root;
-    const igraph_vector_t *map;
-} igraph_i_all_st_cuts_minimal_dfs_data_t;
-
-static igraph_bool_t igraph_i_all_st_cuts_minimal_dfs_incb(
-        const igraph_t *graph,
-        igraph_integer_t vid,
-        igraph_integer_t dist,
-        void *extra) {
-
-    igraph_i_all_st_cuts_minimal_dfs_data_t *data = extra;
-    igraph_stack_t *stack = data->stack;
-    igraph_vector_bool_t *nomark = data->nomark;
-    const igraph_vector_bool_t *GammaX = data->GammaX;
-    const igraph_vector_t *map = data->map;
-    long int realvid = (long int) VECTOR(*map)[(long int)vid];
-
-    IGRAPH_UNUSED(graph); IGRAPH_UNUSED(dist);
-
-    if (VECTOR(*GammaX)[(long int)realvid]) {
-        if (!igraph_stack_empty(stack)) {
-            long int top = (long int) igraph_stack_top(stack);
-            VECTOR(*nomark)[top] = 1; /* we just found a smaller one */
-        }
-        igraph_stack_push(stack, realvid); /* TODO: error check */
+/**
+ * \function igraph_es_path
+ * \brief Edge selector, edge ids on a path.
+ *
+ * This function takes a vector of vertices and creates a selector of
+ * edges between those vertices. Vector {0, 3, 4, 7} will select edges
+ * (0 -> 3), (3 -> 4), (4 -> 7). If these edges don't exist then trying
+ * to create an iterator using this selector will fail.
+ *
+ * \param es Pointer to an uninitialized edge selector object.
+ * \param v Pointer to a vector of vertex id's along the path.
+ * \param directed If edge directions should be taken into account. This
+ *                 will be ignored if the graph to select from is undirected.
+ * \return Error code.
+ * \sa \ref igraph_es_destroy()
+ *
+ * Time complexity: O(n), the number of vertices.
+ */
+int igraph_es_path(igraph_es_t *es, const igraph_vector_t *v,
+                   igraph_bool_t directed) {
+    es->type = IGRAPH_ES_PATH;
+    es->data.path.mode = directed;
+    es->data.path.ptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (es->data.path.ptr == 0) {
+        IGRAPH_ERROR("Cannot create edge selector", IGRAPH_ENOMEM);
     }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*) es->data.path.ptr);
 
+    IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*) es->data.path.ptr, v));
+
+    IGRAPH_FINALLY_CLEAN(1);
     return 0;
 }
 
-static igraph_bool_t igraph_i_all_st_cuts_minimal_dfs_otcb(
-        const igraph_t *graph,
-        igraph_integer_t vid,
-        igraph_integer_t dist,
-        void *extra) {
-    igraph_i_all_st_cuts_minimal_dfs_data_t *data = extra;
-    igraph_stack_t *stack = data->stack;
-    const igraph_vector_t *map = data->map;
-    long int realvid = (long int) VECTOR(*map)[(long int)vid];
+int igraph_es_path_small(igraph_es_t *es, igraph_bool_t directed, ...) {
+    va_list ap;
+    long int i, n = 0;
+    es->type = IGRAPH_ES_PATH;
+    es->data.path.mode = directed;
+    es->data.path.ptr = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (es->data.path.ptr == 0) {
+        IGRAPH_ERROR("Cannot create edge selector", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)es->data.path.ptr);
+
+    va_start(ap, directed);
+    while (1) {
+        int num = va_arg(ap, int);
+        if (num == -1) {
+            break;
+        }
+        n++;
+    }
+    va_end(ap);
 
-    IGRAPH_UNUSED(graph); IGRAPH_UNUSED(dist);
+    IGRAPH_VECTOR_INIT_FINALLY( (igraph_vector_t*) es->data.path.ptr, n);
 
-    if (!igraph_stack_empty(stack) &&
-        igraph_stack_top(stack) == realvid) {
-        igraph_stack_pop(stack);
+    va_start(ap, directed);
+    for (i = 0; i < n; i++) {
+        VECTOR(*es->data.path.ptr)[i] = (igraph_real_t) va_arg(ap, int);
     }
+    va_end(ap);
 
+    IGRAPH_FINALLY_CLEAN(2);
     return 0;
 }
 
-static int igraph_i_all_st_cuts_minimal(const igraph_t *graph,
-                                        const igraph_t *domtree,
-                                        long int root,
-                                        const igraph_marked_queue_t *X,
-                                        const igraph_vector_bool_t *GammaX,
-                                        const igraph_vector_t *invmap,
-                                        igraph_vector_t *minimal) {
-
-    long int no_of_nodes = igraph_vcount(graph);
-    igraph_stack_t stack;
-    igraph_vector_bool_t nomark;
-    igraph_i_all_st_cuts_minimal_dfs_data_t data;
-    long int i;
-
-    IGRAPH_UNUSED(X);
+/**
+ * \function igraph_es_destroy
+ * \brief Destroys an edge selector object.
+ *
+ * </para><para>
+ * Call this function on an edge selector when it is not needed any
+ * more. Do \em not call this function on edge selectors created by
+ * immediate constructors, those don't need to be destroyed.
+ *
+ * \param es Pointer to an edge selector object.
+ *
+ * Time complexity: operating system dependent, usually O(1).
+ */
 
-    IGRAPH_CHECK(igraph_stack_init(&stack, 10));
-    IGRAPH_FINALLY(igraph_stack_destroy, &stack);
-    IGRAPH_CHECK(igraph_vector_bool_init(&nomark, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_bool_destroy, &nomark);
-
-    data.stack = &stack;
-    data.nomark = &nomark;
-    data.GammaX = GammaX;
-    data.root = root;
-    data.map = invmap;
-
-    /* We mark all GammaX elements as minimal first.
-       TODO: actually, we could just use GammaX to return the minimal
-       elements. */
-    for (i = 0; i < no_of_nodes; i++) {
-        VECTOR(nomark)[i] = VECTOR(*GammaX)[i] == 0 ? 1 : 0;
-    }
-
-    /* We do a reverse DFS from root. If, along a path we find a GammaX
-       vertex after (=below) another GammaX vertex, we mark the higher
-       one as non-minimal. */
-
-    IGRAPH_CHECK(igraph_dfs(domtree, (igraph_integer_t) root, IGRAPH_IN,
-                            /*unreachable=*/ 0, /*order=*/ 0,
-                            /*order_out=*/ 0, /*father=*/ 0,
-                            /*dist=*/ 0, /*in_callback=*/
-                            igraph_i_all_st_cuts_minimal_dfs_incb,
-                            /*out_callback=*/
-                            igraph_i_all_st_cuts_minimal_dfs_otcb,
-                            /*extra=*/ &data));
-
-    igraph_vector_clear(minimal);
-    for (i = 0; i < no_of_nodes; i++) {
-        if (!VECTOR(nomark)[i]) {
-            IGRAPH_CHECK(igraph_vector_push_back(minimal, i));
-        }
+void igraph_es_destroy(igraph_es_t *es) {
+    switch (es->type) {
+    case IGRAPH_ES_ALL:
+    case IGRAPH_ES_ALLFROM:
+    case IGRAPH_ES_ALLTO:
+    case IGRAPH_ES_INCIDENT:
+    case IGRAPH_ES_NONE:
+    case IGRAPH_ES_1:
+    case IGRAPH_ES_VECTORPTR:
+    case IGRAPH_ES_SEQ:
+        break;
+    case IGRAPH_ES_VECTOR:
+        igraph_vector_destroy((igraph_vector_t*)es->data.vecptr);
+        IGRAPH_FREE(es->data.vecptr);
+        break;
+    case IGRAPH_ES_PAIRS:
+    case IGRAPH_ES_PATH:
+    case IGRAPH_ES_MULTIPAIRS:
+        igraph_vector_destroy((igraph_vector_t*)es->data.path.ptr);
+        IGRAPH_FREE(es->data.path.ptr);
+        break;
+    default:
+        break;
     }
+}
 
-    igraph_vector_bool_destroy(&nomark);
-    igraph_stack_destroy(&stack);
-    IGRAPH_FINALLY_CLEAN(2);
+/**
+ * \function igraph_es_is_all
+ * \brief Check whether an edge selector includes all edges.
+ *
+ * \param es Pointer to an edge selector object.
+ * \return TRUE (1) if <code>es</code> was created with \ref
+ * igraph_es_all() or \ref igraph_ess_all(), and FALSE (0) otherwise.
+ *
+ * Time complexity: O(1).
+ */
 
+igraph_bool_t igraph_es_is_all(const igraph_es_t *es) {
+    return es->type == IGRAPH_ES_ALL;
+}
+
+/**
+ * \function igraph_es_copy
+ * \brief Creates a copy of an edge selector.
+ * \param src The selector being copied.
+ * \param dest An uninitialized selector that will contain the copy.
+ * \sa \ref igraph_es_destroy()
+ */
+int igraph_es_copy(igraph_es_t* dest, const igraph_es_t* src) {
+    memcpy(dest, src, sizeof(igraph_es_t));
+    switch (dest->type) {
+    case IGRAPH_ES_VECTOR:
+        dest->data.vecptr = IGRAPH_CALLOC(1, igraph_vector_t);
+        if (!dest->data.vecptr) {
+            IGRAPH_ERROR("Cannot copy edge selector", IGRAPH_ENOMEM);
+        }
+        IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*)dest->data.vecptr,
+                                        (igraph_vector_t*)src->data.vecptr));
+        break;
+    case IGRAPH_ES_PATH:
+    case IGRAPH_ES_PAIRS:
+    case IGRAPH_ES_MULTIPAIRS:
+        dest->data.path.ptr = IGRAPH_CALLOC(1, igraph_vector_t);
+        if (!dest->data.path.ptr) {
+            IGRAPH_ERROR("Cannot copy edge selector", IGRAPH_ENOMEM);
+        }
+        IGRAPH_CHECK(igraph_vector_copy((igraph_vector_t*)dest->data.path.ptr,
+                                        (igraph_vector_t*)src->data.path.ptr));
+        break;
+    }
     return 0;
 }
 
-/* not 'static' because used in igraph_all_st_cuts.c test program */
-int igraph_i_all_st_cuts_pivot(const igraph_t *graph,
-                               const igraph_marked_queue_t *S,
-                               const igraph_estack_t *T,
-                               long int source,
-                               long int target,
-                               long int *v,
-                               igraph_vector_t *Isv,
-                               void *arg) {
+/**
+ * \function igraph_es_as_vector
+ * \brief Transform edge selector into vector.
+ *
+ * </para><para>
+ * Call this function on an edge selector to transform it into a vector.
+ * This is only implemented for sequence and vector selectors. If the
+ * edges do not exist in the graph, this will result in an error.
+ *
+ * \param graph Pointer to a graph to check if the edges in the selector exist.
+ * \param es An edge selector object.
+ * \param v Pointer to initialized vector. The result will be stored here.
+ *
+ * Time complexity: O(n), the number of edges in the selector.
+ */
+int igraph_es_as_vector(const igraph_t *graph, igraph_es_t es,
+                        igraph_vector_t *v) {
+    igraph_eit_t eit;
+
+    IGRAPH_CHECK(igraph_eit_create(graph, es, &eit));
+    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
+    IGRAPH_CHECK(igraph_eit_as_vector(&eit, v));
 
-    long int no_of_nodes = igraph_vcount(graph);
-    igraph_t Sbar;
-    igraph_vector_t Sbar_map, Sbar_invmap;
-    igraph_vector_t keep;
-    igraph_t domtree;
-    igraph_vector_t leftout;
-    long int i, nomin, n;
-    long int root;
-    igraph_vector_t M;
-    igraph_vector_bool_t GammaS;
-    igraph_vector_t Nuv;
-    igraph_vector_t Isv_min;
-    igraph_vector_t GammaS_vec;
-    long int Sbar_size;
-
-    IGRAPH_UNUSED(arg);
-
-    /* We need to create the graph induced by Sbar */
-    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_map, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_invmap, 0);
-
-    IGRAPH_VECTOR_INIT_FINALLY(&keep, 0);
-    for (i = 0; i < no_of_nodes; i++) {
-        if (!igraph_marked_queue_iselement(S, i)) {
-            IGRAPH_CHECK(igraph_vector_push_back(&keep, i));
-        }
-    }
-    Sbar_size = igraph_vector_size(&keep);
-
-    IGRAPH_CHECK(igraph_induced_subgraph_map(graph, &Sbar,
-                 igraph_vss_vector(&keep),
-                 IGRAPH_SUBGRAPH_AUTO,
-                 /* map= */ &Sbar_map,
-                 /* invmap= */ &Sbar_invmap));
-    igraph_vector_destroy(&keep);
+    igraph_eit_destroy(&eit);
     IGRAPH_FINALLY_CLEAN(1);
-    IGRAPH_FINALLY(igraph_destroy, &Sbar);
-
-    root = (long int) VECTOR(Sbar_map)[target] - 1;
+    return 0;
+}
 
-    /* -------------------------------------------------------------*/
-    /* Construct the dominator tree of Sbar */
+/**
+ * \function igraph_es_type
+ * \brief Returns the type of the edge selector.
+ */
+int igraph_es_type(const igraph_es_t *es) {
+    return es->type;
+}
 
-    IGRAPH_VECTOR_INIT_FINALLY(&leftout, 0);
-    IGRAPH_CHECK(igraph_dominator_tree(&Sbar, (igraph_integer_t) root,
-                                       /*dom=*/ 0, &domtree,
-                                       &leftout, IGRAPH_IN));
-    IGRAPH_FINALLY(igraph_destroy, &domtree);
-
-    /* -------------------------------------------------------------*/
-    /* Identify the set M of minimal elements of Gamma(S) with respect
-       to the dominator relation. */
-
-    /* First we create GammaS */
-    /* TODO: use the adjacency list, instead of neighbors() */
-    IGRAPH_CHECK(igraph_vector_bool_init(&GammaS, no_of_nodes));
-    IGRAPH_FINALLY(igraph_vector_bool_destroy, &GammaS);
-    if (igraph_marked_queue_size(S) == 0) {
-        VECTOR(GammaS)[(long int) VECTOR(Sbar_map)[source] - 1] = 1;
-    } else {
-        for (i = 0; i < no_of_nodes; i++) {
-            if (igraph_marked_queue_iselement(S, i)) {
-                igraph_vector_t neis;
-                long int j;
-                IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
-                IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) i,
-                                              IGRAPH_OUT));
-                n = igraph_vector_size(&neis);
-                for (j = 0; j < n; j++) {
-                    long int nei = (long int) VECTOR(neis)[j];
-                    if (!igraph_marked_queue_iselement(S, nei)) {
-                        VECTOR(GammaS)[nei] = 1;
-                    }
-                }
-                igraph_vector_destroy(&neis);
-                IGRAPH_FINALLY_CLEAN(1);
-            }
-        }
-    }
+static int igraph_i_es_pairs_size(const igraph_t *graph,
+                                  const igraph_es_t *es, igraph_integer_t *result);
+static int igraph_i_es_path_size(const igraph_t *graph,
+                                 const igraph_es_t *es, igraph_integer_t *result);
+static int igraph_i_es_multipairs_size(const igraph_t *graph,
+                                       const igraph_es_t *es, igraph_integer_t *result);
 
-    /* Relabel left out vertices (set K in Provan & Shier) to
-       correspond to node labelling of graph instead of SBar.
-       At the same time ensure that GammaS is a proper subset of
-       L, where L are the nodes in the dominator tree. */
-    n = igraph_vector_size(&leftout);
-    for (i = 0; i < n; i++) {
-        VECTOR(leftout)[i] = VECTOR(Sbar_invmap)[(long int)VECTOR(leftout)[i]];
-        VECTOR(GammaS)[(long int)VECTOR(leftout)[i]] = 0;
-    }
+/**
+ * \function igraph_es_size
+ * \brief Returns the size of the edge selector.
+ *
+ * The size of the edge selector is the number of edges it will
+ * yield when it is iterated over.
+ *
+ * \param graph The graph over which we will iterate.
+ * \param result The result will be returned here.
+ */
+int igraph_es_size(const igraph_t *graph, const igraph_es_t *es,
+                   igraph_integer_t *result) {
+    igraph_vector_t v;
+
+    switch (es->type) {
+    case IGRAPH_ES_ALL:
+        *result = igraph_ecount(graph);
+        return 0;
 
-    IGRAPH_VECTOR_INIT_FINALLY(&M, 0);
-    if (igraph_ecount(&domtree) > 0) {
-        IGRAPH_CHECK(igraph_i_all_st_cuts_minimal(graph, &domtree, root, S,
-                     &GammaS, &Sbar_invmap, &M));
-    }
-
-    igraph_vector_clear(Isv);
-    IGRAPH_VECTOR_INIT_FINALLY(&Nuv, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&Isv_min, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&GammaS_vec, 0);
-    for (i = 0; i < no_of_nodes; i++) {
-        if (VECTOR(GammaS)[i]) {
-            IGRAPH_CHECK(igraph_vector_push_back(&GammaS_vec, i));
-        }
-    }
+    case IGRAPH_ES_ALLFROM:
+        *result = igraph_ecount(graph);
+        return 0;
 
-    nomin = igraph_vector_size(&M);
-    for (i = 0; i < nomin; i++) {
-        /* -------------------------------------------------------------*/
-        /* For each v in M find the set Nu(v)=dom(Sbar, v)-K
-           Nu(v) contains all vertices that are dominated by v, for every
-           v, this is a subtree of the dominator tree, rooted at v. The
-           different subtrees are disjoint. */
-        long int min = (long int) VECTOR(Sbar_map)[(long int) VECTOR(M)[i] ] - 1;
-        long int nuvsize, isvlen, j;
-        IGRAPH_CHECK(igraph_dfs(&domtree, (igraph_integer_t) min, IGRAPH_IN,
-                                /*unreachable=*/ 0, /*order=*/ &Nuv,
-                                /*order_out=*/ 0, /*father=*/ 0, /*dist=*/ 0,
-                                /*in_callback=*/ 0, /*out_callback=*/ 0,
-                                /*extra=*/ 0));
-        /* Remove the NAN values from the end of the vector */
-        for (nuvsize = 0; nuvsize < Sbar_size; nuvsize++) {
-            igraph_real_t t = VECTOR(Nuv)[nuvsize];
-            if (IGRAPH_FINITE(t)) {
-                VECTOR(Nuv)[nuvsize] = VECTOR(Sbar_invmap)[(long int) t];
-            } else {
-                break;
-            }
-        }
-        igraph_vector_resize(&Nuv, nuvsize);
+    case IGRAPH_ES_ALLTO:
+        *result = igraph_ecount(graph);
+        return 0;
 
-        /* -------------------------------------------------------------*/
-        /* By a BFS search of <Nu(v)> determine I(S,v)-K.
-           I(S,v) contains all vertices that are in Nu(v) and that are
-           reachable from Gamma(S) via a path in Nu(v). */
-        IGRAPH_CHECK(igraph_bfs(graph, /*root=*/ -1, /*roots=*/ &GammaS_vec,
-                                /*mode=*/ IGRAPH_OUT, /*unreachable=*/ 0,
-                                /*restricted=*/ &Nuv,
-                                /*order=*/ &Isv_min, /*rank=*/ 0,
-                                /*father=*/ 0, /*pred=*/ 0, /*succ=*/ 0,
-                                /*dist=*/ 0, /*callback=*/ 0, /*extra=*/ 0));
-        for (isvlen = 0; isvlen < no_of_nodes; isvlen++) {
-            if (!IGRAPH_FINITE(VECTOR(Isv_min)[isvlen])) {
-                break;
-            }
-        }
-        igraph_vector_resize(&Isv_min, isvlen);
+    case IGRAPH_ES_INCIDENT:
+        IGRAPH_VECTOR_INIT_FINALLY(&v, 0);
+        IGRAPH_CHECK(igraph_incident(graph, &v,
+                                     es->data.incident.vid, es->data.incident.mode));
+        *result = (igraph_integer_t) igraph_vector_size(&v);
+        igraph_vector_destroy(&v);
+        IGRAPH_FINALLY_CLEAN(1);
+        return 0;
 
-        /* -------------------------------------------------------------*/
-        /* For each c in M check whether Isv-K is included in Tbar. If
-           such a v is found, compute Isv={x|v[Nu(v) U K]x} and return v and
-           Isv; otherwise return Isv={}. */
-        for (j = 0; j < isvlen; j++) {
-            long int u = (long int) VECTOR(Isv_min)[j];
-            if (igraph_estack_iselement(T, u) || u == target) {
-                break;
-            }
-        }
-        /* We might have found one */
-        if (j == isvlen) {
-            *v = (long int) VECTOR(M)[i];
-            /* Calculate real Isv */
-            IGRAPH_CHECK(igraph_vector_append(&Nuv, &leftout));
-            IGRAPH_CHECK(igraph_bfs(graph, /*root=*/ (igraph_integer_t) *v,
-                                    /*roots=*/ 0, /*mode=*/ IGRAPH_OUT,
-                                    /*unreachable=*/ 0, /*restricted=*/ &Nuv,
-                                    /*order=*/ &Isv_min, /*rank=*/ 0,
-                                    /*father=*/ 0, /*pred=*/ 0, /*succ=*/ 0,
-                                    /*dist=*/ 0, /*callback=*/ 0, /*extra=*/ 0));
-            for (isvlen = 0; isvlen < no_of_nodes; isvlen++) {
-                if (!IGRAPH_FINITE(VECTOR(Isv_min)[isvlen])) {
-                    break;
-                }
-            }
-            igraph_vector_resize(&Isv_min, isvlen);
-            igraph_vector_update(Isv, &Isv_min);
+    case IGRAPH_ES_NONE:
+        *result = 0;
+        return 0;
 
-            break;
+    case IGRAPH_ES_1:
+        if (es->data.eid < igraph_ecount(graph) && es->data.eid >= 0) {
+            *result = 1;
+        } else {
+            *result = 0;
         }
-    }
+        return 0;
 
-    igraph_vector_destroy(&GammaS_vec);
-    igraph_vector_destroy(&Isv_min);
-    igraph_vector_destroy(&Nuv);
-    IGRAPH_FINALLY_CLEAN(3);
-
-    igraph_vector_destroy(&M);
-    igraph_vector_bool_destroy(&GammaS);
-    igraph_destroy(&domtree);
-    igraph_vector_destroy(&leftout);
-    igraph_destroy(&Sbar);
-    igraph_vector_destroy(&Sbar_map);
-    igraph_vector_destroy(&Sbar_invmap);
-    IGRAPH_FINALLY_CLEAN(7);
+    case IGRAPH_ES_VECTOR:
+    case IGRAPH_ES_VECTORPTR:
+        *result = (igraph_integer_t) igraph_vector_size((igraph_vector_t*)es->data.vecptr);
+        return 0;
 
-    return 0;
-}
+    case IGRAPH_ES_SEQ:
+        *result = es->data.seq.to - es->data.seq.from;
+        return 0;
 
-/* TODO: This is a temporary recursive version, without proper error
-   handling */
-
-int igraph_provan_shier_list(const igraph_t *graph,
-                             igraph_marked_queue_t *S,
-                             igraph_estack_t *T,
-                             long int source,
-                             long int target,
-                             igraph_vector_ptr_t *result,
-                             igraph_provan_shier_pivot_t *pivot,
-                             void *pivot_arg) {
+    case IGRAPH_ES_PAIRS:
+        IGRAPH_CHECK(igraph_i_es_pairs_size(graph, es, result));
+        return 0;
 
-    long int no_of_nodes = igraph_vcount(graph);
-    igraph_vector_t Isv;
-    long int v = 0;
-    long int i, n;
-
-    igraph_vector_init(&Isv, 0);
-
-    pivot(graph, S, T, source, target, &v, &Isv, pivot_arg);
-    if (igraph_vector_size(&Isv) == 0) {
-        if (igraph_marked_queue_size(S) != 0 &&
-            igraph_marked_queue_size(S) != no_of_nodes) {
-            igraph_vector_t *vec = IGRAPH_CALLOC(1, igraph_vector_t);
-            igraph_vector_init(vec, igraph_marked_queue_size(S));
-            igraph_marked_queue_as_vector(S, vec);
-            IGRAPH_CHECK(igraph_vector_ptr_push_back(result, vec));
-        }
-    } else {
-        /* Put v into T */
-        igraph_estack_push(T, v);
+    case IGRAPH_ES_PATH:
+        IGRAPH_CHECK(igraph_i_es_path_size(graph, es, result));
+        return 0;
 
-        /* Go down left in the search tree */
-        igraph_provan_shier_list(graph, S, T, source, target,
-                                 result, pivot, pivot_arg);
-
-        /* Take out v from T */
-        igraph_estack_pop(T);
-
-        /* Add Isv to S */
-        igraph_marked_queue_start_batch(S);
-        n = igraph_vector_size(&Isv);
-        for (i = 0; i < n; i++) {
-            if (!igraph_marked_queue_iselement(S, (long int) VECTOR(Isv)[i])) {
-                igraph_marked_queue_push(S, (long int) VECTOR(Isv)[i]);
-            }
-        }
+    case IGRAPH_ES_MULTIPAIRS:
+        IGRAPH_CHECK(igraph_i_es_multipairs_size(graph, es, result));
+        return 0;
 
-        /* Go down right in the search tree */
+    default:
+        IGRAPH_ERROR("Cannot calculate selector length, invalid selector type",
+                     IGRAPH_EINVAL);
+    }
+}
 
-        igraph_provan_shier_list(graph, S, T, source, target,
-                                 result, pivot, pivot_arg);
+static int igraph_i_es_pairs_size(const igraph_t *graph,
+                                  const igraph_es_t *es, igraph_integer_t *result) {
+    long int n = igraph_vector_size(es->data.path.ptr);
+    long int no_of_nodes = igraph_vcount(graph);
+    long int i;
 
-        /* Take out Isv from S */
-        igraph_marked_queue_pop_back_batch(S);
+    if (n % 2 != 0) {
+        IGRAPH_ERROR("Cannot calculate edge selector length from odd number of vertices",
+                     IGRAPH_EINVAL);
+    }
+    if (!igraph_vector_isininterval(es->data.path.ptr, 0, no_of_nodes - 1)) {
+        IGRAPH_ERROR("Cannot calculate edge selector length", IGRAPH_EINVVID);
     }
 
-    igraph_vector_destroy(&Isv);
+    *result = (igraph_integer_t) (n / 2);
+    /* Check for the existence of all edges */
+    for (i = 0; i < *result; i++) {
+        long int from = (long int) VECTOR(*es->data.path.ptr)[2 * i];
+        long int to = (long int) VECTOR(*es->data.path.ptr)[2 * i + 1];
+        igraph_integer_t eid;
+        IGRAPH_CHECK(igraph_get_eid(graph, &eid, (igraph_integer_t) from,
+                                    (igraph_integer_t) to, es->data.path.mode,
+                                    /*error=*/ 1));
+    }
 
     return 0;
 }
 
-/**
- * \function igraph_all_st_cuts
- * List all edge-cuts between two vertices in a directed graph
- *
- * This function lists all edge-cuts between a source and a target
- * vertex. Every cut is listed exactly once. The implemented algorithm
- * is described in JS Provan and DR Shier: A Paradigm for listing
- * (s,t)-cuts in graphs, Algorithmica 15, 351--372, 1996.
- *
- * \param graph The input graph, is must be directed.
- * \param cuts An initialized pointer vector, the cuts are stored
- *        here. It is a list of pointers to igraph_vector_t
- *        objects. Each vector will contain the ids of the edges in
- *        the cut. This argument is ignored if it is a null pointer.
- *        To free all memory allocated for \c cuts, you need call
- *        \ref igraph_vector_destroy() and then \ref igraph_free() on
- *        each element, before destroying the pointer vector itself.
- * \param partition1s An initialized pointer vector, the list of
- *        vertex sets, generating the actual edge cuts, are stored
- *        here. Each vector contains a set of vertex ids. If X is such
- *        a set, then all edges going from X to the complement of X
- *        form an (s,t) edge-cut in the graph. This argument is
- *        ignored if it is a null pointer.
- *        To free all memory allocated for \c partition1s, you need call
- *        \ref igraph_vector_destroy() and then \ref igraph_free() on
- *        each element, before destroying the pointer vector itself.
- * \param source The id of the source vertex.
- * \param target The id of the target vertex.
- * \return Error code.
- *
- * Time complexity: O(n(|V|+|E|)), where |V| is the number of
- * vertices, |E| is the number of edges, and n is the number of cuts.
- */
+static int igraph_i_es_path_size(const igraph_t *graph,
+                                 const igraph_es_t *es, igraph_integer_t *result) {
+    long int n = igraph_vector_size(es->data.path.ptr);
+    long int no_of_nodes = igraph_vcount(graph);
+    long int i;
 
-int igraph_all_st_cuts(const igraph_t *graph,
-                       igraph_vector_ptr_t *cuts,
-                       igraph_vector_ptr_t *partition1s,
-                       igraph_integer_t source,
-                       igraph_integer_t target) {
+    if (!igraph_vector_isininterval(es->data.path.ptr, 0, no_of_nodes - 1)) {
+        IGRAPH_ERROR("Cannot calculate selector length", IGRAPH_EINVVID);
+    }
 
-    /* S is a special stack, in which elements are pushed in batches.
-       It is then possible to remove the whole batch in one step.
+    if (n <= 1) {
+        *result = 0;
+    } else {
+        *result = (igraph_integer_t) (n - 1);
+    }
+    for (i = 0; i < *result; i++) {
+        long int from = (long int) VECTOR(*es->data.path.ptr)[i];
+        long int to = (long int) VECTOR(*es->data.path.ptr)[i + 1];
+        igraph_integer_t eid;
+        IGRAPH_CHECK(igraph_get_eid(graph, &eid, (igraph_integer_t) from,
+                                    (igraph_integer_t) to, es->data.path.mode,
+                                    /*error=*/ 1));
+    }
 
-       T is a stack with an is-element operation.
-       Every element is included at most once.
-    */
+    return 0;
+}
 
+static int igraph_i_es_multipairs_size(const igraph_t *graph,
+                                       const igraph_es_t *es, igraph_integer_t *result) {
+    IGRAPH_UNUSED(graph); IGRAPH_UNUSED(es); IGRAPH_UNUSED(result);
+    IGRAPH_ERROR("Cannot calculate edge selector length", IGRAPH_UNIMPLEMENTED);
+}
+
+/**************************************************/
+
+static int igraph_i_eit_create_allfromto(const igraph_t *graph,
+                                         igraph_eit_t *eit,
+                                         igraph_neimode_t mode);
+static int igraph_i_eit_pairs(const igraph_t *graph,
+                              igraph_es_t es, igraph_eit_t *eit);
+static int igraph_i_eit_multipairs(const igraph_t *graph,
+                                   igraph_es_t es, igraph_eit_t *eit);
+static int igraph_i_eit_path(const igraph_t *graph,
+                             igraph_es_t es, igraph_eit_t *eit);
+
+static int igraph_i_eit_create_allfromto(const igraph_t *graph,
+                                         igraph_eit_t *eit,
+                                         igraph_neimode_t mode) {
+    igraph_vector_t *vec;
     long int no_of_nodes = igraph_vcount(graph);
     long int no_of_edges = igraph_ecount(graph);
-    igraph_marked_queue_t S;
-    igraph_estack_t T;
-    igraph_vector_ptr_t *mypartition1s = partition1s, vpartition1s;
-    long int i, nocuts;
-
-    if (!igraph_is_directed(graph)) {
-        IGRAPH_ERROR("Listing all s-t cuts only implemented for "
-                     "directed graphs", IGRAPH_UNIMPLEMENTED);
-    }
+    long int i;
+
+    vec = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (vec == 0) {
+        IGRAPH_ERROR("Cannot create edge iterator", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, vec);
+    IGRAPH_VECTOR_INIT_FINALLY(vec, 0);
+    IGRAPH_CHECK(igraph_vector_reserve(vec, no_of_edges));
+
+    if (igraph_is_directed(graph)) {
+        igraph_vector_t adj;
+        IGRAPH_VECTOR_INIT_FINALLY(&adj, 0);
+        for (i = 0; i < no_of_nodes; i++) {
+            igraph_incident(graph, &adj, (igraph_integer_t) i, mode);
+            igraph_vector_append(vec, &adj);
+        }
+        igraph_vector_destroy(&adj);
+        IGRAPH_FINALLY_CLEAN(1);
 
-    if (!partition1s) {
-        mypartition1s = &vpartition1s;
-        IGRAPH_CHECK(igraph_vector_ptr_init(mypartition1s, 0));
-        IGRAPH_FINALLY(igraph_vector_ptr_destroy, mypartition1s);
     } else {
-        igraph_vector_ptr_clear(mypartition1s);
-    }
 
-    IGRAPH_CHECK(igraph_marked_queue_init(&S, no_of_nodes));
-    IGRAPH_FINALLY(igraph_marked_queue_destroy, &S);
-    IGRAPH_CHECK(igraph_estack_init(&T, no_of_nodes, 0));
-    IGRAPH_FINALLY(igraph_estack_destroy, &T);
-
-    if (cuts)        {
-        igraph_vector_ptr_clear(cuts);
-    }
-
-    /* We call it with S={}, T={} */
-    IGRAPH_CHECK(igraph_provan_shier_list(graph, &S, &T,
-                                          source, target, mypartition1s,
-                                          igraph_i_all_st_cuts_pivot,
-                                          /*pivot_arg=*/ 0));
-
-    nocuts = igraph_vector_ptr_size(mypartition1s);
-
-    if (cuts) {
-        igraph_vector_long_t inS;
-        IGRAPH_CHECK(igraph_vector_long_init(&inS, no_of_nodes));
-        IGRAPH_FINALLY(igraph_vector_long_destroy, &inS);
-        IGRAPH_CHECK(igraph_vector_ptr_resize(cuts, nocuts));
-        for (i = 0; i < nocuts; i++) {
-            igraph_vector_t *cut;
-            igraph_vector_t *part = VECTOR(*mypartition1s)[i];
-            long int cutsize = 0;
-            long int j, partlen = igraph_vector_size(part);
-            /* Mark elements */
-            for (j = 0; j < partlen; j++) {
-                long int v = (long int) VECTOR(*part)[j];
-                VECTOR(inS)[v] = i + 1;
-            }
-            /* Check how many edges */
-            for (j = 0; j < no_of_edges; j++) {
-                long int from = IGRAPH_FROM(graph, j);
-                long int to = IGRAPH_TO(graph, j);
-                long int pfrom = VECTOR(inS)[from];
-                long int pto = VECTOR(inS)[to];
-                if (pfrom == i + 1 && pto != i + 1) {
-                    cutsize++;
-                }
-            }
-            /* Add the edges */
-            cut = IGRAPH_CALLOC(1, igraph_vector_t);
-            if (!cut) {
-                IGRAPH_ERROR("Cannot calculate s-t cuts", IGRAPH_ENOMEM);
-            }
-            IGRAPH_VECTOR_INIT_FINALLY(cut, cutsize);
-            cutsize = 0;
-            for (j = 0; j < no_of_edges; j++) {
-                long int from = IGRAPH_FROM(graph, j);
-                long int to = IGRAPH_TO(graph, j);
-                long int pfrom = VECTOR(inS)[from];
-                long int pto = VECTOR(inS)[to];
-                if ((pfrom == i + 1 && pto != i + 1)) {
-                    VECTOR(*cut)[cutsize++] = j;
+        igraph_vector_t adj;
+        igraph_bool_t *added;
+        long int j;
+        IGRAPH_VECTOR_INIT_FINALLY(&adj, 0);
+        added = IGRAPH_CALLOC(no_of_edges, igraph_bool_t);
+        if (added == 0) {
+            IGRAPH_ERROR("Cannot create edge iterator", IGRAPH_ENOMEM);
+        }
+        IGRAPH_FINALLY(igraph_free, added);
+        for (i = 0; i < no_of_nodes; i++) {
+            igraph_incident(graph, &adj, (igraph_integer_t) i, IGRAPH_ALL);
+            for (j = 0; j < igraph_vector_size(&adj); j++) {
+                if (!added[ (long int)VECTOR(adj)[j] ]) {
+                    igraph_vector_push_back(vec, VECTOR(adj)[j]);
+                    added[ (long int)VECTOR(adj)[j] ] += 1;
                 }
             }
-            VECTOR(*cuts)[i] = cut;
-            IGRAPH_FINALLY_CLEAN(1);
         }
-
-        igraph_vector_long_destroy(&inS);
-        IGRAPH_FINALLY_CLEAN(1);
+        igraph_vector_destroy(&adj);
+        IGRAPH_FREE(added);
+        IGRAPH_FINALLY_CLEAN(2);
     }
 
-    igraph_estack_destroy(&T);
-    igraph_marked_queue_destroy(&S);
-    IGRAPH_FINALLY_CLEAN(2);
-
-    if (!partition1s) {
-        for (i = 0; i < nocuts; i++) {
-            igraph_vector_t *cut = VECTOR(*mypartition1s)[i];
-            igraph_vector_destroy(cut);
-            igraph_free(cut);
-            VECTOR(*mypartition1s)[i] = 0;
-        }
-        igraph_vector_ptr_destroy(mypartition1s);
-        IGRAPH_FINALLY_CLEAN(1);
-    }
+    eit->type = IGRAPH_EIT_VECTOR;
+    eit->pos = 0;
+    eit->start = 0;
+    eit->vec = vec;
+    eit->end = igraph_vector_size(eit->vec);
 
+    IGRAPH_FINALLY_CLEAN(2);
     return 0;
 }
 
-/* We need to find the minimal active elements of Sbar. I.e. all
-   active Sbar elements 'v', s.t. there is no other 'w' active Sbar
-   element from which 'v' is reachable. (Not necessarily through
-   active vertices.)
-
-   We calculate the in-degree of all vertices in Sbar first. Then we
-   look at the vertices with zero in-degree. If these are active,
-   then they are minimal. If they are are not active, then we remove
-   them from the graph, and check whether they resulted in more
-   zero-indegree vertices.
-*/
+static int igraph_i_eit_pairs(const igraph_t *graph,
+                              igraph_es_t es, igraph_eit_t *eit) {
+    long int n = igraph_vector_size(es.data.path.ptr);
+    long int no_of_nodes = igraph_vcount(graph);
+    long int i;
 
-static int igraph_i_all_st_mincuts_minimal(const igraph_t *Sbar,
-                                           const igraph_vector_bool_t *active,
-                                           const igraph_vector_t *invmap,
-                                           igraph_vector_t *minimal) {
-
-    long int no_of_nodes = igraph_vcount(Sbar);
-    igraph_vector_t indeg;
-    long int i, minsize;
-    igraph_vector_t neis;
-
-    IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&indeg, no_of_nodes);
-
-    IGRAPH_CHECK(igraph_degree(Sbar, &indeg, igraph_vss_all(),
-                               IGRAPH_IN, /*loops=*/ 1));
-
-#define ACTIVE(x) (VECTOR(*active)[(long int)VECTOR(*invmap)[(x)]])
-#define ZEROIN(x) (VECTOR(indeg)[(x)]==0)
-
-    for (i = 0; i < no_of_nodes; i++) {
-        if (!ACTIVE(i)) {
-            long int j, n;
-            IGRAPH_CHECK(igraph_neighbors(Sbar, &neis, (igraph_integer_t) i,
-                                          IGRAPH_OUT));
-            n = igraph_vector_size(&neis);
-            for (j = 0; j < n; j++) {
-                long int nei = (long int) VECTOR(neis)[j];
-                VECTOR(indeg)[nei] -= 1;
-            }
-        }
+    if (n % 2 != 0) {
+        IGRAPH_ERROR("Cannot create edge iterator from odd number of vertices",
+                     IGRAPH_EINVAL);
+    }
+    if (!igraph_vector_isininterval(es.data.path.ptr, 0, no_of_nodes - 1)) {
+        IGRAPH_ERROR("Cannot create edge iterator", IGRAPH_EINVVID);
     }
 
-    for (minsize = 0, i = 0; i < no_of_nodes; i++) {
-        if (ACTIVE(i) && ZEROIN(i)) {
-            minsize++;
-        }
+    eit->type = IGRAPH_EIT_VECTOR;
+    eit->pos = 0;
+    eit->start = 0;
+    eit->end = n / 2;
+    eit->vec = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (eit->vec == 0) {
+        IGRAPH_ERROR("Cannot create edge iterator", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)eit->vec);
+    IGRAPH_VECTOR_INIT_FINALLY((igraph_vector_t*)eit->vec, n / 2);
+
+    for (i = 0; i < igraph_vector_size(eit->vec); i++) {
+        long int from = (long int) VECTOR(*es.data.path.ptr)[2 * i];
+        long int to = (long int) VECTOR(*es.data.path.ptr)[2 * i + 1];
+        igraph_integer_t eid;
+        IGRAPH_CHECK(igraph_get_eid(graph, &eid, (igraph_integer_t) from,
+                                    (igraph_integer_t) to, es.data.path.mode,
+                                    /*error=*/ 1));
+        VECTOR(*eit->vec)[i] = eid;
     }
 
-    IGRAPH_CHECK(igraph_vector_resize(minimal, minsize));
+    IGRAPH_FINALLY_CLEAN(2);
+    return 0;
+}
 
-    for (minsize = 0, i = 0; i < no_of_nodes; i++) {
-        if (ACTIVE(i) && ZEROIN(i)) {
-            VECTOR(*minimal)[minsize++] = i;
-        }
+static int igraph_i_eit_multipairs(const igraph_t *graph,
+                                   igraph_es_t es, igraph_eit_t *eit) {
+    long int n = igraph_vector_size(es.data.path.ptr);
+    long int no_of_nodes = igraph_vcount(graph);
+
+    if (n % 2 != 0) {
+        IGRAPH_ERROR("Cannot create edge iterator from odd number of vertices",
+                     IGRAPH_EINVAL);
+    }
+    if (!igraph_vector_isininterval(es.data.path.ptr, 0, no_of_nodes - 1)) {
+        IGRAPH_ERROR("Cannot create edge iterator", IGRAPH_EINVVID);
     }
 
-#undef ACTIVE
-#undef ZEROIN
+    eit->type = IGRAPH_EIT_VECTOR;
+    eit->pos = 0;
+    eit->start = 0;
+    eit->end = n / 2;
+    eit->vec = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (eit->vec == 0) {
+        IGRAPH_ERROR("Cannot create edge iterator", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)eit->vec);
+    IGRAPH_VECTOR_INIT_FINALLY((igraph_vector_t*)eit->vec, n / 2);
+
+    IGRAPH_CHECK(igraph_get_eids_multi(graph, (igraph_vector_t *) eit->vec,
+                                       /*pairs=*/ es.data.path.ptr, /*path=*/ 0,
+                                       es.data.path.mode, /*error=*/ 1));
 
-    igraph_vector_destroy(&indeg);
-    igraph_vector_destroy(&neis);
     IGRAPH_FINALLY_CLEAN(2);
-
     return 0;
 }
 
-typedef struct igraph_i_all_st_mincuts_data_t {
-    const igraph_vector_bool_t *active;
-} igraph_i_all_st_mincuts_data_t;
-
-static int igraph_i_all_st_mincuts_pivot(const igraph_t *graph,
-                                         const igraph_marked_queue_t *S,
-                                         const igraph_estack_t *T,
-                                         long int source,
-                                         long int target,
-                                         long int *v,
-                                         igraph_vector_t *Isv,
-                                         void *arg) {
-
-    igraph_i_all_st_mincuts_data_t *data = arg;
-    const igraph_vector_bool_t *active = data->active;
-
+static int igraph_i_eit_path(const igraph_t *graph,
+                             igraph_es_t es, igraph_eit_t *eit) {
+    long int n = igraph_vector_size(es.data.path.ptr);
     long int no_of_nodes = igraph_vcount(graph);
-    long int i, j;
-    igraph_vector_t Sbar_map, Sbar_invmap;
-    igraph_vector_t keep;
-    igraph_t Sbar;
-    igraph_vector_t M;
-    long int nomin;
+    long int i, len;
 
-    IGRAPH_UNUSED(source); IGRAPH_UNUSED(target);
-
-    if (igraph_marked_queue_size(S) == no_of_nodes) {
-        igraph_vector_clear(Isv);
-        return 0;
+    if (!igraph_vector_isininterval(es.data.path.ptr, 0, no_of_nodes - 1)) {
+        IGRAPH_ERROR("Cannot create edge iterator.", IGRAPH_EINVVID);
     }
 
-    /* Create the graph induced by Sbar */
-    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_map, 0);
-    IGRAPH_VECTOR_INIT_FINALLY(&Sbar_invmap, 0);
-
-    IGRAPH_VECTOR_INIT_FINALLY(&keep, 0);
-    for (i = 0; i < no_of_nodes; i++) {
-        if (!igraph_marked_queue_iselement(S, i)) {
-            IGRAPH_CHECK(igraph_vector_push_back(&keep, i));
-        }
+    if (n <= 1) {
+        len = 0;
+    } else {
+        len = n - 1;
     }
 
-    /* TODO: it is not even necessary to create Sbar explicitly, we
-       just need to find the M elements efficiently. See the
-       Provan-Shier paper for details. */
-    IGRAPH_CHECK(igraph_induced_subgraph_map(graph, &Sbar,
-                 igraph_vss_vector(&keep),
-                 IGRAPH_SUBGRAPH_AUTO,
-                 /* map= */ &Sbar_map,
-                 /* invmap= */ &Sbar_invmap));
-    IGRAPH_FINALLY(igraph_destroy, &Sbar);
-
-    /* ------------------------------------------------------------- */
-    /* Identify the set M of minimal elements that are active */
-    IGRAPH_VECTOR_INIT_FINALLY(&M, 0);
-    IGRAPH_CHECK(igraph_i_all_st_mincuts_minimal(&Sbar, active,
-                 &Sbar_invmap, &M));
-
-    /* ------------------------------------------------------------- */
-    /* Now find a minimal element that is not in T */
-    igraph_vector_clear(Isv);
-    nomin = igraph_vector_size(&M);
-    for (i = 0; i < nomin; i++) {
-        long int min = (long int) VECTOR(Sbar_invmap)[ (long int) VECTOR(M)[i] ];
-        if (min != target)
-            if (!igraph_estack_iselement(T, min)) {
-                break;
-            }
-    }
-    if (i != nomin) {
-        /* OK, we found a pivot element. I(S,v) contains all elements
-           that can reach the pivot element */
-        igraph_vector_t Isv_min;
-        IGRAPH_VECTOR_INIT_FINALLY(&Isv_min, 0);
-        *v = (long int) VECTOR(Sbar_invmap)[ (long int) VECTOR(M)[i] ];
-        /* TODO: restricted == keep ? */
-        IGRAPH_CHECK(igraph_bfs(graph, /*root=*/ (igraph_integer_t) *v,/*roots=*/ 0,
-                                /*mode=*/ IGRAPH_IN, /*unreachable=*/ 0,
-                                /*restricted=*/ &keep, /*order=*/ &Isv_min,
-                                /*rank=*/ 0, /*father=*/ 0, /*pred=*/ 0,
-                                /*succ=*/ 0, /*dist=*/ 0, /*callback=*/ 0,
-                                /*extra=*/ 0));
-        for (j = 0; j < no_of_nodes; j++) {
-            igraph_real_t u = VECTOR(Isv_min)[j];
-            if (!IGRAPH_FINITE(u)) {
-                break;
-            }
-            if (!igraph_estack_iselement(T, u)) {
-                IGRAPH_CHECK(igraph_vector_push_back(Isv, u));
-            }
-        }
-        igraph_vector_destroy(&Isv_min);
-        IGRAPH_FINALLY_CLEAN(1);
+    eit->type = IGRAPH_EIT_VECTOR;
+    eit->pos = 0;
+    eit->start = 0;
+    eit->end = len;
+    eit->vec = IGRAPH_CALLOC(1, igraph_vector_t);
+    if (eit->vec == 0) {
+        IGRAPH_ERROR("Cannot create edge iterator.", IGRAPH_ENOMEM);
+    }
+    IGRAPH_FINALLY(igraph_free, (igraph_vector_t*)eit->vec);
+
+    IGRAPH_VECTOR_INIT_FINALLY((igraph_vector_t *)eit->vec, len);
+
+    for (i = 0; i < len; i++) {
+        long int from = (long int) VECTOR(*es.data.path.ptr)[i];
+        long int to = (long int) VECTOR(*es.data.path.ptr)[i + 1];
+        igraph_integer_t eid;
+        IGRAPH_CHECK(igraph_get_eid(graph, &eid, (igraph_integer_t) from,
+                                    (igraph_integer_t) to, es.data.path.mode,
+                                    /*error=*/ 1));
+        VECTOR(*eit->vec)[i] = eid;
     }
 
-    igraph_vector_destroy(&M);
-    igraph_destroy(&Sbar);
-    igraph_vector_destroy(&keep);
-    igraph_vector_destroy(&Sbar_invmap);
-    igraph_vector_destroy(&Sbar_map);
-    IGRAPH_FINALLY_CLEAN(5);
-
+    IGRAPH_FINALLY_CLEAN(2);
     return 0;
 }
 
 /**
- * \function igraph_all_st_mincuts
- * All minimum s-t cuts of a directed graph
- *
- * This function lists all edge cuts between two vertices, in a directed graph,
- * with minimum total capacity. Possibly, multiple cuts may have the same total
- * capacity, although there is often only one minimum cut in weighted graphs.
- * It is recommended to supply integer-values capacities. Otherwise, not all
- * minimum cuts may be detected because of numerical roundoff errors.
- * The implemented algorithm is described in JS Provan and DR
- * Shier: A Paradigm for listing (s,t)-cuts in graphs, Algorithmica 15,
- * 351--372, 1996.
- *
- * \param graph The input graph, it must be directed.
- * \param value Pointer to a real number, the value of the minimum cut
- *        is stored here, unless it is a null pointer.
- * \param cuts An initialized pointer vector, the cuts are stored
- *        here. It is a list of pointers to igraph_vector_t
- *        objects. Each vector will contain the ids of the edges in
- *        the cut. This argument is ignored if it is a null pointer.
- *        To free all memory allocated for \c cuts, you need call
- *        \ref igraph_vector_destroy() and then \ref igraph_free() on
- *        each element, before destroying the pointer vector itself.
- * \param partition1s An initialized pointer vector, the list of
- *        vertex sets, generating the actual edge cuts, are stored
- *        here. Each vector contains a set of vertex ids. If X is such
- *        a set, then all edges going from X to the complement of X
- *        form an (s,t) edge-cut in the graph. This argument is
- *        ignored if it is a null pointer.
- * \param source The id of the source vertex.
- * \param target The id of the target vertex.
- * \param capacity Vector of edge capacities. All capacities must be
- *        strictly positive. If this is a null pointer, then all edges
- *        are assumed to have capacity one.
- * \return Error code.
- *
- * Time complexity: O(n(|V|+|E|))+O(F), where |V| is the number of
- * vertices, |E| is the number of edges, and n is the number of cuts;
- * O(F) is the time complexity of the maximum flow algorithm, see \ref
- * igraph_maxflow().
- *
- * \example examples/simple/igraph_all_st_mincuts.c
- */
-
-int igraph_all_st_mincuts(const igraph_t *graph, igraph_real_t *value,
-                          igraph_vector_ptr_t *cuts,
-                          igraph_vector_ptr_t *partition1s,
-                          igraph_integer_t source,
-                          igraph_integer_t target,
-                          const igraph_vector_t *capacity) {
+ * \function igraph_eit_create
+ * \brief Creates an edge iterator from an edge selector.
+ *
+ * </para><para>
+ * This function creates an edge iterator based on an edge selector
+ * and a graph.
+ *
+ * </para><para>
+ * The same edge selector can be used to create many edge iterators,
+ * also for different graphs.
+ *
+ * \param graph An \type igraph_t object for which the edge selector
+ *        will be instantiated.
+ * \param es The edge selector to instantiate.
+ * \param eit Pointer to an uninitialized edge iterator.
+ * \return Error code.
+ * \sa \ref igraph_eit_destroy()
+ *
+ * Time complexity: depends on the type of the edge selector. For edge
+ * selectors created by \ref igraph_es_all(), \ref igraph_es_none(),
+ * \ref igraph_es_1(), igraph_es_vector(), igraph_es_seq() it is
+ * O(1). For \ref igraph_es_incident() it is O(d) where d is the number of
+ * incident edges of the vertex.
+ */
 
-    long int no_of_nodes = igraph_vcount(graph);
-    long int no_of_edges = igraph_ecount(graph);
-    igraph_vector_t flow;
-    igraph_t residual;
-    igraph_vector_t NtoL;
-    long int newsource, newtarget;
-    igraph_marked_queue_t S;
-    igraph_estack_t T;
-    igraph_i_all_st_mincuts_data_t pivot_data;
-    igraph_vector_bool_t VE1bool;
-    igraph_vector_t VE1;
-    long int VE1size = 0;
-    long int i, nocuts;
-    igraph_integer_t proj_nodes;
-    igraph_vector_t revmap_ptr, revmap_next;
-    igraph_vector_ptr_t closedsets;
-    igraph_vector_ptr_t *mypartition1s = partition1s, vpartition1s;
-    igraph_maxflow_stats_t stats;
-
-    /* -------------------------------------------------------------------- */
-    /* Error checks */
-    if (!igraph_is_directed(graph)) {
-        IGRAPH_ERROR("S-t cuts can only be listed in directed graphs",
-                     IGRAPH_UNIMPLEMENTED);
-    }
-    if (source < 0 || source >= no_of_nodes) {
-        IGRAPH_ERROR("Invalid `source' vertex", IGRAPH_EINVAL);
-    }
-    if (target < 0 || target >= no_of_nodes) {
-        IGRAPH_ERROR("Invalid `target' vertex", IGRAPH_EINVAL);
-    }
-    if (source == target) {
-        IGRAPH_ERROR("`source' and 'target' are the same vertex", IGRAPH_EINVAL);
-    }
-    if (capacity != NULL && igraph_vector_min(capacity) <= 0)
-    {
-        IGRAPH_ERROR("Not all capacities are strictly positive.", IGRAPH_EINVAL);
-    }
-
-    if (!partition1s) {
-        mypartition1s = &vpartition1s;
-        IGRAPH_CHECK(igraph_vector_ptr_init(mypartition1s, 0));
-        IGRAPH_FINALLY(igraph_vector_ptr_destroy, mypartition1s);
-    }
-
-    /* -------------------------------------------------------------------- */
-    /* We need to calculate the maximum flow first */
-    IGRAPH_VECTOR_INIT_FINALLY(&flow, 0);
-    IGRAPH_CHECK(igraph_maxflow(graph, value, &flow, /*cut=*/ 0,
-                                /*partition1=*/ 0, /*partition2=*/ 0,
-                                /*source=*/ source, /*target=*/ target,
-                                capacity, &stats));
-
-    /* -------------------------------------------------------------------- */
-    /* Then we need the reverse residual graph */
-    IGRAPH_CHECK(igraph_reverse_residual_graph(graph, capacity, &residual,
-                 &flow));
-    IGRAPH_FINALLY(igraph_destroy, &residual);
-
-    /* -------------------------------------------------------------------- */
-    /* We shrink it to its strongly connected components */
-    IGRAPH_VECTOR_INIT_FINALLY(&NtoL, 0);
-    IGRAPH_CHECK(igraph_clusters(&residual, /*membership=*/ &NtoL,
-                                 /*csize=*/ 0, /*no=*/ &proj_nodes,
-                                 IGRAPH_STRONG));
-    IGRAPH_CHECK(igraph_contract_vertices(&residual, /*mapping=*/ &NtoL,
-                                          /*vertex_comb=*/ 0));
-    IGRAPH_CHECK(igraph_simplify(&residual, /*multiple=*/ 1, /*loops=*/ 1,
-                                 /*edge_comb=*/ 0));
-
-    newsource = (long int) VECTOR(NtoL)[(long int)source];
-    newtarget = (long int) VECTOR(NtoL)[(long int)target];
-
-    /* TODO: handle the newsource == newtarget case */
-
-    /* -------------------------------------------------------------------- */
-    /* Determine the active vertices in the projection */
-    IGRAPH_VECTOR_INIT_FINALLY(&VE1, 0);
-    IGRAPH_CHECK(igraph_vector_bool_init(&VE1bool, proj_nodes));
-    IGRAPH_FINALLY(igraph_vector_bool_destroy, &VE1bool);
-    for (i = 0; i < no_of_edges; i++) {
-        if (VECTOR(flow)[i] > 0) {
-            long int from = IGRAPH_FROM(graph, i);
-            long int to = IGRAPH_TO(graph, i);
-            long int pfrom = (long int) VECTOR(NtoL)[from];
-            long int pto = (long int) VECTOR(NtoL)[to];
-            if (!VECTOR(VE1bool)[pfrom]) {
-                VECTOR(VE1bool)[pfrom] = 1;
-                VE1size++;
-            }
-            if (!VECTOR(VE1bool)[pto]) {
-                VECTOR(VE1bool)[pto] = 1;
-                VE1size++;
-            }
-        }
-    }
-    IGRAPH_CHECK(igraph_vector_reserve(&VE1, VE1size));
-    for (i = 0; i < proj_nodes; i++) {
-        if (VECTOR(VE1bool)[i]) {
-            igraph_vector_push_back(&VE1, i);
-        }
+int igraph_eit_create(const igraph_t *graph,
+                      igraph_es_t es, igraph_eit_t *eit) {
+    switch (es.type) {
+    case IGRAPH_ES_ALL:
+        eit->type = IGRAPH_EIT_SEQ;
+        eit->pos = 0;
+        eit->start = 0;
+        eit->end = igraph_ecount(graph);
+        break;
+    case IGRAPH_ES_ALLFROM:
+        IGRAPH_CHECK(igraph_i_eit_create_allfromto(graph, eit, IGRAPH_OUT));
+        break;
+    case IGRAPH_ES_ALLTO:
+        IGRAPH_CHECK(igraph_i_eit_create_allfromto(graph, eit, IGRAPH_IN));
+        break;
+    case IGRAPH_ES_INCIDENT:
+        eit->type = IGRAPH_EIT_VECTOR;
+        eit->pos = 0;
+        eit->start = 0;
+        eit->vec = IGRAPH_CALLOC(1, igraph_vector_t);
+        if (eit->vec == 0) {
+            IGRAPH_ERROR("Cannot create iterator.", IGRAPH_ENOMEM);
+        }
+        IGRAPH_FINALLY(igraph_free, (igraph_vector_t*) eit->vec);
+        IGRAPH_VECTOR_INIT_FINALLY((igraph_vector_t*)eit->vec, 0);
+        IGRAPH_CHECK(igraph_incident(graph, (igraph_vector_t*)eit->vec,
+                                     es.data.incident.vid, es.data.incident.mode));
+        eit->end = igraph_vector_size(eit->vec);
+        IGRAPH_FINALLY_CLEAN(2);
+        break;
+    case IGRAPH_ES_NONE:
+        eit->type = IGRAPH_EIT_SEQ;
+        eit->pos = 0;
+        eit->start = 0;
+        eit->end = 0;
+        break;
+    case IGRAPH_ES_1:
+        eit->type = IGRAPH_EIT_SEQ;
+        eit->pos = es.data.eid;
+        eit->start = es.data.eid;
+        eit->end = es.data.eid + 1;
+        if (eit->pos >= igraph_ecount(graph)) {
+            IGRAPH_ERROR("Cannot create iterator, invalid edge id.", IGRAPH_EINVAL);
+        }
+        break;
+    case IGRAPH_ES_VECTOR:
+    case IGRAPH_ES_VECTORPTR:
+        eit->type = IGRAPH_EIT_VECTORPTR;
+        eit->pos = 0;
+        eit->start = 0;
+        eit->vec = es.data.vecptr;
+        eit->end = igraph_vector_size(eit->vec);
+        if (!igraph_vector_isininterval(eit->vec, 0, igraph_ecount(graph) - 1)) {
+            IGRAPH_ERROR("Cannot create iterator, invalid edge id.", IGRAPH_EINVAL);
+        }
+        break;
+    case IGRAPH_ES_SEQ:
+        eit->type = IGRAPH_EIT_SEQ;
+        eit->pos = es.data.seq.from;
+        eit->start = es.data.seq.from;
+        eit->end = es.data.seq.to;
+        if (eit->start < 0) {
+            IGRAPH_ERROR("Cannot create iterator, invalid edge id.", IGRAPH_EINVAL);
+        }
+        if (eit->end < 0) {
+            IGRAPH_ERROR("Cannot create iterator, invalid edge id.", IGRAPH_EINVAL);
+        }
+        if (eit->start >= igraph_ecount(graph)) {
+            IGRAPH_ERROR("Cannot create iterator, starting edge greater than number of edges.", IGRAPH_EINVAL);
+        }
+        break;
+    case IGRAPH_ES_PAIRS:
+        IGRAPH_CHECK(igraph_i_eit_pairs(graph, es, eit));
+        break;
+    case IGRAPH_ES_MULTIPAIRS:
+        IGRAPH_CHECK(igraph_i_eit_multipairs(graph, es, eit));
+        break;
+    case IGRAPH_ES_PATH:
+        IGRAPH_CHECK(igraph_i_eit_path(graph, es, eit));
+        break;
+    default:
+        IGRAPH_ERROR("Cannot create iterator, invalid selector.", IGRAPH_EINVAL);
+        break;
     }
+    return 0;
+}
 
-    if (cuts)        {
-        igraph_vector_ptr_clear(cuts);
-    }
-    if (partition1s) {
-        igraph_vector_ptr_clear(partition1s);
-    }
-
-    /* -------------------------------------------------------------------- */
-    /* Everything is ready, list the cuts, using the right PIVOT
-       function  */
-    IGRAPH_CHECK(igraph_marked_queue_init(&S, no_of_nodes));
-    IGRAPH_FINALLY(igraph_marked_queue_destroy, &S);
-    IGRAPH_CHECK(igraph_estack_init(&T, no_of_nodes, 0));
-    IGRAPH_FINALLY(igraph_estack_destroy, &T);
-
-    pivot_data.active = &VE1bool;
-
-    IGRAPH_CHECK(igraph_vector_ptr_init(&closedsets, 0));
-    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &closedsets); /* TODO */
-    IGRAPH_CHECK(igraph_provan_shier_list(&residual, &S, &T,
-                                          newsource, newtarget, &closedsets,
-                                          igraph_i_all_st_mincuts_pivot,
-                                          &pivot_data));
-
-    /* Convert the closed sets in the contracted graphs to cutsets in the
-       original graph */
-    IGRAPH_VECTOR_INIT_FINALLY(&revmap_ptr, igraph_vcount(&residual));
-    IGRAPH_VECTOR_INIT_FINALLY(&revmap_next, no_of_nodes);
-    for (i = 0; i < no_of_nodes; i++) {
-        long int id = (long int) VECTOR(NtoL)[i];
-        VECTOR(revmap_next)[i] = VECTOR(revmap_ptr)[id];
-        VECTOR(revmap_ptr)[id] = i + 1;
-    }
-
-    /* Create partitions in original graph */
-    nocuts = igraph_vector_ptr_size(&closedsets);
-    igraph_vector_ptr_clear(mypartition1s);
-    IGRAPH_CHECK(igraph_vector_ptr_reserve(mypartition1s, nocuts));
-    for (i = 0; i < nocuts; i++) {
-        igraph_vector_t *supercut = VECTOR(closedsets)[i];
-        long int j, supercutsize = igraph_vector_size(supercut);
-        igraph_vector_t *cut = IGRAPH_CALLOC(1, igraph_vector_t);
-        IGRAPH_VECTOR_INIT_FINALLY(cut, 0); /* TODO: better allocation */
-        for (j = 0; j < supercutsize; j++) {
-            long int vtx = (long int) VECTOR(*supercut)[j];
-            long int ovtx = (long int) VECTOR(revmap_ptr)[vtx];
-            while (ovtx != 0) {
-                ovtx--;
-                IGRAPH_CHECK(igraph_vector_push_back(cut, ovtx));
-                ovtx = (long int) VECTOR(revmap_next)[ovtx];
-            }
-        }
-        igraph_vector_ptr_push_back(mypartition1s, cut);
-        IGRAPH_FINALLY_CLEAN(1);
+/**
+ * \function igraph_eit_destroy
+ * \brief Destroys an edge iterator.
+ *
+ * \param eit Pointer to an edge iterator to destroy.
+ * \sa \ref igraph_eit_create()
+ *
+ * Time complexity: operating system dependent, usually O(1).
+ */
 
-        igraph_vector_destroy(supercut);
-        igraph_free(supercut);
-        VECTOR(closedsets)[i] = 0;
-    }
-
-    igraph_vector_destroy(&revmap_next);
-    igraph_vector_destroy(&revmap_ptr);
-    igraph_vector_ptr_destroy(&closedsets);
-    IGRAPH_FINALLY_CLEAN(3);
-
-    /* Create cuts in original graph */
-    if (cuts) {
-        igraph_vector_long_t memb;
-        IGRAPH_CHECK(igraph_vector_long_init(&memb, no_of_nodes));
-        IGRAPH_FINALLY(igraph_vector_long_destroy, &memb);
-        IGRAPH_CHECK(igraph_vector_ptr_resize(cuts, nocuts));
-        for (i = 0; i < nocuts; i++) {
-            igraph_vector_t *part = VECTOR(*mypartition1s)[i];
-            long int j, n = igraph_vector_size(part);
-            igraph_vector_t *v;
-            v = IGRAPH_CALLOC(1, igraph_vector_t);
-            if (!v) {
-                IGRAPH_ERROR("Cannot list minimum s-t cuts", IGRAPH_ENOMEM);
-            }
-            IGRAPH_VECTOR_INIT_FINALLY(v, 0);
-            for (j = 0; j < n; j++) {
-                long int vtx = (long int) VECTOR(*part)[j];
-                VECTOR(memb)[vtx] = i + 1;
-            }
-            for (j = 0; j < no_of_edges; j++) {
-                if (VECTOR(flow)[j] > 0) {
-                    long int from = IGRAPH_FROM(graph, j);
-                    long int to = IGRAPH_TO(graph, j);
-                    if (VECTOR(memb)[from] == i + 1 && VECTOR(memb)[to] != i + 1) {
-                        IGRAPH_CHECK(igraph_vector_push_back(v, j)); /* TODO: allocation */
-                    }
-                }
-            }
-            VECTOR(*cuts)[i] = v;
-            IGRAPH_FINALLY_CLEAN(1);
-        }
-        igraph_vector_long_destroy(&memb);
-        IGRAPH_FINALLY_CLEAN(1);
+void igraph_eit_destroy(const igraph_eit_t *eit) {
+    switch (eit->type) {
+    case IGRAPH_EIT_SEQ:
+    case IGRAPH_EIT_VECTORPTR:
+        break;
+    case IGRAPH_EIT_VECTOR:
+        igraph_vector_destroy((igraph_vector_t*)eit->vec);
+        igraph_free((igraph_vector_t*)eit->vec);
+        break;
+    default:
+        /*     IGRAPH_ERROR("Cannot destroy iterator, unknown type", IGRAPH_EINVAL); */
+        break;
     }
+}
 
-    igraph_estack_destroy(&T);
-    igraph_marked_queue_destroy(&S);
-    igraph_vector_bool_destroy(&VE1bool);
-    igraph_vector_destroy(&VE1);
-    igraph_vector_destroy(&NtoL);
-    igraph_destroy(&residual);
-    igraph_vector_destroy(&flow);
-    IGRAPH_FINALLY_CLEAN(7);
-
-    if (!partition1s) {
-        for (i = 0; i < nocuts; i++) {
-            igraph_vector_t *cut = VECTOR(*mypartition1s)[i];
-            igraph_vector_destroy(cut);
-            igraph_free(cut);
-            VECTOR(*mypartition1s)[i] = 0;
-        }
-        igraph_vector_ptr_destroy(mypartition1s);
-        IGRAPH_FINALLY_CLEAN(1);
+int igraph_eit_as_vector(const igraph_eit_t *eit, igraph_vector_t *v) {
+
+    long int i;
+
+    IGRAPH_CHECK(igraph_vector_resize(v, IGRAPH_EIT_SIZE(*eit)));
+
+    switch (eit->type) {
+    case IGRAPH_EIT_SEQ:
+        for (i = 0; i < IGRAPH_EIT_SIZE(*eit); i++) {
+            VECTOR(*v)[i] = eit->start + i;
+        }
+        break;
+    case IGRAPH_EIT_VECTOR:
+    case IGRAPH_EIT_VECTORPTR:
+        for (i = 0; i < IGRAPH_EIT_SIZE(*eit); i++) {
+            VECTOR(*v)[i] = VECTOR(*eit->vec)[i];
+        }
+        break;
+    default:
+        IGRAPH_ERROR("Cannot convert to vector, unknown iterator type",
+                     IGRAPH_EINVAL);
+        break;
     }
 
     return 0;
 }
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/barabasi.c` & `igraph-0.9.9/vendor/source/igraph/src/games/barabasi.c`

 * *Files 1% similar despite different names*

```diff
@@ -733,15 +733,15 @@
         } else {
             IGRAPH_CHECK(igraph_psumtree_update(
                 &sumtree, i, (1 + zero_age_appeal) * zero_deg_appeal
             ));
         }
 
         /* aging */
-        for (k = 1; i - binwidth * k + 1 >= 1; k++) {
+        for (k = 1; binwidth * k <= i; k++) {
             long int shnode = i - binwidth * k;
             long int deg = (long int) VECTOR(degree)[shnode];
             long int age = (i - shnode) / binwidth;
             /* igraph_real_t old=igraph_psumtree_get(&sumtree, shnode); */
             IGRAPH_CHECK(igraph_psumtree_update(
                 &sumtree, shnode,
                 (deg_coef * pow(deg, pa_exp) + zero_deg_appeal) *
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/callaway_traits.c` & `igraph-0.9.9/vendor/source/igraph/src/games/callaway_traits.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/citations.c` & `igraph-0.9.9/vendor/source/igraph/src/games/citations.c`

 * *Files 2% similar despite different names*

```diff
@@ -97,15 +97,15 @@
     long int i, j, k;
     long int *lastcit;
     long int *index;
     long int binwidth;
 
     if (agebins != igraph_vector_size(preference) - 1) {
         IGRAPH_ERRORF("The `preference' vector should be of length `agebins' plus one."
-                     "Number of agebins is %"IGRAPH_PRId", preference vector is of length %"IGRAPH_PRId"",
+                     "Number of agebins is %"IGRAPH_PRId", preference vector is of length %ld.",
                      IGRAPH_EINVAL,
                      agebins, igraph_vector_size(preference));
     }
     if (nodes < 0 ) {
         IGRAPH_ERRORF("Number of nodes should be non-negative, received %"IGRAPH_PRId".",
                      IGRAPH_EINVAL,
                      nodes);
@@ -397,22 +397,22 @@
     }
 
     /* avoid calling vector_max on empty vector */
     no_of_types = nodes == 0 ? 0 : igraph_vector_max(types) + 1;
 
     if (igraph_matrix_ncol(pref) != no_of_types) {
         IGRAPH_ERRORF("Number of preference matrix columns (%ld) not "
-                      "equal to number of types (%g).",
+                      "equal to number of types (%ld).",
                       IGRAPH_EINVAL,
                       igraph_matrix_ncol(pref),
                       no_of_types);
     }
     if (igraph_matrix_nrow(pref) != no_of_types) {
         IGRAPH_ERRORF("Number of preference matrix rows (%ld) not "
-                      "equal to number of types (%g).",
+                      "equal to number of types (%ld).",
                       IGRAPH_EINVAL,
                       igraph_matrix_nrow(pref),
                       no_of_types);
     }
 
     /* return an empty graph if nodes is zero */
     if (nodes == 0) {
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/correlated.c` & `igraph-0.9.9/vendor/source/igraph/src/games/correlated.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence.c` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.cpp` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_box_list.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_definitions.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_definitions.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.cpp` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_degree_sequence.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.cpp` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_hash.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.cpp` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1789,14 +1789,16 @@
 }
 
 // void graph_molloy_opt::remove_vertex(int v) {
 //   fprintf(stderr,"Warning : graph_molloy_opt::remove_vertex(%d) called",v);
 // }
 
 bool graph_molloy_opt::verify(int mode) {
+    IGRAPH_UNUSED(mode);
+#ifndef NDEBUG
     int i, j, k;
     assert(neigh[0] == links);
     // verify edges count
     if ((mode & VERIFY_NOARCS) == 0) {
         int sum = 0;
         for (i = 0; i < n; i++) {
             sum += deg[i];
@@ -1820,14 +1822,15 @@
             int v = neigh[i][j];
             int nb = 0;
             for (k = 0; k < deg[v]; k++) if (neigh[v][k] == i) {
                     nb++;
                 }
             assert(nb > 0);
         }
+#endif
     return true;
 }
 
 /*___________________________________________________________________________________
   Not to use anymore : use graph_molloy_hash class instead
 
 void graph_molloy_opt::shuffle(long times) {
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_graph_molloy_optimized.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_hash.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_hash.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_header.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_header.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_mr-connected.cpp` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_mr-connected.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.cpp` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_powerlaw.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_qsort.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_qsort.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.cpp` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_random.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_vertex_cover.h` & `igraph-0.9.9/vendor/source/igraph/src/games/degree_sequence_vl/gengraph_vertex_cover.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/dotproduct.c` & `igraph-0.9.9/vendor/source/igraph/src/games/dotproduct.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/erdos_renyi.c` & `igraph-0.9.9/vendor/source/igraph/src/games/erdos_renyi.c`

 * *Files 1% similar despite different names*

```diff
@@ -49,15 +49,15 @@
     if (n < 0) {
         IGRAPH_ERROR("Invalid number of vertices", IGRAPH_EINVAL);
     }
     if (p < 0.0 || p > 1.0) {
         IGRAPH_ERROR("Invalid probability given", IGRAPH_EINVAL);
     }
 
-    if (p == 0.0 || no_of_nodes <= 1) {
+    if (p == 0.0 || no_of_nodes == 0) {
         IGRAPH_CHECK(retval = igraph_empty(graph, n, directed));
     } else if (p == 1.0) {
         IGRAPH_CHECK(retval = igraph_full(graph, n, directed, loops));
     } else {
 
         long int i;
         double maxedges = n, last;
@@ -146,15 +146,15 @@
     if (n < 0) {
         IGRAPH_ERROR("Invalid number of vertices", IGRAPH_EINVAL);
     }
     if (m < 0) {
         IGRAPH_ERROR("Invalid number of edges", IGRAPH_EINVAL);
     }
 
-    if (m == 0.0 || no_of_nodes <= 1) {
+    if (m == 0.0 || no_of_nodes == 0) {
         IGRAPH_CHECK(retval = igraph_empty(graph, n, directed));
     } else {
 
         long int i;
         double maxedges = n;
         if (directed && loops) {
             maxedges *= n;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/establishment.c` & `igraph-0.9.9/vendor/source/igraph/src/games/establishment.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/forestfire.c` & `igraph-0.9.9/vendor/source/igraph/src/games/forestfire.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/grg.c` & `igraph-0.9.9/vendor/source/igraph/src/games/grg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/growing_random.c` & `igraph-0.9.9/vendor/source/igraph/src/games/growing_random.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/islands.c` & `igraph-0.9.9/vendor/source/igraph/src/games/islands.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/k_regular.c` & `igraph-0.9.9/vendor/source/igraph/src/games/k_regular.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/preference.c` & `igraph-0.9.9/vendor/source/igraph/src/games/preference.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/recent_degree.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/rewire_edges.c`

 * *Files 23% similar despite different names*

```diff
@@ -19,354 +19,376 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
 #include "igraph_games.h"
 
+#include "igraph_conversion.h"
 #include "igraph_constructors.h"
-#include "igraph_dqueue.h"
-#include "igraph_psumtree.h"
-#include "igraph_random.h"
 #include "igraph_interface.h"
+#include "igraph_random.h"
+
+#include "graph/attributes.h"
+
+static int igraph_i_rewire_edges_no_multiple(igraph_t *graph, igraph_real_t prob,
+                                             igraph_bool_t loops,
+                                             igraph_vector_t *edges) {
+
+    int no_verts = igraph_vcount(graph);
+    int no_edges = igraph_ecount(graph);
+    igraph_vector_t eorder, tmp;
+    igraph_vector_int_t first, next, prev, marked;
+    int i, to_rewire, last_other = -1;
+
+    /* Create our special graph representation */
+
+# define ADD_STUB(vertex, stub) do {                \
+        if (VECTOR(first)[(vertex)]) {              \
+            VECTOR(prev)[(int) VECTOR(first)[(vertex)]-1]=(stub)+1;   \
+        }                               \
+        VECTOR(next)[(stub)]=VECTOR(first)[(vertex)];       \
+        VECTOR(prev)[(stub)]=0;                 \
+        VECTOR(first)[(vertex)]=(stub)+1;               \
+    } while (0)
+
+# define DEL_STUB(vertex, stub) do {                    \
+        if (VECTOR(next)[(stub)]) {                     \
+            VECTOR(prev)[VECTOR(next)[(stub)]-1]=VECTOR(prev)[(stub)];    \
+        }                                   \
+        if (VECTOR(prev)[(stub)]) {                     \
+            VECTOR(next)[VECTOR(prev)[(stub)]-1]=VECTOR(next)[(stub)];    \
+        } else {                                \
+            VECTOR(first)[(vertex)]=VECTOR(next)[(stub)];         \
+        }                                   \
+    } while (0)
+
+# define MARK_NEIGHBORS(vertex) do {                \
+        int xxx_ =VECTOR(first)[(vertex)];              \
+        while (xxx_) {                      \
+            int o= (int) VECTOR(*edges)[xxx_ % 2 ? xxx_ : xxx_-2];    \
+            VECTOR(marked)[o]=other+1;                \
+            xxx_=VECTOR(next)[xxx_-1];                \
+        }                               \
+    } while (0)
+
+    IGRAPH_CHECK(igraph_vector_int_init(&first, no_verts));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &first);
+    IGRAPH_CHECK(igraph_vector_int_init(&next, no_edges * 2));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &next);
+    IGRAPH_CHECK(igraph_vector_int_init(&prev, no_edges * 2));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &prev);
+    IGRAPH_CHECK(igraph_get_edgelist(graph, edges, /*bycol=*/ 0));
+    IGRAPH_VECTOR_INIT_FINALLY(&eorder, no_edges);
+    IGRAPH_VECTOR_INIT_FINALLY(&tmp, no_edges);
+    for (i = 0; i < no_edges; i++) {
+        int idx1 = 2 * i, idx2 = idx1 + 1,
+            from = (int) VECTOR(*edges)[idx1], to = (int) VECTOR(*edges)[idx2];
+        VECTOR(tmp)[i] = from;
+        ADD_STUB(from, idx1);
+        ADD_STUB(to, idx2);
+    }
+    IGRAPH_CHECK(igraph_vector_order1(&tmp, &eorder, no_verts));
+    igraph_vector_destroy(&tmp);
+    IGRAPH_FINALLY_CLEAN(1);
+
+    IGRAPH_CHECK(igraph_vector_int_init(&marked, no_verts));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &marked);
+
+    /* Rewire the stubs, part I */
+
+    to_rewire = (int) RNG_GEOM(prob);
+    while (to_rewire < no_edges) {
+        int stub = (int) (2 * VECTOR(eorder)[to_rewire] + 1);
+        int v = (int) VECTOR(*edges)[stub];
+        int ostub = stub - 1;
+        int other = (int) VECTOR(*edges)[ostub];
+        int pot;
+        if (last_other != other) {
+            MARK_NEIGHBORS(other);
+        }
+        /* Do the rewiring */
+        do {
+            if (loops) {
+                pot = (int) RNG_INTEGER(0, no_verts - 1);
+            } else {
+                pot = (int) RNG_INTEGER(0, no_verts - 2);
+                pot = pot != other ? pot : no_verts - 1;
+            }
+        } while (VECTOR(marked)[pot] == other + 1 && pot != v);
+
+        if (pot != v) {
+            DEL_STUB(v, stub);
+            ADD_STUB(pot, stub);
+            VECTOR(marked)[v] = 0;
+            VECTOR(marked)[pot] = other + 1;
+            VECTOR(*edges)[stub] = pot;
+        }
+
+        to_rewire += RNG_GEOM(prob) + 1;
+        last_other = other;
+    }
+
+    /* Create the new index, from the potentially rewired stubs */
+
+    IGRAPH_VECTOR_INIT_FINALLY(&tmp, no_edges);
+    for (i = 0; i < no_edges; i++) {
+        VECTOR(tmp)[i] = VECTOR(*edges)[2 * i + 1];
+    }
+    IGRAPH_CHECK(igraph_vector_order1(&tmp, &eorder, no_verts));
+    igraph_vector_destroy(&tmp);
+    IGRAPH_FINALLY_CLEAN(1);
+
+    /* Rewire the stubs, part II */
+
+    igraph_vector_int_null(&marked);
+    last_other = -1;
+
+    to_rewire = (int) RNG_GEOM(prob);
+    while (to_rewire < no_edges) {
+        int stub = (int) (2 * VECTOR(eorder)[to_rewire]);
+        int v = (int) VECTOR(*edges)[stub];
+        int ostub = stub + 1;
+        int other = (int) VECTOR(*edges)[ostub];
+        int pot;
+        if (last_other != other) {
+            MARK_NEIGHBORS(other);
+        }
+        /* Do the rewiring */
+        do {
+            if (loops) {
+                pot = (int) RNG_INTEGER(0, no_verts - 1);
+            } else {
+                pot = (int) RNG_INTEGER(0, no_verts - 2);
+                pot = pot != other ? pot : no_verts - 1;
+            }
+        } while (VECTOR(marked)[pot] == other + 1 && pot != v);
+        if (pot != v) {
+            DEL_STUB(v, stub);
+            ADD_STUB(pot, stub);
+            VECTOR(marked)[v] = 0;
+            VECTOR(marked)[pot] = other + 1;
+            VECTOR(*edges)[stub] = pot;
+        }
+
+        to_rewire += RNG_GEOM(prob) + 1;
+        last_other = other;
+    }
+
+    igraph_vector_int_destroy(&marked);
+    igraph_vector_int_destroy(&prev);
+    igraph_vector_int_destroy(&next);
+    igraph_vector_int_destroy(&first);
+    igraph_vector_destroy(&eorder);
+    IGRAPH_FINALLY_CLEAN(5);
+
+    return 0;
+}
+
+#undef ADD_STUB
+#undef DEL_STUB
+#undef MARK_NEIGHBORS
 
 /**
- * \function igraph_recent_degree_game
- * \brief Stochastic graph generator based on the number of incident edges a node has gained recently.
+ * \function igraph_rewire_edges
+ * \brief Rewires the edges of a graph with constant probability.
+ *
+ * This function rewires the edges of a graph with a constant
+ * probability. More precisely each end point of each edge is rewired
+ * to a uniformly randomly chosen vertex with constant probability \p
+ * prob.
+ *
+ * </para><para> Note that this function modifies the input \p graph,
+ * call \ref igraph_copy() if you want to keep it.
  *
- * \param graph Pointer to an uninitialized graph object.
- * \param nodes The number of vertices in the graph, this is the same as
- *        the number of time steps.
- * \param power The exponent, the probability that a node gains a
- *        new edge is proportional to the number of edges it has
- *        gained recently (in the last \p window time steps) to \p
- *        power.
- * \param time_window Integer constant, the size of the time window to use
- *        to count the number of recent edges.
- * \param m Integer constant, the number of edges to add per time
- *        step if the \p outseq parameter is a null pointer or a
- *        zero-length vector.
- * \param outseq The number of edges to add in each time step. This
- *        argument is ignored if it is a null pointer or a zero length
- *        vector. In this case the constant \p m parameter is used.
- * \param outpref Logical constant, if true the edges originated by a
- *        vertex also count as recent incident edges.
- *        For most applications it is reasonable to set it to false.
- * \param zero_appeal Constant giving the attractiveness of the
- *        vertices which haven't gained any edge recently.
- * \param directed Logical constant, whether to generate a directed
- *        graph.
+ * \param graph The input graph, this will be rewired, it can be
+ *    directed or undirected.
+ * \param prob The rewiring probability a constant between zero and
+ *    one (inclusive).
+ * \param loops Boolean, whether loop edges are allowed in the new
+ *    graph, or not.
+ * \param multiple Boolean, whether multiple edges are allowed in the
+ *    new graph.
  * \return Error code.
  *
- * Time complexity: O(|V|*log(|V|)+|E|), |V| is the number of
- * vertices, |E| is the number of edges in the graph.
+ * \sa \ref igraph_watts_strogatz_game() uses this function for the
+ * rewiring.
  *
+ * Time complexity: O(|V|+|E|).
  */
-int igraph_recent_degree_game(igraph_t *graph, igraph_integer_t nodes,
-                              igraph_real_t power,
-                              igraph_integer_t time_window,
-                              igraph_integer_t m,
-                              const igraph_vector_t *outseq,
-                              igraph_bool_t outpref,
-                              igraph_real_t zero_appeal,
-                              igraph_bool_t directed) {
-
-    long int no_of_nodes = nodes;
-    long int no_of_neighbors = 0;
-    long int no_of_edges;
+int igraph_rewire_edges(igraph_t *graph, igraph_real_t prob,
+                        igraph_bool_t loops, igraph_bool_t multiple) {
+
+    igraph_t newgraph;
+    long int no_of_edges = igraph_ecount(graph);
+    long int no_of_nodes = igraph_vcount(graph);
+    long int endpoints = no_of_edges * 2;
+    long int to_rewire;
     igraph_vector_t edges;
-    long int i, j;
-    igraph_psumtree_t sumtree;
-    long int edgeptr = 0;
-    igraph_vector_t degree;
-    igraph_dqueue_t history;
-    igraph_bool_t have_outseq = outseq && igraph_vector_size(outseq) > 0;
 
-    if (no_of_nodes < 0) {
-        IGRAPH_ERRORF("Number of vertices cannot be negative, got %ld.", IGRAPH_EINVAL, no_of_nodes);
-    }
-    if (have_outseq && igraph_vector_size(outseq) != no_of_nodes) {
-        IGRAPH_ERRORF("Out-degree sequence is specified, but its length (%ld) does not equal the number of nodes (%ld).",
-                      IGRAPH_EINVAL, (long) igraph_vector_size(outseq), no_of_nodes);
-    }
-    if (!have_outseq && m < 0) {
-        IGRAPH_ERRORF("Numer of edges per step cannot be negative, got %" IGRAPH_PRId ".",
-                       IGRAPH_EINVAL, m);
-    }
-    if (time_window < 0) {
-        IGRAPH_ERRORF("Time window cannot be negative, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, time_window);
-    }
-    if (zero_appeal < 0) {
-        IGRAPH_ERRORF("The zero appeal cannot be negative, got %g.", IGRAPH_EINVAL, zero_appeal);
+    if (prob < 0 || prob > 1) {
+        IGRAPH_ERROR("Rewiring probability should be between zero and one",
+                     IGRAPH_EINVAL);
     }
 
-    if (nodes == 0) {
-        igraph_empty(graph, 0, directed);
+    if (prob == 0) {
+        /* This is easy, just leave things as they are */
         return IGRAPH_SUCCESS;
     }
 
-    if (!have_outseq) {
-        no_of_neighbors = m;
-        no_of_edges = (no_of_nodes - 1) * no_of_neighbors;
-    } else {
-        long int outseq_len = igraph_vector_size(outseq);
-        no_of_edges = 0;
-        for (i = 1; i < outseq_len; i++) {
-            no_of_edges += VECTOR(*outseq)[i];
-        }
-    }
-
-    IGRAPH_VECTOR_INIT_FINALLY(&edges, no_of_edges * 2);
-    IGRAPH_CHECK(igraph_psumtree_init(&sumtree, no_of_nodes));
-    IGRAPH_FINALLY(igraph_psumtree_destroy, &sumtree);
-    IGRAPH_VECTOR_INIT_FINALLY(&degree, no_of_nodes);
-    IGRAPH_CHECK(igraph_dqueue_init(&history,
-                                    1.5 * time_window * no_of_edges / no_of_nodes + 10));
-    IGRAPH_FINALLY(igraph_dqueue_destroy, &history);
+    IGRAPH_VECTOR_INIT_FINALLY(&edges, endpoints);
 
     RNG_BEGIN();
 
-    /* first node */
-    IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_appeal));
-    igraph_dqueue_push(&history, -1);
-
-    /* and the rest */
-    for (i = 1; i < no_of_nodes; i++) {
-        igraph_real_t sum;
-        long int to;
-        if (have_outseq) {
-            no_of_neighbors = (long int) VECTOR(*outseq)[i];
-        }
-
-        if (i >= time_window) {
-            while ((j = (long int) igraph_dqueue_pop(&history)) != -1) {
-                VECTOR(degree)[j] -= 1;
-                IGRAPH_CHECK(igraph_psumtree_update(&sumtree, j, pow(VECTOR(degree)[j], power) + zero_appeal));
+    if (prob != 0 && no_of_edges > 0) {
+        if (multiple) {
+            /* If multiple edges are allowed, then there is an easy and fast
+            method. Each endpoint of an edge is rewired with probability p,
+             so the "skips" between the really rewired endpoints follow a
+             geometric distribution. */
+            IGRAPH_CHECK(igraph_get_edgelist(graph, &edges, 0));
+            to_rewire = (long int) RNG_GEOM(prob);
+            while (to_rewire < endpoints) {
+                if (loops) {
+                    VECTOR(edges)[to_rewire] = RNG_INTEGER(0, no_of_nodes - 1);
+                } else {
+                    long int opos = to_rewire % 2 ? to_rewire - 1 : to_rewire + 1;
+                    long int nei = (long int) VECTOR(edges)[opos];
+                    long int r = RNG_INTEGER(0, no_of_nodes - 2);
+                    VECTOR(edges)[ to_rewire ] = (r != nei ? r : no_of_nodes - 1);
+                }
+                to_rewire += RNG_GEOM(prob) + 1;
             }
-        }
 
-        sum = igraph_psumtree_sum(&sumtree);
-        for (j = 0; j < no_of_neighbors; j++) {
-            igraph_psumtree_search(&sumtree, &to, RNG_UNIF(0, sum));
-            VECTOR(degree)[to]++;
-            VECTOR(edges)[edgeptr++] = i;
-            VECTOR(edges)[edgeptr++] = to;
-            igraph_dqueue_push(&history, to);
-        }
-        igraph_dqueue_push(&history, -1);
-
-        /* update probabilities */
-        for (j = 0; j < no_of_neighbors; j++) {
-            long int nn = (long int) VECTOR(edges)[edgeptr - 2 * j - 1];
-            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, nn, pow(VECTOR(degree)[nn], power) + zero_appeal));
-        }
-        if (outpref) {
-            VECTOR(degree)[i] += no_of_neighbors;
-            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, i, pow(VECTOR(degree)[i], power) + zero_appeal));
         } else {
-            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, i, zero_appeal));
+            IGRAPH_CHECK(igraph_i_rewire_edges_no_multiple(graph, prob, loops,
+                         &edges));
         }
     }
 
     RNG_END();
 
-    igraph_dqueue_destroy(&history);
-    igraph_psumtree_destroy(&sumtree);
-    igraph_vector_destroy(&degree);
-    IGRAPH_FINALLY_CLEAN(3);
-
-    IGRAPH_CHECK(igraph_create(graph, &edges, nodes, directed));
+    IGRAPH_CHECK(igraph_create(&newgraph, &edges, (igraph_integer_t) no_of_nodes,
+                               igraph_is_directed(graph)));
     igraph_vector_destroy(&edges);
     IGRAPH_FINALLY_CLEAN(1);
 
+    IGRAPH_FINALLY(igraph_destroy, &newgraph);
+    IGRAPH_I_ATTRIBUTE_DESTROY(&newgraph);
+    IGRAPH_I_ATTRIBUTE_COPY(&newgraph, graph, 1, 1, 1);
+    IGRAPH_FINALLY_CLEAN(1);
+    igraph_destroy(graph);
+    *graph = newgraph;
+
     return 0;
 }
 
 /**
- * \function igraph_recent_degree_aging_game
- * \brief Preferential attachment based on the number of edges gained recently, with aging of vertices.
+ * \function igraph_rewire_directed_edges
+ * \brief Rewires the chosen endpoint of directed edges.
+ *
+ * This function rewires either the start or end of directed edges in a graph
+ * with a constant probability. Correspondingly, either the in-degree sequence
+ * or the out-degree sequence of the graph will be preserved.
+ *
+ * </para><para> Note that this function modifies the input \p graph,
+ * call \ref igraph_copy() if you want to keep it.
  *
- * </para><para>
- * This game is very similar to \ref igraph_barabasi_aging_game(),
- * except that instead of the total number of incident edges the
- * number of edges gained in the last \p time_window time steps are
- * counted.
- *
- * </para><para>The degree dependent part of the attractiveness is
- * given by k to the power of \p pa_exp plus \p zero_appeal; the age
- * dependent part is l to the power to \p aging_exp.
- * k is the number of edges gained in the last \p time_window time
- * steps, l is the age of the vertex.
- * \param graph Pointer to an uninitialized graph object.
- * \param nodes The number of vertices in the graph.
- * \param m The number of edges to add in each time step. If the \p
- *        outseq argument is not a null vector or a zero-length vector
- *        then it is ignored.
- * \param outseq Vector giving the number of edges to add in each time
- *        step. If it is a null pointer or a zero-length vector then
- *        it is ignored and the \p m argument is used.
- * \param outpref Logical constant, if true the edges initiated by a
- *        vertex are also counted. Normally it is false.
- * \param pa_exp The exponent for the preferential attachment.
- * \param aging_exp The exponent for the aging, normally it is
- *        negative: old vertices gain edges with less probability.
- * \param aging_bins Integer constant, the number of age bins to use.
- * \param time_window The time window to use to count the number of
- *        incident edges for the vertices.
- * \param zero_appeal The degree dependent part of the attractiveness
- *        for zero degree vertices.
- * \param directed Logical constant, whether to create a directed
- *        graph.
+ * </para><para> This function can produce multiple edges between two vertices.
+ *
+ * \param graph The input graph, this will be rewired, it can be
+ *    directed or undirected. If it is undirected or \p mode is set to
+ *    IGRAPH_ALL, \ref igraph_rewire_edges() will be called.
+ * \param prob The rewiring probability, a constant between zero and
+ *    one (inclusive).
+ * \param loops Boolean, whether loop edges are allowed in the new
+ *    graph, or not.
+ * \param mode The endpoints of directed edges to rewire. It is ignored for
+ *    undirected graphs. Possible values:
+ *        \clist
+ *        \cli IGRAPH_OUT
+ *          rewire the end of each directed edge
+ *        \cli IGRAPH_IN
+ *          rewire the start of each directed edge
+ *        \cli IGRAPH_ALL
+ *          rewire both endpoints of each edge
+ *        \endclist
  * \return Error code.
  *
- * Time complexity: O((|V|+|V|/aging_bins)*log(|V|)+|E|). |V| is the number
- * of vertices, |E| the number of edges.
+ * \sa \ref igraph_rewire_edges(), \ref igraph_rewire()
+ *
+ * Time complexity: O(|E|).
  */
-int igraph_recent_degree_aging_game(igraph_t *graph,
-                                    igraph_integer_t nodes,
-                                    igraph_integer_t m,
-                                    const igraph_vector_t *outseq,
-                                    igraph_bool_t outpref,
-                                    igraph_real_t pa_exp,
-                                    igraph_real_t aging_exp,
-                                    igraph_integer_t aging_bins,
-                                    igraph_integer_t time_window,
-                                    igraph_real_t zero_appeal,
-                                    igraph_bool_t directed) {
-
-    long int no_of_nodes = nodes;
-    long int no_of_neighbors;
-    long int binwidth;
-    long int no_of_edges;
-    igraph_vector_t edges;
-    long int i, j, k;
-    igraph_psumtree_t sumtree;
-    long int edgeptr = 0;
-    igraph_vector_t degree;
-    igraph_dqueue_t history;
-    igraph_bool_t have_outseq = outseq && igraph_vector_size(outseq) > 0;
+int igraph_rewire_directed_edges(igraph_t *graph, igraph_real_t prob,
+                                 igraph_bool_t loops, igraph_neimode_t mode) {
 
-    if (no_of_nodes == 0) {
-        igraph_empty(graph, 0, directed);
-        return IGRAPH_SUCCESS;
-    }
-    if (no_of_nodes < 0) {
-        IGRAPH_ERRORF("Number of nodes should not be negative, got %ld.", IGRAPH_EINVAL, no_of_nodes);
-    }
-    if (have_outseq && igraph_vector_size(outseq) != no_of_nodes) {
-        IGRAPH_ERRORF("Out-degree sequence is specified, but its length (%ld) does not equal the number of nodes (%ld).",
-                      IGRAPH_EINVAL, (long) igraph_vector_size(outseq), no_of_nodes);
-    }
-    if (!have_outseq && m < 0) {
-        IGRAPH_ERRORF("Numer of edges per step cannot be negative, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, m);
-    }
-    if (aging_bins <= 0) {
-        IGRAPH_ERRORF("Aging bins should be positive, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, aging_bins);
-    }
-    if (time_window < 0) {
-        IGRAPH_ERRORF("Time window cannot be negative, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, time_window);
-    }
-    if (zero_appeal < 0) {
-        IGRAPH_ERRORF("The zero appeal cannot be negative, got %g.", IGRAPH_EINVAL, zero_appeal);
+    if (prob < 0 || prob > 1) {
+        IGRAPH_ERROR("Rewiring probability should be between zero and one",
+                     IGRAPH_EINVAL);
     }
 
-    if (!have_outseq) {
-        no_of_neighbors = m;
-        no_of_edges = (no_of_nodes - 1) * no_of_neighbors;
-    } else {
-        long int outseq_len = igraph_vector_size(outseq);
-        no_of_edges = 0;
-        for (i = 1; i < outseq_len; i++) {
-            no_of_edges += VECTOR(*outseq)[i];
-        }
+    if (mode != IGRAPH_OUT && mode != IGRAPH_IN &&
+        mode != IGRAPH_ALL) {
+        IGRAPH_ERROR("Invalid mode argument", IGRAPH_EINVMODE);
     }
 
-    binwidth = nodes / aging_bins + 1;
-
-    IGRAPH_VECTOR_INIT_FINALLY(&edges, no_of_edges * 2);
-    IGRAPH_CHECK(igraph_psumtree_init(&sumtree, no_of_nodes));
-    IGRAPH_FINALLY(igraph_psumtree_destroy, &sumtree);
-    IGRAPH_VECTOR_INIT_FINALLY(&degree, no_of_nodes);
-    IGRAPH_CHECK(igraph_dqueue_init(&history,
-                                    1.5 * time_window * no_of_edges / no_of_nodes + 10));
-    IGRAPH_FINALLY(igraph_dqueue_destroy, &history);
-
-    RNG_BEGIN();
-
-    /* first node */
-    IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_appeal));
-    igraph_dqueue_push(&history, -1);
-
-    /* and the rest */
-    for (i = 1; i < no_of_nodes; i++) {
-        igraph_real_t sum;
-        long int to;
-
-        if (have_outseq) {
-            no_of_neighbors = (long int) VECTOR(*outseq)[i];
-        }
+    if (prob == 0) {
+        return IGRAPH_SUCCESS;
+    }
 
-        if (i >= time_window) {
-            while ((j = (long int) igraph_dqueue_pop(&history)) != -1) {
-                long int age = (i - j) / binwidth;
-                VECTOR(degree)[j] -= 1;
-                IGRAPH_CHECK(igraph_psumtree_update(
-                    &sumtree, j,
-                    (pow(VECTOR(degree)[j], pa_exp) + zero_appeal) * pow(age + 1, aging_exp)
-                ));
+    if (igraph_is_directed(graph) && mode != IGRAPH_ALL) {
+        igraph_t newgraph;
+        long int no_of_edges = igraph_ecount(graph);
+        long int no_of_nodes = igraph_vcount(graph);
+        long int to_rewire;
+        long int offset = 0;
+        igraph_vector_t edges;
+
+        IGRAPH_VECTOR_INIT_FINALLY(&edges, 2 * no_of_edges);
+
+        switch (mode) {
+        case IGRAPH_IN:
+            offset = 0;
+            break;
+        case IGRAPH_OUT:
+            offset = 1;
+            break;
+        case IGRAPH_ALL:
+            break; /* suppress compiler warning */
+        }
+
+        IGRAPH_CHECK(igraph_get_edgelist(graph, &edges, 0));
+
+        RNG_BEGIN();
+
+        to_rewire = RNG_GEOM(prob);
+        while (to_rewire < no_of_edges) {
+            if (loops) {
+                VECTOR(edges)[2 * to_rewire + offset] = RNG_INTEGER(0, no_of_nodes - 1);
+            } else {
+                long int nei = (long int) VECTOR(edges)[2 * to_rewire + (1 - offset)];
+                long int r = RNG_INTEGER(0, no_of_nodes - 2);
+                VECTOR(edges)[2 * to_rewire + offset] = (r != nei ? r : no_of_nodes - 1);
             }
+            to_rewire += RNG_GEOM(prob) + 1;
         }
 
-        sum = igraph_psumtree_sum(&sumtree);
-        for (j = 0; j < no_of_neighbors; j++) {
-            igraph_psumtree_search(&sumtree, &to, RNG_UNIF(0, sum));
-            VECTOR(degree)[to]++;
-            VECTOR(edges)[edgeptr++] = i;
-            VECTOR(edges)[edgeptr++] = to;
-            igraph_dqueue_push(&history, to);
-        }
-        igraph_dqueue_push(&history, -1);
+        RNG_END();
 
-        /* update probabilities */
-        for (j = 0; j < no_of_neighbors; j++) {
-            long int n = (long int) VECTOR(edges)[edgeptr - 2 * j - 1];
-            long int age = (i - n) / binwidth;
-            IGRAPH_CHECK(igraph_psumtree_update(
-                &sumtree, n,
-                (pow(VECTOR(degree)[n], pa_exp) + zero_appeal) * pow(age + 1, aging_exp)
-            ));
-        }
-        if (outpref) {
-            VECTOR(degree)[i] += no_of_neighbors;
-            IGRAPH_CHECK(igraph_psumtree_update(
-                &sumtree, i,
-                pow(VECTOR(degree)[i], pa_exp) + zero_appeal
-            ));
-        } else {
-            IGRAPH_CHECK(igraph_psumtree_update(&sumtree, i, zero_appeal));
-        }
+        IGRAPH_CHECK(igraph_create(&newgraph, &edges, (igraph_integer_t) no_of_nodes,
+                                   igraph_is_directed(graph)));
+        igraph_vector_destroy(&edges);
+        IGRAPH_FINALLY_CLEAN(1);
+
+        IGRAPH_FINALLY(igraph_destroy, &newgraph);
+        IGRAPH_I_ATTRIBUTE_DESTROY(&newgraph);
+        IGRAPH_I_ATTRIBUTE_COPY(&newgraph, graph, 1, 1, 1);
+        IGRAPH_FINALLY_CLEAN(1);
+        igraph_destroy(graph);
+        *graph = newgraph;
 
-        /* aging */
-        for (k = 1; i - binwidth * k + 1 >= 1; k++) {
-            long int shnode = i - binwidth * k;
-            long int deg = (long int) VECTOR(degree)[shnode];
-            long int age = (i - shnode) / binwidth;
-            IGRAPH_CHECK(igraph_psumtree_update(
-                &sumtree, shnode,
-                (pow(deg, pa_exp) + zero_appeal) * pow(age + 2, aging_exp)
-            ));
-        }
+    } else {
+        IGRAPH_CHECK(igraph_rewire_edges(graph, prob, loops, /* multiple = */ 1));
     }
 
-    RNG_END();
-
-    igraph_dqueue_destroy(&history);
-    igraph_vector_destroy(&degree);
-    igraph_psumtree_destroy(&sumtree);
-    IGRAPH_FINALLY_CLEAN(3);
-
-    IGRAPH_CHECK(igraph_create(graph, &edges, nodes, directed));
-    igraph_vector_destroy(&edges);
-    IGRAPH_FINALLY_CLEAN(1);
-
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/sbm.c` & `igraph-0.9.9/vendor/source/igraph/src/games/sbm.c`

 * *Files 0% similar despite different names*

```diff
@@ -112,15 +112,15 @@
         if (igraph_vector_int_min(block_sizes) < 0) {
             IGRAPH_ERRORF("Block sizes must be non-negative, but got %" IGRAPH_PRId ".",
                           IGRAPH_EINVAL, igraph_vector_int_min(block_sizes));
         }
     }
 
     if (igraph_vector_int_sum(block_sizes) != n) {
-        IGRAPH_ERRORF("Sum of the block sizes (%ld) must equal the number of vertices (%ld).",
+        IGRAPH_ERRORF("Sum of the block sizes (%" IGRAPH_PRId ") must equal the number of vertices (%" IGRAPH_PRId ").",
                       IGRAPH_EINVAL, igraph_vector_int_sum(block_sizes), n);
     }
 
     /* Since the sum of the block sizes should equal the number of vertices,
      * and the block sizes are non-negative, the number of vertices is
      * guaranteed to be non-negative. This shouldn't be checked separately.
      */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/static_fitness.c` & `igraph-0.9.9/vendor/source/igraph/src/games/static_fitness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/tree.c` & `igraph-0.9.9/vendor/source/igraph/src/games/tree.c`

 * *Files 5% similar despite different names*

```diff
@@ -150,14 +150,18 @@
  * \ingroup generators
  * \function igraph_tree_game
  * \brief Generates a random tree with the given number of nodes.
  *
  * This function samples uniformly from the set of labelled trees,
  * i.e. it generates each labelled tree with the same probability.
  *
+ * </para><para>
+ * Note that for <code>n=0</code>, the null graph is returned,
+ * which is not considered to be a tree by \ref igraph_is_tree().
+ *
  * \param graph Pointer to an uninitialized graph object.
  * \param n The number of nodes in the tree.
  * \param directed Whether to create a directed tree. The edges are oriented away from the root.
  * \param method The algorithm to use to generate the tree. Possible values:
  *        \clist
  *        \cli IGRAPH_RANDOM_TREE_PRUFER
  *          This algorithm samples Pr&uuml;fer sequences uniformly, then converts them to trees.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/games/watts_strogatz.c` & `igraph-0.9.9/vendor/source/igraph/src/games/watts_strogatz.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/adjlist.c` & `igraph-0.9.9/vendor/source/igraph/src/graph/adjlist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/attributes.c` & `igraph-0.9.9/vendor/source/igraph/src/graph/attributes.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/attributes.h` & `igraph-0.9.9/vendor/source/igraph/src/graph/attributes.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/basic_query.c` & `igraph-0.9.9/vendor/source/igraph/src/graph/basic_query.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/cattributes.c` & `igraph-0.9.9/vendor/source/igraph/src/graph/cattributes.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/neighbors.h` & `igraph-0.9.9/vendor/source/igraph/src/graph/neighbors.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/type_indexededgelist.c` & `igraph-0.9.9/vendor/source/igraph/src/graph/type_indexededgelist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/graph/visitors.c` & `igraph-0.9.9/vendor/source/igraph/src/graph/visitors.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/hrg/dendro.h` & `igraph-0.9.9/vendor/source/igraph/src/hrg/dendro.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/hrg/graph.h` & `igraph-0.9.9/vendor/source/igraph/src/hrg/graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/hrg/graph_simp.h` & `igraph-0.9.9/vendor/source/igraph/src/hrg/graph_simp.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/hrg/hrg.cc` & `igraph-0.9.9/vendor/source/igraph/src/hrg/hrg.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/hrg/hrg_types.cc` & `igraph-0.9.9/vendor/source/igraph/src/hrg/hrg_types.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/hrg/rbtree.h` & `igraph-0.9.9/vendor/source/igraph/src/hrg/rbtree.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/hrg/splittree_eq.h` & `igraph-0.9.9/vendor/source/igraph/src/hrg/splittree_eq.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/glpk_support.c` & `igraph-0.9.9/vendor/source/igraph/src/internal/glpk_support.c`

 * *Files 2% similar despite different names*

```diff
@@ -45,16 +45,15 @@
            and the error_hook. */
         igraph_i_glpk_error_info.is_interrupted = 1;
         glp_error("GLPK was interrupted."); /* This dummy message is never printed */
     } else if (glp_at_error()) {
         /* Copy the error messages into a buffer for later reporting */
         /* We must use glp_at_error() instead of igraph_i_glpk_error_info.is_error
          * to determine if a message is an error message, as the reporting function is
-         * called before the error function. The vendored old GLPK is patched to add support
-         * for glp_at_error(). New GLPK versions have this functions. */
+         * called before the error function. */
         const size_t n = sizeof(igraph_i_glpk_error_info.msg) / sizeof(char) - 1;
         while (*s != '\0' && igraph_i_glpk_error_info.msg_ptr < igraph_i_glpk_error_info.msg + n) {
             *(igraph_i_glpk_error_info.msg_ptr++) = *(s++);
         }
         *igraph_i_glpk_error_info.msg_ptr = '\0';
     }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/glpk_support.h` & `igraph-0.9.9/vendor/source/igraph/src/internal/glpk_support.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/gmp_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/internal/gmp_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/hacks.c` & `igraph-0.9.9/vendor/source/igraph/src/internal/hacks.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/hacks.h` & `igraph-0.9.9/vendor/source/igraph/src/internal/hacks.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/lsap.c` & `igraph-0.9.9/vendor/source/igraph/src/internal/lsap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/pstdint.h` & `igraph-0.9.9/vendor/source/igraph/src/internal/pstdint.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/qsort.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_1.c`

 * *Files 27% similar despite different names*

```diff
@@ -1,208 +1,181 @@
-/*-
- * Copyright (c) 1992, 1993
- *  The Regents of the University of California.  All rights reserved.
+/* ========================================================================= */
+/* === AMD_1 =============================================================== */
+/* ========================================================================= */
+
+/* ------------------------------------------------------------------------- */
+/* AMD, Copyright (c) Timothy A. Davis,                                      */
+/* Patrick R. Amestoy, and Iain S. Duff.  See ../README.txt for License.     */
+/* email: davis at cise.ufl.edu    CISE Department, Univ. of Florida.        */
+/* web: http://www.cise.ufl.edu/research/sparse/amd                          */
+/* ------------------------------------------------------------------------- */
+
+/* AMD_1: Construct A+A' for a sparse matrix A and perform the AMD ordering.
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *  This product includes software developed by the University of
- *  California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
+ * The n-by-n sparse matrix A can be unsymmetric.  It is stored in MATLAB-style
+ * compressed-column form, with sorted row indices in each column, and no
+ * duplicate entries.  Diagonal entries may be present, but they are ignored.
+ * Row indices of column j of A are stored in Ai [Ap [j] ... Ap [j+1]-1].
+ * Ap [0] must be zero, and nz = Ap [n] is the number of entries in A.  The
+ * size of the matrix, n, must be greater than or equal to zero.
  *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "igraph_qsort.h"
-
-#ifdef _MSC_VER
-    /* MSVC does not have inline when compiling C source files */
-    #define inline __inline
-    #define __unused
-#endif
-
-#ifndef __unused
-    #define __unused    __attribute__ ((unused))
-#endif
-
-#if defined(LIBC_SCCS) && !defined(lint)
-    static char sccsid[] = "@(#)qsort.c	8.1 (Berkeley) 6/4/93";
-#endif /* LIBC_SCCS and not lint */
-/*#include <sys/cdefs.h> */
-
-#include <stdlib.h>
-
-#ifdef I_AM_QSORT_R
-    typedef int      cmp_t(void *, const void *, const void *);
-#else
-    typedef int      cmp_t(const void *, const void *);
-#endif
-static inline char  *med3(char *, char *, char *, cmp_t *, void *);
-static inline void   swapfunc(char *, char *, int, int);
-
-#define igraph_min(a, b)    (a) < (b) ? a : b
-
-/*
- * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
+ * This routine must be preceded by a call to AMD_aat, which computes the
+ * number of entries in each row/column in A+A', excluding the diagonal.
+ * Len [j], on input, is the number of entries in row/column j of A+A'.  This
+ * routine constructs the matrix A+A' and then calls AMD_2.  No error checking
+ * is performed (this was done in AMD_valid).
  */
-#define swapcode(TYPE, parmi, parmj, n) {       \
-        long i = (n) / sizeof (TYPE);           \
-        TYPE *pi = (TYPE *) (parmi);        \
-        TYPE *pj = (TYPE *) (parmj);        \
-        do {                        \
-            TYPE    t = *pi;        \
-            *pi++ = *pj;                \
-            *pj++ = t;              \
-        } while (--i > 0);              \
-    }
 
-#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
-                                   es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
+#include "amd_internal.h"
 
-static inline void
-swapfunc(char *a, char *b, int n, int swaptype)
+GLOBAL void AMD_1
+(
+    Int n,              /* n > 0 */
+    const Int Ap [ ],   /* input of size n+1, not modified */
+    const Int Ai [ ],   /* input of size nz = Ap [n], not modified */
+    Int P [ ],          /* size n output permutation */
+    Int Pinv [ ],       /* size n output inverse permutation */
+    Int Len [ ],        /* size n input, undefined on output */
+    Int slen,           /* slen >= sum (Len [0..n-1]) + 7n,
+                         * ideally slen = 1.2 * sum (Len) + 8n */
+    Int S [ ],          /* size slen workspace */
+    double Control [ ], /* input array of size AMD_CONTROL */
+    double Info [ ]     /* output array of size AMD_INFO */
+)
 {
-    if (swaptype <= 1)
-        swapcode(long, a, b, n)
-        else
-            swapcode(char, a, b, n)
-        }
-
-#define swap(a, b)                  \
-    if (swaptype == 0) {                \
-        long t = *(long *)(a);          \
-        *(long *)(a) = *(long *)(b);        \
-        *(long *)(b) = t;           \
-    } else                      \
-        swapfunc(a, b, es, swaptype)
-
-#define vecswap(a, b, n)    if ((n) > 0) swapfunc(a, b, n, swaptype)
-
-#ifdef I_AM_QSORT_R
-    #define CMP(t, x, y) (cmp((t), (x), (y)))
-#else
-    #define CMP(t, x, y) (cmp((x), (y)))
-#endif
-
-static inline char *
-med3(char *a, char *b, char *c, cmp_t *cmp, void *thunk)
-{
-    #ifndef I_AM_QSORT_R
-        IGRAPH_UNUSED(thunk);
-    #endif
-    return CMP(thunk, a, b) < 0 ?
-           (CMP(thunk, b, c) < 0 ? b : (CMP(thunk, a, c) < 0 ? c : a ))
-           : (CMP(thunk, b, c) > 0 ? b : (CMP(thunk, a, c) < 0 ? a : c ));
-}
+    Int i, j, k, p, pfree, iwlen, pj, p1, p2, pj2, *Iw, *Pe, *Nv, *Head,
+        *Elen, *Degree, *s, *W, *Sp, *Tp ;
 
-#ifdef I_AM_QSORT_R
-    void
-    igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
-#else
-    #define thunk NULL
-    void
-    igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)
-#endif
-{
-    char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
-    int d, r, swaptype, swap_cnt;
-
-loop:   SWAPINIT(a, es);
-    swap_cnt = 0;
-    if (n < 7) {
-        for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
-            for (pl = pm;
-                 pl > (char *)a && CMP(thunk, pl - es, pl) > 0;
-                 pl -= es) {
-                swap(pl, pl - es);
+    /* --------------------------------------------------------------------- */
+    /* construct the matrix for AMD_2 */
+    /* --------------------------------------------------------------------- */
+
+    ASSERT (n > 0) ;
+
+    iwlen = slen - 6*n ;
+    s = S ;
+    Pe = s ;        s += n ;
+    Nv = s ;        s += n ;
+    Head = s ;      s += n ;
+    Elen = s ;      s += n ;
+    Degree = s ;    s += n ;
+    W = s ;         s += n ;
+    Iw = s ;        s += iwlen ;
+
+    ASSERT (AMD_valid (n, n, Ap, Ai) == AMD_OK) ;
+
+    /* construct the pointers for A+A' */
+    Sp = Nv ;                   /* use Nv and W as workspace for Sp and Tp [ */
+    Tp = W ;
+    pfree = 0 ;
+    for (j = 0 ; j < n ; j++)
+    {
+        Pe [j] = pfree ;
+        Sp [j] = pfree ;
+        pfree += Len [j] ;
+    }
+
+    /* Note that this restriction on iwlen is slightly more restrictive than
+     * what is strictly required in AMD_2.  AMD_2 can operate with no elbow
+     * room at all, but it will be very slow.  For better performance, at
+     * least size-n elbow room is enforced. */
+    ASSERT (iwlen >= pfree + n) ;
+
+#ifndef NDEBUG
+    for (p = 0 ; p < iwlen ; p++) Iw [p] = EMPTY ;
+#endif
+
+    for (k = 0 ; k < n ; k++)
+    {
+        AMD_DEBUG1 (("Construct row/column k= "ID" of A+A'\n", k))  ;
+        p1 = Ap [k] ;
+        p2 = Ap [k+1] ;
+
+        /* construct A+A' */
+        for (p = p1 ; p < p2 ; )
+        {
+            /* scan the upper triangular part of A */
+            j = Ai [p] ;
+            ASSERT (j >= 0 && j < n) ;
+            if (j < k)
+            {
+                /* entry A (j,k) in the strictly upper triangular part */
+                ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;
+                ASSERT (Sp [k] < (k == n-1 ? pfree : Pe [k+1])) ;
+                Iw [Sp [j]++] = k ;
+                Iw [Sp [k]++] = j ;
+                p++ ;
             }
-        return;
-    }
-    pm = (char *)a + (n / 2) * es;
-    if (n > 7) {
-        pl = a;
-        pn = (char *)a + (n - 1) * es;
-        if (n > 40) {
-            d = (n / 8) * es;
-            pl = med3(pl, pl + d, pl + 2 * d, cmp, thunk);
-            pm = med3(pm - d, pm, pm + d, cmp, thunk);
-            pn = med3(pn - 2 * d, pn - d, pn, cmp, thunk);
-        }
-        pm = med3(pl, pm, pn, cmp, thunk);
-    }
-    swap(a, pm);
-    pa = pb = (char *)a + es;
-
-    pc = pd = (char *)a + (n - 1) * es;
-    for (;;) {
-        while (pb <= pc && (r = CMP(thunk, pb, a)) <= 0) {
-            if (r == 0) {
-                swap_cnt = 1;
-                swap(pa, pb);
-                pa += es;
+            else if (j == k)
+            {
+                /* skip the diagonal */
+                p++ ;
+                break ;
             }
-            pb += es;
-        }
-        while (pb <= pc && (r = CMP(thunk, pc, a)) >= 0) {
-            if (r == 0) {
-                swap_cnt = 1;
-                swap(pc, pd);
-                pd -= es;
+            else /* j > k */
+            {
+                /* first entry below the diagonal */
+                break ;
             }
-            pc -= es;
-        }
-        if (pb > pc) {
-            break;
+            /* scan lower triangular part of A, in column j until reaching
+             * row k.  Start where last scan left off. */
+            ASSERT (Ap [j] <= Tp [j] && Tp [j] <= Ap [j+1]) ;
+            pj2 = Ap [j+1] ;
+            for (pj = Tp [j] ; pj < pj2 ; )
+            {
+                i = Ai [pj] ;
+                ASSERT (i >= 0 && i < n) ;
+                if (i < k)
+                {
+                    /* A (i,j) is only in the lower part, not in upper */
+                    ASSERT (Sp [i] < (i == n-1 ? pfree : Pe [i+1])) ;
+                    ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;
+                    Iw [Sp [i]++] = j ;
+                    Iw [Sp [j]++] = i ;
+                    pj++ ;
+                }
+                else if (i == k)
+                {
+                    /* entry A (k,j) in lower part and A (j,k) in upper */
+                    pj++ ;
+                    break ;
+                }
+                else /* i > k */
+                {
+                    /* consider this entry later, when k advances to i */
+                    break ;
+                }
+            }
+            Tp [j] = pj ;
         }
-        swap(pb, pc);
-        swap_cnt = 1;
-        pb += es;
-        pc -= es;
+        Tp [k] = p ;
     }
-    if (swap_cnt == 0) {  /* Switch to insertion sort */
-        for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
-            for (pl = pm;
-                 pl > (char *)a && CMP(thunk, pl - es, pl) > 0;
-                 pl -= es) {
-                swap(pl, pl - es);
-            }
-        return;
+
+    /* clean up, for remaining mismatched entries */
+    for (j = 0 ; j < n ; j++)
+    {
+        for (pj = Tp [j] ; pj < Ap [j+1] ; pj++)
+        {
+            i = Ai [pj] ;
+            ASSERT (i >= 0 && i < n) ;
+            /* A (i,j) is only in the lower part, not in upper */
+            ASSERT (Sp [i] < (i == n-1 ? pfree : Pe [i+1])) ;
+            ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;
+            Iw [Sp [i]++] = j ;
+            Iw [Sp [j]++] = i ;
+        }
     }
 
-    pn = (char *)a + n * es;
-    r = igraph_min(pa - (char *)a, pb - pa);
-    vecswap(a, pb - r, r);
-    r = igraph_min((size_t)(pd - pc), (size_t)(pn - pd - es));
-    vecswap(pb, pn - r, r);
-    if ((size_t)(r = pb - pa) > es)
-#ifdef I_AM_QSORT_R
-        igraph_qsort_r(a, r / es, es, thunk, cmp);
-#else
-        igraph_qsort(a, r / es, es, cmp);
+#ifndef NDEBUG
+    for (j = 0 ; j < n-1 ; j++) ASSERT (Sp [j] == Pe [j+1]) ;
+    ASSERT (Sp [n-1] == pfree) ;
 #endif
-    if ((size_t)(r = pd - pc) > es) {
-        /* Iterate rather than recurse to save stack space */
-        a = pn - r;
-        n = r / es;
-        goto loop;
-    }
-    /*      qsort(pn - r, r / es, es, cmp);*/
+
+    /* Tp and Sp no longer needed ] */
+
+    /* --------------------------------------------------------------------- */
+    /* order the matrix */
+    /* --------------------------------------------------------------------- */
+
+    AMD_2 (n, Pe, Iw, Len, iwlen, pfree,
+        Nv, Pinv, P, Head, Elen, Degree, W, Control, Info) ;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/internal/zeroin.c` & `igraph-0.9.9/vendor/source/igraph/src/internal/zeroin.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/dimacs.c` & `igraph-0.9.9/vendor/source/igraph/src/io/dimacs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/dl-header.h` & `igraph-0.9.9/vendor/source/igraph/src/io/dl-header.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/dl-lexer.l` & `igraph-0.9.9/vendor/source/igraph/src/io/dl-lexer.l`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/dl-parser.y` & `igraph-0.9.9/vendor/source/igraph/src/io/dl-parser.y`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/dl.c` & `igraph-0.9.9/vendor/source/igraph/src/io/dl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/dot.c` & `igraph-0.9.9/vendor/source/igraph/src/io/dot.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/edgelist.c` & `igraph-0.9.9/vendor/source/igraph/src/io/edgelist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/gml-header.h` & `igraph-0.9.9/vendor/source/igraph/src/io/gml-header.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/gml-lexer.l` & `igraph-0.9.9/vendor/source/igraph/src/io/gml-lexer.l`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/gml-parser.y` & `igraph-0.9.9/vendor/source/igraph/src/io/gml-parser.y`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/gml-tree.c` & `igraph-0.9.9/vendor/source/igraph/src/io/gml-tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/gml-tree.h` & `igraph-0.9.9/vendor/source/igraph/src/io/gml-tree.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/gml.c` & `igraph-0.9.9/vendor/source/igraph/src/io/gml.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/graphdb.c` & `igraph-0.9.9/vendor/source/igraph/src/io/graphdb.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/graphml.c` & `igraph-0.9.9/vendor/source/igraph/src/io/graphml.c`

 * *Files 4% similar despite different names*

```diff
@@ -68,15 +68,14 @@
     1
 };
 
 xmlEntityPtr blankEntity = &blankEntityStruct;
 
 #define GRAPHML_PARSE_ERROR_WITH_CODE(state, msg, code) do {  \
         if (state->successful) {                                    \
-            igraph_error(msg, IGRAPH_FILE_BASENAME, __LINE__, code);              \
             igraph_i_graphml_sax_handler_error(state, msg);           \
         }                                                           \
     } while (0)
 #define GRAPHML_PARSE_ERROR(state, msg) \
     GRAPHML_PARSE_ERROR_WITH_CODE(state, msg, IGRAPH_PARSEERROR)
 #define RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, msg, code) do {  \
         GRAPHML_PARSE_ERROR_WITH_CODE(state, msg, code);            \
@@ -110,15 +109,16 @@
     igraph_t *g;
     igraph_trie_t node_trie;
     igraph_strvector_t edgeids;
     igraph_vector_t edgelist;
     igraph_vector_int_t prev_state_stack;
     unsigned int unknown_depth;
     int index;
-    igraph_bool_t successful, edges_directed, destroyed;
+    igraph_bool_t successful;
+    igraph_bool_t edges_directed;
     igraph_trie_t v_names;
     igraph_vector_ptr_t v_attrs;
     igraph_trie_t e_names;
     igraph_vector_ptr_t e_attrs;
     igraph_trie_t g_names;
     igraph_vector_ptr_t g_attrs;
     igraph_i_graphml_attribute_record_t* current_attr_record;
@@ -180,78 +180,128 @@
         if (rec->record.value != 0) {
             igraph_vector_destroy((igraph_vector_t*)rec->record.value);
             IGRAPH_FREE(rec->record.value);
         }
     } else if (rec->record.type == IGRAPH_ATTRIBUTE_STRING) {
         if (rec->record.value != 0) {
             igraph_strvector_destroy((igraph_strvector_t*)rec->record.value);
-            if (rec->default_value.as_string != 0) {
-                IGRAPH_FREE(rec->default_value.as_string);
-            }
             IGRAPH_FREE(rec->record.value);
         }
+        if (rec->default_value.as_string != 0) {
+            IGRAPH_FREE(rec->default_value.as_string);
+        }
     } else if (rec->record.type == IGRAPH_ATTRIBUTE_BOOLEAN) {
         if (rec->record.value != 0) {
             igraph_vector_bool_destroy((igraph_vector_bool_t*)rec->record.value);
             IGRAPH_FREE(rec->record.value);
         }
     }
     if (rec->id != 0) {
         IGRAPH_FREE(rec->id);
     }
     if (rec->record.name != 0) {
         IGRAPH_FREE(rec->record.name);
     }
 }
 
-static void igraph_i_graphml_destroy_state(struct igraph_i_graphml_parser_state* state) {
-    if (state->destroyed) {
-        return;
-    }
-    state->destroyed = 1;
+static int igraph_i_graphml_parser_state_init(struct igraph_i_graphml_parser_state* state, igraph_t* graph, int index) {
+    memset(state, 0, sizeof(struct igraph_i_graphml_parser_state));
+
+    state->g = graph;
+    state->index = index < 0 ? 0 : index;
+    state->successful = 1;
+    state->error_message = NULL;
+
+    IGRAPH_CHECK(igraph_vector_int_init(&state->prev_state_stack, 0));
+    IGRAPH_CHECK(igraph_vector_int_reserve(&state->prev_state_stack, 32));
+    IGRAPH_FINALLY(igraph_vector_int_destroy, &state->prev_state_stack);
+
+    IGRAPH_CHECK(igraph_vector_ptr_init(&state->v_attrs, 0));
+    IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&state->v_attrs,
+                                          igraph_i_graphml_attribute_record_destroy);
+    IGRAPH_FINALLY(igraph_vector_ptr_destroy_all, &state->v_attrs);
+
+    IGRAPH_CHECK(igraph_vector_ptr_init(&state->e_attrs, 0));
+    IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&state->e_attrs,
+                                          igraph_i_graphml_attribute_record_destroy);
+    IGRAPH_FINALLY(igraph_vector_ptr_destroy_all, &state->e_attrs);
 
+    IGRAPH_CHECK(igraph_vector_ptr_init(&state->g_attrs, 0));
+    IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&state->g_attrs,
+                                          igraph_i_graphml_attribute_record_destroy);
+    IGRAPH_FINALLY(igraph_vector_ptr_destroy_all, &state->g_attrs);
+
+    IGRAPH_CHECK(igraph_vector_init(&state->edgelist, 0));
+    IGRAPH_FINALLY(igraph_vector_destroy, &state->edgelist);
+
+    IGRAPH_CHECK(igraph_trie_init(&state->node_trie, 1));
+    IGRAPH_FINALLY(igraph_trie_destroy, &state->node_trie);
+
+    IGRAPH_CHECK(igraph_strvector_init(&state->edgeids, 0));
+    IGRAPH_FINALLY(igraph_strvector_destroy, &state->edgeids);
+
+    IGRAPH_CHECK(igraph_trie_init(&state->v_names, 0));
+    IGRAPH_FINALLY(igraph_trie_destroy, &state->v_names);
+
+    IGRAPH_CHECK(igraph_trie_init(&state->e_names, 0));
+    IGRAPH_FINALLY(igraph_trie_destroy, &state->e_names);
+
+    IGRAPH_CHECK(igraph_trie_init(&state->g_names, 0));
+
+    IGRAPH_FINALLY_CLEAN(9);
+
+    return IGRAPH_SUCCESS;
+}
+
+static void igraph_i_graphml_parser_state_destroy(struct igraph_i_graphml_parser_state* state) {
     igraph_trie_destroy(&state->node_trie);
     igraph_strvector_destroy(&state->edgeids);
     igraph_trie_destroy(&state->v_names);
     igraph_trie_destroy(&state->e_names);
     igraph_trie_destroy(&state->g_names);
     igraph_vector_destroy(&state->edgelist);
     igraph_vector_int_destroy(&state->prev_state_stack);
 
-    if (state->error_message) {
-        free(state->error_message);
-    }
+    igraph_vector_ptr_destroy_all(&state->v_attrs);
+    igraph_vector_ptr_destroy_all(&state->e_attrs);
+    igraph_vector_ptr_destroy_all(&state->g_attrs);
+
     if (state->data_key) {
         free(state->data_key);
+        state->data_key = NULL;
     }
     if (state->data_char) {
         free(state->data_char);
+        state->data_char = NULL;
     }
 
-    igraph_vector_ptr_destroy_all(&state->v_attrs);
-    igraph_vector_ptr_destroy_all(&state->e_attrs);
-    igraph_vector_ptr_destroy_all(&state->g_attrs);
-
-    IGRAPH_FINALLY_CLEAN(1);
+    if (state->error_message) {
+        free(state->error_message);
+        state->error_message = NULL;
+    }
 }
 
 static void igraph_i_graphml_sax_handler_error(void *state0, const char* msg, ...) {
     struct igraph_i_graphml_parser_state *state =
         (struct igraph_i_graphml_parser_state*)state0;
+    const size_t max_error_message_length = 4096;
+
     va_list ap;
 
     va_start(ap, msg);
 
     if (state->error_message == 0) {
-        state->error_message = IGRAPH_CALLOC(4096, char);
+        /* ownership of state->error_message passed on immediately to
+         * state so the state destructor is responsible for freeing it */
+        state->error_message = IGRAPH_CALLOC(max_error_message_length, char);
     }
 
     state->successful = 0;
     state->st = ERROR;
-    vsnprintf(state->error_message, 4096, msg, ap);
+    vsnprintf(state->error_message, max_error_message_length, msg, ap);
 
     va_end(ap);
 }
 
 static xmlEntityPtr igraph_i_graphml_sax_handler_get_entity(void *state0,
         const xmlChar* name) {
     xmlEntityPtr predef = xmlGetPredefinedEntity(name);
@@ -272,288 +322,192 @@
         state->unknown_depth++;
     }
 }
 
 static void igraph_i_graphml_sax_handler_start_document(void *state0) {
     struct igraph_i_graphml_parser_state *state =
         (struct igraph_i_graphml_parser_state*)state0;
-    int ret;
 
     state->st = START;
     state->successful = 1;
     state->edges_directed = 0;
-    state->destroyed = 0;
-    state->data_key = 0;
-    state->error_message = 0;
-    state->data_char = 0;
+    state->data_key = NULL;
+    state->data_char = NULL;
     state->unknown_depth = 0;
     state->ignore_namespaces = 0;
-
-    ret = igraph_vector_int_init(&state->prev_state_stack, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    ret = igraph_vector_int_reserve(&state->prev_state_stack, 32);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &state->prev_state_stack);
-
-    ret = igraph_vector_ptr_init(&state->v_attrs, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&state->v_attrs,
-                                          igraph_i_graphml_attribute_record_destroy);
-    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &state->v_attrs);
-
-    ret = igraph_vector_ptr_init(&state->e_attrs, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&state->e_attrs,
-                                          igraph_i_graphml_attribute_record_destroy);
-    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &state->e_attrs);
-
-    ret = igraph_vector_ptr_init(&state->g_attrs, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_VECTOR_PTR_SET_ITEM_DESTRUCTOR(&state->g_attrs,
-                                          igraph_i_graphml_attribute_record_destroy);
-    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &state->g_attrs);
-
-    ret = igraph_vector_init(&state->edgelist, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_FINALLY(igraph_vector_destroy, &state->edgelist);
-
-    ret = igraph_trie_init(&state->node_trie, 1);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_FINALLY(igraph_trie_destroy, &state->node_trie);
-
-    ret = igraph_strvector_init(&state->edgeids, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_FINALLY(igraph_strvector_destroy, &state->edgeids);
-
-    ret = igraph_trie_init(&state->v_names, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_FINALLY(igraph_trie_destroy, &state->v_names);
-
-    ret = igraph_trie_init(&state->e_names, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_FINALLY(igraph_trie_destroy, &state->e_names);
-
-    ret = igraph_trie_init(&state->g_names, 0);
-    if (ret) {
-        RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", ret);
-    }
-    IGRAPH_FINALLY(igraph_trie_destroy, &state->g_names);
-
-    IGRAPH_FINALLY_CLEAN(10);
-    IGRAPH_FINALLY(igraph_i_graphml_destroy_state, state);
 }
 
-static void igraph_i_graphml_sax_handler_end_document(void *state0) {
-    struct igraph_i_graphml_parser_state *state =
-        (struct igraph_i_graphml_parser_state*)state0;
+static int igraph_i_graphml_parser_state_finish_parsing(struct igraph_i_graphml_parser_state *state) {
     long i, l;
-    int r;
     igraph_attribute_record_t idrec, eidrec;
     const char *idstr = "id";
     igraph_bool_t already_has_vertex_id = 0, already_has_edge_id = 0;
-
-    if (!state->successful) {
-        return;
+    igraph_vector_ptr_t vattr, eattr, gattr;
+    long int esize;
+    const void **tmp;
+
+    IGRAPH_ASSERT(state->successful);
+
+    /* check that we have found and parsed the graph the user is interested in */
+    IGRAPH_ASSERT(state->index < 0);
+
+    IGRAPH_CHECK(igraph_vector_ptr_init(&vattr, igraph_vector_ptr_size(&state->v_attrs) + 1));
+    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &vattr);
+
+    esize = igraph_vector_ptr_size(&state->e_attrs);
+    if (igraph_strvector_size(&state->edgeids) != 0) {
+        esize++;
+    }
+    IGRAPH_CHECK(igraph_vector_ptr_init(&eattr, esize));
+    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &eattr);
+
+    IGRAPH_CHECK(igraph_vector_ptr_init(&gattr, igraph_vector_ptr_size(&state->g_attrs)));
+    IGRAPH_FINALLY(igraph_vector_ptr_destroy, &gattr);
+
+    for (i = 0; i < igraph_vector_ptr_size(&state->v_attrs); i++) {
+        igraph_i_graphml_attribute_record_t *graphmlrec =
+            VECTOR(state->v_attrs)[i];
+        igraph_attribute_record_t *rec = &graphmlrec->record;
+
+        /* Check that the name of the vertex attribute is not 'id'.
+        If it is then we cannot the complimentary 'id' attribute. */
+        if (! strcmp(rec->name, idstr)) {
+            already_has_vertex_id = 1;
+        }
+
+        if (rec->type == IGRAPH_ATTRIBUTE_NUMERIC) {
+            igraph_vector_t *vec = (igraph_vector_t*)rec->value;
+            long int origsize = igraph_vector_size(vec);
+            long int nodes = igraph_trie_size(&state->node_trie);
+            IGRAPH_CHECK(igraph_vector_resize(vec, nodes));
+            for (l = origsize; l < nodes; l++) {
+                VECTOR(*vec)[l] = graphmlrec->default_value.as_numeric;
+            }
+        } else if (rec->type == IGRAPH_ATTRIBUTE_STRING) {
+            igraph_strvector_t *strvec = (igraph_strvector_t*)rec->value;
+            long int origsize = igraph_strvector_size(strvec);
+            long int nodes = igraph_trie_size(&state->node_trie);
+            IGRAPH_CHECK(igraph_strvector_resize(strvec, nodes));
+            for (l = origsize; l < nodes; l++) {
+                IGRAPH_CHECK(igraph_strvector_set(strvec, l, graphmlrec->default_value.as_string));
+            }
+        } else if (rec->type == IGRAPH_ATTRIBUTE_BOOLEAN) {
+            igraph_vector_bool_t *boolvec = (igraph_vector_bool_t*)rec->value;
+            long int origsize = igraph_vector_bool_size(boolvec);
+            long int nodes = igraph_trie_size(&state->node_trie);
+            IGRAPH_CHECK(igraph_vector_bool_resize(boolvec, nodes));
+            for (l = origsize; l < nodes; l++) {
+                VECTOR(*boolvec)[l] = graphmlrec->default_value.as_boolean;
+            }
+        }
+        VECTOR(vattr)[i] = rec;
+    }
+    if (!already_has_vertex_id) {
+        idrec.name = idstr;
+        idrec.type = IGRAPH_ATTRIBUTE_STRING;
+        tmp = &idrec.value;
+        IGRAPH_CHECK(igraph_trie_getkeys(&state->node_trie, (const igraph_strvector_t **)tmp));
+        VECTOR(vattr)[i] = &idrec;
+    } else {
+        igraph_vector_ptr_pop_back(&vattr);
     }
 
-    if (state->index < 0) {
-
-        igraph_vector_ptr_t vattr, eattr, gattr;
-        long int esize = igraph_vector_ptr_size(&state->e_attrs);
-        const void **tmp;
-        r = igraph_vector_ptr_init(&vattr,
-                                   igraph_vector_ptr_size(&state->v_attrs) + 1);
-        if (r) {
-            igraph_error("Cannot parse GraphML file", IGRAPH_FILE_BASENAME, __LINE__, r);
-            igraph_i_graphml_sax_handler_error(state, "Cannot parse GraphML file");
-            return;
-        }
-        IGRAPH_FINALLY(igraph_vector_ptr_destroy, &vattr);
-        if (igraph_strvector_size(&state->edgeids) != 0) {
-            esize++;
-        }
-        r = igraph_vector_ptr_init(&eattr, esize);
-        if (r) {
-            igraph_error("Cannot parse GraphML file", IGRAPH_FILE_BASENAME, __LINE__, r);
-            igraph_i_graphml_sax_handler_error(state, "Cannot parse GraphML file");
-            return;
-        }
-        IGRAPH_FINALLY(igraph_vector_ptr_destroy, &eattr);
-        r = igraph_vector_ptr_init(&gattr, igraph_vector_ptr_size(&state->g_attrs));
-        if (r) {
-            igraph_error("Cannot parse GraphML file", IGRAPH_FILE_BASENAME, __LINE__, r);
-            igraph_i_graphml_sax_handler_error(state, "Cannot parse GraphML file");
-            return;
-        }
-        IGRAPH_FINALLY(igraph_vector_ptr_destroy, &gattr);
-
-        for (i = 0; i < igraph_vector_ptr_size(&state->v_attrs); i++) {
-            igraph_i_graphml_attribute_record_t *graphmlrec =
-                VECTOR(state->v_attrs)[i];
-            igraph_attribute_record_t *rec = &graphmlrec->record;
-
-            /* Check that the name of the vertex attribute is not 'id'.
-            If it is then we cannot the complimentary 'id' attribute. */
-            if (! strcmp(rec->name, idstr)) {
-                already_has_vertex_id = 1;
-            }
-
-            if (rec->type == IGRAPH_ATTRIBUTE_NUMERIC) {
-                igraph_vector_t *vec = (igraph_vector_t*)rec->value;
-                long int origsize = igraph_vector_size(vec);
-                long int nodes = igraph_trie_size(&state->node_trie);
-                igraph_vector_resize(vec, nodes);
-                for (l = origsize; l < nodes; l++) {
-                    VECTOR(*vec)[l] = graphmlrec->default_value.as_numeric;
-                }
-            } else if (rec->type == IGRAPH_ATTRIBUTE_STRING) {
-                igraph_strvector_t *strvec = (igraph_strvector_t*)rec->value;
-                long int origsize = igraph_strvector_size(strvec);
-                long int nodes = igraph_trie_size(&state->node_trie);
-                igraph_strvector_resize(strvec, nodes);
-                for (l = origsize; l < nodes; l++) {
-                    igraph_strvector_set(strvec, l, graphmlrec->default_value.as_string);
-                }
-            } else if (rec->type == IGRAPH_ATTRIBUTE_BOOLEAN) {
-                igraph_vector_bool_t *boolvec = (igraph_vector_bool_t*)rec->value;
-                long int origsize = igraph_vector_bool_size(boolvec);
-                long int nodes = igraph_trie_size(&state->node_trie);
-                igraph_vector_bool_resize(boolvec, nodes);
-                for (l = origsize; l < nodes; l++) {
-                    VECTOR(*boolvec)[l] = graphmlrec->default_value.as_boolean;
-                }
+    for (i = 0; i < igraph_vector_ptr_size(&state->e_attrs); i++) {
+        igraph_i_graphml_attribute_record_t *graphmlrec =
+            VECTOR(state->e_attrs)[i];
+        igraph_attribute_record_t *rec = &graphmlrec->record;
+
+        if (! strcmp(rec->name, idstr)) {
+            already_has_edge_id = 1;
+        }
+
+        if (rec->type == IGRAPH_ATTRIBUTE_NUMERIC) {
+            igraph_vector_t *vec = (igraph_vector_t*)rec->value;
+            long int origsize = igraph_vector_size(vec);
+            long int edges = igraph_vector_size(&state->edgelist) / 2;
+            IGRAPH_CHECK(igraph_vector_resize(vec, edges));
+            for (l = origsize; l < edges; l++) {
+                VECTOR(*vec)[l] = graphmlrec->default_value.as_numeric;
+            }
+        } else if (rec->type == IGRAPH_ATTRIBUTE_STRING) {
+            igraph_strvector_t *strvec = (igraph_strvector_t*)rec->value;
+            long int origsize = igraph_strvector_size(strvec);
+            long int edges = igraph_vector_size(&state->edgelist) / 2;
+            IGRAPH_CHECK(igraph_strvector_resize(strvec, edges));
+            for (l = origsize; l < edges; l++) {
+                IGRAPH_CHECK(igraph_strvector_set(strvec, l, graphmlrec->default_value.as_string));
+            }
+        } else if (rec->type == IGRAPH_ATTRIBUTE_BOOLEAN) {
+            igraph_vector_bool_t *boolvec = (igraph_vector_bool_t*)rec->value;
+            long int origsize = igraph_vector_bool_size(boolvec);
+            long int edges = igraph_vector_size(&state->edgelist) / 2;
+            IGRAPH_CHECK(igraph_vector_bool_resize(boolvec, edges));
+            for (l = origsize; l < edges; l++) {
+                VECTOR(*boolvec)[l] = graphmlrec->default_value.as_boolean;
+            }
+        }
+        VECTOR(eattr)[i] = rec;
+    }
+    if (igraph_strvector_size(&state->edgeids) != 0) {
+        if (!already_has_edge_id) {
+            long int origsize = igraph_strvector_size(&state->edgeids);
+            eidrec.name = idstr;
+            eidrec.type = IGRAPH_ATTRIBUTE_STRING;
+            IGRAPH_CHECK(igraph_strvector_resize(&state->edgeids, igraph_vector_size(&state->edgelist) / 2));
+            for (; origsize < igraph_strvector_size(&state->edgeids); origsize++) {
+                IGRAPH_CHECK(igraph_strvector_set(&state->edgeids, origsize, ""));
             }
-            VECTOR(vattr)[i] = rec;
-        }
-        if (!already_has_vertex_id) {
-            idrec.name = idstr;
-            idrec.type = IGRAPH_ATTRIBUTE_STRING;
-            tmp = &idrec.value;
-            igraph_trie_getkeys(&state->node_trie, (const igraph_strvector_t **)tmp);
-            VECTOR(vattr)[i] = &idrec;
+            eidrec.value = &state->edgeids;
+            VECTOR(eattr)[(long int)igraph_vector_ptr_size(&eattr) - 1] = &eidrec;
         } else {
-            igraph_vector_ptr_pop_back(&vattr);
+            igraph_vector_ptr_pop_back(&eattr);
+            IGRAPH_WARNING("Could not add edge ids, "
+                            "there is already an 'id' edge attribute");
         }
-
-        for (i = 0; i < igraph_vector_ptr_size(&state->e_attrs); i++) {
-            igraph_i_graphml_attribute_record_t *graphmlrec =
-                VECTOR(state->e_attrs)[i];
-            igraph_attribute_record_t *rec = &graphmlrec->record;
-
-            if (! strcmp(rec->name, idstr)) {
-                already_has_edge_id = 1;
-            }
-
-            if (rec->type == IGRAPH_ATTRIBUTE_NUMERIC) {
-                igraph_vector_t *vec = (igraph_vector_t*)rec->value;
-                long int origsize = igraph_vector_size(vec);
-                long int edges = igraph_vector_size(&state->edgelist) / 2;
-                igraph_vector_resize(vec, edges);
-                for (l = origsize; l < edges; l++) {
-                    VECTOR(*vec)[l] = graphmlrec->default_value.as_numeric;
-                }
-            } else if (rec->type == IGRAPH_ATTRIBUTE_STRING) {
-                igraph_strvector_t *strvec = (igraph_strvector_t*)rec->value;
-                long int origsize = igraph_strvector_size(strvec);
-                long int edges = igraph_vector_size(&state->edgelist) / 2;
-                igraph_strvector_resize(strvec, edges);
-                for (l = origsize; l < edges; l++) {
-                    igraph_strvector_set(strvec, l, graphmlrec->default_value.as_string);
-                }
-            } else if (rec->type == IGRAPH_ATTRIBUTE_BOOLEAN) {
-                igraph_vector_bool_t *boolvec = (igraph_vector_bool_t*)rec->value;
-                long int origsize = igraph_vector_bool_size(boolvec);
-                long int edges = igraph_vector_size(&state->edgelist) / 2;
-                igraph_vector_bool_resize(boolvec, edges);
-                for (l = origsize; l < edges; l++) {
-                    VECTOR(*boolvec)[l] = graphmlrec->default_value.as_boolean;
-                }
-            }
-            VECTOR(eattr)[i] = rec;
-        }
-        if (igraph_strvector_size(&state->edgeids) != 0) {
-            if (!already_has_edge_id) {
-                long int origsize = igraph_strvector_size(&state->edgeids);
-                eidrec.name = idstr;
-                eidrec.type = IGRAPH_ATTRIBUTE_STRING;
-                igraph_strvector_resize(&state->edgeids,
-                                        igraph_vector_size(&state->edgelist) / 2);
-                for (; origsize < igraph_strvector_size(&state->edgeids); origsize++) {
-                    igraph_strvector_set(&state->edgeids, origsize, "");
-                }
-                eidrec.value = &state->edgeids;
-                VECTOR(eattr)[(long int)igraph_vector_ptr_size(&eattr) - 1] = &eidrec;
-            } else {
-                igraph_vector_ptr_pop_back(&eattr);
-                IGRAPH_WARNING("Could not add edge ids, "
-                               "there is already an 'id' edge attribute");
-            }
-        }
-
-        for (i = 0; i < igraph_vector_ptr_size(&state->g_attrs); i++) {
-            igraph_i_graphml_attribute_record_t *graphmlrec =
-                VECTOR(state->g_attrs)[i];
-            igraph_attribute_record_t *rec = &graphmlrec->record;
-            if (rec->type == IGRAPH_ATTRIBUTE_NUMERIC) {
-                igraph_vector_t *vec = (igraph_vector_t*)rec->value;
-                long int origsize = igraph_vector_size(vec);
-                igraph_vector_resize(vec, 1);
-                for (l = origsize; l < 1; l++) {
-                    VECTOR(*vec)[l] = graphmlrec->default_value.as_numeric;
-                }
-            } else if (rec->type == IGRAPH_ATTRIBUTE_STRING) {
-                igraph_strvector_t *strvec = (igraph_strvector_t*)rec->value;
-                long int origsize = igraph_strvector_size(strvec);
-                igraph_strvector_resize(strvec, 1);
-                for (l = origsize; l < 1; l++) {
-                    igraph_strvector_set(strvec, l, graphmlrec->default_value.as_string);
-                }
-            } else if (rec->type == IGRAPH_ATTRIBUTE_BOOLEAN) {
-                igraph_vector_bool_t *boolvec = (igraph_vector_bool_t*)rec->value;
-                long int origsize = igraph_vector_bool_size(boolvec);
-                igraph_vector_bool_resize(boolvec, 1);
-                for (l = origsize; l < 1; l++) {
-                    VECTOR(*boolvec)[l] = graphmlrec->default_value.as_boolean;
-                }
-            }
-            VECTOR(gattr)[i] = rec;
-        }
-
-        igraph_empty_attrs(state->g, 0, state->edges_directed, &gattr);
-        igraph_add_vertices(state->g, (igraph_integer_t)
-                            igraph_trie_size(&state->node_trie), &vattr);
-        igraph_add_edges(state->g, &state->edgelist, &eattr);
-
-        igraph_vector_ptr_destroy(&vattr);
-        igraph_vector_ptr_destroy(&eattr);
-        igraph_vector_ptr_destroy(&gattr);
-        IGRAPH_FINALLY_CLEAN(3);
     }
 
-    igraph_i_graphml_destroy_state(state);
+    for (i = 0; i < igraph_vector_ptr_size(&state->g_attrs); i++) {
+        igraph_i_graphml_attribute_record_t *graphmlrec =
+            VECTOR(state->g_attrs)[i];
+        igraph_attribute_record_t *rec = &graphmlrec->record;
+        if (rec->type == IGRAPH_ATTRIBUTE_NUMERIC) {
+            igraph_vector_t *vec = (igraph_vector_t*)rec->value;
+            long int origsize = igraph_vector_size(vec);
+            IGRAPH_CHECK(igraph_vector_resize(vec, 1));
+            for (l = origsize; l < 1; l++) {
+                VECTOR(*vec)[l] = graphmlrec->default_value.as_numeric;
+            }
+        } else if (rec->type == IGRAPH_ATTRIBUTE_STRING) {
+            igraph_strvector_t *strvec = (igraph_strvector_t*)rec->value;
+            long int origsize = igraph_strvector_size(strvec);
+            IGRAPH_CHECK(igraph_strvector_resize(strvec, 1));
+            for (l = origsize; l < 1; l++) {
+                IGRAPH_CHECK(igraph_strvector_set(strvec, l, graphmlrec->default_value.as_string));
+            }
+        } else if (rec->type == IGRAPH_ATTRIBUTE_BOOLEAN) {
+            igraph_vector_bool_t *boolvec = (igraph_vector_bool_t*)rec->value;
+            long int origsize = igraph_vector_bool_size(boolvec);
+            IGRAPH_CHECK(igraph_vector_bool_resize(boolvec, 1));
+            for (l = origsize; l < 1; l++) {
+                VECTOR(*boolvec)[l] = graphmlrec->default_value.as_boolean;
+            }
+        }
+        VECTOR(gattr)[i] = rec;
+    }
+
+    IGRAPH_CHECK(igraph_empty_attrs(state->g, 0, state->edges_directed, &gattr));
+    IGRAPH_CHECK(igraph_add_vertices(state->g, (igraph_integer_t) igraph_trie_size(&state->node_trie), &vattr));
+    IGRAPH_CHECK(igraph_add_edges(state->g, &state->edgelist, &eattr));
+
+    igraph_vector_ptr_destroy(&vattr);
+    igraph_vector_ptr_destroy(&eattr);
+    igraph_vector_ptr_destroy(&gattr);
+    IGRAPH_FINALLY_CLEAN(3);
+
+    return IGRAPH_SUCCESS;
 }
 
 #define toXmlChar(a)   (BAD_CAST(a))
 #define fromXmlChar(a) ((char *)(a)) /* not the most elegant way... */
 
 #define XML_ATTR_LOCALNAME(it) (*(it))
 #define XML_ATTR_PREFIX(it) (*(it+1))
@@ -563,16 +517,16 @@
 #define XML_ATTR_VALUE(it) *(it+3), (*(it+4))-(*(it+3))
 
 static igraph_i_graphml_attribute_record_t* igraph_i_graphml_add_attribute_key(
         const xmlChar** attrs, int nb_attrs,
         struct igraph_i_graphml_parser_state *state) {
     xmlChar **it;
     xmlChar *localname;
-    igraph_trie_t *trie = 0;
-    igraph_vector_ptr_t *ptrvector = 0;
+    igraph_trie_t *trie = NULL;
+    igraph_vector_ptr_t *ptrvector = NULL;
     long int id;
     unsigned short int skip = 0;
     int i, ret;
     igraph_i_graphml_attribute_record_t *rec;
 
     if (!state->successful) {
         return 0;
@@ -580,14 +534,15 @@
 
     rec = IGRAPH_CALLOC(1, igraph_i_graphml_attribute_record_t);
     if (rec == 0) {
         GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot parse GraphML file", IGRAPH_ENOMEM);
         return 0;
     }
     IGRAPH_FINALLY(igraph_free, rec);
+    IGRAPH_FINALLY(igraph_i_graphml_attribute_record_destroy, rec);
 
     rec->type = I_GRAPHML_UNKNOWN_TYPE;
 
     for (i = 0, it = (xmlChar**)attrs; i < nb_attrs; i++, it += 5) {
         if (XML_ATTR_URI(it) != 0 &&
             !xmlStrEqual(toXmlChar(GRAPHML_NAMESPACE_URI), XML_ATTR_URI(it))) {
             continue;
@@ -688,16 +643,17 @@
                             "Cannot parse GraphML file, missing 'for' attribute in a <key> tag");
         return 0;
     }
 
     /* if the code above requested skipping the attribute, free everything and
      * return */
     if (skip) {
+        igraph_i_graphml_attribute_record_destroy(rec);
         igraph_free(rec);
-        IGRAPH_FINALLY_CLEAN(1);
+        IGRAPH_FINALLY_CLEAN(2);
         return 0;
     }
 
     /* add to trie, attribues */
     igraph_trie_get(trie, rec->id, &id);
     if (id != igraph_trie_size(trie) - 1) {
         GRAPHML_PARSE_ERROR(state, "Cannot parse GraphML file, duplicate attribute");
@@ -708,15 +664,15 @@
     if (ret) {
         GRAPHML_PARSE_ERROR_WITH_CODE(state, "Cannot read GraphML file", ret);
         return 0;
     }
 
     /* Ownership of 'rec' is now taken by ptrvector so we can clean the
      * finally stack */
-    IGRAPH_FINALLY_CLEAN(1);  /* rec */
+    IGRAPH_FINALLY_CLEAN(2);  /* rec, destructor + igraph_free */
 
     /* create the attribute values */
     switch (rec->record.type) {
         igraph_vector_t *vec;
         igraph_vector_bool_t *boolvec;
         igraph_strvector_t *strvec;
     case IGRAPH_ATTRIBUTE_BOOLEAN:
@@ -773,15 +729,15 @@
             if (state->data_key) {
                 free(state->data_key);
             }
             state->data_key = xmlStrndup(XML_ATTR_VALUE(it));
             if (state->data_char) {
                 free(state->data_char);
             }
-            state->data_char = 0;
+            state->data_char = NULL;
             state->data_type = type;
         } else {
             /* ignore */
         }
     }
 }
 
@@ -807,16 +763,16 @@
            (size_t) len * sizeof(xmlChar));
     state->data_char[data_char_new_start + len] = '\0';
 }
 
 static void igraph_i_graphml_attribute_data_finish(struct igraph_i_graphml_parser_state *state) {
     const char *key = fromXmlChar(state->data_key);
     igraph_attribute_elemtype_t type = state->data_type;
-    igraph_trie_t *trie = 0;
-    igraph_vector_ptr_t *ptrvector = 0;
+    igraph_trie_t *trie = NULL;
+    igraph_vector_ptr_t *ptrvector = NULL;
     igraph_i_graphml_attribute_record_t *graphmlrec;
     igraph_attribute_record_t *rec;
     long int recid, id = 0;
     int ret;
 
     switch (type) {
     case IGRAPH_ATTRIBUTE_GRAPH:
@@ -837,19 +793,15 @@
     default:
         /* impossible */
         break;
     }
 
     if (key == 0) {
         /* no key specified, issue a warning */
-        igraph_warningf(
-            "missing attribute key in a <data> tag, ignoring attribute",
-            IGRAPH_FILE_BASENAME, __LINE__, 0,
-            key
-        );
+        IGRAPH_WARNING("missing attribute key in a <data> tag, ignoring attribute");
         IGRAPH_FREE(state->data_char);
         return;
     }
 
     igraph_trie_check(trie, key, &recid);
     if (recid < 0) {
         /* no such attribute key, issue a warning */
@@ -934,17 +886,18 @@
 }
 
 static void igraph_i_graphml_attribute_default_value_finish(
         struct igraph_i_graphml_parser_state *state) {
     igraph_i_graphml_attribute_record_t *graphmlrec = state->current_attr_record;
 
     if (graphmlrec == 0) {
-        igraph_warning("state->current_attr_record was null where it should have been "
-                       "non-null; this is probably a bug. Please notify the developers!",
-                       IGRAPH_FILE_BASENAME, __LINE__, 0);
+        IGRAPH_FATAL(
+            "state->current_attr_record was null where it should have been "
+            "non-null; please report as a bug."
+        );
         return;
     }
 
     if (state->data_char == 0) {
         return;
     }
 
@@ -1062,16 +1015,17 @@
             state->st = INSIDE_KEY;
         } else {
             igraph_i_graphml_handle_unknown_start_tag(state);
         }
         break;
 
     case INSIDE_KEY:
-        /* If we are in the INSIDE_KEY state, check for default tag */
-        if (xmlStrEqual(localname, toXmlChar("default"))) {
+        /* If we are in the INSIDE_KEY state and we are not skipping the current
+         * attribute, check for default tag */
+        if (state->current_attr_record != NULL && xmlStrEqual(localname, toXmlChar("default"))) {
             state->st = INSIDE_DEFAULT;
         } else {
             igraph_i_graphml_handle_unknown_start_tag(state);
         }
         break;
 
     case INSIDE_DEFAULT:
@@ -1203,15 +1157,15 @@
         break;
 
     case INSIDE_GRAPH:
         state->st = INSIDE_GRAPHML;
         break;
 
     case INSIDE_KEY:
-        state->current_attr_record = 0;
+        state->current_attr_record = NULL;
         state->st = INSIDE_GRAPHML;
         break;
 
     case INSIDE_DEFAULT:
         igraph_i_graphml_attribute_default_value_finish(state);
         state->st = INSIDE_KEY;
         break;
@@ -1274,15 +1228,15 @@
     /* entityDecl = */ 0,
     /* notationDecl = */ 0,
     /* attributeDecl = */ 0,
     /* elementDecl = */ 0,
     /* unparsedEntityDecl = */ 0,
     /* setDocumentLocator = */ 0,
     /* startDocument = */ igraph_i_graphml_sax_handler_start_document,
-    /* endDocument = */ igraph_i_graphml_sax_handler_end_document,
+    /* endDocument = */ 0,
     /* startElement = */ 0,
     /* endElement = */ 0,
     /* reference = */ 0,
     /* characters = */ igraph_i_graphml_sax_handler_chars,
     /* ignorableWhitespaceFunc = */ 0,
     /* processingInstruction = */ 0,
     /* comment = */ 0,
@@ -1382,32 +1336,33 @@
  *         problem reading the file, or the file is syntactically
  *         incorrect.
  *         \c IGRAPH_UNIMPLEMENTED: the GraphML functionality was disabled
  *         at compile-time
  *
  * \example examples/simple/graphml.c
  */
-int igraph_read_graph_graphml(igraph_t *graph, FILE *instream,
-                              int index) {
+int igraph_read_graph_graphml(igraph_t *graph, FILE *instream, int index) {
 
 #if HAVE_LIBXML == 1
     xmlParserCtxtPtr ctxt;
     struct igraph_i_graphml_parser_state state;
     int res;
     char buffer[4096];
+    igraph_bool_t parsing_successful;
+    char* error_message;
 
     if (index < 0) {
         IGRAPH_ERROR("Graph index must be non-negative", IGRAPH_EINVAL);
     }
 
     xmlInitParser();
+    IGRAPH_CHECK(igraph_i_graphml_parser_state_init(&state, graph, index));
+    IGRAPH_FINALLY(igraph_i_graphml_parser_state_destroy, &state);
 
     /* Create a progressive parser context */
-    state.g = graph;
-    state.index = index < 0 ? 0 : index;
     res = (int) fread(buffer, 1, 4096, instream);
     ctxt = xmlCreatePushParserCtxt(&igraph_i_graphml_sax_handler,
                                    &state,
                                    buffer,
                                    res,
                                    NULL);
     /*   ctxt=xmlCreateIOParserCtxt(&igraph_i_graphml_sax_handler, &state, */
@@ -1420,40 +1375,76 @@
 
     /* Set parsing options */
     if (xmlCtxtUseOptions(ctxt,
                           XML_PARSE_NOENT | XML_PARSE_NOBLANKS |
                           XML_PARSE_NONET | XML_PARSE_NSCLEAN |
                           XML_PARSE_NOCDATA | XML_PARSE_HUGE
                          )) {
+        xmlFreeParserCtxt(ctxt);
         IGRAPH_ERROR("Cannot set options for the parser context", IGRAPH_EINVAL);
     }
 
-    /* Parse the file */
+    /* Okay, parsing will start now. The parser might do things that eventually
+     * trigger the igraph error handler, but we want the parser state to
+     * survive whatever happens here. So, we need to pop off
+     * igraph_i_graphml_parser_state_destroy() from the stack and temporarily
+     * assume responsibility for calling it ourselves until we are back from the
+     * parser */
+    IGRAPH_FINALLY_CLEAN(1);
+
+    /* Do the parsing */
     while ((res = (int) fread(buffer, 1, 4096, instream)) > 0) {
         xmlParseChunk(ctxt, buffer, res, 0);
         if (!state.successful) {
             break;
         }
     }
     xmlParseChunk(ctxt, buffer, res, 1);
 
     /* Free the context */
     xmlFreeParserCtxt(ctxt);
-    if (!state.successful) {
-        if (state.error_message != 0) {
-            IGRAPH_ERROR(state.error_message, IGRAPH_PARSEERROR);
+
+    /* Extract the error message from the parser state (if any), and make a
+     * copy so we can safely destroy the parser state before triggering the
+     * error */
+    parsing_successful = state.successful;
+    error_message = parsing_successful || state.error_message == NULL ? NULL : strdup(state.error_message);
+
+    /* Now that we have lifted error_message out of the parser state, we can
+     * put the destructor of the parser state back on the FINALLY stack */
+    IGRAPH_FINALLY(igraph_i_graphml_parser_state_destroy, &state);
+
+    /* ...and we can also put the error message pointer on the FINALLY stack */
+    if (error_message != NULL) {
+        IGRAPH_FINALLY(free, error_message);
+    }
+
+    /* Trigger the stored error if needed */
+    if (!parsing_successful) {
+        if (error_message != NULL) {
+            IGRAPH_ERROR(error_message, IGRAPH_PARSEERROR);
         } else {
             IGRAPH_ERROR("Malformed GraphML file", IGRAPH_PARSEERROR);
         }
     }
+
+    /* Did we actually manage to reach the graph to be parsed, given its index?
+     * If not, that's an error as well. */
     if (state.index >= 0) {
         IGRAPH_ERROR("Graph index was too large", IGRAPH_EINVAL);
     }
 
-    return 0;
+    /* Okay, everything seems good. We can now take the parser state and
+     * construct our graph from the data gathered during the parsing */
+    IGRAPH_CHECK(igraph_i_graphml_parser_state_finish_parsing(&state));
+
+    igraph_i_graphml_parser_state_destroy(&state);
+    IGRAPH_FINALLY_CLEAN(1);
+
+    return IGRAPH_SUCCESS;
 #else
     IGRAPH_UNUSED(graph);
     IGRAPH_UNUSED(instream);
     IGRAPH_UNUSED(index);
 
     IGRAPH_ERROR("GraphML support is disabled", IGRAPH_UNIMPLEMENTED);
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/leda.c` & `igraph-0.9.9/vendor/source/igraph/src/io/leda.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/lgl-header.h` & `igraph-0.9.9/vendor/source/igraph/src/io/lgl-header.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/lgl-lexer.l` & `igraph-0.9.9/vendor/source/igraph/src/io/lgl-lexer.l`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/lgl-parser.y` & `igraph-0.9.9/vendor/source/igraph/src/io/lgl-parser.y`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/lgl.c` & `igraph-0.9.9/vendor/source/igraph/src/io/lgl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/ncol-header.h` & `igraph-0.9.9/vendor/source/igraph/src/io/ncol-header.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/ncol-lexer.l` & `igraph-0.9.9/vendor/source/igraph/src/io/ncol-lexer.l`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/ncol-parser.y` & `igraph-0.9.9/vendor/source/igraph/src/io/ncol-parser.y`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/ncol.c` & `igraph-0.9.9/vendor/source/igraph/src/io/ncol.c`

 * *Files 0% similar despite different names*

```diff
@@ -93,15 +93,15 @@
  * the time required by the parsing. As usual
  * |V| is the number of vertices,
  * while |E| is the number of edges.
  *
  * \sa \ref igraph_read_graph_lgl(), \ref igraph_write_graph_ncol()
  */
 int igraph_read_graph_ncol(igraph_t *graph, FILE *instream,
-                           igraph_strvector_t *predefnames,
+                           const igraph_strvector_t *predefnames,
                            igraph_bool_t names,
                            igraph_add_weights_t weights,
                            igraph_bool_t directed) {
 
     igraph_vector_t edges, ws;
     igraph_trie_t trie = IGRAPH_TRIE_NULL;
     igraph_integer_t no_of_nodes;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/pajek-header.h` & `igraph-0.9.9/vendor/source/igraph/src/io/pajek-header.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/pajek-lexer.l` & `igraph-0.9.9/vendor/source/igraph/src/io/pajek-lexer.l`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/pajek-parser.y` & `igraph-0.9.9/vendor/source/igraph/src/io/pajek-parser.y`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/pajek.c` & `igraph-0.9.9/vendor/source/igraph/src/io/pajek.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-lexer.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-lexer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-lexer.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-lexer.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-parser.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-parser.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/dl-parser.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/dl-parser.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-lexer.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-lexer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-lexer.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-lexer.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-parser.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-parser.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/gml-parser.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/gml-parser.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-lexer.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-lexer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-lexer.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-lexer.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-parser.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-parser.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/lgl-parser.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/lgl-parser.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-lexer.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-lexer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-lexer.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-lexer.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-parser.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-parser.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/ncol-parser.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/ncol-parser.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-lexer.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-lexer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-lexer.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-lexer.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-parser.c` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-parser.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/io/parsers/pajek-parser.h` & `igraph-0.9.9/vendor/source/igraph/src/io/parsers/pajek-parser.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/bignum.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/bignum.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/defs.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/defs.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/defs.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/defs.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/graph.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/graph.cc`

 * *Files 0% similar despite different names*

```diff
@@ -1495,14 +1495,17 @@
           child_node.long_prune_begin = current_node.long_prune_begin;
 
           /* Save component recursion info for backtracking */
           child_node.cr_level = cr_level;
           child_node.cr_cep_stack_size = cr_cep_stack.size();
           child_node.cr_cep_index = cr_cep_index;
 
+          /* Initialize needs_long_prune to prevent a gcc-ubsan warning */
+          child_node.needs_long_prune = true;
+
           search_stack.push_back(child_node);
           continue;
         }
 
       /*
        * A leaf node not in the first path or equivalent to the first path
        */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/graph.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/graph.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/heap.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/heap.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/heap.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/heap.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/igraph-changes.md` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/igraph-changes.md`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/kqueue.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/kqueue.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/kstack.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/kstack.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/orbit.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/orbit.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/orbit.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/orbit.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/partition.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/partition.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/partition.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/partition.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/stats.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/stats.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/uintseqhash.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/utils.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/utils.cc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss/utils.hh` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss/utils.hh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/bliss.cc` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/bliss.cc`

 * *Files 3% similar despite different names*

```diff
@@ -214,33 +214,39 @@
 };
 
 } // end unnamed namespace
 
 
 /**
  * \function igraph_canonical_permutation
- * Canonical permutation using Bliss
+ * \brief Canonical permutation using Bliss.
  *
- * This function computes the canonical permutation which transforms
- * the graph into a canonical form by using the Bliss algorithm.
+ * This function computes the vertex permutation which transforms
+ * the graph into a canonical form, using the Bliss algorithm.
+ * Two graphs have the same canonical form if and only if they
+ * are isomorphic. Use \ref igraph_is_same_graph() to compare
+ * two canonical forms.
  *
  * \param graph The input graph. Multiple edges between the same nodes
  *   are not supported and will cause an incorrect result to be returned.
  * \param colors An optional vertex color vector for the graph. Supply a
  *   null pointer is the graph is not colored.
  * \param labeling Pointer to a vector, the result is stored here. The
  *    permutation takes vertex 0 to the first element of the vector,
  *    vertex 1 to the second, etc. The vector will be resized as
  *    needed.
  * \param sh The splitting heuristics to be used in Bliss. See \ref
  *    igraph_bliss_sh_t.
  * \param info If not \c NULL then information on Bliss internals is
- *    stored here. See \ref igraph_bliss_info_t.
+ *    stored here. The memory used by this structure must to be freed
+ *    when no longer needed, see \ref igraph_bliss_info_t.
  * \return Error code.
  *
+ * \sa igraph_is_same_graph()
+ *
  * Time complexity: exponential, in practice it is fast for many graphs.
  */
 int igraph_canonical_permutation(const igraph_t *graph, const igraph_vector_int_t *colors,
                                  igraph_vector_t *labeling, igraph_bliss_sh_t sh, igraph_bliss_info_t *info) {
     IGRAPH_HANDLE_EXCEPTIONS(
         AbstractGraph *g = bliss_from_igraph(graph);
         IGRAPH_FINALLY(bliss_free_graph, g);
@@ -268,15 +274,15 @@
     );
 
     return IGRAPH_SUCCESS;
 }
 
 /**
  * \function igraph_automorphisms
- * Number of automorphisms using Bliss
+ * \brief Number of automorphisms using Bliss.
  *
  * The number of automorphisms of a graph is computed using Bliss. The
  * result is returned as part of the \p info structure, in tag \c
  * group_size. It is returned as a string, as it can be very high even
  * for relatively small graphs. If the GNU MP library is used then
  * this number is exact, otherwise a <type>long double</type> is used
  * and it is only approximate. See also \ref igraph_bliss_info_t.
@@ -284,15 +290,16 @@
  * \param graph The input graph. Multiple edges between the same nodes
  *   are not supported and will cause an incorrect result to be returned.
  * \param colors An optional vertex color vector for the graph. Supply a
  *   null pointer is the graph is not colored.
  * \param sh The splitting heuristics to be used in Bliss. See \ref
  *    igraph_bliss_sh_t.
  * \param info The result is stored here, in particular in the \c
- *    group_size tag of \p info.
+ *    group_size tag of \p info. The memory used by this structure must be
+ *    released when no longer needed, see \ref igraph_bliss_info_t.
  * \return Error code.
  *
  * Time complexity: exponential, in practice it is fast for many graphs.
  */
 int igraph_automorphisms(const igraph_t *graph, const igraph_vector_int_t *colors,
                          igraph_bliss_sh_t sh, igraph_bliss_info_t *info) {
     IGRAPH_HANDLE_EXCEPTIONS(
@@ -316,31 +323,33 @@
     );
 
     return IGRAPH_SUCCESS;
 }
 
 /**
  * \function igraph_automorphism_group
- * Automorphism group generators using Bliss
+ * \brief Automorphism group generators using Bliss.
  *
  * The generators of the automorphism group of a graph are computed
  * using Bliss. The generator set may not be minimal and may depend on
- * the splitting heuristics.
+ * the splitting heuristics. The generators are permutations represented
+ * using zero-based indexing.
  *
  * \param graph The input graph. Multiple edges between the same nodes
  *   are not supported and will cause an incorrect result to be returned.
  * \param colors An optional vertex color vector for the graph. Supply a
  *   null pointer is the graph is not colored.
  * \param generators Must be an initialized pointer vector. It will
  *    contain pointers to \ref igraph_vector_t objects
  *    representing generators of the automorphism group.
  * \param sh The splitting heuristics to be used in Bliss. See \ref
  *    igraph_bliss_sh_t.
  * \param info If not \c NULL then information on Bliss internals is
- *    stored here. See \ref igraph_bliss_info_t.
+ *    stored here. The memory used by this structure must to be freed
+ *    when no longer needed, see \ref igraph_bliss_info_t.
  * \return Error code.
  *
  * Time complexity: exponential, in practice it is fast for many graphs.
  */
 int igraph_automorphism_group(
     const igraph_t *graph, const igraph_vector_int_t *colors, igraph_vector_ptr_t *generators,
     igraph_bliss_sh_t sh, igraph_bliss_info_t *info) {
@@ -387,23 +396,26 @@
 
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
 
 /**
  * \function igraph_isomorphic_bliss
- * Graph isomorphism via Bliss
+ * \brief Graph isomorphism via Bliss.
  *
  * This function uses the Bliss graph isomorphism algorithm, a
  * successor of the famous NAUTY algorithm and implementation. Bliss
  * is open source and licensed according to the GNU LGPL. See
  * https://users.aalto.fi/~tjunttil/bliss/ for
  * details. Currently the 0.75 version of Bliss is included in igraph.
  *
  * </para><para>
+ * Isomorphism testing is implemented by producing the canonical form
+ * of both graphs using \ref igraph_canonical_permutation() and
+ * comparing them.
  *
  * \param graph1 The first input graph. Multiple edges between the same nodes
  *   are not supported and will cause an incorrect result to be returned.
  * \param graph2 The second input graph. Multiple edges between the same nodes
  *   are not supported and will cause an incorrect result to be returned.
  * \param colors1 An optional vertex color vector for the first graph. Supply a
  *   null pointer if your graph is not colored.
@@ -415,17 +427,19 @@
  *   If the input graphs are not isomorphic then this vector is
  *   cleared, i.e. it will have length zero.
  * \param map21 Similar to \p map12, but for the mapping from \p
  *   graph2 to \p graph1.
  * \param sh Splitting heuristics to be used for the graphs. See
  *   \ref igraph_bliss_sh_t.
  * \param info1 If not \c NULL, information about the canonization of
- *    the first input graph is stored here. See \ref igraph_bliss_info_t
- *    for details. Note that if the two graphs have different number
- *    of vertices or edges, then this is not filled.
+ *    the first input graph is stored here. Note that if the two graphs
+ *    have different number of vertices or edges, then this is only
+ *    partially filled. The memory used by this structure should be
+ *    released when no longer needed, see \ref igraph_bliss_info_t
+ *    for details.
  * \param info2 Same as \p info1, but for the second graph.
  * \return Error code.
  *
  * Time complexity: exponential, but in practice it is quite fast.
  */
 int igraph_isomorphic_bliss(const igraph_t *graph1, const igraph_t *graph2,
                             const igraph_vector_int_t *colors1, const igraph_vector_int_t *colors2,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/isoclasses.h` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/isoclasses.h`

 * *Files 2% similar despite different names*

```diff
@@ -24,23 +24,23 @@
 #ifndef IGRAPH_ISOCLASSES_H
 #define IGRAPH_ISOCLASSES_H
 
 #include "igraph_decls.h"
 
 __BEGIN_DECLS
 
-extern const unsigned int igraph_i_isoclass_3[];
-extern const unsigned int igraph_i_isoclass_4[];
-extern const unsigned int igraph_i_isoclass_3u[];
-extern const unsigned int igraph_i_isoclass_4u[];
 extern const unsigned int igraph_i_isoclass2_3[];
 extern const unsigned int igraph_i_isoclass2_4[];
 extern const unsigned int igraph_i_isoclass2_3u[];
 extern const unsigned int igraph_i_isoclass2_4u[];
+extern const unsigned int igraph_i_isoclass2_5u[];
+extern const unsigned int igraph_i_isoclass2_6u[];
 extern const unsigned int igraph_i_isoclass_3_idx[];
 extern const unsigned int igraph_i_isoclass_4_idx[];
 extern const unsigned int igraph_i_isoclass_3u_idx[];
 extern const unsigned int igraph_i_isoclass_4u_idx[];
+extern const unsigned int igraph_i_isoclass_5u_idx[];
+extern const unsigned int igraph_i_isoclass_6u_idx[];
 
 __END_DECLS
 
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/isomorphism_misc.c` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/isomorphism_misc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/lad.c` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/lad.c`

 * *Files 0% similar despite different names*

```diff
@@ -459,16 +459,16 @@
        is stronger than FC(diff), but this speeds up the solution process).
        return false if an inconsistency is detected by FC(Edges) or
        FC(diff); true otherwise; */
     igraph_vector_int_t toBeMatched;
     igraph_vector_int_init(&toBeMatched, Gp->nbVertices);
     IGRAPH_FINALLY(igraph_vector_int_destroy, &toBeMatched);
     VECTOR(toBeMatched)[0] = u;
-    igraph_i_lad_matchVertices(1, &toBeMatched, induced, D, Gp, Gt,
-                               &invalid);
+    IGRAPH_CHECK(igraph_i_lad_matchVertices(1, &toBeMatched, induced, D, Gp, Gt,
+                               &invalid));
     igraph_vector_int_destroy(&toBeMatched);
     IGRAPH_FINALLY_CLEAN(1);
 
     return invalid ? false : true;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/queries.c` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/queries.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/isomorphism/vf2.c` & `igraph-0.9.9/vendor/source/igraph/src/isomorphism/vf2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/circular.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/circular.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/davidson_harel.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/davidson_harel.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid.cpp` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid_3d.cpp` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid_3d.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/DensityGrid_3d.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/DensityGrid_3d.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_Node.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_Node.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_Node_3d.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_Node_3d.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph.cpp` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph_3d.cpp` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph_3d.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_graph_3d.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_graph_3d.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout.cpp` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -449,15 +449,15 @@
  * \return Error code.
  *
  * Time complexity: ???.
  */
 
 int igraph_layout_drl(const igraph_t *graph, igraph_matrix_t *res,
                       igraph_bool_t use_seed,
-                      igraph_layout_drl_options_t *options,
+                      const igraph_layout_drl_options_t *options,
                       const igraph_vector_t *weights,
                       const igraph_vector_bool_t *fixed) {
     const char msg[] = "Damping multipliers cannot be negative, got %f.";
 
     if (options->init_damping_mult < 0) {
         IGRAPH_ERRORF(msg, IGRAPH_EINVAL, options->init_damping_mult);
     }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout_3d.cpp` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout_3d.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -96,15 +96,15 @@
  * Time complexity: ???.
  *
  * \sa \ref igraph_layout_drl() for the standard 2d version.
  */
 
 int igraph_layout_drl_3d(const igraph_t *graph, igraph_matrix_t *res,
                          igraph_bool_t use_seed,
-                         igraph_layout_drl_options_t *options,
+                         const igraph_layout_drl_options_t *options,
                          const igraph_vector_t *weights,
                          const igraph_vector_bool_t *fixed) {
     IGRAPH_HANDLE_EXCEPTIONS(
         RNG_BEGIN();
 
         drl3d::graph neighbors(graph, options, weights);
         neighbors.init_parms(options);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_layout_3d.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_layout_3d.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_parse.cpp` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_parse.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/drl/drl_parse.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/drl/drl_parse.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/fruchterman_reingold.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/fruchterman_reingold.c`

 * *Files 0% similar despite different names*

```diff
@@ -24,14 +24,15 @@
 #include "igraph_layout.h"
 
 #include "igraph_random.h"
 #include "igraph_interface.h"
 #include "igraph_components.h"
 
 #include "core/grid.h"
+#include "core/interruption.h"
 
 static int igraph_layout_i_fr(const igraph_t *graph,
                               igraph_matrix_t *res,
                               igraph_bool_t use_seed,
                               igraph_integer_t niter,
                               igraph_real_t start_temp,
                               const igraph_vector_t *weight,
@@ -46,15 +47,15 @@
     igraph_vector_float_t dispx, dispy;
     igraph_real_t temp = start_temp;
     igraph_real_t difftemp = start_temp / niter;
     float width = sqrtf(no_nodes), height = width;
     igraph_bool_t conn = 1;
     float C = 0;
 
-    igraph_is_connected(graph, &conn, IGRAPH_WEAK);
+    IGRAPH_CHECK(igraph_is_connected(graph, &conn, IGRAPH_WEAK));
     if (!conn) {
         C = no_nodes * sqrtf(no_nodes);
     }
 
     RNG_BEGIN();
 
     if (!use_seed) {
@@ -85,14 +86,16 @@
     IGRAPH_FINALLY(igraph_vector_float_destroy, &dispx);
     IGRAPH_CHECK(igraph_vector_float_init(&dispy, no_nodes));
     IGRAPH_FINALLY(igraph_vector_float_destroy, &dispy);
 
     for (i = 0; i < niter; i++) {
         igraph_integer_t v, u, e;
 
+        IGRAPH_ALLOW_INTERRUPTION();
+
         /* calculate repulsive forces, we have a special version
            for unconnected graphs */
         igraph_vector_float_null(&dispx);
         igraph_vector_float_null(&dispy);
         if (conn) {
             for (v = 0; v < no_nodes; v++) {
                 for (u = v + 1; u < no_nodes; u++) {
@@ -248,14 +251,16 @@
     IGRAPH_FINALLY(igraph_vector_float_destroy, &dispx);
     IGRAPH_CHECK(igraph_vector_float_init(&dispy, no_nodes));
     IGRAPH_FINALLY(igraph_vector_float_destroy, &dispy);
 
     for (i = 0; i < niter; i++) {
         igraph_integer_t v, u, e;
 
+        IGRAPH_ALLOW_INTERRUPTION();
+
         igraph_vector_float_null(&dispx);
         igraph_vector_float_null(&dispy);
 
         /* repulsion */
         igraph_2dgrid_reset(&grid, &vidit);
         while ( (v = igraph_2dgrid_next(&grid, &vidit) - 1) != -1) {
             while ( (u = igraph_2dgrid_next_nei(&grid, &vidit) - 1) != -1) {
@@ -543,15 +548,15 @@
     if (maxz && igraph_vector_size(maxz) != no_nodes) {
         IGRAPH_ERROR("Invalid maxz vector length", IGRAPH_EINVAL);
     }
     if (minz && maxz && !igraph_vector_all_le(minz, maxz)) {
         IGRAPH_ERROR("minz must not be greater than maxz", IGRAPH_EINVAL);
     }
 
-    igraph_is_connected(graph, &conn, IGRAPH_WEAK);
+    IGRAPH_CHECK(igraph_is_connected(graph, &conn, IGRAPH_WEAK));
     if (!conn) {
         C = no_nodes * sqrtf(no_nodes);
     }
 
     RNG_BEGIN();
 
     if (!use_seed) {
@@ -575,14 +580,16 @@
     IGRAPH_FINALLY(igraph_vector_float_destroy, &dispy);
     IGRAPH_CHECK(igraph_vector_float_init(&dispz, no_nodes));
     IGRAPH_FINALLY(igraph_vector_float_destroy, &dispz);
 
     for (i = 0; i < niter; i++) {
         igraph_integer_t v, u, e;
 
+        IGRAPH_ALLOW_INTERRUPTION();
+
         /* calculate repulsive forces, we have a special version
            for unconnected graphs */
         igraph_vector_float_null(&dispx);
         igraph_vector_float_null(&dispy);
         igraph_vector_float_null(&dispz);
         if (conn) {
             for (v = 0; v < no_nodes; v++) {
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/gem.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/gem.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/graphopt.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/graphopt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/kamada_kawai.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/kamada_kawai.c`

 * *Files 3% similar despite different names*

```diff
@@ -23,23 +23,42 @@
 
 #include "igraph_layout.h"
 
 #include "igraph_interface.h"
 #include "igraph_paths.h"
 #include "igraph_random.h"
 
+#include "core/interruption.h"
+
 /**
  * \ingroup layout
  * \function igraph_layout_kamada_kawai
- * \brief Places the vertices on a plane according the Kamada-Kawai algorithm.
+ * \brief Places the vertices on a plane according to the Kamada-Kawai algorithm.
+ *
+ * This is a force-directed layout. A spring is inserted between all pairs
+ * of vertices, both those which are directly connected and those that are not.
+ * The unstretched length of springs is chosen based on the graph distance
+ * between the corresponding pair of vertices. Thus, in a weighted graph, increasing
+ * the weight between two vertices pushes them apart. The Young modulus of springs
+ * is inversely proportional to the graph distance, ensuring that springs between
+ * far-apart veritces will have a smaller effect on the layout.
+ *
+ * </para><para>
+ * This layout algorithm is not suitable for large graphs. The memory
+ * requirements are of the order O(|V|^2).
  *
  * </para><para>
- * This is a force directed layout, see  Kamada, T. and Kawai, S.: An
- * Algorithm for Drawing General Undirected Graphs. Information
- * Processing Letters, 31/1, 7--15, 1989.
+ * Reference:
+ *
+ * </para><para>
+ * Kamada, T. and Kawai, S.:
+ * An Algorithm for Drawing General Undirected Graphs.
+ * Information Processing Letters, 31/1, 7--15, 1989.
+ * https://doi.org/10.1016/0020-0190(89)90102-6
+ *
  * \param graph A graph object.
  * \param res Pointer to an initialized matrix object. This will
  *        contain the result (x-positions in column zero and
  *        y-positions in column one) and will be resized if needed.
  * \param use_seed Boolean, whether to use the values supplied in the
  *        \p res argument as the initial configuration. If zero and there
  *        are any limits on the X or Y coordinates, then a random initial
@@ -225,14 +244,16 @@
     }
 
     for (j = 0; j < maxiter; j++) {
         igraph_real_t myD1, myD2, A, B, C;
         igraph_real_t max_delta, delta_x, delta_y;
         igraph_real_t old_x, old_y, new_x, new_y;
 
+        IGRAPH_ALLOW_INTERRUPTION();
+
         myD1 = 0.0, myD2 = 0.0, A = 0.0, B = 0.0, C = 0.0;
 
         /* Select maximal delta */
         m = 0; max_delta = -1;
         for (i = 0; i < no_nodes; i++) {
             igraph_real_t delta = (VECTOR(D1)[i] * VECTOR(D1)[i] +
                                    VECTOR(D2)[i] * VECTOR(D2)[i]);
@@ -327,27 +348,30 @@
 
     return 0;
 }
 
 /**
  * \ingroup layout
  * \function igraph_layout_kamada_kawai_3d
- * \brief 3D version of the Kamada-Kawai layout generator
+ * \brief 3D version of the Kamada-Kawai layout generator.
+ *
+ * This is the 3D version of igraph_layout_kamada_kawai().
+ * See the documentation of that function for more information.
  *
  * </para><para>
- * This is a force directed layout, see  Kamada, T. and Kawai, S.: An
- * Algorithm for Drawing General Undirected Graphs. Information
- * Processing Letters, 31/1, 7--15, 1989.
+ * This layout algorithm is not suitable for large graphs. The memory
+ * requirements are of the order O(|V|^2).
+ *
  * \param graph A graph object.
  * \param res Pointer to an initialized matrix object. This will
- *        contain the result (x-positions in column zero and
- *        y-positions in column one) and will be resized if needed.
+ *        contain the result (x-, y- and z-positions in columns one
+ *        through three) and will be resized if needed.
  * \param use_seed Boolean, whether to use the values supplied in the
  *        \p res argument as the initial configuration. If zero and there
- *        are any limits on the X, Y or Z coordinates, then a random initial
+ *        are any limits on the z, y or z coordinates, then a random initial
  *        configuration is used. Otherwise the vertices are placed uniformly
  *        on a sphere of radius 1 as the initial configuration.
  * \param maxiter The maximum number of iterations to perform. A reasonable
  *        default value is at least ten (or more) times the number of
  *        vertices.
  * \param epsilon Stop the iteration, if the maximum delta value of the
  *        algorithm is smaller than still. It is safe to leave it at zero,
@@ -549,14 +573,16 @@
 
         igraph_real_t Ax = 0.0, Ay = 0.0, Az = 0.0;
         igraph_real_t Axx = 0.0, Axy = 0.0, Axz = 0.0, Ayy = 0.0, Ayz = 0.0, Azz = 0.0;
         igraph_real_t max_delta, delta_x, delta_y, delta_z;
         igraph_real_t old_x, old_y, old_z, new_x, new_y, new_z;
         igraph_real_t detnum;
 
+        IGRAPH_ALLOW_INTERRUPTION();
+
         /* Select maximal delta */
         m = 0; max_delta = -1;
         for (i = 0; i < no_nodes; i++) {
             igraph_real_t delta = (VECTOR(D1)[i] * VECTOR(D1)[i] +
                                    VECTOR(D2)[i] * VECTOR(D2)[i] +
                                    VECTOR(D3)[i] * VECTOR(D3)[i]);
             if (delta > max_delta) {
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/large_graph.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/large_graph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/layout_bipartite.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/layout_bipartite.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/layout_grid.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/layout_grid.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/layout_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/layout_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/layout_random.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/layout_random.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/mds.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/mds.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/merge_dla.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/merge_dla.c`

 * *Files 1% similar despite different names*

```diff
@@ -36,30 +36,30 @@
  * \brief Merge multiple layouts by using a DLA algorithm
  *
  * </para><para>
  * First each layout is covered by a circle. Then the layout of the
  * largest graph is placed at the origin. Then the other layouts are
  * placed by the DLA algorithm, larger ones first and smaller ones
  * last.
- * \param thegraphs Pointer vector containing the graph object of
+ * \param thegraphs Pointer vector containing the graph objects of
  *        which the layouts will be merged.
  * \param coords Pointer vector containing matrix objects with the 2d
  *        layouts of the graphs in \p thegraphs.
  * \param res Pointer to an initialized matrix object, the result will
  *        be stored here. It will be resized if needed.
  * \return Error code.
  *
  * Added in version 0.2. This function is experimental.
  *
  * </para><para>
  * Time complexity: TODO.
  */
 
-int igraph_layout_merge_dla(igraph_vector_ptr_t *thegraphs,
-                            igraph_vector_ptr_t *coords,
+int igraph_layout_merge_dla(const igraph_vector_ptr_t *thegraphs,
+                            const igraph_vector_ptr_t *coords,
                             igraph_matrix_t *res) {
     long int graphs = igraph_vector_ptr_size(coords);
     igraph_vector_t sizes;
     igraph_vector_t x, y, r;
     igraph_vector_t nx, ny, nr;
     long int allnodes = 0;
     long int i, j;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/merge_grid.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/merge_grid.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/merge_grid.h` & `igraph-0.9.9/vendor/source/igraph/src/layout/merge_grid.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/reingold_tilford.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/reingold_tilford.c`

 * *Files 4% similar despite different names*

```diff
@@ -24,17 +24,17 @@
 #include "igraph_layout.h"
 
 #include "igraph_adjlist.h"
 #include "igraph_components.h"
 #include "igraph_dqueue.h"
 #include "igraph_interface.h"
 #include "igraph_memory.h"
+#include "igraph_paths.h"
 #include "igraph_progress.h"
 #include "igraph_structural.h"
-#include "igraph_topology.h"
 
 #include "core/math.h"
 
 static int igraph_i_layout_reingold_tilford_unreachable(
     const igraph_t *graph,
     igraph_neimode_t mode,
     long int real_root,
@@ -442,47 +442,216 @@
             vdata[i].offset -= avg;
         }
     }
 
     return 0;
 }
 
+/* This function computes the number of outgoing (or incoming) connections
+ * of clusters, represented as a membership vector. It only works with
+ * directed graphs. */
+int igraph_i_layout_reingold_tilford_cluster_degrees_directed(
+        const igraph_t *graph,
+        const igraph_vector_t *membership,
+        igraph_integer_t no_comps,
+        igraph_neimode_t mode,
+        igraph_vector_t *degrees) {
+
+    igraph_eit_t eit;
+
+    if (! igraph_is_directed(graph) || (mode != IGRAPH_OUT && mode != IGRAPH_IN)) {
+        IGRAPH_ERROR("Directed graph expected.", IGRAPH_EINVAL);
+    }
+
+    IGRAPH_CHECK(igraph_vector_resize(degrees, no_comps));
+    igraph_vector_null(degrees);
+
+    IGRAPH_CHECK(igraph_eit_create(graph, igraph_ess_all(IGRAPH_EDGEORDER_ID), &eit));
+    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
+
+    for (; !IGRAPH_EIT_END(eit); IGRAPH_EIT_NEXT(eit)) {
+        igraph_integer_t eid = IGRAPH_EIT_GET(eit);
+
+        igraph_integer_t from = IGRAPH_FROM(graph, eid);
+        igraph_integer_t to   = IGRAPH_TO(graph, eid);
+
+        igraph_integer_t from_cl = VECTOR(*membership)[from];
+        igraph_integer_t to_cl   = VECTOR(*membership)[to];
+
+        igraph_integer_t cl = mode == IGRAPH_OUT ? from_cl : to_cl;
+
+        if (from_cl != to_cl) {
+            VECTOR(*degrees)[cl] += 1;
+        }
+    }
+
+    igraph_eit_destroy(&eit);
+    IGRAPH_FINALLY_CLEAN(1);
+
+    return IGRAPH_SUCCESS;
+}
+
+/* Heuristic method to choose "nice" roots for the Reingold-Tilford layout algorithm.
+ *
+ * The principle is to select a minimal set of roots so that all other vertices
+ * will be reachable from them.
+ *
+ * In the undirected case, one root is chosen from each connected component.
+ * In the directed case, one root is chosen from each strongly connected component
+ * that has no incoming (or outgoing) edges (depending on 'mode').
+ * When more than one root choice is possible, nodes are prioritized based on
+ * either lowest ecccentricity (if 'use_ecccentricity' is true) or based on
+ * highest degree (out- or in-degree in directed mode).
+ */
+int igraph_i_layout_reingold_tilford_select_roots(
+        const igraph_t *graph,
+        igraph_neimode_t mode,
+        igraph_vector_t *roots,
+        igraph_bool_t use_eccentricity) {
+
+    igraph_integer_t no_of_nodes = igraph_vcount(graph);
+    igraph_vector_t order, membership;
+    igraph_integer_t no_comps;
+    long int i, j;
+
+    if (! igraph_is_directed(graph)) {
+        mode = IGRAPH_ALL;
+    }
+
+    IGRAPH_VECTOR_INIT_FINALLY(&order, no_of_nodes);
+    if (use_eccentricity) {
+        /* Sort vertices by decreasing eccenticity. */
+
+        igraph_vector_t ecc;
+
+        IGRAPH_VECTOR_INIT_FINALLY(&ecc, no_of_nodes);
+        IGRAPH_CHECK(igraph_eccentricity(graph, &ecc, igraph_vss_all(), mode));
+        IGRAPH_CHECK(igraph_vector_qsort_ind(&ecc, &order, /* descending= */ 0));
+
+        igraph_vector_destroy(&ecc);
+        IGRAPH_FINALLY_CLEAN(1);
+    } else {
+        /* Sort vertices by decreasing degree (out- or in-degree in directed case). */
+
+        IGRAPH_CHECK(igraph_sort_vertex_ids_by_degree(graph, &order,
+                     igraph_vss_all(), mode, 0, IGRAPH_DESCENDING, 0));
+    }
+
+    IGRAPH_VECTOR_INIT_FINALLY(&membership, no_of_nodes);    
+    IGRAPH_CHECK(igraph_clusters(graph, &membership, /*csize=*/ NULL,
+                                 &no_comps, mode == IGRAPH_ALL ? IGRAPH_WEAK : IGRAPH_STRONG));
+
+    IGRAPH_CHECK(igraph_vector_resize(roots, no_comps));
+    igraph_vector_fill(roots, -1); /* -1 signifies a not-yet-determined root for a component */
+
+    if (mode != IGRAPH_ALL) {
+        /* Directed case:
+         *
+         * We break the graph into strongly-connected components and find those components
+         * which have no incoming (outgoing) edges. The largest out-degree (in-degree)
+         * nodes from these components will be chosen as roots. When the graph is a DAG,
+         * these will simply be the source (sink) nodes. */
+
+        igraph_vector_t cluster_degrees;
+
+        IGRAPH_VECTOR_INIT_FINALLY(&cluster_degrees, no_of_nodes);
+        IGRAPH_CHECK(igraph_i_layout_reingold_tilford_cluster_degrees_directed(
+                         graph, &membership, no_comps,
+                         mode == IGRAPH_OUT ? IGRAPH_IN : IGRAPH_OUT, /* reverse direction */
+                         &cluster_degrees));
+
+        /* Iterate through nodes in decreasing out-degree (or in-degree) order
+         * and record largest degree node in each strongly-connected component
+         * which has no incoming (outgoing) edges. */
+        for (i = 0; i < no_of_nodes; ++i) {
+            long int v  = (long int) VECTOR(order)[i];
+            long int cl = VECTOR(membership)[v];
+            if (VECTOR(cluster_degrees)[cl] == 0 && VECTOR(*roots)[cl] == -1) {
+                VECTOR(*roots)[cl] = v;
+            }
+        }
+
+        igraph_vector_destroy(&cluster_degrees);
+        IGRAPH_FINALLY_CLEAN(1);
+
+        /* Remove remaining -1 indices. These correspond to components that
+         * did have some incoming edges. */
+        for (i=0, j=0; i < no_comps; ++i) {
+            if (VECTOR(*roots)[i] == -1) {
+                continue;
+            }
+            VECTOR(*roots)[j++] = VECTOR(*roots)[i];
+        }
+        igraph_vector_resize(roots, j);
+
+    } else {
+        /* Undirected case:
+         *
+         * Select the highest degree node from each component.
+         */
+
+        long int no_seen = 0;
+
+        for (i=0; i < no_of_nodes; ++i) {
+            long int v  = VECTOR(order)[i];
+            long int cl = VECTOR(membership)[v];
+            if (VECTOR(*roots)[cl] == -1) {
+                no_seen += 1;
+                VECTOR(*roots)[cl] = v;
+            }
+            if (no_seen == no_comps) {
+                /* All components have roots now. */
+                break;
+            }
+        }
+    }
+
+    igraph_vector_destroy(&membership);
+    igraph_vector_destroy(&order);
+    IGRAPH_FINALLY_CLEAN(2);
+
+    return IGRAPH_SUCCESS;
+}
+
 /**
  * \function igraph_layout_reingold_tilford
  * \brief Reingold-Tilford layout for tree graphs
  *
  * </para><para>
  * Arranges the nodes in a tree where the given node is used as the root.
  * The tree is directed downwards and the parents are centered above its
  * children. For the exact algorithm, see:
  *
  * </para><para>
  * Reingold, E and Tilford, J: Tidier drawing of trees.
- * IEEE Trans. Softw. Eng., SE-7(2):223--228, 1981
+ * IEEE Trans. Softw. Eng., SE-7(2):223--228, 1981.
+ * https://doi.org/10.1109/TSE.1981.234519
  *
  * </para><para>
  * If the given graph is not a tree, a breadth-first search is executed
  * first to obtain a possible spanning tree.
  *
  * \param graph The graph object.
  * \param res The result, the coordinates in a matrix. The parameter
  *   should point to an initialized matrix object and will be resized.
  * \param mode Specifies which edges to consider when building the tree.
  *   If it is \c IGRAPH_OUT then only the outgoing, if it is \c IGRAPH_IN
  *   then only the incoming edges of a parent are considered. If it is
  *   \c IGRAPH_ALL then all edges are used (this was the behavior in
  *   igraph 0.5 and before). This parameter also influences how the root
  *   vertices are calculated, if they are not given. See the \p roots parameter.
- * \param roots The index of the root vertex or root vertices.
- *   If this is a non-empty vector then the supplied vertex ids are used
- *   as the roots of the trees (or a single tree if the graph is connected).
- *   If it is a null pointer of a pointer to an empty vector, then the root
- *   vertices are automatically calculated based on topological sorting,
- *   performed with the opposite mode than the \p mode argument.
- *   After the vertices have been sorted, one is selected from each component.
+ * \param roots The index of the root vertex or root vertices. The set of roots
+ *   should be specified so that all vertices of the graph are reachable from them.
+ *   Simply put, in the udirected case, one root should be given from each
+ *   connected component. If \p roots is \c NULL or a pointer to an empty vector,
+ *   then the roots will be selected automatically. Currently, automatic root
+ *   selection prefers low ecccentricity vertices in graphs with fewer than
+ *   500 vertices, and high degree vertices (acording to \p mode) in larger graphs.
+ *   The root selecton heuristic may change without notice. To ensure a consistent
+ *   output, please specify the roots manually.
  * \param rootlevel This argument can be useful when drawing forests which are
  *   not trees (i.e. they are unconnected and have tree components). It specifies
  *   the level of the root vertices for every tree in the forest. It is only
  *   considered if not a null pointer and the \p roots argument is also given
  *   (and it is not a null pointer of an empty vector).
  * \return Error code.
  *
@@ -501,15 +670,15 @@
     long int no_of_nodes_orig = igraph_vcount(graph);
     long int no_of_nodes = no_of_nodes_orig;
     long int real_root;
     igraph_t extended;
     const igraph_t *pextended = graph;
     igraph_vector_t myroots;
     const igraph_vector_t *proots = roots;
-    igraph_neimode_t mode2;
+
     long int i;
     igraph_vector_t newedges;
 
     /* TODO: possible speedup could be achieved if we use a table for storing
      * the children of each node in the tree. (Now the implementation uses a
      * single array containing the parent of each node and a node's children
      * are determined by looking for other nodes that have this node as parent)
@@ -524,66 +693,21 @@
 
     if ( (!roots || igraph_vector_size(roots) == 0) &&
          rootlevel && igraph_vector_size(rootlevel) != 0 ) {
         IGRAPH_WARNING("Reingold-Tilford layout: 'rootlevel' ignored");
     }
 
     /* ----------------------------------------------------------------------- */
-    /* If root vertices are not given, then do a topological sort and take
-       the last element from every component for directed graphs and mode == out,
-       or the first element from every component for directed graphs and mode ==
-       in,or select the vertex with the maximum degree from each component for
-       undirected graphs */
+    /* If root vertices are not given, perform automated root selection. */
 
     if (!roots || igraph_vector_size(roots) == 0) {
 
-        igraph_vector_t order, membership;
-        igraph_integer_t no_comps;
-        long int i, noseen = 0;
-
         IGRAPH_VECTOR_INIT_FINALLY(&myroots, 0);
-        IGRAPH_VECTOR_INIT_FINALLY(&order, no_of_nodes);
-        IGRAPH_VECTOR_INIT_FINALLY(&membership, no_of_nodes);
-
-        if (mode != IGRAPH_ALL) {
-            /* look for roots by swimming against the stream */
-            mode2 = (mode == IGRAPH_IN) ? IGRAPH_OUT : IGRAPH_IN;
-
-            IGRAPH_CHECK(igraph_topological_sorting(graph, &order, mode2));
-            IGRAPH_CHECK(igraph_clusters(graph, &membership, /*csize=*/ 0,
-                                         &no_comps, IGRAPH_WEAK));
-        } else {
-            IGRAPH_CHECK(igraph_sort_vertex_ids_by_degree(graph, &order,
-                         igraph_vss_all(), IGRAPH_ALL, 0, IGRAPH_ASCENDING, 0));
-            IGRAPH_CHECK(igraph_clusters(graph, &membership, /*csize=*/ 0,
-                                         &no_comps, IGRAPH_WEAK));
-        }
-
-        IGRAPH_CHECK(igraph_vector_resize(&myroots, no_comps));
-
-        /* go backwards and fill the roots vector with indices [1, no_of_nodes]
-           The index 0 is used to signal this root has not been found yet:
-           all indices are then decreased by one to [0, no_of_nodes - 1] */
-        igraph_vector_null(&myroots);
+        igraph_i_layout_reingold_tilford_select_roots(graph, mode, &myroots, no_of_nodes < 500);
         proots = &myroots;
-        for (i = no_of_nodes - 1; noseen < no_comps && i >= 0; i--) {
-            long int v = (long int) VECTOR(order)[i];
-            long int mem = (long int) VECTOR(membership)[v];
-            if (VECTOR(myroots)[mem] == 0) {
-                noseen += 1;
-                VECTOR(myroots)[mem] = v + 1;
-            }
-        }
-        for (i = 0; i < no_comps; i++) {
-            VECTOR(myroots)[i] -= 1;
-        }
-
-        igraph_vector_destroy(&membership);
-        igraph_vector_destroy(&order);
-        IGRAPH_FINALLY_CLEAN(2);
 
     } else if (rootlevel && igraph_vector_size(rootlevel) > 0 &&
                igraph_vector_size(roots) > 1) {
 
         /* ----------------------------------------------------------------------- */
         /* Many roots were given to us, check 'rootlevel' */
 
@@ -777,21 +901,23 @@
  *   should point to an initialized matrix object and will be resized.
  * \param mode Specifies which edges to consider when building the tree.
  *   If it is \c IGRAPH_OUT then only the outgoing, if it is \c IGRAPH_IN
  *   then only the incoming edges of a parent are considered. If it is
  *   \c IGRAPH_ALL then all edges are used (this was the behavior in
  *   igraph 0.5 and before). This parameter also influences how the root
  *   vertices are calculated, if they are not given. See the \p roots parameter.
- * \param roots The index of the root vertex or root vertices.
- *   If this is a non-empty vector then the supplied vertex ids are used
- *   as the roots of the trees (or a single tree if the graph is connected).
- *   If it is a null pointer of a pointer to an empty vector, then the root
- *   vertices are automatically calculated based on topological sorting,
- *   performed with the opposite mode than the \p mode argument.
- *   After the vertices have been sorted, one is selected from each component.
+ * \param roots The index of the root vertex or root vertices. The set of roots
+ *   should be specified so that all vertices of the graph are reachable from them.
+ *   Simply put, in the udirected case, one root should be given from each
+ *   connected component. If \p roots is \c NULL or a pointer to an empty vector,
+ *   then the roots will be selected automatically. Currently, automatic root
+ *   selection prefers low ecccentricity vertices in graphs with fewer than
+ *   500 vertices, and high degree vertices (acording to \p mode) in larger graphs.
+ *   The root selecton heuristic may change without notice. To ensure a consistent
+ *   output, please specify the roots manually.
  * \param rootlevel This argument can be useful when drawing forests which are
  *   not trees (i.e. they are unconnected and have tree components). It specifies
  *   the level of the root vertices for every tree in the forest. It is only
  *   considered if not a null pointer and the \p roots argument is also given
  *   (and it is not a null pointer or an empty vector).
  * \return Error code.
  *
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/layout/sugiyama.c` & `igraph-0.9.9/vendor/source/igraph/src/layout/sugiyama.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/linalg/arpack.c` & `igraph-0.9.9/vendor/source/igraph/src/linalg/arpack.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/linalg/arpack_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/linalg/arpack_internal.h`

 * *Files 15% similar despite different names*

```diff
@@ -122,59 +122,69 @@
     #define igraphs_copy    s_copy
     #define igraphd_lg10_   d_lg10_
     #define igraphi_dnnt_   i_dnnt_
 #endif
 
 #ifdef HAVE_GFORTRAN
 
-int igraphdsaupd_(int *ido, char *bmat, int *n,
+/* GFortran-specific calling conventions, used when compiling the R interface.
+ * Derived with "gfortran -fc-prototypes-external", applied on the original
+ * Fortran sources of these functions.
+ *
+ * Caveats:
+ *
+ * 1) gfortran prints size_t for the "_len" arguments, but in fact they must be
+ *    long int
+ * 2) gofrtran maps Fortran LOGICAL types to int_least32_t, but in fact they
+ *    must be void* (anything else doesn't work, not even _Bool*)
+ * */
+
+void igraphdsaupd_(int *ido, char *bmat, int *n,
                   char *which, int *nev, igraph_real_t *tol,
                   igraph_real_t *resid, int *ncv, igraph_real_t *v,
                   int *ldv, int *iparam, int *ipntr,
                   igraph_real_t *workd, igraph_real_t *workl,
                   int *lworkl, int *info,
-                  int bmat_len, int which_len);
+                  long int bmat_len, long int which_len);
 
-int igraphdseupd_(int *rvec, char *howmny, int *select,
+void igraphdseupd_(void *rvec, char *howmny, void *select,
                   igraph_real_t *d, igraph_real_t *z, int *ldz,
                   igraph_real_t *sigma, char *bmat, int *n,
                   char *which, int *nev, igraph_real_t *tol,
                   igraph_real_t *resid, int *ncv, igraph_real_t *v,
                   int *ldv, int *iparam, int *ipntr,
                   igraph_real_t *workd, igraph_real_t *workl,
                   int *lworkl, int *info,
-                  int howmny_len, int bmat_len, int which_len);
+                  long int howmny_len, long int bmat_len, long int which_len);
 
-int igraphdnaupd_(int *ido, char *bmat, int *n,
+void igraphdnaupd_(int *ido, char *bmat, int *n,
                   char *which, int *nev, igraph_real_t *tol,
                   igraph_real_t *resid, int *ncv, igraph_real_t *v,
                   int *ldv, int *iparam, int *ipntr,
                   igraph_real_t *workd, igraph_real_t *workl,
                   int *lworkl, int *info,
-                  int bmat_len, int which_len);
+                  long int bmat_len, long int which_len);
 
-int igraphdneupd_(int *rvec, char *howmny, int *select,
+void igraphdneupd_(void *rvec, char *howmny, void *select,
                   igraph_real_t *dr, igraph_real_t *di,
                   igraph_real_t *z, int *ldz,
                   igraph_real_t *sigmar, igraph_real_t *sigmai,
                   igraph_real_t *workev, char *bmat, int *n,
                   char *which, int *nev, igraph_real_t *tol,
                   igraph_real_t *resid, int *ncv, igraph_real_t *v,
                   int *ldv, int *iparam, int *ipntr,
                   igraph_real_t *workd, igraph_real_t *workl,
                   int *lworkl, int *info,
-                  int howmny_len, int bmat_len, int which_len);
+                  long int howmny_len, long int bmat_len, long int which_len);
+
+void igraphdsortr_(char *which, void *apply, int* n, igraph_real_t *x1,
+                  igraph_real_t *x2, long int which_len);
 
-int igraphdsortr_(char *which, int *apply, int* n, igraph_real_t *x1,
-                  igraph_real_t *x2,
-                  int which_len);
-
-int igraphdsortc_(char *which, int *apply, int* n, igraph_real_t *xreal,
-                  igraph_real_t *ximag, igraph_real_t *y,
-                  int which_len);
+void igraphdsortc_(char *which, void *apply, int* n, igraph_real_t *xreal,
+                  igraph_real_t *ximag, igraph_real_t *y, long int which_len);
 
 #else
 
 int igraphdsaupd_(int *ido, char *bmat, int *n,
                   char *which, int *nev, igraph_real_t *tol,
                   igraph_real_t *resid, int *ncv, igraph_real_t *v,
                   int *ldv, int *iparam, int *ipntr,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/linalg/blas.c` & `igraph-0.9.9/vendor/source/igraph/src/linalg/blas.c`

 * *Files 13% similar despite different names*

```diff
@@ -59,16 +59,21 @@
 
     m = (int) igraph_matrix_nrow(a);
     n = (int) igraph_matrix_ncol(a);
 
     IGRAPH_ASSERT(igraph_vector_size(x) == transpose ? m : n);
     IGRAPH_ASSERT(igraph_vector_size(y) == transpose ? n : m);
 
+#ifdef HAVE_GFORTRAN
+    igraphdgemv_(&trans, &m, &n, &alpha, VECTOR(a->data), &m,
+                 VECTOR(*x), &inc, &beta, VECTOR(*y), &inc, /* trans_len = */ 1);
+#else
     igraphdgemv_(&trans, &m, &n, &alpha, VECTOR(a->data), &m,
                  VECTOR(*x), &inc, &beta, VECTOR(*y), &inc);
+#endif
 }
 
 /**
  * \function igraph_blas_dgemv_array
  * \brief Matrix-vector multiplication using BLAS, array version.
  *
  * This function is a somewhat more user-friendly interface to
@@ -95,16 +100,21 @@
     char trans = transpose ? 'T' : 'N';
     int m, n;
     int inc = 1;
 
     m = (int) igraph_matrix_nrow(a);
     n = (int) igraph_matrix_ncol(a);
 
+#ifdef HAVE_GFORTRAN
+    igraphdgemv_(&trans, &m, &n, &alpha, VECTOR(a->data), &m,
+                 (igraph_real_t*)x, &inc, &beta, y, &inc, /* trans_len = */ 1);
+#else
     igraphdgemv_(&trans, &m, &n, &alpha, VECTOR(a->data), &m,
                  (igraph_real_t*)x, &inc, &beta, y, &inc);
+#endif
 }
 
 igraph_real_t igraph_blas_dnrm2(const igraph_vector_t *v) {
     int n = igraph_vector_size(v);
     int one = 1;
     return igraphdnrm2_(&n, VECTOR(*v), &one);
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/linalg/blas_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/linalg/blas_internal.h`

 * *Files 12% similar despite different names*

```diff
@@ -53,20 +53,38 @@
     #define igraphdsymv_    dsymv_
     #define igraphdsyr2_    dsyr2_
     #define igraphdsyr2k_   dsyr2k_
     #define igraphdtrmv_    dtrmv_
     #define igraphdsyrk_    dsyrk_
 #endif
 
+#ifdef HAVE_GFORTRAN
+
+/* GFortran-specific calling conventions, used when compiling the R interface.
+ * Derived with "gfortran -fc-prototypes-external", applied on the original
+ * Fortran sources of these functions. */
+
+void igraphdgemv_(char *trans, int *m, int *n, igraph_real_t *alpha,
+                 igraph_real_t *a, int *lda, igraph_real_t *x, int *incx,
+                 igraph_real_t *beta, igraph_real_t *y, int *incy, long int trans_len);
+
+void igraphdgemm_(char *transa, char *transb, int *m, int *n, int *k,
+                 double *alpha, double *a, int *lda, double *b, int *ldb,
+                 double *beta, double *c__, int *ldc, long int transa_len, long int transb_len);
+
+#else
+
 int igraphdgemv_(char *trans, int *m, int *n, igraph_real_t *alpha,
                  igraph_real_t *a, int *lda, igraph_real_t *x, int *incx,
                  igraph_real_t *beta, igraph_real_t *y, int *incy);
 
 int igraphdgemm_(char *transa, char *transb, int *m, int *n, int *k,
                  double *alpha, double *a, int *lda, double *b, int *ldb,
                  double *beta, double *c__, int *ldc);
 
+#endif
+
 double igraphdnrm2_(int *n, double *x, int *incx);
 
 double igraphddot_(int *n, double *dx, int *incx, double *dy, int *incy);
 
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/linalg/eigen.c` & `igraph-0.9.9/vendor/source/igraph/src/linalg/eigen.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/linalg/lapack.c` & `igraph-0.9.9/vendor/source/igraph/src/linalg/lapack.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/linalg/lapack_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/linalg/lapack_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/math/bfgs.c` & `igraph-0.9.9/vendor/source/igraph/src/math/bfgs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/math/complex.c` & `igraph-0.9.9/vendor/source/igraph/src/math/complex.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/math/utils.c` & `igraph-0.9.9/vendor/source/igraph/src/math/utils.c`

 * *Files 5% similar despite different names*

```diff
@@ -269,14 +269,29 @@
  * \return nonzero if the two floats are nearly equal to each other within
  *         the given level of tolerance, zero otherwise
  */
 int igraph_almost_equals(double a, double b, double eps) {
     return igraph_cmp_epsilon(a, b, eps) == 0 ? 1 : 0;
 }
 
+/* Use value-safe floating point math for igraph_cmp_epsilon() with
+ * the Intel compiler.
+ *
+ * The Intel compiler rewrites arithmetic expressions for faster
+ * evaluation by default. In the below function, it will evaluate
+ * (eps * fabs(a) + eps * fabs(b)) as eps*(fabs(a) + fabs(b)).
+ * However, this code path is taken precisely when fabs(a) + fabs(b)
+ * overflows, thus this rearrangement of the expression causes
+ * the function to return incorrect results, and some test failures.
+ * To avoid this, we switch the Intel compiler to "precise" mode.
+ */
+#ifdef __INTEL_COMPILER
+#pragma float_control(push)
+#pragma float_control (precise, on)
+#endif
 
 /**
  * \function igraph_cmp_epsilon
  * Compare two double-precision floats with a tolerance
  *
  * Determines whether two double-precision floats are "almost equal"
  * to each other with a given level of tolerance on the relative error.
@@ -290,26 +305,35 @@
  * \return zero if the two floats are nearly equal to each other within
  *         the given level of tolerance, positive number if the first float is
  *         larger, negative number if the second float is larger
  */
 int igraph_cmp_epsilon(double a, double b, double eps) {
     double diff;
     double abs_diff;
+    double sum;
 
     if (a == b) {
         /* shortcut, handles infinities */
         return 0;
     }
 
     diff = a - b;
     abs_diff = fabs(diff);
+    sum = fabs(a) + fabs(b);
 
-    if (a == 0 || b == 0 || diff < DBL_MIN) {
+    if (a == 0 || b == 0 || sum < DBL_MIN) {
         /* a or b is zero or both are extremely close to it; relative
          * error is less meaningful here so just compare it with
          * epsilon */
         return abs_diff < (eps * DBL_MIN) ? 0 : (diff < 0 ? -1 : 1);
+    } else if (!isfinite(sum)) {
+        /* addition overflow, so presumably |a| and |b| are both large; use a
+         * different formulation */
+        return (abs_diff < (eps * fabs(a) + eps * fabs(b))) ? 0 : (diff < 0 ? -1 : 1);
     } else {
-        /* use relative error */
-        return (abs_diff / (fabs(a) + fabs(b)) < eps) ? 0 : (diff < 0 ? -1 : 1);
+        return (abs_diff / sum < eps) ? 0 : (diff < 0 ? -1 : 1);
     }
 }
+
+#ifdef __INTEL_COMPILER
+#pragma float_control(pop)
+#endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/bipartite.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/bipartite.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/chordality.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/chordality.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/cocitation.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/cocitation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/coloring.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/coloring.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/conversion.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/conversion.c`

 * *Files 0% similar despite different names*

```diff
@@ -465,29 +465,33 @@
 
 /**
  * \function igraph_to_undirected
  * \brief Convert a directed graph to an undirected one.
  *
  * </para><para>
  * If the supplied graph is undirected, this function does nothing.
+ *
  * \param graph The graph object to convert.
  * \param mode Constant, specifies the details of how exactly the
  *        conversion is done. Possible values: \c
  *        IGRAPH_TO_UNDIRECTED_EACH: the number of edges remains
  *        constant, an undirected edge is created for each directed
  *        one, this version might create graphs with multiple edges;
  *        \c IGRAPH_TO_UNDIRECTED_COLLAPSE: one undirected edge will
  *        be created for each pair of vertices that are connected
  *        with at least one directed edge, no multiple edges will be
  *        created. \c IGRAPH_TO_UNDIRECTED_MUTUAL creates an undirected
  *        edge for each pair of mutual edges in the directed graph.
  *        Non-mutual edges are lost; loop edges are kept unconditionally.
  *        This mode might create multiple edges.
  * \param edge_comb What to do with the edge attributes. See the igraph
- *        manual section about attributes for details.
+ *        manual section about attributes for details. \c NULL means that
+ *        the edge attributes are lost during the conversion, \em except
+ *        when \c mode is \c IGRAPH_TO_UNDIRECTED_EACH, in which case the
+ *        edge attributes are kept intact.
  * \return Error code.
  *
  * Time complexity: O(|V|+|E|), the number of vertices plus the number
  * of edges.
  *
  * \example examples/simple/igraph_to_undirected.c
  */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/conversion_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/misc/conversion_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/degree_sequence.cpp` & `igraph-0.9.9/vendor/source/igraph/src/misc/degree_sequence.cpp`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/embedding.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/embedding.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/feedback_arc_set.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/feedback_arc_set.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/feedback_arc_set.h` & `igraph-0.9.9/vendor/source/igraph/src/misc/feedback_arc_set.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/graphicality.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/graphicality.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/matching.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/matching.c`

 * *Files 0% similar despite different names*

```diff
@@ -549,14 +549,15 @@
     igraph_dqueue_long_t q;           /* a FIFO for BST */
     igraph_bool_t smaller_set_type;   /* denotes which part of the bipartite graph is smaller */
     igraph_vector_t smaller_set;      /* stores the vertex IDs of the smaller set */
     igraph_vector_t larger_set;       /* stores the vertex IDs of the larger set */
     long int smaller_set_size;        /* size of the smaller set */
     long int larger_set_size;         /* size of the larger set */
     igraph_real_t dual;               /* solution of the dual problem */
+    IGRAPH_UNUSED(dual);              /* We mark it as unused to prevent warnings about unused-but-set-variables. */
     igraph_adjlist_t tight_phantom_edges; /* adjacency list to manage tight phantom edges */
     igraph_integer_t alternating_path_endpoint;
     igraph_vector_int_t* neis;
     igraph_vector_int_t *neis2;
     igraph_inclist_t inclist;         /* incidence list of the original graph */
 
     /* The Hungarian algorithm is originally for complete bipartite graphs.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/microscopic_update.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/microscopic_update.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/mixing.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/mixing.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/motifs.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/motifs.c`

 * *Files 2% similar despite different names*

```diff
@@ -55,118 +55,163 @@
  * Motifs are small weakly connected induced subgraphs of a given structure in a
  * graph. It is argued that the motif profile (i.e. the number of
  * different motifs in the graph) is characteristic for different
  * types of networks and network function is related to the motifs in
  * the graph.
  *
  * </para><para>
- * This function is able to find the different motifs of size three
- * and four (i.e. the number of different subgraphs with three and four
- * vertices) in the network.
+ * This function is able to find directed motifs of sizes three
+ * and four and undirected motifs of sizes three to six
+ * (i.e. the number of different subgraphs with three to six
+ * vertices in the network).
  *
  * </para><para>
  * In a big network the total number of motifs can be very large, so
  * it takes a lot of time to find all of them, a sampling method can
  * be used. This function is capable of doing sampling via the
- * \c cut_prob argument. This argument gives the probability that
+ * \p cut_prob argument. This argument gives the probability that
  * a branch of the motif search tree will not be explored. See
  * S. Wernicke and F. Rasche: FANMOD: a tool for fast network motif
  * detection, Bioinformatics 22(9), 1152--1153, 2006 for details.
+ * https://doi.org/10.1093/bioinformatics/btl038
  *
  * </para><para>
- * Set the \c cut_prob argument to a zero vector for finding all
+ * Set the \p cut_prob argument to a zero vector for finding all
  * motifs.
  *
  * </para><para>
  * Directed motifs will be counted in directed graphs and undirected
  * motifs in undirected graphs.
  *
  * \param graph The graph to find the motifs in.
  * \param hist The result of the computation, it gives the number of
  *        motifs found for each isomorphism class. See
  *        \ref igraph_isoclass() for help about isomorphism classes.
  *        Note that this function does \em not count isomorphism
  *        classes that are not connected and will report NaN (more
  *        precisely \c IGRAPH_NAN) for them.
- * \param size The size of the motifs to search for. Only three and
- *        four are implemented currently. The limitation is not in the
- *        motif finding code, but the graph isomorphism code.
+ * \param size The size of the motifs to search for. For directed graphs,
+ *        only 3 and 4 are implemented, for undirected, 3 to 6.
+ *        The limitation is not in the motif finding code, but the graph
+ *        isomorphism code.
  * \param cut_prob Vector of probabilities for cutting the search tree
  *        at a given level. The first element is the first level, etc.
- *        Supply all zeros here (of length \c size) to find all motifs
+ *        Supply all zeros here (of length \p size) to find all motifs
  *        in a graph.
  * \return Error code.
+ *
  * \sa \ref igraph_motifs_randesu_estimate() for estimating the number
  * of motifs in a graph, this can help to set the \p cut_prob
  * parameter; \ref igraph_motifs_randesu_no() to calculate the total
  * number of motifs of a given size in a graph;
  * \ref igraph_motifs_randesu_callback() for calling a callback function
  * for every motif found; \ref igraph_subisomorphic_lad() for finding
- * subgraphs on more than 4 vertices.
+ * subgraphs on more than 4 (directed) or 6 (undirected) vertices.
  *
  * Time complexity: TODO.
  *
  * \example examples/simple/igraph_motifs_randesu.c
  */
 int igraph_motifs_randesu(const igraph_t *graph, igraph_vector_t *hist,
                           int size, const igraph_vector_t *cut_prob) {
+    igraph_bool_t directed = igraph_is_directed(graph);
     int histlen;
 
-    if (size != 3 && size != 4) {
-        IGRAPH_ERROR("Only 3 and 4 vertex motifs are implemented",
-                     IGRAPH_EINVAL);
+    if (directed) {
+        switch (size) {
+        case 3:
+            histlen = 16;
+            break;
+        case 4:
+            histlen = 218;
+            break;
+        default:
+            IGRAPH_ERROR("In directed graphs, only 3 and 4 vertex motifs are supported.",
+                         IGRAPH_UNIMPLEMENTED);
+        }
+    } else {
+        switch (size) {
+        case 3:
+            histlen = 4;
+            break;
+        case 4:
+            histlen = 11;
+            break;
+        case 5:
+            histlen = 34;
+            break;
+        case 6:
+            histlen = 156;
+            break;
+        default:
+            IGRAPH_ERROR("In undirected graphs, only 3 to 6 vertex motifs are supported.",
+                         IGRAPH_UNIMPLEMENTED);
+        }
     }
+
     if (igraph_vector_size(cut_prob) != size) {
         IGRAPH_ERRORF("Cut probability vector size (%ld) must agree with motif size (%" IGRAPH_PRId ").",
                       IGRAPH_EINVAL, igraph_vector_size(cut_prob), size);
     }
-    if (size == 3) {
-        histlen = igraph_is_directed(graph) ? 16 : 4;
-    } else {
-        histlen = igraph_is_directed(graph) ? 218 : 11;
-    }
 
     IGRAPH_CHECK(igraph_vector_resize(hist, histlen));
     igraph_vector_null(hist);
 
     IGRAPH_CHECK(igraph_motifs_randesu_callback(graph, size, cut_prob,
                  &igraph_i_motifs_randesu_update_hist, hist));
 
     if (size == 3) {
-        if (igraph_is_directed(graph)) {
+        if (directed) {
             VECTOR(*hist)[0] = VECTOR(*hist)[1] = VECTOR(*hist)[3] = IGRAPH_NAN;
         } else {
             VECTOR(*hist)[0] = VECTOR(*hist)[1] = IGRAPH_NAN;
         }
     } else if (size == 4) {
-        if (igraph_is_directed(graph)) {
+        if (directed) {
             int not_connected[] = { 0, 1, 2, 4, 5, 6, 9, 10, 11, 15, 22, 23, 27,
                                     28, 33, 34, 39, 62, 120
                                   };
             int i, n = sizeof(not_connected) / sizeof(int);
             for (i = 0; i < n; i++) {
                 VECTOR(*hist)[not_connected[i]] = IGRAPH_NAN;
             }
         } else {
             VECTOR(*hist)[0] = VECTOR(*hist)[1] = VECTOR(*hist)[2] =
                     VECTOR(*hist)[3] = VECTOR(*hist)[5] = IGRAPH_NAN;
         }
+    } else if (size == 5) {
+        /* undirected only */
+        int not_connected[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 19 };
+        int i, n = sizeof(not_connected) / sizeof(int);
+        for (i = 0; i < n; i++) {
+            VECTOR(*hist)[not_connected[i]] = IGRAPH_NAN;
+        }
+    } else if (size == 6) {
+        /* undirected only */
+        int not_connected[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
+                               19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 38,
+                               44, 50, 51, 54, 74, 77, 89, 120};
+        int i, n = sizeof(not_connected) / sizeof(int);
+        for (i = 0; i < n; i++) {
+            VECTOR(*hist)[not_connected[i]] = IGRAPH_NAN;
+        }
     }
 
     return IGRAPH_SUCCESS;
 }
 
 /**
  * \function igraph_motifs_randesu_callback
  * \brief Finds motifs in a graph and calls a function for each of them.
  *
  * </para><para>
- * Similarly to \ref igraph_motifs_randesu(), this function is able to find the
- * different motifs of size three and four (i.e. the number of different
- * subgraphs with three and four vertices) in the network. However, instead of
+ * Similarly to \ref igraph_motifs_randesu(), this function is able to find
+ * directed motifs of sizes three and four and undirected motifs of sizes
+ * three to six (i.e. the number of different subgraphs with three to six
+ * vertices in the network). However, instead of
  * counting them, the function will call a callback function for each motif
  * found to allow further tests or post-processing.
  *
  * </para><para>
  * The \p cut_prob argument also allows sampling the motifs, just like for
  * \ref igraph_motifs_randesu(). Set the \p cut_prob argument to a zero vector
  * for finding all motifs.
@@ -195,57 +240,77 @@
 
     long int no_of_nodes = igraph_vcount(graph);
     igraph_adjlist_t allneis, alloutneis;
     igraph_vector_int_t *neis;
     long int father;
     long int i, j, s;
     long int motifs = 0;
+    IGRAPH_UNUSED(motifs);    /* We mark it as unused to prevent warnings about unused-but-set-variables. */
 
     igraph_vector_t vids;     /* this is G */
     igraph_vector_t adjverts; /* this is V_E */
     igraph_stack_t stack;     /* this is S */
     long int *added;
     char *subg;
 
     const unsigned int *arr_idx, *arr_code;
-    int code = 0;
-    unsigned char mul, idx;
+    unsigned int code = 0;
+    unsigned int mul, idx;
 
     igraph_bool_t terminate = 0;
 
-    if (size != 3 && size != 4) {
-        IGRAPH_ERROR("Only 3 and 4 vertex motifs are implemented.",
-                     IGRAPH_EINVAL);
-    }
-
-    if (igraph_vector_size(cut_prob) != size) {
-        IGRAPH_ERRORF("Cut probability vector size (%ld) must agree with motif size (%" IGRAPH_PRId ").",
-                      IGRAPH_EINVAL, igraph_vector_size(cut_prob), size);
-    }
-
-    if (size == 3) {
-        mul = 3;
-        if (igraph_is_directed(graph)) {
+    if (igraph_is_directed(graph)) {
+        switch (size) {
+        case 3:
             arr_idx = igraph_i_isoclass_3_idx;
             arr_code = igraph_i_isoclass2_3;
-        } else {
-            arr_idx = igraph_i_isoclass_3u_idx;
-            arr_code = igraph_i_isoclass2_3u;
-        }
-    } else {
-        mul = 4;
-        if (igraph_is_directed(graph)) {
+            mul = 3;
+            break;
+        case 4:
             arr_idx = igraph_i_isoclass_4_idx;
             arr_code = igraph_i_isoclass2_4;
-        } else {
+            mul = 4;
+            break;
+        default:
+            IGRAPH_ERROR("In directed graphs, only 3 and 4 vertex motifs are supported.",
+                         IGRAPH_UNIMPLEMENTED);
+        }
+    } else {
+        switch (size) {
+        case 3:
+            arr_idx = igraph_i_isoclass_3u_idx;
+            arr_code = igraph_i_isoclass2_3u;
+            mul = 3;
+            break;
+        case 4:
             arr_idx = igraph_i_isoclass_4u_idx;
             arr_code = igraph_i_isoclass2_4u;
+            mul = 4;
+            break;
+        case 5:
+            arr_idx = igraph_i_isoclass_5u_idx;
+            arr_code = igraph_i_isoclass2_5u;
+            mul = 5;
+            break;
+        case 6:
+            arr_idx = igraph_i_isoclass_6u_idx;
+            arr_code = igraph_i_isoclass2_6u;
+            mul = 6;
+            break;
+        default:
+            IGRAPH_ERROR("In undirected graphs, only 3 to 6 vertex motifs are supported.",
+                         IGRAPH_UNIMPLEMENTED);
         }
     }
 
+    if (igraph_vector_size(cut_prob) != size) {
+        IGRAPH_ERRORF("Cut probability vector size (%ld) must agree with motif size (%" IGRAPH_PRId ").",
+                      IGRAPH_EINVAL, igraph_vector_size(cut_prob), size);
+    }
+
     added = IGRAPH_CALLOC(no_of_nodes, long int);
     if (added == 0) {
         IGRAPH_ERROR("Cannot find motifs", IGRAPH_ENOMEM);
     }
     IGRAPH_FINALLY(igraph_free, added);
 
     subg = IGRAPH_CALLOC(no_of_nodes, char);
@@ -420,25 +485,26 @@
     IGRAPH_FREE(subg);
     igraph_vector_destroy(&vids);
     igraph_vector_destroy(&adjverts);
     igraph_adjlist_destroy(&alloutneis);
     igraph_adjlist_destroy(&allneis);
     igraph_stack_destroy(&stack);
     IGRAPH_FINALLY_CLEAN(7);
+
     return IGRAPH_SUCCESS;
 }
 
 /**
  * \function igraph_motifs_randesu_estimate
  * \brief Estimate the total number of motifs in a graph.
  *
- * This function estimates the total number of connected induced
+ * This function estimates the total number of weakly connected induced
  * subgraphs, called motifs, of a fixed number of vertices. For
  * example, an undirected complete graph on \c n vertices
- * will have one motif of \p size \c n, and \c n motifs
+ * will have one motif of size \c n, and \c n motifs
  * of \p size <code>n - 1</code>. As another example, one triangle
  * and a separate vertex will have zero motifs of size four.
  *
  * </para><para>
  * This function is useful for large graphs for which it is not
  * feasible to count all the different motifs, because there are very
  * many of them.
@@ -452,25 +518,25 @@
  * </para><para>
  * Directed motifs will be counted in directed graphs and undirected
  * motifs in undirected graphs.
  *
  * \param graph The graph object to study.
  * \param est Pointer to an integer type, the result will be stored
  *        here.
- * \param size The size of the motif to look for.
+ * \param size The size of the motifs to look for.
  * \param cut_prob Vector giving the probabilities to cut a branch of
  *        the search tree and omit counting the motifs in that branch.
- *        It contains a probability for each level. Supply \c size
+ *        It contains a probability for each level. Supply \p size
  *        zeros here to count all the motifs in the sample.
  * \param sample_size The number of vertices to use as the
- *        sample. This parameter is only used if the \c parsample
+ *        sample. This parameter is only used if the \p parsample
  *        argument is a null pointer.
  * \param parsample Either pointer to an initialized vector or a null
  *        pointer. If a vector then the vertex ids in the vector are
- *        used as a sample. If a null pointer then the \c sample_size
+ *        used as a sample. If a null pointer then the \p sample_size
  *        argument is used to create a sample of vertices drawn with
  *        uniform probability.
  * \return Error code.
  * \sa \ref igraph_motifs_randesu(), \ref igraph_motifs_randesu_no().
  *
  * Time complexity: TODO.
  */
@@ -487,14 +553,19 @@
     igraph_vector_t adjverts; /* this is V_E */
     igraph_stack_t stack;     /* this is S */
     long int *added;
     igraph_vector_t *sample;
     long int sam;
     long int i;
 
+    if (size < 3) {
+        IGRAPH_ERRORF("Motif size must be at least 3, received %" IGRAPH_PRId ".",
+                      IGRAPH_EINVAL, (igraph_integer_t) size);
+    }
+
     if (igraph_vector_size(cut_prob) != size) {
         IGRAPH_ERRORF("Cut probability vector size (%ld) must agree with motif size (%" IGRAPH_PRId ").",
                       IGRAPH_EINVAL, igraph_vector_size(cut_prob), size);
     }
 
     if (parsample && igraph_vector_size(parsample) != 0) {
         igraph_real_t min, max;
@@ -701,14 +772,19 @@
     igraph_vector_t vids;     /* this is G */
     igraph_vector_t adjverts; /* this is V_E */
     igraph_stack_t stack;     /* this is S */
     long int *added;
     long int father;
     long int i;
 
+    if (size < 3) {
+        IGRAPH_ERRORF("Motif size must be at least 3, received %" IGRAPH_PRId ".",
+                      IGRAPH_EINVAL, (igraph_integer_t) size);
+    }
+
     if (igraph_vector_size(cut_prob) != size) {
         IGRAPH_ERRORF("Cut probability vector size (%ld) must agree with motif size (%" IGRAPH_PRId ").",
                       IGRAPH_EINVAL, igraph_vector_size(cut_prob), size);
     }
     added = IGRAPH_CALLOC(no_of_nodes, long int);
     if (added == 0) {
         IGRAPH_ERROR("Cannot find motifs.", IGRAPH_ENOMEM);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/other.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/other.c`

 * *Files 1% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 */
 
 #include "igraph_nongraph.h"
 #include "igraph_random.h"
 #include "igraph_types.h"
 
 #include "core/interruption.h"
-#include "plfit/error.h"
+#include "plfit/plfit_error.h"
 #include "plfit/plfit.h"
 
 #include <math.h>
 
 /**
  * \ingroup nongraph
  * \function igraph_running_mean
@@ -59,15 +59,15 @@
     long int i;
 
     /* Check */
     if (igraph_vector_size(data) < binwidth) {
         IGRAPH_ERRORF("Data vector length (%ld) smaller than bin width (%" IGRAPH_PRId ").", IGRAPH_EINVAL, igraph_vector_size(data), binwidth);
     }
     if (binwidth < 1) {
-        IGRAPH_ERRORF("Bin width for running mean should be at least 1, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, igraph_vector_size(data), binwidth);
+        IGRAPH_ERRORF("Bin width for running mean should be at least 1, got %" IGRAPH_PRId ".", IGRAPH_EINVAL, binwidth);
     }
 
     /* Memory for result */
 
     IGRAPH_CHECK(igraph_vector_resize(res, (long int)(igraph_vector_size(data) - binwidth + 1)));
 
     /* Initial bin */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/scan.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/scan.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/sir.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/sir.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/misc/spanning_trees.c` & `igraph-0.9.9/vendor/source/igraph/src/misc/spanning_trees.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/add_edge.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/add_edge.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/complementer.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/complementer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/compose.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/compose.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/connect_neighborhood.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/connect_neighborhood.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/contract.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/contract.c`

 * *Files 7% similar despite different names*

```diff
@@ -48,16 +48,18 @@
  * to sets of vertices in the input graph.
  * \param graph The input graph, it can be directed or
  *        undirected.
  * \param mapping A vector giving the mapping. For each
  *        vertex in the original graph, it should contain
  *        its id in the new graph.
  * \param vertex_comb What to do with the vertex attributes.
- *        See the igraph manual section about attributes for
- *        details.
+ *        \c NULL means that vertex attributes are not kept
+ *        after the contraction (not even for unaffected
+ *        vertices). See the igraph manual section about attributes
+ *        for details.
  * \return Error code.
  *
  * Time complexity: O(|V|+|E|), linear in the number
  * or vertices plus edges.
  */
 
 int igraph_contract_vertices(igraph_t *graph,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/difference.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/difference.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/disjoint_union.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/disjoint_union.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/intersection.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/intersection.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/misc_internal.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/misc_internal.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/misc_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/operators/misc_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/permute.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/permute.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/rewire.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/rewire.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/rewire_edges.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/multiplicity.c`

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 /* -*- mode: C -*-  */
 /* vim:set ts=4 sw=4 sts=4 et: */
 /*
    IGraph library.
-   Copyright (C) 2003-2021 The igraph development team
+   Copyright (C) 2005-2012  Gabor Csardi <csardi.gabor@gmail.com>
+   334 Harvard street, Cambridge, MA 02139 USA
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
@@ -17,378 +18,339 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
-#include "igraph_games.h"
+#include "igraph_structural.h"
 
-#include "igraph_conversion.h"
-#include "igraph_constructors.h"
+#include "igraph_adjlist.h"
 #include "igraph_interface.h"
-#include "igraph_random.h"
 
-#include "graph/attributes.h"
-
-static int igraph_i_rewire_edges_no_multiple(igraph_t *graph, igraph_real_t prob,
-                                             igraph_bool_t loops,
-                                             igraph_vector_t *edges) {
-
-    int no_verts = igraph_vcount(graph);
-    int no_edges = igraph_ecount(graph);
-    igraph_vector_t eorder, tmp;
-    igraph_vector_int_t first, next, prev, marked;
-    int i, to_rewire, last_other = -1;
-
-    /* Create our special graph representation */
-
-# define ADD_STUB(vertex, stub) do {                \
-        if (VECTOR(first)[(vertex)]) {              \
-            VECTOR(prev)[(int) VECTOR(first)[(vertex)]-1]=(stub)+1;   \
-        }                               \
-        VECTOR(next)[(stub)]=VECTOR(first)[(vertex)];       \
-        VECTOR(prev)[(stub)]=0;                 \
-        VECTOR(first)[(vertex)]=(stub)+1;               \
-    } while (0)
-
-# define DEL_STUB(vertex, stub) do {                    \
-        if (VECTOR(next)[(stub)]) {                     \
-            VECTOR(prev)[VECTOR(next)[(stub)]-1]=VECTOR(prev)[(stub)];    \
-        }                                   \
-        if (VECTOR(prev)[(stub)]) {                     \
-            VECTOR(next)[VECTOR(prev)[(stub)]-1]=VECTOR(next)[(stub)];    \
-        } else {                                \
-            VECTOR(first)[(vertex)]=VECTOR(next)[(stub)];         \
-        }                                   \
-    } while (0)
-
-# define MARK_NEIGHBORS(vertex) do {                \
-        int xxx_ =VECTOR(first)[(vertex)];              \
-        while (xxx_) {                      \
-            int o= (int) VECTOR(*edges)[xxx_ % 2 ? xxx_ : xxx_-2];    \
-            VECTOR(marked)[o]=other+1;                \
-            xxx_=VECTOR(next)[xxx_-1];                \
-        }                               \
-    } while (0)
-
-    IGRAPH_CHECK(igraph_vector_int_init(&first, no_verts));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &first);
-    IGRAPH_CHECK(igraph_vector_int_init(&next, no_edges * 2));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &next);
-    IGRAPH_CHECK(igraph_vector_int_init(&prev, no_edges * 2));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &prev);
-    IGRAPH_CHECK(igraph_get_edgelist(graph, edges, /*bycol=*/ 0));
-    IGRAPH_VECTOR_INIT_FINALLY(&eorder, no_edges);
-    IGRAPH_VECTOR_INIT_FINALLY(&tmp, no_edges);
-    for (i = 0; i < no_edges; i++) {
-        int idx1 = 2 * i, idx2 = idx1 + 1,
-            from = (int) VECTOR(*edges)[idx1], to = (int) VECTOR(*edges)[idx2];
-        VECTOR(tmp)[i] = from;
-        ADD_STUB(from, idx1);
-        ADD_STUB(to, idx2);
-    }
-    IGRAPH_CHECK(igraph_vector_order1(&tmp, &eorder, no_verts));
-    igraph_vector_destroy(&tmp);
-    IGRAPH_FINALLY_CLEAN(1);
-
-    IGRAPH_CHECK(igraph_vector_int_init(&marked, no_verts));
-    IGRAPH_FINALLY(igraph_vector_int_destroy, &marked);
-
-    /* Rewire the stubs, part I */
-
-    to_rewire = (int) RNG_GEOM(prob);
-    while (to_rewire < no_edges) {
-        int stub = (int) (2 * VECTOR(eorder)[to_rewire] + 1);
-        int v = (int) VECTOR(*edges)[stub];
-        int ostub = stub - 1;
-        int other = (int) VECTOR(*edges)[ostub];
-        int pot;
-        if (last_other != other) {
-            MARK_NEIGHBORS(other);
-        }
-        /* Do the rewiring */
-        do {
-            if (loops) {
-                pot = (int) RNG_INTEGER(0, no_verts - 1);
-            } else {
-                pot = (int) RNG_INTEGER(0, no_verts - 2);
-                pot = pot != other ? pot : no_verts - 1;
-            }
-        } while (VECTOR(marked)[pot] == other + 1 && pot != v);
-
-        if (pot != v) {
-            DEL_STUB(v, stub);
-            ADD_STUB(pot, stub);
-            VECTOR(marked)[v] = 0;
-            VECTOR(marked)[pot] = other + 1;
-            VECTOR(*edges)[stub] = pot;
-        }
-
-        to_rewire += RNG_GEOM(prob) + 1;
-        last_other = other;
-    }
-
-    /* Create the new index, from the potentially rewired stubs */
+/**
+ * \function igraph_is_simple
+ * \brief Decides whether the input graph is a simple graph.
+ *
+ * </para><para>
+ * A graph is a simple graph if it does not contain loop edges and
+ * multiple edges.
+ *
+ * \param graph The input graph.
+ * \param res Pointer to a boolean constant, the result
+ *     is stored here.
+ * \return Error code.
+ *
+ * \sa \ref igraph_is_loop() and \ref igraph_is_multiple() to
+ * find the loops and multiple edges, \ref igraph_simplify() to
+ * get rid of them, or \ref igraph_has_multiple() to decide whether
+ * there is at least one multiple edge.
+ *
+ * Time complexity: O(|V|+|E|).
+ */
+int igraph_is_simple(const igraph_t *graph, igraph_bool_t *res) {
+    long int vc = igraph_vcount(graph);
+    long int ec = igraph_ecount(graph);
 
-    IGRAPH_VECTOR_INIT_FINALLY(&tmp, no_edges);
-    for (i = 0; i < no_edges; i++) {
-        VECTOR(tmp)[i] = VECTOR(*edges)[2 * i + 1];
-    }
-    IGRAPH_CHECK(igraph_vector_order1(&tmp, &eorder, no_verts));
-    igraph_vector_destroy(&tmp);
-    IGRAPH_FINALLY_CLEAN(1);
-
-    /* Rewire the stubs, part II */
-
-    igraph_vector_int_null(&marked);
-    last_other = -1;
-
-    to_rewire = (int) RNG_GEOM(prob);
-    while (to_rewire < no_edges) {
-        int stub = (int) (2 * VECTOR(eorder)[to_rewire]);
-        int v = (int) VECTOR(*edges)[stub];
-        int ostub = stub + 1;
-        int other = (int) VECTOR(*edges)[ostub];
-        int pot;
-        if (last_other != other) {
-            MARK_NEIGHBORS(other);
-        }
-        /* Do the rewiring */
-        do {
-            if (loops) {
-                pot = (int) RNG_INTEGER(0, no_verts - 1);
-            } else {
-                pot = (int) RNG_INTEGER(0, no_verts - 2);
-                pot = pot != other ? pot : no_verts - 1;
+    if (vc == 0 || ec == 0) {
+        *res = 1;
+    } else {
+        igraph_vector_t neis;
+        long int i, j, n;
+        igraph_bool_t found = 0;
+        IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
+        for (i = 0; i < vc; i++) {
+            IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) i, IGRAPH_OUT));
+            n = igraph_vector_size(&neis);
+            for (j = 0; j < n; j++) {
+                if (VECTOR(neis)[j] == i) {
+                    found = 1; break;
+                }
+                if (j > 0 && VECTOR(neis)[j - 1] == VECTOR(neis)[j]) {
+                    found = 1; break;
+                }
             }
-        } while (VECTOR(marked)[pot] == other + 1 && pot != v);
-        if (pot != v) {
-            DEL_STUB(v, stub);
-            ADD_STUB(pot, stub);
-            VECTOR(marked)[v] = 0;
-            VECTOR(marked)[pot] = other + 1;
-            VECTOR(*edges)[stub] = pot;
         }
-
-        to_rewire += RNG_GEOM(prob) + 1;
-        last_other = other;
+        *res = !found;
+        igraph_vector_destroy(&neis);
+        IGRAPH_FINALLY_CLEAN(1);
     }
 
-    igraph_vector_int_destroy(&marked);
-    igraph_vector_int_destroy(&prev);
-    igraph_vector_int_destroy(&next);
-    igraph_vector_int_destroy(&first);
-    igraph_vector_destroy(&eorder);
-    IGRAPH_FINALLY_CLEAN(5);
-
     return 0;
 }
 
-#undef ADD_STUB
-#undef DEL_STUB
-#undef MARK_NEIGHBORS
 
 /**
- * \function igraph_rewire_edges
- * \brief Rewires the edges of a graph with constant probability.
+ * \function igraph_has_multiple
+ * \brief Check whether the graph has at least one multiple edge.
  *
- * This function rewires the edges of a graph with a constant
- * probability. More precisely each end point of each edge is rewired
- * to a uniformly randomly chosen vertex with constant probability \p
- * prob.
- *
- * </para><para> Note that this function modifies the input \p graph,
- * call \ref igraph_copy() if you want to keep it.
- *
- * \param graph The input graph, this will be rewired, it can be
- *    directed or undirected.
- * \param prob The rewiring probability a constant between zero and
- *    one (inclusive).
- * \param loops Boolean, whether loop edges are allowed in the new
- *    graph, or not.
- * \param multiple Boolean, whether multiple edges are allowed in the
- *    new graph.
+ * </para><para>
+ * An edge is a multiple edge if there is another
+ * edge with the same head and tail vertices in the graph.
+ *
+ * \param graph The input graph.
+ * \param res Pointer to a boolean variable, the result will be stored here.
  * \return Error code.
  *
- * \sa \ref igraph_watts_strogatz_game() uses this function for the
- * rewiring.
+ * \sa \ref igraph_count_multiple(), \ref igraph_is_multiple() and \ref igraph_simplify().
  *
- * Time complexity: O(|V|+|E|).
+ * Time complexity: O(e*d), e is the number of edges to check and d is the
+ * average degree (out-degree in directed graphs) of the vertices at the
+ * tail of the edges.
+ *
+ * \example examples/simple/igraph_has_multiple.c
  */
-int igraph_rewire_edges(igraph_t *graph, igraph_real_t prob,
-                        igraph_bool_t loops, igraph_bool_t multiple) {
-
-    igraph_t newgraph;
-    long int no_of_edges = igraph_ecount(graph);
-    long int no_of_nodes = igraph_vcount(graph);
-    long int endpoints = no_of_edges * 2;
-    long int to_rewire;
-    igraph_vector_t edges;
-
-    if (prob < 0 || prob > 1) {
-        IGRAPH_ERROR("Rewiring probability should be between zero and one",
-                     IGRAPH_EINVAL);
-    }
+int igraph_has_multiple(const igraph_t *graph, igraph_bool_t *res) {
+    long int vc = igraph_vcount(graph);
+    long int ec = igraph_ecount(graph);
+    igraph_bool_t directed = igraph_is_directed(graph);
 
-    if (prob == 0) {
-        /* This is easy, just leave things as they are */
-        return IGRAPH_SUCCESS;
-    }
-
-    IGRAPH_VECTOR_INIT_FINALLY(&edges, endpoints);
-
-    RNG_BEGIN();
-
-    if (prob != 0 && no_of_edges > 0) {
-        if (multiple) {
-            /* If multiple edges are allowed, then there is an easy and fast
-            method. Each endpoint of an edge is rewired with probability p,
-             so the "skips" between the really rewired endpoints follow a
-             geometric distribution. */
-            IGRAPH_CHECK(igraph_get_edgelist(graph, &edges, 0));
-            to_rewire = (long int) RNG_GEOM(prob);
-            while (to_rewire < endpoints) {
-                if (loops) {
-                    VECTOR(edges)[to_rewire] = RNG_INTEGER(0, no_of_nodes - 1);
-                } else {
-                    long int opos = to_rewire % 2 ? to_rewire - 1 : to_rewire + 1;
-                    long int nei = (long int) VECTOR(edges)[opos];
-                    long int r = RNG_INTEGER(0, no_of_nodes - 2);
-                    VECTOR(edges)[ to_rewire ] = (r != nei ? r : no_of_nodes - 1);
+    if (vc == 0 || ec == 0) {
+        *res = 0;
+    } else {
+        igraph_vector_t neis;
+        long int i, j, n;
+        igraph_bool_t found = 0;
+        IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
+        for (i = 0; i < vc && !found; i++) {
+            IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) i,
+                                          IGRAPH_OUT));
+            n = igraph_vector_size(&neis);
+            for (j = 1; j < n; j++) {
+                if (VECTOR(neis)[j - 1] == VECTOR(neis)[j]) {
+                    /* If the graph is undirected, loop edges appear twice in the neighbor
+                     * list, so check the next item as well */
+                    if (directed) {
+                        /* Directed, so this is a real multiple edge */
+                        found = 1; break;
+                    } else if (VECTOR(neis)[j - 1] != i) {
+                        /* Undirected, but not a loop edge */
+                        found = 1; break;
+                    } else if (j < n - 1 && VECTOR(neis)[j] == VECTOR(neis)[j + 1]) {
+                        /* Undirected, loop edge, multiple times */
+                        found = 1; break;
+                    }
                 }
-                to_rewire += RNG_GEOM(prob) + 1;
             }
-
-        } else {
-            IGRAPH_CHECK(igraph_i_rewire_edges_no_multiple(graph, prob, loops,
-                         &edges));
         }
+        *res = found;
+        igraph_vector_destroy(&neis);
+        IGRAPH_FINALLY_CLEAN(1);
     }
 
-    RNG_END();
-
-    IGRAPH_CHECK(igraph_create(&newgraph, &edges, (igraph_integer_t) no_of_nodes,
-                               igraph_is_directed(graph)));
-    igraph_vector_destroy(&edges);
-    IGRAPH_FINALLY_CLEAN(1);
-
-    IGRAPH_FINALLY(igraph_destroy, &newgraph);
-    IGRAPH_I_ATTRIBUTE_DESTROY(&newgraph);
-    IGRAPH_I_ATTRIBUTE_COPY(&newgraph, graph, 1, 1, 1);
-    IGRAPH_FINALLY_CLEAN(1);
-    igraph_destroy(graph);
-    *graph = newgraph;
-
     return 0;
 }
 
 /**
- * \function igraph_rewire_directed_edges
- * \brief Rewires the chosen endpoint of directed edges.
+ * \function igraph_is_multiple
+ * \brief Find the multiple edges in a graph.
  *
- * This function rewires either the start or end of directed edges in a graph
- * with a constant probability. Correspondingly, either the in-degree sequence
- * or the out-degree sequence of the graph will be preserved.
- *
- * </para><para> Note that this function modifies the input \p graph,
- * call \ref igraph_copy() if you want to keep it.
- *
- * </para><para> This function can produce multiple edges between two vertices.
- *
- * \param graph The input graph, this will be rewired, it can be
- *    directed or undirected. If it is undirected or \p mode is set to
- *    IGRAPH_ALL, \ref igraph_rewire_edges() will be called.
- * \param prob The rewiring probability, a constant between zero and
- *    one (inclusive).
- * \param loops Boolean, whether loop edges are allowed in the new
- *    graph, or not.
- * \param mode The endpoints of directed edges to rewire. It is ignored for
- *    undirected graphs. Possible values:
- *        \clist
- *        \cli IGRAPH_OUT
- *          rewire the end of each directed edge
- *        \cli IGRAPH_IN
- *          rewire the start of each directed edge
- *        \cli IGRAPH_ALL
- *          rewire both endpoints of each edge
- *        \endclist
+ * </para><para>
+ * An edge is a multiple edge if there is another
+ * edge with the same head and tail vertices in the graph.
+ *
+ * </para><para>
+ * Note that this function returns true only for the second or more
+ * appearances of the multiple edges.
+ * \param graph The input graph.
+ * \param res Pointer to a boolean vector, the result will be stored
+ *        here. It will be resized as needed.
+ * \param es The edges to check. Supply \ref igraph_ess_all() if you want
+ *        to check all edges.
  * \return Error code.
  *
- * \sa \ref igraph_rewire_edges(), \ref igraph_rewire()
+ * \sa \ref igraph_count_multiple(), \ref igraph_has_multiple() and \ref igraph_simplify().
+ *
+ * Time complexity: O(e*d), e is the number of edges to check and d is the
+ * average degree (out-degree in directed graphs) of the vertices at the
+ * tail of the edges.
  *
- * Time complexity: O(|E|).
+ * \example examples/simple/igraph_is_multiple.c
  */
-int igraph_rewire_directed_edges(igraph_t *graph, igraph_real_t prob,
-                                 igraph_bool_t loops, igraph_neimode_t mode) {
+int igraph_is_multiple(const igraph_t *graph, igraph_vector_bool_t *res,
+                       igraph_es_t es) {
+    igraph_eit_t eit;
+    long int i, j, n;
+    igraph_lazy_inclist_t inclist;
+
+    IGRAPH_CHECK(igraph_eit_create(graph, es, &eit));
+    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
+
+    IGRAPH_CHECK(igraph_lazy_inclist_init(graph, &inclist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE));
+    IGRAPH_FINALLY(igraph_lazy_inclist_destroy, &inclist);
+
+    IGRAPH_CHECK(igraph_vector_bool_resize(res, IGRAPH_EIT_SIZE(eit)));
+
+    for (i = 0; !IGRAPH_EIT_END(eit); i++, IGRAPH_EIT_NEXT(eit)) {
+        long int e = IGRAPH_EIT_GET(eit);
+        long int from = IGRAPH_FROM(graph, e);
+        long int to = IGRAPH_TO(graph, e);
+        igraph_vector_int_t *neis =
+            igraph_lazy_inclist_get(&inclist, (igraph_integer_t) from);
+
+        if (neis == 0) {
+            /* Most likely out of memory */
+            IGRAPH_ERROR("Out of memory while building lazy incidence list", IGRAPH_ENOMEM);
+        }
 
-    if (prob < 0 || prob > 1) {
-        IGRAPH_ERROR("Rewiring probability should be between zero and one",
-                     IGRAPH_EINVAL);
-    }
+        VECTOR(*res)[i] = 0;
 
-    if (mode != IGRAPH_OUT && mode != IGRAPH_IN &&
-        mode != IGRAPH_ALL) {
-        IGRAPH_ERROR("Invalid mode argument", IGRAPH_EINVMODE);
+        n = igraph_vector_int_size(neis);
+        for (j = 0; j < n; j++) {
+            long int e2 = (long int) VECTOR(*neis)[j];
+            long int to2 = IGRAPH_OTHER(graph, e2, from);
+            if (to2 == to && e2 < e) {
+                VECTOR(*res)[i] = 1;
+            }
+        }
     }
 
-    if (prob == 0) {
-        return IGRAPH_SUCCESS;
-    }
+    igraph_lazy_inclist_destroy(&inclist);
+    igraph_eit_destroy(&eit);
+    IGRAPH_FINALLY_CLEAN(2);
+    return 0;
+}
 
-    if (igraph_is_directed(graph) && mode != IGRAPH_ALL) {
-        igraph_t newgraph;
-        long int no_of_edges = igraph_ecount(graph);
-        long int no_of_nodes = igraph_vcount(graph);
-        long int to_rewire;
-        long int offset = 0;
-        igraph_vector_t edges;
-
-        IGRAPH_VECTOR_INIT_FINALLY(&edges, 2 * no_of_edges);
-
-        switch (mode) {
-        case IGRAPH_IN:
-            offset = 0;
-            break;
-        case IGRAPH_OUT:
-            offset = 1;
-            break;
-        case IGRAPH_ALL:
-            break; /* suppress compiler warning */
-        }
 
-        IGRAPH_CHECK(igraph_get_edgelist(graph, &edges, 0));
+/**
+ * \function igraph_count_multiple
+ * \brief Count the number of appearances of the edges in a graph.
+ *
+ * </para><para>
+ * If the graph has no multiple edges then the result vector will be
+ * filled with ones.
+ * (An edge is a multiple edge if there is another
+ * edge with the same head and tail vertices in the graph.)
+ *
+ * </para><para>
+ * \param graph The input graph.
+ * \param res Pointer to a vector, the result will be stored
+ *        here. It will be resized as needed.
+ * \param es The edges to check. Supply \ref igraph_ess_all() if you want
+ *        to check all edges.
+ * \return Error code.
+ *
+ * \sa \ref igraph_is_multiple() and \ref igraph_simplify().
+ *
+ * Time complexity: O(E d), E is the number of edges to check and d is the
+ * average degree (out-degree in directed graphs) of the vertices at the
+ * tail of the edges.
+ */
+int igraph_count_multiple(const igraph_t *graph, igraph_vector_t *res, igraph_es_t es) {
+    igraph_eit_t eit;
+    long int i, j, n;
+    igraph_lazy_inclist_t inclist;
+
+    IGRAPH_CHECK(igraph_eit_create(graph, es, &eit));
+    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
+    IGRAPH_CHECK(igraph_lazy_inclist_init(graph, &inclist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE));
+    IGRAPH_FINALLY(igraph_lazy_inclist_destroy, &inclist);
+
+    IGRAPH_CHECK(igraph_vector_resize(res, IGRAPH_EIT_SIZE(eit)));
+
+    for (i = 0; !IGRAPH_EIT_END(eit); i++, IGRAPH_EIT_NEXT(eit)) {
+        long int e = IGRAPH_EIT_GET(eit);
+        long int from = IGRAPH_FROM(graph, e);
+        long int to = IGRAPH_TO(graph, e);
+        igraph_vector_int_t *neis =
+            igraph_lazy_inclist_get(&inclist, (igraph_integer_t) from);
+
+        if (neis == 0) {
+            /* Most likely out of memory */
+            IGRAPH_ERROR("Out of memory while building lazy incidence list", IGRAPH_ENOMEM);
+        }
 
-        RNG_BEGIN();
+        VECTOR(*res)[i] = 0;
 
-        to_rewire = RNG_GEOM(prob);
-        while (to_rewire < no_of_edges) {
-            if (loops) {
-                VECTOR(edges)[2 * to_rewire + offset] = RNG_INTEGER(0, no_of_nodes - 1);
-            } else {
-                long int nei = (long int) VECTOR(edges)[2 * to_rewire + (1 - offset)];
-                long int r = RNG_INTEGER(0, no_of_nodes - 2);
-                VECTOR(edges)[2 * to_rewire + offset] = (r != nei ? r : no_of_nodes - 1);
+        n = igraph_vector_int_size(neis);
+        for (j = 0; j < n; j++) {
+            long int e2 = (long int) VECTOR(*neis)[j];
+            long int to2 = IGRAPH_OTHER(graph, e2, from);
+            if (to2 == to) {
+                VECTOR(*res)[i] += 1;
             }
-            to_rewire += RNG_GEOM(prob) + 1;
         }
+    }
 
-        RNG_END();
+    igraph_lazy_inclist_destroy(&inclist);
+    igraph_eit_destroy(&eit);
+    IGRAPH_FINALLY_CLEAN(2);
 
-        IGRAPH_CHECK(igraph_create(&newgraph, &edges, (igraph_integer_t) no_of_nodes,
-                                   igraph_is_directed(graph)));
-        igraph_vector_destroy(&edges);
-        IGRAPH_FINALLY_CLEAN(1);
+    return IGRAPH_SUCCESS;
+}
 
-        IGRAPH_FINALLY(igraph_destroy, &newgraph);
-        IGRAPH_I_ATTRIBUTE_DESTROY(&newgraph);
-        IGRAPH_I_ATTRIBUTE_COPY(&newgraph, graph, 1, 1, 1);
+/**
+ * \function igraph_is_mutual
+ * Check whether the edges of a directed graph are mutual.
+ *
+ * An (A,B) edge is mutual if the graph contains the (B,A) edge, too.
+ * </para>
+ *
+ * <para>An undirected graph only has mutual edges, by definition.
+ * </para>
+ *
+ * <para>Edge multiplicity is not considered here, e.g. if there are two
+ * (A,B) edges and one (B,A) edge, then all three are considered to be
+ * mutual.
+ * </para>
+ *
+ * <para>Loops are always mutual.
+ *
+ * \param graph The input graph.
+ * \param res Pointer to an initialized vector, the result is stored
+ *        here.
+ * \param es The sequence of edges to check. Supply
+ *        <code>igraph_ess_all()</code> for all edges, see \ref
+ *        igraph_ess_all().
+ * \return Error code.
+ *
+ * Time complexity: O(n log(d)), n is the number of edges supplied, d
+ * is the maximum in-degree of the vertices that are targets of the
+ * supplied edges. An upper limit of the time complexity is O(n log(|E|)),
+ * |E| is the number of edges in the graph.
+ */
+int igraph_is_mutual(const igraph_t *graph, igraph_vector_bool_t *res, igraph_es_t es) {
+
+    igraph_eit_t eit;
+    igraph_lazy_adjlist_t adjlist;
+    long int i;
+
+    /* How many edges do we have? */
+    IGRAPH_CHECK(igraph_eit_create(graph, es, &eit));
+    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
+    IGRAPH_CHECK(igraph_vector_bool_resize(res, IGRAPH_EIT_SIZE(eit)));
+
+    /* An undirected graph has mutual edges by definition,
+       res is already properly resized */
+    if (! igraph_is_directed(graph)) {
+        igraph_vector_bool_fill(res, 1);
+        igraph_eit_destroy(&eit);
         IGRAPH_FINALLY_CLEAN(1);
-        igraph_destroy(graph);
-        *graph = newgraph;
+        return IGRAPH_SUCCESS;
+    }
 
-    } else {
-        IGRAPH_CHECK(igraph_rewire_edges(graph, prob, loops, /* multiple = */ 1));
+    IGRAPH_CHECK(igraph_lazy_adjlist_init(graph, &adjlist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
+    IGRAPH_FINALLY(igraph_lazy_adjlist_destroy, &adjlist);
+
+    for (i = 0; ! IGRAPH_EIT_END(eit); i++, IGRAPH_EIT_NEXT(eit)) {
+        long int edge = IGRAPH_EIT_GET(eit);
+        long int from = IGRAPH_FROM(graph, edge);
+        long int to = IGRAPH_TO(graph, edge);
+
+        /* Check whether there is a to->from edge, search for from in the
+           out-list of to. We don't search an empty vector, because
+           vector_binsearch seems to have a bug with this. */
+        igraph_vector_int_t *neis = igraph_lazy_adjlist_get(&adjlist,
+                                (igraph_integer_t) to);
+        if (igraph_vector_int_empty(neis)) {
+            VECTOR(*res)[i] = 0;
+        } else {
+            VECTOR(*res)[i] = igraph_vector_int_binsearch2(neis, from);
+        }
     }
 
-    return 0;
+    igraph_lazy_adjlist_destroy(&adjlist);
+    igraph_eit_destroy(&eit);
+    IGRAPH_FINALLY_CLEAN(2);
+
+    return IGRAPH_SUCCESS;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/simplify.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/simplify.c`

 * *Files 4% similar despite different names*

```diff
@@ -32,16 +32,18 @@
  * \ingroup structural
  * \function igraph_simplify
  * \brief Removes loop and/or multiple edges from the graph.
  *
  * \param graph The graph object.
  * \param multiple Logical, if true, multiple edges will be removed.
  * \param loops Logical, if true, loops (self edges) will be removed.
- * \param edge_comb What to do with the edge attributes. See the igraph
- *        manual section about attributes for details.
+ * \param edge_comb What to do with the edge attributes. \c NULL means to
+ *        discard the edge attributes after the operation, even for edges
+ *        that were unaffeccted. See the igraph manual section about attributes
+ *        for details.
  * \return Error code:
  *    \c IGRAPH_ENOMEM if we are out of memory.
  *
  * Time complexity: O(|V|+|E|).
  *
  * \example examples/simple/igraph_simplify.c
  */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/subgraph.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/subgraph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/subgraph.h` & `igraph-0.9.9/vendor/source/igraph/src/operators/subgraph.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/operators/union.c` & `igraph-0.9.9/vendor/source/igraph/src/operators/union.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/all_shortest_paths.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/all_shortest_paths.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/bellman_ford.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/bellman_ford.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/dijkstra.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/dijkstra.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/distances.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/distances.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/eulerian.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/eulerian.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/histogram.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/histogram.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/johnson.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/johnson.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/random_walk.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/random_walk.c`

 * *Files 2% similar despite different names*

```diff
@@ -23,14 +23,15 @@
 
 #include "igraph_paths.h"
 
 #include "igraph_adjlist.h"
 #include "igraph_interface.h"
 #include "igraph_random.h"
 #include "igraph_memory.h"
+
 #include "core/interruption.h"
 
 /**
  * \function igraph_random_walk
  * Perform a random walk on a graph
  *
  * Performs a random walk with a given length on a graph, from the given
@@ -71,18 +72,18 @@
     */
 
     igraph_lazy_adjlist_t adj;
     igraph_integer_t vc = igraph_vcount(graph);
     igraph_integer_t i;
 
     if (start < 0 || start >= vc) {
-        IGRAPH_ERROR("Invalid start vertex", IGRAPH_EINVAL);
+        IGRAPH_ERROR("Invalid start vertex.", IGRAPH_EINVAL);
     }
     if (steps < 0) {
-        IGRAPH_ERROR("Invalid number of steps", IGRAPH_EINVAL);
+        IGRAPH_ERROR("Invalid number of steps.", IGRAPH_EINVAL);
     }
 
     IGRAPH_CHECK(igraph_lazy_adjlist_init(graph, &adj, mode, IGRAPH_LOOPS, IGRAPH_MULTIPLE));
     IGRAPH_FINALLY(igraph_lazy_adjlist_destroy, &adj);
 
     IGRAPH_CHECK(igraph_vector_resize(walk, steps));
 
@@ -96,26 +97,26 @@
         nn = igraph_vector_int_size(neis);
 
         if (IGRAPH_UNLIKELY(nn == 0)) {
             igraph_vector_resize(walk, i);
             if (stuck == IGRAPH_RANDOM_WALK_STUCK_RETURN) {
                 break;
             } else {
-                IGRAPH_ERROR("Random walk got stuck", IGRAPH_ERWSTUCK);
+                IGRAPH_ERROR("Random walk got stuck.", IGRAPH_ERWSTUCK);
             }
         }
         start = VECTOR(*walk)[i] = VECTOR(*neis)[ RNG_INTEGER(0, nn - 1) ];
     }
 
     RNG_END();
 
     igraph_lazy_adjlist_destroy(&adj);
     IGRAPH_FINALLY_CLEAN(1);
 
-    return 0;
+    return IGRAPH_SUCCESS;
 }
 
 
 /* Used as item destructor for 'cdfs' in igraph_random_edge_walk(). */
 static void vec_destr(igraph_vector_t *vec) {
     if (vec != NULL) {
         igraph_vector_destroy(vec);
@@ -165,43 +166,42 @@
     igraph_integer_t vc = igraph_vcount(graph);
     igraph_integer_t ec = igraph_ecount(graph);
     igraph_integer_t i;
     igraph_inclist_t il;
     igraph_vector_t weight_temp;
     igraph_vector_ptr_t cdfs; /* cumulative distribution vectors for each node, used for weighted choice */
 
-    /* the fourth igraph_neimode_t value, IGRAPH_TOTAL, is disallowed */
     if (! (mode == IGRAPH_ALL || mode == IGRAPH_IN || mode == IGRAPH_OUT)) {
-        IGRAPH_ERROR("Invalid mode parameter", IGRAPH_EINVMODE);
+        IGRAPH_ERROR("Invalid mode parameter.", IGRAPH_EINVMODE);
     }
 
     /* ref switch statement at end of main loop */
     if (! igraph_is_directed(graph)) {
         mode = IGRAPH_ALL;
     }
 
     if (start < 0 || start >= vc) {
-        IGRAPH_ERROR("Invalid start vertex", IGRAPH_EINVAL);
+        IGRAPH_ERROR("Invalid start vertex.", IGRAPH_EINVAL);
     }
 
     if (steps < 0) {
-        IGRAPH_ERROR("Invalid number of steps", IGRAPH_EINVAL);
+        IGRAPH_ERROR("Invalid number of steps.", IGRAPH_EINVAL);
     }
 
     if (weights) {
         if (igraph_vector_size(weights) != ec) {
-            IGRAPH_ERROR("Invalid weight vector length", IGRAPH_EINVAL);
+            IGRAPH_ERROR("Invalid weight vector length.", IGRAPH_EINVAL);
         }
         if (ec > 0) {
             igraph_real_t min = igraph_vector_min(weights);
             if (min < 0) {
-                IGRAPH_ERROR("Weights must be non-negative", IGRAPH_EINVAL);
+                IGRAPH_ERROR("Weights must be non-negative.", IGRAPH_EINVAL);
             }
             else if (igraph_is_nan(min)) {
-                IGRAPH_ERROR("Weights must not contain NaN values", IGRAPH_EINVAL);
+                IGRAPH_ERROR("Weights must not contain NaN values.", IGRAPH_EINVAL);
             }
         }
     }
 
     IGRAPH_CHECK(igraph_vector_resize(edgewalk, steps));
 
     IGRAPH_CHECK(igraph_inclist_init(graph, &il, mode, IGRAPH_LOOPS));
@@ -227,29 +227,29 @@
 
         /* are we stuck? */
         if (IGRAPH_UNLIKELY(degree == 0)) {
             igraph_vector_resize(edgewalk, i); /* can't fail since size is reduced, skip IGRAPH_CHECK */
             if (stuck == IGRAPH_RANDOM_WALK_STUCK_RETURN) {
                 break;
             } else {
-                IGRAPH_ERROR("Random walk got stuck", IGRAPH_ERWSTUCK);
+                IGRAPH_ERROR("Random walk got stuck.", IGRAPH_ERWSTUCK);
             }
         }
 
         if (weights) { /* weighted: choose an out-edge with probability proportional to its weight */
             igraph_real_t r;
             igraph_vector_t **cd = (igraph_vector_t **) & (VECTOR(cdfs)[start]);
 
             /* compute out-edge cdf for this node if not already done */
             if (IGRAPH_UNLIKELY(! *cd)) {
                 long j;
 
                 *cd = IGRAPH_CALLOC(1, igraph_vector_t);
                 if (*cd == NULL) {
-                    IGRAPH_ERROR("random edge walk failed", IGRAPH_ENOMEM);
+                    IGRAPH_ERROR("Random edge walk failed.", IGRAPH_ENOMEM);
                 }
                 IGRAPH_CHECK(igraph_vector_init(*cd, degree));
 
                 IGRAPH_CHECK(igraph_vector_resize(&weight_temp, degree));
                 for (j = 0; j < degree; ++j) {
                     VECTOR(weight_temp)[j] = VECTOR(*weights)[ VECTOR(*edges)[j] ];
                 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/shortest_paths.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/shortest_paths.c`

 * *Files 0% similar despite different names*

```diff
@@ -442,14 +442,18 @@
 
     long int no_of_nodes = igraph_vcount(graph);
     long int vertex_neis_size;
     long int neighbor_count; /* unlike 'vertex_neis_size', 'neighbor_count' does not count self-loops and multi-edges */
     long int i, j;
 
     igraph_dqueue_clear(q);
+
+    /* already_counted[i] is 0 iff vertex i was not reached so far, otherwise
+     * it is the index of the source vertex in vertex_neis that it was reached
+     * from, plus 1 */
     memset(already_counted, 0, no_of_nodes * sizeof(long int));
 
     IGRAPH_CHECK(igraph_neighbors(graph, vertex_neis, vertex, mode));
     vertex_neis_size = igraph_vector_size(vertex_neis);
 
     igraph_vector_char_fill(nei_mask, 0);
     neighbor_count = 0;
@@ -475,19 +479,20 @@
         IGRAPH_ALLOW_INTERRUPTION();
 
         if (source == vertex)
             continue;
 
         if (VECTOR(*nei_mask)[source] == 2)
             continue;
+
         VECTOR(*nei_mask)[source] = 2; /* mark neighbour as already processed */
 
         IGRAPH_CHECK(igraph_dqueue_push(q, source));
         IGRAPH_CHECK(igraph_dqueue_push(q, 0));
-        already_counted[source] = source + 1;
+        already_counted[source] = i + 1;
 
         while (!igraph_dqueue_empty(q)) {
             igraph_vector_int_t *act_neis;
             long int act_neis_size;
             long int act = (long int) igraph_dqueue_pop(q);
             long int actdist = (long int) igraph_dqueue_pop(q);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/simple_paths.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/simple_paths.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/paths/unweighted.c` & `igraph-0.9.9/vendor/source/igraph/src/paths/unweighted.c`

 * *Files 0% similar despite different names*

```diff
@@ -156,15 +156,16 @@
                         igraph_dqueue_clear(&q);
                         break;
                     }
                 }
             }
 
             neis = igraph_adjlist_get(&adjlist, act);
-            for (j = 0; j < igraph_vector_int_size(neis); j++) {
+            long int nei_count = igraph_vector_int_size(neis);
+            for (j = 0; j < nei_count; j++) {
                 long int neighbor = (long int) VECTOR(*neis)[j];
                 if (already_counted[neighbor] == i + 1) {
                     continue;
                 }
                 already_counted[neighbor] = i + 1;
                 IGRAPH_CHECK(igraph_dqueue_push(&q, neighbor));
                 IGRAPH_CHECK(igraph_dqueue_push(&q, actdist + 1));
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/basic_properties.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/basic_properties.c`

 * *Files 0% similar despite different names*

```diff
@@ -116,15 +116,15 @@
  * \param vids Vertex selector that specifies the vertices which to calculate
  *    the measure.
  * \return Error code.
  *
  * Time complexity: O(|V|+|E|), linear.
  *
  */
-int igraph_diversity(igraph_t *graph, const igraph_vector_t *weights,
+int igraph_diversity(const igraph_t *graph, const igraph_vector_t *weights,
                      igraph_vector_t *res, const igraph_vs_t vids) {
 
     int no_of_nodes = igraph_vcount(graph);
     int no_of_edges = igraph_ecount(graph);
     igraph_vector_t incident;
     igraph_vit_t vit;
     igraph_real_t s, ent, w;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/constraint.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/constraint.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/convergence_degree.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/convergence_degree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/dag.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/dag.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/degrees.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/degrees.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/girth.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/girth.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/loops.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/loops.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/multiplicity.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/test_utilities.inc`

 * *Files 26% similar despite different names*

```diff
@@ -1,356 +1,451 @@
-/* -*- mode: C -*-  */
-/* vim:set ts=4 sw=4 sts=4 et: */
+#ifndef TEST_UTILITIES_INC
+#define TEST_UTILITIES_INC
+
 /*
-   IGraph library.
-   Copyright (C) 2005-2012  Gabor Csardi <csardi.gabor@gmail.com>
-   334 Harvard street, Cambridge, MA 02139 USA
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-   02110-1301 USA
-
-*/
-
-#include "igraph_structural.h"
-
-#include "igraph_adjlist.h"
-#include "igraph_interface.h"
-
-/**
- * \function igraph_is_simple
- * \brief Decides whether the input graph is a simple graph.
- *
- * </para><para>
- * A graph is a simple graph if it does not contain loop edges and
- * multiple edges.
- *
- * \param graph The input graph.
- * \param res Pointer to a boolean constant, the result
- *     is stored here.
- * \return Error code.
- *
- * \sa \ref igraph_is_loop() and \ref igraph_is_multiple() to
- * find the loops and multiple edges, \ref igraph_simplify() to
- * get rid of them, or \ref igraph_has_multiple() to decide whether
- * there is at least one multiple edge.
- *
- * Time complexity: O(|V|+|E|).
+ * This file contains functions that are useful when writing tests.
+ * Include it in the test program using #include "test_utilities.inc"
  */
-int igraph_is_simple(const igraph_t *graph, igraph_bool_t *res) {
-    long int vc = igraph_vcount(graph);
-    long int ec = igraph_ecount(graph);
 
-    if (vc == 0 || ec == 0) {
-        *res = 1;
-    } else {
-        igraph_vector_t neis;
-        long int i, j, n;
-        igraph_bool_t found = 0;
-        IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
-        for (i = 0; i < vc; i++) {
-            IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) i, IGRAPH_OUT));
-            n = igraph_vector_size(&neis);
-            for (j = 0; j < n; j++) {
-                if (VECTOR(neis)[j] == i) {
-                    found = 1; break;
-                }
-                if (j > 0 && VECTOR(neis)[j - 1] == VECTOR(neis)[j]) {
-                    found = 1; break;
-                }
-            }
+#include <igraph.h>
+#include <stdio.h>
+#include <string.h>
+
+/* Print an igraph_real_t value. Be consistent in printing NaN/Inf across platforms. */
+void print_real(FILE *f, igraph_real_t x, const char *format) {
+    igraph_bool_t g8 = !strcmp(format, "%8g");
+    if (igraph_finite(x)) {
+        if (x == 0 && signbit(x)) {
+            /* print negative zeros as positive zeros for sake of consistency */
+            x = +0.0;
+        }
+        fprintf(f, format, x);
+    } else if (igraph_is_nan(x)) {
+        fprintf(f, g8 ? "     NaN" : "NaN");
+    } else if (igraph_is_posinf(x)) {
+        fprintf(f, g8 ? "     Inf" : "Inf");
+    } else if (igraph_is_neginf(x)) {
+        fprintf(f, g8 ? "    -Inf" : "-Inf");
+    }
+}
+
+void print_vector_format(const igraph_vector_t *v, FILE *f, const char *format) {
+    long i, n = igraph_vector_size(v);
+    fprintf(f, "(");
+    for (i=0; i < n; i++) {
+        fprintf(f, " ");
+        print_real(f, VECTOR(*v)[i], format);
+    }
+    fprintf(f, " )\n");
+}
+
+/* Print elements of a vector. Use parentheses to make it clear when a vector has size zero. */
+void print_vector(const igraph_vector_t *v) {
+    print_vector_format(v, stdout, "%g");
+}
+
+/* Round elements of a vector to integers and print them. */
+/* This is meant to be used when the elements of a vector are integer values. */
+void print_vector_round(const igraph_vector_t *v) {
+    print_vector_format(v, stdout, "%.f");
+}
+
+
+/* Print elements of an integer vector */
+void print_vector_int(const igraph_vector_int_t *v) {
+    long i, n = igraph_vector_int_size(v);
+    printf("(");
+    for (i=0; i < n; i++) {
+        printf(" %" IGRAPH_PRId, VECTOR(*v)[i]);
+    }
+    printf(" )\n");
+}
+
+
+/* Print elements of a long vector */
+void print_vector_long(const igraph_vector_long_t *v) {
+    long i, n = igraph_vector_long_size(v);
+    printf("(");
+    for (i=0; i < n; i++) {
+        printf(" %ld", VECTOR(*v)[i]);
+    }
+    printf(" )\n");
+}
+
+
+/* Print elements of a matrix. Use brackets to make it clear when a vector has size zero. */
+void print_matrix_format(const igraph_matrix_t *m, FILE *f, const char *format) {
+    long i, j, nrow = igraph_matrix_nrow(m), ncol = igraph_matrix_ncol(m);
+    for (i = 0; i < nrow; i++) {
+        fprintf(f, i == 0 ? "[" : " ");
+        for (j = 0; j < ncol; j++) {
+            fprintf(f, " ");
+            print_real(f, MATRIX(*m, i, j), format);
         }
-        *res = !found;
-        igraph_vector_destroy(&neis);
-        IGRAPH_FINALLY_CLEAN(1);
-    }
-
-    return 0;
+        fprintf(f, i == nrow-1 ? " ]\n" : "\n");
+    }
 }
 
+void print_matrix(const igraph_matrix_t *m) {
+    print_matrix_format(m, stdout, "%8g");
+}
+
+/* Round elements of a matrix to integers and print them. */
+/* This is meant to be used when the elements of a matrix are integer values. */
+void print_matrix_round(const igraph_matrix_t *m) {
+    print_matrix_format(m, stdout, "%4.f");
+}
+
+
+/* Print an adjacency list. Use brackets around each vector and also use
+ * brackets around the entire adjacency list to make it clear when the list
+ * is empty.
+ */
+void print_adjlist(const igraph_adjlist_t *adjlist) {
+    long vcount = igraph_adjlist_size(adjlist);
+    long i;
+
+    printf("{\n");
+    for (i = 0; i < vcount; ++i) {
+        printf("  %ld: ", i);
+        print_vector_int(igraph_adjlist_get(adjlist, i));
+    }
+    printf("}\n");
+}
+
+/* Print a graph. Use brackets to make it obvious when the edge list is empty. */
+void print_graph(const igraph_t *graph) {
+    long ecount = igraph_ecount(graph);
+    long vcount = igraph_vcount(graph);
+    long i;
+
+    printf("directed: %s\n", igraph_is_directed(graph) ? "true" : "false");
+    printf("vcount: %ld\n", vcount);
+    printf("edges: {\n");
+    for (i=0; i < ecount; ++i)
+        printf("%" IGRAPH_PRId " %" IGRAPH_PRId "\n", IGRAPH_FROM(graph, i), IGRAPH_TO(graph, i));
+    printf("}\n");
+}
+
+/* Print an incidence list. Use brackets around each vector and also use
+ * brackets around the entire incidence list to make it clear when the list
+ * is empty.
+ */
+void print_inclist(const igraph_inclist_t *inclist) {
+    long vcount = igraph_inclist_size(inclist);
+    long i;
+
+    printf("{\n");
+    for (i = 0; i < vcount; ++i) {
+        printf("  %ld: ", i);
+        print_vector_int(igraph_inclist_get(inclist, i));
+    }
+    printf("}\n");
+}
 
-/**
- * \function igraph_has_multiple
- * \brief Check whether the graph has at least one multiple edge.
- *
- * </para><para>
- * An edge is a multiple edge if there is another
- * edge with the same head and tail vertices in the graph.
- *
- * \param graph The input graph.
- * \param res Pointer to a boolean variable, the result will be stored here.
- * \return Error code.
- *
- * \sa \ref igraph_count_multiple(), \ref igraph_is_multiple() and \ref igraph_simplify().
- *
- * Time complexity: O(e*d), e is the number of edges to check and d is the
- * average degree (out-degree in directed graphs) of the vertices at the
- * tail of the edges.
- *
- * \example examples/simple/igraph_has_multiple.c
+/* Print a lazy adjacency list. Use brackets around each vector and also use
+ * brackets around the entire lazy adjacency list to make it clear when the list
+ * is empty.
  */
-int igraph_has_multiple(const igraph_t *graph, igraph_bool_t *res) {
-    long int vc = igraph_vcount(graph);
-    long int ec = igraph_ecount(graph);
-    igraph_bool_t directed = igraph_is_directed(graph);
+void print_lazy_adjlist(igraph_lazy_adjlist_t *adjlist) {
+    long vcount = igraph_lazy_adjlist_size(adjlist);
+    long i;
+
+    printf("{\n");
+    for (i = 0; i < vcount; ++i) {
+        printf("  %ld: ", i);
+        print_vector_int(igraph_lazy_adjlist_get(adjlist, i));
+    }
+    printf("}\n");
+}
+
+/* Print a lazy incidence list. Use brackets around each vector and also use
+ * brackets around the entire incidence list to make it clear when the list
+ * is empty.
+ */
+void print_lazy_inclist(igraph_lazy_inclist_t *inclist) {
+    long vcount = igraph_lazy_inclist_size(inclist);
+    long i;
+
+    printf("{\n");
+    for (i = 0; i < vcount; ++i) {
+        printf("  %ld: ", i);
+        print_vector_int(igraph_lazy_inclist_get(inclist, i));
+    }
+    printf("}\n");
+}
 
-    if (vc == 0 || ec == 0) {
-        *res = 0;
+/* Edge comparisong function used for sorting in print_graph_canon(). */
+int edge_compare(const void *e1, const void *e2) {
+    const igraph_real_t *edge1 = (igraph_real_t *) e1, *edge2 = (igraph_real_t *) e2;
+    if (edge1[0] < edge2[0]) {
+        return -1;
+    } else if (edge1[0] > edge2[0]) {
+        return 1;
+    } else if (edge1[1] < edge2[1]) {
+        return -1;
+    } else if (edge1[1] > edge2[1]) {
+        return 1;
     } else {
-        igraph_vector_t neis;
-        long int i, j, n;
-        igraph_bool_t found = 0;
-        IGRAPH_VECTOR_INIT_FINALLY(&neis, 0);
-        for (i = 0; i < vc && !found; i++) {
-            IGRAPH_CHECK(igraph_neighbors(graph, &neis, (igraph_integer_t) i,
-                                          IGRAPH_OUT));
-            n = igraph_vector_size(&neis);
-            for (j = 1; j < n; j++) {
-                if (VECTOR(neis)[j - 1] == VECTOR(neis)[j]) {
-                    /* If the graph is undirected, loop edges appear twice in the neighbor
-                     * list, so check the next item as well */
-                    if (directed) {
-                        /* Directed, so this is a real multiple edge */
-                        found = 1; break;
-                    } else if (VECTOR(neis)[j - 1] != i) {
-                        /* Undirected, but not a loop edge */
-                        found = 1; break;
-                    } else if (j < n - 1 && VECTOR(neis)[j] == VECTOR(neis)[j + 1]) {
-                        /* Undirected, loop edge, multiple times */
-                        found = 1; break;
-                    }
+        return 0;
+    }
+}
+
+/* Print a graph using a sorted edge list. Other than sorting (i.e. canonicalizing) the edge list,
+ * this function is identical to print_graph(). */
+void print_graph_canon(const igraph_t *graph) {
+    long ecount = igraph_ecount(graph);
+    long vcount = igraph_vcount(graph);
+    long i;
+    igraph_vector_t edges;
+
+    printf("directed: %s\n", igraph_is_directed(graph) ? "true" : "false");
+    printf("vcount: %ld\n", vcount);
+    printf("edges: {\n");
+
+    igraph_vector_init(&edges, 0);
+    igraph_get_edgelist(graph, &edges, 0);
+
+    /* If the graph is undirected, we make sure that the first vertex of undirected edges
+     * is always the one with the lower ID. */
+    if (! igraph_is_directed(graph)) {
+        for (i=0; i < ecount; ++i) {
+            if (VECTOR(edges)[2*i] > VECTOR(edges)[2*i+1]) {
+                igraph_real_t tmp = VECTOR(edges)[2*i];
+                VECTOR(edges)[2*i] = VECTOR(edges)[2*i+1];
+                VECTOR(edges)[2*i+1] = tmp;
+            }
+        }
+    }
+
+    /* Sort the edge list */
+    igraph_qsort(&VECTOR(edges)[0], ecount, 2*sizeof(igraph_real_t), &edge_compare);
+
+    for (i=0; i < ecount; ++i) {
+        printf("%ld %ld\n", (long) VECTOR(edges)[2*i], (long) VECTOR(edges)[2*i+1]);
+    }
+
+    igraph_vector_destroy(&edges);
+
+    printf("}\n");
+}
+
+/* Print a vector, ensuring that the first nonzero element is positive. */
+void print_vector_first_nonzero_element_positive(const igraph_vector_t *vector, const char* format) {
+    igraph_vector_t copy;
+    long i, n;
+
+    igraph_vector_copy(&copy, vector);
+
+    n = igraph_vector_size(&copy);
+
+    for (i = 0; i < n; i++) {
+        if (VECTOR(copy)[i] < 0) {
+            for (; i < n; i++) {
+                if (VECTOR(copy)[i] != 0) {
+                    VECTOR(copy)[i] *= -1;
                 }
             }
+            break;
+        } else if (VECTOR(copy)[i] > 0) {
+            break;
         }
-        *res = found;
-        igraph_vector_destroy(&neis);
-        IGRAPH_FINALLY_CLEAN(1);
-    }
-
-    return 0;
-}
-
-/**
- * \function igraph_is_multiple
- * \brief Find the multiple edges in a graph.
- *
- * </para><para>
- * An edge is a multiple edge if there is another
- * edge with the same head and tail vertices in the graph.
- *
- * </para><para>
- * Note that this function returns true only for the second or more
- * appearances of the multiple edges.
- * \param graph The input graph.
- * \param res Pointer to a boolean vector, the result will be stored
- *        here. It will be resized as needed.
- * \param es The edges to check. Supply \ref igraph_ess_all() if you want
- *        to check all edges.
- * \return Error code.
- *
- * \sa \ref igraph_count_multiple(), \ref igraph_has_multiple() and \ref igraph_simplify().
- *
- * Time complexity: O(e*d), e is the number of edges to check and d is the
- * average degree (out-degree in directed graphs) of the vertices at the
- * tail of the edges.
- *
- * \example examples/simple/igraph_is_multiple.c
- */
-int igraph_is_multiple(const igraph_t *graph, igraph_vector_bool_t *res,
-                       igraph_es_t es) {
-    igraph_eit_t eit;
-    long int i, j, n;
-    igraph_lazy_inclist_t inclist;
-
-    IGRAPH_CHECK(igraph_eit_create(graph, es, &eit));
-    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
-
-    IGRAPH_CHECK(igraph_lazy_inclist_init(graph, &inclist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE));
-    IGRAPH_FINALLY(igraph_lazy_inclist_destroy, &inclist);
-
-    IGRAPH_CHECK(igraph_vector_bool_resize(res, IGRAPH_EIT_SIZE(eit)));
-
-    for (i = 0; !IGRAPH_EIT_END(eit); i++, IGRAPH_EIT_NEXT(eit)) {
-        long int e = IGRAPH_EIT_GET(eit);
-        long int from = IGRAPH_FROM(graph, e);
-        long int to = IGRAPH_TO(graph, e);
-        igraph_vector_int_t *neis =
-            igraph_lazy_inclist_get(&inclist, (igraph_integer_t) from);
-
-        if (neis == 0) {
-            /* Most likely out of memory */
-            IGRAPH_ERROR("Out of memory while building lazy incidence list", IGRAPH_ENOMEM);
-        }
-
-        VECTOR(*res)[i] = 0;
-
-        n = igraph_vector_int_size(neis);
-        for (j = 0; j < n; j++) {
-            long int e2 = (long int) VECTOR(*neis)[j];
-            long int to2 = IGRAPH_OTHER(graph, e2, from);
-            if (to2 == to && e2 < e) {
-                VECTOR(*res)[i] = 1;
+    }
+
+    igraph_vector_printf(&copy, format);
+    igraph_vector_destroy(&copy);
+}
+
+/* Print a complex vector, ensuring that the first element with nonzero real
+ * part has a positive real part. */
+void print_vector_complex_first_nonzero_real_part_positive(const igraph_vector_complex_t *vector) {
+    igraph_vector_complex_t copy;
+    long i, n;
+
+    igraph_vector_complex_copy(&copy, vector);
+
+    n = igraph_vector_complex_size(&copy);
+
+    for (i = 0; i < n; i++) {
+        if (IGRAPH_REAL(VECTOR(copy)[i]) < 0) {
+            for (; i < n; i++) {
+                if (IGRAPH_REAL(VECTOR(copy)[i]) != 0) {
+                    IGRAPH_REAL(VECTOR(copy)[i]) *= -1;
+                }
+                if (IGRAPH_IMAG(VECTOR(copy)[i]) != 0) {
+                    IGRAPH_IMAG(VECTOR(copy)[i]) *= -1;
+                }
             }
+            break;
+        } else if (IGRAPH_REAL(VECTOR(copy)[i]) > 0) {
+            break;
         }
     }
 
-    igraph_lazy_inclist_destroy(&inclist);
-    igraph_eit_destroy(&eit);
-    IGRAPH_FINALLY_CLEAN(2);
-    return 0;
+    igraph_vector_complex_print(&copy);
+    igraph_vector_complex_destroy(&copy);
 }
 
+/* Print a matrix, ensuring that the first nonzero element in each column is
+ * positive. */
+void print_matrix_first_row_positive(const igraph_matrix_t *matrix, const char* format) {
+    igraph_matrix_t copy;
+    long i, j, nrow, ncol;
+
+    igraph_matrix_copy(&copy, matrix);
+
+    nrow = igraph_matrix_nrow(&copy);
+    ncol = igraph_matrix_ncol(&copy);
+
+    for (i = 0; i < ncol; i++) {
+        for (j = 0; j < nrow; j++) {
+            if (MATRIX(copy, j, i) < 0) {
+                for (; j < nrow; j++) {
+                    if (MATRIX(copy, j, i) != 0) {
+                        MATRIX(copy, j, i) *= -1;
+                    }
+                }
+                break;
+            } else if (MATRIX(copy, j, i) > 0) {
+                break;
+            }
+        }
+    }
 
-/**
- * \function igraph_count_multiple
- * \brief Count the number of appearances of the edges in a graph.
- *
- * </para><para>
- * If the graph has no multiple edges then the result vector will be
- * filled with ones.
- * (An edge is a multiple edge if there is another
- * edge with the same head and tail vertices in the graph.)
- *
- * </para><para>
- * \param graph The input graph.
- * \param res Pointer to a vector, the result will be stored
- *        here. It will be resized as needed.
- * \param es The edges to check. Supply \ref igraph_ess_all() if you want
- *        to check all edges.
- * \return Error code.
- *
- * \sa \ref igraph_is_multiple() and \ref igraph_simplify().
- *
- * Time complexity: O(E d), E is the number of edges to check and d is the
- * average degree (out-degree in directed graphs) of the vertices at the
- * tail of the edges.
- */
-int igraph_count_multiple(const igraph_t *graph, igraph_vector_t *res, igraph_es_t es) {
-    igraph_eit_t eit;
-    long int i, j, n;
-    igraph_lazy_inclist_t inclist;
-
-    IGRAPH_CHECK(igraph_eit_create(graph, es, &eit));
-    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
-    IGRAPH_CHECK(igraph_lazy_inclist_init(graph, &inclist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE));
-    IGRAPH_FINALLY(igraph_lazy_inclist_destroy, &inclist);
-
-    IGRAPH_CHECK(igraph_vector_resize(res, IGRAPH_EIT_SIZE(eit)));
-
-    for (i = 0; !IGRAPH_EIT_END(eit); i++, IGRAPH_EIT_NEXT(eit)) {
-        long int e = IGRAPH_EIT_GET(eit);
-        long int from = IGRAPH_FROM(graph, e);
-        long int to = IGRAPH_TO(graph, e);
-        igraph_vector_int_t *neis =
-            igraph_lazy_inclist_get(&inclist, (igraph_integer_t) from);
-
-        if (neis == 0) {
-            /* Most likely out of memory */
-            IGRAPH_ERROR("Out of memory while building lazy incidence list", IGRAPH_ENOMEM);
-        }
-
-        VECTOR(*res)[i] = 0;
-
-        n = igraph_vector_int_size(neis);
-        for (j = 0; j < n; j++) {
-            long int e2 = (long int) VECTOR(*neis)[j];
-            long int to2 = IGRAPH_OTHER(graph, e2, from);
-            if (to2 == to) {
-                VECTOR(*res)[i] += 1;
+    igraph_matrix_printf(&copy, format);
+    igraph_matrix_destroy(&copy);
+}
+
+/* Print a complex matrix, ensuring that the first element with nonzero real
+ * part in each column has a positive real part. */
+void print_matrix_complex_first_row_positive(const igraph_matrix_complex_t *matrix) {
+    igraph_matrix_complex_t copy;
+    long i, j, nrow, ncol;
+    igraph_complex_t z;
+    char buf[256];
+    size_t len;
+
+    igraph_matrix_complex_copy(&copy, matrix);
+
+    nrow = igraph_matrix_complex_nrow(&copy);
+    ncol = igraph_matrix_complex_ncol(&copy);
+
+    for (i = 0; i < ncol; i++) {
+        for (j = 0; j < nrow; j++) {
+            if (IGRAPH_REAL(MATRIX(copy, j, i)) < 0) {
+                for (; j < nrow; j++) {
+                    if (IGRAPH_REAL(MATRIX(copy, j, i)) != 0) {
+                        IGRAPH_REAL(MATRIX(copy, j, i)) *= -1;
+                    }
+                    if (IGRAPH_IMAG(MATRIX(copy, j, i)) != 0) {
+                        IGRAPH_IMAG(MATRIX(copy, j, i)) *= -1;
+                    }
+                }
+                break;
+            } else if (IGRAPH_REAL(MATRIX(copy, j, i)) > 0) {
+                break;
             }
         }
     }
 
-    igraph_lazy_inclist_destroy(&inclist);
-    igraph_eit_destroy(&eit);
-    IGRAPH_FINALLY_CLEAN(2);
-
-    return IGRAPH_SUCCESS;
-}
-
-/**
- * \function igraph_is_mutual
- * Check whether the edges of a directed graph are mutual.
- *
- * An (A,B) edge is mutual if the graph contains the (B,A) edge, too.
- * </para>
- *
- * <para>An undirected graph only has mutual edges, by definition.
- * </para>
- *
- * <para>Edge multiplicity is not considered here, e.g. if there are two
- * (A,B) edges and one (B,A) edge, then all three are considered to be
- * mutual.
- * </para>
- *
- * <para>Loops are always mutual.
- *
- * \param graph The input graph.
- * \param res Pointer to an initialized vector, the result is stored
- *        here.
- * \param es The sequence of edges to check. Supply
- *        <code>igraph_ess_all()</code> for all edges, see \ref
- *        igraph_ess_all().
- * \return Error code.
- *
- * Time complexity: O(n log(d)), n is the number of edges supplied, d
- * is the maximum in-degree of the vertices that are targets of the
- * supplied edges. An upper limit of the time complexity is O(n log(|E|)),
- * |E| is the number of edges in the graph.
- */
-int igraph_is_mutual(igraph_t *graph, igraph_vector_bool_t *res, igraph_es_t es) {
+    for (i = 0; i < nrow; i++) {
+        for (j = 0; j < ncol; j++) {
+            z = MATRIX(copy, i, j);
+            if (j != 0) {
+                putchar(' ');
+            }
 
-    igraph_eit_t eit;
-    igraph_lazy_adjlist_t adjlist;
-    long int i;
-
-    /* How many edges do we have? */
-    IGRAPH_CHECK(igraph_eit_create(graph, es, &eit));
-    IGRAPH_FINALLY(igraph_eit_destroy, &eit);
-    IGRAPH_CHECK(igraph_vector_bool_resize(res, IGRAPH_EIT_SIZE(eit)));
+            snprintf(buf, sizeof(buf), "%g%+gi", IGRAPH_REAL(z), IGRAPH_IMAG(z));
+            len = strlen(buf);
 
-    /* An undirected graph has mutual edges by definition,
-       res is already properly resized */
-    if (! igraph_is_directed(graph)) {
-        igraph_vector_bool_fill(res, 1);
-        igraph_eit_destroy(&eit);
-        IGRAPH_FINALLY_CLEAN(1);
-        return IGRAPH_SUCCESS;
+            /* ensure that we don't print -0 in the imaginary part */
+            if (len > 3 && buf[len-3] == '-' && buf[len-2] == '0' && buf[len-1] == 'i') {
+              buf[len-3] = '+';
+            }
+
+            /* ensure that we don't print -0 in the real part either */
+            if (buf[0] == '-' && buf[1] == '0' && (buf[2] == '+' || buf[2] == '-')) {
+                printf("%s", buf + 1);
+            } else {
+                printf("%s", buf);
+            }
+        }
+        printf("\n");
     }
 
-    IGRAPH_CHECK(igraph_lazy_adjlist_init(graph, &adjlist, IGRAPH_OUT, IGRAPH_LOOPS_ONCE, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_lazy_adjlist_destroy, &adjlist);
+    igraph_matrix_complex_destroy(&copy);
+}
 
-    for (i = 0; ! IGRAPH_EIT_END(eit); i++, IGRAPH_EIT_NEXT(eit)) {
-        long int edge = IGRAPH_EIT_GET(eit);
-        long int from = IGRAPH_FROM(graph, edge);
-        long int to = IGRAPH_TO(graph, edge);
+void matrix_init_int_row_major(igraph_matrix_t *mat, int nrow, int ncol, int* elem) {
+    int c, r;
+    int i_elem = 0;
+    igraph_matrix_init(mat, nrow, ncol);
+    for (r = 0; r < nrow; r++) {
+        for (c = 0; c < ncol; c++) {
+            MATRIX(*mat, r, c) = elem[i_elem];
+            i_elem++;
+        }
+    }
+}
 
-        /* Check whether there is a to->from edge, search for from in the
-           out-list of to. We don't search an empty vector, because
-           vector_binsearch seems to have a bug with this. */
-        igraph_vector_int_t *neis = igraph_lazy_adjlist_get(&adjlist,
-                                (igraph_integer_t) to);
-        if (igraph_vector_int_empty(neis)) {
-            VECTOR(*res)[i] = 0;
-        } else {
-            VECTOR(*res)[i] = igraph_vector_int_binsearch2(neis, from);
+void matrix_init_real_row_major(igraph_matrix_t *mat, int nrow, int ncol, igraph_real_t* elem) {
+    int c, r;
+    int i_elem = 0;
+    igraph_matrix_init(mat, nrow, ncol);
+    for (r = 0; r < nrow; r++) {
+        for (c = 0; c < ncol; c++) {
+            MATRIX(*mat, r, c) = elem[i_elem];
+            i_elem++;
         }
     }
+}
 
-    igraph_lazy_adjlist_destroy(&adjlist);
-    igraph_eit_destroy(&eit);
-    IGRAPH_FINALLY_CLEAN(2);
+void matrix_chop(igraph_matrix_t *mat, igraph_real_t cutoff) {
+    int i;
+    for (i = 0; i < igraph_matrix_nrow(mat) * igraph_matrix_ncol(mat); i++) {
+        if (fabs(VECTOR(mat->data)[i]) < cutoff) {
+            VECTOR(mat->data)[i] = 0;
+        }
+    }
+}
 
-    return IGRAPH_SUCCESS;
+void print_spmatrix(igraph_spmatrix_t *m) {
+    long int i, j;
+    for (i = 0; i < igraph_spmatrix_nrow(m); i++) {
+        for (j = 0; j < igraph_spmatrix_ncol(m); j++) {
+            printf(" %8g", igraph_spmatrix_e(m, i, j));
+        }
+        printf("\n");
+    }
 }
+
+#define VERIFY_FINALLY_STACK() \
+    if (!IGRAPH_FINALLY_STACK_EMPTY) { \
+        printf( \
+          "%s:%d : " \
+          "Finally stack is not empty (stack size is %d). " \
+          "Check that the number in IGRAPH_FINALLY_CLEAN matches the IGRAPH_FINALLY count.\n", \
+          IGRAPH_FILE_BASENAME, __LINE__, IGRAPH_FINALLY_STACK_SIZE()); \
+        abort(); \
+    }
+
+/* Run a test in a separate function; return the return value of the function
+ * if it is nonzero. Also verify the FINALLY stack and bail out if it is not
+ * empty. Needs an integer variable named 'retval' in the local context. */
+#define RUN_TEST(func) \
+    { \
+        retval = func(); \
+        if (retval) { \
+            return retval; \
+        } \
+        VERIFY_FINALLY_STACK(); \
+    }
+
+#define CHECK_ERROR(funcall, expected_err) \
+    do { \
+        igraph_error_handler_t *handler; \
+        handler = igraph_set_error_handler(igraph_error_handler_ignore); \
+        IGRAPH_ASSERT(funcall == expected_err); \
+        igraph_set_error_handler(handler); \
+    } while (0)
+
+#endif /* TEST_UTILITIES_INC */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/neighborhood.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/neighborhood.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/properties_internal.h` & `igraph-0.9.9/vendor/source/igraph/src/properties/properties_internal.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/spectral.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/spectral.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/trees.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/trees.c`

 * *Files 6% similar despite different names*

```diff
@@ -153,56 +153,58 @@
 
     return 0;
 }
 
 /* igraph_is_tree -- check if a graph is a tree */
 
 /* count the number of vertices reachable from the root */
-static int igraph_i_is_tree_visitor(igraph_integer_t root, const igraph_adjlist_t *al, igraph_integer_t *visited_count) {
+static int igraph_i_is_tree_visitor(const igraph_t *graph, igraph_integer_t root, igraph_neimode_t mode, igraph_integer_t *visited_count) {
     igraph_stack_int_t stack;
     igraph_vector_bool_t visited;
+    igraph_vector_t neighbors;
     long i;
 
-    IGRAPH_CHECK(igraph_vector_bool_init(&visited, igraph_adjlist_size(al)));
-    IGRAPH_FINALLY(igraph_vector_bool_destroy, &visited);
+    IGRAPH_VECTOR_INIT_FINALLY(&neighbors, 0);
+
+    IGRAPH_VECTOR_BOOL_INIT_FINALLY(&visited, igraph_vcount(graph));
 
     IGRAPH_CHECK(igraph_stack_int_init(&stack, 0));
     IGRAPH_FINALLY(igraph_stack_int_destroy, &stack);
 
     *visited_count = 0;
 
     /* push the root into the stack */
     IGRAPH_CHECK(igraph_stack_int_push(&stack, root));
 
     while (! igraph_stack_int_empty(&stack)) {
         igraph_integer_t u;
-        igraph_vector_int_t *neighbors;
         long ncount;
 
         /* take a vertex from the stack, mark it as visited */
         u = igraph_stack_int_pop(&stack);
         if (IGRAPH_LIKELY(! VECTOR(visited)[u])) {
             VECTOR(visited)[u] = 1;
             *visited_count += 1;
         }
 
         /* register all its yet-unvisited neighbours for future processing */
-        neighbors = igraph_adjlist_get(al, u);
-        ncount = igraph_vector_int_size(neighbors);
+        IGRAPH_CHECK(igraph_neighbors(graph, &neighbors, u, mode));
+        ncount = igraph_vector_size(&neighbors);
         for (i = 0; i < ncount; ++i) {
-            igraph_integer_t v = VECTOR(*neighbors)[i];
+            igraph_integer_t v = VECTOR(neighbors)[i];
             if (! VECTOR(visited)[v]) {
                 IGRAPH_CHECK(igraph_stack_int_push(&stack, v));
             }
         }
     }
 
+    igraph_vector_destroy(&neighbors);
     igraph_stack_int_destroy(&stack);
     igraph_vector_bool_destroy(&visited);
-    IGRAPH_FINALLY_CLEAN(2);
+    IGRAPH_FINALLY_CLEAN(3);
 
     return IGRAPH_SUCCESS;
 }
 
 
 /**
  * \ingroup structural
@@ -240,15 +242,14 @@
  * number of vertices plus the number of edges in the graph.
  *
  * \sa igraph_is_weakly_connected()
  *
  * \example examples/simple/igraph_tree.c
  */
 int igraph_is_tree(const igraph_t *graph, igraph_bool_t *res, igraph_integer_t *root, igraph_neimode_t mode) {
-    igraph_adjlist_t al;
     igraph_integer_t iroot = 0;
     igraph_integer_t visited_count;
     igraph_integer_t vcount, ecount;
 
     vcount = igraph_vcount(graph);
     ecount = igraph_ecount(graph);
 
@@ -272,17 +273,14 @@
      * of loops or multi-edges even when the edge count is correct. */
 
     /* Ignore mode for undirected graphs. */
     if (! igraph_is_directed(graph)) {
         mode = IGRAPH_ALL;
     }
 
-    IGRAPH_CHECK(igraph_adjlist_init(graph, &al, mode, IGRAPH_LOOPS, IGRAPH_MULTIPLE));
-    IGRAPH_FINALLY(igraph_adjlist_destroy, &al);
-
     /* The main algorithm:
      * We find a root and check that all other vertices are reachable from it.
      * We have already checked the number of edges, so with the additional
      * reachability condition we can verify if the graph is a tree.
      *
      * For directed graphs, the root is the node with no incoming/outgoing
      * connections, depending on 'mode'. For undirected, it is arbitrary, so
@@ -302,43 +300,52 @@
         igraph_integer_t i;
 
         IGRAPH_CHECK(igraph_vector_init(&degree, 0));
         IGRAPH_FINALLY(igraph_vector_destroy, &degree);
 
         IGRAPH_CHECK(igraph_degree(graph, &degree, igraph_vss_all(), mode == IGRAPH_IN ? IGRAPH_OUT : IGRAPH_IN, /* loops = */ 1));
 
-        for (i = 0; i < vcount; ++i)
+        for (i = 0; i < vcount; ++i) {
             if (VECTOR(degree)[i] == 0) {
                 break;
             }
+            if (VECTOR(degree)[i] > 1) {
+                /* In an out-tree, all vertices have in-degree 1, except for the root,
+                 * which has in-degree 0. Thus, if we encounter a larger in-degree,
+                 * the graph cannot be an out-tree.
+                 * We could perform this check for all degrees, but that would not
+                 * improve performance when the graph is indeed a tree, persumably
+                 * the most common case. Thus we only check until finding the root.
+                 */
+                *res = 0;
+                break;
+            }
+        }
 
-        /* if no suitable root is found, the graph is not a tree */
-        if (i == vcount) {
+        /* If no suitable root is found, the graph is not a tree. */
+        if (*res && i == vcount) {
             *res = 0;
         } else {
             iroot = i;
         }
 
         igraph_vector_destroy(&degree);
         IGRAPH_FINALLY_CLEAN(1);
     }
 
     break;
     default:
-        IGRAPH_ERROR("Invalid mode", IGRAPH_EINVMODE);
+        IGRAPH_ERROR("Invalid mode,", IGRAPH_EINVMODE);
     }
 
     /* if no suitable root was found, skip visiting vertices */
     if (*res) {
-        IGRAPH_CHECK(igraph_i_is_tree_visitor(iroot, &al, &visited_count));
+        IGRAPH_CHECK(igraph_i_is_tree_visitor(graph, iroot, mode, &visited_count));
         *res = visited_count == vcount;
     }
 
     if (root) {
         *root = iroot;
     }
 
-    igraph_adjlist_destroy(&al);
-    IGRAPH_FINALLY_CLEAN(1);
-
     return IGRAPH_SUCCESS;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/triangles.c` & `igraph-0.9.9/vendor/source/igraph/src/properties/triangles.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/triangles_template.h` & `igraph-0.9.9/vendor/source/igraph/src/properties/triangles_template.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/properties/triangles_template1.h` & `igraph-0.9.9/vendor/source/igraph/src/properties/triangles_template1.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/random/random.c` & `igraph-0.9.9/vendor/source/igraph/src/random/random.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/scg/scg.c` & `igraph-0.9.9/vendor/source/igraph/src/scg/scg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/scg/scg_approximate_methods.c` & `igraph-0.9.9/vendor/source/igraph/src/scg/scg_approximate_methods.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/scg/scg_exact_scg.c` & `igraph-0.9.9/vendor/source/igraph/src/scg/scg_exact_scg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/scg/scg_headers.h` & `igraph-0.9.9/vendor/source/igraph/src/scg/scg_headers.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/scg/scg_kmeans.c` & `igraph-0.9.9/vendor/source/igraph/src/scg/scg_kmeans.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/scg/scg_optimal_method.c` & `igraph-0.9.9/vendor/source/igraph/src/scg/scg_optimal_method.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/scg/scg_utils.c` & `igraph-0.9.9/vendor/source/igraph/src/scg/scg_utils.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/src/version.c` & `igraph-0.9.9/vendor/source/igraph/src/version.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/tests/CMakeLists.txt`

 * *Files 2% similar despite different names*

```diff
@@ -267,14 +267,15 @@
   igraph_diversity
   igraph_eccentricity
   igraph_edge_betweenness
   igraph_get_all_simple_paths
   igraph_get_shortest_paths2
   igraph_get_shortest_paths_bellman_ford
   igraph_is_bipartite
+  igraph_is_connected
   igraph_is_chordal
   igraph_is_mutual
   igraph_is_tree
   igraph_list_triangles
   igraph_local_scan_k_ecount
   igraph_local_transitivity
   igraph_neighborhood
@@ -374,14 +375,15 @@
   bliss_automorphisms
   igraph_get_isomorphisms_vf2
   igraph_get_subisomorphisms_vf2
   igraph_subisomorphic
   igraph_isomorphic_bliss
   isomorphism_test
   isoclasses
+  isoclasses2
   VF2-compat
 )
 
 # coloring.at
 add_examples(
   FOLDER examples/simple NAMES
   igraph_coloring
@@ -392,14 +394,15 @@
   FOLDER examples/simple NAMES
   igraph_motifs_randesu
 )
 
 add_legacy_tests(
   FOLDER tests/unit NAMES
   igraph_dyad_census
+  igraph_motifs_randesu
   igraph_motifs_randesu_estimate
   igraph_motifs_randesu_no
   triad_census
 )
 
 # foreign.at
 add_examples(
@@ -430,14 +433,19 @@
 # other.at
 add_examples(
   FOLDER examples/simple NAMES
   igraph_convex_hull
   igraph_power_law_fit
 )
 
+add_legacy_tests(
+  FOLDER tests/unit NAMES
+  igraph_almost_equals
+)
+
 # operators.at
 add_examples(
   FOLDER examples/simple NAMES
   igraph_complementer
   igraph_compose
   igraph_difference
   igraph_disjoint_union
@@ -517,14 +525,16 @@
   walktrap
 )
 
 add_legacy_tests(
   FOLDER tests/unit NAMES
   community_leiden
   community_label_propagation
+  community_label_propagation2
+  community_label_propagation3
   igraph_community_infomap
   igraph_community_leading_eigenvector2
   igraph_compare_communities
   igraph_le_community_to_membership
   igraph_modularity
   igraph_modularity_matrix
   igraph_split_join_distance
@@ -776,14 +786,15 @@
 )
 
 # regression and fuzzing tests
 
 add_legacy_tests(
   FOLDER tests/regression NAMES
   igraph_read_graph_gml_invalid_inputs
+  igraph_read_graph_graphml_invalid_inputs
 )
 
 # non-graph
 
 add_legacy_tests(
   FOLDER tests/unit NAMES
   igraph_running_mean
@@ -804,14 +815,15 @@
   igraph_sir
 )
 
 
 # benchmarks
 add_benchmarks(
   NAMES
+  igraph_average_path_length_unweighted
   igraph_betweenness
   igraph_betweenness_weighted
   igraph_cliques
   igraph_closeness_weighted
   igraph_coloring
   igraph_decompose
   igraph_maximal_cliques
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/bench.h` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/bench.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_betweenness.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_betweenness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_betweenness_weighted.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_betweenness_weighted.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_cliques.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_cliques.c`

 * *Files 8% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 
     igraph_vector_ptr_resize(res, 0);
 }
 
 int main() {
     igraph_t g;
     igraph_vector_ptr_t res;
+    igraph_integer_t res_int;
 
     igraph_rng_seed(igraph_rng_default(), 42);
     BENCH_INIT();
 
     igraph_vector_ptr_init(&res, 0);
 
     igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNM, 100, 3000, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);
@@ -32,14 +33,18 @@
     igraph_destroy(&g);
     free_result(&res);
 
     igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNM, 200, 10000, IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);
     BENCH(" 2 Cliques in random graph with 200 vertices and 10000 edges, up to size 5",
           igraph_cliques(&g, &res, /* min_size= */ 0, /* max_size= */ 5);
          );
-    igraph_destroy(&g);
     free_result(&res);
+    BENCH(" 3 Clique number of the same graph with 200 vertices and 10000 edges",
+          igraph_clique_number(&g, &res_int);
+         );
+    free_result(&res);
+    igraph_destroy(&g);
 
     igraph_vector_ptr_destroy(&res);
 
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_closeness_weighted.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_closeness_weighted.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_coloring.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_coloring.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_decompose.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_decompose.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_maximal_cliques.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_maximal_cliques.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_pagerank.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_pagerank.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_pagerank_weighted.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_pagerank_weighted.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_power_law_fit.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_power_law_fit.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 #include <igraph.h>
+#include <plfit_sampling.h>
 
 #include "bench.h"
-#include "../../vendor/plfit/sampling.h"
 
 igraph_vector_t data;
 
 double rpareto(double xmin, double alpha) {
     /* 1-u is used in the base here because we want to avoid the case of
      * sampling zero */
     return pow(1 - RNG_UNIF01(), -1.0 / alpha) * xmin;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_random_walk.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_random_walk.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/benchmarks/igraph_transitivity.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_transitivity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/bug-1033045.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/bug-1033045.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/bug-1149658.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/bug-1149658.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/bug_1760.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/bug_1760.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/bug_1814.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/bug_1814.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/bug_1814.out` & `igraph-0.9.9/vendor/source/igraph/tests/regression/bug_1814.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/cattr_bool_bug.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/cattr_bool_bug.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/cattr_bool_bug.graphml` & `igraph-0.9.9/vendor/source/igraph/tests/regression/cattr_bool_bug.graphml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/cattr_bool_bug2.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/cattr_bool_bug2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_layout_reingold_tilford_bug_879.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/igraph_read_graph_gml_invalid_inputs.c` & `igraph-0.9.9/vendor/source/igraph/tests/regression/igraph_read_graph_gml_invalid_inputs.c`

 * *Files 8% similar despite different names*

```diff
@@ -20,14 +20,16 @@
 
 #include <stdint.h>
 #include <string.h>
 #include <stdlib.h>
 #include "igraph.h"
 #include <stdio.h>
 
+#include "../unit/test_utilities.inc"
+
 int test_file(const char* fname) {
     FILE *ifile;
     igraph_t g;
     int retval;
 
     ifile = fopen(fname, "r");
     if (ifile == 0) {
@@ -44,29 +46,32 @@
     }
 
     fclose(ifile);
 
     return 0;
 }
 
+#undef RUN_TEST
 #define RUN_TEST(fname) {   \
     index++;                \
     if (test_file(fname)) { \
         return index;       \
     }                       \
+    VERIFY_FINALLY_STACK(); \
 }
 
 int main(int argc, char* argv[]) {
     int index = 0;
 
     /* We do not care about errors; all we care about is that the library
      * should not segfault and should not accept invalid input either */
     igraph_set_error_handler(igraph_error_handler_ignore);
 
     RUN_TEST("invalid1.gml");
     RUN_TEST("invalid2.gml");
     RUN_TEST("invalid3.gml");
     RUN_TEST("invalid4.gml");
     RUN_TEST("invalid5.gml");
+    RUN_TEST("invalid6.gml");
 
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/invalid1.gml` & `igraph-0.9.9/vendor/source/igraph/tests/regression/invalid1.gml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/regression/invalid3.gml` & `igraph-0.9.9/vendor/source/igraph/tests/regression/invalid3.gml`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/2wheap.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/2wheap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/VF2-compat.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/VF2-compat.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/adjlist.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/adjlist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/adjlist.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/adjlist.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/all_shortest_paths.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/all_shortest_paths.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/bfs.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/bfs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/bfs.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/bfs.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/bfs_simple.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/bfs_simple.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/bliss_automorphisms.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/bliss_automorphisms.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/cattributes5.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/cattributes5.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/cattributes5.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/cattributes5.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/community_label_propagation.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/community_label_propagation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/community_leiden.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/community_leiden.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/community_leiden.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/community_leiden.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/cutheap.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/cutheap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/d_indheap.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/d_indheap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/dgemv.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/dgemv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/dgemv.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/dgemv.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/edge_selectors.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/edge_selectors.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/efficiency.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/efficiency.c`

 * *Files 24% similar despite different names*

```diff
@@ -1,108 +1,133 @@
 
 #include <igraph.h>
 
 #include "test_utilities.inc"
 
-/* Number of edges in the test graph.
-   This value, 'graph', and 'weights_array' must be consistent. */
-#define N_EDGES 24
-
-int main() {
-    igraph_t graph;
-    const igraph_real_t weights_array[N_EDGES] = {4, 4, 4, 3, 1, 5, 1, 2, 4, 5, 3, 5, 5, 4, 1, 1, 5, 4, 1, 1, 2, 1, 3, 5};
-    const igraph_vector_t weights;
+int test_graph(const char* name, const igraph_t* graph, const igraph_real_t* weights_array) {
     igraph_real_t eff;
     igraph_vector_t eff_vec;
+    igraph_vector_t weights;
 
-    igraph_small(&graph, 13, /* directed= */ 1,
-                 0,8, 1,3, 1,4, 1,5, 1,8, 1,10, 2,0, 2,1, 2,4, 3,5, 4,2, 4,7,
-                 4,9, 5,3, 5,10, 6,7, 8,2, 8,3, 8,4, 8,9, 9,3, 9,4, 11,9, 11,3,
-                 -1);
-
-    IGRAPH_ASSERT(igraph_ecount(&graph) == N_EDGES);
-
-    igraph_vector_view(&weights, weights_array, N_EDGES);
+    printf("###### Testing graph: %s ######\n\n", name);
 
     igraph_vector_init(&eff_vec, 0);
 
-    printf("UNWEIGHTED CASE:\n\n");
+    if (weights_array) {
+        printf("UNWEIGHTED CASE:\n\n");
+    }
 
-    igraph_global_efficiency(&graph, &eff, NULL, 0);
+    igraph_global_efficiency(graph, &eff, NULL, 0);
     printf("Global efficiency, undirected: %f\n", eff);
 
-    igraph_global_efficiency(&graph, &eff, NULL, 1);
+    igraph_global_efficiency(graph, &eff, NULL, 1);
     printf("Global efficiency, directed: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, NULL, 0, IGRAPH_ALL);
+    igraph_average_local_efficiency(graph, &eff, NULL, 0, IGRAPH_ALL);
     printf("Average local efficiency, undirected: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, NULL, 1, IGRAPH_ALL);
+    igraph_average_local_efficiency(graph, &eff, NULL, 1, IGRAPH_ALL);
     printf("Average local efficiency, directed, all neighbors: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, NULL, 1, IGRAPH_IN);
+    igraph_average_local_efficiency(graph, &eff, NULL, 1, IGRAPH_IN);
     printf("Average local efficiency, directed, in-neighbors: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, NULL, 1, IGRAPH_OUT);
+    igraph_average_local_efficiency(graph, &eff, NULL, 1, IGRAPH_OUT);
     printf("Average local efficiency, directed, out-neighbors: %f\n", eff);
 
     printf("\nLocal efficiency, undirected:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), NULL, 0, IGRAPH_ALL);
+    igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), NULL, 0, IGRAPH_ALL);
     print_vector(&eff_vec);
 
     printf("\nLocal efficiency, directed, all neighbors:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), NULL, 1, IGRAPH_ALL);
+    igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), NULL, 1, IGRAPH_ALL);
     print_vector(&eff_vec);
 
     printf("\nLocal efficiency, directed, in-neighbors:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), NULL, 1, IGRAPH_IN);
+    igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), NULL, 1, IGRAPH_IN);
     print_vector(&eff_vec);
 
     printf("\nLocal efficiency, directed, out-neighbors:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), NULL, 1, IGRAPH_OUT);
+    igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), NULL, 1, IGRAPH_OUT);
     print_vector(&eff_vec);
 
+    if (weights_array) {
+        igraph_vector_view(&weights, weights_array, igraph_ecount(graph));
+        printf("\nWEIGHTED CASE:\n\n");
 
-    printf("\n\nWEIGHTED CASE:\n\n");
-
-    igraph_global_efficiency(&graph, &eff, &weights, 0);
-    printf("Global efficiency, undirected: %f\n", eff);
+        igraph_global_efficiency(graph, &eff, &weights, 0);
+        printf("Global efficiency, undirected: %f\n", eff);
 
-    igraph_global_efficiency(&graph, &eff, &weights, 1);
-    printf("Global efficiency, directed: %f\n", eff);
+        igraph_global_efficiency(graph, &eff, &weights, 1);
+        printf("Global efficiency, directed: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, &weights, 0, IGRAPH_ALL);
-    printf("Average local efficiency, undirected: %f\n", eff);
+        igraph_average_local_efficiency(graph, &eff, &weights, 0, IGRAPH_ALL);
+        printf("Average local efficiency, undirected: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, &weights, 1, IGRAPH_ALL);
-    printf("Average local efficiency, directed, all neighbors: %f\n", eff);
+        igraph_average_local_efficiency(graph, &eff, &weights, 1, IGRAPH_ALL);
+        printf("Average local efficiency, directed, all neighbors: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, &weights, 1, IGRAPH_IN);
-    printf("Average local efficiency, directed, in-neighbors: %f\n", eff);
+        igraph_average_local_efficiency(graph, &eff, &weights, 1, IGRAPH_IN);
+        printf("Average local efficiency, directed, in-neighbors: %f\n", eff);
 
-    igraph_average_local_efficiency(&graph, &eff, &weights, 1, IGRAPH_OUT);
-    printf("Average local efficiency, directed, out-neighbors: %f\n", eff);
+        igraph_average_local_efficiency(graph, &eff, &weights, 1, IGRAPH_OUT);
+        printf("Average local efficiency, directed, out-neighbors: %f\n", eff);
 
-    printf("\nLocal efficiency, undirected:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), &weights, 0, IGRAPH_ALL);
-    print_vector(&eff_vec);
+        printf("\nLocal efficiency, undirected:\n");
+        igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), &weights, 0, IGRAPH_ALL);
+        print_vector(&eff_vec);
 
-    printf("\nLocal efficiency, directed, all neighbors:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), &weights, 1, IGRAPH_ALL);
-    print_vector(&eff_vec);
+        printf("\nLocal efficiency, directed, all neighbors:\n");
+        igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), &weights, 1, IGRAPH_ALL);
+        print_vector(&eff_vec);
 
-    printf("\nLocal efficiency, directed, in-neighbors:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), &weights, 1, IGRAPH_IN);
-    print_vector(&eff_vec);
+        printf("\nLocal efficiency, directed, in-neighbors:\n");
+        igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), &weights, 1, IGRAPH_IN);
+        print_vector(&eff_vec);
 
-    printf("\nLocal efficiency, directed, out-neighbors:\n");
-    igraph_local_efficiency(&graph, &eff_vec, igraph_vss_all(), &weights, 1, IGRAPH_OUT);
-    print_vector(&eff_vec);
+        printf("\nLocal efficiency, directed, out-neighbors:\n");
+        igraph_local_efficiency(graph, &eff_vec, igraph_vss_all(), &weights, 1, IGRAPH_OUT);
+        print_vector(&eff_vec);
+    }
 
+    printf("\n\n");
 
     igraph_vector_destroy(&eff_vec);
+
+    return 0;
+}
+
+int test_ring() {
+    int result;
+    igraph_t graph;
+    const igraph_real_t weights_array[] = {1, 1, 1, 1};
+
+    igraph_ring(&graph, 4, IGRAPH_DIRECTED, /* mutual = */ 0, /* circular = */ 1);
+    result = test_graph("Ring graph", &graph, weights_array);
+    igraph_destroy(&graph);
+
+    return result;
+}
+
+int test_small_graph() {
+    int result;
+    igraph_t graph;
+    const igraph_real_t weights_array[] = {4, 4, 4, 3, 1, 5, 1, 2, 4, 5, 3, 5, 5, 4, 1, 1, 5, 4, 1, 1, 2, 1, 3, 5};
+
+    igraph_small(&graph, 13, /* directed= */ 1,
+                 0,8, 1,3, 1,4, 1,5, 1,8, 1,10, 2,0, 2,1, 2,4, 3,5, 4,2, 4,7,
+                 4,9, 5,3, 5,10, 6,7, 8,2, 8,3, 8,4, 8,9, 9,3, 9,4, 11,9, 11,3,
+                 -1);
+    result = test_graph("Small test graph", &graph, weights_array);
     igraph_destroy(&graph);
 
-    VERIFY_FINALLY_STACK();
+    return result;
+}
+
+int main() {
+    int retval;
+
+    RUN_TEST(test_ring);
+    RUN_TEST(test_small_graph);
 
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/efficiency.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/efficiency.out`

 * *Files 18% similar despite different names*

```diff
@@ -1,7 +1,54 @@
+###### Testing graph: Ring graph ######
+
+UNWEIGHTED CASE:
+
+Global efficiency, undirected: 0.833333
+Global efficiency, directed: 0.611111
+Average local efficiency, undirected: 0.500000
+Average local efficiency, directed, all neighbors: 0.250000
+Average local efficiency, directed, in-neighbors: 0.000000
+Average local efficiency, directed, out-neighbors: 0.000000
+
+Local efficiency, undirected:
+( 0.5 0.5 0.5 0.5 )
+
+Local efficiency, directed, all neighbors:
+( 0.25 0.25 0.25 0.25 )
+
+Local efficiency, directed, in-neighbors:
+( 0 0 0 0 )
+
+Local efficiency, directed, out-neighbors:
+( 0 0 0 0 )
+
+WEIGHTED CASE:
+
+Global efficiency, undirected: 0.833333
+Global efficiency, directed: 0.611111
+Average local efficiency, undirected: 0.500000
+Average local efficiency, directed, all neighbors: 0.250000
+Average local efficiency, directed, in-neighbors: 0.000000
+Average local efficiency, directed, out-neighbors: 0.000000
+
+Local efficiency, undirected:
+( 0.5 0.5 0.5 0.5 )
+
+Local efficiency, directed, all neighbors:
+( 0.25 0.25 0.25 0.25 )
+
+Local efficiency, directed, in-neighbors:
+( 0 0 0 0 )
+
+Local efficiency, directed, out-neighbors:
+( 0 0 0 0 )
+
+
+###### Testing graph: Small test graph ######
+
 UNWEIGHTED CASE:
 
 Global efficiency, undirected: 0.509615
 Global efficiency, directed: 0.274786
 Average local efficiency, undirected: 0.605769
 Average local efficiency, directed, all neighbors: 0.329936
 Average local efficiency, directed, in-neighbors: 0.212115
@@ -15,15 +62,14 @@
 
 Local efficiency, directed, in-neighbors:
 ( 0 0 0.5 0.340833 0.527778 0.5 0 0 0.166667 0.222222 0.5 0 0 )
 
 Local efficiency, directed, out-neighbors:
 ( 0 0.3875 0.25 0 0.0555556 0 0 0 0.583333 0.166667 0 0.5 0 )
 
-
 WEIGHTED CASE:
 
 Global efficiency, undirected: 0.247686
 Global efficiency, directed: 0.125356
 Average local efficiency, undirected: 0.281019
 Average local efficiency, directed, all neighbors: 0.150368
 Average local efficiency, directed, in-neighbors: 0.122897
@@ -36,7 +82,9 @@
 ( 0.291667 0.16403 0.245833 0.207976 0.204643 0.075 0 0 0.204987 0.143981 0.166667 0.25 0 )
 
 Local efficiency, directed, in-neighbors:
 ( 0 0 0.5 0.207976 0.341071 0.125 0 0 0.0625 0.194444 0.166667 0 0 )
 
 Local efficiency, directed, out-neighbors:
 ( 0 0.180711 0.116667 0 0.0416667 0 0 0 0.246164 0.0555556 0 0.25 0 )
+
+
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/erdos_renyi_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/erdos_renyi_game.c`

 * *Files 3% similar despite different names*

```diff
@@ -42,14 +42,30 @@
     igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNP, 10, 0.0,
                             IGRAPH_DIRECTED, IGRAPH_NO_LOOPS);
     IGRAPH_ASSERT(igraph_ecount(&g) == 0);
     IGRAPH_ASSERT(igraph_is_directed(&g));
     igraph_is_simple(&g, &simple); IGRAPH_ASSERT(simple);
     igraph_destroy(&g);
 
+    /* Singleton with loop */
+
+    igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNP, 1, 1.0,
+                            IGRAPH_UNDIRECTED, IGRAPH_LOOPS);
+    IGRAPH_ASSERT(igraph_ecount(&g) == 1);
+    IGRAPH_ASSERT(! igraph_is_directed(&g));
+    igraph_is_simple(&g, &simple); IGRAPH_ASSERT(! simple);
+    igraph_destroy(&g);
+
+    igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNP, 1, 1.0,
+                            IGRAPH_DIRECTED, IGRAPH_LOOPS);
+    IGRAPH_ASSERT(igraph_ecount(&g) == 1);
+    IGRAPH_ASSERT(igraph_is_directed(&g));
+    igraph_is_simple(&g, &simple); IGRAPH_ASSERT(! simple);
+    igraph_destroy(&g);
+
     /* Complete graph */
 
     igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNP, 10, 1.0,
                             IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);
     IGRAPH_ASSERT(igraph_ecount(&g) == 10 * 9 / 2);
     IGRAPH_ASSERT(! igraph_is_directed(&g));
     igraph_is_simple(&g, &simple); IGRAPH_ASSERT(simple);
@@ -120,14 +136,35 @@
     IGRAPH_ASSERT(igraph_vcount(&g) == 100000);
     igraph_destroy(&g);
 
 
     /* --------------------------------------------------------------------- */
     /* G(n,m) */
 
+    /* singleton with loop */
+
+    igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNM, 1, 1,
+                            IGRAPH_UNDIRECTED, IGRAPH_LOOPS);
+
+    IGRAPH_ASSERT(igraph_vcount(&g) == 1);
+    IGRAPH_ASSERT(igraph_ecount(&g) == 1);
+    IGRAPH_ASSERT(! igraph_is_directed(&g));
+
+    igraph_destroy(&g);
+
+    igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNM, 1, 1,
+                            IGRAPH_DIRECTED, IGRAPH_LOOPS);
+
+    IGRAPH_ASSERT(igraph_vcount(&g) == 1);
+    IGRAPH_ASSERT(igraph_ecount(&g) == 1);
+    IGRAPH_ASSERT(igraph_is_directed(&g));
+
+    igraph_destroy(&g);
+
+
     /* directed with loops */
     igraph_erdos_renyi_game(&g, IGRAPH_ERDOS_RENYI_GNM, 10, 10 * 10 - 1,
                             IGRAPH_DIRECTED, IGRAPH_LOOPS);
     IGRAPH_ASSERT(igraph_vcount(&g) == 10);
     IGRAPH_ASSERT(igraph_ecount(&g) == 10 * 10 - 1);
     IGRAPH_ASSERT(igraph_is_directed(&g));
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/error_macros.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/error_macros.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/fatal_handler.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/fatal_handler.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/full.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/full.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/full.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/full.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/global_transitivity.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/global_transitivity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/glpk_error.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/glpk_error.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/harmonic_centrality.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/harmonic_centrality.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/harmonic_centrality.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/harmonic_centrality.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/hashtable.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/hashtable.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/heap.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/heap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/heap.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/heap.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adhesion.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adhesion.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adjacency_spectral_embedding.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_adjacent_triangles.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_adjacent_triangles.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_all_st_cuts.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_all_st_cuts.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_all_st_cuts.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_all_st_cuts.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_are_connected.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_are_connected.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_rnsolve.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_arpack_unpack_complex.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_array.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_array.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_attribute_combination_remove.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_attribute_combination_remove.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_average_path_length_dijkstra.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_barabasi_aging_game.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_betweenness.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_betweenness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_betweenness.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_betweenness.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_bipartite_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_bipartite_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_bridges.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_bridges.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_callaway_traits_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_callaway_traits_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_cited_type_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_cited_type_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_cited_type_game.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_cited_type_game.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_citing_cited_type_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_citing_cited_type_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_clique_size_hist.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_clique_size_hist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_closeness.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_closeness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_closeness.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_closeness.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_cohesion.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_cohesion.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_community_infomap.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_community_infomap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_community_infomap.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_community_infomap.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_community_leading_eigenvector2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_community_leading_eigenvector2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_compare_communities.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_compare_communities.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_compare_communities.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_compare_communities.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_complex.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_complex.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_convergence_degree.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_convergence_degree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_correlated_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_correlated_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_count_multiple.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_count_multiple.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_decompose_strong.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_decompose_strong.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_degree_sequence_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_degree_sequence_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_density.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_density.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_diversity.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_diversity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_dyad_census.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_dyad_census.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eccentricity.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eccentricity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_edge_betweenness.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_edge_betweenness.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_edge_betweenness.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_edge_betweenness.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_edge_disjoint_paths.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_edge_disjoint_paths.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix3.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix4.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix4.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric_arpack.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eigen_matrix_symmetric_arpack.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_es_path.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_es_path.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_establishment_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_establishment_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eulerian_cycle.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eulerian_cycle.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eulerian_path.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eulerian_path.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_eulerian_path.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_eulerian_path.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_extended_chordal_ring.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_extended_chordal_ring.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_forest_fire_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_forest_fire_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_from_prufer.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_from_prufer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_full_citation.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_full_citation.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_adjacency_sparse.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_all_simple_paths.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_all_simple_paths.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_incidence.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_incidence.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_incidence.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_incidence.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_isomorphisms_vf2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_shortest_paths2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_shortest_paths2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_shortest_paths_bellman_ford.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_shortest_paths_bellman_ford.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_get_subisomorphisms_vf2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_gomory_hu_tree.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_gomory_hu_tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_grg_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_grg_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_growing_random_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_growing_random_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_hrg.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_hrg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_hrg2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_hrg2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_hrg3.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_hrg3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_incident.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_incident.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_incident.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_incident.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_layout_sphere.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_layout_sphere.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_neighbors.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_neighbors.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_i_neighbors.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_i_neighbors.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_induced_subgraph.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_induced_subgraph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_induced_subgraph_map.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_induced_subgraph_map.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_intersection2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_intersection2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_bigraphical.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_bigraphical.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_bipartite.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_bipartite.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_chordal.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_chordal.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_chordal.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_chordal.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_eulerian.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_eulerian.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_graphical.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_graphical.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_graphical.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_graphical.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_mutual.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_mutual.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_same_graph.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_same_graph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_is_tree.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_is_tree.c`

 * *Files 14% similar despite different names*

```diff
@@ -22,15 +22,15 @@
     root = -1;
     igraph_is_tree(&g, &res, &root, IGRAPH_ALL);
     IGRAPH_ASSERT(res);
     IGRAPH_ASSERT(root == 0);
 
     igraph_destroy(&g);
 
-    /*  4-cycle, not a tree */
+    /* undirected 4-cycle, not a tree */
     igraph_small(&g, 4, 0,
                  0, 1, 1, 2, 2, 3, 3, 0, -1);
 
     igraph_is_tree(&g, &res, &root, IGRAPH_ALL);
     IGRAPH_ASSERT(! res);
 
     igraph_destroy(&g);
@@ -40,14 +40,26 @@
                  0, 1, 1, 2, 0, 2, 3, 4, -1);
 
     igraph_is_tree(&g, &res, &root, IGRAPH_ALL);
     IGRAPH_ASSERT(! res);
 
     igraph_destroy(&g);
 
+    /* disjoint union of an out-tree and two cycles, with the same number
+     * of edges as a tree would have, and the same in-degrees as an out-tree
+     * would have */
+    igraph_small(&g, 11, IGRAPH_DIRECTED,
+                 10, 0, 0, 2, 0, 6, 9, 1, 1, 8, 8, 4, 4, 9, 3, 7, 7, 5, 5, 3,
+                 -1);
+
+    igraph_is_tree(&g, &res, &root, IGRAPH_ALL);
+    IGRAPH_ASSERT(! res);
+
+    igraph_destroy(&g);
+
     /* 3-star, tree */
     igraph_small(&g, 4, 0,
                  0, 1, 0, 2, 0, 3, -1);
 
     root = -1;
     igraph_is_tree(&g, &res, &root, IGRAPH_ALL);
     IGRAPH_ASSERT(res);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_isomorphic_bliss.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_k_regular_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_k_regular_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_kautz.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_kautz.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgehrd.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgehrd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrf.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lapack_dgetrs.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lastcit_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lastcit_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_lattice.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_lattice.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_bipartite.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_bipartite.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_bipartite.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_bipartite.out`

 * *Files 14% similar despite different names*

```diff
@@ -31,11 +31,11 @@
 4 vertices with -10 true values for types:
 [        0        1
          0        0
          1        1
          1        0 ]
 4 vertices, negative vgaps:
 [        0       -1
-         0       -0
+         0        0
          1       -1
-         1       -0 ]
+         1        0 ]
 4 vertices, negative hgaps, emits error.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_davidson_harel.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_davidson_harel.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_drl.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_drl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_fruchterman_reingold.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_fruchterman_reingold.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_graphopt.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_graphopt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_grid.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_grid.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_lgl.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_lgl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_mds.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_mds.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_merge.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_merge.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_merge2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_merge2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_merge3.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_merge3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_random_3d.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_random_3d.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_circular.out`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -25,14 +25,14 @@
         12        0
         -6  10.3923
      -10.5 -18.1865
        -22        0
         11 -19.0526 ]
 Graph with just loops, triple edges and disconnected vertices:
 [        1        0
-  -0.209057  1.98904
   -0.104528 0.994522
+  -0.209057  1.98904
   -0.978148 -0.207912
   0.309017 -0.951057 ]
 Checking proper error handling:
 Giving negative root.
 Giving negative rootlevel.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_extended.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_reingold_tilford_extended.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_star.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_star.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_star.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_star.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_layout_sugiyama.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_le_community_to_membership.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_le_community_to_membership.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_linegraph.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_linegraph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_list_triangles.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_list_triangles.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_scan_k_ecount.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_transitivity.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_transitivity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_local_transitivity.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_local_transitivity.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques3.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques4.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_maximal_cliques_file.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_modularity.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_modularity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_modularity_matrix.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_modularity_matrix.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_modularity_matrix.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_modularity_matrix.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_moran_process.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_moran_process.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu_estimate.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_motifs_randesu_no.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_graphs.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_size.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_size.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_neighborhood_size.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_neighborhood_size.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_pagerank.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_pagerank.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_pagerank.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_pagerank.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_preference_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_preference_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_progress_handler_stderr.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_progress_handler_stderr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_psumtree.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_psumtree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_qsort.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_qsort.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_qsort_r.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/rng_init_destroy_max_min_name_set_default.c`

 * *Files 25% similar despite different names*

```diff
@@ -1,72 +1,62 @@
-/* -*- mode: C -*-  */
 /*
    IGraph library.
-   Copyright (C) 2011-2012  Gabor Csardi <csardi.gabor@gmail.com>
-   334 Harvard st, Cambridge, MA 02139, USA
+   Copyright (C) 2021  The igraph development team <igraph@igraph.org>
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-   02110-1301 USA
-
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
 
 #include <igraph.h>
-
 #include "test_utilities.inc"
 
-int comp(void *extra, const void *a, const void *b) {
-    igraph_vector_t *v = (igraph_vector_t*) extra;
-    int *aa = (int*) a;
-    int *bb = (int*) b;
-    igraph_real_t aaa = VECTOR(*v)[*aa];
-    igraph_real_t bbb = VECTOR(*v)[*bb];
-
-    if (aaa < bbb) {
-        return -1;
-    } else if (aaa > bbb) {
-        return 1;
+void test_and_destroy(igraph_rng_type_t *rng_type, igraph_rng_t *rng_def) {
+    int i;
+    igraph_rng_t rng;
+
+    IGRAPH_ASSERT(igraph_rng_init(&rng, rng_type) == IGRAPH_SUCCESS);
+    printf("rng name: %s\n", igraph_rng_name(&rng));
+
+    igraph_rng_seed(&rng, 42);
+    for (i = 0; i < 5; i++) {
+        printf("%ld\n", igraph_rng_get_integer(&rng, 0, 100));
     }
+    printf("\n");
 
-    return 0;
+    igraph_rng_set_default(&rng);
+    igraph_rng_seed(igraph_rng_default(), 42);
+    for (i = 0; i < 5; i++) {
+        printf("%ld\n", igraph_rng_get_integer(igraph_rng_default(), 0, 100));
+    }
+    printf("\n");
+
+    IGRAPH_ASSERT(igraph_rng_max(&rng) >= 32767);
+    igraph_rng_set_default(rng_def);
+    igraph_rng_destroy(&rng);
 }
 
 int main() {
-    const int len = 100;
-    igraph_vector_t v;
-    igraph_vector_int_t idx;
     int i;
+    igraph_rng_type_t rng_types[3] = {igraph_rngtype_glibc2, igraph_rngtype_mt19937, igraph_rngtype_rand};
+    igraph_rng_t rng_def;
 
-    igraph_rng_seed(igraph_rng_default(), 42);
-    igraph_vector_init(&v, len);
-    igraph_vector_int_init(&idx, len);
-    for (i = 0; i < len; i++) {
-        VECTOR(v)[i] = i;
-        VECTOR(idx)[i] = i;
-    }
-    igraph_vector_shuffle(&v);
-
-    igraph_qsort_r(VECTOR(idx), len, sizeof(VECTOR(idx)[0]), (void*) &v, comp);
+    IGRAPH_ASSERT(igraph_rng_init(&rng_def, &igraph_rngtype_glibc2) == IGRAPH_SUCCESS);
 
-    for (i = 0; i < len; i++) {
-        printf("%g ", VECTOR(v)[ VECTOR(idx)[i] ]);
+    for (i = 0; i < 3; i++) {
+        test_and_destroy(&rng_types[i], &rng_def);
     }
-    printf("\n");
 
-    igraph_vector_int_destroy(&idx);
-    igraph_vector_destroy(&v);
+    igraph_rng_destroy(&rng_def);
 
     VERIFY_FINALLY_STACK();
-
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_random_walk.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_random_walk.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_realize_degree_sequence.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_recent_degree_aging_game.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_recent_degree_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_recent_degree_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_residual_graph.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_residual_graph.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rewire.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rewire.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rewire_directed_edges.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rewire_directed_edges.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rng_get_exp.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rng_get_exp.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rng_get_exp.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rng_get_exp.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_rng_get_integer.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_rng_get_integer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_running_mean.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_running_mean.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sbm_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sbm_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sbm_game.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sbm_game.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_set_progress_handler.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_set_progress_handler.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_shortest_paths_johnson.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_simple_interconnected_islands_game.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sir.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sir.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sir.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sir.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_solve_lsap.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_solve_lsap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat2.c`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA
 
 */
 
 #define NCOMPLEX  /* to make it compile with MSVC on Windows */
 
-#include <cs/cs.h>
+#include <cs.h>
 #include <igraph.h>
 #include "linalg/blas_internal.h"
 #include "linalg/arpack_internal.h"
 
 #include "test_utilities.inc"
 
 int igraph_matrix_dgemv(const igraph_matrix_t *m,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat5.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat5.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat9.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat9.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_droptol.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_droptol.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_fkeep.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_fkeep.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_getelements_sorted.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_getelements_sorted.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_is_symmetric.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_is_symmetric.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_iterator_idx.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_iterator_idx.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_minmax.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_nonzero_storage.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_nonzero_storage.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_view.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_view.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_sparsemat_which_minmax.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_split_join_distance.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_split_join_distance.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_spmatrix_add_col_values.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_spmatrix_add_col_values.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_st_edge_connectivity.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_st_edge_connectivity.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_st_mincut.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_st_mincut.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_st_mincut_value.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_st_mincut_value.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_static_power_law_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_static_power_law_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_subcomponent.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_subcomponent.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_subisomorphic.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_subisomorphic.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_to_directed.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_to_directed.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_to_prufer.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_to_prufer.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitive_closure_dag.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitive_closure_dag.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitivity_avglocal_undirected.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitivity_avglocal_undirected.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_transitivity_barrat.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vector_floor.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vector_floor.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vector_lex_cmp.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vector_lex_cmp.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_vertex_disjoint_paths.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_vertex_disjoint_paths.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_weighted_cliques.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_weighted_cliques.c`

 * *Files 26% similar despite different names*

```diff
@@ -41,20 +41,37 @@
 
 /* Prints a clique vector along with its weight */
 void print_weighted_clique(const igraph_vector_t *clique, const igraph_vector_t *vertex_weights) {
     long int i, n = igraph_vector_size(clique);
     igraph_real_t clique_weight = 0.0;
     for (i = 0; i < n; i++) {
         int v = VECTOR(*clique)[i];
-        clique_weight += igraph_vector_e(vertex_weights, v);
+        clique_weight += vertex_weights ? igraph_vector_e(vertex_weights, v) : 1;
         printf(" %d", v);
     }
     printf(" w=%.1f\n", clique_weight);
 }
 
+/* Prints a clique list and clears it */
+void print_and_clear_weighted_clique_list(igraph_vector_ptr_t *cliques, const igraph_vector_t *vertex_weights) {
+    int i, count;
+
+    canonicalize_list(cliques);
+
+    count = igraph_vector_ptr_size(cliques);
+    for (i = 0; i < count; i++) {
+        igraph_vector_t* v = (igraph_vector_t*) igraph_vector_ptr_e(cliques, i);
+        print_weighted_clique(v, vertex_weights);
+        igraph_vector_destroy(v);
+        igraph_free(v);
+    }
+
+    igraph_vector_ptr_clear(cliques);
+}
+
 int main() {
     igraph_t graph;
 
     const igraph_integer_t n = 10; /* number of vertices in test graph */
 
     /* edges of the test graph */
     igraph_vector_t edges;
@@ -70,106 +87,98 @@
     igraph_real_t vertex_weight_data[] = {3., 2., 3., 5., 2., 3., 1., 3., 5., 5.};
 
     igraph_vector_ptr_t result; /* result clique list */
     igraph_integer_t count; /* number of cliques found */
 
     igraph_real_t weighted_clique_no;
 
-    int i;
-
 
     /* create graph */
     igraph_vector_init_copy(&edges, edge_data, (sizeof edge_data) / sizeof(igraph_real_t));
     igraph_create(&graph, &edges, n, /* directed= */ 0);
 
     /* set up vertex weight vector */
     igraph_vector_init_copy(&vertex_weights, vertex_weight_data, (sizeof vertex_weight_data) / sizeof(igraph_real_t));
 
     /* initialize result vector_ptr */
     igraph_vector_ptr_init(&result, 0);
 
 
-    /* all weighed cliques above weight 6 */
+    /* all weighted cliques above weight 6 */
     igraph_weighted_cliques(&graph, &vertex_weights, &result, 6, 0, /* maximal= */ 0);
 
     count = igraph_vector_ptr_size(&result);
     printf("%ld weighted cliques found above weight 6\n", (long) count);
-
-    canonicalize_list(&result);
-    for (i = 0; i < count; i++) {
-        igraph_vector_t* v = (igraph_vector_t*) igraph_vector_ptr_e(&result, i);
-        print_weighted_clique(v, &vertex_weights);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
+    print_and_clear_weighted_clique_list(&result, &vertex_weights);
 
 
-    /* all weighed cliques beteen weights 5 and 10 */
+    /* all weighted cliques between weights 5 and 10 */
     igraph_weighted_cliques(&graph, &vertex_weights, &result, 5, 10, /* maximal= */ 0);
 
     count = igraph_vector_ptr_size(&result);
     printf("%ld weighted cliques found between weights 5 and 10\n", (long) count);
-
-    canonicalize_list(&result);
-    for (i = 0; i < count; i++) {
-        igraph_vector_t* v = (igraph_vector_t*) igraph_vector_ptr_e(&result, i);
-        print_weighted_clique(v, &vertex_weights);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
+    print_and_clear_weighted_clique_list(&result, &vertex_weights);
 
 
-    /* maximal weighed cliques above weight 7 */
+    /* maximal weighted cliques above weight 7 */
     igraph_weighted_cliques(&graph, &vertex_weights, &result, 7, 0, /* maximal= */ 1);
 
     count = igraph_vector_ptr_size(&result);
     printf("%ld maximal weighted cliques found above weight 7\n", (long) count);
-
-    canonicalize_list(&result);
-    for (i = 0; i < count; i++) {
-        igraph_vector_t* v = (igraph_vector_t*) igraph_vector_ptr_e(&result, i);
-        print_weighted_clique(v, &vertex_weights);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
+    print_and_clear_weighted_clique_list(&result, &vertex_weights);
 
 
     /* maximal weighed cliques beteen weights 5 and 10 */
     igraph_weighted_cliques(&graph, &vertex_weights, &result, 5, 10, /* maximal= */ 1);
 
     count = igraph_vector_ptr_size(&result);
     printf("%ld maximal weighted cliques found between weights 5 and 10\n", (long) count);
-
-    canonicalize_list(&result);
-    for (i = 0; i < count; i++) {
-        igraph_vector_t* v = (igraph_vector_t*) igraph_vector_ptr_e(&result, i);
-        print_weighted_clique(v, &vertex_weights);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
+    print_and_clear_weighted_clique_list(&result, &vertex_weights);
 
 
     /* largest weight cliques */
     igraph_largest_weighted_cliques(&graph, &vertex_weights, &result);
 
     count = igraph_vector_ptr_size(&result);
     printf("%ld largest weight cliques found\n", (long) count);
-
-    canonicalize_list(&result);
-    for (i = 0; i < count; i++) {
-        igraph_vector_t* v = (igraph_vector_t*) igraph_vector_ptr_e(&result, i);
-        print_weighted_clique(v, &vertex_weights);
-        igraph_vector_destroy(v);
-        igraph_free(v);
-    }
+    print_and_clear_weighted_clique_list(&result, &vertex_weights);
 
     igraph_weighted_clique_number(&graph, &vertex_weights, &weighted_clique_no);
     printf("weighted clique number: %.1f\n", weighted_clique_no);
 
 
+    /* test fallback to unweighted variants: all cliques */
+    igraph_weighted_cliques(&graph, 0, &result, 4, 5, /* maximal= */ 0);
+
+    count = igraph_vector_ptr_size(&result);
+    printf("%ld unweighted cliques found between sizes 4 and 5\n", (long) count);
+    print_and_clear_weighted_clique_list(&result, 0);
+
+
+    /* test fallback to unweighted variants: maximal cliques */
+    igraph_weighted_cliques(&graph, 0, &result, 4, 5, /* maximal= */ 1);
+
+    count = igraph_vector_ptr_size(&result);
+    printf("%ld unweighted maximal cliques found between sizes 4 and 5\n", (long) count);
+    print_and_clear_weighted_clique_list(&result, 0);
+
+
+    /* test fallback to unweighted variants: largest cliques */
+    igraph_largest_weighted_cliques(&graph, 0, &result);
+
+    count = igraph_vector_ptr_size(&result);
+    printf("%ld largest unweighted cliques found\n", (long) count);
+    print_and_clear_weighted_clique_list(&result, 0);
+
+
+    /* test fallback to unweighted variants: clique number */
+    igraph_weighted_clique_number(&graph, 0, &weighted_clique_no);
+    printf("unweighted clique number: %.1f\n", weighted_clique_no);
+
+
     /* free data structures */
     igraph_vector_ptr_destroy(&result);
     igraph_vector_destroy(&vertex_weights);
     igraph_destroy(&graph);
     igraph_vector_destroy(&edges);
 
     VERIFY_FINALLY_STACK();
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_weighted_cliques.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_weighted_cliques.out`

 * *Files 4% similar despite different names*

```diff
@@ -130,7 +130,33 @@
  5 8 w=8.0
  1 4 9 w=9.0
  1 4 6 7 w=8.0
 2 largest weight cliques found
  0 1 8 9 w=15.0
  1 2 3 9 w=15.0
 weighted clique number: 15.0
+15 unweighted cliques found between sizes 4 and 5
+ 0 1 6 7 w=4.0
+ 0 1 6 8 w=4.0
+ 0 1 7 8 w=4.0
+ 0 1 8 9 w=4.0
+ 0 6 7 8 w=4.0
+ 1 2 3 6 w=4.0
+ 1 2 3 7 w=4.0
+ 1 2 3 9 w=4.0
+ 1 2 6 7 w=4.0
+ 1 3 6 7 w=4.0
+ 1 4 6 7 w=4.0
+ 1 6 7 8 w=4.0
+ 2 3 6 7 w=4.0
+ 0 1 6 7 8 w=5.0
+ 1 2 3 6 7 w=5.0
+5 unweighted maximal cliques found between sizes 4 and 5
+ 0 1 8 9 w=4.0
+ 1 2 3 9 w=4.0
+ 1 4 6 7 w=4.0
+ 0 1 6 7 8 w=5.0
+ 1 2 3 6 7 w=5.0
+2 largest unweighted cliques found
+ 0 1 6 7 8 w=5.0
+ 1 2 3 6 7 w=5.0
+unweighted clique number: 5.0
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_write_graph_dimacs.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_write_graph_dimacs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_write_graph_leda.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_write_graph_leda.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/igraph_write_graph_leda.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/igraph_write_graph_leda.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/inclist.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/inclist.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/inclist.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/inclist.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/input.dl` & `igraph-0.9.9/vendor/source/igraph/tests/unit/input.dl`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/isoclasses.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/isoclasses.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/isomorphism_test.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/isomorphism_test.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/levc-stress.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/levc-stress.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/lineendings.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/lineendings.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/marked_queue.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/marked_queue.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/matrix.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/matrix.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/matrix.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/matrix.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/matrix2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/matrix2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/matrix2.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/matrix2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/matrix3.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/matrix3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/maximal_cliques_callback.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/maximal_cliques_callback.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/mt.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/mt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek1.net` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek1.net`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek2.net` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek2.net`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek3.net` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek3.net`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek4.net` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek4.net`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek5.net` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek5.net`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek6.net` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek6.net`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bipartite.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bipartite.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bipartite2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bipartite2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_bipartite2.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_bipartite2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_signed.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_signed.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/pajek_signed.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/pajek_signed.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/random_spanning_tree.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/random_spanning_tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/ring.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/ring.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/rng_init_destroy_max_min_name_set_default.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/vertex_selectors.c`

 * *Files 23% similar despite different names*

```diff
@@ -15,48 +15,70 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
 
 #include <igraph.h>
 #include "test_utilities.inc"
 
-void test_and_destroy(igraph_rng_type_t *rng_type, igraph_rng_t *rng_def) {
-    int i;
-    igraph_rng_t rng;
-
-    IGRAPH_ASSERT(igraph_rng_init(&rng, rng_type) == IGRAPH_SUCCESS);
-    printf("rng name: %s\n", igraph_rng_name(&rng));
-
-    igraph_rng_seed(&rng, 42);
-    for (i = 0; i < 5; i++) {
-        printf("%ld\n", igraph_rng_get_integer(&rng, 0, 100));
-    }
-    printf("\n");
+void check(igraph_t *graph, igraph_vs_t *vs) {
+    igraph_vit_t vit;
 
-    igraph_rng_set_default(&rng);
-    igraph_rng_seed(igraph_rng_default(), 42);
-    for (i = 0; i < 5; i++) {
-        printf("%ld\n", igraph_rng_get_integer(igraph_rng_default(), 0, 100));
+    IGRAPH_ASSERT(igraph_vit_create(graph, *vs, &vit) == IGRAPH_SUCCESS);
+    for (; !IGRAPH_VIT_END(vit); IGRAPH_VIT_NEXT(vit)) {
+        printf("%" IGRAPH_PRId "\n", IGRAPH_VIT_GET(vit));
     }
-    printf("\n");
-
-    IGRAPH_ASSERT(igraph_rng_max(&rng) >= 32767);
-    igraph_rng_set_default(rng_def);
-    igraph_rng_destroy(&rng);
 }
 
 int main() {
-    int i;
-    igraph_rng_type_t rng_types[3] = {igraph_rngtype_glibc2, igraph_rngtype_mt19937, igraph_rngtype_rand};
-    igraph_rng_t rng_def;
-
-    IGRAPH_ASSERT(igraph_rng_init(&rng_def, &igraph_rngtype_glibc2) == IGRAPH_SUCCESS);
-
-    for (i = 0; i < 3; i++) {
-        test_and_destroy(&rng_types[i], &rng_def);
-    }
-
-    igraph_rng_destroy(&rng_def);
+    igraph_t g, g_no_vertices, g_no_edges;
+    igraph_vs_t vs;
+    igraph_vector_t v;
+    igraph_vit_t vit;
+
+    igraph_small(&g, 5, IGRAPH_DIRECTED, 0,1, 0,2, 1,1, 1,3, 2,0, 2,3, 3,4, -1);
+    igraph_small(&g_no_vertices, 0, IGRAPH_UNDIRECTED, -1);
+    igraph_small(&g_no_edges, 5, IGRAPH_UNDIRECTED, -1);
+
+    printf("Checking vs_none vertex selector:\n");
+    IGRAPH_ASSERT(igraph_vs_none(&vs) == IGRAPH_SUCCESS);
+    check(&g, &vs);
+    check(&g_no_edges, &vs);
+    check(&g_no_vertices, &vs);
+
+    igraph_set_error_handler(igraph_error_handler_ignore);
+
+    printf("Checking vector selector:\n");
+    igraph_vector_init_int(&v, 3, 2, 3, 4);
+    IGRAPH_ASSERT(igraph_vs_vector(&vs, &v) == IGRAPH_SUCCESS);
+    printf("Some graph:\n");
+    check(&g, &vs);
+    printf("Edgeless graph:\n");
+    check(&g_no_edges, &vs);
+    printf("Graph without vertices should fail.\n");
+    IGRAPH_ASSERT(igraph_vit_create(&g_no_vertices, vs, &vit) == IGRAPH_EINVVID);
+    igraph_vector_destroy(&v);
+
+    printf("Vertex selector with negative index should fail\n");
+    igraph_vector_init_int(&v, 3, -2, 3, 4);
+    IGRAPH_ASSERT(igraph_vs_vector(&vs, &v) == IGRAPH_SUCCESS);
+    IGRAPH_ASSERT(igraph_vit_create(&g, vs, &vit) == IGRAPH_EINVVID);
+    igraph_vector_destroy(&v);
+
+    printf("Checking copy vector selector:\n");
+    igraph_vector_init_int(&v, 3, 2, 3, 4);
+    IGRAPH_ASSERT(igraph_vs_vector_copy(&vs, &v) == IGRAPH_SUCCESS);
+    printf("Some graph:\n");
+    check(&g, &vs);
+    printf("Edgeless graph:\n");
+    check(&g_no_edges, &vs);
+    printf("Graph without vertices should fail.\n");
+    IGRAPH_ASSERT(igraph_vit_create(&g_no_vertices, vs, &vit) == IGRAPH_EINVVID);
+    IGRAPH_ASSERT(igraph_vs_type(&vs) == IGRAPH_VS_VECTOR);
+    igraph_vector_destroy(&v);
+
+    igraph_destroy(&g);
+    igraph_destroy(&g_no_vertices);
+    igraph_destroy(&g_no_edges);
 
     VERIFY_FINALLY_STACK();
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/scg2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/scg2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/scg2.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/scg2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/scg3.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/scg3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/scg3.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/scg3.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/set.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/set.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/simplify_and_colorize.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/simplify_and_colorize.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/simplify_and_colorize.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/simplify_and_colorize.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/single_target_shortest_path.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/single_target_shortest_path.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/spinglass.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/spinglass.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix_clear.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix_clear.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/spmatrix_clear.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/spmatrix_clear.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/stack.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/stack.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/strvector_set2_remove_print.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/strvector_set2_remove_print.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/tls1.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/tls1.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/tls2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/tls2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/tls2.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/tls2.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/topological_sorting.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/topological_sorting.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/tree.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/tree_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/tree_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/triad_census.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/triad_census.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/trie.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/trie.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/vector.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/vector.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/vector.out` & `igraph-0.9.9/vendor/source/igraph/tests/unit/vector.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/vector2.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/vector2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/vector3.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/vector3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/vector_ptr.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/vector_ptr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/vertex_selectors.c` & `igraph-0.9.9/vendor/source/igraph/tests/benchmarks/igraph_average_path_length_unweighted.c`

 * *Files 26% similar despite different names*

```diff
@@ -1,84 +1,75 @@
-/*
-   IGraph library.
-   Copyright (C) 2021  The igraph development team <igraph@igraph.org>
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <https://www.gnu.org/licenses/>.
-*/
 
 #include <igraph.h>
-#include "test_utilities.inc"
 
-void check(igraph_t *graph, igraph_vs_t *vs) {
-    igraph_vit_t vit;
+#include "bench.h"
 
-    IGRAPH_ASSERT(igraph_vit_create(graph, *vs, &vit) == IGRAPH_SUCCESS);
-    for (; !IGRAPH_VIT_END(vit); IGRAPH_VIT_NEXT(vit)) {
-        printf("%" IGRAPH_PRId "\n", IGRAPH_VIT_GET(vit));
+int main() {
+    igraph_t graph;
+    igraph_real_t avglen;
+    igraph_matrix_t mat;
+
+    BENCH_INIT();
+    igraph_rng_seed(igraph_rng_default(), 42);
+
+    igraph_matrix_init(&mat, 0, 0);
+
+    igraph_kautz(&graph, 4, 5);
+    igraph_matrix_resize(&mat, igraph_vcount(&graph), igraph_vcount(&graph)); /* preallocate matrix */
+
+    BENCH(" 1 Kautz(4, 5) average_path_length directed",
+          igraph_average_path_length(&graph, &avglen, NULL, IGRAPH_DIRECTED, 1);
+    );
+    BENCH(" 2 Kautz(4, 5) shortest_paths directed",
+          igraph_shortest_paths(&graph, &mat, igraph_vss_all(), igraph_vss_all(), IGRAPH_OUT);
+    );
+    BENCH(" 3 Kautz(4, 5) average_path_length undirected",
+          igraph_average_path_length(&graph, &avglen, NULL, IGRAPH_UNDIRECTED, 1);
+    );
+    BENCH(" 4 Kautz(4, 5) shortest_paths undirected",
+          igraph_shortest_paths(&graph, &mat, igraph_vss_all(), igraph_vss_all(), IGRAPH_ALL);
+    );
+
+    igraph_destroy(&graph);
+
+    {
+        igraph_vector_t dims;
+        igraph_vector_init_int(&dims, 3, 15, 15, 15);
+        igraph_lattice(&graph, &dims, 1, IGRAPH_UNDIRECTED, 0, 1);
+        igraph_vector_destroy(&dims);
+        igraph_rewire(&graph, 100, IGRAPH_REWIRING_SIMPLE);
+        igraph_matrix_resize(&mat, igraph_vcount(&graph), igraph_vcount(&graph)); /* preallocate matrix */
     }
-}
 
-int main() {
-    igraph_t g, g_no_vertices, g_no_edges;
-    igraph_vs_t vs;
-    igraph_vector_t v;
-    igraph_vit_t vit;
-
-    igraph_small(&g, 5, IGRAPH_DIRECTED, 0,1, 0,2, 1,1, 1,3, 2,0, 2,3, 3,4, -1);
-    igraph_small(&g_no_vertices, 0, IGRAPH_UNDIRECTED, -1);
-    igraph_small(&g_no_edges, 5, IGRAPH_UNDIRECTED, -1);
-
-    printf("Checking vs_none vertex selector:\n");
-    IGRAPH_ASSERT(igraph_vs_none(&vs) == IGRAPH_SUCCESS);
-    check(&g, &vs);
-    check(&g_no_edges, &vs);
-    check(&g_no_vertices, &vs);
-
-    igraph_set_error_handler(igraph_error_handler_ignore);
-
-    printf("Checking vector selector:\n");
-    igraph_vector_init_int(&v, 3, 2, 3, 4);
-    IGRAPH_ASSERT(igraph_vs_vector(&vs, &v) == IGRAPH_SUCCESS);
-    printf("Some graph:\n");
-    check(&g, &vs);
-    printf("Edgeless graph:\n");
-    check(&g_no_edges, &vs);
-    printf("Graph without vertices should fail.\n");
-    IGRAPH_ASSERT(igraph_vit_create(&g_no_vertices, vs, &vit) == IGRAPH_EINVVID);
-    igraph_vector_destroy(&v);
-
-    printf("Vertex selector with negative index should fail\n");
-    igraph_vector_init_int(&v, 3, -2, 3, 4);
-    IGRAPH_ASSERT(igraph_vs_vector(&vs, &v) == IGRAPH_SUCCESS);
-    IGRAPH_ASSERT(igraph_vit_create(&g, vs, &vit) == IGRAPH_EINVVID);
-    igraph_vector_destroy(&v);
-
-    printf("Checking copy vector selector:\n");
-    igraph_vector_init_int(&v, 3, 2, 3, 4);
-    IGRAPH_ASSERT(igraph_vs_vector_copy(&vs, &v) == IGRAPH_SUCCESS);
-    printf("Some graph:\n");
-    check(&g, &vs);
-    printf("Edgeless graph:\n");
-    check(&g_no_edges, &vs);
-    printf("Graph without vertices should fail.\n");
-    IGRAPH_ASSERT(igraph_vit_create(&g_no_vertices, vs, &vit) == IGRAPH_EINVVID);
-    IGRAPH_ASSERT(igraph_vs_type(&vs) == IGRAPH_VS_VECTOR);
-    igraph_vector_destroy(&v);
-
-    igraph_destroy(&g);
-    igraph_destroy(&g_no_vertices);
-    igraph_destroy(&g_no_edges);
+    BENCH(" 5 Rewired 15x15x15 lattice average_path_length",
+          igraph_average_path_length(&graph, &avglen, NULL, IGRAPH_UNDIRECTED, 1);
+    );
+    BENCH(" 6 Rewired 15x15x15 lattice shortest_paths undirected",
+          igraph_shortest_paths(&graph, &mat, igraph_vss_all(), igraph_vss_all(), IGRAPH_ALL);
+    );
+
+    igraph_destroy(&graph);
+
+    igraph_erdos_renyi_game_gnm(&graph, 10000, 12000, IGRAPH_DIRECTED, IGRAPH_LOOPS);
+    igraph_matrix_resize(&mat, igraph_vcount(&graph), igraph_vcount(&graph)); /* preallocate matrix */
+
+    BENCH(" 7 Erdos-Renyi n=10000 m=12000 average_path_length directed",
+          igraph_average_path_length(&graph, &avglen, NULL, IGRAPH_DIRECTED, 1);
+    );
+    BENCH(" 8 Erdos-Renyi n=10000 m=12000 shortest_paths directed",
+          igraph_shortest_paths(&graph, &mat, igraph_vss_all(), igraph_vss_all(), IGRAPH_OUT);
+    );
+
+    /* The undirected computation will be much slower on this graph, as the largest weakly connected
+     * component is much larger. */
+    BENCH(" 9 Erdos-Renyi n=10000 m=12000 average_path_length undirected",
+          igraph_average_path_length(&graph, &avglen, NULL, IGRAPH_UNDIRECTED, 1);
+    );
+    BENCH("10 Erdos-Renyi n=10000 m=12000 shortest_paths undirected",
+          igraph_shortest_paths(&graph, &mat, igraph_vss_all(), igraph_vss_all(), IGRAPH_ALL);
+    );
+
+    igraph_destroy(&graph);
+    igraph_matrix_destroy(&mat);
 
-    VERIFY_FINALLY_STACK();
     return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/watts_strogatz_game.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/watts_strogatz_game.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/wikti_en_V_syn.elist` & `igraph-0.9.9/vendor/source/igraph/tests/unit/wikti_en_V_syn.elist`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tests/unit/zero_allocs.c` & `igraph-0.9.9/vendor/source/igraph/tests/unit/zero_allocs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/arpack-sed.txt` & `igraph-0.9.9/vendor/source/igraph/tools/arpack-sed.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/bump_version.sh` & `igraph-0.9.9/vendor/source/igraph/tools/bump_version.sh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/getglpk.sh` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/env.c`

 * *Files 24% similar despite different names*

```diff
@@ -1,281 +1,313 @@
-#! /bin/sh
+/* env.c (GLPK environment initialization/termination) */
 
-if [ -d ../optional/glpk ]; then
-    echo "GLPK directory '../optional/glpk' already exists, remove it first"
-#    exit 1
-fi
-
-THIS=`pwd`
-IDIR=${THIS}/../optional/glpk/
-mkdir $IDIR
-
-GLPK="http://ftp.gnu.org/gnu/glpk/glpk-4.45.tar.gz"
-TARGZ=`echo $GLPK | sed 's/^.*\///'`
-DIR=`echo $TARGZ | sed 's/\.tar\.gz$//'`
-
-cd /tmp
-if [ ! -f $TARGZ ]; then curl -O $GLPK; fi
-tar xzf $TARGZ
-
-#cp -R $DIR/include/*.h $DIR/src/*.{c,h} $DIR/src/amd $DIR/src/colamd \
-#    $DIR/{README,COPYING} $IDIR
-
-cd $THIS
-
-SRC=`ls ../optional/glpk/*.h ../optional/glpk/*.c`
-SRC2=`ls ../optional/glpk/amd/*.h ../optional/glpk/amd/*.c`
-SRC3=`ls ../optional/glpk/colamd/*.h ../optional/glpk/colamd/*.c`
-
-INC=$IDIR/glpk.inc
-
-/bin/echo -n "GLPK = " > $INC
-for i in $SRC; do /bin/echo -n "$i " >>$INC; done
-for i in $SRC2; do /bin/echo -n "$i " >>$INC; done
-for i in $SRC3; do /bin/echo -n "$i " >>$INC; done
-
-# Need a patch to get rid of an abort() call. We call igraph_error()
-# instead.
-
-patch -p1 -d ../optional/glpk <<-EOF
-diff -ru glpk.old/glpenv01.c glpk/glpenv01.c
---- glpk.old/glpenv01.c	2012-03-30 11:30:58.000000000 -0400
-+++ glpk/glpenv01.c	2012-03-30 12:03:54.000000000 -0400
-@@ -23,6 +23,7 @@
- ***********************************************************************/
-
- #include "glpapi.h"
-+#include "igraph_error.h"
-
- /***********************************************************************
- *  NAME
-@@ -126,19 +127,15 @@
-       {  /* not initialized yet; perform initialization */
-          if (glp_init_env() != 0)
-          {  /* initialization failed; display an error message */
--            fprintf(stderr, "GLPK initialization failed\n");
--            fflush(stderr);
--            /* and abnormally terminate the program */
--            abort();
-+	   IGRAPH_ERROR("GLPK initialization failed", IGRAPH_EGLP);
-          }
-          /* initialization successful; retrieve the pointer */
-          env = tls_get_ptr();
-       }
-       /* check if the environment block is valid */
-       if (env->magic != ENV_MAGIC)
--      {  fprintf(stderr, "Invalid GLPK environment\n");
--         fflush(stderr);
--         abort();
-+      {
-+	IGRAPH_ERROR("Invalid GLPK environment", IGRAPH_EGLP);
-       }
-       return env;
- }
-@@ -200,9 +197,8 @@
-       if (env == NULL) return 1;
-       /* check if the environment block is valid */
-       if (env->magic != ENV_MAGIC)
--      {  fprintf(stderr, "Invalid GLPK environment\n");
--         fflush(stderr);
--         abort();
-+      {
-+	 IGRAPH_ERROR("Invalid GLPK environment", IGRAPH_EGLP);
-       }
-       /* close handles to shared libraries */
-       if (env->h_odbc != NULL)
-diff -ru glpk.old/glpenv03.c glpk/glpenv03.c
---- glpk.old/glpenv03.c	2012-03-30 11:30:58.000000000 -0400
-+++ glpk/glpenv03.c	2012-04-02 11:18:42.000000000 -0400
-@@ -40,9 +40,9 @@
-
- void glp_printf(const char *fmt, ...)
- {     va_list arg;
--      va_start(arg, fmt);
--      xvprintf(fmt, arg);
--      va_end(arg);
-+      /* va_start(arg, fmt); */
-+      /* xvprintf(fmt, arg); */
-+      /* va_end(arg); */
-       return;
- }
-
-@@ -64,22 +64,22 @@
- void glp_vprintf(const char *fmt, va_list arg)
- {     ENV *env = get_env_ptr();
-       /* if terminal output is disabled, do nothing */
--      if (!env->term_out) goto skip;
--      /* format the output */
--      vsprintf(env->term_buf, fmt, arg);
--      /* pass the output to the user-defined routine */
--      if (env->term_hook != NULL)
--      {  if (env->term_hook(env->term_info, env->term_buf) != 0)
--            goto skip;
--      }
--      /* send the output to the terminal */
--      fputs(env->term_buf, stdout);
--      fflush(stdout);
--      /* copy the output to the text file */
--      if (env->tee_file != NULL)
--      {  fputs(env->term_buf, env->tee_file);
--         fflush(env->tee_file);
--      }
-+      /* if (!env->term_out) goto skip; */
-+      /* /\* format the output *\/ */
-+      /* vsprintf(env->term_buf, fmt, arg); */
-+      /* /\* pass the output to the user-defined routine *\/ */
-+      /* if (env->term_hook != NULL) */
-+      /* {  if (env->term_hook(env->term_info, env->term_buf) != 0) */
-+      /*       goto skip; */
-+      /* } */
-+      /* /\* send the output to the terminal *\/ */
-+      /* fputs(env->term_buf, stdout); */
-+      /* fflush(stdout); */
-+      /* /\* copy the output to the text file *\/ */
-+      /* if (env->tee_file != NULL) */
-+      /* {  fputs(env->term_buf, env->tee_file); */
-+      /*    fflush(env->tee_file); */
-+      /* } */
- skip: return;
- }
-
-diff -ru glpk.old/glpenv04.c glpk/glpenv04.c
---- glpk.old/glpenv04.c	2012-03-30 11:30:58.000000000 -0400
-+++ glpk/glpenv04.c	2012-03-30 11:56:41.000000000 -0400
-@@ -23,6 +23,7 @@
- ***********************************************************************/
-
- #include "glpapi.h"
-+#include "igraph_error.h"
-
- /***********************************************************************
- *  NAME
-@@ -44,14 +45,7 @@
-       va_list arg;
-       env->term_out = GLP_ON;
-       va_start(arg, fmt);
--      xvprintf(fmt, arg);
--      va_end(arg);
--      xprintf("Error detected in file %s at line %d\n", env->err_file,
--         env->err_line);
--      if (env->err_hook != NULL)
--         env->err_hook(env->err_info);
--      abort();
--      exit(EXIT_FAILURE);
-+      igraph_errorvf(fmt, env->err_file, env->err_line, IGRAPH_EGLP, arg);
-       /* no return */
- }
-
-diff -ru glpk.old/glpenv07.c glpk/glpenv07.c
---- glpk.old/glpenv07.c	2012-03-30 11:30:58.000000000 -0400
-+++ glpk/glpenv07.c	2012-03-31 13:21:03.000000000 -0400
-@@ -413,13 +413,13 @@
-
- static void *c_fopen(const char *fname, const char *mode)
- {     FILE *fh;
--      if (strcmp(fname, "/dev/stdin") == 0)
--         fh = stdin;
--      else if (strcmp(fname, "/dev/stdout") == 0)
--         fh = stdout;
--      else if (strcmp(fname, "/dev/stderr") == 0)
--         fh = stderr;
--      else
-+      /* if (strcmp(fname, "/dev/stdin") == 0) */
-+      /*    fh = stdin; */
-+      /* else if (strcmp(fname, "/dev/stdout") == 0) */
-+      /*    fh = stdout; */
-+      /* else if (strcmp(fname, "/dev/stderr") == 0) */
-+      /*    fh = stderr; */
-+      /* else */
-          fh = fopen(fname, mode);
-       if (fh == NULL)
-          lib_err_msg(strerror(errno));
-@@ -484,11 +484,11 @@
- static int c_fclose(void *_fh)
- {     FILE *fh = _fh;
-       int ret;
--      if (fh == stdin)
--         ret = 0;
--      else if (fh == stdout || fh == stderr)
--         fflush(fh), ret = 0;
--      else
-+      /* if (fh == stdin) */
-+      /*    ret = 0; */
-+      /* else if (fh == stdout || fh == stderr) */
-+      /*    fflush(fh), ret = 0; */
-+      /* else */
-          ret = fclose(fh);
-       if (ret != 0)
-       {  lib_err_msg(strerror(errno));
-diff -ru glpk.old/glpgmp.c glpk/glpgmp.c
---- glpk.old/glpgmp.c	2012-03-30 11:30:58.000000000 -0400
-+++ glpk/glpgmp.c	2012-04-01 00:05:13.000000000 -0400
-@@ -860,7 +860,7 @@
-          d[j] = (unsigned char)r->val;
-       }
-       /* output the integer to the stream */
--      if (fp == NULL) fp = stdout;
-+      /* if (fp == NULL) fp = stdout; */
-       if (mpz_sgn(x) < 0)
-          fputc('-', fp), nwr++;
-       for (j = n-1; j >= 0; j--)
-@@ -1091,7 +1091,7 @@
-       int nwr;
-       if (!(2 <= base && base <= 36))
-          xfault("mpq_out_str: base = %d; invalid base\n", base);
--      if (fp == NULL) fp = stdout;
-+      /* if (fp == NULL) fp = stdout; */
-       nwr = mpz_out_str(fp, base, &x->p);
-       if (x->q.val == 1 && x->q.ptr == NULL)
-          ;
-diff -ru glpk.old/glpmpl04.c glpk/glpmpl04.c
---- glpk.old/glpmpl04.c	2012-03-30 11:30:58.000000000 -0400
-+++ glpk/glpmpl04.c	2012-04-01 00:07:09.000000000 -0400
-@@ -341,11 +341,11 @@
-
- void open_output(MPL *mpl, char *file)
- {     xassert(mpl->out_fp == NULL);
--      if (file == NULL)
--      {  file = "<stdout>";
--         mpl->out_fp = (void *)stdout;
--      }
--      else
-+      /* if (file == NULL) */
-+      /* {  file = "<stdout>"; */
-+      /*    mpl->out_fp = (void *)stdout; */
-+      /* } */
-+      /* else */
-       {  mpl->out_fp = xfopen(file, "w");
-          if (mpl->out_fp == NULL)
-             error(mpl, "unable to create %s - %s", file, xerrmsg());
-@@ -362,9 +362,9 @@
-
- void write_char(MPL *mpl, int c)
- {     xassert(mpl->out_fp != NULL);
--      if (mpl->out_fp == (void *)stdout)
--         xprintf("%c", c);
--      else
-+      /* if (mpl->out_fp == (void *)stdout) */
-+      /*    xprintf("%c", c); */
-+      /* else */
-          xfprintf(mpl->out_fp, "%c", c);
-       return;
- }
-@@ -393,7 +393,7 @@
-
- void flush_output(MPL *mpl)
- {     xassert(mpl->out_fp != NULL);
--      if (mpl->out_fp != (void *)stdout)
-+      /* if (mpl->out_fp != (void *)stdout) */
-       {  xfflush(mpl->out_fp);
-          if (xferror(mpl->out_fp))
-             error(mpl, "write error on %s - %s", mpl->out_file,
-@@ -1410,7 +1410,7 @@
-       if (mpl->row != NULL) xfree(mpl->row);
-       if (mpl->col != NULL) xfree(mpl->col);
-       if (mpl->in_fp != NULL) xfclose(mpl->in_fp);
--      if (mpl->out_fp != NULL && mpl->out_fp != (void *)stdout)
-+      if (mpl->out_fp != NULL /* && mpl->out_fp != (void *)stdout */)
-          xfclose(mpl->out_fp);
-       if (mpl->out_file != NULL) xfree(mpl->out_file);
-       if (mpl->prt_fp != NULL) xfclose(mpl->prt_fp);
-EOF
+/***********************************************************************
+*  This code is part of GLPK (GNU Linear Programming Kit).
+*  Copyright (C) 2000-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
+*
+*  GLPK is free software: you can redistribute it and/or modify it
+*  under the terms of the GNU General Public License as published by
+*  the Free Software Foundation, either version 3 of the License, or
+*  (at your option) any later version.
+*
+*  GLPK is distributed in the hope that it will be useful, but WITHOUT
+*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+*  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
+*  License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
+***********************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "glpk_tls_config.h"
+
+#include "glpk.h"
+#include "env.h"
+
+#include "igraph_error.h"
+
+/***********************************************************************
+*  NAME
+*
+*  glp_init_env - initialize GLPK environment
+*
+*  SYNOPSIS
+*
+*  int glp_init_env(void);
+*
+*  DESCRIPTION
+*
+*  The routine glp_init_env initializes the GLPK environment. Normally
+*  the application program does not need to call this routine, because
+*  it is called automatically on the first call to any API routine.
+*
+*  RETURNS
+*
+*  The routine glp_init_env returns one of the following codes:
+*
+*  0 - initialization successful;
+*  1 - environment has been already initialized;
+*  2 - initialization failed (insufficient memory);
+*  3 - initialization failed (unsupported programming model). */
+
+int glp_init_env(void)
+{     ENV *env;
+      int ok;
+      /* check if the programming model is supported */
+      ok = (CHAR_BIT == 8 && sizeof(char) == 1 &&
+         sizeof(short) == 2 && sizeof(int) == 4 &&
+         (sizeof(void *) == 4 || sizeof(void *) == 8));
+      if (!ok)
+         return 3;
+      /* check if the environment is already initialized */
+      if (tls_get_ptr() != NULL)
+         return 1;
+      /* allocate and initialize the environment block */
+      env = malloc(sizeof(ENV));
+      if (env == NULL)
+         return 2;
+      memset(env, 0, sizeof(ENV));
+#if 0 /* 14/I-2017 */
+      sprintf(env->version, "%d.%d",
+         GLP_MAJOR_VERSION, GLP_MINOR_VERSION);
+#endif
+      env->self = env;
+      env->term_buf = malloc(TBUF_SIZE);
+      if (env->term_buf == NULL)
+      {  free(env);
+         return 2;
+      }
+      env->term_out = GLP_ON;
+      env->term_hook = NULL;
+      env->term_info = NULL;
+      env->tee_file = NULL;
+#if 1 /* 23/XI-2015 */
+      env->err_st = 0;
+#endif
+      env->err_file = NULL;
+      env->err_line = 0;
+      env->err_hook = NULL;
+      env->err_info = NULL;
+      env->err_buf = malloc(EBUF_SIZE);
+      if (env->err_buf == NULL)
+      {  free(env->term_buf);
+         free(env);
+         return 2;
+      }
+      env->err_buf[0] = '\0';
+      env->mem_limit = SIZE_T_MAX;
+      env->mem_ptr = NULL;
+      env->mem_count = env->mem_cpeak = 0;
+      env->mem_total = env->mem_tpeak = 0;
+#if 1 /* 23/XI-2015 */
+      env->gmp_pool = NULL;
+      env->gmp_size = 0;
+      env->gmp_work = NULL;
+#endif
+      env->h_odbc = env->h_mysql = NULL;
+      /* save pointer to the environment block */
+      tls_set_ptr(env);
+      /* initialization successful */
+      return 0;
+}
+
+/***********************************************************************
+*  NAME
+*
+*  get_env_ptr - retrieve pointer to environment block
+*
+*  SYNOPSIS
+*
+*  #include "env.h"
+*  ENV *get_env_ptr(void);
+*
+*  DESCRIPTION
+*
+*  The routine get_env_ptr retrieves and returns a pointer to the GLPK
+*  environment block.
+*
+*  If the GLPK environment has not been initialized yet, the routine
+*  performs initialization. If initialization fails, the routine prints
+*  an error message to stderr and terminates the program.
+*
+*  RETURNS
+*
+*  The routine returns a pointer to the environment block. */
+
+ENV *get_env_ptr(void)
+{     ENV *env = tls_get_ptr();
+      /* check if the environment has been initialized */
+      if (env == NULL)
+      {  /* not initialized yet; perform initialization */
+         if (glp_init_env() != 0)
+         {  /* initialization failed; display an error message */
+            IGRAPH_FATAL("GLPK initialization failed");
+         }
+         /* initialization successful; retrieve the pointer */
+         env = tls_get_ptr();
+      }
+      /* check if the environment block is valid */
+      if (env->self != env)
+      {
+         IGRAPH_FATAL("Invalid GLPK environment");
+      }
+      return env;
+}
+
+/***********************************************************************
+*  NAME
+*
+*  glp_version - determine library version
+*
+*  SYNOPSIS
+*
+*  const char *glp_version(void);
+*
+*  RETURNS
+*
+*  The routine glp_version returns a pointer to a null-terminated
+*  character string, which specifies the version of the GLPK library in
+*  the form "X.Y", where X is the major version number, and Y is the
+*  minor version number, for example, "4.16". */
+
+#define str(s) # s
+#define xstr(s) str(s)
+
+const char *glp_version(void)
+#if 0 /* 14/I-2017 */
+{     ENV *env = get_env_ptr();
+      return env->version;
+}
+#else /* suggested by Heinrich */
+{     return
+         xstr(GLP_MAJOR_VERSION) "." xstr(GLP_MINOR_VERSION);
+}
+#endif
+
+/***********************************************************************
+*  NAME
+*
+*  glp_config - determine library configuration
+*
+*  SYNOPSIS
+*
+*  const char *glp_config(const char *option);
+*
+*  DESCRIPTION
+*
+*  The routine glp_config determines some options which were specified
+*  on configuring the GLPK library.
+*
+*  RETURNS
+*
+*  The routine glp_config returns a pointer to a null-terminating
+*  string depending on the option inquired.
+*
+*  For option = "TLS" the routine returns the thread local storage
+*  class specifier used (e.g. "_Thread_local") if the GLPK library was
+*  configured to run in multi-threaded environment, or NULL otherwise.
+*
+*  For option = "ODBC_DLNAME" the routine returns the name of ODBC
+*  shared library if this option was enabled, or NULL otherwise.
+*
+*  For option = "MYSQL_DLNAME" the routine returns the name of MySQL
+*  shared library if this option was enabled, or NULL otherwise. */
+
+const char *glp_config(const char *option)
+{     const char *s;
+      if (strcmp(option, "TLS") == 0)
+#ifndef TLS
+         s = NULL;
+#else
+         s = xstr(TLS);
+#endif
+      else if (strcmp(option, "ODBC_DLNAME") == 0)
+#ifndef ODBC_DLNAME
+         s = NULL;
+#else
+         s = ODBC_DLNAME;
+#endif
+      else if (strcmp(option, "MYSQL_DLNAME") == 0)
+#ifndef MYSQL_DLNAME
+         s = NULL;
+#else
+         s = MYSQL_DLNAME;
+#endif
+      else
+      {  /* invalid option is always disabled */
+         s = NULL;
+      }
+      return s;
+}
+
+/***********************************************************************
+*  NAME
+*
+*  glp_free_env - free GLPK environment
+*
+*  SYNOPSIS
+*
+*  int glp_free_env(void);
+*
+*  DESCRIPTION
+*
+*  The routine glp_free_env frees all resources used by GLPK routines
+*  (memory blocks, etc.) which are currently still in use.
+*
+*  Normally the application program does not need to call this routine,
+*  because GLPK routines always free all unused resources. However, if
+*  the application program even has deleted all problem objects, there
+*  will be several memory blocks still allocated for the library needs.
+*  For some reasons the application program may want GLPK to free this
+*  memory, in which case it should call glp_free_env.
+*
+*  Note that a call to glp_free_env invalidates all problem objects as
+*  if no GLPK routine were called.
+*
+*  RETURNS
+*
+*  0 - termination successful;
+*  1 - environment is inactive (was not initialized). */
+
+int glp_free_env(void)
+{     ENV *env = tls_get_ptr();
+      MBD *desc;
+      /* check if the environment is active */
+      if (env == NULL)
+         return 1;
+      /* check if the environment block is valid */
+      if (env->self != env)
+      {
+         IGRAPH_FATAL("Invalid GLPK environment");
+      }
+      /* close handles to shared libraries */
+      if (env->h_odbc != NULL)
+         xdlclose(env->h_odbc);
+      if (env->h_mysql != NULL)
+         xdlclose(env->h_mysql);
+      /* free memory blocks which are still allocated */
+      while (env->mem_ptr != NULL)
+      {  desc = env->mem_ptr;
+         env->mem_ptr = desc->next;
+         free(desc);
+      }
+      /* close text file used for copying terminal output */
+      if (env->tee_file != NULL)
+         fclose(env->tee_file);
+      /* invalidate the environment block */
+      env->self = NULL;
+      /* free memory allocated to the environment block */
+      free(env->term_buf);
+      free(env->err_buf);
+      free(env);
+      /* reset a pointer to the environment block */
+      tls_set_ptr(NULL);
+      /* termination successful */
+      return 0;
+}
+
+/* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/lapack/CompletePolish` & `igraph-0.9.9/vendor/source/igraph/tools/lapack/CompletePolish`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/lapack/getlapack.sh` & `igraph-0.9.9/vendor/source/igraph/tools/lapack/getlapack.sh`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/lapack/lapack.patch` & `igraph-0.9.9/vendor/source/igraph/tools/lapack/lapack.patch`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/lapack/lenscrub.l` & `igraph-0.9.9/vendor/source/igraph/tools/lapack/lenscrub.l`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/lapack/mt.patch` & `igraph-0.9.9/vendor/source/igraph/tools/lapack/mt.patch`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/lapack/split.sed` & `igraph-0.9.9/vendor/source/igraph/tools/lapack/split.sed`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/tools/removeexamples.py` & `igraph-0.9.9/vendor/source/igraph/tools/removeexamples.py`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/License.txt` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/License.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/SuiteSparse_config.h` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/SuiteSparse_config.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs.h` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_add.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_add.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_amd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_amd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_chol.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_chol.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_cholsol.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_cholsol.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_compress.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_compress.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_counts.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_counts.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_cumsum.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_cumsum.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_dfs.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_dfs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_dmperm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_dmperm.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_dupl.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_dupl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_ereach.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_ereach.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_etree.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_etree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_fkeep.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_fkeep.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_happly.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_happly.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_house.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_house.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_leaf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_leaf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_load.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_load.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_lsolve.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_lsolve.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_ltsolve.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_ltsolve.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_lu.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_lu.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_lusol.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_lusol.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_malloc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_malloc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_maxtrans.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_maxtrans.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_multiply.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_multiply.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_permute.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_permute.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_post.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_post.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_print.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_print.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_qr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_qr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_qrsol.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_qrsol.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_randperm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_randperm.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_reach.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_reach.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_scatter.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_scatter.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_scc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_scc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_schol.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_schol.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_spsolve.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_spsolve.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_sqr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_sqr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_symperm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_symperm.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_tdfs.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_tdfs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_transpose.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_transpose.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_updown.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_updown.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_usolve.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_usolve.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_util.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_util.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/cs/cs_utsolve.c` & `igraph-0.9.9/vendor/source/igraph/vendor/cs/cs_utsolve.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/Notice` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/Notice`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/README` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/README`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/arithchk.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/arithchk.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/backspac.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/backspac.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_div.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_div.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/c_sqrt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/c_sqrt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/changes` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/changes`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/close.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/close.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/ctype.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/ctype.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/d_mod.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/d_mod.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/dfe.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/dfe.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/dtime_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/dtime_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/due.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/due.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/ef1asc_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/ef1asc_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/endfile.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/endfile.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/err.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/err.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/etime_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/etime_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/exit_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/exit_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/f2c.h0` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/f2c.h0`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/f2ch.add` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/f2ch.add`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/f77_aloc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/f77_aloc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/f77vers.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/f77vers.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/fio.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/fio.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/fmt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/fmt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/fmt.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/fmt.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/fmtlib.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/fmtlib.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/fp.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/fp.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/ftell_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/ftell_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/getarg_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/getarg_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/getenv_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/getenv_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/i77vers.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/i77vers.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/iio.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/iio.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/ilnw.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/ilnw.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/inquire.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/inquire.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/lbitbits.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/lbitbits.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/libf2c.lbc` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/libf2c.lbc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/libf2c.sy` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/libf2c.sy`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/lio.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/lio.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/lread.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/lread.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/lwrite.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/lwrite.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/main.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/main.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.sy` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.sy`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.u` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.u`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.vc` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.vc`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/makefile.wat` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/makefile.wat`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/mkfile.plan9` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/mkfile.plan9`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/open.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/open.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_zi.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_zi.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/pow_zz.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/pow_zz.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/r_mod.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/r_mod.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/rawio.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/rawio.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/rdfmt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/rdfmt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/rsfe.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/rsfe.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/rsli.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/rsli.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/rsne.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/rsne.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_cat.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_cat.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_cmp.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_cmp.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_copy.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_copy.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_paus.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_paus.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_rnge.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_rnge.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/s_stop.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/s_stop.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/sfe.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/sfe.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/sig_die.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/sig_die.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/signal1.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/signal1.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/signal1.h0` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/signal1.h0`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/sue.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/sue.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/sysdep1.h` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/sysdep1.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/sysdep1.h0` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/sysdep1.h0`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/system_.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/system_.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/uio.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/uio.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/uninit.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/uninit.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/util.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/util.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/wref.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/wref.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/wrtfmt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/wrtfmt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/wsfe.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/wsfe.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/wsle.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/wsle.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/xsum0.out` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/xsum0.out`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/xwsne.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/xwsne.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_div.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_div.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_log.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_log.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/f2c/z_sqrt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/f2c/z_sqrt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/COPYING` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/COPYING`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
@@ -669,8 +668,7 @@
 
   The GNU General Public License does not permit incorporating your program
 into proprietary programs.  If your program is a subroutine library, you
 may consider it more useful to permit linking proprietary applications with
 the library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.  But first, please read
 <http://www.gnu.org/philosophy/why-not-lgpl.html>.
-
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/README` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/README`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,9 @@
-                                                     Olga K. gewidmet
-
-GLPK (GNU Linear Programming Kit) Version 4.45
-
-Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-E-mail: <mao@gnu.org>.
+GLPK (GNU Linear Programming Kit) Version 5.0
+Copyright (C) 2000-2020 Free Software Foundation, Inc.
 
 GLPK is part of the GNU Project released under the aegis of GNU.
 
 GLPK is free software: you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation, either version 3 of the License, or (at your
 option) any later version.
@@ -21,19 +15,19 @@
 The GLPK package is a set of routines written in ANSI C and organized
 in the form of a callable library. This package is intended for solving
 large-scale linear programming (LP), mixed integer linear programming
 (MIP), and other related problems.
 
 The GLPK package includes the following main components:
 
-* implementation of the simplex method;
-* implementation of the exact simplex method based on bignum (rational)
-  arithmetic;
-* implementation of the primal-dual interior-point method;
-* implementation of the branch-and-cut method;
+* primal simplex method;
+* dual simplex method;
+* exact simplex method based on rational arithmetic;
+* primal-dual interior-point method;
+* branch-and-cut method;
 * application program interface (API);
 * GNU MathProg modeling language (a subset of AMPL);
-* GLPSOL, a stand-alone LP/MIP solver.
+* GLPSOL (stand-alone LP/MIP solver).
 
 See GLPK webpage <http://www.gnu.org/software/glpk/glpk.html>.
 
 Please report bugs to <bug-glpk@gnu.org>.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/COPYING` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/COPYING`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/README` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/README`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_1.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_aat.c`

 * *Files 20% similar despite different names*

```diff
@@ -1,181 +1,185 @@
 /* ========================================================================= */
-/* === AMD_1 =============================================================== */
+/* === AMD_aat ============================================================= */
 /* ========================================================================= */
 
 /* ------------------------------------------------------------------------- */
 /* AMD, Copyright (c) Timothy A. Davis,                                      */
 /* Patrick R. Amestoy, and Iain S. Duff.  See ../README.txt for License.     */
 /* email: davis at cise.ufl.edu    CISE Department, Univ. of Florida.        */
 /* web: http://www.cise.ufl.edu/research/sparse/amd                          */
 /* ------------------------------------------------------------------------- */
 
-/* AMD_1: Construct A+A' for a sparse matrix A and perform the AMD ordering.
- *
- * The n-by-n sparse matrix A can be unsymmetric.  It is stored in MATLAB-style
- * compressed-column form, with sorted row indices in each column, and no
- * duplicate entries.  Diagonal entries may be present, but they are ignored.
- * Row indices of column j of A are stored in Ai [Ap [j] ... Ap [j+1]-1].
- * Ap [0] must be zero, and nz = Ap [n] is the number of entries in A.  The
- * size of the matrix, n, must be greater than or equal to zero.
- *
- * This routine must be preceded by a call to AMD_aat, which computes the
- * number of entries in each row/column in A+A', excluding the diagonal.
- * Len [j], on input, is the number of entries in row/column j of A+A'.  This
- * routine constructs the matrix A+A' and then calls AMD_2.  No error checking
- * is performed (this was done in AMD_valid).
+/* AMD_aat:  compute the symmetry of the pattern of A, and count the number of
+ * nonzeros each column of A+A' (excluding the diagonal).  Assumes the input
+ * matrix has no errors, with sorted columns and no duplicates
+ * (AMD_valid (n, n, Ap, Ai) must be AMD_OK, but this condition is not
+ * checked).
  */
 
 #include "amd_internal.h"
 
-GLOBAL void AMD_1
+GLOBAL size_t AMD_aat   /* returns nz in A+A' */
 (
-    Int n,              /* n > 0 */
-    const Int Ap [ ],   /* input of size n+1, not modified */
-    const Int Ai [ ],   /* input of size nz = Ap [n], not modified */
-    Int P [ ],          /* size n output permutation */
-    Int Pinv [ ],       /* size n output inverse permutation */
-    Int Len [ ],        /* size n input, undefined on output */
-    Int slen,           /* slen >= sum (Len [0..n-1]) + 7n,
-                         * ideally slen = 1.2 * sum (Len) + 8n */
-    Int S [ ],          /* size slen workspace */
-    double Control [ ], /* input array of size AMD_CONTROL */
-    double Info [ ]     /* output array of size AMD_INFO */
+    Int n,
+    const Int Ap [ ],
+    const Int Ai [ ],
+    Int Len [ ],        /* Len [j]: length of column j of A+A', excl diagonal*/
+    Int Tp [ ],         /* workspace of size n */
+    double Info [ ]
 )
 {
-    Int i, j, k, p, pfree, iwlen, pj, p1, p2, pj2, *Iw, *Pe, *Nv, *Head,
-        *Elen, *Degree, *s, *W, *Sp, *Tp ;
-
-    /* --------------------------------------------------------------------- */
-    /* construct the matrix for AMD_2 */
-    /* --------------------------------------------------------------------- */
-
-    ASSERT (n > 0) ;
-
-    iwlen = slen - 6*n ;
-    s = S ;
-    Pe = s ;        s += n ;
-    Nv = s ;        s += n ;
-    Head = s ;      s += n ;
-    Elen = s ;      s += n ;
-    Degree = s ;    s += n ;
-    W = s ;         s += n ;
-    Iw = s ;        s += iwlen ;
+    Int p1, p2, p, i, j, pj, pj2, k, nzdiag, nzboth, nz ;
+    double sym ;
+    size_t nzaat ;
 
+#ifndef NDEBUG
+    AMD_debug_init ("AMD AAT") ;
+    for (k = 0 ; k < n ; k++) Tp [k] = EMPTY ;
     ASSERT (AMD_valid (n, n, Ap, Ai) == AMD_OK) ;
+#endif
 
-    /* construct the pointers for A+A' */
-    Sp = Nv ;                   /* use Nv and W as workspace for Sp and Tp [ */
-    Tp = W ;
-    pfree = 0 ;
-    for (j = 0 ; j < n ; j++)
+    if (Info != (double *) NULL)
     {
-        Pe [j] = pfree ;
-        Sp [j] = pfree ;
-        pfree += Len [j] ;
+        /* clear the Info array, if it exists */
+        for (i = 0 ; i < AMD_INFO ; i++)
+        {
+            Info [i] = EMPTY ;
+        }
+        Info [AMD_STATUS] = AMD_OK ;
     }
 
-    /* Note that this restriction on iwlen is slightly more restrictive than
-     * what is strictly required in AMD_2.  AMD_2 can operate with no elbow
-     * room at all, but it will be very slow.  For better performance, at
-     * least size-n elbow room is enforced. */
-    ASSERT (iwlen >= pfree + n) ;
+    for (k = 0 ; k < n ; k++)
+    {
+        Len [k] = 0 ;
+    }
 
-#ifndef NDEBUG
-    for (p = 0 ; p < iwlen ; p++) Iw [p] = EMPTY ;
-#endif
+    nzdiag = 0 ;
+    nzboth = 0 ;
+    nz = Ap [n] ;
 
     for (k = 0 ; k < n ; k++)
     {
-        AMD_DEBUG1 (("Construct row/column k= "ID" of A+A'\n", k))  ;
         p1 = Ap [k] ;
         p2 = Ap [k+1] ;
+        AMD_DEBUG2 (("\nAAT Column: "ID" p1: "ID" p2: "ID"\n", k, p1, p2)) ;
 
         /* construct A+A' */
         for (p = p1 ; p < p2 ; )
         {
             /* scan the upper triangular part of A */
             j = Ai [p] ;
-            ASSERT (j >= 0 && j < n) ;
             if (j < k)
             {
-                /* entry A (j,k) in the strictly upper triangular part */
-                ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;
-                ASSERT (Sp [k] < (k == n-1 ? pfree : Pe [k+1])) ;
-                Iw [Sp [j]++] = k ;
-                Iw [Sp [k]++] = j ;
+                /* entry A (j,k) is in the strictly upper triangular part,
+                 * add both A (j,k) and A (k,j) to the matrix A+A' */
+                Len [j]++ ;
+                Len [k]++ ;
+                AMD_DEBUG3 (("    upper ("ID","ID") ("ID","ID")\n", j,k, k,j));
                 p++ ;
             }
             else if (j == k)
             {
                 /* skip the diagonal */
                 p++ ;
+                nzdiag++ ;
                 break ;
             }
             else /* j > k */
             {
                 /* first entry below the diagonal */
                 break ;
             }
             /* scan lower triangular part of A, in column j until reaching
              * row k.  Start where last scan left off. */
+            ASSERT (Tp [j] != EMPTY) ;
             ASSERT (Ap [j] <= Tp [j] && Tp [j] <= Ap [j+1]) ;
             pj2 = Ap [j+1] ;
             for (pj = Tp [j] ; pj < pj2 ; )
             {
                 i = Ai [pj] ;
-                ASSERT (i >= 0 && i < n) ;
                 if (i < k)
                 {
-                    /* A (i,j) is only in the lower part, not in upper */
-                    ASSERT (Sp [i] < (i == n-1 ? pfree : Pe [i+1])) ;
-                    ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;
-                    Iw [Sp [i]++] = j ;
-                    Iw [Sp [j]++] = i ;
+                    /* A (i,j) is only in the lower part, not in upper.
+                     * add both A (i,j) and A (j,i) to the matrix A+A' */
+                    Len [i]++ ;
+                    Len [j]++ ;
+                    AMD_DEBUG3 (("    lower ("ID","ID") ("ID","ID")\n",
+                        i,j, j,i)) ;
                     pj++ ;
                 }
                 else if (i == k)
                 {
                     /* entry A (k,j) in lower part and A (j,k) in upper */
                     pj++ ;
+                    nzboth++ ;
                     break ;
                 }
                 else /* i > k */
                 {
                     /* consider this entry later, when k advances to i */
                     break ;
                 }
             }
             Tp [j] = pj ;
         }
+        /* Tp [k] points to the entry just below the diagonal in column k */
         Tp [k] = p ;
     }
 
     /* clean up, for remaining mismatched entries */
     for (j = 0 ; j < n ; j++)
     {
         for (pj = Tp [j] ; pj < Ap [j+1] ; pj++)
         {
             i = Ai [pj] ;
-            ASSERT (i >= 0 && i < n) ;
-            /* A (i,j) is only in the lower part, not in upper */
-            ASSERT (Sp [i] < (i == n-1 ? pfree : Pe [i+1])) ;
-            ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;
-            Iw [Sp [i]++] = j ;
-            Iw [Sp [j]++] = i ;
+            /* A (i,j) is only in the lower part, not in upper.
+             * add both A (i,j) and A (j,i) to the matrix A+A' */
+            Len [i]++ ;
+            Len [j]++ ;
+            AMD_DEBUG3 (("    lower cleanup ("ID","ID") ("ID","ID")\n",
+                i,j, j,i)) ;
         }
     }
 
-#ifndef NDEBUG
-    for (j = 0 ; j < n-1 ; j++) ASSERT (Sp [j] == Pe [j+1]) ;
-    ASSERT (Sp [n-1] == pfree) ;
-#endif
-
-    /* Tp and Sp no longer needed ] */
-
     /* --------------------------------------------------------------------- */
-    /* order the matrix */
+    /* compute the symmetry of the nonzero pattern of A */
     /* --------------------------------------------------------------------- */
 
-    AMD_2 (n, Pe, Iw, Len, iwlen, pfree,
-        Nv, Pinv, P, Head, Elen, Degree, W, Control, Info) ;
+    /* Given a matrix A, the symmetry of A is:
+     *  B = tril (spones (A), -1) + triu (spones (A), 1) ;
+     *  sym = nnz (B & B') / nnz (B) ;
+     *  or 1 if nnz (B) is zero.
+     */
+
+    if (nz == nzdiag)
+    {
+        sym = 1 ;
+    }
+    else
+    {
+        sym = (2 * (double) nzboth) / ((double) (nz - nzdiag)) ;
+    }
+
+    nzaat = 0 ;
+    for (k = 0 ; k < n ; k++)
+    {
+        nzaat += Len [k] ;
+    }
+
+    AMD_DEBUG1 (("AMD nz in A+A', excluding diagonal (nzaat) = %g\n",
+        (double) nzaat)) ;
+    AMD_DEBUG1 (("   nzboth: "ID" nz: "ID" nzdiag: "ID" symmetry: %g\n",
+                nzboth, nz, nzdiag, sym)) ;
+
+    if (Info != (double *) NULL)
+    {
+        Info [AMD_STATUS] = AMD_OK ;
+        Info [AMD_N] = n ;
+        Info [AMD_NZ] = nz ;
+        Info [AMD_SYMMETRY] = sym ;         /* symmetry of pattern of A */
+        Info [AMD_NZDIAG] = nzdiag ;        /* nonzeros on diagonal of A */
+        Info [AMD_NZ_A_PLUS_AT] = nzaat ;   /* nonzeros in A+A' */
+    }
+
+    return (nzaat) ;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_2.c`

 * *Files 0% similar despite different names*

```diff
@@ -10,16 +10,14 @@
 /* ------------------------------------------------------------------------- */
 
 /* AMD_2:  performs the AMD ordering on a symmetric sparse matrix A, followed
  * by a postordering (via depth-first search) of the assembly tree using the
  * AMD_postorder routine.
  */
 
-#pragma clang diagnostic ignored "-Wconversion"
-
 #include "amd_internal.h"
 
 /* ========================================================================= */
 /* === clear_flag ========================================================== */
 /* ========================================================================= */
 
 static Int clear_flag (Int wflg, Int wbig, Int W [ ], Int n)
@@ -544,15 +542,15 @@
  * Pointer) is an index into Iw, and all indices into Iw use variables starting
  * with "p."  The only exception to this rule is the iwlen input argument.
  *
  * p:           pointer into lots of things
  * p1:          Pe [i] for some variable i (start of element list)
  * p2:          Pe [i] + Elen [i] -  1 for some variable i
  * p3:          index of first supervariable in clean list
- * p4:          
+ * p4:
  * pdst:        destination pointer, for compression
  * pend:        end of memory to compress
  * pj:          pointer into an element or variable
  * pme:         pointer into the current element (pme1...pme2)
  * pme1:        the current element, me, is stored in Iw [pme1...pme2]
  * pme2:        the end of the current element
  * pn:          pointer into a "clean" variable, also used to compress
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_control.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_control.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_defaults.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_defaults.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_dump.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_dump.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_info.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_info.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_internal.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_internal.h`

 * *Files 4% similar despite different names*

```diff
@@ -2,29 +2,28 @@
 
 /* Written by Andrew Makhorin <mao@gnu.org>. */
 
 #ifndef AMD_INTERNAL_H
 #define AMD_INTERNAL_H
 
 /* AMD will be exceedingly slow when running in debug mode. */
-#if 1
 #ifndef NDEBUG
 #define NDEBUG
 #endif
-#endif
 
 #include "amd.h"
-#define _GLPSTD_STDIO
-#include "glpenv.h"
+#include "env.h"
 
 #define Int int
 #define ID "%d"
 #define Int_MAX INT_MAX
 
-#ifndef SIZE_T_MAX
+#if 0 /* 15/II-2012 */
+/* now this macro is defined in glpenv.h; besides, the definiton below
+   depends on implementation, because size_t is an unsigned type */
 #define SIZE_T_MAX ((size_t)(-1))
 #endif
 
 #define EMPTY (-1)
 #define FLIP(i) (-(i)-2)
 #define UNFLIP(i) ((i < EMPTY) ? FLIP (i) : (i))
 
@@ -50,15 +49,15 @@
 #define AMD_debug_init amd_debug_init
 #define AMD_preprocess amd_preprocess
 
 #define amd_malloc xmalloc
 #if 0 /* 24/V-2009 */
 #define amd_free xfree
 #else
-#define amd_free(ptr) { if ((ptr) != NULL) xfree(ptr); } 
+#define amd_free(ptr) { if ((ptr) != NULL) xfree(ptr); }
 #endif
 #define amd_printf xprintf
 
 #define PRINTF(params) { amd_printf params; }
 
 #ifndef NDEBUG
 #define ASSERT(expr) xassert(expr)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_order.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_order.c`

 * *Files 1% similar despite different names*

```diff
@@ -9,17 +9,14 @@
 /* web: http://www.cise.ufl.edu/research/sparse/amd                          */
 /* ------------------------------------------------------------------------- */
 
 /* User-callable AMD minimum degree ordering routine.  See amd.h for
  * documentation.
  */
 
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-
 #include "amd_internal.h"
 
 /* ========================================================================= */
 /* === AMD_order =========================================================== */
 /* ========================================================================= */
 
 GLOBAL Int AMD_order
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_post_tree.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_post_tree.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_postorder.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_postorder.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_preprocess.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_preprocess.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/amd/amd_valid.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/amd/amd_valid.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/COPYING` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/COPYING`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/README` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/README`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/colamd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/colamd.c`

 * *Files 1% similar despite different names*

```diff
@@ -26,15 +26,15 @@
         routine can be used in place of colmmd in MATLAB.
 
         Symamd computes a permutation P of a symmetric matrix A such that the
         Cholesky factorization of PAP' has less fill-in and requires fewer
         floating point operations than A.  Symamd constructs a matrix M such
         that M'M has the same nonzero pattern of A, and then orders the columns
         of M using colmmd.  The column ordering of M is then returned as the
-        row and column ordering P of A. 
+        row and column ordering P of A.
 
     Authors:
 
         The authors of the code itself are Stefan I. Larimore and Timothy A.
         Davis (davis at cise.ufl.edu), University of Florida.  The algorithm was
         developed in collaboration with John Gilbert, Xerox PARC, and Esmond
         Ng, Oak Ridge National Laboratory.
@@ -164,15 +164,15 @@
                 knobs [0] and knobs [1] control dense row and col detection:
 
                 Colamd: rows with more than
                 max (16, knobs [COLAMD_DENSE_ROW] * sqrt (n_col))
                 entries are removed prior to ordering.  Columns with more than
                 max (16, knobs [COLAMD_DENSE_COL] * sqrt (MIN (n_row,n_col)))
                 entries are removed prior to
-                ordering, and placed last in the output column ordering. 
+                ordering, and placed last in the output column ordering.
 
                 Symamd: uses only knobs [COLAMD_DENSE_ROW], which is knobs [0].
                 Rows and columns with more than
                 max (16, knobs [COLAMD_DENSE_ROW] * sqrt (n))
                 entries are removed prior to ordering, and placed last in the
                 output ordering.
 
@@ -207,15 +207,15 @@
 
         Purpose:
 
             Computes a column ordering (Q) of A such that P(AQ)=LU or
             (AQ)'AQ=LL' have less fill-in and require fewer floating point
             operations than factorizing the unpermuted matrix A or A'A,
             respectively.
-            
+
         Returns:
 
             TRUE (1) if successful, FALSE (0) otherwise.
 
         Arguments:
 
             int n_row ;         Input argument.
@@ -374,15 +374,15 @@
                         -10     (unused; see symamd.c)
 
                         -999    (unused; see symamd.c)
 
                 Future versions may return more statistics in the stats array.
 
         Example:
-        
+
             See http://www.cise.ufl.edu/research/sparse/colamd/example.c
             for a complete example.
 
             To order the columns of a 5-by-4 matrix with 11 nonzero entries in
             the following nonzero pattern
 
                 x 0 x 0
@@ -438,20 +438,20 @@
                 Number of rows and columns in the symmetrix matrix A.
                 Restriction:  n >= 0.
                 Symamd returns FALSE if n is negative.
 
             int A [nnz] ;       Input argument.
 
                 A is an integer array of size nnz, where nnz = p [n].
-                
+
                 The row indices of the entries in column c of the matrix are
                 held in A [(p [c]) ... (p [c+1]-1)].  The row indices in a
                 given column c need not be in ascending order, and duplicate
                 row indices may be present.  However, symamd will run faster
-                if the columns are in sorted order with no duplicate entries. 
+                if the columns are in sorted order with no duplicate entries.
 
                 The matrix is 0-based.  That is, rows are in the range 0 to
                 n-1, and columns are in the range 0 to n-1.  Symamd
                 returns FALSE if any row index is out of range.
 
                 The contents of A are not modified.
 
@@ -485,15 +485,15 @@
             int stats [COLAMD_STATS] ;          Output argument.
 
                 Statistics on the ordering, and error status.
                 See colamd.h for related definitions.
                 Symamd returns FALSE if stats is not present.
 
                 stats [0]:  number of dense or empty row and columns ignored
-                                (and ordered last in the output permutation 
+                                (and ordered last in the output permutation
                                 perm).  Note that a row/column can become
                                 "empty" if it contains only "dense" and/or
                                 "empty" columns/rows.
 
                 stats [1]:  (same as stats [0])
 
                 stats [2]:  number of garbage collections performed.
@@ -659,17 +659,14 @@
 
 */
 
 /* ========================================================================== */
 /* === Include files ======================================================== */
 /* ========================================================================== */
 
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-
 #include "colamd.h"
 
 #if 0 /* by mao */
 #include <limits.h>
 #include <math.h>
 
 #ifdef MATLAB_MEX_FILE
@@ -793,15 +790,15 @@
 
 #define MAX(a,b) (((a) > (b)) ? (a) : (b))
 #define MIN(a,b) (((a) < (b)) ? (a) : (b))
 
 #define ONES_COMPLEMENT(r) (-(r)-1)
 
 /* -------------------------------------------------------------------------- */
-/* Change for version 2.1:  define TRUE and FALSE only if not yet defined */  
+/* Change for version 2.1:  define TRUE and FALSE only if not yet defined */
 /* -------------------------------------------------------------------------- */
 
 #ifndef TRUE
 #define TRUE (1)
 #endif
 
 #ifndef FALSE
@@ -1110,15 +1107,15 @@
 /*
     The colamd_set_defaults routine sets the default values of the user-
     controllable parameters for colamd and symamd:
 
         Colamd: rows with more than max (16, knobs [0] * sqrt (n_col))
         entries are removed prior to ordering.  Columns with more than
         max (16, knobs [1] * sqrt (MIN (n_row,n_col))) entries are removed
-        prior to ordering, and placed last in the output column ordering. 
+        prior to ordering, and placed last in the output column ordering.
 
         Symamd: Rows and columns with more than max (16, knobs [0] * sqrt (n))
         entries are removed prior to ordering, and placed last in the
         output ordering.
 
         knobs [0]       dense row control
 
@@ -1183,15 +1180,15 @@
     Int *mark ;                 /* mark array for finding duplicate entries */
     Int *M ;                    /* row indices of matrix M */
     size_t Mlen ;               /* length of M */
     Int n_row ;                 /* number of rows in M */
     Int nnz ;                   /* number of entries in A */
     Int i ;                     /* row index of A */
     Int j ;                     /* column index of A */
-    Int k ;                     /* row index of M */ 
+    Int k ;                     /* row index of M */
     Int mnz ;                   /* number of nonzeros in M */
     Int pp ;                    /* index into a column of A */
     Int last_row ;              /* last row seen in the current column */
     Int length ;                /* number of nonzeros in a column */
 
     double cknobs [COLAMD_KNOBS] ;              /* knobs for colamd */
     double default_knobs [COLAMD_KNOBS] ;       /* default knobs for colamd */
@@ -1635,15 +1632,15 @@
     order_children (n_col, Col, p) ;
 
     /* === Return statistics in stats ======================================= */
 
     stats [COLAMD_DENSE_ROW] = n_row - n_row2 ;
     stats [COLAMD_DENSE_COL] = n_col - n_col2 ;
     stats [COLAMD_DEFRAG_COUNT] = ngarbage ;
-    DEBUG0 (("colamd: done.\n")) ; 
+    DEBUG0 (("colamd: done.\n")) ;
     return (TRUE) ;
 }
 
 
 /* ========================================================================== */
 /* === colamd_report ======================================================== */
 /* ========================================================================== */
@@ -1697,15 +1694,15 @@
 
     Int n_row,                  /* number of rows of A */
     Int n_col,                  /* number of columns of A */
     Colamd_Row Row [],          /* of size n_row+1 */
     Colamd_Col Col [],          /* of size n_col+1 */
     Int A [],                   /* row indices of A, of size Alen */
     Int p [],                   /* pointers to columns in A, of size n_col+1 */
-    Int stats [COLAMD_STATS]    /* colamd statistics */ 
+    Int stats [COLAMD_STATS]    /* colamd statistics */
 )
 {
     /* === Local variables ================================================== */
 
     Int col ;                   /* a column index */
     Int row ;                   /* a row index */
     Int *cp ;                   /* a column pointer */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/colamd/colamd.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/colamd/colamd.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 /* colamd.h */
 
 /* Written by Andrew Makhorin <mao@gnu.org>. */
 
 #ifndef COLAMD_H
 #define COLAMD_H
 
-#define _GLPSTD_STDIO
-#include "glpenv.h"
+#include "env.h"
 
 #define COLAMD_DATE "Nov 1, 2007"
 #define COLAMD_VERSION_CODE(main, sub) ((main) * 1000 + (sub))
 #define COLAMD_MAIN_VERSION 2
 #define COLAMD_SUB_VERSION 7
 #define COLAMD_SUBSUB_VERSION 1
 #define COLAMD_VERSION \
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi.h (application program interface) */
+/* prob.h (LP/MIP problem object) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,41 +15,48 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPAPI_H
-#define GLPAPI_H
-
-#define GLP_PROB_DEFINED
-typedef struct glp_prob glp_prob;
+#ifndef PROB_H
+#define PROB_H
 
+#include "avl.h"
+#include "bfd.h"
+#include "dmp.h"
+#if 1 /* 28/III-2016 */
+#define GLP_UNDOC 1
+#endif
 #include "glpk.h"
-#include "glpavl.h"
-#include "glpbfd.h"
 
 typedef struct GLPROW GLPROW;
 typedef struct GLPCOL GLPCOL;
 typedef struct GLPAIJ GLPAIJ;
 
+#if 0 /* 04/IV-2016 */
 #define GLP_PROB_MAGIC 0xD7D9D6C2
+#endif
 
 struct glp_prob
 {     /* LP/MIP problem object */
-      int magic;
+#if 0 /* 04/IV-2016 */
+      unsigned magic;
       /* magic value used for debugging */
+#endif
       DMP *pool;
       /* memory pool to store problem object components */
       glp_tree *tree;
       /* pointer to the search tree; set by the MIP solver when this
          object is used in the tree as a core MIP object */
+#if 0 /* 08/III-2014 */
       void *parms;
       /* reserved for backward compatibility */
+#endif
       /*--------------------------------------------------------------*/
       /* LP/MIP data */
       char *name;
       /* problem name (1 to 255 chars); NULL means no name is assigned
          to the problem */
       char *obj;
       /* objective function name (1 to 255 chars); NULL means no name
@@ -88,16 +92,18 @@
       int valid;
       /* the factorization is valid only if this flag is set */
       int *head; /* int head[1+m_max]; */
       /* basis header (valid only if the factorization is valid);
          head[i] = k is the ordinal number of auxiliary (1 <= k <= m)
          or structural (m+1 <= k <= m+n) variable which corresponds to
          i-th basic variable xB[i], 1 <= i <= m */
+#if 0 /* 08/III-2014 */
       glp_bfcp *bfcp;
       /* basis factorization control parameters; may be NULL */
+#endif
       BFD *bfd; /* BFD bfd[1:m,1:m]; */
       /* basis factorization driver; may be NULL */
       /*--------------------------------------------------------------*/
       /* basic solution (LP) */
       int pbs_stat;
       /* primal basic solution status:
          GLP_UNDEF  - primal solution is undefined
@@ -109,15 +115,15 @@
          GLP_UNDEF  - dual solution is undefined
          GLP_FEAS   - dual solution is feasible
          GLP_INFEAS - dual solution is infeasible
          GLP_NOFEAS - no dual feasible solution exists */
       double obj_val;
       /* objective function value */
       int it_cnt;
-      /* simplex method iteration count; increased by one on performing
+      /* simplex method iteration count; increases by one on performing
          one simplex iteration */
       int some;
       /* ordinal number of some auxiliary or structural variable having
          certain property, 0 <= some <= m+n */
       /*--------------------------------------------------------------*/
       /* interior-point solution (LP) */
       int ipt_stat;
@@ -269,46 +275,10 @@
       /* pointer to next coefficient in the same row */
       GLPAIJ *c_prev;
       /* pointer to previous coefficient in the same column */
       GLPAIJ *c_next;
       /* pointer to next coefficient in the same column */
 };
 
-void _glp_check_kkt(glp_prob *P, int sol, int cond, double *ae_max,
-      int *ae_ind, double *re_max, int *re_ind);
-/* check feasibility and optimality conditions */
-
-#define lpx_put_solution _glp_put_solution
-void lpx_put_solution(glp_prob *lp, int inval, const int *p_stat,
-      const int *d_stat, const double *obj_val, const int r_stat[],
-      const double r_prim[], const double r_dual[], const int c_stat[],
-      const double c_prim[], const double c_dual[]);
-/* store basic solution components */
-
-#define lpx_put_mip_soln _glp_put_mip_soln
-void lpx_put_mip_soln(LPX *lp, int i_stat, double row_mipx[],
-      double col_mipx[]);
-/* store mixed integer solution components */
-
-#if 1 /* 28/XI-2009 */
-int _glp_analyze_row(glp_prob *P, int len, const int ind[],
-      const double val[], int type, double rhs, double eps, int *_piv,
-      double *_x, double *_dx, double *_y, double *_dy, double *_dz);
-/* simulate one iteration of dual simplex method */
-#endif
-
-#if 1 /* 08/XII-2009 */
-void _glp_mpl_init_rand(glp_tran *tran, int seed);
-#endif
-
-#define glp_skpgen _glp_skpgen
-void glp_skpgen(int n, int r, int type, int v, int s, int a[],
-   int *b, int c[]);
-/* Pisinger's 0-1 single knapsack problem generator */
-
-#if 1 /* 28/V-2010 */
-int _glp_intopt1(glp_prob *P, const glp_iocp *parm);
-#endif
-
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob1.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi01.c (problem creating and modifying routines) */
+/* prob1.c (problem creating and modifying routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpios.h"
+#include "env.h"
+#include "ios.h"
 
 /* CAUTION: DO NOT CHANGE THE LIMITS BELOW */
 
 #define M_MAX 100000000 /* = 100*10^6 */
 /* maximal number of rows in the problem object */
 
 #define N_MAX 100000000 /* = 100*10^6 */
@@ -56,22 +49,28 @@
 *
 *  RETURNS
 *
 *  The routine returns a pointer to the object created, which should be
 *  used in any subsequent operations on this object. */
 
 static void create_prob(glp_prob *lp)
+#if 0 /* 04/IV-2016 */
 {     lp->magic = GLP_PROB_MAGIC;
+#else
+{
+#endif
       lp->pool = dmp_create_pool();
+#if 0 /* 08/III-2014 */
 #if 0 /* 17/XI-2009 */
       lp->cps = xmalloc(sizeof(struct LPXCPS));
       lpx_reset_parms(lp);
 #else
       lp->parms = NULL;
 #endif
+#endif
       lp->tree = NULL;
 #if 0
       lp->lwa = 0;
       lp->cwa = NULL;
 #endif
       /* LP/MIP data */
       lp->name = NULL;
@@ -84,15 +83,17 @@
       lp->nnz = 0;
       lp->row = xcalloc(1+lp->m_max, sizeof(GLPROW *));
       lp->col = xcalloc(1+lp->n_max, sizeof(GLPCOL *));
       lp->r_tree = lp->c_tree = NULL;
       /* basis factorization */
       lp->valid = 0;
       lp->head = xcalloc(1+lp->m_max, sizeof(int));
+#if 0 /* 08/III-2014 */
       lp->bfcp = NULL;
+#endif
       lp->bfd = NULL;
       /* basic solution (LP) */
       lp->pbs_stat = lp->dbs_stat = GLP_UNDEF;
       lp->obj_val = 0.0;
       lp->it_cnt = 0;
       lp->some = 0;
       /* interior-point solution (LP) */
@@ -1199,17 +1200,19 @@
 *  linked lists become ordered by ascending column indices, and the
 *  elements in the column linked lists become ordered by ascending row
 *  indices. */
 
 void glp_sort_matrix(glp_prob *P)
 {     GLPAIJ *aij;
       int i, j;
+#if 0 /* 04/IV-2016 */
       if (P == NULL || P->magic != GLP_PROB_MAGIC)
          xerror("glp_sort_matrix: P = %p; invalid problem object\n",
             P);
+#endif
       /* rebuild row linked lists */
       for (i = P->m; i >= 1; i--)
          P->row[i]->ptr = NULL;
       for (j = P->n; j >= 1; j--)
       {  for (aij = P->col[j]->ptr; aij != NULL; aij = aij->c_next)
          {  i = aij->row->i;
             aij->r_prev = NULL;
@@ -1538,31 +1541,39 @@
 *
 *  DESCRIPTION
 *
 *  The routine glp_delete_prob deletes the specified problem object and
 *  frees all the memory allocated to it. */
 
 static void delete_prob(glp_prob *lp)
+#if 0 /* 04/IV-2016 */
 {     lp->magic = 0x3F3F3F3F;
+#else
+{
+#endif
       dmp_delete_pool(lp->pool);
+#if 0 /* 08/III-2014 */
 #if 0 /* 17/XI-2009 */
       xfree(lp->cps);
 #else
       if (lp->parms != NULL) xfree(lp->parms);
 #endif
+#endif
       xassert(lp->tree == NULL);
 #if 0
       if (lp->cwa != NULL) xfree(lp->cwa);
 #endif
       xfree(lp->row);
       xfree(lp->col);
       if (lp->r_tree != NULL) avl_delete_tree(lp->r_tree);
       if (lp->c_tree != NULL) avl_delete_tree(lp->c_tree);
       xfree(lp->head);
+#if 0 /* 08/III-2014 */
       if (lp->bfcp != NULL) xfree(lp->bfcp);
+#endif
       if (lp->bfd != NULL) bfd_delete_it(lp->bfd);
       return;
 }
 
 void glp_delete_prob(glp_prob *lp)
 {     glp_tree *tree = lp->tree;
       if (tree != NULL && tree->reason != 0)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob2.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi02.c (problem retrieving routines) */
+/* prob2.c (problem retrieving routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,19 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#include "glpapi.h"
+#include "env.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_get_prob_name - retrieve problem name
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob3.c`

 * *Files 12% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi03.c (row and column searching routines) */
+/* prob3.c (problem row/column searching routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
+#include "env.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_create_index - create the name index
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi04.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob4.c`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi04.c (problem scaling routines) */
+/* prob4.c (problem scaling routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
+#include "env.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_set_rii - set (change) row scale factor
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi05.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/prob5.c`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi05.c (LP basis constructing routines) */
+/* prob5.c (LP problem basis constructing routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,19 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#endif
-
-#include "glpapi.h"
+#include "env.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_set_row_stat - set (change) row status
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi06.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi06.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpapi06.c (simplex method routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2007-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,21 +15,23 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wself-assign"
-#endif
-
-#include "glpios.h"
-#include "glpnpp.h"
+#include "env.h"
+#include "ios.h"
+#include "npp.h"
+#if 0 /* 07/XI-2015 */
 #include "glpspx.h"
+#else
+#include "simplex.h"
+#define spx_dual spy_dual
+#endif
 
 /***********************************************************************
 *  NAME
 *
 *  glp_simplex - solve LP problem with the simplex method
 *
 *  SYNOPSIS
@@ -363,16 +362,18 @@
 }
 
 int glp_simplex(glp_prob *P, const glp_smcp *parm)
 {     /* solve LP problem with the simplex method */
       glp_smcp _parm;
       int i, j, ret;
       /* check problem object */
+#if 0 /* 04/IV-2016 */
       if (P == NULL || P->magic != GLP_PROB_MAGIC)
          xerror("glp_simplex: P = %p; invalid problem object\n", P);
+#endif
       if (P->tree != NULL && P->tree->reason != 0)
          xerror("glp_simplex: operation not allowed\n");
       /* check control parameters */
       if (parm == NULL)
          parm = &_parm, glp_init_smcp((glp_smcp *)parm);
       if (!(parm->msg_lev == GLP_MSG_OFF ||
             parm->msg_lev == GLP_MSG_ERR ||
@@ -387,14 +388,17 @@
          xerror("glp_simplex: meth = %d; invalid parameter\n",
             parm->meth);
       if (!(parm->pricing == GLP_PT_STD ||
             parm->pricing == GLP_PT_PSE))
          xerror("glp_simplex: pricing = %d; invalid parameter\n",
             parm->pricing);
       if (!(parm->r_test == GLP_RT_STD ||
+#if 1 /* 16/III-2016 */
+            parm->r_test == GLP_RT_FLIP ||
+#endif
             parm->r_test == GLP_RT_HAR))
          xerror("glp_simplex: r_test = %d; invalid parameter\n",
             parm->r_test);
       if (!(0.0 < parm->tol_bnd && parm->tol_bnd < 1.0))
          xerror("glp_simplex: tol_bnd = %g; invalid parameter\n",
             parm->tol_bnd);
       if (!(0.0 < parm->tol_dj && parm->tol_dj < 1.0))
@@ -405,23 +409,38 @@
             parm->tol_piv);
       if (parm->it_lim < 0)
          xerror("glp_simplex: it_lim = %d; invalid parameter\n",
             parm->it_lim);
       if (parm->tm_lim < 0)
          xerror("glp_simplex: tm_lim = %d; invalid parameter\n",
             parm->tm_lim);
+#if 0 /* 15/VII-2017 */
       if (parm->out_frq < 1)
+#else
+      if (parm->out_frq < 0)
+#endif
          xerror("glp_simplex: out_frq = %d; invalid parameter\n",
             parm->out_frq);
       if (parm->out_dly < 0)
          xerror("glp_simplex: out_dly = %d; invalid parameter\n",
             parm->out_dly);
       if (!(parm->presolve == GLP_ON || parm->presolve == GLP_OFF))
          xerror("glp_simplex: presolve = %d; invalid parameter\n",
             parm->presolve);
+#if 1 /* 11/VII-2017 */
+      if (!(parm->excl == GLP_ON || parm->excl == GLP_OFF))
+         xerror("glp_simplex: excl = %d; invalid parameter\n",
+            parm->excl);
+      if (!(parm->shift == GLP_ON || parm->shift == GLP_OFF))
+         xerror("glp_simplex: shift = %d; invalid parameter\n",
+            parm->shift);
+      if (!(parm->aorn == GLP_USE_AT || parm->aorn == GLP_USE_NT))
+         xerror("glp_simplex: aorn = %d; invalid parameter\n",
+            parm->aorn);
+#endif
       /* basic solution is currently undefined */
       P->pbs_stat = P->dbs_stat = GLP_UNDEF;
       P->obj_val = 0.0;
       P->some = 0;
       /* check bounds of double-bounded variables */
       for (i = 1; i <= P->m; i++)
       {  GLPROW *row = P->row[i];
@@ -441,15 +460,15 @@
                   "rect bounds\n", j, col->lb, col->ub);
             ret = GLP_EBOUND;
             goto done;
          }
       }
       /* solve LP problem */
       if (parm->msg_lev >= GLP_MSG_ALL)
-      {  xprintf("GLPK Simplex Optimizer, v%s\n", glp_version());
+      {  xprintf("GLPK Simplex Optimizer %s\n", glp_version());
          xprintf("%d row%s, %d column%s, %d non-zero%s\n",
             P->m, P->m == 1 ? "" : "s", P->n, P->n == 1 ? "" : "s",
             P->nnz, P->nnz == 1 ? "" : "s");
       }
       if (P->nnz == 0)
          trivial_lp(P, parm), ret = 0;
       else if (!parm->presolve)
@@ -480,22 +499,35 @@
 void glp_init_smcp(glp_smcp *parm)
 {     parm->msg_lev = GLP_MSG_ALL;
       parm->meth = GLP_PRIMAL;
       parm->pricing = GLP_PT_PSE;
       parm->r_test = GLP_RT_HAR;
       parm->tol_bnd = 1e-7;
       parm->tol_dj = 1e-7;
+#if 0 /* 07/XI-2015 */
       parm->tol_piv = 1e-10;
+#else
+      parm->tol_piv = 1e-9;
+#endif
       parm->obj_ll = -DBL_MAX;
       parm->obj_ul = +DBL_MAX;
       parm->it_lim = INT_MAX;
       parm->tm_lim = INT_MAX;
+#if 0 /* 15/VII-2017 */
       parm->out_frq = 500;
+#else
+      parm->out_frq = 5000; /* 5 seconds */
+#endif
       parm->out_dly = 0;
       parm->presolve = GLP_OFF;
+#if 1 /* 11/VII-2017 */
+      parm->excl = GLP_ON;
+      parm->shift = GLP_ON;
+      parm->aorn = GLP_USE_NT;
+#endif
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  glp_get_status - retrieve generic status of basic solution
@@ -803,8 +835,23 @@
 {     int k;
       k = lp->some;
       xassert(k >= 0);
       if (k > lp->m + lp->n) k = 0;
       return k;
 }
 
+#if 1 /* 08/VIII-2013 */
+int glp_get_it_cnt(glp_prob *P)
+{     /* get simplex solver iteration count */
+      return P->it_cnt;
+}
+#endif
+
+#if 1 /* 08/VIII-2013 */
+void glp_set_it_cnt(glp_prob *P, int it_cnt)
+{     /* set simplex solver iteration count */
+      P->it_cnt = it_cnt;
+      return;
+}
+#endif
+
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi07.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi07.c`

 * *Files 13% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpapi07.c (exact simplex solver) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2007-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,16 +15,18 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
+#include "draft.h"
 #include "glpssx.h"
+#include "misc.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_exact - solve LP problem in exact arithmetic
 *
 *  SYNOPSIS
@@ -122,117 +121,117 @@
       mpq_clear(temp);
       if (s < 0) mpq_neg(x, x);
       /* check that the desired tolerance has been attained */
       xassert(fabs(val - mpq_get_d(x)) <= eps * (1.0 + fabs(val)));
 done: return;
 }
 
-static void load_data(SSX *ssx, LPX *lp)
+static void load_data(SSX *ssx, glp_prob *lp)
 {     /* load LP problem data into simplex solver workspace */
       int m = ssx->m;
       int n = ssx->n;
       int nnz = ssx->A_ptr[n+1]-1;
       int j, k, type, loc, len, *ind;
       double lb, ub, coef, *val;
-      xassert(lpx_get_num_rows(lp) == m);
-      xassert(lpx_get_num_cols(lp) == n);
-      xassert(lpx_get_num_nz(lp) == nnz);
+      xassert(lp->m == m);
+      xassert(lp->n == n);
+      xassert(lp->nnz == nnz);
       /* types and bounds of rows and columns */
       for (k = 1; k <= m+n; k++)
       {  if (k <= m)
-         {  type = lpx_get_row_type(lp, k);
-            lb = lpx_get_row_lb(lp, k);
-            ub = lpx_get_row_ub(lp, k);
+         {  type = lp->row[k]->type;
+            lb = lp->row[k]->lb;
+            ub = lp->row[k]->ub;
          }
          else
-         {  type = lpx_get_col_type(lp, k-m);
-            lb = lpx_get_col_lb(lp, k-m);
-            ub = lpx_get_col_ub(lp, k-m);
+         {  type = lp->col[k-m]->type;
+            lb = lp->col[k-m]->lb;
+            ub = lp->col[k-m]->ub;
          }
          switch (type)
-         {  case LPX_FR: type = SSX_FR; break;
-            case LPX_LO: type = SSX_LO; break;
-            case LPX_UP: type = SSX_UP; break;
-            case LPX_DB: type = SSX_DB; break;
-            case LPX_FX: type = SSX_FX; break;
+         {  case GLP_FR: type = SSX_FR; break;
+            case GLP_LO: type = SSX_LO; break;
+            case GLP_UP: type = SSX_UP; break;
+            case GLP_DB: type = SSX_DB; break;
+            case GLP_FX: type = SSX_FX; break;
             default: xassert(type != type);
          }
          ssx->type[k] = type;
          set_d_eps(ssx->lb[k], lb);
          set_d_eps(ssx->ub[k], ub);
       }
       /* optimization direction */
-      switch (lpx_get_obj_dir(lp))
-      {  case LPX_MIN: ssx->dir = SSX_MIN; break;
-         case LPX_MAX: ssx->dir = SSX_MAX; break;
+      switch (lp->dir)
+      {  case GLP_MIN: ssx->dir = SSX_MIN; break;
+         case GLP_MAX: ssx->dir = SSX_MAX; break;
          default: xassert(lp != lp);
       }
       /* objective coefficients */
       for (k = 0; k <= m+n; k++)
       {  if (k == 0)
-            coef = lpx_get_obj_coef(lp, 0);
+            coef = lp->c0;
          else if (k <= m)
             coef = 0.0;
          else
-            coef = lpx_get_obj_coef(lp, k-m);
+            coef = lp->col[k-m]->coef;
          set_d_eps(ssx->coef[k], coef);
       }
       /* constraint coefficients */
       ind = xcalloc(1+m, sizeof(int));
       val = xcalloc(1+m, sizeof(double));
       loc = 0;
       for (j = 1; j <= n; j++)
       {  ssx->A_ptr[j] = loc+1;
-         len = lpx_get_mat_col(lp, j, ind, val);
+         len = glp_get_mat_col(lp, j, ind, val);
          for (k = 1; k <= len; k++)
          {  loc++;
             ssx->A_ind[loc] = ind[k];
             set_d_eps(ssx->A_val[loc], val[k]);
          }
       }
       xassert(loc == nnz);
       xfree(ind);
       xfree(val);
       return;
 }
 
-static int load_basis(SSX *ssx, LPX *lp)
+static int load_basis(SSX *ssx, glp_prob *lp)
 {     /* load current LP basis into simplex solver workspace */
       int m = ssx->m;
       int n = ssx->n;
       int *type = ssx->type;
       int *stat = ssx->stat;
       int *Q_row = ssx->Q_row;
       int *Q_col = ssx->Q_col;
       int i, j, k;
-      xassert(lpx_get_num_rows(lp) == m);
-      xassert(lpx_get_num_cols(lp) == n);
+      xassert(lp->m == m);
+      xassert(lp->n == n);
       /* statuses of rows and columns */
       for (k = 1; k <= m+n; k++)
       {  if (k <= m)
-            stat[k] = lpx_get_row_stat(lp, k);
+            stat[k] = lp->row[k]->stat;
          else
-            stat[k] = lpx_get_col_stat(lp, k-m);
+            stat[k] = lp->col[k-m]->stat;
          switch (stat[k])
-         {  case LPX_BS:
+         {  case GLP_BS:
                stat[k] = SSX_BS;
                break;
-            case LPX_NL:
+            case GLP_NL:
                stat[k] = SSX_NL;
                xassert(type[k] == SSX_LO || type[k] == SSX_DB);
                break;
-            case LPX_NU:
+            case GLP_NU:
                stat[k] = SSX_NU;
                xassert(type[k] == SSX_UP || type[k] == SSX_DB);
                break;
-            case LPX_NF:
+            case GLP_NF:
                stat[k] = SSX_NF;
                xassert(type[k] == SSX_FR);
                break;
-            case LPX_NS:
+            case GLP_NS:
                stat[k] = SSX_NS;
                xassert(type[k] == SSX_FX);
                break;
             default:
                xassert(stat != stat);
          }
       }
@@ -253,199 +252,245 @@
       xassert(i == m && j == n);
       return 0;
 }
 
 int glp_exact(glp_prob *lp, const glp_smcp *parm)
 {     glp_smcp _parm;
       SSX *ssx;
-      int m = lpx_get_num_rows(lp);
-      int n = lpx_get_num_cols(lp);
-      int nnz = lpx_get_num_nz(lp);
-      int i, j, k, type, pst, dst, ret, *stat;
-      double lb, ub, *prim, *dual, sum;
+      int m = lp->m;
+      int n = lp->n;
+      int nnz = lp->nnz;
+      int i, j, k, type, pst, dst, ret, stat;
+      double lb, ub, prim, dual, sum;
       if (parm == NULL)
          parm = &_parm, glp_init_smcp((glp_smcp *)parm);
       /* check control parameters */
+#if 1 /* 25/XI-2017 */
+      switch (parm->msg_lev)
+      {  case GLP_MSG_OFF:
+         case GLP_MSG_ERR:
+         case GLP_MSG_ON:
+         case GLP_MSG_ALL:
+         case GLP_MSG_DBG:
+            break;
+         default:
+            xerror("glp_exact: msg_lev = %d; invalid parameter\n",
+               parm->msg_lev);
+      }
+#endif
       if (parm->it_lim < 0)
          xerror("glp_exact: it_lim = %d; invalid parameter\n",
             parm->it_lim);
       if (parm->tm_lim < 0)
          xerror("glp_exact: tm_lim = %d; invalid parameter\n",
             parm->tm_lim);
       /* the problem must have at least one row and one column */
       if (!(m > 0 && n > 0))
+#if 0 /* 25/XI-2017 */
       {  xprintf("glp_exact: problem has no rows/columns\n");
+#else
+      {  if (parm->msg_lev >= GLP_MSG_ERR)
+            xprintf("glp_exact: problem has no rows/columns\n");
+#endif
          return GLP_EFAIL;
       }
 #if 1
       /* basic solution is currently undefined */
       lp->pbs_stat = lp->dbs_stat = GLP_UNDEF;
       lp->obj_val = 0.0;
       lp->some = 0;
 #endif
       /* check that all double-bounded variables have correct bounds */
       for (k = 1; k <= m+n; k++)
       {  if (k <= m)
-         {  type = lpx_get_row_type(lp, k);
-            lb = lpx_get_row_lb(lp, k);
-            ub = lpx_get_row_ub(lp, k);
+         {  type = lp->row[k]->type;
+            lb = lp->row[k]->lb;
+            ub = lp->row[k]->ub;
          }
          else
-         {  type = lpx_get_col_type(lp, k-m);
-            lb = lpx_get_col_lb(lp, k-m);
-            ub = lpx_get_col_ub(lp, k-m);
+         {  type = lp->col[k-m]->type;
+            lb = lp->col[k-m]->lb;
+            ub = lp->col[k-m]->ub;
          }
-         if (type == LPX_DB && lb >= ub)
+         if (type == GLP_DB && lb >= ub)
+#if 0 /* 25/XI-2017 */
          {  xprintf("glp_exact: %s %d has invalid bounds\n",
                k <= m ? "row" : "column", k <= m ? k : k-m);
+#else
+         {  if (parm->msg_lev >= GLP_MSG_ERR)
+               xprintf("glp_exact: %s %d has invalid bounds\n",
+                  k <= m ? "row" : "column", k <= m ? k : k-m);
+#endif
             return GLP_EBOUND;
          }
       }
       /* create the simplex solver workspace */
+#if 1 /* 25/XI-2017 */
+      if (parm->msg_lev >= GLP_MSG_ALL)
+      {
+#endif
       xprintf("glp_exact: %d rows, %d columns, %d non-zeros\n",
          m, n, nnz);
 #ifdef HAVE_GMP
       xprintf("GNU MP bignum library is being used\n");
 #else
       xprintf("GLPK bignum module is being used\n");
       xprintf("(Consider installing GNU MP to attain a much better perf"
          "ormance.)\n");
 #endif
+#if 1 /* 25/XI-2017 */
+      }
+#endif
       ssx = ssx_create(m, n, nnz);
       /* load LP problem data into the workspace */
       load_data(ssx, lp);
       /* load current LP basis into the workspace */
       if (load_basis(ssx, lp))
+#if 0 /* 25/XI-2017 */
       {  xprintf("glp_exact: initial LP basis is invalid\n");
+#else
+      {  if (parm->msg_lev >= GLP_MSG_ERR)
+            xprintf("glp_exact: initial LP basis is invalid\n");
+#endif
          ret = GLP_EBADB;
          goto done;
       }
-      /* inherit some control parameters from the LP object */
 #if 0
+      /* inherit some control parameters from the LP object */
       ssx->it_lim = lpx_get_int_parm(lp, LPX_K_ITLIM);
       ssx->it_cnt = lpx_get_int_parm(lp, LPX_K_ITCNT);
       ssx->tm_lim = lpx_get_real_parm(lp, LPX_K_TMLIM);
 #else
+#if 1 /* 25/XI-2017 */
+      ssx->msg_lev = parm->msg_lev;
+#endif
       ssx->it_lim = parm->it_lim;
       ssx->it_cnt = lp->it_cnt;
       ssx->tm_lim = (double)parm->tm_lim / 1000.0;
 #endif
       ssx->out_frq = 5.0;
       ssx->tm_beg = xtime();
+#if 0 /* 10/VI-2013 */
       ssx->tm_lag = xlset(0);
+#else
+      ssx->tm_lag = 0.0;
+#endif
       /* solve LP */
       ret = ssx_driver(ssx);
-      /* copy back some statistics to the LP object */
 #if 0
+      /* copy back some statistics to the LP object */
       lpx_set_int_parm(lp, LPX_K_ITLIM, ssx->it_lim);
       lpx_set_int_parm(lp, LPX_K_ITCNT, ssx->it_cnt);
       lpx_set_real_parm(lp, LPX_K_TMLIM, ssx->tm_lim);
 #else
       lp->it_cnt = ssx->it_cnt;
 #endif
       /* analyze the return code */
       switch (ret)
       {  case 0:
             /* optimal solution found */
             ret = 0;
-            pst = LPX_P_FEAS, dst = LPX_D_FEAS;
+            pst = dst = GLP_FEAS;
             break;
          case 1:
             /* problem has no feasible solution */
             ret = 0;
-            pst = LPX_P_NOFEAS, dst = LPX_D_INFEAS;
+            pst = GLP_NOFEAS, dst = GLP_INFEAS;
             break;
          case 2:
             /* problem has unbounded solution */
             ret = 0;
-            pst = LPX_P_FEAS, dst = LPX_D_NOFEAS;
+            pst = GLP_FEAS, dst = GLP_NOFEAS;
 #if 1
             xassert(1 <= ssx->q && ssx->q <= n);
             lp->some = ssx->Q_col[m + ssx->q];
             xassert(1 <= lp->some && lp->some <= m+n);
 #endif
             break;
          case 3:
             /* iteration limit exceeded (phase I) */
             ret = GLP_EITLIM;
-            pst = LPX_P_INFEAS, dst = LPX_D_INFEAS;
+            pst = dst = GLP_INFEAS;
             break;
          case 4:
             /* iteration limit exceeded (phase II) */
             ret = GLP_EITLIM;
-            pst = LPX_P_FEAS, dst = LPX_D_INFEAS;
+            pst = GLP_FEAS, dst = GLP_INFEAS;
             break;
          case 5:
             /* time limit exceeded (phase I) */
             ret = GLP_ETMLIM;
-            pst = LPX_P_INFEAS, dst = LPX_D_INFEAS;
+            pst = dst = GLP_INFEAS;
             break;
          case 6:
             /* time limit exceeded (phase II) */
             ret = GLP_ETMLIM;
-            pst = LPX_P_FEAS, dst = LPX_D_INFEAS;
+            pst = GLP_FEAS, dst = GLP_INFEAS;
             break;
          case 7:
             /* initial basis matrix is singular */
             ret = GLP_ESING;
             goto done;
          default:
             xassert(ret != ret);
       }
-      /* obtain final basic solution components */
-      stat = xcalloc(1+m+n, sizeof(int));
-      prim = xcalloc(1+m+n, sizeof(double));
-      dual = xcalloc(1+m+n, sizeof(double));
+      /* store final basic solution components into LP object */
+      lp->pbs_stat = pst;
+      lp->dbs_stat = dst;
+      sum = lp->c0;
       for (k = 1; k <= m+n; k++)
       {  if (ssx->stat[k] == SSX_BS)
          {  i = ssx->Q_row[k]; /* x[k] = xB[i] */
             xassert(1 <= i && i <= m);
-            stat[k] = LPX_BS;
-            prim[k] = mpq_get_d(ssx->bbar[i]);
-            dual[k] = 0.0;
+            stat = GLP_BS;
+            prim = mpq_get_d(ssx->bbar[i]);
+            dual = 0.0;
          }
          else
          {  j = ssx->Q_row[k] - m; /* x[k] = xN[j] */
             xassert(1 <= j && j <= n);
             switch (ssx->stat[k])
             {  case SSX_NF:
-                  stat[k] = LPX_NF;
-                  prim[k] = 0.0;
+                  stat = GLP_NF;
+                  prim = 0.0;
                   break;
                case SSX_NL:
-                  stat[k] = LPX_NL;
-                  prim[k] = mpq_get_d(ssx->lb[k]);
+                  stat = GLP_NL;
+                  prim = mpq_get_d(ssx->lb[k]);
                   break;
                case SSX_NU:
-                  stat[k] = LPX_NU;
-                  prim[k] = mpq_get_d(ssx->ub[k]);
+                  stat = GLP_NU;
+                  prim = mpq_get_d(ssx->ub[k]);
                   break;
                case SSX_NS:
-                  stat[k] = LPX_NS;
-                  prim[k] = mpq_get_d(ssx->lb[k]);
+                  stat = GLP_NS;
+                  prim = mpq_get_d(ssx->lb[k]);
                   break;
                default:
                   xassert(ssx != ssx);
             }
-            dual[k] = mpq_get_d(ssx->cbar[j]);
+            dual = mpq_get_d(ssx->cbar[j]);
+         }
+         if (k <= m)
+         {  glp_set_row_stat(lp, k, stat);
+            lp->row[k]->prim = prim;
+            lp->row[k]->dual = dual;
+         }
+         else
+         {  glp_set_col_stat(lp, k-m, stat);
+            lp->col[k-m]->prim = prim;
+            lp->col[k-m]->dual = dual;
+            sum += lp->col[k-m]->coef * prim;
          }
       }
-      /* and store them into the LP object */
-      pst = pst - LPX_P_UNDEF + GLP_UNDEF;
-      dst = dst - LPX_D_UNDEF + GLP_UNDEF;
-      for (k = 1; k <= m+n; k++)
-         stat[k] = stat[k] - LPX_BS + GLP_BS;
-      sum = lpx_get_obj_coef(lp, 0);
-      for (j = 1; j <= n; j++)
-         sum += lpx_get_obj_coef(lp, j) * prim[m+j];
-      lpx_put_solution(lp, 1, &pst, &dst, &sum,
-         &stat[0], &prim[0], &dual[0], &stat[m], &prim[m], &dual[m]);
-      xfree(stat);
-      xfree(prim);
-      xfree(dual);
+      lp->obj_val = sum;
 done: /* delete the simplex solver workspace */
       ssx_delete(ssx);
+#if 1 /* 23/XI-2015 */
+      xassert(gmp_pool_count() == 0);
+      gmp_free_mem();
+#endif
       /* return to the application program */
       return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi08.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi08.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpapi08.c (interior-point method routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,17 +15,17 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
+#include "env.h"
 #include "glpipm.h"
-#include "glpnpp.h"
+#include "npp.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_interior - solve LP problem with the interior-point method
 *
 *  SYNOPSIS
@@ -363,15 +360,14 @@
 /***********************************************************************
 *  NAME
 *
 *  glp_ipt_col_dual - retrieve column dual value (interior point)
 *
 *  SYNOPSIS
 *
-*  #include "glplpx.h"
 *  double glp_ipt_col_dual(glp_prob *lp, int j);
 *
 *  RETURNS
 *
 *  The routine glp_ipt_col_dual returns dual value (i.e. reduced cost)
 *  of the structural variable associated with j-th column. */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi09.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi09.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpapi09.c (mixed integer programming routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,16 +15,18 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpios.h"
-#include "glpnpp.h"
+#include "draft.h"
+#include "env.h"
+#include "ios.h"
+#include "npp.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_set_col_kind - set (change) column kind
 *
 *  SYNOPSIS
@@ -213,15 +212,21 @@
 *  GLP_ENODFS
 *     LP relaxation of the MIP problem instance has no dual feasible
 *     solution (only if the MIP presolver is used).
 *
 *  GLP_ESTOP
 *     The search was prematurely terminated by application. */
 
+#if 0 /* 11/VII-2013 */
 static int solve_mip(glp_prob *P, const glp_iocp *parm)
+#else
+static int solve_mip(glp_prob *P, const glp_iocp *parm,
+      glp_prob *P0 /* problem passed to glp_intopt */,
+      NPP *npp /* preprocessor workspace or NULL */)
+#endif
 {     /* solve MIP directly without using the preprocessor */
       glp_tree *T;
       int ret;
       /* optimal basis to LP relaxation must be provided */
       if (glp_get_status(P) != GLP_OPT)
       {  if (parm->msg_lev >= GLP_MSG_ERR)
             xprintf("glp_intopt: optimal basis to initial LP relaxation"
@@ -230,14 +235,18 @@
          goto done;
       }
       /* it seems all is ok */
       if (parm->msg_lev >= GLP_MSG_ALL)
          xprintf("Integer optimization begins...\n");
       /* create the branch-and-bound tree */
       T = ios_create_tree(P, parm);
+#if 1 /* 11/VII-2013 */
+      T->P = P0;
+      T->npp = npp;
+#endif
       /* solve the problem instance */
       ret = ios_driver(T);
       /* delete the branch-and-bound tree */
       ios_delete_tree(T);
       /* analyze exit code reported by the mip driver */
       if (ret == 0)
       {  if (P->mip_stat == GLP_FEAS)
@@ -363,18 +372,22 @@
       glp_adv_basis(mip, 0);
       env->term_out = term_out;
       /* solve initial LP relaxation */
       if (parm->msg_lev >= GLP_MSG_ALL)
          xprintf("Solving LP relaxation...\n");
       glp_init_smcp(&smcp);
       smcp.msg_lev = parm->msg_lev;
+      /* respect time limit */
+      smcp.tm_lim = parm->tm_lim;
       mip->it_cnt = P->it_cnt;
       ret = glp_simplex(mip, &smcp);
       P->it_cnt = mip->it_cnt;
-      if (ret != 0)
+      if (ret == GLP_ETMLIM)
+         goto done;
+      else if (ret != 0)
       {  if (parm->msg_lev >= GLP_MSG_ERR)
             xprintf("glp_intopt: cannot solve LP relaxation\n");
          ret = GLP_EFAIL;
          goto done;
       }
       /* check status of the basic solution */
       ret = glp_get_status(mip);
@@ -385,15 +398,23 @@
       else if (ret == GLP_UNBND)
          ret = GLP_ENODFS;
       else
          xassert(ret != ret);
       if (ret != 0) goto done;
       /* solve the transformed MIP */
       mip->it_cnt = P->it_cnt;
+#if 0 /* 11/VII-2013 */
       ret = solve_mip(mip, parm);
+#else
+      if (parm->use_sol)
+      {  mip->mip_stat = P->mip_stat;
+         mip->mip_obj = P->mip_obj;
+      }
+      ret = solve_mip(mip, parm, P, npp);
+#endif
       P->it_cnt = mip->it_cnt;
       /* only integer feasible solution can be postprocessed */
       if (!(mip->mip_stat == GLP_OPT || mip->mip_stat == GLP_FEAS))
       {  P->mip_stat = mip->mip_stat;
          goto done;
       }
       /* postprocess solution from the transformed MIP */
@@ -418,17 +439,19 @@
 }
 #endif
 
 int glp_intopt(glp_prob *P, const glp_iocp *parm)
 {     /* solve MIP problem with the branch-and-bound method */
       glp_iocp _parm;
       int i, j, ret;
+#if 0 /* 04/IV-2016 */
       /* check problem object */
       if (P == NULL || P->magic != GLP_PROB_MAGIC)
          xerror("glp_intopt: P = %p; invalid problem object\n", P);
+#endif
       if (P->tree != NULL)
          xerror("glp_intopt: operation not allowed\n");
       /* check control parameters */
       if (parm == NULL)
          parm = &_parm, glp_init_iocp((glp_iocp *)parm);
       if (!(parm->msg_lev == GLP_MSG_OFF ||
             parm->msg_lev == GLP_MSG_ERR ||
@@ -498,17 +521,28 @@
          xerror("glp_intopt: fp_heur = %d; invalid parameter\n",
             parm->fp_heur);
 #if 1 /* 28/V-2010 */
       if (!(parm->alien == GLP_ON || parm->alien == GLP_OFF))
          xerror("glp_intopt: alien = %d; invalid parameter\n",
             parm->alien);
 #endif
+#if 0 /* 11/VII-2013 */
       /* integer solution is currently undefined */
       P->mip_stat = GLP_UNDEF;
       P->mip_obj = 0.0;
+#else
+      if (!parm->use_sol)
+         P->mip_stat = GLP_UNDEF;
+      if (P->mip_stat == GLP_NOFEAS)
+         P->mip_stat = GLP_UNDEF;
+      if (P->mip_stat == GLP_UNDEF)
+         P->mip_obj = 0.0;
+      else if (P->mip_stat == GLP_OPT)
+         P->mip_stat = GLP_FEAS;
+#endif
       /* check bounds of double-bounded variables */
       for (i = 1; i <= P->m; i++)
       {  GLPROW *row = P->row[i];
          if (row->type == GLP_DB && row->lb >= row->ub)
          {  if (parm->msg_lev >= GLP_MSG_ERR)
                xprintf("glp_intopt: row %d: lb = %g, ub = %g; incorrect"
                   " bounds\n", i, row->lb, row->ub);
@@ -559,15 +593,15 @@
          }
       }
       /* solve MIP problem */
       if (parm->msg_lev >= GLP_MSG_ALL)
       {  int ni = glp_get_num_int(P);
          int nb = glp_get_num_bin(P);
          char s[50];
-         xprintf("GLPK Integer Optimizer, v%s\n", glp_version());
+         xprintf("GLPK Integer Optimizer %s\n", glp_version());
          xprintf("%d row%s, %d column%s, %d non-zero%s\n",
             P->m, P->m == 1 ? "" : "s", P->n, P->n == 1 ? "" : "s",
             P->nnz, P->nnz == 1 ? "" : "s");
          if (nb == 0)
             strcpy(s, "none of");
          else if (ni == 1 && nb == 1)
             strcpy(s, "");
@@ -584,17 +618,25 @@
       if (parm->alien)
       {  /* use alien integer optimizer */
          ret = _glp_intopt1(P, parm);
          goto done;
       }
 #endif
       if (!parm->presolve)
+#if 0 /* 11/VII-2013 */
          ret = solve_mip(P, parm);
+#else
+         ret = solve_mip(P, parm, P, NULL);
+#endif
       else
          ret = preprocess_and_solve_mip(P, parm);
+#if 1 /* 12/III-2013 */
+      if (ret == GLP_ENOPFS)
+         P->mip_stat = GLP_NOFEAS;
+#endif
 done: /* return to the application program */
       return ret;
 }
 
 /***********************************************************************
 *  NAME
 *
@@ -629,17 +671,29 @@
       parm->mir_cuts = GLP_OFF;
       parm->gmi_cuts = GLP_OFF;
       parm->cov_cuts = GLP_OFF;
       parm->clq_cuts = GLP_OFF;
       parm->presolve = GLP_OFF;
       parm->binarize = GLP_OFF;
       parm->fp_heur = GLP_OFF;
-#if 1 /* 28/V-2010 */
+      parm->ps_heur = GLP_OFF;
+      parm->ps_tm_lim = 60000; /* 1 minute */
+      parm->sr_heur = GLP_ON;
+#if 1 /* 24/X-2015; not documented--should not be used */
+      parm->use_sol = GLP_OFF;
+      parm->save_sol = NULL;
       parm->alien = GLP_OFF;
 #endif
+#if 0 /* 20/I-2018 */
+#if 1 /* 16/III-2016; not documented--should not be used */
+      parm->flip = GLP_OFF;
+#endif
+#else
+      parm->flip = GLP_ON;
+#endif
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  glp_mip_status - retrieve status of MIP solution
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi10.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi10.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpapi10.c (solution checking routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,17 +15,18 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
+#include "env.h"
+#include "prob.h"
 
-void _glp_check_kkt(glp_prob *P, int sol, int cond, double *_ae_max,
+void glp_check_kkt(glp_prob *P, int sol, int cond, double *_ae_max,
       int *_ae_ind, double *_re_max, int *_re_ind)
 {     /* check feasibility and optimality conditions */
       int m = P->m;
       int n = P->n;
       GLPROW *row;
       GLPCOL *col;
       GLPAIJ *aij;
@@ -215,23 +213,35 @@
             if (P->dir == GLP_MIN)
                t = + t;
             else if (P->dir == GLP_MAX)
                t = - t;
             else
                xassert(P != P);
             /* check for positivity */
+#if 1 /* 08/III-2013 */
+            /* the former check was correct */
+            /* the bug reported by David Price is related to violation
+               of complementarity slackness, not to this condition */
             if (row->type == GLP_FR || row->type == GLP_LO)
+#else
+            if (row->stat == GLP_NF || row->stat == GLP_NL)
+#endif
             {  if (t < 0.0)
                {  e = - t;
                   if (ae_max < e)
                      ae_max = re_max = e, ae_ind = re_ind = i;
                }
             }
             /* check for negativity */
+#if 1 /* 08/III-2013 */
+            /* see comment above */
             if (row->type == GLP_FR || row->type == GLP_UP)
+#else
+            if (row->stat == GLP_NF || row->stat == GLP_NU)
+#endif
             {  if (t > 0.0)
                {  e = + t;
                   if (ae_max < e)
                      ae_max = re_max = e, ae_ind = re_ind = i;
                }
             }
          }
@@ -249,23 +259,33 @@
             if (P->dir == GLP_MIN)
                t = + t;
             else if (P->dir == GLP_MAX)
                t = - t;
             else
                xassert(P != P);
             /* check for positivity */
+#if 1 /* 08/III-2013 */
+            /* see comment above */
             if (col->type == GLP_FR || col->type == GLP_LO)
+#else
+            if (col->stat == GLP_NF || col->stat == GLP_NL)
+#endif
             {  if (t < 0.0)
                {  e = - t;
                   if (ae_max < e)
                      ae_max = re_max = e, ae_ind = re_ind = m+j;
                }
             }
             /* check for negativity */
+#if 1 /* 08/III-2013 */
+            /* see comment above */
             if (col->type == GLP_FR || col->type == GLP_UP)
+#else
+            if (col->stat == GLP_NF || col->stat == GLP_NU)
+#endif
             {  if (t > 0.0)
                {  e = + t;
                   if (ae_max < e)
                      ae_max = re_max = e, ae_ind = re_ind = m+j;
                }
             }
          }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi12.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi12.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpapi12.c (basis factorization and simplex tableau routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,17 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#include "glpapi.h"
+#include "draft.h"
+#include "env.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_bf_exists - check if the basis factorization exists
 *
 *  SYNOPSIS
@@ -105,16 +99,14 @@
             ind[len] = aij->row->i;
             val[len] = - aij->row->rii * aij->val * aij->col->sjj;
          }
       }
       return len;
 }
 
-static void copy_bfcp(glp_prob *lp);
-
 int glp_factorize(glp_prob *lp)
 {     int m = lp->m;
       int n = lp->n;
       GLPROW **row = lp->row;
       GLPCOL **col = lp->col;
       int *head = lp->head;
       int j, k, stat, ret;
@@ -150,17 +142,19 @@
          ret = GLP_EBADB;
          goto fini;
       }
       /* try to factorize the basis matrix */
       if (m > 0)
       {  if (lp->bfd == NULL)
          {  lp->bfd = bfd_create_it();
+#if 0 /* 08/III-2014 */
             copy_bfcp(lp);
+#endif
          }
-         switch (bfd_factorize(lp->bfd, m, lp->head, b_col, lp))
+         switch (bfd_factorize(lp->bfd, m, /*lp->head,*/ b_col, lp))
          {  case 0:
                /* ok */
                break;
             case BFD_ESING:
                /* singular matrix */
                ret = GLP_ESING;
                goto fini;
@@ -220,33 +214,22 @@
 *  The routine glp_get_bfcp retrieves control parameters, which are
 *  used on computing and updating the basis factorization associated
 *  with the specified problem object.
 *
 *  Current values of control parameters are stored by the routine in
 *  a glp_bfcp structure, which the parameter parm points to. */
 
-void glp_get_bfcp(glp_prob *lp, glp_bfcp *parm)
-{     glp_bfcp *bfcp = lp->bfcp;
-      if (bfcp == NULL)
-      {  parm->type = GLP_BF_FT;
-         parm->lu_size = 0;
-         parm->piv_tol = 0.10;
-         parm->piv_lim = 4;
-         parm->suhl = GLP_ON;
-         parm->eps_tol = 1e-15;
-         parm->max_gro = 1e+10;
-         parm->nfs_max = 100;
-         parm->upd_tol = 1e-6;
-         parm->nrs_max = 100;
-         parm->rs_size = 0;
-      }
-      else
-         memcpy(parm, bfcp, sizeof(glp_bfcp));
+#if 1 /* 08/III-2014 */
+void glp_get_bfcp(glp_prob *P, glp_bfcp *parm)
+{     if (P->bfd == NULL)
+         P->bfd = bfd_create_it();
+      bfd_get_bfcp(P->bfd, parm);
       return;
 }
+#endif
 
 /***********************************************************************
 *  NAME
 *
 *  glp_set_bfcp - change basis factorization control parameters
 *
 *  SYNOPSIS
@@ -261,94 +244,49 @@
 *
 *  New values of the control parameters should be passed in a structure
 *  glp_bfcp, which the parameter parm points to.
 *
 *  The parameter parm can be specified as NULL, in which case all
 *  control parameters are reset to their default values. */
 
-#if 0 /* 15/XI-2009 */
-static void copy_bfcp(glp_prob *lp)
-{     glp_bfcp _parm, *parm = &_parm;
-      BFD *bfd = lp->bfd;
-      glp_get_bfcp(lp, parm);
-      xassert(bfd != NULL);
-      bfd->type = parm->type;
-      bfd->lu_size = parm->lu_size;
-      bfd->piv_tol = parm->piv_tol;
-      bfd->piv_lim = parm->piv_lim;
-      bfd->suhl = parm->suhl;
-      bfd->eps_tol = parm->eps_tol;
-      bfd->max_gro = parm->max_gro;
-      bfd->nfs_max = parm->nfs_max;
-      bfd->upd_tol = parm->upd_tol;
-      bfd->nrs_max = parm->nrs_max;
-      bfd->rs_size = parm->rs_size;
-      return;
-}
-#else
-static void copy_bfcp(glp_prob *lp)
-{     glp_bfcp _parm, *parm = &_parm;
-      glp_get_bfcp(lp, parm);
-      bfd_set_parm(lp->bfd, parm);
-      return;
-}
-#endif
-
-void glp_set_bfcp(glp_prob *lp, const glp_bfcp *parm)
-{     glp_bfcp *bfcp = lp->bfcp;
-      if (parm == NULL)
-      {  /* reset to default values */
-         if (bfcp != NULL)
-            xfree(bfcp), lp->bfcp = NULL;
-      }
-      else
-      {  /* set to specified values */
-         if (bfcp == NULL)
-            bfcp = lp->bfcp = xmalloc(sizeof(glp_bfcp));
-         memcpy(bfcp, parm, sizeof(glp_bfcp));
-         if (!(bfcp->type == GLP_BF_FT || bfcp->type == GLP_BF_BG ||
-               bfcp->type == GLP_BF_GR))
-            xerror("glp_set_bfcp: type = %d; invalid parameter\n",
-               bfcp->type);
-         if (bfcp->lu_size < 0)
-            xerror("glp_set_bfcp: lu_size = %d; invalid parameter\n",
-               bfcp->lu_size);
-         if (!(0.0 < bfcp->piv_tol && bfcp->piv_tol < 1.0))
+#if 1 /* 08/III-2014 */
+void glp_set_bfcp(glp_prob *P, const glp_bfcp *parm)
+{     if (P->bfd == NULL)
+         P->bfd = bfd_create_it();
+      if (parm != NULL)
+      {  if (!(parm->type == GLP_BF_LUF + GLP_BF_FT ||
+               parm->type == GLP_BF_LUF + GLP_BF_BG ||
+               parm->type == GLP_BF_LUF + GLP_BF_GR ||
+               parm->type == GLP_BF_BTF + GLP_BF_BG ||
+               parm->type == GLP_BF_BTF + GLP_BF_GR))
+            xerror("glp_set_bfcp: type = 0x%02X; invalid parameter\n",
+               parm->type);
+         if (!(0.0 < parm->piv_tol && parm->piv_tol < 1.0))
             xerror("glp_set_bfcp: piv_tol = %g; invalid parameter\n",
-               bfcp->piv_tol);
-         if (bfcp->piv_lim < 1)
+               parm->piv_tol);
+         if (parm->piv_lim < 1)
             xerror("glp_set_bfcp: piv_lim = %d; invalid parameter\n",
-               bfcp->piv_lim);
-         if (!(bfcp->suhl == GLP_ON || bfcp->suhl == GLP_OFF))
+               parm->piv_lim);
+         if (!(parm->suhl == GLP_ON || parm->suhl == GLP_OFF))
             xerror("glp_set_bfcp: suhl = %d; invalid parameter\n",
-               bfcp->suhl);
-         if (!(0.0 <= bfcp->eps_tol && bfcp->eps_tol <= 1e-6))
+               parm->suhl);
+         if (!(0.0 <= parm->eps_tol && parm->eps_tol <= 1e-6))
             xerror("glp_set_bfcp: eps_tol = %g; invalid parameter\n",
-               bfcp->eps_tol);
-         if (bfcp->max_gro < 1.0)
-            xerror("glp_set_bfcp: max_gro = %g; invalid parameter\n",
-               bfcp->max_gro);
-         if (!(1 <= bfcp->nfs_max && bfcp->nfs_max <= 32767))
+               parm->eps_tol);
+         if (!(1 <= parm->nfs_max && parm->nfs_max <= 32767))
             xerror("glp_set_bfcp: nfs_max = %d; invalid parameter\n",
-               bfcp->nfs_max);
-         if (!(0.0 < bfcp->upd_tol && bfcp->upd_tol < 1.0))
-            xerror("glp_set_bfcp: upd_tol = %g; invalid parameter\n",
-               bfcp->upd_tol);
-         if (!(1 <= bfcp->nrs_max && bfcp->nrs_max <= 32767))
+               parm->nfs_max);
+         if (!(1 <= parm->nrs_max && parm->nrs_max <= 32767))
             xerror("glp_set_bfcp: nrs_max = %d; invalid parameter\n",
-               bfcp->nrs_max);
-         if (bfcp->rs_size < 0)
-            xerror("glp_set_bfcp: rs_size = %d; invalid parameter\n",
-               bfcp->nrs_max);
-         if (bfcp->rs_size == 0)
-            bfcp->rs_size = 20 * bfcp->nrs_max;
+               parm->nrs_max);
       }
-      if (lp->bfd != NULL) copy_bfcp(lp);
+      bfd_set_bfcp(P->bfd, parm);
       return;
 }
+#endif
 
 /***********************************************************************
 *  NAME
 *
 *  glp_get_bhead - retrieve the basis header information
 *
 *  SYNOPSIS
@@ -592,15 +530,15 @@
 *  GLP_ECOND
 *     The basis matrix is ill-conditioned. */
 
 int glp_warm_up(glp_prob *P)
 {     GLPROW *row;
       GLPCOL *col;
       GLPAIJ *aij;
-      int i, j, type, ret;
+      int i, j, type, stat, ret;
       double eps, temp, *work;
       /* invalidate basic solution */
       P->pbs_stat = P->dbs_stat = GLP_UNDEF;
       P->obj_val = 0.0;
       P->some = 0;
       for (i = 1; i <= P->m; i++)
       {  row = P->row[i];
@@ -719,35 +657,51 @@
       {  row = P->row[i];
          if (row->stat == GLP_BS)
          {  row->dual = 0.0;
             continue;
          }
          /* N[j] is i-th column of matrix (I|-A) */
          row->dual = - work[i];
+#if 0 /* 07/III-2013 */
          type = row->type;
          temp = (P->dir == GLP_MIN ? + row->dual : - row->dual);
          if ((type == GLP_FR || type == GLP_LO) && temp < -1e-5 ||
              (type == GLP_FR || type == GLP_UP) && temp > +1e-5)
             P->dbs_stat = GLP_INFEAS;
+#else
+         stat = row->stat;
+         temp = (P->dir == GLP_MIN ? + row->dual : - row->dual);
+         if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||
+             (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)
+            P->dbs_stat = GLP_INFEAS;
+#endif
       }
       for (j = 1; j <= P->n; j++)
       {  col = P->col[j];
          if (col->stat == GLP_BS)
          {  col->dual = 0.0;
             continue;
          }
          /* N[j] is (m+j)-th column of matrix (I|-A) */
          col->dual = col->coef;
          for (aij = col->ptr; aij != NULL; aij = aij->c_next)
             col->dual += aij->val * work[aij->row->i];
+#if 0 /* 07/III-2013 */
          type = col->type;
          temp = (P->dir == GLP_MIN ? + col->dual : - col->dual);
          if ((type == GLP_FR || type == GLP_LO) && temp < -1e-5 ||
              (type == GLP_FR || type == GLP_UP) && temp > +1e-5)
             P->dbs_stat = GLP_INFEAS;
+#else
+         stat = col->stat;
+         temp = (P->dir == GLP_MIN ? + col->dual : - col->dual);
+         if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||
+             (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)
+            P->dbs_stat = GLP_INFEAS;
+#endif
       }
       /* free working array */
       xfree(work);
       ret = 0;
 done: return ret;
 }
 
@@ -1838,18 +1792,20 @@
 
 void glp_analyze_bound(glp_prob *P, int k, double *value1, int *var1,
       double *value2, int *var2)
 {     GLPROW *row;
       GLPCOL *col;
       int m, n, stat, kase, p, len, piv, *ind;
       double x, new_x, ll, uu, xx, delta, *val;
+#if 0 /* 04/IV-2016 */
       /* sanity checks */
       if (P == NULL || P->magic != GLP_PROB_MAGIC)
          xerror("glp_analyze_bound: P = %p; invalid problem object\n",
             P);
+#endif
       m = P->m, n = P->n;
       if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))
          xerror("glp_analyze_bound: optimal basic solution required\n");
       if (!(m == 0 || P->valid))
          xerror("glp_analyze_bound: basis factorization required\n");
       if (!(1 <= k && k <= m+n))
          xerror("glp_analyze_bound: k = %d; variable number out of rang"
@@ -2003,18 +1959,20 @@
 void glp_analyze_coef(glp_prob *P, int k, double *coef1, int *var1,
       double *value1, double *coef2, int *var2, double *value2)
 {     GLPROW *row; GLPCOL *col;
       int m, n, type, stat, kase, p, q, dir, clen, cpiv, rlen, rpiv,
          *cind, *rind;
       double lb, ub, coef, x, lim_coef, new_x, d, delta, ll, uu, xx,
          *rval, *cval;
+#if 0 /* 04/IV-2016 */
       /* sanity checks */
       if (P == NULL || P->magic != GLP_PROB_MAGIC)
          xerror("glp_analyze_coef: P = %p; invalid problem object\n",
             P);
+#endif
       m = P->m, n = P->n;
       if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))
          xerror("glp_analyze_coef: optimal basic solution required\n");
       if (!(m == 0 || P->valid))
          xerror("glp_analyze_coef: basis factorization required\n");
       if (!(1 <= k && k <= m+n))
          xerror("glp_analyze_coef: k = %d; variable number out of range"
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi13.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpapi13.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpapi13.c (branch-and-bound interface routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpios.h"
+#include "env.h"
+#include "ios.h"
 
 /***********************************************************************
 *  NAME
 *
 *  glp_ios_reason - determine reason for calling the callback routine
 *
 *  SYNOPSIS
@@ -452,15 +450,19 @@
 /**********************************************************************/
 
 int glp_ios_pool_size(glp_tree *tree)
 {     /* determine current size of the cut pool */
       if (tree->reason != GLP_ICUTGEN)
          xerror("glp_ios_pool_size: operation not allowed\n");
       xassert(tree->local != NULL);
+#ifdef NEW_LOCAL /* 02/II-2018 */
+      return tree->local->m;
+#else
       return tree->local->size;
+#endif
 }
 
 /**********************************************************************/
 
 int glp_ios_add_row(glp_tree *tree,
       const char *name, int klass, int flags, int len, const int ind[],
       const double val[], int type, double rhs)
@@ -670,14 +672,17 @@
       for (i = 1; i <= m; i++)
       {  GLPROW *row = mip->row[i];
          GLPAIJ *aij;
          row->mipx = 0.0;
          for (aij = row->ptr; aij != NULL; aij = aij->r_next)
             row->mipx += aij->val * aij->col->mipx;
       }
+#if 1 /* 11/VII-2013 */
+      ios_process_sol(tree);
+#endif
       return 0;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  glp_ios_terminate - terminate the solution process.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi14.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/mpl.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi14.c (processing models in GNU MathProg language) */
+/* mpl.c (processing model in GNU MathProg language) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2008-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,35 +15,31 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#define GLP_TRAN_DEFINED
-typedef struct MPL glp_tran;
-
-#include "glpmpl.h"
-#include "glpapi.h"
+#include "mpl.h"
+#include "prob.h"
 
 glp_tran *glp_mpl_alloc_wksp(void)
 {     /* allocate the MathProg translator workspace */
       glp_tran *tran;
       tran = mpl_initialize();
       return tran;
 }
 
-#if 1 /* 08/XII-2009 */
-void _glp_mpl_init_rand(glp_tran *tran, int seed)
-{     if (tran->phase != 0)
+void glp_mpl_init_rand(glp_tran *tran, int seed)
+{     /* initialize pseudo-random number generator */
+      if (tran->phase != 0)
          xerror("glp_mpl_init_rand: invalid call sequence\n");
       rng_init_rand(tran->rand, seed);
       return;
 }
-#endif
 
 int glp_mpl_read_model(glp_tran *tran, const char *fname, int skip)
 {     /* read and translate model section */
       int ret;
       if (tran->phase != 0)
          xerror("glp_mpl_read_model: invalid call sequence\n");
       ret = mpl_read_model(tran, (char *)fname, skip);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi15.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/graph.c`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi15.c (basic graph and network routines) */
+/* graph.c (basic graph routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,18 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpapi.h"
+#include "avl.h"
+#include "dmp.h"
+#include "env.h"
+#include "glpk.h"
 
 /* CAUTION: DO NOT CHANGE THE LIMITS BELOW */
 
 #define NV_MAX 100000000 /* = 100*10^6 */
 /* maximal number of vertices in the graph */
 
 #define NA_MAX 500000000 /* = 500*10^6 */
@@ -500,115 +495,8 @@
       if (G->index != NULL)
       {  avl_delete_tree(G->index), G->index = NULL;
          for (i = 1; i <= G->nv; i++) G->v[i]->entry = NULL;
       }
       return;
 }
 
-/***********************************************************************
-*  NAME
-*
-*  glp_read_graph - read graph from plain text file
-*
-*  SYNOPSIS
-*
-*  int glp_read_graph(glp_graph *G, const char *fname);
-*
-*  DESCRIPTION
-*
-*  The routine glp_read_graph reads a graph from a plain text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_read_graph(glp_graph *G, const char *fname)
-{     glp_data *data;
-      jmp_buf jump;
-      int nv, na, i, j, k, ret;
-      glp_erase_graph(G, G->v_size, G->a_size);
-      xprintf("Reading graph from `%s'...\n", fname);
-      data = glp_sdf_open_file(fname);
-      if (data == NULL)
-      {  ret = 1;
-         goto done;
-      }
-      if (setjmp(jump))
-      {  ret = 1;
-         goto done;
-      }
-      glp_sdf_set_jump(data, jump);
-      nv = glp_sdf_read_int(data);
-      if (nv < 0)
-         glp_sdf_error(data, "invalid number of vertices\n");
-      na = glp_sdf_read_int(data);
-      if (na < 0)
-         glp_sdf_error(data, "invalid number of arcs\n");
-      xprintf("Graph has %d vert%s and %d arc%s\n",
-         nv, nv == 1 ? "ex" : "ices", na, na == 1 ? "" : "s");
-      if (nv > 0) glp_add_vertices(G, nv);
-      for (k = 1; k <= na; k++)
-      {  i = glp_sdf_read_int(data);
-         if (!(1 <= i && i <= nv))
-            glp_sdf_error(data, "tail vertex number out of range\n");
-         j = glp_sdf_read_int(data);
-         if (!(1 <= j && j <= nv))
-            glp_sdf_error(data, "head vertex number out of range\n");
-         glp_add_arc(G, i, j);
-      }
-      xprintf("%d lines were read\n", glp_sdf_line(data));
-      ret = 0;
-done: if (data != NULL) glp_sdf_close_file(data);
-      return ret;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  glp_write_graph - write graph to plain text file
-*
-*  SYNOPSIS
-*
-*  int glp_write_graph(glp_graph *G, const char *fname).
-*
-*  DESCRIPTION
-*
-*  The routine glp_write_graph writes the specified graph to a plain
-*  text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_write_graph(glp_graph *G, const char *fname)
-{     XFILE *fp;
-      glp_vertex *v;
-      glp_arc *a;
-      int i, count, ret;
-      xprintf("Writing graph to `%s'...\n", fname);
-      fp = xfopen(fname, "w"), count = 0;
-      if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      xfprintf(fp, "%d %d\n", G->nv, G->na), count++;
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-            xfprintf(fp, "%d %d\n", a->tail->i, a->head->i), count++;
-      }
-      xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      xprintf("%d lines were written\n", count);
-      ret = 0;
-done: if (fp != NULL) xfclose(fp);
-      return ret;
-}
-
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi16.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/gmicut.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi16.c (graph and network analysis routines) */
+/* gmicut.c (Gomory's mixed integer cut generator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2002-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,312 +15,268 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
-#include "glpnet.h"
+#include "env.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
-*  glp_weak_comp - find all weakly connected components of graph
+*  glp_gmi_cut - generate Gomory's mixed integer cut (core routine)
 *
 *  SYNOPSIS
 *
-*  int glp_weak_comp(glp_graph *G, int v_num);
+*  int glp_gmi_cut(glp_prob *P, int j, int ind[], double val[], double
+*     phi[]);
 *
 *  DESCRIPTION
 *
-*  The routine glp_weak_comp finds all weakly connected components of
-*  the specified graph.
+*  This routine attempts to generate a Gomory's mixed integer cut for
+*  specified integer column (structural variable), whose primal value
+*  in current basic solution is integer infeasible (fractional).
+*
+*  On entry to the routine the basic solution contained in the problem
+*  object P should be optimal, and the basis factorization should be
+*  valid. The parameter j should specify the ordinal number of column
+*  (structural variable x[j]), for which the cut should be generated,
+*  1 <= j <= n, where n is the number of columns in the problem object.
+*  This column should be integer, non-fixed, and basic, and its primal
+*  value should be fractional.
+*
+*  The cut generated by the routine is the following inequality:
+*
+*     sum a[j] * x[j] >= b,
+*
+*  which is expected to be violated at the current basic solution.
+*
+*  If the cut has been successfully generated, the routine stores its
+*  non-zero coefficients a[j] and corresponding column indices j in the
+*  array locations val[1], ..., val[len] and ind[1], ..., ind[len],
+*  where 1 <= len <= n is the number of non-zero coefficients. The
+*  right-hand side value b is stored in val[0], and ind[0] is set to 0.
+*
+*  The working array phi should have 1+m+n locations (location phi[0]
+*  is not used), where m and n is the number of rows and columns in the
+*  problem object, resp.
 *
-*  The parameter v_num specifies an offset of the field of type int
-*  in the vertex data block, to which the routine stores the number of
-*  a (weakly) connected component containing that vertex. If v_num < 0,
-*  no component numbers are stored.
+*  RETURNS
 *
-*  The components are numbered in arbitrary order from 1 to nc, where
-*  nc is the total number of components found, 0 <= nc <= |V|.
+*  If the cut has been successfully generated, the routine returns
+*  len, the number of non-zero coefficients in the cut, 1 <= len <= n.
 *
-*  RETURNS
+*  Otherwise, the routine returns one of the following codes:
 *
-*  The routine returns nc, the total number of components found. */
-
-int glp_weak_comp(glp_graph *G, int v_num)
-{     glp_vertex *v;
-      glp_arc *a;
-      int f, i, j, nc, nv, pos1, pos2, *prev, *next, *list;
-      if (v_num >= 0 && v_num > G->v_size - (int)sizeof(int))
-         xerror("glp_weak_comp: v_num = %d; invalid offset\n", v_num);
-      nv = G->nv;
-      if (nv == 0)
-      {  nc = 0;
-         goto done;
-      }
-      /* allocate working arrays */
-      prev = xcalloc(1+nv, sizeof(int));
-      next = xcalloc(1+nv, sizeof(int));
-      list = xcalloc(1+nv, sizeof(int));
-      /* if vertex i is unlabelled, prev[i] is the index of previous
-         unlabelled vertex, and next[i] is the index of next unlabelled
-         vertex; if vertex i is labelled, then prev[i] < 0, and next[i]
-         is the connected component number */
-      /* initially all vertices are unlabelled */
-      f = 1;
-      for (i = 1; i <= nv; i++)
-         prev[i] = i - 1, next[i] = i + 1;
-      next[nv] = 0;
-      /* main loop (until all vertices have been labelled) */
-      nc = 0;
-      while (f != 0)
-      {  /* take an unlabelled vertex */
-         i = f;
-         /* and remove it from the list of unlabelled vertices */
-         f = next[i];
-         if (f != 0) prev[f] = 0;
-         /* label the vertex; it begins a new component */
-         prev[i] = -1, next[i] = ++nc;
-         /* breadth first search */
-         list[1] = i, pos1 = pos2 = 1;
-         while (pos1 <= pos2)
-         {  /* dequeue vertex i */
-            i = list[pos1++];
-            /* consider all arcs incoming to vertex i */
-            for (a = G->v[i]->in; a != NULL; a = a->h_next)
-            {  /* vertex j is adjacent to vertex i */
-               j = a->tail->i;
-               if (prev[j] >= 0)
-               {  /* vertex j is unlabelled */
-                  /* remove it from the list of unlabelled vertices */
-                  if (prev[j] == 0)
-                     f = next[j];
-                  else
-                     next[prev[j]] = next[j];
-                  if (next[j] == 0)
-                     ;
-                  else
-                     prev[next[j]] = prev[j];
-                  /* label the vertex */
-                  prev[j] = -1, next[j] = nc;
-                  /* and enqueue it for further consideration */
-                  list[++pos2] = j;
-               }
-            }
-            /* consider all arcs outgoing from vertex i */
-            for (a = G->v[i]->out; a != NULL; a = a->t_next)
-            {  /* vertex j is adjacent to vertex i */
-               j = a->head->i;
-               if (prev[j] >= 0)
-               {  /* vertex j is unlabelled */
-                  /* remove it from the list of unlabelled vertices */
-                  if (prev[j] == 0)
-                     f = next[j];
-                  else
-                     next[prev[j]] = next[j];
-                  if (next[j] == 0)
-                     ;
-                  else
-                     prev[next[j]] = prev[j];
-                  /* label the vertex */
-                  prev[j] = -1, next[j] = nc;
-                  /* and enqueue it for further consideration */
-                  list[++pos2] = j;
-               }
-            }
-         }
-      }
-      /* store component numbers */
-      if (v_num >= 0)
-      {  for (i = 1; i <= nv; i++)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_num, &next[i], sizeof(int));
-         }
-      }
-      /* free working arrays */
-      xfree(prev);
-      xfree(next);
-      xfree(list);
-done: return nc;
-}
-
-/***********************************************************************
-*  NAME
+*  -1    current basis factorization is not valid;
 *
-*  glp_strong_comp - find all strongly connected components of graph
+*  -2    current basic solution is not optimal;
 *
-*  SYNOPSIS
+*  -3    column ordinal number j is out of range;
 *
-*  int glp_strong_comp(glp_graph *G, int v_num);
+*  -4    variable x[j] is not of integral kind;
 *
-*  DESCRIPTION
+*  -5    variable x[j] is either fixed or non-basic;
 *
-*  The routine glp_strong_comp finds all strongly connected components
-*  of the specified graph.
+*  -6    primal value of variable x[j] in basic solution is too close
+*        to nearest integer;
 *
-*  The parameter v_num specifies an offset of the field of type int
-*  in the vertex data block, to which the routine stores the number of
-*  a strongly connected component containing that vertex. If v_num < 0,
-*  no component numbers are stored.
-*
-*  The components are numbered in arbitrary order from 1 to nc, where
-*  nc is the total number of components found, 0 <= nc <= |V|. However,
-*  the component numbering has the property that for every arc (i->j)
-*  in the graph the condition num(i) >= num(j) holds.
+*  -7    some coefficients in the simplex table row corresponding to
+*        variable x[j] are too large in magnitude;
 *
-*  RETURNS
+*  -8    some free (unbounded) variables have non-zero coefficients in
+*        the simplex table row corresponding to variable x[j].
 *
-*  The routine returns nc, the total number of components found. */
+*  ALGORITHM
+*
+*  See glpk/doc/notes/gomory (in Russian). */
+
+#define f(x) ((x) - floor(x))
+/* compute fractional part of x */
 
-int glp_strong_comp(glp_graph *G, int v_num)
-{     glp_vertex *v;
-      glp_arc *a;
-      int i, k, last, n, na, nc, *icn, *ip, *lenr, *ior, *ib, *lowl,
-         *numb, *prev;
-      if (v_num >= 0 && v_num > G->v_size - (int)sizeof(int))
-         xerror("glp_strong_comp: v_num = %d; invalid offset\n",
-            v_num);
-      n = G->nv;
-      if (n == 0)
-      {  nc = 0;
-         goto done;
+int glp_gmi_cut(glp_prob *P, int j,
+      int ind[/*1+n*/], double val[/*1+n*/], double phi[/*1+m+n*/])
+{     int m = P->m;
+      int n = P->n;
+      GLPROW *row;
+      GLPCOL *col;
+      GLPAIJ *aij;
+      int i, k, len, kind, stat;
+      double lb, ub, alfa, beta, ksi, phi1, rhs;
+      /* sanity checks */
+      if (!(P->m == 0 || P->valid))
+      {  /* current basis factorization is not valid */
+         return -1;
       }
-      na = G->na;
-      icn = xcalloc(1+na, sizeof(int));
-      ip = xcalloc(1+n, sizeof(int));
-      lenr = xcalloc(1+n, sizeof(int));
-      ior = xcalloc(1+n, sizeof(int));
-      ib = xcalloc(1+n, sizeof(int));
-      lowl = xcalloc(1+n, sizeof(int));
-      numb = xcalloc(1+n, sizeof(int));
-      prev = xcalloc(1+n, sizeof(int));
-      k = 1;
-      for (i = 1; i <= n; i++)
-      {  v = G->v[i];
-         ip[i] = k;
-         for (a = v->out; a != NULL; a = a->t_next)
-            icn[k++] = a->head->i;
-         lenr[i] = k - ip[i];
+      if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))
+      {  /* current basic solution is not optimal */
+         return -2;
       }
-      xassert(na == k-1);
-      nc = mc13d(n, icn, ip, lenr, ior, ib, lowl, numb, prev);
-      if (v_num >= 0)
-      {  xassert(ib[1] == 1);
-         for (k = 1; k <= nc; k++)
-         {  last = (k < nc ? ib[k+1] : n+1);
-            xassert(ib[k] < last);
-            for (i = ib[k]; i < last; i++)
-            {  v = G->v[ior[i]];
-               memcpy((char *)v->data + v_num, &k, sizeof(int));
-            }
-         }
+      if (!(1 <= j && j <= n))
+      {  /* column ordinal number is out of range */
+         return -3;
       }
-      xfree(icn);
-      xfree(ip);
-      xfree(lenr);
-      xfree(ior);
-      xfree(ib);
-      xfree(lowl);
-      xfree(numb);
-      xfree(prev);
-done: return nc;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  glp_top_sort - topological sorting of acyclic digraph
-*
-*  SYNOPSIS
-*
-*  int glp_top_sort(glp_graph *G, int v_num);
-*
-*  DESCRIPTION
-*
-*  The routine glp_top_sort performs topological sorting of vertices of
-*  the specified acyclic digraph.
-*
-*  The parameter v_num specifies an offset of the field of type int in
-*  the vertex data block, to which the routine stores the vertex number
-*  assigned. If v_num < 0, vertex numbers are not stored.
-*
-*  The vertices are numbered from 1 to n, where n is the total number
-*  of vertices in the graph. The vertex numbering has the property that
-*  for every arc (i->j) in the graph the condition num(i) < num(j)
-*  holds. Special case num(i) = 0 means that vertex i is not assigned a
-*  number, because the graph is *not* acyclic.
-*
-*  RETURNS
-*
-*  If the graph is acyclic and therefore all the vertices have been
-*  assigned numbers, the routine glp_top_sort returns zero. Otherwise,
-*  if the graph is not acyclic, the routine returns the number of
-*  vertices which have not been numbered, i.e. for which num(i) = 0. */
-
-static int top_sort(glp_graph *G, int num[])
-{     glp_arc *a;
-      int i, j, cnt, top, *stack, *indeg;
-      /* allocate working arrays */
-      indeg = xcalloc(1+G->nv, sizeof(int));
-      stack = xcalloc(1+G->nv, sizeof(int));
-      /* determine initial indegree of each vertex; push into the stack
-         the vertices having zero indegree */
-      top = 0;
-      for (i = 1; i <= G->nv; i++)
-      {  num[i] = indeg[i] = 0;
-         for (a = G->v[i]->in; a != NULL; a = a->h_next)
-            indeg[i]++;
-         if (indeg[i] == 0)
-            stack[++top] = i;
+      col = P->col[j];
+      if (col->kind != GLP_IV)
+      {  /* x[j] is not of integral kind */
+         return -4;
+      }
+      if (col->type == GLP_FX || col->stat != GLP_BS)
+      {  /* x[j] is either fixed or non-basic */
+         return -5;
+      }
+      if (fabs(col->prim - floor(col->prim + 0.5)) < 0.001)
+      {  /* primal value of x[j] is too close to nearest integer */
+         return -6;
       }
-      /* assign numbers to vertices in the sorted order */
-      cnt = 0;
-      while (top > 0)
-      {  /* pull vertex i from the stack */
-         i = stack[top--];
-         /* it has zero indegree in the current graph */
-         xassert(indeg[i] == 0);
-         /* so assign it a next number */
-         xassert(num[i] == 0);
-         num[i] = ++cnt;
-         /* remove vertex i from the current graph, update indegree of
-            its adjacent vertices, and push into the stack new vertices
-            whose indegree becomes zero */
-         for (a = G->v[i]->out; a != NULL; a = a->t_next)
-         {  j = a->head->i;
-            /* there exists arc (i->j) in the graph */
-            xassert(indeg[j] > 0);
-            indeg[j]--;
-            if (indeg[j] == 0)
-               stack[++top] = j;
+      /* compute row of the simplex tableau, which (row) corresponds
+       * to specified basic variable xB[i] = x[j]; see (23) */
+      len = glp_eval_tab_row(P, m+j, ind, val);
+      /* determine beta[i], which a value of xB[i] in optimal solution
+       * to current LP relaxation; note that this value is the same as
+       * if it would be computed with formula (27); it is assumed that
+       * beta[i] is fractional enough */
+      beta = P->col[j]->prim;
+      /* compute cut coefficients phi and right-hand side rho, which
+       * correspond to formula (30); dense format is used, because rows
+       * of the simplex tableau are usually dense */
+      for (k = 1; k <= m+n; k++)
+         phi[k] = 0.0;
+      rhs = f(beta); /* initial value of rho; see (28), (32) */
+      for (j = 1; j <= len; j++)
+      {  /* determine original number of non-basic variable xN[j] */
+         k = ind[j];
+         xassert(1 <= k && k <= m+n);
+         /* determine the kind, bounds and current status of xN[j] in
+          * optimal solution to LP relaxation */
+         if (k <= m)
+         {  /* auxiliary variable */
+            row = P->row[k];
+            kind = GLP_CV;
+            lb = row->lb;
+            ub = row->ub;
+            stat = row->stat;
          }
+         else
+         {  /* structural variable */
+            col = P->col[k-m];
+            kind = col->kind;
+            lb = col->lb;
+            ub = col->ub;
+            stat = col->stat;
+         }
+         /* xN[j] cannot be basic */
+         xassert(stat != GLP_BS);
+         /* determine row coefficient ksi[i,j] at xN[j]; see (23) */
+         ksi = val[j];
+         /* if ksi[i,j] is too large in magnitude, report failure */
+         if (fabs(ksi) > 1e+05)
+            return -7;
+         /* if ksi[i,j] is too small in magnitude, skip it */
+         if (fabs(ksi) < 1e-10)
+            goto skip;
+         /* compute row coefficient alfa[i,j] at y[j]; see (26) */
+         switch (stat)
+         {  case GLP_NF:
+               /* xN[j] is free (unbounded) having non-zero ksi[i,j];
+                * report failure */
+               return -8;
+            case GLP_NL:
+               /* xN[j] has active lower bound */
+               alfa = - ksi;
+               break;
+            case GLP_NU:
+               /* xN[j] has active upper bound */
+               alfa = + ksi;
+               break;
+            case GLP_NS:
+               /* xN[j] is fixed; skip it */
+               goto skip;
+            default:
+               xassert(stat != stat);
+         }
+         /* compute cut coefficient phi'[j] at y[j]; see (21), (28) */
+         switch (kind)
+         {  case GLP_IV:
+               /* y[j] is integer */
+               if (fabs(alfa - floor(alfa + 0.5)) < 1e-10)
+               {  /* alfa[i,j] is close to nearest integer; skip it */
+                  goto skip;
+               }
+               else if (f(alfa) <= f(beta))
+                  phi1 = f(alfa);
+               else
+                  phi1 = (f(beta) / (1.0 - f(beta))) * (1.0 - f(alfa));
+               break;
+            case GLP_CV:
+               /* y[j] is continuous */
+               if (alfa >= 0.0)
+                  phi1 = + alfa;
+               else
+                  phi1 = (f(beta) / (1.0 - f(beta))) * (- alfa);
+               break;
+            default:
+               xassert(kind != kind);
+         }
+         /* compute cut coefficient phi[j] at xN[j] and update right-
+          * hand side rho; see (31), (32) */
+         switch (stat)
+         {  case GLP_NL:
+               /* xN[j] has active lower bound */
+               phi[k] = + phi1;
+               rhs += phi1 * lb;
+               break;
+            case GLP_NU:
+               /* xN[j] has active upper bound */
+               phi[k] = - phi1;
+               rhs -= phi1 * ub;
+               break;
+            default:
+               xassert(stat != stat);
+         }
+skip:    ;
       }
-      /* free working arrays */
-      xfree(indeg);
-      xfree(stack);
-      return G->nv - cnt;
-}
-
-int glp_top_sort(glp_graph *G, int v_num)
-{     glp_vertex *v;
-      int i, cnt, *num;
-      if (v_num >= 0 && v_num > G->v_size - (int)sizeof(int))
-         xerror("glp_top_sort: v_num = %d; invalid offset\n", v_num);
-      if (G->nv == 0)
-      {  cnt = 0;
-         goto done;
+      /* now the cut has the form sum_k phi[k] * x[k] >= rho, where cut
+       * coefficients are stored in the array phi in dense format;
+       * x[1,...,m] are auxiliary variables, x[m+1,...,m+n] are struc-
+       * tural variables; see (30) */
+      /* eliminate auxiliary variables in order to express the cut only
+       * through structural variables; see (33) */
+      for (i = 1; i <= m; i++)
+      {  if (fabs(phi[i]) < 1e-10)
+            continue;
+         /* auxiliary variable x[i] has non-zero cut coefficient */
+         row = P->row[i];
+         /* x[i] cannot be fixed variable */
+         xassert(row->type != GLP_FX);
+         /* substitute x[i] = sum_j a[i,j] * x[m+j] */
+         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+            phi[m+aij->col->j] += phi[i] * aij->val;
       }
-      num = xcalloc(1+G->nv, sizeof(int));
-      cnt = top_sort(G, num);
-      if (v_num >= 0)
-      {  for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_num, &num[i], sizeof(int));
+      /* convert the final cut to sparse format and substitute fixed
+       * (structural) variables */
+      len = 0;
+      for (j = 1; j <= n; j++)
+      {  if (fabs(phi[m+j]) < 1e-10)
+            continue;
+         /* structural variable x[m+j] has non-zero cut coefficient */
+         col = P->col[j];
+         if (col->type == GLP_FX)
+         {  /* eliminate x[m+j] */
+            rhs -= phi[m+j] * col->lb;
+         }
+         else
+         {  len++;
+            ind[len] = j;
+            val[len] = phi[m+j];
          }
       }
-      xfree(num);
-done: return cnt;
+      if (fabs(rhs) < 1e-12)
+         rhs = 0.0;
+      ind[0] = 0, val[0] = rhs;
+      /* the cut has been successfully generated */
+      return len;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi17.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpipm.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi17.c (flow network problems) */
+/* glpipm.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,1031 +15,1127 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
-#include "glpnet.h"
+#include "env.h"
+#include "glpipm.h"
+#include "glpmat.h"
+
+#define ITER_MAX 100
+/* maximal number of iterations */
+
+struct csa
+{     /* common storage area */
+      /*--------------------------------------------------------------*/
+      /* LP data */
+      int m;
+      /* number of rows (equality constraints) */
+      int n;
+      /* number of columns (structural variables) */
+      int *A_ptr; /* int A_ptr[1+m+1]; */
+      int *A_ind; /* int A_ind[A_ptr[m+1]]; */
+      double *A_val; /* double A_val[A_ptr[m+1]]; */
+      /* mxn-matrix A in storage-by-rows format */
+      double *b; /* double b[1+m]; */
+      /* m-vector b of right-hand sides */
+      double *c; /* double c[1+n]; */
+      /* n-vector c of objective coefficients; c[0] is constant term of
+         the objective function */
+      /*--------------------------------------------------------------*/
+      /* LP solution */
+      double *x; /* double x[1+n]; */
+      double *y; /* double y[1+m]; */
+      double *z; /* double z[1+n]; */
+      /* current point in primal-dual space; the best point on exit */
+      /*--------------------------------------------------------------*/
+      /* control parameters */
+      const glp_iptcp *parm;
+      /*--------------------------------------------------------------*/
+      /* working arrays and variables */
+      double *D; /* double D[1+n]; */
+      /* diagonal nxn-matrix D = X*inv(Z), where X = diag(x[j]) and
+         Z = diag(z[j]) */
+      int *P; /* int P[1+m+m]; */
+      /* permutation mxm-matrix P used to minimize fill-in in Cholesky
+         factorization */
+      int *S_ptr; /* int S_ptr[1+m+1]; */
+      int *S_ind; /* int S_ind[S_ptr[m+1]]; */
+      double *S_val; /* double S_val[S_ptr[m+1]]; */
+      double *S_diag; /* double S_diag[1+m]; */
+      /* symmetric mxm-matrix S = P*A*D*A'*P' whose upper triangular
+         part without diagonal elements is stored in S_ptr, S_ind, and
+         S_val in storage-by-rows format, diagonal elements are stored
+         in S_diag */
+      int *U_ptr; /* int U_ptr[1+m+1]; */
+      int *U_ind; /* int U_ind[U_ptr[m+1]]; */
+      double *U_val; /* double U_val[U_ptr[m+1]]; */
+      double *U_diag; /* double U_diag[1+m]; */
+      /* upper triangular mxm-matrix U defining Cholesky factorization
+         S = U'*U; its non-diagonal elements are stored in U_ptr, U_ind,
+         U_val in storage-by-rows format, diagonal elements are stored
+         in U_diag */
+      int iter;
+      /* iteration number (0, 1, 2, ...); iter = 0 corresponds to the
+         initial point */
+      double obj;
+      /* current value of the objective function */
+      double rpi;
+      /* relative primal infeasibility rpi = ||A*x-b||/(1+||b||) */
+      double rdi;
+      /* relative dual infeasibility rdi = ||A'*y+z-c||/(1+||c||) */
+      double gap;
+      /* primal-dual gap = |c'*x-b'*y|/(1+|c'*x|) which is a relative
+         difference between primal and dual objective functions */
+      double phi;
+      /* merit function phi = ||A*x-b||/max(1,||b||) +
+                            + ||A'*y+z-c||/max(1,||c||) +
+                            + |c'*x-b'*y|/max(1,||b||,||c||) */
+      double mu;
+      /* duality measure mu = x'*z/n (used as barrier parameter) */
+      double rmu;
+      /* rmu = max(||A*x-b||,||A'*y+z-c||)/mu */
+      double rmu0;
+      /* the initial value of rmu on iteration 0 */
+      double *phi_min; /* double phi_min[1+ITER_MAX]; */
+      /* phi_min[k] = min(phi[k]), where phi[k] is the value of phi on
+         k-th iteration, 0 <= k <= iter */
+      int best_iter;
+      /* iteration number, on which the value of phi reached its best
+         (minimal) value */
+      double *best_x; /* double best_x[1+n]; */
+      double *best_y; /* double best_y[1+m]; */
+      double *best_z; /* double best_z[1+n]; */
+      /* best point (in the sense of the merit function phi) which has
+         been reached on iteration iter_best */
+      double best_obj;
+      /* objective value at the best point */
+      double *dx_aff; /* double dx_aff[1+n]; */
+      double *dy_aff; /* double dy_aff[1+m]; */
+      double *dz_aff; /* double dz_aff[1+n]; */
+      /* affine scaling direction */
+      double alfa_aff_p, alfa_aff_d;
+      /* maximal primal and dual stepsizes in affine scaling direction,
+         on which x and z are still non-negative */
+      double mu_aff;
+      /* duality measure mu_aff = x_aff'*z_aff/n in the boundary point
+         x_aff' = x+alfa_aff_p*dx_aff, z_aff' = z+alfa_aff_d*dz_aff */
+      double sigma;
+      /* Mehrotra's heuristic parameter (0 <= sigma <= 1) */
+      double *dx_cc; /* double dx_cc[1+n]; */
+      double *dy_cc; /* double dy_cc[1+m]; */
+      double *dz_cc; /* double dz_cc[1+n]; */
+      /* centering corrector direction */
+      double *dx; /* double dx[1+n]; */
+      double *dy; /* double dy[1+m]; */
+      double *dz; /* double dz[1+n]; */
+      /* final combined direction dx = dx_aff+dx_cc, dy = dy_aff+dy_cc,
+         dz = dz_aff+dz_cc */
+      double alfa_max_p;
+      double alfa_max_d;
+      /* maximal primal and dual stepsizes in combined direction, on
+         which x and z are still non-negative */
+};
 
 /***********************************************************************
-*  NAME
+*  initialize - allocate and initialize common storage area
 *
-*  glp_mincost_lp - convert minimum cost flow problem to LP
-*
-*  SYNOPSIS
-*
-*  void glp_mincost_lp(glp_prob *lp, glp_graph *G, int names,
-*     int v_rhs, int a_low, int a_cap, int a_cost);
-*
-*  DESCRIPTION
-*
-*  The routine glp_mincost_lp builds an LP problem, which corresponds
-*  to the minimum cost flow problem on the specified network G. */
+*  This routine allocates and initializes the common storage area (CSA)
+*  used by interior-point method routines. */
 
-void glp_mincost_lp(glp_prob *lp, glp_graph *G, int names, int v_rhs,
-      int a_low, int a_cap, int a_cost)
-{     glp_vertex *v;
-      glp_arc *a;
-      int i, j, type, ind[1+2];
-      double rhs, low, cap, cost, val[1+2];
-      if (!(names == GLP_ON || names == GLP_OFF))
-         xerror("glp_mincost_lp: names = %d; invalid parameter\n",
-            names);
-      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))
-         xerror("glp_mincost_lp: v_rhs = %d; invalid offset\n", v_rhs);
-      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))
-         xerror("glp_mincost_lp: a_low = %d; invalid offset\n", a_low);
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_mincost_lp: a_cap = %d; invalid offset\n", a_cap);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_mincost_lp: a_cost = %d; invalid offset\n", a_cost)
-            ;
-      glp_erase_prob(lp);
-      if (names) glp_set_prob_name(lp, G->name);
-      if (G->nv > 0) glp_add_rows(lp, G->nv);
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (names) glp_set_row_name(lp, i, v->name);
-         if (v_rhs >= 0)
-            memcpy(&rhs, (char *)v->data + v_rhs, sizeof(double));
-         else
-            rhs = 0.0;
-         glp_set_row_bnds(lp, i, GLP_FX, rhs, rhs);
-      }
-      if (G->na > 0) glp_add_cols(lp, G->na);
-      for (i = 1, j = 0; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  j++;
-            if (names)
-            {  char name[50+1];
-               sprintf(name, "x[%d,%d]", a->tail->i, a->head->i);
-               xassert(strlen(name) < sizeof(name));
-               glp_set_col_name(lp, j, name);
-            }
-            if (a->tail->i != a->head->i)
-            {  ind[1] = a->tail->i, val[1] = +1.0;
-               ind[2] = a->head->i, val[2] = -1.0;
-               glp_set_mat_col(lp, j, 2, ind, val);
-            }
-            if (a_low >= 0)
-               memcpy(&low, (char *)a->data + a_low, sizeof(double));
-            else
-               low = 0.0;
-            if (a_cap >= 0)
-               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));
-            else
-               cap = 1.0;
-            if (cap == DBL_MAX)
-               type = GLP_LO;
-            else if (low != cap)
-               type = GLP_DB;
-            else
-               type = GLP_FX;
-            glp_set_col_bnds(lp, j, type, low, cap);
-            if (a_cost >= 0)
-               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));
-            else
-               cost = 0.0;
-            glp_set_obj_coef(lp, j, cost);
-         }
+static void initialize(struct csa *csa)
+{     int m = csa->m;
+      int n = csa->n;
+      int i;
+      if (csa->parm->msg_lev >= GLP_MSG_ALL)
+         xprintf("Matrix A has %d non-zeros\n", csa->A_ptr[m+1]-1);
+      csa->D = xcalloc(1+n, sizeof(double));
+      /* P := I */
+      csa->P = xcalloc(1+m+m, sizeof(int));
+      for (i = 1; i <= m; i++) csa->P[i] = csa->P[m+i] = i;
+      /* S := A*A', symbolically */
+      csa->S_ptr = xcalloc(1+m+1, sizeof(int));
+      csa->S_ind = adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind,
+         csa->S_ptr);
+      if (csa->parm->msg_lev >= GLP_MSG_ALL)
+         xprintf("Matrix S = A*A' has %d non-zeros (upper triangle)\n",
+            csa->S_ptr[m+1]-1 + m);
+      /* determine P using specified ordering algorithm */
+      if (csa->parm->ord_alg == GLP_ORD_NONE)
+      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+            xprintf("Original ordering is being used\n");
+         for (i = 1; i <= m; i++)
+            csa->P[i] = csa->P[m+i] = i;
+      }
+      else if (csa->parm->ord_alg == GLP_ORD_QMD)
+      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+            xprintf("Minimum degree ordering (QMD)...\n");
+         min_degree(m, csa->S_ptr, csa->S_ind, csa->P);
+      }
+      else if (csa->parm->ord_alg == GLP_ORD_AMD)
+      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+            xprintf("Approximate minimum degree ordering (AMD)...\n");
+         amd_order1(m, csa->S_ptr, csa->S_ind, csa->P);
+      }
+      else if (csa->parm->ord_alg == GLP_ORD_SYMAMD)
+      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+            xprintf("Approximate minimum degree ordering (SYMAMD)...\n")
+               ;
+         symamd_ord(m, csa->S_ptr, csa->S_ind, csa->P);
       }
-      xassert(j == G->na);
+      else
+         xassert(csa != csa);
+      /* S := P*A*A'*P', symbolically */
+      xfree(csa->S_ind);
+      csa->S_ind = adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind,
+         csa->S_ptr);
+      csa->S_val = xcalloc(csa->S_ptr[m+1], sizeof(double));
+      csa->S_diag = xcalloc(1+m, sizeof(double));
+      /* compute Cholesky factorization S = U'*U, symbolically */
+      if (csa->parm->msg_lev >= GLP_MSG_ALL)
+         xprintf("Computing Cholesky factorization S = L*L'...\n");
+      csa->U_ptr = xcalloc(1+m+1, sizeof(int));
+      csa->U_ind = chol_symbolic(m, csa->S_ptr, csa->S_ind, csa->U_ptr);
+      if (csa->parm->msg_lev >= GLP_MSG_ALL)
+         xprintf("Matrix L has %d non-zeros\n", csa->U_ptr[m+1]-1 + m);
+      csa->U_val = xcalloc(csa->U_ptr[m+1], sizeof(double));
+      csa->U_diag = xcalloc(1+m, sizeof(double));
+      csa->iter = 0;
+      csa->obj = 0.0;
+      csa->rpi = 0.0;
+      csa->rdi = 0.0;
+      csa->gap = 0.0;
+      csa->phi = 0.0;
+      csa->mu = 0.0;
+      csa->rmu = 0.0;
+      csa->rmu0 = 0.0;
+      csa->phi_min = xcalloc(1+ITER_MAX, sizeof(double));
+      csa->best_iter = 0;
+      csa->best_x = xcalloc(1+n, sizeof(double));
+      csa->best_y = xcalloc(1+m, sizeof(double));
+      csa->best_z = xcalloc(1+n, sizeof(double));
+      csa->best_obj = 0.0;
+      csa->dx_aff = xcalloc(1+n, sizeof(double));
+      csa->dy_aff = xcalloc(1+m, sizeof(double));
+      csa->dz_aff = xcalloc(1+n, sizeof(double));
+      csa->alfa_aff_p = 0.0;
+      csa->alfa_aff_d = 0.0;
+      csa->mu_aff = 0.0;
+      csa->sigma = 0.0;
+      csa->dx_cc = xcalloc(1+n, sizeof(double));
+      csa->dy_cc = xcalloc(1+m, sizeof(double));
+      csa->dz_cc = xcalloc(1+n, sizeof(double));
+      csa->dx = csa->dx_aff;
+      csa->dy = csa->dy_aff;
+      csa->dz = csa->dz_aff;
+      csa->alfa_max_p = 0.0;
+      csa->alfa_max_d = 0.0;
       return;
 }
 
-/**********************************************************************/
+/***********************************************************************
+*  A_by_vec - compute y = A*x
+*
+*  This routine computes matrix-vector product y = A*x, where A is the
+*  constraint matrix. */
 
-int glp_mincost_okalg(glp_graph *G, int v_rhs, int a_low, int a_cap,
-      int a_cost, double *sol, int a_x, int v_pi)
-{     /* find minimum-cost flow with out-of-kilter algorithm */
-      glp_vertex *v;
-      glp_arc *a;
-      int nv, na, i, k, s, t, *tail, *head, *low, *cap, *cost, *x, *pi,
-         ret;
-      double sum, temp;
-      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))
-         xerror("glp_mincost_okalg: v_rhs = %d; invalid offset\n",
-            v_rhs);
-      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))
-         xerror("glp_mincost_okalg: a_low = %d; invalid offset\n",
-            a_low);
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_mincost_okalg: a_cap = %d; invalid offset\n",
-            a_cap);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_mincost_okalg: a_cost = %d; invalid offset\n",
-            a_cost);
-      if (a_x >= 0 && a_x > G->a_size - (int)sizeof(double))
-         xerror("glp_mincost_okalg: a_x = %d; invalid offset\n", a_x);
-      if (v_pi >= 0 && v_pi > G->v_size - (int)sizeof(double))
-         xerror("glp_mincost_okalg: v_pi = %d; invalid offset\n", v_pi);
-      /* s is artificial source node */
-      s = G->nv + 1;
-      /* t is artificial sink node */
-      t = s + 1;
-      /* nv is the total number of nodes in the resulting network */
-      nv = t;
-      /* na is the total number of arcs in the resulting network */
-      na = G->na + 1;
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (v_rhs >= 0)
-            memcpy(&temp, (char *)v->data + v_rhs, sizeof(double));
-         else
-            temp = 0.0;
-         if (temp != 0.0) na++;
-      }
-      /* allocate working arrays */
-      tail = xcalloc(1+na, sizeof(int));
-      head = xcalloc(1+na, sizeof(int));
-      low = xcalloc(1+na, sizeof(int));
-      cap = xcalloc(1+na, sizeof(int));
-      cost = xcalloc(1+na, sizeof(int));
-      x = xcalloc(1+na, sizeof(int));
-      pi = xcalloc(1+nv, sizeof(int));
-      /* construct the resulting network */
-      k = 0;
-      /* (original arcs) */
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  k++;
-            tail[k] = a->tail->i;
-            head[k] = a->head->i;
-            if (tail[k] == head[k])
-            {  ret = GLP_EDATA;
-               goto done;
-            }
-            if (a_low >= 0)
-               memcpy(&temp, (char *)a->data + a_low, sizeof(double));
-            else
-               temp = 0.0;
-            if (!(0.0 <= temp && temp <= (double)INT_MAX &&
-                  temp == floor(temp)))
-            {  ret = GLP_EDATA;
-               goto done;
-            }
-            low[k] = (int)temp;
-            if (a_cap >= 0)
-               memcpy(&temp, (char *)a->data + a_cap, sizeof(double));
-            else
-               temp = 1.0;
-            if (!((double)low[k] <= temp && temp <= (double)INT_MAX &&
-                  temp == floor(temp)))
-            {  ret = GLP_EDATA;
-               goto done;
-            }
-            cap[k] = (int)temp;
-            if (a_cost >= 0)
-               memcpy(&temp, (char *)a->data + a_cost, sizeof(double));
-            else
-               temp = 0.0;
-            if (!(fabs(temp) <= (double)INT_MAX && temp == floor(temp)))
-            {  ret = GLP_EDATA;
-               goto done;
-            }
-            cost[k] = (int)temp;
-         }
-      }
-      /* (artificial arcs) */
-      sum = 0.0;
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (v_rhs >= 0)
-            memcpy(&temp, (char *)v->data + v_rhs, sizeof(double));
-         else
-            temp = 0.0;
-         if (!(fabs(temp) <= (double)INT_MAX && temp == floor(temp)))
-         {  ret = GLP_EDATA;
-            goto done;
-         }
-         if (temp > 0.0)
-         {  /* artificial arc from s to original source i */
-            k++;
-            tail[k] = s;
-            head[k] = i;
-            low[k] = cap[k] = (int)(+temp); /* supply */
-            cost[k] = 0;
-            sum += (double)temp;
-         }
-         else if (temp < 0.0)
-         {  /* artificial arc from original sink i to t */
-            k++;
-            tail[k] = i;
-            head[k] = t;
-            low[k] = cap[k] = (int)(-temp); /* demand */
-            cost[k] = 0;
-         }
-      }
-      /* (feedback arc from t to s) */
-      k++;
-      xassert(k == na);
-      tail[k] = t;
-      head[k] = s;
-      if (sum > (double)INT_MAX)
-      {  ret = GLP_EDATA;
-         goto done;
-      }
-      low[k] = cap[k] = (int)sum; /* total supply/demand */
-      cost[k] = 0;
-      /* find minimal-cost circulation in the resulting network */
-      ret = okalg(nv, na, tail, head, low, cap, cost, x, pi);
-      switch (ret)
-      {  case 0:
-            /* optimal circulation found */
-            ret = 0;
-            break;
-         case 1:
-            /* no feasible circulation exists */
-            ret = GLP_ENOPFS;
-            break;
-         case 2:
-            /* integer overflow occured */
-            ret = GLP_ERANGE;
-            goto done;
-         case 3:
-            /* optimality test failed (logic error) */
-            ret = GLP_EFAIL;
-            goto done;
-         default:
-            xassert(ret != ret);
-      }
-      /* store solution components */
-      /* (objective function = the total cost) */
-      if (sol != NULL)
+static void A_by_vec(struct csa *csa, double x[], double y[])
+{     /* compute y = A*x */
+      int m = csa->m;
+      int *A_ptr = csa->A_ptr;
+      int *A_ind = csa->A_ind;
+      double *A_val = csa->A_val;
+      int i, t, beg, end;
+      double temp;
+      for (i = 1; i <= m; i++)
       {  temp = 0.0;
-         for (k = 1; k <= na; k++)
-            temp += (double)cost[k] * (double)x[k];
-         *sol = temp;
-      }
-      /* (arc flows) */
-      if (a_x >= 0)
-      {  k = 0;
-         for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            for (a = v->out; a != NULL; a = a->t_next)
-            {  temp = (double)x[++k];
-               memcpy((char *)a->data + a_x, &temp, sizeof(double));
-            }
-         }
-      }
-      /* (node potentials = Lagrange multipliers) */
-      if (v_pi >= 0)
-      {  for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            temp = - (double)pi[i];
-            memcpy((char *)v->data + v_pi, &temp, sizeof(double));
-         }
+         beg = A_ptr[i], end = A_ptr[i+1];
+         for (t = beg; t < end; t++) temp += A_val[t] * x[A_ind[t]];
+         y[i] = temp;
       }
-done: /* free working arrays */
-      xfree(tail);
-      xfree(head);
-      xfree(low);
-      xfree(cap);
-      xfree(cost);
-      xfree(x);
-      xfree(pi);
-      return ret;
+      return;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  glp_maxflow_lp - convert maximum flow problem to LP
+*  AT_by_vec - compute y = A'*x
 *
-*  SYNOPSIS
-*
-*  void glp_maxflow_lp(glp_prob *lp, glp_graph *G, int names, int s,
-*     int t, int a_cap);
-*
-*  DESCRIPTION
-*
-*  The routine glp_maxflow_lp builds an LP problem, which corresponds
-*  to the maximum flow problem on the specified network G. */
+*  This routine computes matrix-vector product y = A'*x, where A' is a
+*  matrix transposed to the constraint matrix A. */
 
-void glp_maxflow_lp(glp_prob *lp, glp_graph *G, int names, int s,
-      int t, int a_cap)
-{     glp_vertex *v;
-      glp_arc *a;
-      int i, j, type, ind[1+2];
-      double cap, val[1+2];
-      if (!(names == GLP_ON || names == GLP_OFF))
-         xerror("glp_maxflow_lp: names = %d; invalid parameter\n",
-            names);
-      if (!(1 <= s && s <= G->nv))
-         xerror("glp_maxflow_lp: s = %d; source node number out of rang"
-            "e\n", s);
-      if (!(1 <= t && t <= G->nv))
-         xerror("glp_maxflow_lp: t = %d: sink node number out of range "
-            "\n", t);
-      if (s == t)
-         xerror("glp_maxflow_lp: s = t = %d; source and sink nodes must"
-            " be distinct\n", s);
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_maxflow_lp: a_cap = %d; invalid offset\n", a_cap);
-      glp_erase_prob(lp);
-      if (names) glp_set_prob_name(lp, G->name);
-      glp_set_obj_dir(lp, GLP_MAX);
-      glp_add_rows(lp, G->nv);
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (names) glp_set_row_name(lp, i, v->name);
-         if (i == s)
-            type = GLP_LO;
-         else if (i == t)
-            type = GLP_UP;
-         else
-            type = GLP_FX;
-         glp_set_row_bnds(lp, i, type, 0.0, 0.0);
-      }
-      if (G->na > 0) glp_add_cols(lp, G->na);
-      for (i = 1, j = 0; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  j++;
-            if (names)
-            {  char name[50+1];
-               sprintf(name, "x[%d,%d]", a->tail->i, a->head->i);
-               xassert(strlen(name) < sizeof(name));
-               glp_set_col_name(lp, j, name);
-            }
-            if (a->tail->i != a->head->i)
-            {  ind[1] = a->tail->i, val[1] = +1.0;
-               ind[2] = a->head->i, val[2] = -1.0;
-               glp_set_mat_col(lp, j, 2, ind, val);
-            }
-            if (a_cap >= 0)
-               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));
-            else
-               cap = 1.0;
-            if (cap == DBL_MAX)
-               type = GLP_LO;
-            else if (cap != 0.0)
-               type = GLP_DB;
-            else
-               type = GLP_FX;
-            glp_set_col_bnds(lp, j, type, 0.0, cap);
-            if (a->tail->i == s)
-               glp_set_obj_coef(lp, j, +1.0);
-            else if (a->head->i == s)
-               glp_set_obj_coef(lp, j, -1.0);
-         }
+static void AT_by_vec(struct csa *csa, double x[], double y[])
+{     /* compute y = A'*x, where A' is transposed to A */
+      int m = csa->m;
+      int n = csa->n;
+      int *A_ptr = csa->A_ptr;
+      int *A_ind = csa->A_ind;
+      double *A_val = csa->A_val;
+      int i, j, t, beg, end;
+      double temp;
+      for (j = 1; j <= n; j++) y[j] = 0.0;
+      for (i = 1; i <= m; i++)
+      {  temp = x[i];
+         if (temp == 0.0) continue;
+         beg = A_ptr[i], end = A_ptr[i+1];
+         for (t = beg; t < end; t++) y[A_ind[t]] += A_val[t] * temp;
       }
-      xassert(j == G->na);
       return;
 }
 
-int glp_maxflow_ffalg(glp_graph *G, int s, int t, int a_cap,
-      double *sol, int a_x, int v_cut)
-{     /* find maximal flow with Ford-Fulkerson algorithm */
-      glp_vertex *v;
-      glp_arc *a;
-      int nv, na, i, k, flag, *tail, *head, *cap, *x, ret;
-      char *cut;
-      double temp;
-      if (!(1 <= s && s <= G->nv))
-         xerror("glp_maxflow_ffalg: s = %d; source node number out of r"
-            "ange\n", s);
-      if (!(1 <= t && t <= G->nv))
-         xerror("glp_maxflow_ffalg: t = %d: sink node number out of ran"
-            "ge\n", t);
-      if (s == t)
-         xerror("glp_maxflow_ffalg: s = t = %d; source and sink nodes m"
-            "ust be distinct\n", s);
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_maxflow_ffalg: a_cap = %d; invalid offset\n",
-            a_cap);
-      if (v_cut >= 0 && v_cut > G->v_size - (int)sizeof(int))
-         xerror("glp_maxflow_ffalg: v_cut = %d; invalid offset\n",
-            v_cut);
-      /* allocate working arrays */
-      nv = G->nv;
-      na = G->na;
-      tail = xcalloc(1+na, sizeof(int));
-      head = xcalloc(1+na, sizeof(int));
-      cap = xcalloc(1+na, sizeof(int));
-      x = xcalloc(1+na, sizeof(int));
-      if (v_cut < 0)
-         cut = NULL;
-      else
-         cut = xcalloc(1+nv, sizeof(char));
-      /* copy the flow network */
-      k = 0;
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  k++;
-            tail[k] = a->tail->i;
-            head[k] = a->head->i;
-            if (tail[k] == head[k])
-            {  ret = GLP_EDATA;
-               goto done;
-            }
-            if (a_cap >= 0)
-               memcpy(&temp, (char *)a->data + a_cap, sizeof(double));
-            else
-               temp = 1.0;
-            if (!(0.0 <= temp && temp <= (double)INT_MAX &&
-                  temp == floor(temp)))
-            {  ret = GLP_EDATA;
-               goto done;
-            }
-            cap[k] = (int)temp;
-         }
-      }
-      xassert(k == na);
-      /* find maximal flow in the flow network */
-      ffalg(nv, na, tail, head, s, t, cap, x, cut);
-      ret = 0;
-      /* store solution components */
-      /* (objective function = total flow through the network) */
-      if (sol != NULL)
-      {  temp = 0.0;
-         for (k = 1; k <= na; k++)
-         {  if (tail[k] == s)
-               temp += (double)x[k];
-            else if (head[k] == s)
-               temp -= (double)x[k];
-         }
-         *sol = temp;
-      }
-      /* (arc flows) */
-      if (a_x >= 0)
-      {  k = 0;
-         for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            for (a = v->out; a != NULL; a = a->t_next)
-            {  temp = (double)x[++k];
-               memcpy((char *)a->data + a_x, &temp, sizeof(double));
-            }
-         }
-      }
-      /* (node flags) */
-      if (v_cut >= 0)
-      {  for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            flag = cut[i];
-            memcpy((char *)v->data + v_cut, &flag, sizeof(int));
+/***********************************************************************
+*  decomp_NE - numeric factorization of matrix S = P*A*D*A'*P'
+*
+*  This routine implements numeric phase of Cholesky factorization of
+*  the matrix S = P*A*D*A'*P', which is a permuted matrix of the normal
+*  equation system. Matrix D is assumed to be already computed. */
+
+static void decomp_NE(struct csa *csa)
+{     adat_numeric(csa->m, csa->n, csa->P, csa->A_ptr, csa->A_ind,
+         csa->A_val, csa->D, csa->S_ptr, csa->S_ind, csa->S_val,
+         csa->S_diag);
+      chol_numeric(csa->m, csa->S_ptr, csa->S_ind, csa->S_val,
+         csa->S_diag, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag);
+      return;
+}
+
+/***********************************************************************
+*  solve_NE - solve normal equation system
+*
+*  This routine solves the normal equation system:
+*
+*     A*D*A'*y = h.
+*
+*  It is assumed that the matrix A*D*A' has been previously factorized
+*  by the routine decomp_NE.
+*
+*  On entry the array y contains the vector of right-hand sides h. On
+*  exit this array contains the computed vector of unknowns y.
+*
+*  Once the vector y has been computed the routine checks for numeric
+*  stability. If the residual vector:
+*
+*     r = A*D*A'*y - h
+*
+*  is relatively small, the routine returns zero, otherwise non-zero is
+*  returned. */
+
+static int solve_NE(struct csa *csa, double y[])
+{     int m = csa->m;
+      int n = csa->n;
+      int *P = csa->P;
+      int i, j, ret = 0;
+      double *h, *r, *w;
+      /* save vector of right-hand sides h */
+      h = xcalloc(1+m, sizeof(double));
+      for (i = 1; i <= m; i++) h[i] = y[i];
+      /* solve normal equation system (A*D*A')*y = h */
+      /* since S = P*A*D*A'*P' = U'*U, then A*D*A' = P'*U'*U*P, so we
+         have inv(A*D*A') = P'*inv(U)*inv(U')*P */
+      /* w := P*h */
+      w = xcalloc(1+m, sizeof(double));
+      for (i = 1; i <= m; i++) w[i] = y[P[i]];
+      /* w := inv(U')*w */
+      ut_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);
+      /* w := inv(U)*w */
+      u_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);
+      /* y := P'*w */
+      for (i = 1; i <= m; i++) y[i] = w[P[m+i]];
+      xfree(w);
+      /* compute residual vector r = A*D*A'*y - h */
+      r = xcalloc(1+m, sizeof(double));
+      /* w := A'*y */
+      w = xcalloc(1+n, sizeof(double));
+      AT_by_vec(csa, y, w);
+      /* w := D*w */
+      for (j = 1; j <= n; j++) w[j] *= csa->D[j];
+      /* r := A*w */
+      A_by_vec(csa, w, r);
+      xfree(w);
+      /* r := r - h */
+      for (i = 1; i <= m; i++) r[i] -= h[i];
+      /* check for numeric stability */
+      for (i = 1; i <= m; i++)
+      {  if (fabs(r[i]) / (1.0 + fabs(h[i])) > 1e-4)
+         {  ret = 1;
+            break;
          }
       }
-done: /* free working arrays */
-      xfree(tail);
-      xfree(head);
-      xfree(cap);
-      xfree(x);
-      if (cut != NULL) xfree(cut);
+      xfree(h);
+      xfree(r);
       return ret;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  glp_check_asnprob - check correctness of assignment problem data
+*  solve_NS - solve Newtonian system
 *
-*  SYNOPSIS
+*  This routine solves the Newtonian system:
 *
-*  int glp_check_asnprob(glp_graph *G, int v_set);
+*     A*dx               = p
 *
-*  RETURNS
+*           A'*dy +   dz = q
 *
-*  If the specified assignment problem data are correct, the routine
-*  glp_check_asnprob returns zero, otherwise, non-zero. */
-
-int glp_check_asnprob(glp_graph *G, int v_set)
-{     glp_vertex *v;
-      int i, k, ret = 0;
-      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))
-         xerror("glp_check_asnprob: v_set = %d; invalid offset\n",
-            v_set);
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (v_set >= 0)
-         {  memcpy(&k, (char *)v->data + v_set, sizeof(int));
-            if (k == 0)
-            {  if (v->in != NULL)
-               {  ret = 1;
-                  break;
-               }
-            }
-            else if (k == 1)
-            {  if (v->out != NULL)
-               {  ret = 2;
-                  break;
-               }
-            }
-            else
-            {  ret = 3;
-               break;
-            }
-         }
-         else
-         {  if (v->in != NULL && v->out != NULL)
-            {  ret = 4;
-               break;
-            }
-         }
+*     Z*dx        + X*dz = r
+*
+*  where X = diag(x[j]), Z = diag(z[j]), by reducing it to the normal
+*  equation system:
+*
+*     (A*inv(Z)*X*A')*dy = A*inv(Z)*(X*q-r)+p
+*
+*  (it is assumed that the matrix A*inv(Z)*X*A' has been factorized by
+*  the routine decomp_NE).
+*
+*  Once vector dy has been computed the routine computes vectors dx and
+*  dz as follows:
+*
+*     dx = inv(Z)*(X*(A'*dy-q)+r)
+*
+*     dz = inv(X)*(r-Z*dx)
+*
+*  The routine solve_NS returns the same code which was reported by the
+*  routine solve_NE (see above). */
+
+static int solve_NS(struct csa *csa, double p[], double q[], double r[],
+      double dx[], double dy[], double dz[])
+{     int m = csa->m;
+      int n = csa->n;
+      double *x = csa->x;
+      double *z = csa->z;
+      int i, j, ret;
+      double *w = dx;
+      /* compute the vector of right-hand sides A*inv(Z)*(X*q-r)+p for
+         the normal equation system */
+      for (j = 1; j <= n; j++)
+         w[j] = (x[j] * q[j] - r[j]) / z[j];
+      A_by_vec(csa, w, dy);
+      for (i = 1; i <= m; i++) dy[i] += p[i];
+      /* solve the normal equation system to compute vector dy */
+      ret = solve_NE(csa, dy);
+      /* compute vectors dx and dz */
+      AT_by_vec(csa, dy, dx);
+      for (j = 1; j <= n; j++)
+      {  dx[j] = (x[j] * (dx[j] - q[j]) + r[j]) / z[j];
+         dz[j] = (r[j] - z[j] * dx[j]) / x[j];
       }
       return ret;
 }
 
 /***********************************************************************
-*  NAME
+*  initial_point - choose initial point using Mehrotra's heuristic
 *
-*  glp_asnprob_lp - convert assignment problem to LP
+*  This routine chooses a starting point using a heuristic proposed in
+*  the paper:
 *
-*  SYNOPSIS
+*  S. Mehrotra. On the implementation of a primal-dual interior point
+*  method. SIAM J. on Optim., 2(4), pp. 575-601, 1992.
 *
-*  int glp_asnprob_lp(glp_prob *P, int form, glp_graph *G, int names,
-*     int v_set, int a_cost);
+*  The starting point x in the primal space is chosen as a solution of
+*  the following least squares problem:
+*
+*     minimize    ||x||
+*
+*     subject to  A*x = b
+*
+*  which can be computed explicitly as follows:
+*
+*     x = A'*inv(A*A')*b
+*
+*  Similarly, the starting point (y, z) in the dual space is chosen as
+*  a solution of the following least squares problem:
+*
+*     minimize    ||z||
+*
+*     subject to  A'*y + z = c
+*
+*  which can be computed explicitly as follows:
+*
+*     y = inv(A*A')*A*c
+*
+*     z = c - A'*y
+*
+*  However, some components of the vectors x and z may be non-positive
+*  or close to zero, so the routine uses a Mehrotra's heuristic to find
+*  a more appropriate starting point. */
+
+static void initial_point(struct csa *csa)
+{     int m = csa->m;
+      int n = csa->n;
+      double *b = csa->b;
+      double *c = csa->c;
+      double *x = csa->x;
+      double *y = csa->y;
+      double *z = csa->z;
+      double *D = csa->D;
+      int i, j;
+      double dp, dd, ex, ez, xz;
+      /* factorize A*A' */
+      for (j = 1; j <= n; j++) D[j] = 1.0;
+      decomp_NE(csa);
+      /* x~ = A'*inv(A*A')*b */
+      for (i = 1; i <= m; i++) y[i] = b[i];
+      solve_NE(csa, y);
+      AT_by_vec(csa, y, x);
+      /* y~ = inv(A*A')*A*c */
+      A_by_vec(csa, c, y);
+      solve_NE(csa, y);
+      /* z~ = c - A'*y~ */
+      AT_by_vec(csa, y,z);
+      for (j = 1; j <= n; j++) z[j] = c[j] - z[j];
+      /* use Mehrotra's heuristic in order to choose more appropriate
+         starting point with positive components of vectors x and z */
+      dp = dd = 0.0;
+      for (j = 1; j <= n; j++)
+      {  if (dp < -1.5 * x[j]) dp = -1.5 * x[j];
+         if (dd < -1.5 * z[j]) dd = -1.5 * z[j];
+      }
+      /* note that b = 0 involves x = 0, and c = 0 involves y = 0 and
+         z = 0, so we need to be careful */
+      if (dp == 0.0) dp = 1.5;
+      if (dd == 0.0) dd = 1.5;
+      ex = ez = xz = 0.0;
+      for (j = 1; j <= n; j++)
+      {  ex += (x[j] + dp);
+         ez += (z[j] + dd);
+         xz += (x[j] + dp) * (z[j] + dd);
+      }
+      dp += 0.5 * (xz / ez);
+      dd += 0.5 * (xz / ex);
+      for (j = 1; j <= n; j++)
+      {  x[j] += dp;
+         z[j] += dd;
+         xassert(x[j] > 0.0 && z[j] > 0.0);
+      }
+      return;
+}
+
+/***********************************************************************
+*  basic_info - perform basic computations at the current point
 *
-*  DESCRIPTION
+*  This routine computes the following quantities at the current point:
 *
-*  The routine glp_asnprob_lp builds an LP problem, which corresponds
-*  to the assignment problem on the specified graph G.
+*  1) value of the objective function:
 *
-*  RETURNS
+*     F = c'*x + c[0]
 *
-*  If the LP problem has been successfully built, the routine returns
-*  zero, otherwise, non-zero. */
-
-int glp_asnprob_lp(glp_prob *P, int form, glp_graph *G, int names,
-      int v_set, int a_cost)
-{     glp_vertex *v;
-      glp_arc *a;
-      int i, j, ret, ind[1+2];
-      double cost, val[1+2];
-      if (!(form == GLP_ASN_MIN || form == GLP_ASN_MAX ||
-            form == GLP_ASN_MMP))
-         xerror("glp_asnprob_lp: form = %d; invalid parameter\n",
-            form);
-      if (!(names == GLP_ON || names == GLP_OFF))
-         xerror("glp_asnprob_lp: names = %d; invalid parameter\n",
-            names);
-      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))
-         xerror("glp_asnprob_lp: v_set = %d; invalid offset\n",
-            v_set);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_asnprob_lp: a_cost = %d; invalid offset\n",
-            a_cost);
-      ret = glp_check_asnprob(G, v_set);
-      if (ret != 0) goto done;
-      glp_erase_prob(P);
-      if (names) glp_set_prob_name(P, G->name);
-      glp_set_obj_dir(P, form == GLP_ASN_MIN ? GLP_MIN : GLP_MAX);
-      if (G->nv > 0) glp_add_rows(P, G->nv);
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (names) glp_set_row_name(P, i, v->name);
-         glp_set_row_bnds(P, i, form == GLP_ASN_MMP ? GLP_UP : GLP_FX,
-            1.0, 1.0);
-      }
-      if (G->na > 0) glp_add_cols(P, G->na);
-      for (i = 1, j = 0; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  j++;
-            if (names)
-            {  char name[50+1];
-               sprintf(name, "x[%d,%d]", a->tail->i, a->head->i);
-               xassert(strlen(name) < sizeof(name));
-               glp_set_col_name(P, j, name);
-            }
-            ind[1] = a->tail->i, val[1] = +1.0;
-            ind[2] = a->head->i, val[2] = +1.0;
-            glp_set_mat_col(P, j, 2, ind, val);
-            glp_set_col_bnds(P, j, GLP_DB, 0.0, 1.0);
-            if (a_cost >= 0)
-               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));
-            else
-               cost = 1.0;
-            glp_set_obj_coef(P, j, cost);
-         }
-      }
-      xassert(j == G->na);
-done: return ret;
+*  2) relative primal infeasibility:
+*
+*     rpi = ||A*x-b|| / (1+||b||)
+*
+*  3) relative dual infeasibility:
+*
+*     rdi = ||A'*y+z-c|| / (1+||c||)
+*
+*  4) primal-dual gap (relative difference between the primal and the
+*     dual objective function values):
+*
+*     gap = |c'*x-b'*y| / (1+|c'*x|)
+*
+*  5) merit function:
+*
+*     phi = ||A*x-b|| / max(1,||b||) + ||A'*y+z-c|| / max(1,||c||) +
+*
+*         + |c'*x-b'*y| / max(1,||b||,||c||)
+*
+*  6) duality measure:
+*
+*     mu = x'*z / n
+*
+*  7) the ratio of infeasibility to mu:
+*
+*     rmu = max(||A*x-b||,||A'*y+z-c||) / mu
+*
+*  where ||*|| denotes euclidian norm, *' denotes transposition. */
+
+static void basic_info(struct csa *csa)
+{     int m = csa->m;
+      int n = csa->n;
+      double *b = csa->b;
+      double *c = csa->c;
+      double *x = csa->x;
+      double *y = csa->y;
+      double *z = csa->z;
+      int i, j;
+      double norm1, bnorm, norm2, cnorm, cx, by, *work, temp;
+      /* compute value of the objective function */
+      temp = c[0];
+      for (j = 1; j <= n; j++) temp += c[j] * x[j];
+      csa->obj = temp;
+      /* norm1 = ||A*x-b|| */
+      work = xcalloc(1+m, sizeof(double));
+      A_by_vec(csa, x, work);
+      norm1 = 0.0;
+      for (i = 1; i <= m; i++)
+         norm1 += (work[i] - b[i]) * (work[i] - b[i]);
+      norm1 = sqrt(norm1);
+      xfree(work);
+      /* bnorm = ||b|| */
+      bnorm = 0.0;
+      for (i = 1; i <= m; i++) bnorm += b[i] * b[i];
+      bnorm = sqrt(bnorm);
+      /* compute relative primal infeasibility */
+      csa->rpi = norm1 / (1.0 + bnorm);
+      /* norm2 = ||A'*y+z-c|| */
+      work = xcalloc(1+n, sizeof(double));
+      AT_by_vec(csa, y, work);
+      norm2 = 0.0;
+      for (j = 1; j <= n; j++)
+         norm2 += (work[j] + z[j] - c[j]) * (work[j] + z[j] - c[j]);
+      norm2 = sqrt(norm2);
+      xfree(work);
+      /* cnorm = ||c|| */
+      cnorm = 0.0;
+      for (j = 1; j <= n; j++) cnorm += c[j] * c[j];
+      cnorm = sqrt(cnorm);
+      /* compute relative dual infeasibility */
+      csa->rdi = norm2 / (1.0 + cnorm);
+      /* by = b'*y */
+      by = 0.0;
+      for (i = 1; i <= m; i++) by += b[i] * y[i];
+      /* cx = c'*x */
+      cx = 0.0;
+      for (j = 1; j <= n; j++) cx += c[j] * x[j];
+      /* compute primal-dual gap */
+      csa->gap = fabs(cx - by) / (1.0 + fabs(cx));
+      /* compute merit function */
+      csa->phi = 0.0;
+      csa->phi += norm1 / (bnorm > 1.0 ? bnorm : 1.0);
+      csa->phi += norm2 / (cnorm > 1.0 ? cnorm : 1.0);
+      temp = 1.0;
+      if (temp < bnorm) temp = bnorm;
+      if (temp < cnorm) temp = cnorm;
+      csa->phi += fabs(cx - by) / temp;
+      /* compute duality measure */
+      temp = 0.0;
+      for (j = 1; j <= n; j++) temp += x[j] * z[j];
+      csa->mu = temp / (double)n;
+      /* compute the ratio of infeasibility to mu */
+      csa->rmu = (norm1 > norm2 ? norm1 : norm2) / csa->mu;
+      return;
 }
 
-/**********************************************************************/
+/***********************************************************************
+*  make_step - compute next point using Mehrotra's technique
+*
+*  This routine computes the next point using the predictor-corrector
+*  technique proposed in the paper:
+*
+*  S. Mehrotra. On the implementation of a primal-dual interior point
+*  method. SIAM J. on Optim., 2(4), pp. 575-601, 1992.
+*
+*  At first, the routine computes so called affine scaling (predictor)
+*  direction (dx_aff,dy_aff,dz_aff) which is a solution of the system:
+*
+*     A*dx_aff                       = b - A*x
+*
+*               A'*dy_aff +   dz_aff = c - A'*y - z
+*
+*     Z*dx_aff            + X*dz_aff = - X*Z*e
+*
+*  where (x,y,z) is the current point, X = diag(x[j]), Z = diag(z[j]),
+*  e = (1,...,1)'.
+*
+*  Then, the routine computes the centering parameter sigma, using the
+*  following Mehrotra's heuristic:
+*
+*     alfa_aff_p = inf{0 <= alfa <= 1 | x+alfa*dx_aff >= 0}
+*
+*     alfa_aff_d = inf{0 <= alfa <= 1 | z+alfa*dz_aff >= 0}
+*
+*     mu_aff = (x+alfa_aff_p*dx_aff)'*(z+alfa_aff_d*dz_aff)/n
+*
+*     sigma = (mu_aff/mu)^3
+*
+*  where alfa_aff_p is the maximal stepsize along the affine scaling
+*  direction in the primal space, alfa_aff_d is the maximal stepsize
+*  along the same direction in the dual space.
+*
+*  After determining sigma the routine computes so called centering
+*  (corrector) direction (dx_cc,dy_cc,dz_cc) which is the solution of
+*  the system:
+*
+*     A*dx_cc                     = 0
+*
+*              A'*dy_cc +   dz_cc = 0
+*
+*     Z*dx_cc           + X*dz_cc = sigma*mu*e - X*Z*e
+*
+*  Finally, the routine computes the combined direction
+*
+*     (dx,dy,dz) = (dx_aff,dy_aff,dz_aff) + (dx_cc,dy_cc,dz_cc)
+*
+*  and determines maximal primal and dual stepsizes along the combined
+*  direction:
+*
+*     alfa_max_p = inf{0 <= alfa <= 1 | x+alfa*dx >= 0}
+*
+*     alfa_max_d = inf{0 <= alfa <= 1 | z+alfa*dz >= 0}
+*
+*  In order to prevent the next point to be too close to the boundary
+*  of the positive ortant, the routine decreases maximal stepsizes:
+*
+*     alfa_p = gamma_p * alfa_max_p
+*
+*     alfa_d = gamma_d * alfa_max_d
+*
+*  where gamma_p and gamma_d are scaling factors, and computes the next
+*  point:
+*
+*     x_new = x + alfa_p * dx
+*
+*     y_new = y + alfa_d * dy
+*
+*     z_new = z + alfa_d * dz
+*
+*  which becomes the current point on the next iteration. */
 
-int glp_asnprob_okalg(int form, glp_graph *G, int v_set, int a_cost,
-      double *sol, int a_x)
-{     /* solve assignment problem with out-of-kilter algorithm */
-      glp_vertex *v;
-      glp_arc *a;
-      int nv, na, i, k, *tail, *head, *low, *cap, *cost, *x, *pi, ret;
-      double temp;
-      if (!(form == GLP_ASN_MIN || form == GLP_ASN_MAX ||
-            form == GLP_ASN_MMP))
-         xerror("glp_asnprob_okalg: form = %d; invalid parameter\n",
-            form);
-      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))
-         xerror("glp_asnprob_okalg: v_set = %d; invalid offset\n",
-            v_set);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_asnprob_okalg: a_cost = %d; invalid offset\n",
-            a_cost);
-      if (a_x >= 0 && a_x > G->a_size - (int)sizeof(int))
-         xerror("glp_asnprob_okalg: a_x = %d; invalid offset\n", a_x);
-      if (glp_check_asnprob(G, v_set))
-         return GLP_EDATA;
-      /* nv is the total number of nodes in the resulting network */
-      nv = G->nv + 1;
-      /* na is the total number of arcs in the resulting network */
-      na = G->na + G->nv;
+static int make_step(struct csa *csa)
+{     int m = csa->m;
+      int n = csa->n;
+      double *b = csa->b;
+      double *c = csa->c;
+      double *x = csa->x;
+      double *y = csa->y;
+      double *z = csa->z;
+      double *dx_aff = csa->dx_aff;
+      double *dy_aff = csa->dy_aff;
+      double *dz_aff = csa->dz_aff;
+      double *dx_cc = csa->dx_cc;
+      double *dy_cc = csa->dy_cc;
+      double *dz_cc = csa->dz_cc;
+      double *dx = csa->dx;
+      double *dy = csa->dy;
+      double *dz = csa->dz;
+      int i, j, ret = 0;
+      double temp, gamma_p, gamma_d, *p, *q, *r;
       /* allocate working arrays */
-      tail = xcalloc(1+na, sizeof(int));
-      head = xcalloc(1+na, sizeof(int));
-      low = xcalloc(1+na, sizeof(int));
-      cap = xcalloc(1+na, sizeof(int));
-      cost = xcalloc(1+na, sizeof(int));
-      x = xcalloc(1+na, sizeof(int));
-      pi = xcalloc(1+nv, sizeof(int));
-      /* construct the resulting network */
-      k = 0;
-      /* (original arcs) */
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  k++;
-            tail[k] = a->tail->i;
-            head[k] = a->head->i;
-            low[k] = 0;
-            cap[k] = 1;
-            if (a_cost >= 0)
-               memcpy(&temp, (char *)a->data + a_cost, sizeof(double));
-            else
-               temp = 1.0;
-            if (!(fabs(temp) <= (double)INT_MAX && temp == floor(temp)))
-            {  ret = GLP_EDATA;
-               goto done;
-            }
-            cost[k] = (int)temp;
-            if (form != GLP_ASN_MIN) cost[k] = - cost[k];
-         }
+      p = xcalloc(1+m, sizeof(double));
+      q = xcalloc(1+n, sizeof(double));
+      r = xcalloc(1+n, sizeof(double));
+      /* p = b - A*x */
+      A_by_vec(csa, x, p);
+      for (i = 1; i <= m; i++) p[i] = b[i] - p[i];
+      /* q = c - A'*y - z */
+      AT_by_vec(csa, y,q);
+      for (j = 1; j <= n; j++) q[j] = c[j] - q[j] - z[j];
+      /* r = - X * Z * e */
+      for (j = 1; j <= n; j++) r[j] = - x[j] * z[j];
+      /* solve the first Newtonian system */
+      if (solve_NS(csa, p, q, r, dx_aff, dy_aff, dz_aff))
+      {  ret = 1;
+         goto done;
       }
-      /* (artificial arcs) */
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         k++;
-         if (v->out == NULL)
-            tail[k] = i, head[k] = nv;
-         else if (v->in == NULL)
-            tail[k] = nv, head[k] = i;
-         else
-            xassert(v != v);
-         low[k] = (form == GLP_ASN_MMP ? 0 : 1);
-         cap[k] = 1;
-         cost[k] = 0;
-      }
-      xassert(k == na);
-      /* find minimal-cost circulation in the resulting network */
-      ret = okalg(nv, na, tail, head, low, cap, cost, x, pi);
-      switch (ret)
-      {  case 0:
-            /* optimal circulation found */
-            ret = 0;
-            break;
-         case 1:
-            /* no feasible circulation exists */
-            ret = GLP_ENOPFS;
-            break;
-         case 2:
-            /* integer overflow occured */
-            ret = GLP_ERANGE;
-            goto done;
-         case 3:
-            /* optimality test failed (logic error) */
-            ret = GLP_EFAIL;
-            goto done;
-         default:
-            xassert(ret != ret);
-      }
-      /* store solution components */
-      /* (objective function = the total cost) */
-      if (sol != NULL)
-      {  temp = 0.0;
-         for (k = 1; k <= na; k++)
-            temp += (double)cost[k] * (double)x[k];
-         if (form != GLP_ASN_MIN) temp = - temp;
-         *sol = temp;
-      }
-      /* (arc flows) */
-      if (a_x >= 0)
-      {  k = 0;
-         for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            for (a = v->out; a != NULL; a = a->t_next)
-            {  k++;
-               if (ret == 0)
-                  xassert(x[k] == 0 || x[k] == 1);
-               memcpy((char *)a->data + a_x, &x[k], sizeof(int));
-            }
-         }
+      /* alfa_aff_p = inf{0 <= alfa <= 1 | x + alfa*dx_aff >= 0} */
+      /* alfa_aff_d = inf{0 <= alfa <= 1 | z + alfa*dz_aff >= 0} */
+      csa->alfa_aff_p = csa->alfa_aff_d = 1.0;
+      for (j = 1; j <= n; j++)
+      {  if (dx_aff[j] < 0.0)
+         {  temp = - x[j] / dx_aff[j];
+            if (csa->alfa_aff_p > temp) csa->alfa_aff_p = temp;
+         }
+         if (dz_aff[j] < 0.0)
+         {  temp = - z[j] / dz_aff[j];
+            if (csa->alfa_aff_d > temp) csa->alfa_aff_d = temp;
+         }
+      }
+      /* mu_aff = (x+alfa_aff_p*dx_aff)' * (z+alfa_aff_d*dz_aff) / n */
+      temp = 0.0;
+      for (j = 1; j <= n; j++)
+         temp += (x[j] + csa->alfa_aff_p * dx_aff[j]) *
+                 (z[j] + csa->alfa_aff_d * dz_aff[j]);
+      csa->mu_aff = temp / (double)n;
+      /* sigma = (mu_aff/mu)^3 */
+      temp = csa->mu_aff / csa->mu;
+      csa->sigma = temp * temp * temp;
+      /* p = 0 */
+      for (i = 1; i <= m; i++) p[i] = 0.0;
+      /* q = 0 */
+      for (j = 1; j <= n; j++) q[j] = 0.0;
+      /* r = sigma * mu * e - X * Z * e */
+      for (j = 1; j <= n; j++)
+         r[j] = csa->sigma * csa->mu - dx_aff[j] * dz_aff[j];
+      /* solve the second Newtonian system with the same coefficients
+         but with altered right-hand sides */
+      if (solve_NS(csa, p, q, r, dx_cc, dy_cc, dz_cc))
+      {  ret = 1;
+         goto done;
+      }
+      /* (dx,dy,dz) = (dx_aff,dy_aff,dz_aff) + (dx_cc,dy_cc,dz_cc) */
+      for (j = 1; j <= n; j++) dx[j] = dx_aff[j] + dx_cc[j];
+      for (i = 1; i <= m; i++) dy[i] = dy_aff[i] + dy_cc[i];
+      for (j = 1; j <= n; j++) dz[j] = dz_aff[j] + dz_cc[j];
+      /* alfa_max_p = inf{0 <= alfa <= 1 | x + alfa*dx >= 0} */
+      /* alfa_max_d = inf{0 <= alfa <= 1 | z + alfa*dz >= 0} */
+      csa->alfa_max_p = csa->alfa_max_d = 1.0;
+      for (j = 1; j <= n; j++)
+      {  if (dx[j] < 0.0)
+         {  temp = - x[j] / dx[j];
+            if (csa->alfa_max_p > temp) csa->alfa_max_p = temp;
+         }
+         if (dz[j] < 0.0)
+         {  temp = - z[j] / dz[j];
+            if (csa->alfa_max_d > temp) csa->alfa_max_d = temp;
+         }
+      }
+      /* determine scale factors (not implemented yet) */
+      gamma_p = 0.90;
+      gamma_d = 0.90;
+      /* compute the next point */
+      for (j = 1; j <= n; j++)
+      {  x[j] += gamma_p * csa->alfa_max_p * dx[j];
+         xassert(x[j] > 0.0);
+      }
+      for (i = 1; i <= m; i++)
+         y[i] += gamma_d * csa->alfa_max_d * dy[i];
+      for (j = 1; j <= n; j++)
+      {  z[j] += gamma_d * csa->alfa_max_d * dz[j];
+         xassert(z[j] > 0.0);
       }
 done: /* free working arrays */
-      xfree(tail);
-      xfree(head);
-      xfree(low);
-      xfree(cap);
-      xfree(cost);
-      xfree(x);
-      xfree(pi);
+      xfree(p);
+      xfree(q);
+      xfree(r);
       return ret;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  glp_asnprob_hall - find bipartite matching of maximum cardinality
-*
-*  SYNOPSIS
+*  terminate - deallocate common storage area
 *
-*  int glp_asnprob_hall(glp_graph *G, int v_set, int a_x);
+*  This routine frees all memory allocated to the common storage area
+*  used by interior-point method routines. */
+
+static void terminate(struct csa *csa)
+{     xfree(csa->D);
+      xfree(csa->P);
+      xfree(csa->S_ptr);
+      xfree(csa->S_ind);
+      xfree(csa->S_val);
+      xfree(csa->S_diag);
+      xfree(csa->U_ptr);
+      xfree(csa->U_ind);
+      xfree(csa->U_val);
+      xfree(csa->U_diag);
+      xfree(csa->phi_min);
+      xfree(csa->best_x);
+      xfree(csa->best_y);
+      xfree(csa->best_z);
+      xfree(csa->dx_aff);
+      xfree(csa->dy_aff);
+      xfree(csa->dz_aff);
+      xfree(csa->dx_cc);
+      xfree(csa->dy_cc);
+      xfree(csa->dz_cc);
+      return;
+}
+
+/***********************************************************************
+*  ipm_main - main interior-point method routine
 *
-*  DESCRIPTION
+*  This is a main routine of the primal-dual interior-point method.
 *
-*  The routine glp_asnprob_hall finds a matching of maximal cardinality
-*  in the specified bipartite graph G. It uses a version of the Fortran
-*  routine MC21A developed by I.S.Duff [1], which implements Hall's
-*  algorithm [2].
+*  The routine ipm_main returns one of the following codes:
 *
-*  RETURNS
+*  0 - optimal solution found;
+*  1 - problem has no feasible (primal or dual) solution;
+*  2 - no convergence;
+*  3 - iteration limit exceeded;
+*  4 - numeric instability on solving Newtonian system.
 *
-*  The routine glp_asnprob_hall returns the cardinality of the matching
-*  found. However, if the specified graph is incorrect (as detected by
-*  the routine glp_check_asnprob), the routine returns negative value.
-*
-*  REFERENCES
-*
-*  1. I.S.Duff, Algorithm 575: Permutations for zero-free diagonal, ACM
-*     Trans. on Math. Softw. 7 (1981), 387-390.
-*
-*  2. M.Hall, "An Algorithm for distinct representatives," Amer. Math.
-*     Monthly 63 (1956), 716-717. */
-
-int glp_asnprob_hall(glp_graph *G, int v_set, int a_x)
-{     glp_vertex *v;
-      glp_arc *a;
-      int card, i, k, loc, n, n1, n2, xij;
-      int *num, *icn, *ip, *lenr, *iperm, *pr, *arp, *cv, *out;
-      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))
-         xerror("glp_asnprob_hall: v_set = %d; invalid offset\n",
-            v_set);
-      if (a_x >= 0 && a_x > G->a_size - (int)sizeof(int))
-         xerror("glp_asnprob_hall: a_x = %d; invalid offset\n", a_x);
-      if (glp_check_asnprob(G, v_set))
-         return -1;
-      /* determine the number of vertices in sets R and S and renumber
-         vertices in S which correspond to columns of the matrix; skip
-         all isolated vertices */
-      num = xcalloc(1+G->nv, sizeof(int));
-      n1 = n2 = 0;
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (v->in == NULL && v->out != NULL)
-            n1++, num[i] = 0; /* vertex in R */
-         else if (v->in != NULL && v->out == NULL)
-            n2++, num[i] = n2; /* vertex in S */
+*  In case of non-zero return code the routine returns the best point,
+*  which has been reached during optimization. */
+
+static int ipm_main(struct csa *csa)
+{     int m = csa->m;
+      int n = csa->n;
+      int i, j, status;
+      double temp;
+      /* choose initial point using Mehrotra's heuristic */
+      if (csa->parm->msg_lev >= GLP_MSG_ALL)
+         xprintf("Guessing initial point...\n");
+      initial_point(csa);
+      /* main loop starts here */
+      if (csa->parm->msg_lev >= GLP_MSG_ALL)
+         xprintf("Optimization begins...\n");
+      for (;;)
+      {  /* perform basic computations at the current point */
+         basic_info(csa);
+         /* save initial value of rmu */
+         if (csa->iter == 0) csa->rmu0 = csa->rmu;
+         /* accumulate values of min(phi[k]) and save the best point */
+         xassert(csa->iter <= ITER_MAX);
+         if (csa->iter == 0 || csa->phi_min[csa->iter-1] > csa->phi)
+         {  csa->phi_min[csa->iter] = csa->phi;
+            csa->best_iter = csa->iter;
+            for (j = 1; j <= n; j++) csa->best_x[j] = csa->x[j];
+            for (i = 1; i <= m; i++) csa->best_y[i] = csa->y[i];
+            for (j = 1; j <= n; j++) csa->best_z[j] = csa->z[j];
+            csa->best_obj = csa->obj;
+         }
          else
-         {  xassert(v->in == NULL && v->out == NULL);
-            num[i] = -1; /* isolated vertex */
+            csa->phi_min[csa->iter] = csa->phi_min[csa->iter-1];
+         /* display information at the current point */
+         if (csa->parm->msg_lev >= GLP_MSG_ON)
+            xprintf("%3d: obj = %17.9e; rpi = %8.1e; rdi = %8.1e; gap ="
+               " %8.1e\n", csa->iter, csa->obj, csa->rpi, csa->rdi,
+               csa->gap);
+         /* check if the current point is optimal */
+         if (csa->rpi < 1e-8 && csa->rdi < 1e-8 && csa->gap < 1e-8)
+         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+               xprintf("OPTIMAL SOLUTION FOUND\n");
+            status = 0;
+            break;
          }
-      }
-      /* the matrix must be square, thus, if it has more columns than
-         rows, extra rows will be just empty, and vice versa */
-      n = (n1 >= n2 ? n1 : n2);
-      /* allocate working arrays */
-      icn = xcalloc(1+G->na, sizeof(int));
-      ip = xcalloc(1+n, sizeof(int));
-      lenr = xcalloc(1+n, sizeof(int));
-      iperm = xcalloc(1+n, sizeof(int));
-      pr = xcalloc(1+n, sizeof(int));
-      arp = xcalloc(1+n, sizeof(int));
-      cv = xcalloc(1+n, sizeof(int));
-      out = xcalloc(1+n, sizeof(int));
-      /* build the adjacency matrix of the bipartite graph in row-wise
-         format (rows are vertices in R, columns are vertices in S) */
-      k = 0, loc = 1;
-      for (i = 1; i <= G->nv; i++)
-      {  if (num[i] != 0) continue;
-         /* vertex i in R */
-         ip[++k] = loc;
-         v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  xassert(num[a->head->i] != 0);
-            icn[loc++] = num[a->head->i];
+         /* check if the problem has no feasible solution */
+         temp = 1e5 * csa->phi_min[csa->iter];
+         if (temp < 1e-8) temp = 1e-8;
+         if (csa->phi >= temp)
+         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+               xprintf("PROBLEM HAS NO FEASIBLE PRIMAL/DUAL SOLUTION\n")
+                  ;
+            status = 1;
+            break;
          }
-         lenr[k] = loc - ip[k];
-      }
-      xassert(loc-1 == G->na);
-      /* make all extra rows empty (all extra columns are empty due to
-         the row-wise format used) */
-      for (k++; k <= n; k++)
-         ip[k] = loc, lenr[k] = 0;
-      /* find a row permutation that maximizes the number of non-zeros
-         on the main diagonal */
-      card = mc21a(n, icn, ip, lenr, iperm, pr, arp, cv, out);
-#if 1 /* 18/II-2010 */
-      /* FIXED: if card = n, arp remains clobbered on exit */
-      for (i = 1; i <= n; i++)
-         arp[i] = 0;
-      for (i = 1; i <= card; i++)
-      {  k = iperm[i];
-         xassert(1 <= k && k <= n);
-         xassert(arp[k] == 0);
-         arp[k] = i;
-      }
-#endif
-      /* store solution, if necessary */
-      if (a_x < 0) goto skip;
-      k = 0;
-      for (i = 1; i <= G->nv; i++)
-      {  if (num[i] != 0) continue;
-         /* vertex i in R */
-         k++;
-         v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  /* arp[k] is the number of matched column or zero */
-            if (arp[k] == num[a->head->i])
-            {  xassert(arp[k] != 0);
-               xij = 1;
-            }
-            else
-               xij = 0;
-            memcpy((char *)a->data + a_x, &xij, sizeof(int));
+         /* check for very slow convergence or divergence */
+         if (((csa->rpi >= 1e-8 || csa->rdi >= 1e-8) && csa->rmu /
+               csa->rmu0 >= 1e6) ||
+               (csa->iter >= 30 && csa->phi_min[csa->iter] >= 0.5 *
+               csa->phi_min[csa->iter - 30]))
+         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+               xprintf("NO CONVERGENCE; SEARCH TERMINATED\n");
+            status = 2;
+            break;
          }
+         /* check for maximal number of iterations */
+         if (csa->iter == ITER_MAX)
+         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+               xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
+            status = 3;
+            break;
+         }
+         /* start the next iteration */
+         csa->iter++;
+         /* factorize normal equation system */
+         for (j = 1; j <= n; j++) csa->D[j] = csa->x[j] / csa->z[j];
+         decomp_NE(csa);
+         /* compute the next point using Mehrotra's predictor-corrector
+            technique */
+         if (make_step(csa))
+         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)
+               xprintf("NUMERIC INSTABILITY; SEARCH TERMINATED\n");
+            status = 4;
+            break;
+         }
+      }
+      /* restore the best point */
+      if (status != 0)
+      {  for (j = 1; j <= n; j++) csa->x[j] = csa->best_x[j];
+         for (i = 1; i <= m; i++) csa->y[i] = csa->best_y[i];
+         for (j = 1; j <= n; j++) csa->z[j] = csa->best_z[j];
+         if (csa->parm->msg_lev >= GLP_MSG_ALL)
+            xprintf("Best point %17.9e was reached on iteration %d\n",
+               csa->best_obj, csa->best_iter);
       }
-skip: /* free working arrays */
-      xfree(num);
-      xfree(icn);
-      xfree(ip);
-      xfree(lenr);
-      xfree(iperm);
-      xfree(pr);
-      xfree(arp);
-      xfree(cv);
-      xfree(out);
-      return card;
+      /* return to the calling program */
+      return status;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  glp_cpp - solve critical path problem
+*  ipm_solve - core LP solver based on the interior-point method
 *
 *  SYNOPSIS
 *
-*  double glp_cpp(glp_graph *G, int v_t, int v_es, int v_ls);
+*  #include "glpipm.h"
+*  int ipm_solve(glp_prob *P, const glp_iptcp *parm);
 *
 *  DESCRIPTION
 *
-*  The routine glp_cpp solves the critical path problem represented in
-*  the form of the project network.
+*  The routine ipm_solve is a core LP solver based on the primal-dual
+*  interior-point method.
+*
+*  The routine assumes the following standard formulation of LP problem
+*  to be solved:
+*
+*     minimize
+*
+*        F = c[0] + c[1]*x[1] + c[2]*x[2] + ... + c[n]*x[n]
+*
+*     subject to linear constraints
+*
+*        a[1,1]*x[1] + a[1,2]*x[2] + ... + a[1,n]*x[n] = b[1]
+*
+*        a[2,1]*x[1] + a[2,2]*x[2] + ... + a[2,n]*x[n] = b[2]
+*
+*              . . . . . .
+*
+*        a[m,1]*x[1] + a[m,2]*x[2] + ... + a[m,n]*x[n] = b[m]
+*
+*     and non-negative variables
+*
+*        x[1] >= 0, x[2] >= 0, ..., x[n] >= 0
+*
+*  where:
+*  F                    is the objective function;
+*  x[1], ..., x[n]      are (structural) variables;
+*  c[0]                 is a constant term of the objective function;
+*  c[1], ..., c[n]      are objective coefficients;
+*  a[1,1], ..., a[m,n]  are constraint coefficients;
+*  b[1], ..., b[n]      are right-hand sides.
+*
+*  The solution is three vectors x, y, and z, which are stored by the
+*  routine in the arrays x, y, and z, respectively. These vectors
+*  correspond to the best primal-dual point found during optimization.
+*  They are approximate solution of the following system (which is the
+*  Karush-Kuhn-Tucker optimality conditions):
+*
+*     A*x      = b      (primal feasibility condition)
+*
+*     A'*y + z = c      (dual feasibility condition)
+*
+*     x'*z     = 0      (primal-dual complementarity condition)
+*
+*     x >= 0, z >= 0    (non-negativity condition)
 *
-*  The parameter G is a pointer to the graph object, which specifies
-*  the project network. This graph must be acyclic. Multiple arcs are
-*  allowed being considered as single arcs.
-*
-*  The parameter v_t specifies an offset of the field of type double
-*  in the vertex data block, which contains time t[i] >= 0 needed to
-*  perform corresponding job j. If v_t < 0, it is assumed that t[i] = 1
-*  for all jobs.
-*
-*  The parameter v_es specifies an offset of the field of type double
-*  in the vertex data block, to which the routine stores earliest start
-*  time for corresponding job. If v_es < 0, this time is not stored.
-*
-*  The parameter v_ls specifies an offset of the field of type double
-*  in the vertex data block, to which the routine stores latest start
-*  time for corresponding job. If v_ls < 0, this time is not stored.
+*  where:
+*  x[1], ..., x[n]      are primal (structural) variables;
+*  y[1], ..., y[m]      are dual variables (Lagrange multipliers) for
+*                       equality constraints;
+*  z[1], ..., z[n]      are dual variables (Lagrange multipliers) for
+*                       non-negativity constraints.
 *
 *  RETURNS
 *
-*  The routine glp_cpp returns the minimal project duration, that is,
-*  minimal time needed to perform all jobs in the project. */
-
-static void sorting(glp_graph *G, int list[]);
-
-double glp_cpp(glp_graph *G, int v_t, int v_es, int v_ls)
-{     glp_vertex *v;
-      glp_arc *a;
-      int i, j, k, nv, *list;
-      double temp, total, *t, *es, *ls;
-      if (v_t >= 0 && v_t > G->v_size - (int)sizeof(double))
-         xerror("glp_cpp: v_t = %d; invalid offset\n", v_t);
-      if (v_es >= 0 && v_es > G->v_size - (int)sizeof(double))
-         xerror("glp_cpp: v_es = %d; invalid offset\n", v_es);
-      if (v_ls >= 0 && v_ls > G->v_size - (int)sizeof(double))
-         xerror("glp_cpp: v_ls = %d; invalid offset\n", v_ls);
-      nv = G->nv;
-      if (nv == 0)
-      {  total = 0.0;
-         goto done;
-      }
+*  0  LP has been successfully solved.
+*
+*  GLP_ENOCVG
+*     No convergence.
+*
+*  GLP_EITLIM
+*     Iteration limit exceeded.
+*
+*  GLP_EINSTAB
+*     Numeric instability on solving Newtonian system.
+*
+*  In case of non-zero return code the routine returns the best point,
+*  which has been reached during optimization. */
+
+int ipm_solve(glp_prob *P, const glp_iptcp *parm)
+{     struct csa _dsa, *csa = &_dsa;
+      int m = P->m;
+      int n = P->n;
+      int nnz = P->nnz;
+      GLPROW *row;
+      GLPCOL *col;
+      GLPAIJ *aij;
+      int i, j, loc, ret, *A_ind, *A_ptr;
+      double dir, *A_val, *b, *c, *x, *y, *z;
+      xassert(m > 0);
+      xassert(n > 0);
       /* allocate working arrays */
-      t = xcalloc(1+nv, sizeof(double));
-      es = xcalloc(1+nv, sizeof(double));
-      ls = xcalloc(1+nv, sizeof(double));
-      list = xcalloc(1+nv, sizeof(int));
-      /* retrieve job times */
-      for (i = 1; i <= nv; i++)
-      {  v = G->v[i];
-         if (v_t >= 0)
-         {  memcpy(&t[i], (char *)v->data + v_t, sizeof(double));
-            if (t[i] < 0.0)
-               xerror("glp_cpp: t[%d] = %g; invalid time\n", i, t[i]);
-         }
-         else
-            t[i] = 1.0;
-      }
-      /* perform topological sorting to determine the list of nodes
-         (jobs) such that if list[k] = i and list[kk] = j and there
-         exists arc (i->j), then k < kk */
-      sorting(G, list);
-      /* FORWARD PASS */
-      /* determine earliest start times */
-      for (k = 1; k <= nv; k++)
-      {  j = list[k];
-         es[j] = 0.0;
-         for (a = G->v[j]->in; a != NULL; a = a->h_next)
-         {  i = a->tail->i;
-            /* there exists arc (i->j) in the project network */
-            temp = es[i] + t[i];
-            if (es[j] < temp) es[j] = temp;
-         }
-      }
-      /* determine the minimal project duration */
-      total = 0.0;
-      for (i = 1; i <= nv; i++)
-      {  temp = es[i] + t[i];
-         if (total < temp) total = temp;
-      }
-      /* BACKWARD PASS */
-      /* determine latest start times */
-      for (k = nv; k >= 1; k--)
-      {  i = list[k];
-         ls[i] = total - t[i];
-         for (a = G->v[i]->out; a != NULL; a = a->t_next)
-         {  j = a->head->i;
-            /* there exists arc (i->j) in the project network */
-            temp = ls[j] - t[i];
-            if (ls[i] > temp) ls[i] = temp;
-         }
-         /* avoid possible round-off errors */
-         if (ls[i] < es[i]) ls[i] = es[i];
-      }
-      /* store results, if necessary */
-      if (v_es >= 0)
-      {  for (i = 1; i <= nv; i++)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_es, &es[i], sizeof(double));
-         }
+      A_ptr = xcalloc(1+m+1, sizeof(int));
+      A_ind = xcalloc(1+nnz, sizeof(int));
+      A_val = xcalloc(1+nnz, sizeof(double));
+      b = xcalloc(1+m, sizeof(double));
+      c = xcalloc(1+n, sizeof(double));
+      x = xcalloc(1+n, sizeof(double));
+      y = xcalloc(1+m, sizeof(double));
+      z = xcalloc(1+n, sizeof(double));
+      /* prepare rows and constraint coefficients */
+      loc = 1;
+      for (i = 1; i <= m; i++)
+      {  row = P->row[i];
+         xassert(row->type == GLP_FX);
+         b[i] = row->lb * row->rii;
+         A_ptr[i] = loc;
+         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+         {  A_ind[loc] = aij->col->j;
+            A_val[loc] = row->rii * aij->val * aij->col->sjj;
+            loc++;
+         }
+      }
+      A_ptr[m+1] = loc;
+      xassert(loc-1 == nnz);
+      /* prepare columns and objective coefficients */
+      if (P->dir == GLP_MIN)
+         dir = +1.0;
+      else if (P->dir == GLP_MAX)
+         dir = -1.0;
+      else
+         xassert(P != P);
+      c[0] = dir * P->c0;
+      for (j = 1; j <= n; j++)
+      {  col = P->col[j];
+         xassert(col->type == GLP_LO && col->lb == 0.0);
+         c[j] = dir * col->coef * col->sjj;
+      }
+      /* allocate and initialize the common storage area */
+      csa->m = m;
+      csa->n = n;
+      csa->A_ptr = A_ptr;
+      csa->A_ind = A_ind;
+      csa->A_val = A_val;
+      csa->b = b;
+      csa->c = c;
+      csa->x = x;
+      csa->y = y;
+      csa->z = z;
+      csa->parm = parm;
+      initialize(csa);
+      /* solve LP with the interior-point method */
+      ret = ipm_main(csa);
+      /* deallocate the common storage area */
+      terminate(csa);
+      /* determine solution status */
+      if (ret == 0)
+      {  /* optimal solution found */
+         P->ipt_stat = GLP_OPT;
+         ret = 0;
+      }
+      else if (ret == 1)
+      {  /* problem has no feasible (primal or dual) solution */
+         P->ipt_stat = GLP_NOFEAS;
+         ret = 0;
+      }
+      else if (ret == 2)
+      {  /* no convergence */
+         P->ipt_stat = GLP_INFEAS;
+         ret = GLP_ENOCVG;
+      }
+      else if (ret == 3)
+      {  /* iteration limit exceeded */
+         P->ipt_stat = GLP_INFEAS;
+         ret = GLP_EITLIM;
+      }
+      else if (ret == 4)
+      {  /* numeric instability on solving Newtonian system */
+         P->ipt_stat = GLP_INFEAS;
+         ret = GLP_EINSTAB;
       }
-      if (v_ls >= 0)
-      {  for (i = 1; i <= nv; i++)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_ls, &ls[i], sizeof(double));
-         }
+      else
+         xassert(ret != ret);
+      /* store row solution components */
+      for (i = 1; i <= m; i++)
+      {  row = P->row[i];
+         row->pval = row->lb;
+         row->dval = dir * y[i] * row->rii;
+      }
+      /* store column solution components */
+      P->ipt_obj = P->c0;
+      for (j = 1; j <= n; j++)
+      {  col = P->col[j];
+         col->pval = x[j] * col->sjj;
+         col->dval = dir * z[j] / col->sjj;
+         P->ipt_obj += col->coef * col->pval;
       }
       /* free working arrays */
-      xfree(t);
-      xfree(es);
-      xfree(ls);
-      xfree(list);
-done: return total;
-}
-
-static void sorting(glp_graph *G, int list[])
-{     /* perform topological sorting to determine the list of nodes
-         (jobs) such that if list[k] = i and list[kk] = j and there
-         exists arc (i->j), then k < kk */
-      int i, k, nv, v_size, *num;
-      void **save;
-      nv = G->nv;
-      v_size = G->v_size;
-      save = xcalloc(1+nv, sizeof(void *));
-      num = xcalloc(1+nv, sizeof(int));
-      G->v_size = sizeof(int);
-      for (i = 1; i <= nv; i++)
-      {  save[i] = G->v[i]->data;
-         G->v[i]->data = &num[i];
-         list[i] = 0;
-      }
-      if (glp_top_sort(G, 0) != 0)
-         xerror("glp_cpp: project network is not acyclic\n");
-      G->v_size = v_size;
-      for (i = 1; i <= nv; i++)
-      {  G->v[i]->data = save[i];
-         k = num[i];
-         xassert(1 <= k && k <= nv);
-         xassert(list[k] == 0);
-         list[k] = i;
-      }
-      xfree(save);
-      xfree(num);
-      return;
+      xfree(A_ptr);
+      xfree(A_ind);
+      xfree(A_val);
+      xfree(b);
+      xfree(c);
+      xfree(x);
+      xfree(y);
+      xfree(z);
+      return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi18.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/wcliqex.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi18.c (maximum clique problem) */
+/* wcliqex.c (find maximum weight clique with exact algorithm) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,17 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpapi.h"
-#include "glpnet.h"
+#include "env.h"
+#include "glpk.h"
+#include "wclique.h"
 
 static void set_edge(int nv, unsigned char a[], int i, int j)
 {     int k;
       xassert(1 <= j && j < i && i <= nv);
       k = ((i - 1) * (i - 2)) / 2 + (j - 1);
       a[k / CHAR_BIT] |=
          (unsigned char)(1 << ((CHAR_BIT - 1) - k % CHAR_BIT));
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpapi19.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/cplex.c`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpapi19.c (stand-alone LP/MIP solver) */
+/* cplex.c (CPLEX LP format routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,1184 +15,1267 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
+#include "env.h"
+#include "misc.h"
+#include "prob.h"
+
+#define xfprintf glp_format
+
+/***********************************************************************
+*  NAME
+*
+*  glp_init_cpxcp - initialize CPLEX LP format control parameters
+*
+*  SYNOPSIS
+*
+*  void glp_init_cpxcp(glp_cpxcp *parm):
+*
+*  The routine glp_init_cpxcp initializes control parameters used by
+*  the CPLEX LP input/output routines glp_read_lp and glp_write_lp with
+*  default values.
+*
+*  Default values of the control parameters are stored in the glp_cpxcp
+*  structure, which the parameter parm points to. */
+
+void glp_init_cpxcp(glp_cpxcp *parm)
+{     xassert(parm != NULL);
+      return;
+}
 
-#include "glpapi.h"
-#include "glpgmp.h"
+static void check_parm(const char *func, const glp_cpxcp *parm)
+{     /* check control parameters */
+      xassert(func != NULL);
+      xassert(parm != NULL);
+      return;
+}
+
+/***********************************************************************
+*  NAME
+*
+*  glp_read_lp - read problem data in CPLEX LP format
+*
+*  SYNOPSIS
+*
+*  int glp_read_lp(glp_prob *P, const glp_cpxcp *parm, const char
+*     *fname);
+*
+*  DESCRIPTION
+*
+*  The routine glp_read_lp reads problem data in CPLEX LP format from
+*  a text file.
+*
+*  The parameter parm is a pointer to the structure glp_cpxcp, which
+*  specifies control parameters used by the routine. If parm is NULL,
+*  the routine uses default settings.
+*
+*  The character string fname specifies a name of the text file to be
+*  read.
+*
+*  Note that before reading data the current content of the problem
+*  object is completely erased with the routine glp_erase_prob.
+*
+*  RETURNS
+*
+*  If the operation was successful, the routine glp_read_lp returns
+*  zero. Otherwise, it prints an error message and returns non-zero. */
 
 struct csa
 {     /* common storage area */
-      glp_prob *prob;
+      glp_prob *P;
       /* LP/MIP problem object */
-      glp_bfcp bfcp;
-      /* basis factorization control parameters */
-      glp_smcp smcp;
-      /* simplex method control parameters */
-      glp_iptcp iptcp;
-      /* interior-point method control parameters */
-      glp_iocp iocp;
-      /* integer optimizer control parameters */
-      glp_tran *tran;
-      /* model translator workspace */
-      glp_graph *graph;
-      /* network problem object */
-      int format;
-      /* problem file format: */
-#define FMT_MPS_DECK    1  /* fixed MPS */
-#define FMT_MPS_FILE    2  /* free MPS */
-#define FMT_LP          3  /* CPLEX LP */
-#define FMT_GLP         4  /* GLPK LP/MIP */
-#define FMT_MATHPROG    5  /* MathProg */
-#define FMT_MIN_COST    6  /* DIMACS min-cost flow */
-#define FMT_MAX_FLOW    7  /* DIMACS maximum flow */
-      const char *in_file;
-      /* name of input problem file */
-#define DATA_MAX 10
-      /* maximal number of input data files */
-      int ndf;
-      /* number of input data files specified */
-      const char *in_data[1+DATA_MAX];
-      /* name(s) of input data file(s) */
-      const char *out_dpy;
-      /* name of output file to send display output; NULL means the
-         display output is sent to the terminal */
-      int seed;
-      /* seed value to be passed to the MathProg translator; initially
-         set to 1; 0x80000000 means the value is omitted */
-      int solution;
-      /* solution type flag: */
-#define SOL_BASIC       1  /* basic */
-#define SOL_INTERIOR    2  /* interior-point */
-#define SOL_INTEGER     3  /* mixed integer */
-      const char *in_res;
-      /* name of input solution file in raw format */
-      int dir;
-      /* optimization direction flag:
-         0       - not specified
-         GLP_MIN - minimization
-         GLP_MAX - maximization */
-      int scale;
-      /* automatic problem scaling flag */
-      const char *out_sol;
-      /* name of output solution file in printable format */
-      const char *out_res;
-      /* name of output solution file in raw format */
-      const char *out_ranges;
-      /* name of output file to write sensitivity analysis report */
-      int check;
-      /* input data checking flag; no solution is performed */
-      const char *new_name;
-      /* new name to be assigned to the problem */
-      const char *out_mps;
-      /* name of output problem file in fixed MPS format */
-      const char *out_freemps;
-      /* name of output problem file in free MPS format */
-      const char *out_cpxlp;
-      /* name of output problem file in CPLEX LP format */
-      const char *out_glp;
-      /* name of output problem file in GLPK format */
-      const char *out_pb;
-      /* name of output problem file in OPB format */
-      const char *out_npb;
-      /* name of output problem file in normalized OPB format */
-      const char *log_file;
-      /* name of output file to hardcopy terminal output */
-      int crash;
-      /* initial basis option: */
-#define USE_STD_BASIS   1  /* use standard basis */
-#define USE_ADV_BASIS   2  /* use advanced basis */
-#define USE_CPX_BASIS   3  /* use Bixby's basis */
-#define USE_INI_BASIS   4  /* use initial basis from ini_file */
-      const char *ini_file;
-      /* name of input file containing initial basis */
-      int exact;
-      /* flag to use glp_exact rather than glp_simplex */
-      int xcheck;
-      /* flag to check final basis with glp_exact */
-      int nomip;
-      /* flag to consider MIP as pure LP */
+      const glp_cpxcp *parm;
+      /* pointer to control parameters */
+      const char *fname;
+      /* name of input CPLEX LP file */
+      glp_file *fp;
+      /* stream assigned to input CPLEX LP file */
+      jmp_buf jump;
+      /* label for go to in case of error */
+      int count;
+      /* line count */
+      int c;
+      /* current character or EOF */
+      int token;
+      /* current token: */
+#define T_EOF        0x00  /* end of file */
+#define T_MINIMIZE   0x01  /* keyword 'minimize' */
+#define T_MAXIMIZE   0x02  /* keyword 'maximize' */
+#define T_SUBJECT_TO 0x03  /* keyword 'subject to' */
+#define T_BOUNDS     0x04  /* keyword 'bounds' */
+#define T_GENERAL    0x05  /* keyword 'general' */
+#define T_INTEGER    0x06  /* keyword 'integer' */
+#define T_BINARY     0x07  /* keyword 'binary' */
+#define T_END        0x08  /* keyword 'end' */
+#define T_NAME       0x09  /* symbolic name */
+#define T_NUMBER     0x0A  /* numeric constant */
+#define T_PLUS       0x0B  /* delimiter '+' */
+#define T_MINUS      0x0C  /* delimiter '-' */
+#define T_COLON      0x0D  /* delimiter ':' */
+#define T_LE         0x0E  /* delimiter '<=' */
+#define T_GE         0x0F  /* delimiter '>=' */
+#define T_EQ         0x10  /* delimiter '=' */
+      char image[255+1];
+      /* image of current token */
+      int imlen;
+      /* length of token image */
+      double value;
+      /* value of numeric constant */
+      int n_max;
+      /* length of the following five arrays (enlarged automatically,
+         if necessary) */
+      int *ind; /* int ind[1+n_max]; */
+      double *val; /* double val[1+n_max]; */
+      char *flag; /* char flag[1+n_max]; */
+      /* working arrays used to construct linear forms */
+      double *lb; /* double lb[1+n_max]; */
+      double *ub; /* double ub[1+n_max]; */
+      /* lower and upper bounds of variables (columns) */
+#if 1 /* 27/VII-2013 */
+      int lb_warn, ub_warn;
+      /* warning 'lower/upper bound redefined' already issued */
+#endif
 };
 
-static void print_help(const char *my_name)
-{     /* print help information */
-      xprintf("Usage: %s [options...] filename\n", my_name);
-      xprintf("\n");
-      xprintf("General options:\n");
-      xprintf("   --mps             read LP/MIP problem in fixed MPS fo"
-         "rmat\n");
-      xprintf("   --freemps         read LP/MIP problem in free MPS for"
-         "mat (default)\n");
-      xprintf("   --lp              read LP/MIP problem in CPLEX LP for"
-         "mat\n");
-      xprintf("   --glp             read LP/MIP problem in GLPK format "
-         "\n");
-      xprintf("   --math            read LP/MIP model written in GNU Ma"
-         "thProg modeling\n");
-      xprintf("                     language\n");
-      xprintf("   -m filename, --model filename\n");
-      xprintf("                     read model section and optional dat"
-         "a section from\n");
-      xprintf("                     filename (same as --math)\n");
-      xprintf("   -d filename, --data filename\n");
-      xprintf("                     read data section from filename (fo"
-         "r --math only);\n");
-      xprintf("                     if model file also has data section"
-         ", it is ignored\n");
-      xprintf("   -y filename, --display filename\n");
-      xprintf("                     send display output to filename (fo"
-         "r --math only);\n");
-      xprintf("                     by default the output is sent to te"
-         "rminal\n");
-      xprintf("   --seed value      initialize pseudo-random number gen"
-         "erator used in\n");
-      xprintf("                     MathProg model with specified seed "
-         "(any integer);\n");
-      xprintf("                     if seed value is ?, some random see"
-         "d will be used\n");
-      xprintf("   --mincost         read min-cost flow problem in DIMAC"
-         "S format\n");
-      xprintf("   --maxflow         read maximum flow problem in DIMACS"
-         " format\n");
-      xprintf("   --simplex         use simplex method (default)\n");
-      xprintf("   --interior        use interior point method (LP only)"
-         "\n");
-      xprintf("   -r filename, --read filename\n");
-      xprintf("                     read solution from filename rather "
-         "to find it with\n");
-      xprintf("                     the solver\n");
-      xprintf("   --min             minimization\n");
-      xprintf("   --max             maximization\n");
-      xprintf("   --scale           scale problem (default)\n");
-      xprintf("   --noscale         do not scale problem\n");
-      xprintf("   -o filename, --output filename\n");
-      xprintf("                     write solution to filename in print"
-         "able format\n");
-      xprintf("   -w filename, --write filename\n");
-      xprintf("                     write solution to filename in plain"
-         " text format\n");
-      xprintf("   --ranges filename\n");
-      xprintf("                     write sensitivity analysis report t"
-         "o filename in\n");
-      xprintf("                     printable format (simplex only)\n");
-      xprintf("   --tmlim nnn       limit solution time to nnn seconds "
-         "\n");
-      xprintf("   --memlim nnn      limit available memory to nnn megab"
-         "ytes\n");
-      xprintf("   --check           do not solve problem, check input d"
-         "ata only\n");
-      xprintf("   --name probname   change problem name to probname\n");
-      xprintf("   --wmps filename   write problem to filename in fixed "
-         "MPS format\n");
-      xprintf("   --wfreemps filename\n");
-      xprintf("                     write problem to filename in free M"
-         "PS format\n");
-      xprintf("   --wlp filename    write problem to filename in CPLEX "
-         "LP format\n");
-      xprintf("   --wglp filename   write problem to filename in GLPK f"
-         "ormat\n");
-#if 0
-      xprintf("   --wpb filename    write problem to filename in OPB fo"
-         "rmat\n");
-      xprintf("   --wnpb filename   write problem to filename in normal"
-         "ized OPB format\n");
-#endif
-      xprintf("   --log filename    write copy of terminal output to fi"
-         "lename\n");
-      xprintf("   -h, --help        display this help information and e"
-         "xit\n");
-      xprintf("   -v, --version     display program version and exit\n")
-         ;
-      xprintf("\n");
-      xprintf("LP basis factorization options:\n");
-      xprintf("   --luf             LU + Forrest-Tomlin update\n");
-      xprintf("                     (faster, less stable; default)\n");
-      xprintf("   --cbg             LU + Schur complement + Bartels-Gol"
-         "ub update\n");
-      xprintf("                     (slower, more stable)\n");
-      xprintf("   --cgr             LU + Schur complement + Givens rota"
-         "tion update\n");
-      xprintf("                     (slower, more stable)\n");
-      xprintf("\n");
-      xprintf("Options specific to simplex solver:\n");
-      xprintf("   --primal          use primal simplex (default)\n");
-      xprintf("   --dual            use dual simplex\n");
-      xprintf("   --std             use standard initial basis of all s"
-         "lacks\n");
-      xprintf("   --adv             use advanced initial basis (default"
-         ")\n");
-      xprintf("   --bib             use Bixby's initial basis\n");
-      xprintf("   --ini filename    use as initial basis previously sav"
-         "ed with -w\n");
-      xprintf("                     (disables LP presolver)\n");
-      xprintf("   --steep           use steepest edge technique (defaul"
-         "t)\n");
-      xprintf("   --nosteep         use standard \"textbook\" pricing\n"
-         );
-      xprintf("   --relax           use Harris' two-pass ratio test (de"
-         "fault)\n");
-      xprintf("   --norelax         use standard \"textbook\" ratio tes"
-         "t\n");
-      xprintf("   --presol          use presolver (default; assumes --s"
-         "cale and --adv)\n");
-      xprintf("   --nopresol        do not use presolver\n");
-      xprintf("   --exact           use simplex method based on exact a"
-         "rithmetic\n");
-      xprintf("   --xcheck          check final basis using exact arith"
-         "metic\n");
-      xprintf("\n");
-      xprintf("Options specific to interior-point solver:\n");
-      xprintf("   --nord            use natural (original) ordering\n");
-      xprintf("   --qmd             use quotient minimum degree orderin"
-         "g\n");
-      xprintf("   --amd             use approximate minimum degree orde"
-         "ring (default)\n");
-      xprintf("   --symamd          use approximate minimum degree orde"
-         "ring\n");
-      xprintf("\n");
-      xprintf("Options specific to MIP solver:\n");
-      xprintf("   --nomip           consider all integer variables as c"
-         "ontinuous\n");
-      xprintf("                     (allows solving MIP as pure LP)\n");
-      xprintf("   --first           branch on first integer variable\n")
-         ;
-      xprintf("   --last            branch on last integer variable\n");
-      xprintf("   --mostf           branch on most fractional variable "
-         "\n");
-      xprintf("   --drtom           branch using heuristic by Driebeck "
-         "and Tomlin\n");
-      xprintf("                     (default)\n");
-      xprintf("   --pcost           branch using hybrid pseudocost heur"
-         "istic (may be\n");
-      xprintf("                     useful for hard instances)\n");
-      xprintf("   --dfs             backtrack using depth first search "
-         "\n");
-      xprintf("   --bfs             backtrack using breadth first searc"
-         "h\n");
-      xprintf("   --bestp           backtrack using the best projection"
-         " heuristic\n");
-      xprintf("   --bestb           backtrack using node with best loca"
-         "l bound\n");
-      xprintf("                     (default)\n");
-      xprintf("   --intopt          use MIP presolver (default)\n");
-      xprintf("   --nointopt        do not use MIP presolver\n");
-      xprintf("   --binarize        replace general integer variables b"
-         "y binary ones\n");
-      xprintf("                     (assumes --intopt)\n");
-      xprintf("   --fpump           apply feasibility pump heuristic\n")
-         ;
-      xprintf("   --gomory          generate Gomory's mixed integer cut"
-         "s\n");
-      xprintf("   --mir             generate MIR (mixed integer roundin"
-         "g) cuts\n");
-      xprintf("   --cover           generate mixed cover cuts\n");
-      xprintf("   --clique          generate clique cuts\n");
-      xprintf("   --cuts            generate all cuts above\n");
-      xprintf("   --mipgap tol      set relative mip gap tolerance to t"
-         "ol\n");
-      xprintf("\n");
-      xprintf("For description of the MPS and CPLEX LP formats see Refe"
-         "rence Manual.\n");
-      xprintf("For description of the modeling language see \"GLPK: Mod"
-         "eling Language\n");
-      xprintf("GNU MathProg\". Both documents are included in the GLPK "
-         "distribution.\n");
-      xprintf("\n");
-      xprintf("See GLPK web page at <http://www.gnu.org/software/glpk/g"
-         "lpk.html>.\n");
-      xprintf("\n");
-      xprintf("Please report bugs to <bug-glpk@gnu.org>.\n");
-      return;
+#define CHAR_SET "!\"#$%&()/,.;?@_`'{}|~"
+/* characters that may appear in symbolic names */
+
+static void error(struct csa *csa, const char *fmt, ...)
+{     /* print error message and terminate processing */
+      va_list arg;
+      xprintf("%s:%d: ", csa->fname, csa->count);
+      va_start(arg, fmt);
+      xvprintf(fmt, arg);
+      va_end(arg);
+      longjmp(csa->jump, 1);
+      /* no return */
 }
 
-static void print_version(int briefly)
-{     /* print version information */
-      xprintf("GLPSOL: GLPK LP/MIP Solver, v%s\n", glp_version());
-      if (briefly) goto done;
-      xprintf("\n");
-      xprintf("Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, "
-         "2007, 2008,\n");
-      xprintf("2009, 2010 Andrew Makhorin, Department for Applied Infor"
-         "matics, Moscow\n");
-      xprintf("Aviation Institute, Moscow, Russia. All rights reserved."
-         "\n");
-      xprintf("\n");
-      xprintf("This program has ABSOLUTELY NO WARRANTY.\n");
-      xprintf("\n");
-      xprintf("This program is free software; you may re-distribute it "
-         "under the terms\n");
-      xprintf("of the GNU General Public License version 3 or later.\n")
-         ;
-done: return;
+static void warning(struct csa *csa, const char *fmt, ...)
+{     /* print warning message and continue processing */
+      va_list arg;
+      xprintf("%s:%d: warning: ", csa->fname, csa->count);
+      va_start(arg, fmt);
+      xvprintf(fmt, arg);
+      va_end(arg);
+      return;
 }
 
-static int parse_cmdline(struct csa *csa, int argc, const char *argv[])
-{     /* parse command-line parameters */
-      int k;
-#define p(str) (strcmp(argv[k], str) == 0)
-      for (k = 1; k < argc; k++)
-      {  if (p("--mps"))
-            csa->format = FMT_MPS_DECK;
-         else if (p("--freemps"))
-            csa->format = FMT_MPS_FILE;
-         else if (p("--lp") || p("--cpxlp"))
-            csa->format = FMT_LP;
-         else if (p("--glp"))
-            csa->format = FMT_GLP;
-         else if (p("--math") || p("-m") || p("--model"))
-            csa->format = FMT_MATHPROG;
-         else if (p("-d") || p("--data"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No input data file specified\n");
-               return 1;
-            }
-            if (csa->ndf == DATA_MAX)
-            {  xprintf("Too many input data files\n");
-               return 1;
-            }
-            csa->in_data[++(csa->ndf)] = argv[k];
+static void read_char(struct csa *csa)
+{     /* read next character from input file */
+      int c;
+      xassert(csa->c != EOF);
+      if (csa->c == '\n') csa->count++;
+      c = glp_getc(csa->fp);
+      if (c < 0)
+      {  if (glp_ioerr(csa->fp))
+            error(csa, "read error - %s\n", get_err_msg());
+         else if (csa->c == '\n')
+         {  csa->count--;
+            c = EOF;
          }
-         else if (p("-y") || p("--display"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No display output file specified\n");
-               return 1;
-            }
-            if (csa->out_dpy != NULL)
-            {  xprintf("Only one display output file allowed\n");
-               return 1;
-            }
-            csa->out_dpy = argv[k];
-         }
-         else if (p("--seed"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' ||
-               argv[k][0] == '-' && !isdigit((unsigned char)argv[k][1]))
-            {  xprintf("No seed value specified\n");
-               return 1;
-            }
-            if (strcmp(argv[k], "?") == 0)
-               csa->seed = 0x80000000;
-            else if (str2int(argv[k], &csa->seed))
-            {  xprintf("Invalid seed value `%s'\n", argv[k]);
-               return 1;
-            }
-         }
-         else if (p("--mincost"))
-            csa->format = FMT_MIN_COST;
-         else if (p("--maxflow"))
-            csa->format = FMT_MAX_FLOW;
-         else if (p("--simplex"))
-            csa->solution = SOL_BASIC;
-         else if (p("--interior"))
-            csa->solution = SOL_INTERIOR;
-#if 1 /* 28/V-2010 */
-         else if (p("--alien"))
-            csa->iocp.alien = GLP_ON;
-#endif
-         else if (p("-r") || p("--read"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No input solution file specified\n");
-               return 1;
-            }
-            if (csa->in_res != NULL)
-            {  xprintf("Only one input solution file allowed\n");
-               return 1;
-            }
-            csa->in_res = argv[k];
+         else
+         {  warning(csa, "missing final end of line\n");
+            c = '\n';
          }
-         else if (p("--min"))
-            csa->dir = GLP_MIN;
-         else if (p("--max"))
-            csa->dir = GLP_MAX;
-         else if (p("--scale"))
-            csa->scale = 1;
-         else if (p("--noscale"))
-            csa->scale = 0;
-         else if (p("-o") || p("--output"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No output solution file specified\n");
-               return 1;
+      }
+      else if (c == '\n')
+         ;
+      else if (isspace(c))
+         c = ' ';
+      else if (iscntrl(c))
+         error(csa, "invalid control character 0x%02X\n", c);
+      csa->c = c;
+      return;
+}
+
+static void add_char(struct csa *csa)
+{     /* append current character to current token */
+      if (csa->imlen == sizeof(csa->image)-1)
+         error(csa, "token '%.15s...' too long\n", csa->image);
+      csa->image[csa->imlen++] = (char)csa->c;
+      csa->image[csa->imlen] = '\0';
+      read_char(csa);
+      return;
+}
+
+static int the_same(char *s1, char *s2)
+{     /* compare two character strings ignoring case sensitivity */
+      for (; *s1 != '\0'; s1++, s2++)
+      {  if (tolower((unsigned char)*s1) != tolower((unsigned char)*s2))
+            return 0;
+      }
+      return 1;
+}
+
+static void scan_token(struct csa *csa)
+{     /* scan next token */
+      int flag;
+      csa->token = -1;
+      csa->image[0] = '\0';
+      csa->imlen = 0;
+      csa->value = 0.0;
+loop: flag = 0;
+      /* skip non-significant characters */
+      while (csa->c == ' ') read_char(csa);
+      /* recognize and scan current token */
+      if (csa->c == EOF)
+         csa->token = T_EOF;
+      else if (csa->c == '\n')
+      {  read_char(csa);
+         /* if the next character is letter, it may begin a keyword */
+         if (isalpha(csa->c))
+         {  flag = 1;
+            goto name;
+         }
+         goto loop;
+      }
+      else if (csa->c == '\\')
+      {  /* comment; ignore everything until end-of-line */
+         while (csa->c != '\n') read_char(csa);
+         goto loop;
+      }
+      else if (isalpha(csa->c) || csa->c != '.' && strchr(CHAR_SET,
+         csa->c) != NULL)
+name: {  /* symbolic name */
+         csa->token = T_NAME;
+         while (isalnum(csa->c) || strchr(CHAR_SET, csa->c) != NULL)
+            add_char(csa);
+         if (flag)
+         {  /* check for keyword */
+            if (the_same(csa->image, "minimize"))
+               csa->token = T_MINIMIZE;
+            else if (the_same(csa->image, "minimum"))
+               csa->token = T_MINIMIZE;
+            else if (the_same(csa->image, "min"))
+               csa->token = T_MINIMIZE;
+            else if (the_same(csa->image, "maximize"))
+               csa->token = T_MAXIMIZE;
+            else if (the_same(csa->image, "maximum"))
+               csa->token = T_MAXIMIZE;
+            else if (the_same(csa->image, "max"))
+               csa->token = T_MAXIMIZE;
+            else if (the_same(csa->image, "subject"))
+            {  if (csa->c == ' ')
+               {  read_char(csa);
+                  if (tolower(csa->c) == 't')
+                  {  csa->token = T_SUBJECT_TO;
+                     csa->image[csa->imlen++] = ' ';
+                     csa->image[csa->imlen] = '\0';
+                     add_char(csa);
+                     if (tolower(csa->c) != 'o')
+                        error(csa, "keyword 'subject to' incomplete\n");
+                     add_char(csa);
+                     if (isalpha(csa->c))
+                        error(csa, "keyword '%s%c...' not recognized\n",
+                           csa->image, csa->c);
+                  }
+               }
             }
-            if (csa->out_sol != NULL)
-            {  xprintf("Only one output solution file allowed\n");
-               return 1;
+            else if (the_same(csa->image, "such"))
+            {  if (csa->c == ' ')
+               {  read_char(csa);
+                  if (tolower(csa->c) == 't')
+                  {  csa->token = T_SUBJECT_TO;
+                     csa->image[csa->imlen++] = ' ';
+                     csa->image[csa->imlen] = '\0';
+                     add_char(csa);
+                     if (tolower(csa->c) != 'h')
+err:                    error(csa, "keyword 'such that' incomplete\n");
+                     add_char(csa);
+                     if (tolower(csa->c) != 'a') goto err;
+                     add_char(csa);
+                     if (tolower(csa->c) != 't') goto err;
+                     add_char(csa);
+                     if (isalpha(csa->c))
+                        error(csa, "keyword '%s%c...' not recognized\n",
+                           csa->image, csa->c);
+                  }
+               }
             }
-            csa->out_sol = argv[k];
+            else if (the_same(csa->image, "st"))
+               csa->token = T_SUBJECT_TO;
+            else if (the_same(csa->image, "s.t."))
+               csa->token = T_SUBJECT_TO;
+            else if (the_same(csa->image, "st."))
+               csa->token = T_SUBJECT_TO;
+            else if (the_same(csa->image, "bounds"))
+               csa->token = T_BOUNDS;
+            else if (the_same(csa->image, "bound"))
+               csa->token = T_BOUNDS;
+            else if (the_same(csa->image, "general"))
+               csa->token = T_GENERAL;
+            else if (the_same(csa->image, "generals"))
+               csa->token = T_GENERAL;
+            else if (the_same(csa->image, "gen"))
+               csa->token = T_GENERAL;
+            else if (the_same(csa->image, "integer"))
+               csa->token = T_INTEGER;
+            else if (the_same(csa->image, "integers"))
+               csa->token = T_INTEGER;
+            else if (the_same(csa->image, "int"))
+              csa->token = T_INTEGER;
+            else if (the_same(csa->image, "binary"))
+               csa->token = T_BINARY;
+            else if (the_same(csa->image, "binaries"))
+               csa->token = T_BINARY;
+            else if (the_same(csa->image, "bin"))
+               csa->token = T_BINARY;
+            else if (the_same(csa->image, "end"))
+               csa->token = T_END;
+         }
+      }
+      else if (isdigit(csa->c) || csa->c == '.')
+      {  /* numeric constant */
+         csa->token = T_NUMBER;
+         /* scan integer part */
+         while (isdigit(csa->c)) add_char(csa);
+         /* scan optional fractional part (it is mandatory, if there is
+            no integer part) */
+         if (csa->c == '.')
+         {  add_char(csa);
+            if (csa->imlen == 1 && !isdigit(csa->c))
+               error(csa, "invalid use of decimal point\n");
+            while (isdigit(csa->c)) add_char(csa);
+         }
+         /* scan optional decimal exponent */
+         if (csa->c == 'e' || csa->c == 'E')
+         {  add_char(csa);
+            if (csa->c == '+' || csa->c == '-') add_char(csa);
+            if (!isdigit(csa->c))
+               error(csa, "numeric constant '%s' incomplete\n",
+                  csa->image);
+            while (isdigit(csa->c)) add_char(csa);
+         }
+         /* convert the numeric constant to floating-point */
+         if (str2num(csa->image, &csa->value))
+            error(csa, "numeric constant '%s' out of range\n",
+               csa->image);
+      }
+      else if (csa->c == '+')
+         csa->token = T_PLUS, add_char(csa);
+      else if (csa->c == '-')
+         csa->token = T_MINUS, add_char(csa);
+      else if (csa->c == ':')
+         csa->token = T_COLON, add_char(csa);
+      else if (csa->c == '<')
+      {  csa->token = T_LE, add_char(csa);
+         if (csa->c == '=') add_char(csa);
+      }
+      else if (csa->c == '>')
+      {  csa->token = T_GE, add_char(csa);
+         if (csa->c == '=') add_char(csa);
+      }
+      else if (csa->c == '=')
+      {  csa->token = T_EQ, add_char(csa);
+         if (csa->c == '<')
+            csa->token = T_LE, add_char(csa);
+         else if (csa->c == '>')
+            csa->token = T_GE, add_char(csa);
+      }
+      else
+         error(csa, "character '%c' not recognized\n", csa->c);
+      /* skip non-significant characters */
+      while (csa->c == ' ') read_char(csa);
+      return;
+}
+
+static int find_col(struct csa *csa, char *name)
+{     /* find column by its symbolic name */
+      int j;
+      j = glp_find_col(csa->P, name);
+      if (j == 0)
+      {  /* not found; create new column */
+         j = glp_add_cols(csa->P, 1);
+         glp_set_col_name(csa->P, j, name);
+         /* enlarge working arrays, if necessary */
+         if (csa->n_max < j)
+         {  int n_max = csa->n_max;
+            int *ind = csa->ind;
+            double *val = csa->val;
+            char *flag = csa->flag;
+            double *lb = csa->lb;
+            double *ub = csa->ub;
+            csa->n_max += csa->n_max;
+            csa->ind = xcalloc(1+csa->n_max, sizeof(int));
+            memcpy(&csa->ind[1], &ind[1], n_max * sizeof(int));
+            xfree(ind);
+            csa->val = xcalloc(1+csa->n_max, sizeof(double));
+            memcpy(&csa->val[1], &val[1], n_max * sizeof(double));
+            xfree(val);
+            csa->flag = xcalloc(1+csa->n_max, sizeof(char));
+            memset(&csa->flag[1], 0, csa->n_max * sizeof(char));
+            memcpy(&csa->flag[1], &flag[1], n_max * sizeof(char));
+            xfree(flag);
+            csa->lb = xcalloc(1+csa->n_max, sizeof(double));
+            memcpy(&csa->lb[1], &lb[1], n_max * sizeof(double));
+            xfree(lb);
+            csa->ub = xcalloc(1+csa->n_max, sizeof(double));
+            memcpy(&csa->ub[1], &ub[1], n_max * sizeof(double));
+            xfree(ub);
          }
-         else if (p("-w") || p("--write"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No output solution file specified\n");
-               return 1;
-            }
-            if (csa->out_res != NULL)
-            {  xprintf("Only one output solution file allowed\n");
-               return 1;
-            }
-            csa->out_res = argv[k];
+         csa->lb[j] = +DBL_MAX, csa->ub[j] = -DBL_MAX;
+      }
+      return j;
+}
+
+/***********************************************************************
+*  parse_linear_form - parse linear form
+*
+*  This routine parses the linear form using the following syntax:
+*
+*  <variable> ::= <symbolic name>
+*  <coefficient> ::= <numeric constant>
+*  <term> ::= <variable> | <numeric constant> <variable>
+*  <linear form> ::= <term> | + <term> | - <term> |
+*     <linear form> + <term> | <linear form> - <term>
+*
+*  The routine returns the number of terms in the linear form. */
+
+static int parse_linear_form(struct csa *csa)
+{     int j, k, len = 0, newlen;
+      double s, coef;
+loop: /* parse an optional sign */
+      if (csa->token == T_PLUS)
+         s = +1.0, scan_token(csa);
+      else if (csa->token == T_MINUS)
+         s = -1.0, scan_token(csa);
+      else
+         s = +1.0;
+      /* parse an optional coefficient */
+      if (csa->token == T_NUMBER)
+         coef = csa->value, scan_token(csa);
+      else
+         coef = 1.0;
+      /* parse a variable name */
+      if (csa->token != T_NAME)
+         error(csa, "missing variable name\n");
+      /* find the corresponding column */
+      j = find_col(csa, csa->image);
+      /* check if the variable is already used in the linear form */
+      if (csa->flag[j])
+         error(csa, "multiple use of variable '%s' not allowed\n",
+            csa->image);
+      /* add new term to the linear form */
+      len++, csa->ind[len] = j, csa->val[len] = s * coef;
+      /* and mark that the variable is used in the linear form */
+      csa->flag[j] = 1;
+      scan_token(csa);
+      /* if the next token is a sign, there is another term */
+      if (csa->token == T_PLUS || csa->token == T_MINUS) goto loop;
+      /* clear marks of the variables used in the linear form */
+      for (k = 1; k <= len; k++) csa->flag[csa->ind[k]] = 0;
+      /* remove zero coefficients */
+      newlen = 0;
+      for (k = 1; k <= len; k++)
+      {  if (csa->val[k] != 0.0)
+         {  newlen++;
+            csa->ind[newlen] = csa->ind[k];
+            csa->val[newlen] = csa->val[k];
          }
-         else if (p("--ranges") || p("--bounds"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No output file specified to write sensitivity a"
-                  "nalysis report\n");
-               return 1;
-            }
-            if (csa->out_ranges != NULL)
-            {  xprintf("Only one output file allowed to write sensitivi"
-                  "ty analysis report\n");
-               return 1;
-            }
-            csa->out_ranges = argv[k];
+      }
+      return newlen;
+}
+
+/***********************************************************************
+*  parse_objective - parse objective function
+*
+*  This routine parses definition of the objective function using the
+*  following syntax:
+*
+*  <obj sense> ::= minimize | minimum | min | maximize | maximum | max
+*  <obj name> ::= <empty> | <symbolic name> :
+*  <obj function> ::= <obj sense> <obj name> <linear form> */
+
+static void parse_objective(struct csa *csa)
+{     /* parse objective sense */
+      int k, len;
+      /* parse the keyword 'minimize' or 'maximize' */
+      if (csa->token == T_MINIMIZE)
+         glp_set_obj_dir(csa->P, GLP_MIN);
+      else if (csa->token == T_MAXIMIZE)
+         glp_set_obj_dir(csa->P, GLP_MAX);
+      else
+         xassert(csa != csa);
+      scan_token(csa);
+      /* parse objective name */
+      if (csa->token == T_NAME && csa->c == ':')
+      {  /* objective name is followed by a colon */
+         glp_set_obj_name(csa->P, csa->image);
+         scan_token(csa);
+         xassert(csa->token == T_COLON);
+         scan_token(csa);
+      }
+      else
+      {  /* objective name is not specified; use default */
+         glp_set_obj_name(csa->P, "obj");
+      }
+      /* parse linear form */
+      len = parse_linear_form(csa);
+      for (k = 1; k <= len; k++)
+         glp_set_obj_coef(csa->P, csa->ind[k], csa->val[k]);
+      return;
+}
+
+/***********************************************************************
+*  parse_constraints - parse constraints section
+*
+*  This routine parses the constraints section using the following
+*  syntax:
+*
+*  <row name> ::= <empty> | <symbolic name> :
+*  <row sense> ::= < | <= | =< | > | >= | => | =
+*  <right-hand side> ::= <numeric constant> | + <numeric constant> |
+*     - <numeric constant>
+*  <constraint> ::= <row name> <linear form> <row sense>
+*     <right-hand side>
+*  <subject to> ::= subject to | such that | st | s.t. | st.
+*  <constraints section> ::= <subject to> <constraint> |
+*     <constraints section> <constraint> */
+
+static void parse_constraints(struct csa *csa)
+{     int i, len, type;
+      double s;
+      /* parse the keyword 'subject to' */
+      xassert(csa->token == T_SUBJECT_TO);
+      scan_token(csa);
+loop: /* create new row (constraint) */
+      i = glp_add_rows(csa->P, 1);
+      /* parse row name */
+      if (csa->token == T_NAME && csa->c == ':')
+      {  /* row name is followed by a colon */
+         if (glp_find_row(csa->P, csa->image) != 0)
+            error(csa, "constraint '%s' multiply defined\n",
+               csa->image);
+         glp_set_row_name(csa->P, i, csa->image);
+         scan_token(csa);
+         xassert(csa->token == T_COLON);
+         scan_token(csa);
+      }
+      else
+      {  /* row name is not specified; use default */
+         char name[50];
+         sprintf(name, "r.%d", csa->count);
+         glp_set_row_name(csa->P, i, name);
+      }
+      /* parse linear form */
+      len = parse_linear_form(csa);
+      glp_set_mat_row(csa->P, i, len, csa->ind, csa->val);
+      /* parse constraint sense */
+      if (csa->token == T_LE)
+         type = GLP_UP, scan_token(csa);
+      else if (csa->token == T_GE)
+         type = GLP_LO, scan_token(csa);
+      else if (csa->token == T_EQ)
+         type = GLP_FX, scan_token(csa);
+      else
+         error(csa, "missing constraint sense\n");
+      /* parse right-hand side */
+      if (csa->token == T_PLUS)
+         s = +1.0, scan_token(csa);
+      else if (csa->token == T_MINUS)
+         s = -1.0, scan_token(csa);
+      else
+         s = +1.0;
+      if (csa->token != T_NUMBER)
+         error(csa, "missing right-hand side\n");
+      glp_set_row_bnds(csa->P, i, type, s * csa->value, s * csa->value);
+      /* the rest of the current line must be empty */
+      if (!(csa->c == '\n' || csa->c == EOF))
+         error(csa, "invalid symbol(s) beyond right-hand side\n");
+      scan_token(csa);
+      /* if the next token is a sign, numeric constant, or a symbolic
+         name, here is another constraint */
+      if (csa->token == T_PLUS || csa->token == T_MINUS ||
+          csa->token == T_NUMBER || csa->token == T_NAME) goto loop;
+      return;
+}
+
+static void set_lower_bound(struct csa *csa, int j, double lb)
+{     /* set lower bound of j-th variable */
+      if (csa->lb[j] != +DBL_MAX && !csa->lb_warn)
+      {  warning(csa, "lower bound of variable '%s' redefined\n",
+            glp_get_col_name(csa->P, j));
+         csa->lb_warn = 1;
+      }
+      csa->lb[j] = lb;
+      return;
+}
+
+static void set_upper_bound(struct csa *csa, int j, double ub)
+{     /* set upper bound of j-th variable */
+      if (csa->ub[j] != -DBL_MAX && !csa->ub_warn)
+      {  warning(csa, "upper bound of variable '%s' redefined\n",
+            glp_get_col_name(csa->P, j));
+         csa->ub_warn = 1;
+      }
+      csa->ub[j] = ub;
+      return;
+}
+
+/***********************************************************************
+*  parse_bounds - parse bounds section
+*
+*  This routine parses the bounds section using the following syntax:
+*
+*  <variable> ::= <symbolic name>
+*  <infinity> ::= infinity | inf
+*  <bound> ::= <numeric constant> | + <numeric constant> |
+*     - <numeric constant> | + <infinity> | - <infinity>
+*  <lt> ::= < | <= | =<
+*  <gt> ::= > | >= | =>
+*  <bound definition> ::= <bound> <lt> <variable> <lt> <bound> |
+*     <bound> <lt> <variable> | <variable> <lt> <bound> |
+*     <variable> <gt> <bound> | <variable> = <bound> | <variable> free
+*  <bounds> ::= bounds | bound
+*  <bounds section> ::= <bounds> |
+*     <bounds section> <bound definition> */
+
+static void parse_bounds(struct csa *csa)
+{     int j, lb_flag;
+      double lb, s;
+      /* parse the keyword 'bounds' */
+      xassert(csa->token == T_BOUNDS);
+      scan_token(csa);
+loop: /* bound definition can start with a sign, numeric constant, or
+         a symbolic name */
+      if (!(csa->token == T_PLUS || csa->token == T_MINUS ||
+            csa->token == T_NUMBER || csa->token == T_NAME)) goto done;
+      /* parse bound definition */
+      if (csa->token == T_PLUS || csa->token == T_MINUS)
+      {  /* parse signed lower bound */
+         lb_flag = 1;
+         s = (csa->token == T_PLUS ? +1.0 : -1.0);
+         scan_token(csa);
+         if (csa->token == T_NUMBER)
+            lb = s * csa->value, scan_token(csa);
+         else if (the_same(csa->image, "infinity") ||
+                  the_same(csa->image, "inf"))
+         {  if (s > 0.0)
+               error(csa, "invalid use of '+inf' as lower bound\n");
+            lb = -DBL_MAX, scan_token(csa);
          }
-         else if (p("--tmlim"))
-         {  int tm_lim;
-            k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No time limit specified\n");
-               return 1;
-            }
-            if (str2int(argv[k], &tm_lim) || tm_lim < 0)
-            {  xprintf("Invalid time limit `%s'\n", argv[k]);
-               return 1;
+         else
+            error(csa, "missing lower bound\n");
+      }
+      else if (csa->token == T_NUMBER)
+      {  /* parse unsigned lower bound */
+         lb_flag = 1;
+         lb = csa->value, scan_token(csa);
+      }
+      else
+      {  /* lower bound is not specified */
+         lb_flag = 0;
+      }
+      /* parse the token that should follow the lower bound */
+      if (lb_flag)
+      {  if (csa->token != T_LE)
+            error(csa, "missing '<', '<=', or '=<' after lower bound\n")
+               ;
+         scan_token(csa);
+      }
+      /* parse variable name */
+      if (csa->token != T_NAME)
+         error(csa, "missing variable name\n");
+      j = find_col(csa, csa->image);
+      /* set lower bound */
+      if (lb_flag) set_lower_bound(csa, j, lb);
+      scan_token(csa);
+      /* parse the context that follows the variable name */
+      if (csa->token == T_LE)
+      {  /* parse upper bound */
+         scan_token(csa);
+         if (csa->token == T_PLUS || csa->token == T_MINUS)
+         {  /* parse signed upper bound */
+            s = (csa->token == T_PLUS ? +1.0 : -1.0);
+            scan_token(csa);
+            if (csa->token == T_NUMBER)
+            {  set_upper_bound(csa, j, s * csa->value);
+               scan_token(csa);
+            }
+            else if (the_same(csa->image, "infinity") ||
+                     the_same(csa->image, "inf"))
+            {  if (s < 0.0)
+                  error(csa, "invalid use of '-inf' as upper bound\n");
+               set_upper_bound(csa, j, +DBL_MAX);
+               scan_token(csa);
             }
-            if (tm_lim <= INT_MAX / 1000)
-               csa->smcp.tm_lim = csa->iocp.tm_lim = 1000 * tm_lim;
             else
-               csa->smcp.tm_lim = csa->iocp.tm_lim = INT_MAX;
-         }
-         else if (p("--memlim"))
-         {  int mem_lim;
-            k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No memory limit specified\n");
-               return 1;
-            }
-            if (str2int(argv[k], &mem_lim) || mem_lim < 1)
-            {  xprintf("Invalid memory limit `%s'\n", argv[k]);
-               return 1;
-            }
-            glp_mem_limit(mem_lim);
-         }
-         else if (p("--check"))
-            csa->check = 1;
-         else if (p("--name"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No problem name specified\n");
-               return 1;
-            }
-            if (csa->new_name != NULL)
-            {  xprintf("Only one problem name allowed\n");
-               return 1;
-            }
-            csa->new_name = argv[k];
-         }
-         else if (p("--wmps"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No fixed MPS output file specified\n");
-               return 1;
-            }
-            if (csa->out_mps != NULL)
-            {  xprintf("Only one fixed MPS output file allowed\n");
-               return 1;
-            }
-            csa->out_mps = argv[k];
+               error(csa, "missing upper bound\n");
          }
-         else if (p("--wfreemps"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No free MPS output file specified\n");
-               return 1;
-            }
-            if (csa->out_freemps != NULL)
-            {  xprintf("Only one free MPS output file allowed\n");
-               return 1;
-            }
-            csa->out_freemps = argv[k];
-         }
-         else if (p("--wlp") || p("--wcpxlp") || p("--wlpt"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No CPLEX LP output file specified\n");
-               return 1;
-            }
-            if (csa->out_cpxlp != NULL)
-            {  xprintf("Only one CPLEX LP output file allowed\n");
-               return 1;
-            }
-            csa->out_cpxlp = argv[k];
-         }
-         else if (p("--wglp"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No GLPK LP/MIP output file specified\n");
-               return 1;
-            }
-            if (csa->out_glp != NULL)
-            {  xprintf("Only one GLPK LP/MIP output file allowed\n");
-               return 1;
-            }
-            csa->out_glp = argv[k];
+         else if (csa->token == T_NUMBER)
+         {  /* parse unsigned upper bound */
+            set_upper_bound(csa, j, csa->value);
+            scan_token(csa);
          }
-         else if (p("--wpb"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No problem output file specified\n");
-               return 1;
-            }
-            if (csa->out_pb != NULL)
-            {  xprintf("Only one OPB output file allowed\n");
-               return 1;
-            }
-            csa->out_pb = argv[k];
-         }
-         else if (p("--wnpb"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No problem output file specified\n");
-               return 1;
-            }
-            if (csa->out_npb != NULL)
-            {  xprintf("Only one normalized OPB output file allowed\n");
-               return 1;
-            }
-            csa->out_npb = argv[k];
-         }
-         else if (p("--log"))
-         {  k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No log file specified\n");
-               return 1;
-            }
-            if (csa->log_file != NULL)
-            {  xprintf("Only one log file allowed\n");
-               return 1;
+         else
+            error(csa, "missing upper bound\n");
+      }
+      else if (csa->token == T_GE)
+      {  /* parse lower bound */
+         if (lb_flag)
+         {  /* the context '... <= x >= ...' is invalid */
+            error(csa, "invalid bound definition\n");
+         }
+         scan_token(csa);
+         if (csa->token == T_PLUS || csa->token == T_MINUS)
+         {  /* parse signed lower bound */
+            s = (csa->token == T_PLUS ? +1.0 : -1.0);
+            scan_token(csa);
+            if (csa->token == T_NUMBER)
+            {  set_lower_bound(csa, j, s * csa->value);
+               scan_token(csa);
+            }
+            else if (the_same(csa->image, "infinity") ||
+                     the_same(csa->image, "inf") == 0)
+            {  if (s > 0.0)
+                  error(csa, "invalid use of '+inf' as lower bound\n");
+               set_lower_bound(csa, j, -DBL_MAX);
+               scan_token(csa);
             }
-            csa->log_file = argv[k];
+            else
+               error(csa, "missing lower bound\n");
          }
-         else if (p("-h") || p("--help"))
-         {  print_help(argv[0]);
-            return -1;
-         }
-         else if (p("-v") || p("--version"))
-         {  print_version(0);
-            return -1;
-         }
-         else if (p("--luf"))
-            csa->bfcp.type = GLP_BF_FT;
-         else if (p("--cbg"))
-            csa->bfcp.type = GLP_BF_BG;
-         else if (p("--cgr"))
-            csa->bfcp.type = GLP_BF_GR;
-         else if (p("--primal"))
-            csa->smcp.meth = GLP_PRIMAL;
-         else if (p("--dual"))
-            csa->smcp.meth = GLP_DUAL;
-         else if (p("--std"))
-            csa->crash = USE_STD_BASIS;
-         else if (p("--adv"))
-            csa->crash = USE_ADV_BASIS;
-         else if (p("--bib"))
-            csa->crash = USE_CPX_BASIS;
-         else if (p("--ini"))
-         {  csa->crash = USE_INI_BASIS;
-            csa->smcp.presolve = GLP_OFF;
-            k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No initial basis file specified\n");
-               return 1;
-            }
-            if (csa->ini_file != NULL)
-            {  xprintf("Only one initial basis file allowed\n");
-               return 1;
-            }
-            csa->ini_file = argv[k];
+         else if (csa->token == T_NUMBER)
+         {  /* parse unsigned lower bound */
+            set_lower_bound(csa, j, csa->value);
+            scan_token(csa);
          }
-         else if (p("--steep"))
-            csa->smcp.pricing = GLP_PT_PSE;
-         else if (p("--nosteep"))
-            csa->smcp.pricing = GLP_PT_STD;
-         else if (p("--relax"))
-            csa->smcp.r_test = GLP_RT_HAR;
-         else if (p("--norelax"))
-            csa->smcp.r_test = GLP_RT_STD;
-         else if (p("--presol"))
-            csa->smcp.presolve = GLP_ON;
-         else if (p("--nopresol"))
-            csa->smcp.presolve = GLP_OFF;
-         else if (p("--exact"))
-            csa->exact = 1;
-         else if (p("--xcheck"))
-            csa->xcheck = 1;
-         else if (p("--nord"))
-            csa->iptcp.ord_alg = GLP_ORD_NONE;
-         else if (p("--qmd"))
-            csa->iptcp.ord_alg = GLP_ORD_QMD;
-         else if (p("--amd"))
-            csa->iptcp.ord_alg = GLP_ORD_AMD;
-         else if (p("--symamd"))
-            csa->iptcp.ord_alg = GLP_ORD_SYMAMD;
-         else if (p("--nomip"))
-            csa->nomip = 1;
-         else if (p("--first"))
-            csa->iocp.br_tech = GLP_BR_FFV;
-         else if (p("--last"))
-            csa->iocp.br_tech = GLP_BR_LFV;
-         else if (p("--drtom"))
-            csa->iocp.br_tech = GLP_BR_DTH;
-         else if (p("--mostf"))
-            csa->iocp.br_tech = GLP_BR_MFV;
-         else if (p("--pcost"))
-            csa->iocp.br_tech = GLP_BR_PCH;
-         else if (p("--dfs"))
-            csa->iocp.bt_tech = GLP_BT_DFS;
-         else if (p("--bfs"))
-            csa->iocp.bt_tech = GLP_BT_BFS;
-         else if (p("--bestp"))
-            csa->iocp.bt_tech = GLP_BT_BPH;
-         else if (p("--bestb"))
-            csa->iocp.bt_tech = GLP_BT_BLB;
-         else if (p("--intopt"))
-            csa->iocp.presolve = GLP_ON;
-         else if (p("--nointopt"))
-            csa->iocp.presolve = GLP_OFF;
-         else if (p("--binarize"))
-            csa->iocp.presolve = csa->iocp.binarize = GLP_ON;
-         else if (p("--fpump"))
-            csa->iocp.fp_heur = GLP_ON;
-         else if (p("--gomory"))
-            csa->iocp.gmi_cuts = GLP_ON;
-         else if (p("--mir"))
-            csa->iocp.mir_cuts = GLP_ON;
-         else if (p("--cover"))
-            csa->iocp.cov_cuts = GLP_ON;
-         else if (p("--clique"))
-            csa->iocp.clq_cuts = GLP_ON;
-         else if (p("--cuts"))
-            csa->iocp.gmi_cuts = csa->iocp.mir_cuts =
-            csa->iocp.cov_cuts = csa->iocp.clq_cuts = GLP_ON;
-         else if (p("--mipgap"))
-         {  double mip_gap;
-            k++;
-            if (k == argc || argv[k][0] == '\0' || argv[k][0] == '-')
-            {  xprintf("No relative gap tolerance specified\n");
-               return 1;
-            }
-            if (str2num(argv[k], &mip_gap) || mip_gap < 0.0)
-            {  xprintf("Invalid relative mip gap tolerance `%s'\n",
-                  argv[k]);
-               return 1;
+         else
+            error(csa, "missing lower bound\n");
+      }
+      else if (csa->token == T_EQ)
+      {  /* parse fixed value */
+         if (lb_flag)
+         {  /* the context '... <= x = ...' is invalid */
+            error(csa, "invalid bound definition\n");
+         }
+         scan_token(csa);
+         if (csa->token == T_PLUS || csa->token == T_MINUS)
+         {  /* parse signed fixed value */
+            s = (csa->token == T_PLUS ? +1.0 : -1.0);
+            scan_token(csa);
+            if (csa->token == T_NUMBER)
+            {  set_lower_bound(csa, j, s * csa->value);
+               set_upper_bound(csa, j, s * csa->value);
+               scan_token(csa);
             }
-            csa->iocp.mip_gap = mip_gap;
+            else
+               error(csa, "missing fixed value\n");
          }
-         else if (argv[k][0] == '-' ||
-                 (argv[k][0] == '-' && argv[k][1] == '-'))
-         {  xprintf("Invalid option `%s'; try %s --help\n",
-               argv[k], argv[0]);
-            return 1;
+         else if (csa->token == T_NUMBER)
+         {  /* parse unsigned fixed value */
+            set_lower_bound(csa, j, csa->value);
+            set_upper_bound(csa, j, csa->value);
+            scan_token(csa);
          }
          else
-         {  if (csa->in_file != NULL)
-            {  xprintf("Only one input problem file allowed\n");
-               return 1;
-            }
-            csa->in_file = argv[k];
-         }
+            error(csa, "missing fixed value\n");
+      }
+      else if (the_same(csa->image, "free"))
+      {  /* parse the keyword 'free' */
+         if (lb_flag)
+         {  /* the context '... <= x free ...' is invalid */
+            error(csa, "invalid bound definition\n");
+         }
+         set_lower_bound(csa, j, -DBL_MAX);
+         set_upper_bound(csa, j, +DBL_MAX);
+         scan_token(csa);
+      }
+      else if (!lb_flag)
+      {  /* neither lower nor upper bounds are specified */
+         error(csa, "invalid bound definition\n");
       }
-#undef p
-      return 0;
+      goto loop;
+done: return;
 }
 
-typedef struct { double rhs, pi; } v_data;
-typedef struct { double low, cap, cost, x; } a_data;
+/***********************************************************************
+*  parse_integer - parse general, integer, or binary section
+*
+*  <variable> ::= <symbolic name>
+*  <general> ::= general | generals | gen
+*  <integer> ::= integer | integers | int
+*  <binary> ::= binary | binaries | bin
+*  <section head> ::= <general> <integer> <binary>
+*  <additional section> ::= <section head> |
+*     <additional section> <variable> */
+
+static void parse_integer(struct csa *csa)
+{     int j, binary;
+      /* parse the keyword 'general', 'integer', or 'binary' */
+      if (csa->token == T_GENERAL)
+         binary = 0, scan_token(csa);
+      else if (csa->token == T_INTEGER)
+         binary = 0, scan_token(csa);
+      else if (csa->token == T_BINARY)
+         binary = 1, scan_token(csa);
+      else
+         xassert(csa != csa);
+      /* parse list of variables (may be empty) */
+      while (csa->token == T_NAME)
+      {  /* find the corresponding column */
+         j = find_col(csa, csa->image);
+         /* change kind of the variable */
+         glp_set_col_kind(csa->P, j, GLP_IV);
+         /* set bounds for the binary variable */
+         if (binary)
+#if 0 /* 07/VIII-2013 */
+         {  set_lower_bound(csa, j, 0.0);
+            set_upper_bound(csa, j, 1.0);
+         }
+#else
+         {  set_lower_bound(csa, j,
+               csa->lb[j] == +DBL_MAX ? 0.0 : csa->lb[j]);
+            set_upper_bound(csa, j,
+               csa->ub[j] == -DBL_MAX ? 1.0 : csa->ub[j]);
+         }
+#endif
+         scan_token(csa);
+      }
+      return;
+}
 
-int glp_main(int argc, const char *argv[])
-{     /* stand-alone LP/MIP solver */
+int glp_read_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname)
+{     /* read problem data in CPLEX LP format */
+      glp_cpxcp _parm;
       struct csa _csa, *csa = &_csa;
       int ret;
-      glp_long start;
-      /* perform initialization */
-      csa->prob = glp_create_prob();
-      glp_get_bfcp(csa->prob, &csa->bfcp);
-      glp_init_smcp(&csa->smcp);
-      csa->smcp.presolve = GLP_ON;
-      glp_init_iptcp(&csa->iptcp);
-      glp_init_iocp(&csa->iocp);
-      csa->iocp.presolve = GLP_ON;
-      csa->tran = NULL;
-      csa->graph = NULL;
-      csa->format = FMT_MPS_FILE;
-      csa->in_file = NULL;
-      csa->ndf = 0;
-      csa->out_dpy = NULL;
-      csa->seed = 1;
-      csa->solution = SOL_BASIC;
-      csa->in_res = NULL;
-      csa->dir = 0;
-      csa->scale = 1;
-      csa->out_sol = NULL;
-      csa->out_res = NULL;
-      csa->out_ranges = NULL;
-      csa->check = 0;
-      csa->new_name = NULL;
-      csa->out_mps = NULL;
-      csa->out_freemps = NULL;
-      csa->out_cpxlp = NULL;
-      csa->out_glp = NULL;
-      csa->out_pb = NULL;
-      csa->out_npb = NULL;
-      csa->log_file = NULL;
-      csa->crash = USE_ADV_BASIS;
-      csa->ini_file = NULL;
-      csa->exact = 0;
-      csa->xcheck = 0;
-      csa->nomip = 0;
-      /* parse command-line parameters */
-      ret = parse_cmdline(csa, argc, argv);
-      if (ret < 0)
-      {  ret = EXIT_SUCCESS;
+      xprintf("Reading problem data from '%s'...\n", fname);
+      if (parm == NULL)
+         glp_init_cpxcp(&_parm), parm = &_parm;
+      /* check control parameters */
+      check_parm("glp_read_lp", parm);
+      /* initialize common storage area */
+      csa->P = P;
+      csa->parm = parm;
+      csa->fname = fname;
+      csa->fp = NULL;
+      if (setjmp(csa->jump))
+      {  ret = 1;
          goto done;
       }
-      if (ret > 0)
-      {  ret = EXIT_FAILURE;
-         goto done;
-      }
-      /*--------------------------------------------------------------*/
-      /* remove all output files specified in the command line */
-      if (csa->out_dpy != NULL) remove(csa->out_dpy);
-      if (csa->out_sol != NULL) remove(csa->out_sol);
-      if (csa->out_res != NULL) remove(csa->out_res);
-      if (csa->out_ranges != NULL) remove(csa->out_ranges);
-      if (csa->out_mps != NULL) remove(csa->out_mps);
-      if (csa->out_freemps != NULL) remove(csa->out_freemps);
-      if (csa->out_cpxlp != NULL) remove(csa->out_cpxlp);
-      if (csa->out_glp != NULL) remove(csa->out_glp);
-      if (csa->out_pb != NULL) remove(csa->out_pb);
-      if (csa->out_npb != NULL) remove(csa->out_npb);
-      if (csa->log_file != NULL) remove(csa->log_file);
-      /*--------------------------------------------------------------*/
-      /* open log file, if required */
-      if (csa->log_file != NULL)
-      {  if (glp_open_tee(csa->log_file))
-         {  xprintf("Unable to create log file\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /*--------------------------------------------------------------*/
-      /* print version information */
-      print_version(1);
-      /*--------------------------------------------------------------*/
-      /* print parameters specified in the command line */
-      if (argc > 1)
-      {  int k, len = INT_MAX;
-         xprintf("Parameter(s) specified in the command line:");
-         for (k = 1; k < argc; k++)
-         {  if (len > 72)
-               xprintf("\n"), len = 0;
-            xprintf(" %s", argv[k]);
-            len += 1 + strlen(argv[k]);
-         }
-         xprintf("\n");
-      }
-      /*--------------------------------------------------------------*/
-      /* read problem data from the input file */
-      if (csa->in_file == NULL)
-      {  xprintf("No input problem file specified; try %s --help\n",
-            argv[0]);
-         ret = EXIT_FAILURE;
+      csa->count = 0;
+      csa->c = '\n';
+      csa->token = T_EOF;
+      csa->image[0] = '\0';
+      csa->imlen = 0;
+      csa->value = 0.0;
+      csa->n_max = 100;
+      csa->ind = xcalloc(1+csa->n_max, sizeof(int));
+      csa->val = xcalloc(1+csa->n_max, sizeof(double));
+      csa->flag = xcalloc(1+csa->n_max, sizeof(char));
+      memset(&csa->flag[1], 0, csa->n_max * sizeof(char));
+      csa->lb = xcalloc(1+csa->n_max, sizeof(double));
+      csa->ub = xcalloc(1+csa->n_max, sizeof(double));
+#if 1 /* 27/VII-2013 */
+      csa->lb_warn = csa->ub_warn = 0;
+#endif
+      /* erase problem object */
+      glp_erase_prob(P);
+      glp_create_index(P);
+      /* open input CPLEX LP file */
+      csa->fp = glp_open(fname, "r");
+      if (csa->fp == NULL)
+      {  xprintf("Unable to open '%s' - %s\n", fname, get_err_msg());
+         ret = 1;
          goto done;
       }
-      if (csa->format == FMT_MPS_DECK)
-      {  ret = glp_read_mps(csa->prob, GLP_MPS_DECK, NULL,
-            csa->in_file);
-         if (ret != 0)
-err1:    {  xprintf("MPS file processing error\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      else if (csa->format == FMT_MPS_FILE)
-      {  ret = glp_read_mps(csa->prob, GLP_MPS_FILE, NULL,
-            csa->in_file);
-         if (ret != 0) goto err1;
-      }
-      else if (csa->format == FMT_LP)
-      {  ret = glp_read_lp(csa->prob, NULL, csa->in_file);
-         if (ret != 0)
-         {  xprintf("CPLEX LP file processing error\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      else if (csa->format == FMT_GLP)
-      {  ret = glp_read_prob(csa->prob, 0, csa->in_file);
-         if (ret != 0)
-         {  xprintf("GLPK LP/MIP file processing error\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      else if (csa->format == FMT_MATHPROG)
-      {  int k;
-         /* allocate the translator workspace */
-         csa->tran = glp_mpl_alloc_wksp();
-         /* set seed value */
-         if (csa->seed == 0x80000000)
-         {  csa->seed = glp_time().lo;
-            xprintf("Seed value %d will be used\n", csa->seed);
-         }
-         _glp_mpl_init_rand(csa->tran, csa->seed);
-         /* read model section and optional data section */
-         if (glp_mpl_read_model(csa->tran, csa->in_file, csa->ndf > 0))
-err2:    {  xprintf("MathProg model processing error\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-         /* read optional data section(s), if necessary */
-         for (k = 1; k <= csa->ndf; k++)
-         {  if (glp_mpl_read_data(csa->tran, csa->in_data[k]))
-               goto err2;
-         }
-         /* generate the model */
-         if (glp_mpl_generate(csa->tran, csa->out_dpy)) goto err2;
-         /* build the problem instance from the model */
-         glp_mpl_build_prob(csa->tran, csa->prob);
-      }
-      else if (csa->format == FMT_MIN_COST)
-      {  csa->graph = glp_create_graph(sizeof(v_data), sizeof(a_data));
-         ret = glp_read_mincost(csa->graph, offsetof(v_data, rhs),
-            offsetof(a_data, low), offsetof(a_data, cap),
-            offsetof(a_data, cost), csa->in_file);
-         if (ret != 0)
-         {  xprintf("DIMACS file processing error\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-         glp_mincost_lp(csa->prob, csa->graph, GLP_ON,
-            offsetof(v_data, rhs), offsetof(a_data, low),
-            offsetof(a_data, cap), offsetof(a_data, cost));
-         glp_set_prob_name(csa->prob, csa->in_file);
-      }
-      else if (csa->format == FMT_MAX_FLOW)
-      {  int s, t;
-         csa->graph = glp_create_graph(sizeof(v_data), sizeof(a_data));
-         ret = glp_read_maxflow(csa->graph, &s, &t,
-            offsetof(a_data, cap), csa->in_file);
-         if (ret != 0)
-         {  xprintf("DIMACS file processing error\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-         glp_maxflow_lp(csa->prob, csa->graph, GLP_ON, s, t,
-            offsetof(a_data, cap));
-         glp_set_prob_name(csa->prob, csa->in_file);
-      }
+      /* scan very first token */
+      scan_token(csa);
+      /* parse definition of the objective function */
+      if (!(csa->token == T_MINIMIZE || csa->token == T_MAXIMIZE))
+         error(csa, "'minimize' or 'maximize' keyword missing\n");
+      parse_objective(csa);
+      /* parse constraints section */
+      if (csa->token != T_SUBJECT_TO)
+         error(csa, "constraints section missing\n");
+      parse_constraints(csa);
+      /* parse optional bounds section */
+      if (csa->token == T_BOUNDS) parse_bounds(csa);
+      /* parse optional general, integer, and binary sections */
+      while (csa->token == T_GENERAL ||
+             csa->token == T_INTEGER ||
+             csa->token == T_BINARY) parse_integer(csa);
+      /* check for the keyword 'end' */
+      if (csa->token == T_END)
+         scan_token(csa);
+      else if (csa->token == T_EOF)
+         warning(csa, "keyword 'end' missing\n");
       else
-         xassert(csa != csa);
-      /*--------------------------------------------------------------*/
-      /* change problem name, if required */
-      if (csa->new_name != NULL)
-         glp_set_prob_name(csa->prob, csa->new_name);
-      /* change optimization direction, if required */
-      if (csa->dir != 0)
-         glp_set_obj_dir(csa->prob, csa->dir);
-      /* sort elements of the constraint matrix */
-      glp_sort_matrix(csa->prob);
-      /*--------------------------------------------------------------*/
-      /* write problem data in fixed MPS format, if required */
-      if (csa->out_mps != NULL)
-      {  ret = glp_write_mps(csa->prob, GLP_MPS_DECK, NULL,
-            csa->out_mps);
-         if (ret != 0)
-         {  xprintf("Unable to write problem in fixed MPS format\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /* write problem data in free MPS format, if required */
-      if (csa->out_freemps != NULL)
-      {  ret = glp_write_mps(csa->prob, GLP_MPS_FILE, NULL,
-            csa->out_freemps);
-         if (ret != 0)
-         {  xprintf("Unable to write problem in free MPS format\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /* write problem data in CPLEX LP format, if required */
-      if (csa->out_cpxlp != NULL)
-      {  ret = glp_write_lp(csa->prob, NULL, csa->out_cpxlp);
-         if (ret != 0)
-         {  xprintf("Unable to write problem in CPLEX LP format\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /* write problem data in GLPK format, if required */
-      if (csa->out_glp != NULL)
-      {  ret = glp_write_prob(csa->prob, 0, csa->out_glp);
-         if (ret != 0)
-         {  xprintf("Unable to write problem in GLPK format\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /* write problem data in OPB format, if required */
-      if (csa->out_pb != NULL)
-      {  ret = lpx_write_pb(csa->prob, csa->out_pb, 0, 0);
-         if (ret != 0)
-         {  xprintf("Unable to write problem in OPB format\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /* write problem data in normalized OPB format, if required */
-      if (csa->out_npb != NULL)
-      {  ret = lpx_write_pb(csa->prob, csa->out_npb, 1, 1);
-         if (ret != 0)
-         {  xprintf(
-               "Unable to write problem in normalized OPB format\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /*--------------------------------------------------------------*/
-      /* if only problem data check is required, skip computations */
-      if (csa->check)
-      {  ret = EXIT_SUCCESS;
-         goto done;
-      }
-      /*--------------------------------------------------------------*/
-      /* determine the solution type */
-      if (!csa->nomip &&
-          glp_get_num_int(csa->prob) + glp_get_num_bin(csa->prob) > 0)
-      {  if (csa->solution == SOL_INTERIOR)
-         {  xprintf("Interior-point method is not able to solve MIP pro"
-               "blem; use --simplex\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-         csa->solution = SOL_INTEGER;
-      }
-      /*--------------------------------------------------------------*/
-      /* if solution is provided, read it and skip computations */
-      if (csa->in_res != NULL)
-      {  if (csa->solution == SOL_BASIC)
-            ret = glp_read_sol(csa->prob, csa->in_res);
-         else if (csa->solution == SOL_INTERIOR)
-            ret = glp_read_ipt(csa->prob, csa->in_res);
-         else if (csa->solution == SOL_INTEGER)
-            ret = glp_read_mip(csa->prob, csa->in_res);
-         else
-            xassert(csa != csa);
-         if (ret != 0)
-         {  xprintf("Unable to read problem solution\n");
-            ret = EXIT_FAILURE;
-            goto done;
+         error(csa, "symbol '%s' in wrong position\n", csa->image);
+      /* nothing must follow the keyword 'end' (except comments) */
+      if (csa->token != T_EOF)
+         error(csa, "extra symbol(s) detected beyond 'end'\n");
+      /* set bounds of variables */
+      {  int j, type;
+         double lb, ub;
+         for (j = 1; j <= P->n; j++)
+         {  lb = csa->lb[j];
+            ub = csa->ub[j];
+            if (lb == +DBL_MAX) lb = 0.0;      /* default lb */
+            if (ub == -DBL_MAX) ub = +DBL_MAX; /* default ub */
+            if (lb == -DBL_MAX && ub == +DBL_MAX)
+               type = GLP_FR;
+            else if (ub == +DBL_MAX)
+               type = GLP_LO;
+            else if (lb == -DBL_MAX)
+               type = GLP_UP;
+            else if (lb != ub)
+               type = GLP_DB;
+            else
+               type = GLP_FX;
+            glp_set_col_bnds(csa->P, j, type, lb, ub);
          }
-         goto skip;
       }
-      /*--------------------------------------------------------------*/
-      /* scale the problem data, if required */
-      if (csa->scale)
-      {  if (csa->solution == SOL_BASIC && !csa->smcp.presolve ||
-             csa->solution == SOL_INTERIOR ||
-             csa->solution == SOL_INTEGER && !csa->iocp.presolve)
-            glp_scale_prob(csa->prob, GLP_SF_AUTO);
-      }
-      /*--------------------------------------------------------------*/
-      /* construct starting LP basis */
-      if (csa->solution == SOL_BASIC && !csa->smcp.presolve ||
-          csa->solution == SOL_INTEGER && !csa->iocp.presolve)
-      {  if (csa->crash == USE_STD_BASIS)
-            glp_std_basis(csa->prob);
-         else if (csa->crash == USE_ADV_BASIS)
-            glp_adv_basis(csa->prob, 0);
-         else if (csa->crash == USE_CPX_BASIS)
-            glp_cpx_basis(csa->prob);
-         else if (csa->crash == USE_INI_BASIS)
-         {  ret = glp_read_sol(csa->prob, csa->ini_file);
-            if (ret != 0)
-            {  xprintf("Unable to read initial basis\n");
-               ret = EXIT_FAILURE;
-               goto done;
-            }
+      /* print some statistics */
+      xprintf("%d row%s, %d column%s, %d non-zero%s\n",
+         P->m, P->m == 1 ? "" : "s", P->n, P->n == 1 ? "" : "s",
+         P->nnz, P->nnz == 1 ? "" : "s");
+      if (glp_get_num_int(P) > 0)
+      {  int ni = glp_get_num_int(P);
+         int nb = glp_get_num_bin(P);
+         if (ni == 1)
+         {  if (nb == 0)
+               xprintf("One variable is integer\n");
+            else
+               xprintf("One variable is binary\n");
          }
          else
-            xassert(csa != csa);
+         {  xprintf("%d integer variables, ", ni);
+            if (nb == 0)
+               xprintf("none");
+            else if (nb == 1)
+               xprintf("one");
+            else if (nb == ni)
+               xprintf("all");
+            else
+               xprintf("%d", nb);
+            xprintf(" of which %s binary\n", nb == 1 ? "is" : "are");
+         }
       }
-      /*--------------------------------------------------------------*/
-      /* solve the problem */
-      start = xtime();
-      if (csa->solution == SOL_BASIC)
-      {  if (!csa->exact)
-         {  glp_set_bfcp(csa->prob, &csa->bfcp);
-            glp_simplex(csa->prob, &csa->smcp);
-            if (csa->xcheck)
-            {  if (csa->smcp.presolve &&
-                   glp_get_status(csa->prob) != GLP_OPT)
-                  xprintf("If you need to check final basis for non-opt"
-                     "imal solution, use --nopresol\n");
-               else
-                  glp_exact(csa->prob, &csa->smcp);
-            }
-            if (csa->out_sol != NULL || csa->out_res != NULL)
-            {  if (csa->smcp.presolve &&
-                   glp_get_status(csa->prob) != GLP_OPT)
-               xprintf("If you need actual output for non-optimal solut"
-                  "ion, use --nopresol\n");
-            }
+      xprintf("%d lines were read\n", csa->count);
+      /* problem data has been successfully read */
+      glp_delete_index(P);
+      glp_sort_matrix(P);
+      ret = 0;
+done: if (csa->fp != NULL) glp_close(csa->fp);
+      xfree(csa->ind);
+      xfree(csa->val);
+      xfree(csa->flag);
+      xfree(csa->lb);
+      xfree(csa->ub);
+      if (ret != 0) glp_erase_prob(P);
+      return ret;
+}
+
+/***********************************************************************
+*  NAME
+*
+*  glp_write_lp - write problem data in CPLEX LP format
+*
+*  SYNOPSIS
+*
+*  int glp_write_lp(glp_prob *P, const glp_cpxcp *parm, const char
+*     *fname);
+*
+*  DESCRIPTION
+*
+*  The routine glp_write_lp writes problem data in CPLEX LP format to
+*  a text file.
+*
+*  The parameter parm is a pointer to the structure glp_cpxcp, which
+*  specifies control parameters used by the routine. If parm is NULL,
+*  the routine uses default settings.
+*
+*  The character string fname specifies a name of the text file to be
+*  written.
+*
+*  RETURNS
+*
+*  If the operation was successful, the routine glp_write_lp returns
+*  zero. Otherwise, it prints an error message and returns non-zero. */
+
+#define csa csa1
+
+struct csa
+{     /* common storage area */
+      glp_prob *P;
+      /* pointer to problem object */
+      const glp_cpxcp *parm;
+      /* pointer to control parameters */
+};
+
+static int check_name(char *name)
+{     /* check if specified name is valid for CPLEX LP format */
+      if (*name == '.') return 1;
+      if (isdigit((unsigned char)*name)) return 1;
+      for (; *name; name++)
+      {  if (!isalnum((unsigned char)*name) &&
+             strchr(CHAR_SET, (unsigned char)*name) == NULL) return 1;
+      }
+      return 0; /* name is ok */
+}
+
+static void adjust_name(char *name)
+{     /* attempt to adjust specified name to make it valid for CPLEX LP
+         format */
+      for (; *name; name++)
+      {  if (*name == ' ')
+            *name = '_';
+         else if (*name == '-')
+            *name = '~';
+         else if (*name == '[')
+            *name = '(';
+         else if (*name == ']')
+            *name = ')';
+      }
+      return;
+}
+
+static char *row_name(struct csa *csa, int i, char rname[255+1])
+{     /* construct symbolic name of i-th row (constraint) */
+      const char *name;
+      if (i == 0)
+         name = glp_get_obj_name(csa->P);
+      else
+         name = glp_get_row_name(csa->P, i);
+      if (name == NULL) goto fake;
+      strcpy(rname, name);
+      adjust_name(rname);
+      if (check_name(rname)) goto fake;
+      return rname;
+fake: if (i == 0)
+         strcpy(rname, "obj");
+      else
+         sprintf(rname, "r_%d", i);
+      return rname;
+}
+
+static char *col_name(struct csa *csa, int j, char cname[255+1])
+{     /* construct symbolic name of j-th column (variable) */
+      const char *name;
+      name = glp_get_col_name(csa->P, j);
+      if (name == NULL) goto fake;
+      strcpy(cname, name);
+      adjust_name(cname);
+      if (check_name(cname)) goto fake;
+      return cname;
+#if 0 /* 18/I-2018 */
+fake: sprintf(cname, "x_%d", j);
+#else
+fake: /* construct fake name depending on column's attributes */
+      {  GLPCOL *col = csa->P->col[j];
+         if (col->type == GLP_FX)
+         {  /* fixed column */
+            sprintf(cname, "s_%d", j);
+         }
+         else if (col->kind == GLP_CV)
+         {  /* continuous variable */
+            sprintf(cname, "x_%d", j);
+         }
+         else if (!(col->lb == 0 && col->ub == 1))
+         {  /* general (non-binary) integer variable */
+            sprintf(cname, "y_%d", j);
          }
          else
-            glp_exact(csa->prob, &csa->smcp);
+         {  /* binary variable */
+            sprintf(cname, "z_%d", j);
+         }
       }
-      else if (csa->solution == SOL_INTERIOR)
-         glp_interior(csa->prob, &csa->iptcp);
-      else if (csa->solution == SOL_INTEGER)
-      {  if (!csa->iocp.presolve)
-         {  glp_set_bfcp(csa->prob, &csa->bfcp);
-            glp_simplex(csa->prob, &csa->smcp);
-         }
-#if 0
-         csa->iocp.msg_lev = GLP_MSG_DBG;
-         csa->iocp.pp_tech = GLP_PP_NONE;
 #endif
-         glp_intopt(csa->prob, &csa->iocp);
+      return cname;
+}
+
+int glp_write_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname)
+{     /* write problem data in CPLEX LP format */
+      glp_cpxcp _parm;
+      struct csa _csa, *csa = &_csa;
+      glp_file *fp;
+      GLPROW *row;
+      GLPCOL *col;
+      GLPAIJ *aij;
+      int i, j, len, flag, count, ret;
+      char line[1000+1], term[500+1], name[255+1];
+      xprintf("Writing problem data to '%s'...\n", fname);
+      if (parm == NULL)
+         glp_init_cpxcp(&_parm), parm = &_parm;
+      /* check control parameters */
+      check_parm("glp_write_lp", parm);
+      /* initialize common storage area */
+      csa->P = P;
+      csa->parm = parm;
+      /* create output CPLEX LP file */
+      fp = glp_open(fname, "w"), count = 0;
+      if (fp == NULL)
+      {  xprintf("Unable to create '%s' - %s\n", fname, get_err_msg());
+         ret = 1;
+         goto done;
+      }
+      /* write problem name */
+      xfprintf(fp, "\\* Problem: %s *\\\n",
+         P->name == NULL ? "Unknown" : P->name), count++;
+      xfprintf(fp, "\n"), count++;
+      /* the problem should contain at least one row and one column */
+      if (!(P->m > 0 && P->n > 0))
+      {  xprintf("Warning: problem has no rows/columns\n");
+         xfprintf(fp, "\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\\n"),
+            count++;
+         xfprintf(fp, "\n"), count++;
+         goto skip;
       }
+      /* write the objective function definition */
+      if (P->dir == GLP_MIN)
+         xfprintf(fp, "Minimize\n"), count++;
+      else if (P->dir == GLP_MAX)
+         xfprintf(fp, "Maximize\n"), count++;
       else
-         xassert(csa != csa);
-      /*--------------------------------------------------------------*/
-      /* display statistics */
-      xprintf("Time used:   %.1f secs\n", xdifftime(xtime(), start));
-      {  glp_long tpeak;
-         char buf[50];
-         glp_mem_usage(NULL, NULL, NULL, &tpeak);
-         xprintf("Memory used: %.1f Mb (%s bytes)\n",
-            xltod(tpeak) / 1048576.0, xltoa(tpeak, buf));
-      }
-      /*--------------------------------------------------------------*/
-skip: /* postsolve the model, if necessary */
-      if (csa->tran != NULL)
-      {  if (csa->solution == SOL_BASIC)
-            ret = glp_mpl_postsolve(csa->tran, csa->prob, GLP_SOL);
-         else if (csa->solution == SOL_INTERIOR)
-            ret = glp_mpl_postsolve(csa->tran, csa->prob, GLP_IPT);
-         else if (csa->solution == SOL_INTEGER)
-            ret = glp_mpl_postsolve(csa->tran, csa->prob, GLP_MIP);
+         xassert(P != P);
+      row_name(csa, 0, name);
+      sprintf(line, " %s:", name);
+      len = 0;
+      for (j = 1; j <= P->n; j++)
+      {  col = P->col[j];
+         if (col->coef != 0.0 || col->ptr == NULL)
+         {  len++;
+            col_name(csa, j, name);
+            if (col->coef == 0.0)
+               sprintf(term, " + 0 %s", name); /* empty column */
+            else if (col->coef == +1.0)
+               sprintf(term, " + %s", name);
+            else if (col->coef == -1.0)
+               sprintf(term, " - %s", name);
+            else if (col->coef > 0.0)
+               sprintf(term, " + %.*g %s", DBL_DIG, +col->coef, name);
+            else
+               sprintf(term, " - %.*g %s", DBL_DIG, -col->coef, name);
+            if (strlen(line) + strlen(term) > 72)
+               xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
+            strcat(line, term);
+         }
+      }
+      if (len == 0)
+      {  /* empty objective */
+         sprintf(term, " 0 %s", col_name(csa, 1, name));
+         strcat(line, term);
+      }
+      xfprintf(fp, "%s\n", line), count++;
+      if (P->c0 != 0.0)
+         xfprintf(fp, "\\* constant term = %.*g *\\\n", DBL_DIG, P->c0),
+            count++;
+      xfprintf(fp, "\n"), count++;
+      /* write the constraints section */
+      xfprintf(fp, "Subject To\n"), count++;
+      for (i = 1; i <= P->m; i++)
+      {  row = P->row[i];
+         if (row->type == GLP_FR) continue; /* skip free row */
+         row_name(csa, i, name);
+         sprintf(line, " %s:", name);
+         /* linear form */
+         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+         {  col_name(csa, aij->col->j, name);
+            if (aij->val == +1.0)
+               sprintf(term, " + %s", name);
+            else if (aij->val == -1.0)
+               sprintf(term, " - %s", name);
+            else if (aij->val > 0.0)
+               sprintf(term, " + %.*g %s", DBL_DIG, +aij->val, name);
+            else
+               sprintf(term, " - %.*g %s", DBL_DIG, -aij->val, name);
+            if (strlen(line) + strlen(term) > 72)
+               xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
+            strcat(line, term);
+         }
+         if (row->type == GLP_DB)
+         {  /* double-bounded (ranged) constraint */
+            sprintf(term, " - ~r_%d", i);
+            if (strlen(line) + strlen(term) > 72)
+               xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
+            strcat(line, term);
+         }
+         else if (row->ptr == NULL)
+         {  /* empty constraint */
+            sprintf(term, " 0 %s", col_name(csa, 1, name));
+            strcat(line, term);
+         }
+         /* right hand-side */
+         if (row->type == GLP_LO)
+            sprintf(term, " >= %.*g", DBL_DIG, row->lb);
+         else if (row->type == GLP_UP)
+            sprintf(term, " <= %.*g", DBL_DIG, row->ub);
+         else if (row->type == GLP_DB || row->type == GLP_FX)
+            sprintf(term, " = %.*g", DBL_DIG, row->lb);
          else
-            xassert(csa != csa);
-         if (ret != 0)
-         {  xprintf("Model postsolving error\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /*--------------------------------------------------------------*/
-      /* write problem solution in printable format, if required */
-      if (csa->out_sol != NULL)
-      {  if (csa->solution == SOL_BASIC)
-            ret = lpx_print_sol(csa->prob, csa->out_sol);
-         else if (csa->solution == SOL_INTERIOR)
-            ret = lpx_print_ips(csa->prob, csa->out_sol);
-         else if (csa->solution == SOL_INTEGER)
-            ret = lpx_print_mip(csa->prob, csa->out_sol);
+            xassert(row != row);
+         if (strlen(line) + strlen(term) > 72)
+            xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
+         strcat(line, term);
+         xfprintf(fp, "%s\n", line), count++;
+      }
+      xfprintf(fp, "\n"), count++;
+      /* write the bounds section */
+      flag = 0;
+      for (i = 1; i <= P->m; i++)
+      {  row = P->row[i];
+         if (row->type != GLP_DB) continue;
+         if (!flag)
+            xfprintf(fp, "Bounds\n"), flag = 1, count++;
+         xfprintf(fp, " 0 <= ~r_%d <= %.*g\n",
+            i, DBL_DIG, row->ub - row->lb), count++;
+      }
+      for (j = 1; j <= P->n; j++)
+      {  col = P->col[j];
+         if (col->type == GLP_LO && col->lb == 0.0) continue;
+         if (!flag)
+            xfprintf(fp, "Bounds\n"), flag = 1, count++;
+         col_name(csa, j, name);
+         if (col->type == GLP_FR)
+            xfprintf(fp, " %s free\n", name), count++;
+         else if (col->type == GLP_LO)
+            xfprintf(fp, " %s >= %.*g\n",
+               name, DBL_DIG, col->lb), count++;
+         else if (col->type == GLP_UP)
+            xfprintf(fp, " -Inf <= %s <= %.*g\n",
+               name, DBL_DIG, col->ub), count++;
+         else if (col->type == GLP_DB)
+            xfprintf(fp, " %.*g <= %s <= %.*g\n",
+               DBL_DIG, col->lb, name, DBL_DIG, col->ub), count++;
+         else if (col->type == GLP_FX)
+            xfprintf(fp, " %s = %.*g\n",
+               name, DBL_DIG, col->lb), count++;
          else
-            xassert(csa != csa);
-         if (ret != 0)
-         {  xprintf("Unable to write problem solution\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
+            xassert(col != col);
       }
-      /* write problem solution in printable format, if required */
-      if (csa->out_res != NULL)
-      {  if (csa->solution == SOL_BASIC)
-            ret = glp_write_sol(csa->prob, csa->out_res);
-         else if (csa->solution == SOL_INTERIOR)
-            ret = glp_write_ipt(csa->prob, csa->out_res);
-         else if (csa->solution == SOL_INTEGER)
-            ret = glp_write_mip(csa->prob, csa->out_res);
-         else
-            xassert(csa != csa);
-         if (ret != 0)
-         {  xprintf("Unable to write problem solution\n");
-            ret = EXIT_FAILURE;
-            goto done;
-         }
-      }
-      /* write sensitivity analysis report, if required */
-      if (csa->out_ranges != NULL)
-      {  if (csa->solution == SOL_BASIC)
-         {  if (glp_get_status(csa->prob) == GLP_OPT)
-            {  if (glp_bf_exists(csa->prob))
-ranges:        {  ret = glp_print_ranges(csa->prob, 0, NULL, 0,
-                     csa->out_ranges);
-                  if (ret != 0)
-                  {  xprintf("Unable to write sensitivity analysis repo"
-                        "rt\n");
-                     ret = EXIT_FAILURE;
-                     goto done;
-                  }
-               }
-               else
-               {  ret = glp_factorize(csa->prob);
-                  if (ret == 0) goto ranges;
-                  xprintf("Cannot produce sensitivity analysis report d"
-                     "ue to error in basis factorization (glp_factorize"
-                     " returned %d); try --nopresol\n", ret);
-               }
-            }
-            else
-               xprintf("Cannot produce sensitivity analysis report for "
-                  "non-optimal basic solution\n");
-         }
-         else
-            xprintf("Cannot produce sensitivity analysis report for int"
-               "erior-point or MIP solution\n");
+      if (flag) xfprintf(fp, "\n"), count++;
+      /* write the integer section */
+      flag = 0;
+      for (j = 1; j <= P->n; j++)
+      {  col = P->col[j];
+         if (col->kind == GLP_CV) continue;
+         xassert(col->kind == GLP_IV);
+         if (!flag)
+            xfprintf(fp, "Generals\n"), flag = 1, count++;
+         xfprintf(fp, " %s\n", col_name(csa, j, name)), count++;
+      }
+      if (flag) xfprintf(fp, "\n"), count++;
+skip: /* write the end keyword */
+      xfprintf(fp, "End\n"), count++;
+#if 0 /* FIXME */
+      xfflush(fp);
+#endif
+      if (glp_ioerr(fp))
+      {  xprintf("Write error on '%s' - %s\n", fname, get_err_msg());
+         ret = 1;
+         goto done;
       }
-      /*--------------------------------------------------------------*/
-      /* all seems to be ok */
-      ret = EXIT_SUCCESS;
-      /*--------------------------------------------------------------*/
-done: /* delete the LP/MIP problem object */
-      if (csa->prob != NULL)
-         glp_delete_prob(csa->prob);
-      /* free the translator workspace, if necessary */
-      if (csa->tran != NULL)
-         glp_mpl_free_wksp(csa->tran);
-      /* delete the network problem object, if necessary */
-      if (csa->graph != NULL)
-         glp_delete_graph(csa->graph);
-      xassert(gmp_pool_count() == 0);
-      gmp_free_mem();
-      /* close log file, if necessary */
-      if (csa->log_file != NULL) glp_close_tee();
-      /* check that no memory blocks are still allocated */
-      {  int count;
-         glp_long total;
-         glp_mem_usage(&count, NULL, &total, NULL);
-         if (count != 0)
-            xerror("Error: %d memory block(s) were lost\n", count);
-         xassert(count == 0);
-         xassert(total.lo == 0 && total.hi == 0);
-      }
-      /* free the GLPK environment */
-      glp_free_env();
-      /* return to the control program */
+      /* problem data has been successfully written */
+      xprintf("%d lines were written\n", count);
+      ret = 0;
+done: if (fp != NULL) glp_close(fp);
       return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpavl.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/avl.c`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpavl.c (binary search tree) */
+/* avl.c (binary search tree) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,64 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpavl.h"
+#include "avl.h"
+#include "dmp.h"
+#include "env.h"
+
+struct AVL
+{     /* AVL tree (Adelson-Velsky & Landis binary search tree) */
+      DMP *pool;
+      /* memory pool for allocating nodes */
+      AVLNODE *root;
+      /* pointer to the root node */
+      int (*fcmp)(void *info, const void *key1, const void *key2);
+      /* application-defined key comparison routine */
+      void *info;
+      /* transit pointer passed to the routine fcmp */
+      int size;
+      /* the tree size (the total number of nodes) */
+      int height;
+      /* the tree height */
+};
+
+struct AVLNODE
+{     /* node of AVL tree */
+      const void *key;
+      /* pointer to the node key (data structure for representing keys
+         is supplied by the application) */
+      int rank;
+      /* node rank = relative position of the node in its own subtree =
+         the number of nodes in the left subtree plus one */
+      int type;
+      /* reserved for the application specific information */
+      void *link;
+      /* reserved for the application specific information */
+      AVLNODE *up;
+      /* pointer to the parent node */
+      short int flag;
+      /* node flag:
+         0 - this node is the left child of its parent (or this node is
+             the root of the tree and has no parent)
+         1 - this node is the right child of its parent */
+      short int bal;
+      /* node balance = the difference between heights of the right and
+         left subtrees:
+         -1 - the left subtree is higher than the right one;
+          0 - the left and right subtrees have the same height;
+         +1 - the left subtree is lower than the right one */
+      AVLNODE *left;
+      /* pointer to the root of the left subtree */
+      AVLNODE *right;
+      /* pointer to the root of the right subtree */
+};
 
 AVL *avl_create_tree(int (*fcmp)(void *info, const void *key1,
       const void *key2), void *info)
 {     /* create AVL tree */
       AVL *tree;
       tree = xmalloc(sizeof(AVL));
       tree->pool = dmp_create_pool();
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios11.c`

 * *Files 26% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpbfd.c (LP basis factorization driver) */
+/* glpios11.c (process cuts stored in the local cut pool) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2005-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,468 +15,418 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-typedef struct BFD BFD;
-
-#define GLPBFD_PRIVATE
-#include "glpapi.h"
-#include "glpfhv.h"
-#include "glplpf.h"
-
-/* CAUTION: DO NOT CHANGE THE LIMIT BELOW */
-
-#define M_MAX 100000000 /* = 100*10^6 */
-/* maximal order of the basis matrix */
-
-struct BFD
-{     /* LP basis factorization */
-      int valid;
-      /* factorization is valid only if this flag is set */
-      int type;
-      /* factorization type:
-         GLP_BF_FT - LUF + Forrest-Tomlin
-         GLP_BF_BG - LUF + Schur compl. + Bartels-Golub
-         GLP_BF_GR - LUF + Schur compl. + Givens rotation */
-      FHV *fhv;
-      /* LP basis factorization (GLP_BF_FT) */
-      LPF *lpf;
-      /* LP basis factorization (GLP_BF_BG, GLP_BF_GR) */
-      int lu_size;      /* luf.sv_size */
-      double piv_tol;   /* luf.piv_tol */
-      int piv_lim;      /* luf.piv_lim */
-      int suhl;         /* luf.suhl */
-      double eps_tol;   /* luf.eps_tol */
-      double max_gro;   /* luf.max_gro */
-      int nfs_max;      /* fhv.hh_max */
-      double upd_tol;   /* fhv.upd_tol */
-      int nrs_max;      /* lpf.n_max */
-      int rs_size;      /* lpf.v_size */
-      /* internal control parameters */
-      int upd_lim;
-      /* the factorization update limit */
-      int upd_cnt;
-      /* the factorization update count */
-};
+#include "draft.h"
+#include "env.h"
+#include "ios.h"
 
 /***********************************************************************
 *  NAME
 *
-*  bfd_create_it - create LP basis factorization
+*  ios_process_cuts - process cuts stored in the local cut pool
 *
 *  SYNOPSIS
 *
-*  #include "glpbfd.h"
-*  BFD *bfd_create_it(void);
+*  #include "glpios.h"
+*  void ios_process_cuts(glp_tree *T);
 *
 *  DESCRIPTION
 *
-*  The routine bfd_create_it creates a program object, which represents
-*  a factorization of LP basis.
-*
-*  RETURNS
-*
-*  The routine bfd_create_it returns a pointer to the object created. */
+*  The routine ios_process_cuts analyzes each cut currently stored in
+*  the local cut pool, which must be non-empty, and either adds the cut
+*  to the current subproblem or just discards it. All cuts are assumed
+*  to be locally valid. On exit the local cut pool remains unchanged.
+*
+*  REFERENCES
+*
+*  1. E.Balas, S.Ceria, G.Cornuejols, "Mixed 0-1 Programming by
+*     Lift-and-Project in a Branch-and-Cut Framework", Management Sc.,
+*     42 (1996) 1229-1246.
+*
+*  2. G.Andreello, A.Caprara, and M.Fischetti, "Embedding Cuts in
+*     a Branch&Cut Framework: a Computational Study with {0,1/2}-Cuts",
+*     Preliminary Draft, October 28, 2003, pp.6-8. */
+
+struct info
+{     /* estimated cut efficiency */
+      IOSCUT *cut;
+      /* pointer to cut in the cut pool */
+      char flag;
+      /* if this flag is set, the cut is included into the current
+         subproblem */
+      double eff;
+      /* cut efficacy (normalized residual) */
+      double deg;
+      /* lower bound to objective degradation */
+};
 
-BFD *bfd_create_it(void)
-{     BFD *bfd;
-      bfd = xmalloc(sizeof(BFD));
-      bfd->valid = 0;
-      bfd->type = GLP_BF_FT;
-      bfd->fhv = NULL;
-      bfd->lpf = NULL;
-      bfd->lu_size = 0;
-      bfd->piv_tol = 0.10;
-      bfd->piv_lim = 4;
-      bfd->suhl = 1;
-      bfd->eps_tol = 1e-15;
-      bfd->max_gro = 1e+10;
-      bfd->nfs_max = 100;
-      bfd->upd_tol = 1e-6;
-      bfd->nrs_max = 100;
-      bfd->rs_size = 1000;
-      bfd->upd_lim = -1;
-      bfd->upd_cnt = 0;
-      return bfd;
+static int CDECL fcmp(const void *arg1, const void *arg2)
+{     const struct info *info1 = arg1, *info2 = arg2;
+      if (info1->deg == 0.0 && info2->deg == 0.0)
+      {  if (info1->eff > info2->eff) return -1;
+         if (info1->eff < info2->eff) return +1;
+      }
+      else
+      {  if (info1->deg > info2->deg) return -1;
+         if (info1->deg < info2->deg) return +1;
+      }
+      return 0;
 }
 
-/**********************************************************************/
+static double parallel(IOSCUT *a, IOSCUT *b, double work[]);
 
-void bfd_set_parm(BFD *bfd, const void *_parm)
-{     /* change LP basis factorization control parameters */
-      const glp_bfcp *parm = _parm;
-      xassert(bfd != NULL);
-      bfd->type = parm->type;
-      bfd->lu_size = parm->lu_size;
-      bfd->piv_tol = parm->piv_tol;
-      bfd->piv_lim = parm->piv_lim;
-      bfd->suhl = parm->suhl;
-      bfd->eps_tol = parm->eps_tol;
-      bfd->max_gro = parm->max_gro;
-      bfd->nfs_max = parm->nfs_max;
-      bfd->upd_tol = parm->upd_tol;
-      bfd->nrs_max = parm->nrs_max;
-      bfd->rs_size = parm->rs_size;
+#ifdef NEW_LOCAL /* 02/II-2018 */
+void ios_process_cuts(glp_tree *T)
+{     IOSPOOL *pool;
+      IOSCUT *cut;
+      GLPAIJ *aij;
+      struct info *info;
+      int k, kk, max_cuts, len, ret, *ind;
+      double *val, *work, rhs;
+      /* the current subproblem must exist */
+      xassert(T->curr != NULL);
+      /* the pool must exist and be non-empty */
+      pool = T->local;
+      xassert(pool != NULL);
+      xassert(pool->m > 0);
+      /* allocate working arrays */
+      info = xcalloc(1+pool->m, sizeof(struct info));
+      ind = xcalloc(1+T->n, sizeof(int));
+      val = xcalloc(1+T->n, sizeof(double));
+      work = xcalloc(1+T->n, sizeof(double));
+      for (k = 1; k <= T->n; k++) work[k] = 0.0;
+      /* build the list of cuts stored in the cut pool */
+      for (k = 1; k <= pool->m; k++)
+         info[k].cut = pool->row[k], info[k].flag = 0;
+      /* estimate efficiency of all cuts in the cut pool */
+      for (k = 1; k <= pool->m; k++)
+      {  double temp, dy, dz;
+         cut = info[k].cut;
+         /* build the vector of cut coefficients and compute its
+            Euclidean norm */
+         len = 0; temp = 0.0;
+         for (aij = cut->ptr; aij != NULL; aij = aij->r_next)
+         {  xassert(1 <= aij->col->j && aij->col->j <= T->n);
+            len++, ind[len] = aij->col->j, val[len] = aij->val;
+            temp += aij->val * aij->val;
+         }
+         if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;
+         /* transform the cut to express it only through non-basic
+            (auxiliary and structural) variables */
+         len = glp_transform_row(T->mip, len, ind, val);
+         /* determine change in the cut value and in the objective
+            value for the adjacent basis by simulating one step of the
+            dual simplex */
+         switch (cut->type)
+         {  case GLP_LO: rhs = cut->lb; break;
+            case GLP_UP: rhs = cut->ub; break;
+            default: xassert(cut != cut);
+         }
+         ret = _glp_analyze_row(T->mip, len, ind, val, cut->type,
+            rhs, 1e-9, NULL, NULL, NULL, NULL, &dy, &dz);
+         /* determine normalized residual and lower bound to objective
+            degradation */
+         if (ret == 0)
+         {  info[k].eff = fabs(dy) / sqrt(temp);
+            /* if some reduced costs violates (slightly) their zero
+               bounds (i.e. have wrong signs) due to round-off errors,
+               dz also may have wrong sign being close to zero */
+            if (T->mip->dir == GLP_MIN)
+            {  if (dz < 0.0) dz = 0.0;
+               info[k].deg = + dz;
+            }
+            else /* GLP_MAX */
+            {  if (dz > 0.0) dz = 0.0;
+               info[k].deg = - dz;
+            }
+         }
+         else if (ret == 1)
+         {  /* the constraint is not violated at the current point */
+            info[k].eff = info[k].deg = 0.0;
+         }
+         else if (ret == 2)
+         {  /* no dual feasible adjacent basis exists */
+            info[k].eff = 1.0;
+            info[k].deg = DBL_MAX;
+         }
+         else
+            xassert(ret != ret);
+         /* if the degradation is too small, just ignore it */
+         if (info[k].deg < 0.01) info[k].deg = 0.0;
+      }
+      /* sort the list of cuts by decreasing objective degradation and
+         then by decreasing efficacy */
+      qsort(&info[1], pool->m, sizeof(struct info), fcmp);
+      /* only first (most efficient) max_cuts in the list are qualified
+         as candidates to be added to the current subproblem */
+      max_cuts = (T->curr->level == 0 ? 90 : 10);
+      if (max_cuts > pool->m) max_cuts = pool->m;
+      /* add cuts to the current subproblem */
+#if 0
+      xprintf("*** adding cuts ***\n");
+#endif
+      for (k = 1; k <= max_cuts; k++)
+      {  int i, len;
+         /* if this cut seems to be inefficient, skip it */
+         if (info[k].deg < 0.01 && info[k].eff < 0.01) continue;
+         /* if the angle between this cut and every other cut included
+            in the current subproblem is small, skip this cut */
+         for (kk = 1; kk < k; kk++)
+         {  if (info[kk].flag)
+            {  if (parallel(info[k].cut, info[kk].cut, work) > 0.90)
+                  break;
+            }
+         }
+         if (kk < k) continue;
+         /* add this cut to the current subproblem */
+#if 0
+         xprintf("eff = %g; deg = %g\n", info[k].eff, info[k].deg);
+#endif
+         cut = info[k].cut, info[k].flag = 1;
+         i = glp_add_rows(T->mip, 1);
+         if (cut->name != NULL)
+            glp_set_row_name(T->mip, i, cut->name);
+         xassert(T->mip->row[i]->origin == GLP_RF_CUT);
+         T->mip->row[i]->klass = cut->klass;
+         len = 0;
+         for (aij = cut->ptr; aij != NULL; aij = aij->r_next)
+            len++, ind[len] = aij->col->j, val[len] = aij->val;
+         glp_set_mat_row(T->mip, i, len, ind, val);
+         switch (cut->type)
+         {  case GLP_LO: rhs = cut->lb; break;
+            case GLP_UP: rhs = cut->ub; break;
+            default: xassert(cut != cut);
+         }
+         glp_set_row_bnds(T->mip, i, cut->type, rhs, rhs);
+      }
+      /* free working arrays */
+      xfree(info);
+      xfree(ind);
+      xfree(val);
+      xfree(work);
       return;
 }
-
-/***********************************************************************
-*  NAME
-*
-*  bfd_factorize - compute LP basis factorization
-*
-*  SYNOPSIS
-*
-*  #include "glpbfd.h"
-*  int bfd_factorize(BFD *bfd, int m, int bh[], int (*col)(void *info,
-*     int j, int ind[], double val[]), void *info);
-*
-*  DESCRIPTION
-*
-*  The routine bfd_factorize computes the factorization of the basis
-*  matrix B specified by the routine col.
-*
-*  The parameter bfd specified the basis factorization data structure
-*  created with the routine bfd_create_it.
-*
-*  The parameter m specifies the order of B, m > 0.
-*
-*  The array bh specifies the basis header: bh[j], 1 <= j <= m, is the
-*  number of j-th column of B in some original matrix. The array bh is
-*  optional and can be specified as NULL.
-*
-*  The formal routine col specifies the matrix B to be factorized. To
-*  obtain j-th column of A the routine bfd_factorize calls the routine
-*  col with the parameter j (1 <= j <= n). In response the routine col
-*  should store row indices and numerical values of non-zero elements
-*  of j-th column of B to locations ind[1,...,len] and val[1,...,len],
-*  respectively, where len is the number of non-zeros in j-th column
-*  returned on exit. Neither zero nor duplicate elements are allowed.
-*
-*  The parameter info is a transit pointer passed to the routine col.
-*
-*  RETURNS
-*
-*  0  The factorization has been successfully computed.
-*
-*  BFD_ESING
-*     The specified matrix is singular within the working precision.
-*
-*  BFD_ECOND
-*     The specified matrix is ill-conditioned.
-*
-*  For more details see comments to the routine luf_factorize. */
-
-int bfd_factorize(BFD *bfd, int m, const int bh[], int (*col)
-      (void *info, int j, int ind[], double val[]), void *info)
-{     LUF *luf;
-      int nov, ret;
-      xassert(bfd != NULL);
-      xassert(1 <= m && m <= M_MAX);
-      /* invalidate the factorization */
-      bfd->valid = 0;
-      /* create the factorization, if necessary */
-      nov = 0;
-      switch (bfd->type)
-      {  case GLP_BF_FT:
-            if (bfd->lpf != NULL)
-               lpf_delete_it(bfd->lpf), bfd->lpf = NULL;
-            if (bfd->fhv == NULL)
-               bfd->fhv = fhv_create_it(), nov = 1;
-            break;
-         case GLP_BF_BG:
-         case GLP_BF_GR:
-            if (bfd->fhv != NULL)
-               fhv_delete_it(bfd->fhv), bfd->fhv = NULL;
-            if (bfd->lpf == NULL)
-               bfd->lpf = lpf_create_it(), nov = 1;
-            break;
-         default:
-            xassert(bfd != bfd);
-      }
-      /* set control parameters specific to LUF */
-      if (bfd->fhv != NULL)
-         luf = bfd->fhv->luf;
-      else if (bfd->lpf != NULL)
-         luf = bfd->lpf->luf;
-      else
-         xassert(bfd != bfd);
-      if (nov) luf->new_sva = bfd->lu_size;
-      luf->piv_tol = bfd->piv_tol;
-      luf->piv_lim = bfd->piv_lim;
-      luf->suhl = bfd->suhl;
-      luf->eps_tol = bfd->eps_tol;
-      luf->max_gro = bfd->max_gro;
-      /* set control parameters specific to FHV */
-      if (bfd->fhv != NULL)
-      {  if (nov) bfd->fhv->hh_max = bfd->nfs_max;
-         bfd->fhv->upd_tol = bfd->upd_tol;
-      }
-      /* set control parameters specific to LPF */
-      if (bfd->lpf != NULL)
-      {  if (nov) bfd->lpf->n_max = bfd->nrs_max;
-         if (nov) bfd->lpf->v_size = bfd->rs_size;
-      }
-      /* try to factorize the basis matrix */
-      if (bfd->fhv != NULL)
-      {  switch (fhv_factorize(bfd->fhv, m, col, info))
-         {  case 0:
-               break;
-            case FHV_ESING:
-               ret = BFD_ESING;
-               goto done;
-            case FHV_ECOND:
-               ret = BFD_ECOND;
-               goto done;
-            default:
-               xassert(bfd != bfd);
-         }
-      }
-      else if (bfd->lpf != NULL)
-      {  switch (lpf_factorize(bfd->lpf, m, bh, col, info))
-         {  case 0:
-               /* set the Schur complement update type */
-               switch (bfd->type)
-               {  case GLP_BF_BG:
-                     /* Bartels-Golub update */
-                     bfd->lpf->scf->t_opt = SCF_TBG;
-                     break;
-                  case GLP_BF_GR:
-                     /* Givens rotation update */
-                     bfd->lpf->scf->t_opt = SCF_TGR;
-                     break;
-                  default:
-                     xassert(bfd != bfd);
-               }
-               break;
-            case LPF_ESING:
-               ret = BFD_ESING;
-               goto done;
-            case LPF_ECOND:
-               ret = BFD_ECOND;
-               goto done;
-            default:
-               xassert(bfd != bfd);
+#else
+void ios_process_cuts(glp_tree *T)
+{     IOSPOOL *pool;
+      IOSCUT *cut;
+      IOSAIJ *aij;
+      struct info *info;
+      int k, kk, max_cuts, len, ret, *ind;
+      double *val, *work;
+      /* the current subproblem must exist */
+      xassert(T->curr != NULL);
+      /* the pool must exist and be non-empty */
+      pool = T->local;
+      xassert(pool != NULL);
+      xassert(pool->size > 0);
+      /* allocate working arrays */
+      info = xcalloc(1+pool->size, sizeof(struct info));
+      ind = xcalloc(1+T->n, sizeof(int));
+      val = xcalloc(1+T->n, sizeof(double));
+      work = xcalloc(1+T->n, sizeof(double));
+      for (k = 1; k <= T->n; k++) work[k] = 0.0;
+      /* build the list of cuts stored in the cut pool */
+      for (k = 0, cut = pool->head; cut != NULL; cut = cut->next)
+         k++, info[k].cut = cut, info[k].flag = 0;
+      xassert(k == pool->size);
+      /* estimate efficiency of all cuts in the cut pool */
+      for (k = 1; k <= pool->size; k++)
+      {  double temp, dy, dz;
+         cut = info[k].cut;
+         /* build the vector of cut coefficients and compute its
+            Euclidean norm */
+         len = 0; temp = 0.0;
+         for (aij = cut->ptr; aij != NULL; aij = aij->next)
+         {  xassert(1 <= aij->j && aij->j <= T->n);
+            len++, ind[len] = aij->j, val[len] = aij->val;
+            temp += aij->val * aij->val;
          }
+         if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;
+         /* transform the cut to express it only through non-basic
+            (auxiliary and structural) variables */
+         len = glp_transform_row(T->mip, len, ind, val);
+         /* determine change in the cut value and in the objective
+            value for the adjacent basis by simulating one step of the
+            dual simplex */
+         ret = _glp_analyze_row(T->mip, len, ind, val, cut->type,
+            cut->rhs, 1e-9, NULL, NULL, NULL, NULL, &dy, &dz);
+         /* determine normalized residual and lower bound to objective
+            degradation */
+         if (ret == 0)
+         {  info[k].eff = fabs(dy) / sqrt(temp);
+            /* if some reduced costs violates (slightly) their zero
+               bounds (i.e. have wrong signs) due to round-off errors,
+               dz also may have wrong sign being close to zero */
+            if (T->mip->dir == GLP_MIN)
+            {  if (dz < 0.0) dz = 0.0;
+               info[k].deg = + dz;
+            }
+            else /* GLP_MAX */
+            {  if (dz > 0.0) dz = 0.0;
+               info[k].deg = - dz;
+            }
+         }
+         else if (ret == 1)
+         {  /* the constraint is not violated at the current point */
+            info[k].eff = info[k].deg = 0.0;
+         }
+         else if (ret == 2)
+         {  /* no dual feasible adjacent basis exists */
+            info[k].eff = 1.0;
+            info[k].deg = DBL_MAX;
+         }
+         else
+            xassert(ret != ret);
+         /* if the degradation is too small, just ignore it */
+         if (info[k].deg < 0.01) info[k].deg = 0.0;
       }
-      else
-         xassert(bfd != bfd);
-      /* the basis matrix has been successfully factorized */
-      bfd->valid = 1;
-      bfd->upd_cnt = 0;
-      ret = 0;
-done: /* return to the calling program */
-      return ret;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  bfd_ftran - perform forward transformation (solve system B*x = b)
-*
-*  SYNOPSIS
-*
-*  #include "glpbfd.h"
-*  void bfd_ftran(BFD *bfd, double x[]);
-*
-*  DESCRIPTION
-*
-*  The routine bfd_ftran performs forward transformation, i.e. solves
-*  the system B*x = b, where B is the basis matrix, x is the vector of
-*  unknowns to be computed, b is the vector of right-hand sides.
-*
-*  On entry elements of the vector b should be stored in dense format
-*  in locations x[1], ..., x[m], where m is the number of rows. On exit
-*  the routine stores elements of the vector x in the same locations. */
-
-void bfd_ftran(BFD *bfd, double x[])
-{     xassert(bfd != NULL);
-      xassert(bfd->valid);
-      if (bfd->fhv != NULL)
-         fhv_ftran(bfd->fhv, x);
-      else if (bfd->lpf != NULL)
-         lpf_ftran(bfd->lpf, x);
-      else
-         xassert(bfd != bfd);
+      /* sort the list of cuts by decreasing objective degradation and
+         then by decreasing efficacy */
+      qsort(&info[1], pool->size, sizeof(struct info), fcmp);
+      /* only first (most efficient) max_cuts in the list are qualified
+         as candidates to be added to the current subproblem */
+      max_cuts = (T->curr->level == 0 ? 90 : 10);
+      if (max_cuts > pool->size) max_cuts = pool->size;
+      /* add cuts to the current subproblem */
+#if 0
+      xprintf("*** adding cuts ***\n");
+#endif
+      for (k = 1; k <= max_cuts; k++)
+      {  int i, len;
+         /* if this cut seems to be inefficient, skip it */
+         if (info[k].deg < 0.01 && info[k].eff < 0.01) continue;
+         /* if the angle between this cut and every other cut included
+            in the current subproblem is small, skip this cut */
+         for (kk = 1; kk < k; kk++)
+         {  if (info[kk].flag)
+            {  if (parallel(info[k].cut, info[kk].cut, work) > 0.90)
+                  break;
+            }
+         }
+         if (kk < k) continue;
+         /* add this cut to the current subproblem */
+#if 0
+         xprintf("eff = %g; deg = %g\n", info[k].eff, info[k].deg);
+#endif
+         cut = info[k].cut, info[k].flag = 1;
+         i = glp_add_rows(T->mip, 1);
+         if (cut->name != NULL)
+            glp_set_row_name(T->mip, i, cut->name);
+         xassert(T->mip->row[i]->origin == GLP_RF_CUT);
+         T->mip->row[i]->klass = cut->klass;
+         len = 0;
+         for (aij = cut->ptr; aij != NULL; aij = aij->next)
+            len++, ind[len] = aij->j, val[len] = aij->val;
+         glp_set_mat_row(T->mip, i, len, ind, val);
+         xassert(cut->type == GLP_LO || cut->type == GLP_UP);
+         glp_set_row_bnds(T->mip, i, cut->type, cut->rhs, cut->rhs);
+      }
+      /* free working arrays */
+      xfree(info);
+      xfree(ind);
+      xfree(val);
+      xfree(work);
       return;
 }
+#endif
 
+#if 0
 /***********************************************************************
-*  NAME
-*
-*  bfd_btran - perform backward transformation (solve system B'*x = b)
-*
-*  SYNOPSIS
-*
-*  #include "glpbfd.h"
-*  void bfd_btran(BFD *bfd, double x[]);
+*  Given a cut a * x >= b (<= b) the routine efficacy computes the cut
+*  efficacy as follows:
 *
-*  DESCRIPTION
+*     eff = d * (a * x~ - b) / ||a||,
 *
-*  The routine bfd_btran performs backward transformation, i.e. solves
-*  the system B'*x = b, where B' is a matrix transposed to the basis
-*  matrix B, x is the vector of unknowns to be computed, b is the vector
-*  of right-hand sides.
-*
-*  On entry elements of the vector b should be stored in dense format
-*  in locations x[1], ..., x[m], where m is the number of rows. On exit
-*  the routine stores elements of the vector x in the same locations. */
-
-void bfd_btran(BFD *bfd, double x[])
-{     xassert(bfd != NULL);
-      xassert(bfd->valid);
-      if (bfd->fhv != NULL)
-         fhv_btran(bfd->fhv, x);
-      else if (bfd->lpf != NULL)
-         lpf_btran(bfd->lpf, x);
+*  where d is -1 (in case of '>= b') or +1 (in case of '<= b'), x~ is
+*  the vector of values of structural variables in optimal solution to
+*  LP relaxation of the current subproblem, ||a|| is the Euclidean norm
+*  of the vector of cut coefficients.
+*
+*  If the cut is violated at point x~, the efficacy eff is positive,
+*  and its value is the Euclidean distance between x~ and the cut plane
+*  a * x = b in the space of structural variables.
+*
+*  Following geometrical intuition, it is quite natural to consider
+*  this distance as a first-order measure of the expected efficacy of
+*  the cut: the larger the distance the better the cut [1]. */
+
+static double efficacy(glp_tree *T, IOSCUT *cut)
+{     glp_prob *mip = T->mip;
+      IOSAIJ *aij;
+      double s = 0.0, t = 0.0, temp;
+      for (aij = cut->ptr; aij != NULL; aij = aij->next)
+      {  xassert(1 <= aij->j && aij->j <= mip->n);
+         s += aij->val * mip->col[aij->j]->prim;
+         t += aij->val * aij->val;
+      }
+      temp = sqrt(t);
+      if (temp < DBL_EPSILON) temp = DBL_EPSILON;
+      if (cut->type == GLP_LO)
+         temp = (s >= cut->rhs ? 0.0 : (cut->rhs - s) / temp);
+      else if (cut->type == GLP_UP)
+         temp = (s <= cut->rhs ? 0.0 : (s - cut->rhs) / temp);
       else
-         xassert(bfd != bfd);
-      return;
+         xassert(cut != cut);
+      return temp;
 }
+#endif
 
 /***********************************************************************
-*  NAME
-*
-*  bfd_update_it - update LP basis factorization
-*
-*  SYNOPSIS
-*
-*  #include "glpbfd.h"
-*  int bfd_update_it(BFD *bfd, int j, int bh, int len, const int ind[],
-*     const double val[]);
-*
-*  DESCRIPTION
-*
-*  The routine bfd_update_it updates the factorization of the basis
-*  matrix B after replacing its j-th column by a new vector.
-*
-*  The parameter j specifies the number of column of B, which has been
-*  replaced, 1 <= j <= m, where m is the order of B.
-*
-*  The parameter bh specifies the basis header entry for the new column
-*  of B, which is the number of the new column in some original matrix.
-*  This parameter is optional and can be specified as 0.
-*
-*  Row indices and numerical values of non-zero elements of the new
-*  column of B should be placed in locations ind[1], ..., ind[len] and
-*  val[1], ..., val[len], resp., where len is the number of non-zeros
-*  in the column. Neither zero nor duplicate elements are allowed.
-*
-*  RETURNS
-*
-*  0  The factorization has been successfully updated.
-*
-*  BFD_ESING
-*     New basis matrix is singular within the working precision.
-*
-*  BFD_ECHECK
-*     The factorization is inaccurate.
-*
-*  BFD_ELIMIT
-*     Factorization update limit has been reached.
-*
-*  BFD_EROOM
-*     Overflow of the sparse vector area.
-*
-*  In case of non-zero return code the factorization becomes invalid.
-*  It should not be used until it has been recomputed with the routine
-*  bfd_factorize. */
-
-int bfd_update_it(BFD *bfd, int j, int bh, int len, const int ind[],
-      const double val[])
-{     int ret;
-      xassert(bfd != NULL);
-      xassert(bfd->valid);
-      /* try to update the factorization */
-      if (bfd->fhv != NULL)
-      {  switch (fhv_update_it(bfd->fhv, j, len, ind, val))
-         {  case 0:
-               break;
-            case FHV_ESING:
-               bfd->valid = 0;
-               ret = BFD_ESING;
-               goto done;
-            case FHV_ECHECK:
-               bfd->valid = 0;
-               ret = BFD_ECHECK;
-               goto done;
-            case FHV_ELIMIT:
-               bfd->valid = 0;
-               ret = BFD_ELIMIT;
-               goto done;
-            case FHV_EROOM:
-               bfd->valid = 0;
-               ret = BFD_EROOM;
-               goto done;
-            default:
-               xassert(bfd != bfd);
-         }
-      }
-      else if (bfd->lpf != NULL)
-      {  switch (lpf_update_it(bfd->lpf, j, bh, len, ind, val))
-         {  case 0:
-               break;
-            case LPF_ESING:
-               bfd->valid = 0;
-               ret = BFD_ESING;
-               goto done;
-            case LPF_ELIMIT:
-               bfd->valid = 0;
-               ret = BFD_ELIMIT;
-               goto done;
-            default:
-               xassert(bfd != bfd);
-         }
+*  Given two cuts a1 * x >= b1 (<= b1) and a2 * x >= b2 (<= b2) the
+*  routine parallel computes the cosine of angle between the cut planes
+*  a1 * x = b1 and a2 * x = b2 (which is the acute angle between two
+*  normals to these planes) in the space of structural variables as
+*  follows:
+*
+*     cos phi = (a1' * a2) / (||a1|| * ||a2||),
+*
+*  where (a1' * a2) is a dot product of vectors of cut coefficients,
+*  ||a1|| and ||a2|| are Euclidean norms of vectors a1 and a2.
+*
+*  Note that requirement cos phi = 0 forces the cuts to be orthogonal,
+*  i.e. with disjoint support, while requirement cos phi <= 0.999 means
+*  only avoiding duplicate (parallel) cuts [1]. */
+
+#ifdef NEW_LOCAL /* 02/II-2018 */
+static double parallel(IOSCUT *a, IOSCUT *b, double work[])
+{     GLPAIJ *aij;
+      double s = 0.0, sa = 0.0, sb = 0.0, temp;
+      for (aij = a->ptr; aij != NULL; aij = aij->r_next)
+      {  work[aij->col->j] = aij->val;
+         sa += aij->val * aij->val;
       }
-      else
-         xassert(bfd != bfd);
-      /* the factorization has been successfully updated */
-      /* increase the update count */
-      bfd->upd_cnt++;
-      ret = 0;
-done: /* return to the calling program */
-      return ret;
-}
-
-/**********************************************************************/
-
-int bfd_get_count(BFD *bfd)
-{     /* determine factorization update count */
-      xassert(bfd != NULL);
-      xassert(bfd->valid);
-      return bfd->upd_cnt;
+      for (aij = b->ptr; aij != NULL; aij = aij->r_next)
+      {  s += work[aij->col->j] * aij->val;
+         sb += aij->val * aij->val;
+      }
+      for (aij = a->ptr; aij != NULL; aij = aij->r_next)
+         work[aij->col->j] = 0.0;
+      temp = sqrt(sa) * sqrt(sb);
+      if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;
+      return s / temp;
 }
-
-/***********************************************************************
-*  NAME
-*
-*  bfd_delete_it - delete LP basis factorization
-*
-*  SYNOPSIS
-*
-*  #include "glpbfd.h"
-*  void bfd_delete_it(BFD *bfd);
-*
-*  DESCRIPTION
-*
-*  The routine bfd_delete_it deletes LP basis factorization specified
-*  by the parameter fhv and frees all memory allocated to this program
-*  object. */
-
-void bfd_delete_it(BFD *bfd)
-{     xassert(bfd != NULL);
-      if (bfd->fhv != NULL)
-         fhv_delete_it(bfd->fhv);
-      if (bfd->lpf != NULL)
-         lpf_delete_it(bfd->lpf);
-      xfree(bfd);
-      return;
+#else
+static double parallel(IOSCUT *a, IOSCUT *b, double work[])
+{     IOSAIJ *aij;
+      double s = 0.0, sa = 0.0, sb = 0.0, temp;
+      for (aij = a->ptr; aij != NULL; aij = aij->next)
+      {  work[aij->j] = aij->val;
+         sa += aij->val * aij->val;
+      }
+      for (aij = b->ptr; aij != NULL; aij = aij->next)
+      {  s += work[aij->j] * aij->val;
+         sb += aij->val * aij->val;
+      }
+      for (aij = a->ptr; aij != NULL; aij = aij->next)
+         work[aij->j] = 0.0;
+      temp = sqrt(sa) * sqrt(sb);
+      if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;
+      return s / temp;
 }
+#endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfd.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/bfd.h`

 * *Files 13% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpbfd.h (LP basis factorization driver) */
+/* bfd.h (LP basis factorization driver) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2007-2014 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,52 +15,84 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPBFD_H
-#define GLPBFD_H
+#ifndef BFD_H
+#define BFD_H
 
-#ifndef GLPBFD_PRIVATE
-typedef struct BFD BFD;
+#if 1 /* 30/III-2016 */
+#include "fvs.h"
 #endif
 
+typedef struct BFD BFD;
+
 /* return codes: */
 #define BFD_ESING    1  /* singular matrix */
 #define BFD_ECOND    2  /* ill-conditioned matrix */
 #define BFD_ECHECK   3  /* insufficient accuracy */
 #define BFD_ELIMIT   4  /* update limit reached */
+#if 0 /* 05/III-2014 */
 #define BFD_EROOM    5  /* SVA overflow */
+#endif
 
 #define bfd_create_it _glp_bfd_create_it
 BFD *bfd_create_it(void);
 /* create LP basis factorization */
 
+#if 0 /* 08/III-2014 */
 #define bfd_set_parm _glp_bfd_set_parm
 void bfd_set_parm(BFD *bfd, const void *parm);
 /* change LP basis factorization control parameters */
+#endif
+
+#define bfd_get_bfcp _glp_bfd_get_bfcp
+void bfd_get_bfcp(BFD *bfd, void /* glp_bfcp */ *parm);
+/* retrieve LP basis factorization control parameters */
+
+#define bfd_set_bfcp _glp_bfd_set_bfcp
+void bfd_set_bfcp(BFD *bfd, const void /* glp_bfcp */ *parm);
+/* change LP basis factorization control parameters */
 
 #define bfd_factorize _glp_bfd_factorize
-int bfd_factorize(BFD *bfd, int m, const int bh[], int (*col)
+int bfd_factorize(BFD *bfd, int m, /*const int bh[],*/ int (*col)
       (void *info, int j, int ind[], double val[]), void *info);
 /* compute LP basis factorization */
 
+#if 1 /* 21/IV-2014 */
+#define bfd_condest _glp_bfd_condest
+double bfd_condest(BFD *bfd);
+/* estimate condition of B */
+#endif
+
 #define bfd_ftran _glp_bfd_ftran
 void bfd_ftran(BFD *bfd, double x[]);
 /* perform forward transformation (solve system B*x = b) */
 
+#if 1 /* 30/III-2016 */
+#define bfd_ftran_s _glp_bfd_ftran_s
+void bfd_ftran_s(BFD *bfd, FVS *x);
+/* sparse version of bfd_ftran */
+#endif
+
 #define bfd_btran _glp_bfd_btran
 void bfd_btran(BFD *bfd, double x[]);
 /* perform backward transformation (solve system B'*x = b) */
 
-#define bfd_update_it _glp_bfd_update_it
-int bfd_update_it(BFD *bfd, int j, int bh, int len, const int ind[],
-      const double val[]);
+#if 1 /* 30/III-2016 */
+#define bfd_btran_s _glp_bfd_btran_s
+void bfd_btran_s(BFD *bfd, FVS *x);
+/* sparse version of bfd_btran */
+#endif
+
+#define bfd_update _glp_bfd_update
+int bfd_update(BFD *bfd, int j, int len, const int ind[], const double
+      val[]);
 /* update LP basis factorization */
 
 #define bfd_get_count _glp_bfd_get_count
 int bfd_get_count(BFD *bfd);
 /* determine factorization update count */
 
 #define bfd_delete_it _glp_bfd_delete_it
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfx.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/bfx.c`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpbfx.c */
+/* bfx.c (LP basis factorization driver, rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2007-2014 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,19 +15,17 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-typedef struct BFX BFX;
-#define GLPBFX_DEFINED
-#include "glpbfx.h"
-#include "glpenv.h"
-#include "glplux.h"
+#include "bfx.h"
+#include "env.h"
+#include "lux.h"
 
 struct BFX
 {     int valid;
       LUX *lux;
 };
 
 BFX *bfx_create_binv(void)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpbfx.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/bfx.h`

 * *Files 20% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpbfx.h (basis factorization interface, bignum arithmetic) */
+/* bfx.h (LP basis factorization driver, rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2007-2014 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,54 +15,50 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPBFX_H
-#define GLPBFX_H
+#ifndef BFX_H
+#define BFX_H
 
-#include "glpgmp.h"
+#include "mygmp.h"
 
-#ifndef GLPBFX_DEFINED
-#define GLPBFX_DEFINED
 typedef struct BFX BFX;
-#endif
-
-#define bfx_create_binv       _glp_bfx_create_binv
-#define bfx_is_valid          _glp_bfx_is_valid
-#define bfx_invalidate        _glp_bfx_invalidate
-#define bfx_factorize         _glp_bfx_factorize
-#define bfx_ftran             _glp_bfx_ftran
-#define bfx_btran             _glp_bfx_btran
-#define bfx_update            _glp_bfx_update
-#define bfx_delete_binv       _glp_bfx_delete_binv
 
+#define bfx_create_binv _glp_bfx_create_binv
 BFX *bfx_create_binv(void);
 /* create factorization of the basis matrix */
 
+#define bfx_is_valid _glp_bfx_is_valid
 int bfx_is_valid(BFX *binv);
 /* check if factorization is valid */
 
+#define bfx_invalidate _glp_bfx_invalidate
 void bfx_invalidate(BFX *binv);
 /* invalidate factorization of the basis matrix */
 
+#define bfx_factorize _glp_bfx_factorize
 int bfx_factorize(BFX *binv, int m, int (*col)(void *info, int j,
       int ind[], mpq_t val[]), void *info);
 /* compute factorization of the basis matrix */
 
+#define bfx_ftran _glp_bfx_ftran
 void bfx_ftran(BFX *binv, mpq_t x[], int save);
 /* perform forward transformation (FTRAN) */
 
+#define bfx_btran _glp_bfx_btran
 void bfx_btran(BFX *binv, mpq_t x[]);
 /* perform backward transformation (BTRAN) */
 
+#define bfx_update _glp_bfx_update
 int bfx_update(BFX *binv, int j);
 /* update factorization of the basis matrix */
 
+#define bfx_delete_binv _glp_bfx_delete_binv
 void bfx_delete_binv(BFX *binv);
 /* delete factorization of the basis matrix */
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpcpx.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/mps.c`

 * *Files 17% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpcpx.c (CPLEX LP format routines) */
+/* mps.c (MPS format routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2008-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,910 +15,983 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
+#include "env.h"
+#include "misc.h"
+#include "prob.h"
 
-#include "glpapi.h"
+#define xfprintf glp_format
 
 /***********************************************************************
 *  NAME
 *
-*  glp_init_cpxcp - initialize CPLEX LP format control parameters
+*  glp_init_mpscp - initialize MPS format control parameters
 *
 *  SYNOPSIS
 *
-*  void glp_init_cpxcp(glp_cpxcp *parm):
+*  void glp_init_mpscp(glp_mpscp *parm);
+*
+*  DESCRIPTION
 *
-*  The routine glp_init_cpxcp initializes control parameters used by
-*  the CPLEX LP input/output routines glp_read_lp and glp_write_lp with
-*  default values.
+*  The routine glp_init_mpscp initializes control parameters, which are
+*  used by the MPS input/output routines glp_read_mps and glp_write_mps,
+*  with default values.
 *
-*  Default values of the control parameters are stored in the glp_cpxcp
+*  Default values of the control parameters are stored in the glp_mpscp
 *  structure, which the parameter parm points to. */
 
-void glp_init_cpxcp(glp_cpxcp *parm)
-{     xassert(parm != NULL);
+void glp_init_mpscp(glp_mpscp *parm)
+{     parm->blank = '\0';
+      parm->obj_name = NULL;
+      parm->tol_mps = 1e-12;
       return;
 }
 
-static void check_parm(const char *func, const glp_cpxcp *parm)
+static void check_parm(const char *func, const glp_mpscp *parm)
 {     /* check control parameters */
-      xassert(func != NULL);
-      xassert(parm != NULL);
+      if (!(0x00 <= parm->blank && parm->blank <= 0xFF) ||
+          !(parm->blank == '\0' || isprint(parm->blank)))
+         xerror("%s: blank = 0x%02X; invalid parameter\n",
+            func, parm->blank);
+      if (!(parm->obj_name == NULL || strlen(parm->obj_name) <= 255))
+         xerror("%s: obj_name = \"%.12s...\"; parameter too long\n",
+            func, parm->obj_name);
+      if (!(0.0 <= parm->tol_mps && parm->tol_mps < 1.0))
+         xerror("%s: tol_mps = %g; invalid parameter\n",
+            func, parm->tol_mps);
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  glp_read_lp - read problem data in CPLEX LP format
+*  glp_read_mps - read problem data in MPS format
 *
 *  SYNOPSIS
 *
-*  int glp_read_lp(glp_prob *P, const glp_cpxcp *parm, const char
-*     *fname);
+*  int glp_read_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
+*     const char *fname);
 *
 *  DESCRIPTION
 *
-*  The routine glp_read_lp reads problem data in CPLEX LP format from
-*  a text file.
+*  The routine glp_read_mps reads problem data in MPS format from a
+*  text file.
+*
+*  The parameter fmt specifies the version of MPS format:
+*
+*  GLP_MPS_DECK - fixed (ancient) MPS format;
+*  GLP_MPS_FILE - free (modern) MPS format.
 *
-*  The parameter parm is a pointer to the structure glp_cpxcp, which
+*  The parameter parm is a pointer to the structure glp_mpscp, which
 *  specifies control parameters used by the routine. If parm is NULL,
 *  the routine uses default settings.
 *
 *  The character string fname specifies a name of the text file to be
 *  read.
 *
 *  Note that before reading data the current content of the problem
 *  object is completely erased with the routine glp_erase_prob.
 *
 *  RETURNS
 *
-*  If the operation was successful, the routine glp_read_lp returns
+*  If the operation was successful, the routine glp_read_mps returns
 *  zero. Otherwise, it prints an error message and returns non-zero. */
 
 struct csa
 {     /* common storage area */
       glp_prob *P;
-      /* LP/MIP problem object */
-      const glp_cpxcp *parm;
+      /* pointer to problem object */
+      int deck;
+      /* MPS format (0 - free, 1 - fixed) */
+      const glp_mpscp *parm;
       /* pointer to control parameters */
       const char *fname;
-      /* name of input CPLEX LP file */
-      XFILE *fp;
-      /* stream assigned to input CPLEX LP file */
+      /* name of input MPS file */
+      glp_file *fp;
+      /* stream assigned to input MPS file */
       jmp_buf jump;
       /* label for go to in case of error */
-      int count;
-      /* line count */
+      int recno;
+      /* current record (card) number */
+      int recpos;
+      /* current record (card) position */
       int c;
-      /* current character or XEOF */
-      int token;
-      /* current token: */
-#define T_EOF        0x00  /* end of file */
-#define T_MINIMIZE   0x01  /* keyword 'minimize' */
-#define T_MAXIMIZE   0x02  /* keyword 'maximize' */
-#define T_SUBJECT_TO 0x03  /* keyword 'subject to' */
-#define T_BOUNDS     0x04  /* keyword 'bounds' */
-#define T_GENERAL    0x05  /* keyword 'general' */
-#define T_INTEGER    0x06  /* keyword 'integer' */
-#define T_BINARY     0x07  /* keyword 'binary' */
-#define T_END        0x08  /* keyword 'end' */
-#define T_NAME       0x09  /* symbolic name */
-#define T_NUMBER     0x0A  /* numeric constant */
-#define T_PLUS       0x0B  /* delimiter '+' */
-#define T_MINUS      0x0C  /* delimiter '-' */
-#define T_COLON      0x0D  /* delimiter ':' */
-#define T_LE         0x0E  /* delimiter '<=' */
-#define T_GE         0x0F  /* delimiter '>=' */
-#define T_EQ         0x10  /* delimiter '=' */
-      char image[255+1];
-      /* image of current token */
-      int imlen;
-      /* length of token image */
-      double value;
-      /* value of numeric constant */
-      int n_max;
-      /* length of the following five arrays (enlarged automatically,
-         if necessary) */
-      int *ind; /* int ind[1+n_max]; */
-      double *val; /* double val[1+n_max]; */
-      char *flag; /* char flag[1+n_max]; */
-      /* working arrays used to construct linear forms */
-      double *lb; /* double lb[1+n_max]; */
-      double *ub; /* double ub[1+n_max]; */
-      /* lower and upper bounds of variables (columns) */
+      /* current character */
+      int fldno;
+      /* current field number */
+      char field[255+1];
+      /* current field content */
+      int w80;
+      /* warning 'record must not be longer than 80 chars' issued */
+      int wef;
+      /* warning 'extra fields detected beyond field 6' issued */
+      int obj_row;
+      /* objective row number */
+      void *work1, *work2, *work3;
+      /* working arrays */
 };
 
-#define CHAR_SET "!\"#$%&()/,.;?@_`'{}|~"
-/* characters, which may appear in symbolic names */
-
 static void error(struct csa *csa, const char *fmt, ...)
 {     /* print error message and terminate processing */
       va_list arg;
-      xprintf("%s:%d: ", csa->fname, csa->count);
+      xprintf("%s:%d: ", csa->fname, csa->recno);
       va_start(arg, fmt);
       xvprintf(fmt, arg);
       va_end(arg);
       longjmp(csa->jump, 1);
       /* no return */
 }
 
 static void warning(struct csa *csa, const char *fmt, ...)
 {     /* print warning message and continue processing */
       va_list arg;
-      xprintf("%s:%d: warning: ", csa->fname, csa->count);
+      xprintf("%s:%d: warning: ", csa->fname, csa->recno);
       va_start(arg, fmt);
       xvprintf(fmt, arg);
       va_end(arg);
       return;
 }
 
 static void read_char(struct csa *csa)
-{     /* read next character from input file */
+{     /* read next character */
       int c;
-      xassert(csa->c != XEOF);
-      if (csa->c == '\n') csa->count++;
-      c = xfgetc(csa->fp);
+      if (csa->c == '\n')
+         csa->recno++, csa->recpos = 0;
+      csa->recpos++;
+read: c = glp_getc(csa->fp);
       if (c < 0)
-      {  if (xferror(csa->fp))
-            error(csa, "read error - %s\n", xerrmsg());
+      {  if (glp_ioerr(csa->fp))
+            error(csa, "read error - %s\n", get_err_msg());
          else if (csa->c == '\n')
-         {  csa->count--;
-            c = XEOF;
-         }
+            error(csa, "unexpected end of file\n");
          else
          {  warning(csa, "missing final end of line\n");
             c = '\n';
          }
       }
       else if (c == '\n')
          ;
+      else if (csa->c == '\r')
+      {  c = '\r';
+         goto badc;
+      }
+      else if (csa->deck && c == '\r')
+      {  csa->c = '\r';
+         goto read;
+      }
+      else if (c == ' ')
+         ;
       else if (isspace(c))
+      {  if (csa->deck)
+badc:       error(csa, "in fixed MPS format white-space character 0x%02"
+               "X is not allowed\n", c);
          c = ' ';
+      }
       else if (iscntrl(c))
          error(csa, "invalid control character 0x%02X\n", c);
+      if (csa->deck && csa->recpos == 81 && c != '\n' && csa->w80 < 1)
+      {  warning(csa, "in fixed MPS format record must not be longer th"
+            "an 80 characters\n");
+         csa->w80++;
+      }
       csa->c = c;
       return;
 }
 
-static void add_char(struct csa *csa)
-{     /* append current character to current token */
-      if (csa->imlen == sizeof(csa->image)-1)
-         error(csa, "token `%.15s...' too long\n", csa->image);
-      csa->image[csa->imlen++] = (char)csa->c;
-      csa->image[csa->imlen] = '\0';
+static int indicator(struct csa *csa, int name)
+{     /* skip comment records and read possible indicator record */
+      int ret;
+      /* reset current field number */
+      csa->fldno = 0;
+loop: /* read the very first character of the next record */
+      xassert(csa->c == '\n');
       read_char(csa);
-      return;
-}
-
-static int the_same(char *s1, char *s2)
-{     /* compare two character strings ignoring case sensitivity */
-      for (; *s1 != '\0'; s1++, s2++)
-      {  if (tolower((unsigned char)*s1) != tolower((unsigned char)*s2))
-            return 0;
-      }
-      return 1;
-}
-
-static void scan_token(struct csa *csa)
-{     /* scan next token */
-      int flag;
-      csa->token = -1;
-      csa->image[0] = '\0';
-      csa->imlen = 0;
-      csa->value = 0.0;
-loop: flag = 0;
-      /* skip non-significant characters */
-      while (csa->c == ' ') read_char(csa);
-      /* recognize and scan current token */
-      if (csa->c == XEOF)
-         csa->token = T_EOF;
-      else if (csa->c == '\n')
-      {  read_char(csa);
-         /* if the next character is letter, it may begin a keyword */
-         if (isalpha(csa->c))
-         {  flag = 1;
-            goto name;
-         }
+      if (csa->c == ' ' || csa->c == '\n')
+      {  /* data record */
+         ret = 0;
+      }
+      else if (csa->c == '*')
+      {  /* comment record */
+         while (csa->c != '\n')
+            read_char(csa);
          goto loop;
       }
-      else if (csa->c == '\\')
-      {  /* comment; ignore everything until end-of-line */
-         while (csa->c != '\n') read_char(csa);
-         goto loop;
+      else
+      {  /* indicator record */
+         int len = 0;
+         while (csa->c != ' ' && csa->c != '\n' && len < 12)
+         {  csa->field[len++] = (char)csa->c;
+            read_char(csa);
+         }
+         csa->field[len] = '\0';
+         if (!(strcmp(csa->field, "NAME")    == 0 ||
+               strcmp(csa->field, "ROWS")    == 0 ||
+               strcmp(csa->field, "COLUMNS") == 0 ||
+               strcmp(csa->field, "RHS")     == 0 ||
+               strcmp(csa->field, "RANGES")  == 0 ||
+               strcmp(csa->field, "BOUNDS")  == 0 ||
+               strcmp(csa->field, "ENDATA")  == 0))
+            error(csa, "invalid indicator record\n");
+         if (!name)
+         {  while (csa->c != '\n')
+               read_char(csa);
+         }
+         ret = 1;
       }
-      else if (isalpha(csa->c) || csa->c != '.' && strchr(CHAR_SET,
-         csa->c) != NULL)
-name: {  /* symbolic name */
-         csa->token = T_NAME;
-         while (isalnum(csa->c) || strchr(CHAR_SET, csa->c) != NULL)
-            add_char(csa);
-         if (flag)
-         {  /* check for keyword */
-            if (the_same(csa->image, "minimize"))
-               csa->token = T_MINIMIZE;
-            else if (the_same(csa->image, "minimum"))
-               csa->token = T_MINIMIZE;
-            else if (the_same(csa->image, "min"))
-               csa->token = T_MINIMIZE;
-            else if (the_same(csa->image, "maximize"))
-               csa->token = T_MAXIMIZE;
-            else if (the_same(csa->image, "maximum"))
-               csa->token = T_MAXIMIZE;
-            else if (the_same(csa->image, "max"))
-               csa->token = T_MAXIMIZE;
-            else if (the_same(csa->image, "subject"))
+      return ret;
+}
+
+static void read_field(struct csa *csa)
+{     /* read next field of the current data record */
+      csa->fldno++;
+      if (csa->deck)
+      {  /* fixed MPS format */
+         int beg, end, pos;
+         /* determine predefined field positions */
+         if (csa->fldno == 1)
+            beg = 2, end = 3;
+         else if (csa->fldno == 2)
+            beg = 5, end = 12;
+         else if (csa->fldno == 3)
+            beg = 15, end = 22;
+         else if (csa->fldno == 4)
+            beg = 25, end = 36;
+         else if (csa->fldno == 5)
+            beg = 40, end = 47;
+         else if (csa->fldno == 6)
+            beg = 50, end = 61;
+         else
+            xassert(csa != csa);
+         /* skip blanks preceding the current field */
+         if (csa->c != '\n')
+         {  pos = csa->recpos;
+            while (csa->recpos < beg)
             {  if (csa->c == ' ')
-               {  read_char(csa);
-                  if (tolower(csa->c) == 't')
-                  {  csa->token = T_SUBJECT_TO;
-                     csa->image[csa->imlen++] = ' ';
-                     csa->image[csa->imlen] = '\0';
-                     add_char(csa);
-                     if (tolower(csa->c) != 'o')
-                        error(csa, "keyword `subject to' incomplete\n");
-                     add_char(csa);
-                     if (isalpha(csa->c))
-                        error(csa, "keyword `%s%c...' not recognized\n",
-                           csa->image, csa->c);
-                  }
-               }
+                  ;
+               else if (csa->c == '\n')
+                  break;
+               else
+                  error(csa, "in fixed MPS format positions %d-%d must "
+                     "be blank\n", pos, beg-1);
+               read_char(csa);
             }
-            else if (the_same(csa->image, "such"))
+         }
+         /* skip possible comment beginning in the field 3 or 5 */
+         if ((csa->fldno == 3 || csa->fldno == 5) && csa->c == '$')
+         {  while (csa->c != '\n')
+               read_char(csa);
+         }
+         /* read the current field */
+         for (pos = beg; pos <= end; pos++)
+         {  if (csa->c == '\n') break;
+            csa->field[pos-beg] = (char)csa->c;
+            read_char(csa);
+         }
+         csa->field[pos-beg] = '\0';
+         strtrim(csa->field);
+         /* skip blanks following the last field */
+         if (csa->fldno == 6 && csa->c != '\n')
+         {  while (csa->recpos <= 72)
             {  if (csa->c == ' ')
-               {  read_char(csa);
-                  if (tolower(csa->c) == 't')
-                  {  csa->token = T_SUBJECT_TO;
-                     csa->image[csa->imlen++] = ' ';
-                     csa->image[csa->imlen] = '\0';
-                     add_char(csa);
-                     if (tolower(csa->c) != 'h')
-err:                    error(csa, "keyword `such that' incomplete\n");
-                     add_char(csa);
-                     if (tolower(csa->c) != 'a') goto err;
-                     add_char(csa);
-                     if (tolower(csa->c) != 't') goto err;
-                     add_char(csa);
-                     if (isalpha(csa->c))
-                        error(csa, "keyword `%s%c...' not recognized\n",
-                           csa->image, csa->c);
-                  }
-               }
+                  ;
+               else if (csa->c == '\n')
+                  break;
+               else
+                  error(csa, "in fixed MPS format positions 62-72 must "
+                     "be blank\n");
+               read_char(csa);
             }
-            else if (the_same(csa->image, "st"))
-               csa->token = T_SUBJECT_TO;
-            else if (the_same(csa->image, "s.t."))
-               csa->token = T_SUBJECT_TO;
-            else if (the_same(csa->image, "st."))
-               csa->token = T_SUBJECT_TO;
-            else if (the_same(csa->image, "bounds"))
-               csa->token = T_BOUNDS;
-            else if (the_same(csa->image, "bound"))
-               csa->token = T_BOUNDS;
-            else if (the_same(csa->image, "general"))
-               csa->token = T_GENERAL;
-            else if (the_same(csa->image, "generals"))
-               csa->token = T_GENERAL;
-            else if (the_same(csa->image, "gen"))
-               csa->token = T_GENERAL;
-            else if (the_same(csa->image, "integer"))
-               csa->token = T_INTEGER;
-            else if (the_same(csa->image, "integers"))
-               csa->token = T_INTEGER;
-            else if (the_same(csa->image, "int"))
-              csa->token = T_INTEGER;
-            else if (the_same(csa->image, "binary"))
-               csa->token = T_BINARY;
-            else if (the_same(csa->image, "binaries"))
-               csa->token = T_BINARY;
-            else if (the_same(csa->image, "bin"))
-               csa->token = T_BINARY;
-            else if (the_same(csa->image, "end"))
-               csa->token = T_END;
-         }
-      }
-      else if (isdigit(csa->c) || csa->c == '.')
-      {  /* numeric constant */
-         csa->token = T_NUMBER;
-         /* scan integer part */
-         while (isdigit(csa->c)) add_char(csa);
-         /* scan optional fractional part (it is mandatory, if there is
-            no integer part) */
-         if (csa->c == '.')
-         {  add_char(csa);
-            if (csa->imlen == 1 && !isdigit(csa->c))
-               error(csa, "invalid use of decimal point\n");
-            while (isdigit(csa->c)) add_char(csa);
-         }
-         /* scan optional decimal exponent */
-         if (csa->c == 'e' || csa->c == 'E')
-         {  add_char(csa);
-            if (csa->c == '+' || csa->c == '-') add_char(csa);
-            if (!isdigit(csa->c))
-               error(csa, "numeric constant `%s' incomplete\n",
-                  csa->image);
-            while (isdigit(csa->c)) add_char(csa);
-         }
-         /* convert the numeric constant to floating-point */
-         if (str2num(csa->image, &csa->value))
-            error(csa, "numeric constant `%s' out of range\n",
-               csa->image);
-      }
-      else if (csa->c == '+')
-         csa->token = T_PLUS, add_char(csa);
-      else if (csa->c == '-')
-         csa->token = T_MINUS, add_char(csa);
-      else if (csa->c == ':')
-         csa->token = T_COLON, add_char(csa);
-      else if (csa->c == '<')
-      {  csa->token = T_LE, add_char(csa);
-         if (csa->c == '=') add_char(csa);
-      }
-      else if (csa->c == '>')
-      {  csa->token = T_GE, add_char(csa);
-         if (csa->c == '=') add_char(csa);
-      }
-      else if (csa->c == '=')
-      {  csa->token = T_EQ, add_char(csa);
-         if (csa->c == '<')
-            csa->token = T_LE, add_char(csa);
-         else if (csa->c == '>')
-            csa->token = T_GE, add_char(csa);
-      }
-      else
-         error(csa, "character `%c' not recognized\n", csa->c);
-      /* skip non-significant characters */
-      while (csa->c == ' ') read_char(csa);
-      return;
-}
-
-static int find_col(struct csa *csa, char *name)
-{     /* find column by its symbolic name */
-      int j;
-      j = glp_find_col(csa->P, name);
-      if (j == 0)
-      {  /* not found; create new column */
-         j = glp_add_cols(csa->P, 1);
-         glp_set_col_name(csa->P, j, name);
-         /* enlarge working arrays, if necessary */
-         if (csa->n_max < j)
-         {  int n_max = csa->n_max;
-            int *ind = csa->ind;
-            double *val = csa->val;
-            char *flag = csa->flag;
-            double *lb = csa->lb;
-            double *ub = csa->ub;
-            csa->n_max += csa->n_max;
-            csa->ind = xcalloc(1+csa->n_max, sizeof(int));
-            memcpy(&csa->ind[1], &ind[1], n_max * sizeof(int));
-            xfree(ind);
-            csa->val = xcalloc(1+csa->n_max, sizeof(double));
-            memcpy(&csa->val[1], &val[1], n_max * sizeof(double));
-            xfree(val);
-            csa->flag = xcalloc(1+csa->n_max, sizeof(char));
-            memset(&csa->flag[1], 0, csa->n_max * sizeof(char));
-            memcpy(&csa->flag[1], &flag[1], n_max * sizeof(char));
-            xfree(flag);
-            csa->lb = xcalloc(1+csa->n_max, sizeof(double));
-            memcpy(&csa->lb[1], &lb[1], n_max * sizeof(double));
-            xfree(lb);
-            csa->ub = xcalloc(1+csa->n_max, sizeof(double));
-            memcpy(&csa->ub[1], &ub[1], n_max * sizeof(double));
-            xfree(ub);
+            while (csa->c != '\n')
+               read_char(csa);
          }
-         csa->lb[j] = +DBL_MAX, csa->ub[j] = -DBL_MAX;
       }
-      return j;
-}
-
-/***********************************************************************
-*  parse_linear_form - parse linear form
-*
-*  This routine parses the linear form using the following syntax:
-*
-*  <variable> ::= <symbolic name>
-*  <coefficient> ::= <numeric constant>
-*  <term> ::= <variable> | <numeric constant> <variable>
-*  <linear form> ::= <term> | + <term> | - <term> |
-*     <linear form> + <term> | <linear form> - <term>
-*
-*  The routine returns the number of terms in the linear form. */
-
-static int parse_linear_form(struct csa *csa)
-{     int j, k, len = 0, newlen;
-      double s, coef;
-loop: /* parse an optional sign */
-      if (csa->token == T_PLUS)
-         s = +1.0, scan_token(csa);
-      else if (csa->token == T_MINUS)
-         s = -1.0, scan_token(csa);
-      else
-         s = +1.0;
-      /* parse an optional coefficient */
-      if (csa->token == T_NUMBER)
-         coef = csa->value, scan_token(csa);
-      else
-         coef = 1.0;
-      /* parse a variable name */
-      if (csa->token != T_NAME)
-         error(csa, "missing variable name\n");
-      /* find the corresponding column */
-      j = find_col(csa, csa->image);
-      /* check if the variable is already used in the linear form */
-      if (csa->flag[j])
-         error(csa, "multiple use of variable `%s' not allowed\n",
-            csa->image);
-      /* add new term to the linear form */
-      len++, csa->ind[len] = j, csa->val[len] = s * coef;
-      /* and mark that the variable is used in the linear form */
-      csa->flag[j] = 1;
-      scan_token(csa);
-      /* if the next token is a sign, there is another term */
-      if (csa->token == T_PLUS || csa->token == T_MINUS) goto loop;
-      /* clear marks of the variables used in the linear form */
-      for (k = 1; k <= len; k++) csa->flag[csa->ind[k]] = 0;
-      /* remove zero coefficients */
-      newlen = 0;
-      for (k = 1; k <= len; k++)
-      {  if (csa->val[k] != 0.0)
-         {  newlen++;
-            csa->ind[newlen] = csa->ind[k];
-            csa->val[newlen] = csa->val[k];
+      else
+      {  /* free MPS format */
+         int len;
+         /* skip blanks preceding the current field */
+         while (csa->c == ' ')
+            read_char(csa);
+         /* skip possible comment */
+         if (csa->c == '$')
+         {  while (csa->c != '\n')
+               read_char(csa);
+         }
+         /* read the current field */
+         len = 0;
+         while (!(csa->c == ' ' || csa->c == '\n'))
+         {  if (len == 255)
+               error(csa, "length of field %d exceeds 255 characters\n",
+                  csa->fldno++);
+            csa->field[len++] = (char)csa->c;
+            read_char(csa);
+         }
+         csa->field[len] = '\0';
+         /* skip anything following the last field (any extra fields
+            are considered to be comments) */
+         if (csa->fldno == 6)
+         {  while (csa->c == ' ')
+               read_char(csa);
+            if (csa->c != '$' && csa->c != '\n' && csa->wef < 1)
+            {  warning(csa, "some extra field(s) detected beyond field "
+                  "6; field(s) ignored\n");
+               csa->wef++;
+            }
+            while (csa->c != '\n')
+               read_char(csa);
          }
       }
-      return newlen;
+      return;
 }
 
-/***********************************************************************
-*  parse_objective - parse objective function
-*
-*  This routine parses definition of the objective function using the
-*  following syntax:
-*
-*  <obj sense> ::= minimize | minimum | min | maximize | maximum | max
-*  <obj name> ::= <empty> | <symbolic name> :
-*  <obj function> ::= <obj sense> <obj name> <linear form> */
-
-static void parse_objective(struct csa *csa)
-{     /* parse objective sense */
-      int k, len;
-      /* parse the keyword 'minimize' or 'maximize' */
-      if (csa->token == T_MINIMIZE)
-         glp_set_obj_dir(csa->P, GLP_MIN);
-      else if (csa->token == T_MAXIMIZE)
-         glp_set_obj_dir(csa->P, GLP_MAX);
-      else
-         xassert(csa != csa);
-      scan_token(csa);
-      /* parse objective name */
-      if (csa->token == T_NAME && csa->c == ':')
-      {  /* objective name is followed by a colon */
-         glp_set_obj_name(csa->P, csa->image);
-         scan_token(csa);
-         xassert(csa->token == T_COLON);
-         scan_token(csa);
-      }
-      else
-      {  /* objective name is not specified; use default */
-         glp_set_obj_name(csa->P, "obj");
-      }
-      /* parse linear form */
-      len = parse_linear_form(csa);
-      for (k = 1; k <= len; k++)
-         glp_set_obj_coef(csa->P, csa->ind[k], csa->val[k]);
+static void patch_name(struct csa *csa, char *name)
+{     /* process embedded blanks in symbolic name */
+      int blank = csa->parm->blank;
+      if (blank == '\0')
+      {  /* remove emedded blanks */
+         strspx(name);
+      }
+      else
+      {  /* replace embedded blanks by specified character */
+         for (; *name != '\0'; name++)
+            if (*name == ' ') *name = (char)blank;
+      }
       return;
 }
 
-/***********************************************************************
-*  parse_constraints - parse constraints section
-*
-*  This routine parses the constraints section using the following
-*  syntax:
-*
-*  <row name> ::= <empty> | <symbolic name> :
-*  <row sense> ::= < | <= | =< | > | >= | => | =
-*  <right-hand side> ::= <numeric constant> | + <numeric constant> |
-*     - <numeric constant>
-*  <constraint> ::= <row name> <linear form> <row sense>
-*     <right-hand side>
-*  <subject to> ::= subject to | such that | st | s.t. | st.
-*  <constraints section> ::= <subject to> <constraint> |
-*     <constraints section> <constraint> */
-
-static void parse_constraints(struct csa *csa)
-{     int i, len, type;
-      double s;
-      /* parse the keyword 'subject to' */
-      xassert(csa->token == T_SUBJECT_TO);
-      scan_token(csa);
-loop: /* create new row (constraint) */
-      i = glp_add_rows(csa->P, 1);
-      /* parse row name */
-      if (csa->token == T_NAME && csa->c == ':')
-      {  /* row name is followed by a colon */
-         if (glp_find_row(csa->P, csa->image) != 0)
-            error(csa, "constraint `%s' multiply defined\n",
-               csa->image);
-         glp_set_row_name(csa->P, i, csa->image);
-         scan_token(csa);
-         xassert(csa->token == T_COLON);
-         scan_token(csa);
-      }
-      else
-      {  /* row name is not specified; use default */
-         char name[50];
-         sprintf(name, "r.%d", csa->count);
-         glp_set_row_name(csa->P, i, name);
-      }
-      /* parse linear form */
-      len = parse_linear_form(csa);
-      glp_set_mat_row(csa->P, i, len, csa->ind, csa->val);
-      /* parse constraint sense */
-      if (csa->token == T_LE)
-         type = GLP_UP, scan_token(csa);
-      else if (csa->token == T_GE)
-         type = GLP_LO, scan_token(csa);
-      else if (csa->token == T_EQ)
-         type = GLP_FX, scan_token(csa);
-      else
-         error(csa, "missing constraint sense\n");
-      /* parse right-hand side */
-      if (csa->token == T_PLUS)
-         s = +1.0, scan_token(csa);
-      else if (csa->token == T_MINUS)
-         s = -1.0, scan_token(csa);
-      else
-         s = +1.0;
-      if (csa->token != T_NUMBER)
-         error(csa, "missing right-hand side\n");
-      glp_set_row_bnds(csa->P, i, type, s * csa->value, s * csa->value);
-      /* the rest of the current line must be empty */
-      if (!(csa->c == '\n' || csa->c == XEOF))
-         error(csa, "invalid symbol(s) beyond right-hand side\n");
-      scan_token(csa);
-      /* if the next token is a sign, numeric constant, or a symbolic
-         name, here is another constraint */
-      if (csa->token == T_PLUS || csa->token == T_MINUS ||
-          csa->token == T_NUMBER || csa->token == T_NAME) goto loop;
+static double read_number(struct csa *csa)
+{     /* read next field and convert it to floating-point number */
+      double x;
+      char *s;
+      /* read next field */
+      read_field(csa);
+      xassert(csa->fldno == 4 || csa->fldno == 6);
+      if (csa->field[0] == '\0')
+         error(csa, "missing numeric value in field %d\n", csa->fldno);
+      /* skip initial spaces of the field */
+      for (s = csa->field; *s == ' '; s++);
+      /* perform conversion */
+      if (str2num(s, &x) != 0)
+         error(csa, "cannot convert '%s' to floating-point number\n",
+            s);
+      return x;
+}
+
+static void skip_field(struct csa *csa)
+{     /* read and skip next field (assumed to be blank) */
+      read_field(csa);
+      if (csa->field[0] != '\0')
+         error(csa, "field %d must be blank\n", csa->fldno);
       return;
 }
 
-static void set_lower_bound(struct csa *csa, int j, double lb)
-{     /* set lower bound of j-th variable */
-      if (csa->lb[j] != +DBL_MAX)
-      {  warning(csa, "lower bound of variable `%s' redefined\n",
-            glp_get_col_name(csa->P, j));
-      }
-      csa->lb[j] = lb;
+static void read_name(struct csa *csa)
+{     /* read NAME indicator record */
+      if (!(indicator(csa, 1) && strcmp(csa->field, "NAME") == 0))
+         error(csa, "missing NAME indicator record\n");
+      /* this indicator record looks like a data record; simulate that
+         fields 1 and 2 were read */
+      csa->fldno = 2;
+      /* field 3: model name */
+      read_field(csa), patch_name(csa, csa->field);
+      if (csa->field[0] == '\0')
+         warning(csa, "missing model name in field 3\n");
+      else
+         glp_set_prob_name(csa->P, csa->field);
+      /* skip anything following field 3 */
+      while (csa->c != '\n')
+         read_char(csa);
       return;
 }
 
-static void set_upper_bound(struct csa *csa, int j, double ub)
-{     /* set upper bound of j-th variable */
-      if (csa->ub[j] != -DBL_MAX)
-      {  warning(csa, "upper bound of variable `%s' redefined\n",
-            glp_get_col_name(csa->P, j));
-      }
-      csa->ub[j] = ub;
-      return;
+static void read_rows(struct csa *csa)
+{     /* read ROWS section */
+      int i, type;
+loop: if (indicator(csa, 0)) goto done;
+      /* field 1: row type */
+      read_field(csa), strspx(csa->field);
+      if (strcmp(csa->field, "N") == 0)
+         type = GLP_FR;
+      else if (strcmp(csa->field, "G") == 0)
+         type = GLP_LO;
+      else if (strcmp(csa->field, "L") == 0)
+         type = GLP_UP;
+      else if (strcmp(csa->field, "E") == 0)
+         type = GLP_FX;
+      else if (csa->field[0] == '\0')
+         error(csa, "missing row type in field 1\n");
+      else
+         error(csa, "invalid row type in field 1\n");
+      /* field 2: row name */
+      read_field(csa), patch_name(csa, csa->field);
+      if (csa->field[0] == '\0')
+         error(csa, "missing row name in field 2\n");
+      if (glp_find_row(csa->P, csa->field) != 0)
+         error(csa, "row '%s' multiply specified\n", csa->field);
+      i = glp_add_rows(csa->P, 1);
+      glp_set_row_name(csa->P, i, csa->field);
+      glp_set_row_bnds(csa->P, i, type, 0.0, 0.0);
+      /* fields 3, 4, 5, and 6 must be blank */
+      skip_field(csa);
+      skip_field(csa);
+      skip_field(csa);
+      skip_field(csa);
+      goto loop;
+done: return;
 }
 
-/***********************************************************************
-*  parse_bounds - parse bounds section
-*
-*  This routine parses the bounds section using the following syntax:
-*
-*  <variable> ::= <symbolic name>
-*  <infinity> ::= infinity | inf
-*  <bound> ::= <numeric constant> | + <numeric constant> |
-*     - <numeric constant> | + <infinity> | - <infinity>
-*  <lt> ::= < | <= | =<
-*  <gt> ::= > | >= | =>
-*  <bound definition> ::= <bound> <lt> <variable> <lt> <bound> |
-*     <bound> <lt> <variable> | <variable> <lt> <bound> |
-*     <variable> <gt> <bound> | <variable> = <bound> | <variable> free
-*  <bounds> ::= bounds | bound
-*  <bounds section> ::= <bounds> |
-*     <bounds section> <bound definition> */
-
-static void parse_bounds(struct csa *csa)
-{     int j, lb_flag;
-      double lb, s;
-      /* parse the keyword 'bounds' */
-      xassert(csa->token == T_BOUNDS);
-      scan_token(csa);
-loop: /* bound definition can start with a sign, numeric constant, or
-         a symbolic name */
-      if (!(csa->token == T_PLUS || csa->token == T_MINUS ||
-            csa->token == T_NUMBER || csa->token == T_NAME)) goto done;
-      /* parse bound definition */
-      if (csa->token == T_PLUS || csa->token == T_MINUS)
-      {  /* parse signed lower bound */
-         lb_flag = 1;
-         s = (csa->token == T_PLUS ? +1.0 : -1.0);
-         scan_token(csa);
-         if (csa->token == T_NUMBER)
-            lb = s * csa->value, scan_token(csa);
-         else if (the_same(csa->image, "infinity") ||
-                  the_same(csa->image, "inf"))
-         {  if (s > 0.0)
-               error(csa, "invalid use of `+inf' as lower bound\n");
-            lb = -DBL_MAX, scan_token(csa);
+static void read_columns(struct csa *csa)
+{     /* read COLUMNS section */
+      int i, j, f, len, kind = GLP_CV, *ind;
+      double aij, *val;
+      char name[255+1], *flag;
+      /* allocate working arrays */
+      csa->work1 = ind = xcalloc(1+csa->P->m, sizeof(int));
+      csa->work2 = val = xcalloc(1+csa->P->m, sizeof(double));
+      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));
+      memset(&flag[1], 0, csa->P->m);
+      /* no current column exists */
+      j = 0, len = 0;
+loop: if (indicator(csa, 0)) goto done;
+      /* field 1 must be blank */
+      if (csa->deck)
+      {  read_field(csa);
+         if (csa->field[0] != '\0')
+            error(csa, "field 1 must be blank\n");
+      }
+      else
+         csa->fldno++;
+      /* field 2: column or kind name */
+      read_field(csa), patch_name(csa, csa->field);
+      strcpy(name, csa->field);
+      /* field 3: row name or keyword 'MARKER' */
+      read_field(csa), patch_name(csa, csa->field);
+      if (strcmp(csa->field, "'MARKER'") == 0)
+      {  /* process kind data record */
+         /* field 4 must be blank */
+         if (csa->deck)
+         {  read_field(csa);
+            if (csa->field[0] != '\0')
+               error(csa, "field 4 must be blank\n");
          }
          else
-            error(csa, "missing lower bound\n");
+            csa->fldno++;
+         /* field 5: keyword 'INTORG' or 'INTEND' */
+         read_field(csa), patch_name(csa, csa->field);
+         if (strcmp(csa->field, "'INTORG'") == 0)
+            kind = GLP_IV;
+         else if (strcmp(csa->field, "'INTEND'") == 0)
+            kind = GLP_CV;
+         else if (csa->field[0] == '\0')
+            error(csa, "missing keyword in field 5\n");
+         else
+            error(csa, "invalid keyword in field 5\n");
+         /* field 6 must be blank */
+         skip_field(csa);
+         goto loop;
+      }
+      /* process column name specified in field 2 */
+      if (name[0] == '\0')
+      {  /* the same column as in previous data record */
+         if (j == 0)
+            error(csa, "missing column name in field 2\n");
+      }
+      else if (j != 0 && strcmp(name, csa->P->col[j]->name) == 0)
+      {  /* the same column as in previous data record */
+         xassert(j != 0);
+      }
+      else
+      {  /* store the current column */
+         if (j != 0)
+         {  glp_set_mat_col(csa->P, j, len, ind, val);
+            while (len > 0) flag[ind[len--]] = 0;
+         }
+         /* create new column */
+         if (glp_find_col(csa->P, name) != 0)
+            error(csa, "column '%s' multiply specified\n", name);
+         j = glp_add_cols(csa->P, 1);
+         glp_set_col_name(csa->P, j, name);
+         glp_set_col_kind(csa->P, j, kind);
+         if (kind == GLP_CV)
+            glp_set_col_bnds(csa->P, j, GLP_LO, 0.0, 0.0);
+         else if (kind == GLP_IV)
+            glp_set_col_bnds(csa->P, j, GLP_DB, 0.0, 1.0);
+         else
+            xassert(kind != kind);
       }
-      else if (csa->token == T_NUMBER)
-      {  /* parse unsigned lower bound */
-         lb_flag = 1;
-         lb = csa->value, scan_token(csa);
-      }
-      else
-      {  /* lower bound is not specified */
-         lb_flag = 0;
-      }
-      /* parse the token that should follow the lower bound */
-      if (lb_flag)
-      {  if (csa->token != T_LE)
-            error(csa, "missing `<', `<=', or `=<' after lower bound\n")
-               ;
-         scan_token(csa);
-      }
-      /* parse variable name */
-      if (csa->token != T_NAME)
-         error(csa, "missing variable name\n");
-      j = find_col(csa, csa->image);
-      /* set lower bound */
-      if (lb_flag) set_lower_bound(csa, j, lb);
-      scan_token(csa);
-      /* parse the context that follows the variable name */
-      if (csa->token == T_LE)
-      {  /* parse upper bound */
-         scan_token(csa);
-         if (csa->token == T_PLUS || csa->token == T_MINUS)
-         {  /* parse signed upper bound */
-            s = (csa->token == T_PLUS ? +1.0 : -1.0);
-            scan_token(csa);
-            if (csa->token == T_NUMBER)
-            {  set_upper_bound(csa, j, s * csa->value);
-               scan_token(csa);
-            }
-            else if (the_same(csa->image, "infinity") ||
-                     the_same(csa->image, "inf"))
-            {  if (s < 0.0)
-                  error(csa, "invalid use of `-inf' as upper bound\n");
-               set_upper_bound(csa, j, +DBL_MAX);
-               scan_token(csa);
+      /* process fields 3-4 and 5-6 */
+      for (f = 3; f <= 5; f += 2)
+      {  /* field 3 or 5: row name */
+         if (f == 3)
+         {  if (csa->field[0] == '\0')
+               error(csa, "missing row name in field 3\n");
+         }
+         else
+         {  read_field(csa), patch_name(csa, csa->field);
+            if (csa->field[0] == '\0')
+            {  /* if field 5 is blank, field 6 also must be blank */
+               skip_field(csa);
+               continue;
             }
-            else
-               error(csa, "missing upper bound\n");
          }
-         else if (csa->token == T_NUMBER)
-         {  /* parse unsigned upper bound */
-            set_upper_bound(csa, j, csa->value);
-            scan_token(csa);
+         i = glp_find_row(csa->P, csa->field);
+         if (i == 0)
+            error(csa, "row '%s' not found\n", csa->field);
+         if (flag[i])
+            error(csa, "duplicate coefficient in row '%s'\n",
+               csa->field);
+         /* field 4 or 6: coefficient value */
+         aij = read_number(csa);
+         if (fabs(aij) < csa->parm->tol_mps) aij = 0.0;
+         len++, ind[len] = i, val[len] = aij, flag[i] = 1;
+      }
+      goto loop;
+done: /* store the last column */
+      if (j != 0)
+         glp_set_mat_col(csa->P, j, len, ind, val);
+      /* free working arrays */
+      xfree(ind);
+      xfree(val);
+      xfree(flag);
+      csa->work1 = csa->work2 = csa->work3 = NULL;
+      return;
+}
+
+static void read_rhs(struct csa *csa)
+{     /* read RHS section */
+      int i, f, v, type;
+      double rhs;
+      char name[255+1], *flag;
+      /* allocate working array */
+      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));
+      memset(&flag[1], 0, csa->P->m);
+      /* no current RHS vector exists */
+      v = 0;
+loop: if (indicator(csa, 0)) goto done;
+      /* field 1 must be blank */
+      if (csa->deck)
+      {  read_field(csa);
+         if (csa->field[0] != '\0')
+            error(csa, "field 1 must be blank\n");
+      }
+      else
+         csa->fldno++;
+      /* field 2: RHS vector name */
+      read_field(csa), patch_name(csa, csa->field);
+      if (csa->field[0] == '\0')
+      {  /* the same RHS vector as in previous data record */
+         if (v == 0)
+         {  warning(csa, "missing RHS vector name in field 2\n");
+            goto blnk;
          }
-         else
-            error(csa, "missing upper bound\n");
       }
-      else if (csa->token == T_GE)
-      {  /* parse lower bound */
-         if (lb_flag)
-         {  /* the context '... <= x >= ...' is invalid */
-            error(csa, "invalid bound definition\n");
-         }
-         scan_token(csa);
-         if (csa->token == T_PLUS || csa->token == T_MINUS)
-         {  /* parse signed lower bound */
-            s = (csa->token == T_PLUS ? +1.0 : -1.0);
-            scan_token(csa);
-            if (csa->token == T_NUMBER)
-            {  set_lower_bound(csa, j, s * csa->value);
-               scan_token(csa);
-            }
-            else if (the_same(csa->image, "infinity") ||
-                     the_same(csa->image, "inf") == 0)
-            {  if (s > 0.0)
-                  error(csa, "invalid use of `+inf' as lower bound\n");
-               set_lower_bound(csa, j, -DBL_MAX);
-               scan_token(csa);
-            }
+      else if (v != 0 && strcmp(csa->field, name) == 0)
+      {  /* the same RHS vector as in previous data record */
+         xassert(v != 0);
+      }
+      else
+blnk: {  /* new RHS vector */
+         if (v != 0)
+            error(csa, "multiple RHS vectors not supported\n");
+         v++;
+         strcpy(name, csa->field);
+      }
+      /* process fields 3-4 and 5-6 */
+      for (f = 3; f <= 5; f += 2)
+      {  /* field 3 or 5: row name */
+         read_field(csa), patch_name(csa, csa->field);
+         if (csa->field[0] == '\0')
+         {  if (f == 3)
+               error(csa, "missing row name in field 3\n");
             else
-               error(csa, "missing lower bound\n");
+            {  /* if field 5 is blank, field 6 also must be blank */
+               skip_field(csa);
+               continue;
+            }
          }
-         else if (csa->token == T_NUMBER)
-         {  /* parse unsigned lower bound */
-            set_lower_bound(csa, j, csa->value);
-            scan_token(csa);
+         i = glp_find_row(csa->P, csa->field);
+         if (i == 0)
+            error(csa, "row '%s' not found\n", csa->field);
+         if (flag[i])
+            error(csa, "duplicate right-hand side for row '%s'\n",
+               csa->field);
+         /* field 4 or 6: right-hand side value */
+         rhs = read_number(csa);
+         if (fabs(rhs) < csa->parm->tol_mps) rhs = 0.0;
+         type = csa->P->row[i]->type;
+         if (type == GLP_FR)
+         {  if (i == csa->obj_row)
+               glp_set_obj_coef(csa->P, 0, rhs);
+            else if (rhs != 0.0)
+               warning(csa, "non-zero right-hand side for free row '%s'"
+                  " ignored\n", csa->P->row[i]->name);
          }
          else
-            error(csa, "missing lower bound\n");
+            glp_set_row_bnds(csa->P, i, type, rhs, rhs);
+         flag[i] = 1;
       }
-      else if (csa->token == T_EQ)
-      {  /* parse fixed value */
-         if (lb_flag)
-         {  /* the context '... <= x = ...' is invalid */
-            error(csa, "invalid bound definition\n");
-         }
-         scan_token(csa);
-         if (csa->token == T_PLUS || csa->token == T_MINUS)
-         {  /* parse signed fixed value */
-            s = (csa->token == T_PLUS ? +1.0 : -1.0);
-            scan_token(csa);
-            if (csa->token == T_NUMBER)
-            {  set_lower_bound(csa, j, s * csa->value);
-               set_upper_bound(csa, j, s * csa->value);
-               scan_token(csa);
-            }
+      goto loop;
+done: /* free working array */
+      xfree(flag);
+      csa->work3 = NULL;
+      return;
+}
+
+static void read_ranges(struct csa *csa)
+{     /* read RANGES section */
+      int i, f, v, type;
+      double rhs, rng;
+      char name[255+1], *flag;
+      /* allocate working array */
+      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));
+      memset(&flag[1], 0, csa->P->m);
+      /* no current RANGES vector exists */
+      v = 0;
+loop: if (indicator(csa, 0)) goto done;
+      /* field 1 must be blank */
+      if (csa->deck)
+      {  read_field(csa);
+         if (csa->field[0] != '\0')
+            error(csa, "field 1 must be blank\n");
+      }
+      else
+         csa->fldno++;
+      /* field 2: RANGES vector name */
+      read_field(csa), patch_name(csa, csa->field);
+      if (csa->field[0] == '\0')
+      {  /* the same RANGES vector as in previous data record */
+         if (v == 0)
+         {  warning(csa, "missing RANGES vector name in field 2\n");
+            goto blnk;
+         }
+      }
+      else if (v != 0 && strcmp(csa->field, name) == 0)
+      {  /* the same RANGES vector as in previous data record */
+         xassert(v != 0);
+      }
+      else
+blnk: {  /* new RANGES vector */
+         if (v != 0)
+            error(csa, "multiple RANGES vectors not supported\n");
+         v++;
+         strcpy(name, csa->field);
+      }
+      /* process fields 3-4 and 5-6 */
+      for (f = 3; f <= 5; f += 2)
+      {  /* field 3 or 5: row name */
+         read_field(csa), patch_name(csa, csa->field);
+         if (csa->field[0] == '\0')
+         {  if (f == 3)
+               error(csa, "missing row name in field 3\n");
             else
-               error(csa, "missing fixed value\n");
+            {  /* if field 5 is blank, field 6 also must be blank */
+               skip_field(csa);
+               continue;
+            }
+         }
+         i = glp_find_row(csa->P, csa->field);
+         if (i == 0)
+            error(csa, "row '%s' not found\n", csa->field);
+         if (flag[i])
+            error(csa, "duplicate range for row '%s'\n", csa->field);
+         /* field 4 or 6: range value */
+         rng = read_number(csa);
+         if (fabs(rng) < csa->parm->tol_mps) rng = 0.0;
+         type = csa->P->row[i]->type;
+         if (type == GLP_FR)
+            warning(csa, "range for free row '%s' ignored\n",
+               csa->P->row[i]->name);
+         else if (type == GLP_LO)
+         {  rhs = csa->P->row[i]->lb;
+#if 0 /* 26/V-2017 by cmatraki */
+            glp_set_row_bnds(csa->P, i, rhs == 0.0 ? GLP_FX : GLP_DB,
+#else
+            glp_set_row_bnds(csa->P, i, rng == 0.0 ? GLP_FX : GLP_DB,
+#endif
+               rhs, rhs + fabs(rng));
+         }
+         else if (type == GLP_UP)
+         {  rhs = csa->P->row[i]->ub;
+#if 0 /* 26/V-2017 by cmatraki */
+            glp_set_row_bnds(csa->P, i, rhs == 0.0 ? GLP_FX : GLP_DB,
+#else
+            glp_set_row_bnds(csa->P, i, rng == 0.0 ? GLP_FX : GLP_DB,
+#endif
+               rhs - fabs(rng), rhs);
          }
-         else if (csa->token == T_NUMBER)
-         {  /* parse unsigned fixed value */
-            set_lower_bound(csa, j, csa->value);
-            set_upper_bound(csa, j, csa->value);
-            scan_token(csa);
+         else if (type == GLP_FX)
+         {  rhs = csa->P->row[i]->lb;
+            if (rng > 0.0)
+               glp_set_row_bnds(csa->P, i, GLP_DB, rhs, rhs + rng);
+            else if (rng < 0.0)
+               glp_set_row_bnds(csa->P, i, GLP_DB, rhs + rng, rhs);
          }
          else
-            error(csa, "missing fixed value\n");
-      }
-      else if (the_same(csa->image, "free"))
-      {  /* parse the keyword 'free' */
-         if (lb_flag)
-         {  /* the context '... <= x free ...' is invalid */
-            error(csa, "invalid bound definition\n");
-         }
-         set_lower_bound(csa, j, -DBL_MAX);
-         set_upper_bound(csa, j, +DBL_MAX);
-         scan_token(csa);
-      }
-      else if (!lb_flag)
-      {  /* neither lower nor upper bounds are specified */
-         error(csa, "invalid bound definition\n");
+            xassert(type != type);
+         flag[i] = 1;
       }
       goto loop;
-done: return;
+done: /* free working array */
+      xfree(flag);
+      csa->work3 = NULL;
+      return;
 }
 
-/***********************************************************************
-*  parse_integer - parse general, integer, or binary section
-*
-*  <variable> ::= <symbolic name>
-*  <general> ::= general | generals | gen
-*  <integer> ::= integer | integers | int
-*  <binary> ::= binary | binaries | bin
-*  <section head> ::= <general> <integer> <binary>
-*  <additional section> ::= <section head> |
-*     <additional section> <variable> */
-
-static void parse_integer(struct csa *csa)
-{     int j, binary;
-      /* parse the keyword 'general', 'integer', or 'binary' */
-      if (csa->token == T_GENERAL)
-         binary = 0, scan_token(csa);
-      else if (csa->token == T_INTEGER)
-         binary = 0, scan_token(csa);
-      else if (csa->token == T_BINARY)
-         binary = 1, scan_token(csa);
-      else
-         xassert(csa != csa);
-      /* parse list of variables (may be empty) */
-      while (csa->token == T_NAME)
-      {  /* find the corresponding column */
-         j = find_col(csa, csa->image);
-         /* change kind of the variable */
-         glp_set_col_kind(csa->P, j, GLP_IV);
-         /* set 0-1 bounds for the binary variable */
-         if (binary)
-         {  set_lower_bound(csa, j, 0.0);
-            set_upper_bound(csa, j, 1.0);
+static void read_bounds(struct csa *csa)
+{     /* read BOUNDS section */
+      GLPCOL *col;
+      int j, v, mask, data;
+      double bnd, lb, ub;
+      char type[2+1], name[255+1], *flag;
+      /* allocate working array */
+      csa->work3 = flag = xcalloc(1+csa->P->n, sizeof(char));
+      memset(&flag[1], 0, csa->P->n);
+      /* no current BOUNDS vector exists */
+      v = 0;
+loop: if (indicator(csa, 0)) goto done;
+      /* field 1: bound type */
+      read_field(csa);
+      if (strcmp(csa->field, "LO") == 0)
+         mask = 0x01, data = 1;
+      else if (strcmp(csa->field, "UP") == 0)
+         mask = 0x10, data = 1;
+      else if (strcmp(csa->field, "FX") == 0)
+         mask = 0x11, data = 1;
+      else if (strcmp(csa->field, "FR") == 0)
+         mask = 0x11, data = 0;
+      else if (strcmp(csa->field, "MI") == 0)
+         mask = 0x01, data = 0;
+      else if (strcmp(csa->field, "PL") == 0)
+         mask = 0x10, data = 0;
+      else if (strcmp(csa->field, "LI") == 0)
+         mask = 0x01, data = 1;
+      else if (strcmp(csa->field, "UI") == 0)
+         mask = 0x10, data = 1;
+      else if (strcmp(csa->field, "BV") == 0)
+         mask = 0x11, data = 0;
+      else if (csa->field[0] == '\0')
+         error(csa, "missing bound type in field 1\n");
+      else
+         error(csa, "invalid bound type in field 1\n");
+      strcpy(type, csa->field);
+      /* field 2: BOUNDS vector name */
+      read_field(csa), patch_name(csa, csa->field);
+      if (csa->field[0] == '\0')
+      {  /* the same BOUNDS vector as in previous data record */
+         if (v == 0)
+         {  warning(csa, "missing BOUNDS vector name in field 2\n");
+            goto blnk;
          }
-         scan_token(csa);
       }
+      else if (v != 0 && strcmp(csa->field, name) == 0)
+      {  /* the same BOUNDS vector as in previous data record */
+         xassert(v != 0);
+      }
+      else
+blnk: {  /* new BOUNDS vector */
+         if (v != 0)
+            error(csa, "multiple BOUNDS vectors not supported\n");
+         v++;
+         strcpy(name, csa->field);
+      }
+      /* field 3: column name */
+      read_field(csa), patch_name(csa, csa->field);
+      if (csa->field[0] == '\0')
+         error(csa, "missing column name in field 3\n");
+      j = glp_find_col(csa->P, csa->field);
+      if (j == 0)
+         error(csa, "column '%s' not found\n", csa->field);
+      if ((flag[j] & mask) == 0x01)
+         error(csa, "duplicate lower bound for column '%s'\n",
+            csa->field);
+      if ((flag[j] & mask) == 0x10)
+         error(csa, "duplicate upper bound for column '%s'\n",
+            csa->field);
+      xassert((flag[j] & mask) == 0x00);
+      /* field 4: bound value */
+      if (data)
+      {  bnd = read_number(csa);
+         if (fabs(bnd) < csa->parm->tol_mps) bnd = 0.0;
+      }
+      else
+         read_field(csa), bnd = 0.0;
+      /* get current column bounds */
+      col = csa->P->col[j];
+      if (col->type == GLP_FR)
+         lb = -DBL_MAX, ub = +DBL_MAX;
+      else if (col->type == GLP_LO)
+         lb = col->lb, ub = +DBL_MAX;
+      else if (col->type == GLP_UP)
+         lb = -DBL_MAX, ub = col->ub;
+      else if (col->type == GLP_DB)
+         lb = col->lb, ub = col->ub;
+      else if (col->type == GLP_FX)
+         lb = ub = col->lb;
+      else
+         xassert(col != col);
+      /* change column bounds */
+      if (strcmp(type, "LO") == 0)
+         lb = bnd;
+      else if (strcmp(type, "UP") == 0)
+         ub = bnd;
+      else if (strcmp(type, "FX") == 0)
+         lb = ub = bnd;
+      else if (strcmp(type, "FR") == 0)
+         lb = -DBL_MAX, ub = +DBL_MAX;
+      else if (strcmp(type, "MI") == 0)
+         lb = -DBL_MAX;
+      else if (strcmp(type, "PL") == 0)
+         ub = +DBL_MAX;
+      else if (strcmp(type, "LI") == 0)
+      {  glp_set_col_kind(csa->P, j, GLP_IV);
+         lb = ceil(bnd);
+#if 1 /* 16/VII-2013 */
+         /* if column upper bound has not been explicitly specified,
+            take it as +inf */
+         if (!(flag[j] & 0x10))
+            ub = +DBL_MAX;
+#endif
+      }
+      else if (strcmp(type, "UI") == 0)
+      {  glp_set_col_kind(csa->P, j, GLP_IV);
+         ub = floor(bnd);
+      }
+      else if (strcmp(type, "BV") == 0)
+      {  glp_set_col_kind(csa->P, j, GLP_IV);
+         lb = 0.0, ub = 1.0;
+      }
+      else
+         xassert(type != type);
+      /* set new column bounds */
+      if (lb == -DBL_MAX && ub == +DBL_MAX)
+         glp_set_col_bnds(csa->P, j, GLP_FR, lb, ub);
+      else if (ub == +DBL_MAX)
+         glp_set_col_bnds(csa->P, j, GLP_LO, lb, ub);
+      else if (lb == -DBL_MAX)
+         glp_set_col_bnds(csa->P, j, GLP_UP, lb, ub);
+      else if (lb != ub)
+         glp_set_col_bnds(csa->P, j, GLP_DB, lb, ub);
+      else
+         glp_set_col_bnds(csa->P, j, GLP_FX, lb, ub);
+      flag[j] |= (char)mask;
+      /* fields 5 and 6 must be blank */
+      skip_field(csa);
+      skip_field(csa);
+      goto loop;
+done: /* free working array */
+      xfree(flag);
+      csa->work3 = NULL;
       return;
 }
 
-int glp_read_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname)
-{     /* read problem data in CPLEX LP format */
-      glp_cpxcp _parm;
+int glp_read_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
+      const char *fname)
+{     /* read problem data in MPS format */
+      glp_mpscp _parm;
       struct csa _csa, *csa = &_csa;
       int ret;
-      xprintf("Reading problem data from `%s'...\n", fname);
+      xprintf("Reading problem data from '%s'...\n", fname);
+      if (!(fmt == GLP_MPS_DECK || fmt == GLP_MPS_FILE))
+         xerror("glp_read_mps: fmt = %d; invalid parameter\n", fmt);
       if (parm == NULL)
-         glp_init_cpxcp(&_parm), parm = &_parm;
+         glp_init_mpscp(&_parm), parm = &_parm;
       /* check control parameters */
-      check_parm("glp_read_lp", parm);
+      check_parm("glp_read_mps", parm);
       /* initialize common storage area */
       csa->P = P;
+      csa->deck = (fmt == GLP_MPS_DECK);
       csa->parm = parm;
       csa->fname = fname;
       csa->fp = NULL;
       if (setjmp(csa->jump))
       {  ret = 1;
          goto done;
       }
-      csa->count = 0;
+      csa->recno = csa->recpos = 0;
       csa->c = '\n';
-      csa->token = T_EOF;
-      csa->image[0] = '\0';
-      csa->imlen = 0;
-      csa->value = 0.0;
-      csa->n_max = 100;
-      csa->ind = xcalloc(1+csa->n_max, sizeof(int));
-      csa->val = xcalloc(1+csa->n_max, sizeof(double));
-      csa->flag = xcalloc(1+csa->n_max, sizeof(char));
-      memset(&csa->flag[1], 0, csa->n_max * sizeof(char));
-      csa->lb = xcalloc(1+csa->n_max, sizeof(double));
-      csa->ub = xcalloc(1+csa->n_max, sizeof(double));
+      csa->fldno = 0;
+      csa->field[0] = '\0';
+      csa->w80 = csa->wef = 0;
+      csa->obj_row = 0;
+      csa->work1 = csa->work2 = csa->work3 = NULL;
       /* erase problem object */
       glp_erase_prob(P);
       glp_create_index(P);
-      /* open input CPLEX LP file */
-      csa->fp = xfopen(fname, "r");
+      /* open input MPS file */
+      csa->fp = glp_open(fname, "r");
       if (csa->fp == NULL)
-      {  xprintf("Unable to open `%s' - %s\n", fname, xerrmsg());
+      {  xprintf("Unable to open '%s' - %s\n", fname, get_err_msg());
          ret = 1;
          goto done;
       }
-      /* scan very first token */
-      scan_token(csa);
-      /* parse definition of the objective function */
-      if (!(csa->token == T_MINIMIZE || csa->token == T_MAXIMIZE))
-         error(csa, "`minimize' or `maximize' keyword missing\n");
-      parse_objective(csa);
-      /* parse constraints section */
-      if (csa->token != T_SUBJECT_TO)
-         error(csa, "constraints section missing\n");
-      parse_constraints(csa);
-      /* parse optional bounds section */
-      if (csa->token == T_BOUNDS) parse_bounds(csa);
-      /* parse optional general, integer, and binary sections */
-      while (csa->token == T_GENERAL ||
-             csa->token == T_INTEGER ||
-             csa->token == T_BINARY) parse_integer(csa);
-      /* check for the keyword 'end' */
-      if (csa->token == T_END)
-         scan_token(csa);
-      else if (csa->token == T_EOF)
-         warning(csa, "keyword `end' missing\n");
-      else
-         error(csa, "symbol `%s' in wrong position\n", csa->image);
-      /* nothing must follow the keyword 'end' (except comments) */
-      if (csa->token != T_EOF)
-         error(csa, "extra symbol(s) detected beyond `end'\n");
-      /* set bounds of variables */
-      {  int j, type;
-         double lb, ub;
-         for (j = 1; j <= P->n; j++)
-         {  lb = csa->lb[j];
-            ub = csa->ub[j];
-            if (lb == +DBL_MAX) lb = 0.0;      /* default lb */
-            if (ub == -DBL_MAX) ub = +DBL_MAX; /* default ub */
-            if (lb == -DBL_MAX && ub == +DBL_MAX)
-               type = GLP_FR;
-            else if (ub == +DBL_MAX)
-               type = GLP_LO;
-            else if (lb == -DBL_MAX)
-               type = GLP_UP;
-            else if (lb != ub)
-               type = GLP_DB;
-            else
-               type = GLP_FX;
-            glp_set_col_bnds(csa->P, j, type, lb, ub);
+      /* read NAME indicator record */
+      read_name(csa);
+      if (P->name != NULL)
+         xprintf("Problem: %s\n", P->name);
+      /* read ROWS section */
+      if (!(indicator(csa, 0) && strcmp(csa->field, "ROWS") == 0))
+         error(csa, "missing ROWS indicator record\n");
+      read_rows(csa);
+      /* determine objective row */
+      if (parm->obj_name == NULL || parm->obj_name[0] == '\0')
+      {  /* use the first row of N type */
+         int i;
+         for (i = 1; i <= P->m; i++)
+         {  if (P->row[i]->type == GLP_FR)
+            {  csa->obj_row = i;
+               break;
+            }
          }
+         if (csa->obj_row == 0)
+            warning(csa, "unable to determine objective row\n");
       }
+      else
+      {  /* use a row with specified name */
+         int i;
+         for (i = 1; i <= P->m; i++)
+         {  xassert(P->row[i]->name != NULL);
+            if (strcmp(parm->obj_name, P->row[i]->name) == 0)
+            {  csa->obj_row = i;
+               break;
+            }
+         }
+         if (csa->obj_row == 0)
+            error(csa, "objective row '%s' not found\n",
+               parm->obj_name);
+      }
+      if (csa->obj_row != 0)
+      {  glp_set_obj_name(P, P->row[csa->obj_row]->name);
+         xprintf("Objective: %s\n", P->obj);
+      }
+      /* read COLUMNS section */
+      if (strcmp(csa->field, "COLUMNS") != 0)
+         error(csa, "missing COLUMNS indicator record\n");
+      read_columns(csa);
+      /* set objective coefficients */
+      if (csa->obj_row != 0)
+      {  GLPAIJ *aij;
+         for (aij = P->row[csa->obj_row]->ptr; aij != NULL; aij =
+            aij->r_next) glp_set_obj_coef(P, aij->col->j, aij->val);
+      }
+      /* read optional RHS section */
+      if (strcmp(csa->field, "RHS") == 0)
+         read_rhs(csa);
+      /* read optional RANGES section */
+      if (strcmp(csa->field, "RANGES") == 0)
+         read_ranges(csa);
+      /* read optional BOUNDS section */
+      if (strcmp(csa->field, "BOUNDS") == 0)
+         read_bounds(csa);
+      /* read ENDATA indicator record */
+      if (strcmp(csa->field, "ENDATA") != 0)
+         error(csa, "invalid use of %s indicator record\n",
+            csa->field);
       /* print some statistics */
       xprintf("%d row%s, %d column%s, %d non-zero%s\n",
          P->m, P->m == 1 ? "" : "s", P->n, P->n == 1 ? "" : "s",
          P->nnz, P->nnz == 1 ? "" : "s");
       if (glp_get_num_int(P) > 0)
       {  int ni = glp_get_num_int(P);
          int nb = glp_get_num_bin(P);
@@ -940,305 +1010,441 @@
             else if (nb == ni)
                xprintf("all");
             else
                xprintf("%d", nb);
             xprintf(" of which %s binary\n", nb == 1 ? "is" : "are");
          }
       }
-      xprintf("%d lines were read\n", csa->count);
+      xprintf("%d records were read\n", csa->recno);
+#if 1 /* 31/III-2016 */
+      /* free (unbounded) row(s) in MPS file are intended to specify
+       * objective function(s), so all such rows can be removed */
+#if 1 /* 08/VIII-2013 */
+      /* remove free rows */
+      {  int i, nrs, *num;
+         num = talloc(1+P->m, int);
+         nrs = 0;
+         for (i = 1; i <= P->m; i++)
+         {  if (P->row[i]->type == GLP_FR)
+               num[++nrs] = i;
+         }
+         if (nrs > 0)
+         {  glp_del_rows(P, nrs, num);
+            if (nrs == 1)
+               xprintf("One free row was removed\n");
+            else
+               xprintf("%d free rows were removed\n", nrs);
+         }
+         tfree(num);
+      }
+#endif
+#else
+      /* if objective function row is free, remove it */
+      if (csa->obj_row != 0 && P->row[csa->obj_row]->type == GLP_FR)
+      {  int num[1+1];
+         num[1] = csa->obj_row;
+         glp_del_rows(P, 1, num);
+         xprintf("Free objective row was removed\n");
+      }
+#endif
       /* problem data has been successfully read */
       glp_delete_index(P);
       glp_sort_matrix(P);
       ret = 0;
-done: if (csa->fp != NULL) xfclose(csa->fp);
-      xfree(csa->ind);
-      xfree(csa->val);
-      xfree(csa->flag);
-      xfree(csa->lb);
-      xfree(csa->ub);
+done: if (csa->fp != NULL) glp_close(csa->fp);
+      if (csa->work1 != NULL) xfree(csa->work1);
+      if (csa->work2 != NULL) xfree(csa->work2);
+      if (csa->work3 != NULL) xfree(csa->work3);
       if (ret != 0) glp_erase_prob(P);
       return ret;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  glp_write_lp - write problem data in CPLEX LP format
+*  glp_write_mps - write problem data in MPS format
 *
 *  SYNOPSIS
 *
-*  int glp_write_lp(glp_prob *P, const glp_cpxcp *parm, const char
-*     *fname);
+*  int glp_write_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
+*     const char *fname);
 *
 *  DESCRIPTION
 *
-*  The routine glp_write_lp writes problem data in CPLEX LP format to
-*  a text file.
+*  The routine glp_write_mps writes problem data in MPS format to a
+*  text file.
 *
-*  The parameter parm is a pointer to the structure glp_cpxcp, which
+*  The parameter fmt specifies the version of MPS format:
+*
+*  GLP_MPS_DECK - fixed (ancient) MPS format;
+*  GLP_MPS_FILE - free (modern) MPS format.
+*
+*  The parameter parm is a pointer to the structure glp_mpscp, which
 *  specifies control parameters used by the routine. If parm is NULL,
 *  the routine uses default settings.
 *
 *  The character string fname specifies a name of the text file to be
 *  written.
 *
 *  RETURNS
 *
-*  If the operation was successful, the routine glp_write_lp returns
+*  If the operation was successful, the routine glp_read_mps returns
 *  zero. Otherwise, it prints an error message and returns non-zero. */
 
 #define csa csa1
 
 struct csa
 {     /* common storage area */
       glp_prob *P;
       /* pointer to problem object */
-      const glp_cpxcp *parm;
+      int deck;
+      /* MPS format (0 - free, 1 - fixed) */
+      const glp_mpscp *parm;
       /* pointer to control parameters */
+      char field[255+1];
+      /* field buffer */
 };
 
-static int check_name(char *name)
-{     /* check if specified name is valid for CPLEX LP format */
-      if (*name == '.') return 1;
-      if (isdigit((unsigned char)*name)) return 1;
-      for (; *name; name++)
-      {  if (!isalnum((unsigned char)*name) &&
-             strchr(CHAR_SET, (unsigned char)*name) == NULL) return 1;
-      }
-      return 0; /* name is ok */
-}
-
-static void adjust_name(char *name)
-{     /* attempt to adjust specified name to make it valid for CPLEX LP
-         format */
-      for (; *name; name++)
-      {  if (*name == ' ')
-            *name = '_';
-         else if (*name == '-')
-            *name = '~';
-         else if (*name == '[')
-            *name = '(';
-         else if (*name == ']')
-            *name = ')';
+static char *mps_name(struct csa *csa)
+{     /* make problem name */
+      char *f;
+      if (csa->P->name == NULL)
+         csa->field[0] = '\0';
+      else if (csa->deck)
+      {  strncpy(csa->field, csa->P->name, 8);
+         csa->field[8] = '\0';
       }
-      return;
+      else
+         strcpy(csa->field, csa->P->name);
+      for (f = csa->field; *f != '\0'; f++)
+         if (*f == ' ') *f = '_';
+      return csa->field;
+}
+
+static char *row_name(struct csa *csa, int i)
+{     /* make i-th row name */
+      char *f;
+      xassert(0 <= i && i <= csa->P->m);
+      if (i == 0 || csa->P->row[i]->name == NULL ||
+          csa->deck && strlen(csa->P->row[i]->name) > 8)
+         sprintf(csa->field, "R%07d", i);
+      else
+      {  strcpy(csa->field, csa->P->row[i]->name);
+         for (f = csa->field; *f != '\0'; f++)
+            if (*f == ' ') *f = '_';
+      }
+      return csa->field;
+}
+
+static char *col_name(struct csa *csa, int j)
+{     /* make j-th column name */
+      char *f;
+      xassert(1 <= j && j <= csa->P->n);
+      if (csa->P->col[j]->name == NULL ||
+          csa->deck && strlen(csa->P->col[j]->name) > 8)
+         sprintf(csa->field, "C%07d", j);
+      else
+      {  strcpy(csa->field, csa->P->col[j]->name);
+         for (f = csa->field; *f != '\0'; f++)
+            if (*f == ' ') *f = '_';
+      }
+      return csa->field;
+}
+
+static char *mps_numb(struct csa *csa, double val)
+{     /* format floating-point number */
+      int dig;
+      char *exp;
+      for (dig = 12; dig >= 6; dig--)
+      {  if (val != 0.0 && fabs(val) < 0.002)
+            sprintf(csa->field, "%.*E", dig-1, val);
+         else
+            sprintf(csa->field, "%.*G", dig, val);
+         exp = strchr(csa->field, 'E');
+         if (exp != NULL)
+            sprintf(exp+1, "%d", atoi(exp+1));
+         if (strlen(csa->field) <= 12) break;
+      }
+      xassert(strlen(csa->field) <= 12);
+      return csa->field;
 }
 
-static char *row_name(struct csa *csa, int i, char rname[255+1])
-{     /* construct symbolic name of i-th row (constraint) */
-      const char *name;
-      if (i == 0)
-         name = glp_get_obj_name(csa->P);
-      else
-         name = glp_get_row_name(csa->P, i);
-      if (name == NULL) goto fake;
-      strcpy(rname, name);
-      adjust_name(rname);
-      if (check_name(rname)) goto fake;
-      return rname;
-fake: if (i == 0)
-         strcpy(rname, "obj");
-      else
-         sprintf(rname, "r_%d", i);
-      return rname;
-}
-
-static char *col_name(struct csa *csa, int j, char cname[255+1])
-{     /* construct symbolic name of j-th column (variable) */
-      const char *name;
-      name = glp_get_col_name(csa->P, j);
-      if (name == NULL) goto fake;
-      strcpy(cname, name);
-      adjust_name(cname);
-      if (check_name(cname)) goto fake;
-      return cname;
-fake: sprintf(cname, "x_%d", j);
-      return cname;
-}
-
-int glp_write_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname)
-{     /* write problem data in CPLEX LP format */
-      glp_cpxcp _parm;
+int glp_write_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
+      const char *fname)
+{     /* write problem data in MPS format */
+      glp_mpscp _parm;
       struct csa _csa, *csa = &_csa;
-      XFILE *fp;
-      GLPROW *row;
-      GLPCOL *col;
-      GLPAIJ *aij;
-      int i, j, len, flag, count, ret;
-      char line[1000+1], term[500+1], name[255+1];
-      xprintf("Writing problem data to `%s'...\n", fname);
+      glp_file *fp;
+      int out_obj, one_col = 0, empty = 0;
+      int i, j, recno, marker, count, gap, ret;
+      xprintf("Writing problem data to '%s'...\n", fname);
+      if (!(fmt == GLP_MPS_DECK || fmt == GLP_MPS_FILE))
+         xerror("glp_write_mps: fmt = %d; invalid parameter\n", fmt);
       if (parm == NULL)
-         glp_init_cpxcp(&_parm), parm = &_parm;
+         glp_init_mpscp(&_parm), parm = &_parm;
       /* check control parameters */
-      check_parm("glp_write_lp", parm);
+      check_parm("glp_write_mps", parm);
       /* initialize common storage area */
       csa->P = P;
+      csa->deck = (fmt == GLP_MPS_DECK);
       csa->parm = parm;
-      /* create output CPLEX LP file */
-      fp = xfopen(fname, "w"), count = 0;
+      /* create output MPS file */
+      fp = glp_open(fname, "w"), recno = 0;
       if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
+      {  xprintf("Unable to create '%s' - %s\n", fname, get_err_msg());
          ret = 1;
          goto done;
       }
-      /* write problem name */
-      xfprintf(fp, "\\* Problem: %s *\\\n",
-         P->name == NULL ? "Unknown" : P->name), count++;
-      xfprintf(fp, "\n"), count++;
-      /* the problem should contain at least one row and one column */
-      if (!(P->m > 0 && P->n > 0))
-      {  xprintf("Warning: problem has no rows/columns\n");
-         xfprintf(fp, "\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\\n"),
-            count++;
-         xfprintf(fp, "\n"), count++;
-         goto skip;
-      }
-      /* write the objective function definition */
-      if (P->dir == GLP_MIN)
-         xfprintf(fp, "Minimize\n"), count++;
-      else if (P->dir == GLP_MAX)
-         xfprintf(fp, "Maximize\n"), count++;
-      else
-         xassert(P != P);
-      row_name(csa, 0, name);
-      sprintf(line, " %s:", name);
-      len = 0;
-      for (j = 1; j <= P->n; j++)
-      {  col = P->col[j];
-         if (col->coef != 0.0 || col->ptr == NULL)
-         {  len++;
-            col_name(csa, j, name);
-            if (col->coef == 0.0)
-               sprintf(term, " + 0 %s", name); /* empty column */
-            else if (col->coef == +1.0)
-               sprintf(term, " + %s", name);
-            else if (col->coef == -1.0)
-               sprintf(term, " - %s", name);
-            else if (col->coef > 0.0)
-               sprintf(term, " + %.*g %s", DBL_DIG, +col->coef, name);
-            else
-               sprintf(term, " - %.*g %s", DBL_DIG, -col->coef, name);
-            if (strlen(line) + strlen(term) > 72)
-               xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
-            strcat(line, term);
-         }
-      }
-      if (len == 0)
-      {  /* empty objective */
-         sprintf(term, " 0 %s", col_name(csa, 1, name));
-         strcat(line, term);
-      }
-      xfprintf(fp, "%s\n", line), count++;
-      if (P->c0 != 0.0)
-         xfprintf(fp, "\\* constant term = %.*g *\\\n", DBL_DIG, P->c0),
-            count++;
-      xfprintf(fp, "\n"), count++;
-      /* write the constraints section */
-      xfprintf(fp, "Subject To\n"), count++;
+      /* write comment records */
+      xfprintf(fp, "* %-*s%s\n", P->name == NULL ? 1 : 12, "Problem:",
+         P->name == NULL ? "" : P->name), recno++;
+      xfprintf(fp, "* %-12s%s\n", "Class:", glp_get_num_int(P) == 0 ?
+         "LP" : "MIP"), recno++;
+      xfprintf(fp, "* %-12s%d\n", "Rows:", P->m), recno++;
+      if (glp_get_num_int(P) == 0)
+         xfprintf(fp, "* %-12s%d\n", "Columns:", P->n), recno++;
+      else
+         xfprintf(fp, "* %-12s%d (%d integer, %d binary)\n",
+            "Columns:", P->n, glp_get_num_int(P), glp_get_num_bin(P)),
+            recno++;
+      xfprintf(fp, "* %-12s%d\n", "Non-zeros:", P->nnz), recno++;
+      xfprintf(fp, "* %-12s%s\n", "Format:", csa->deck ? "Fixed MPS" :
+         "Free MPS"), recno++;
+      xfprintf(fp, "*\n", recno++);
+      /* write NAME indicator record */
+      xfprintf(fp, "NAME%*s%s\n",
+         P->name == NULL ? 0 : csa->deck ? 10 : 1, "", mps_name(csa)),
+         recno++;
+#if 1
+      /* determine whether to write the objective row */
+      out_obj = 1;
       for (i = 1; i <= P->m; i++)
-      {  row = P->row[i];
-         if (row->type == GLP_FR) continue; /* skip free row */
-         row_name(csa, i, name);
-         sprintf(line, " %s:", name);
-         /* linear form */
-         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
-         {  col_name(csa, aij->col->j, name);
-            if (aij->val == +1.0)
-               sprintf(term, " + %s", name);
-            else if (aij->val == -1.0)
-               sprintf(term, " - %s", name);
-            else if (aij->val > 0.0)
-               sprintf(term, " + %.*g %s", DBL_DIG, +aij->val, name);
-            else
-               sprintf(term, " - %.*g %s", DBL_DIG, -aij->val, name);
-            if (strlen(line) + strlen(term) > 72)
-               xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
-            strcat(line, term);
-         }
-         if (row->type == GLP_DB)
-         {  /* double-bounded (ranged) constraint */
-            sprintf(term, " - ~r_%d", i);
-            if (strlen(line) + strlen(term) > 72)
-               xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
-            strcat(line, term);
-         }
-         else if (row->ptr == NULL)
-         {  /* empty constraint */
-            sprintf(term, " 0 %s", col_name(csa, 1, name));
-            strcat(line, term);
-         }
-         /* right hand-side */
-         if (row->type == GLP_LO)
-            sprintf(term, " >= %.*g", DBL_DIG, row->lb);
-         else if (row->type == GLP_UP)
-            sprintf(term, " <= %.*g", DBL_DIG, row->ub);
-         else if (row->type == GLP_DB || row->type == GLP_FX)
-            sprintf(term, " = %.*g", DBL_DIG, row->lb);
+      {  if (P->row[i]->type == GLP_FR)
+         {  out_obj = 0;
+            break;
+         }
+      }
+#endif
+      /* write ROWS section */
+      xfprintf(fp, "ROWS\n"), recno++;
+      for (i = (out_obj ? 0 : 1); i <= P->m; i++)
+      {  int type;
+         type = (i == 0 ? GLP_FR : P->row[i]->type);
+         if (type == GLP_FR)
+            type = 'N';
+         else if (type == GLP_LO)
+            type = 'G';
+         else if (type == GLP_UP)
+            type = 'L';
+         else if (type == GLP_DB || type == GLP_FX)
+            type = 'E';
+         else
+            xassert(type != type);
+         xfprintf(fp, " %c%*s%s\n", type, csa->deck ? 2 : 1, "",
+            row_name(csa, i)), recno++;
+      }
+      /* write COLUMNS section */
+      xfprintf(fp, "COLUMNS\n"), recno++;
+      marker = 0;
+      for (j = 1; j <= P->n; j++)
+      {  GLPAIJ cj, *aij;
+         int kind;
+         kind = P->col[j]->kind;
+         if (kind == GLP_CV)
+         {  if (marker % 2 == 1)
+            {  /* close current integer block */
+               marker++;
+               xfprintf(fp, "%*sM%07d%*s'MARKER'%*s'INTEND'\n",
+                  csa->deck ? 4 : 1, "", marker, csa->deck ? 2 : 1, "",
+                  csa->deck ? 17 : 1, ""), recno++;
+            }
+         }
+         else if (kind == GLP_IV)
+         {  if (marker % 2 == 0)
+            {  /* open new integer block */
+               marker++;
+               xfprintf(fp, "%*sM%07d%*s'MARKER'%*s'INTORG'\n",
+                  csa->deck ? 4 : 1, "", marker, csa->deck ? 2 : 1, "",
+                  csa->deck ? 17 : 1, ""), recno++;
+            }
+         }
+         else
+            xassert(kind != kind);
+         if (out_obj && P->col[j]->coef != 0.0)
+         {  /* make fake objective coefficient */
+            aij = &cj;
+            aij->row = NULL;
+            aij->val = P->col[j]->coef;
+            aij->c_next = P->col[j]->ptr;
+         }
+         else
+            aij = P->col[j]->ptr;
+#if 1 /* FIXME */
+         if (aij == NULL)
+         {  /* empty column */
+            empty++;
+            xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
+               csa->deck ? 8 : 1, col_name(csa, j));
+            /* we need a row */
+            xassert(P->m > 0);
+            xfprintf(fp, "%*s%-*s",
+               csa->deck ? 2 : 1, "", csa->deck ? 8 : 1,
+               row_name(csa, 1));
+            xfprintf(fp, "%*s0%*s$ empty column\n",
+               csa->deck ? 13 : 1, "", csa->deck ? 3 : 1, ""), recno++;
+         }
+#endif
+         count = 0;
+         for (aij = aij; aij != NULL; aij = aij->c_next)
+         {  if (one_col || count % 2 == 0)
+               xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
+                  csa->deck ? 8 : 1, col_name(csa, j));
+            gap = (one_col || count % 2 == 0 ? 2 : 3);
+            xfprintf(fp, "%*s%-*s",
+               csa->deck ? gap : 1, "", csa->deck ? 8 : 1,
+               row_name(csa, aij->row == NULL ? 0 : aij->row->i));
+            xfprintf(fp, "%*s%*s",
+               csa->deck ? 2 : 1, "", csa->deck ? 12 : 1,
+               mps_numb(csa, aij->val)), count++;
+            if (one_col || count % 2 == 0)
+               xfprintf(fp, "\n"), recno++;
+         }
+         if (!(one_col || count % 2 == 0))
+            xfprintf(fp, "\n"), recno++;
+      }
+      if (marker % 2 == 1)
+      {  /* close last integer block */
+         marker++;
+         xfprintf(fp, "%*sM%07d%*s'MARKER'%*s'INTEND'\n",
+            csa->deck ? 4 : 1, "", marker, csa->deck ? 2 : 1, "",
+            csa->deck ? 17 : 1, ""), recno++;
+      }
+#if 1
+      if (empty > 0)
+         xprintf("Warning: problem has %d empty column(s)\n", empty);
+#endif
+      /* write RHS section */
+      xfprintf(fp, "RHS\n"), recno++;
+      count = 0;
+      for (i = (out_obj ? 0 : 1); i <= P->m; i++)
+      {  int type;
+         double rhs;
+         if (i == 0)
+            rhs = P->c0;
          else
-            xassert(row != row);
-         if (strlen(line) + strlen(term) > 72)
-            xfprintf(fp, "%s\n", line), line[0] = '\0', count++;
-         strcat(line, term);
-         xfprintf(fp, "%s\n", line), count++;
-      }
-      xfprintf(fp, "\n"), count++;
-      /* write the bounds section */
-      flag = 0;
+         {  type = P->row[i]->type;
+            if (type == GLP_FR)
+               rhs = 0.0;
+            else if (type == GLP_LO)
+               rhs = P->row[i]->lb;
+            else if (type == GLP_UP)
+               rhs = P->row[i]->ub;
+            else if (type == GLP_DB || type == GLP_FX)
+               rhs = P->row[i]->lb;
+            else
+               xassert(type != type);
+         }
+         if (rhs != 0.0)
+         {  if (one_col || count % 2 == 0)
+               xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
+                  csa->deck ? 8 : 1, "RHS1");
+            gap = (one_col || count % 2 == 0 ? 2 : 3);
+            xfprintf(fp, "%*s%-*s",
+               csa->deck ? gap : 1, "", csa->deck ? 8 : 1,
+               row_name(csa, i));
+            xfprintf(fp, "%*s%*s",
+               csa->deck ? 2 : 1, "", csa->deck ? 12 : 1,
+               mps_numb(csa, rhs)), count++;
+            if (one_col || count % 2 == 0)
+               xfprintf(fp, "\n"), recno++;
+         }
+      }
+      if (!(one_col || count % 2 == 0))
+         xfprintf(fp, "\n"), recno++;
+      /* write RANGES section */
+      for (i = P->m; i >= 1; i--)
+         if (P->row[i]->type == GLP_DB) break;
+      if (i == 0) goto bnds;
+      xfprintf(fp, "RANGES\n"), recno++;
+      count = 0;
       for (i = 1; i <= P->m; i++)
-      {  row = P->row[i];
-         if (row->type != GLP_DB) continue;
-         if (!flag)
-            xfprintf(fp, "Bounds\n"), flag = 1, count++;
-         xfprintf(fp, " 0 <= ~r_%d <= %.*g\n",
-            i, DBL_DIG, row->ub - row->lb), count++;
-      }
+      {  if (P->row[i]->type == GLP_DB)
+         {  if (one_col || count % 2 == 0)
+               xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
+                  csa->deck ? 8 : 1, "RNG1");
+            gap = (one_col || count % 2 == 0 ? 2 : 3);
+            xfprintf(fp, "%*s%-*s",
+               csa->deck ? gap : 1, "", csa->deck ? 8 : 1,
+               row_name(csa, i));
+            xfprintf(fp, "%*s%*s",
+               csa->deck ? 2 : 1, "", csa->deck ? 12 : 1,
+               mps_numb(csa, P->row[i]->ub - P->row[i]->lb)), count++;
+            if (one_col || count % 2 == 0)
+               xfprintf(fp, "\n"), recno++;
+         }
+      }
+      if (!(one_col || count % 2 == 0))
+         xfprintf(fp, "\n"), recno++;
+bnds: /* write BOUNDS section */
+      for (j = P->n; j >= 1; j--)
+         if (!(P->col[j]->kind == GLP_CV &&
+               P->col[j]->type == GLP_LO && P->col[j]->lb == 0.0))
+            break;
+      if (j == 0) goto endt;
+      xfprintf(fp, "BOUNDS\n"), recno++;
       for (j = 1; j <= P->n; j++)
-      {  col = P->col[j];
-         if (col->type == GLP_LO && col->lb == 0.0) continue;
-         if (!flag)
-            xfprintf(fp, "Bounds\n"), flag = 1, count++;
-         col_name(csa, j, name);
-         if (col->type == GLP_FR)
-            xfprintf(fp, " %s free\n", name), count++;
-         else if (col->type == GLP_LO)
-            xfprintf(fp, " %s >= %.*g\n",
-               name, DBL_DIG, col->lb), count++;
-         else if (col->type == GLP_UP)
-            xfprintf(fp, " -Inf <= %s <= %.*g\n",
-               name, DBL_DIG, col->ub), count++;
-         else if (col->type == GLP_DB)
-            xfprintf(fp, " %.*g <= %s <= %.*g\n",
-               DBL_DIG, col->lb, name, DBL_DIG, col->ub), count++;
-         else if (col->type == GLP_FX)
-            xfprintf(fp, " %s = %.*g\n",
-               name, DBL_DIG, col->lb), count++;
+      {  int type, data[2];
+         double bnd[2];
+         char *spec[2];
+         spec[0] = spec[1] = NULL;
+         type = P->col[j]->type;
+         if (type == GLP_FR)
+            spec[0] = "FR", data[0] = 0;
+         else if (type == GLP_LO)
+         {  if (P->col[j]->lb != 0.0)
+               spec[0] = "LO", data[0] = 1, bnd[0] = P->col[j]->lb;
+            if (P->col[j]->kind == GLP_IV)
+               spec[1] = "PL", data[1] = 0;
+         }
+         else if (type == GLP_UP)
+         {  spec[0] = "MI", data[0] = 0;
+            spec[1] = "UP", data[1] = 1, bnd[1] = P->col[j]->ub;
+         }
+         else if (type == GLP_DB)
+         {  if (P->col[j]->lb != 0.0)
+               spec[0] = "LO", data[0] = 1, bnd[0] = P->col[j]->lb;
+            spec[1] = "UP", data[1] = 1, bnd[1] = P->col[j]->ub;
+         }
+         else if (type == GLP_FX)
+            spec[0] = "FX", data[0] = 1, bnd[0] = P->col[j]->lb;
          else
-            xassert(col != col);
+            xassert(type != type);
+         for (i = 0; i <= 1; i++)
+         {  if (spec[i] != NULL)
+            {  xfprintf(fp, " %s %-*s%*s%-*s", spec[i],
+                  csa->deck ? 8 : 1, "BND1", csa->deck ? 2 : 1, "",
+                  csa->deck ? 8 : 1, col_name(csa, j));
+               if (data[i])
+                  xfprintf(fp, "%*s%*s", csa->deck ? 2 : 1, "",
+                     csa->deck ? 12 : 1, mps_numb(csa, bnd[i]));
+               xfprintf(fp, "\n"), recno++;
+            }
+         }
       }
-      if (flag) xfprintf(fp, "\n"), count++;
-      /* write the integer section */
-      flag = 0;
-      for (j = 1; j <= P->n; j++)
-      {  col = P->col[j];
-         if (col->kind == GLP_CV) continue;
-         xassert(col->kind == GLP_IV);
-         if (!flag)
-            xfprintf(fp, "Generals\n"), flag = 1, count++;
-         xfprintf(fp, " %s\n", col_name(csa, j, name)), count++;
-      }
-      if (flag) xfprintf(fp, "\n"), count++;
-skip: /* write the end keyword */
-      xfprintf(fp, "End\n"), count++;
+endt: /* write ENDATA indicator record */
+      xfprintf(fp, "ENDATA\n"), recno++;
+#if 0 /* FIXME */
       xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
+#endif
+      if (glp_ioerr(fp))
+      {  xprintf("Write error on '%s' - %s\n", fname, get_err_msg());
          ret = 1;
          goto done;
       }
       /* problem data has been successfully written */
-      xprintf("%d lines were written\n", count);
+      xprintf("%d records were written\n", recno);
       ret = 0;
-done: if (fp != NULL) xfclose(fp);
+done: if (fp != NULL) glp_close(fp);
       return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpdmp.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/dmp.c`

 * *Files 27% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpdmp.c (dynamic memory pool) */
+/* dmp.c (dynamic memory pool) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,242 +15,227 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpdmp.h"
+#include "env.h"
+#include "dmp.h"
 
-#if 1 /* 29/VIII-2008 */
-/* some processors need data to be properly aligned; the macro
-   align_datasize enlarges the specified size of a data item to provide
-   a proper alignment of immediately following data */
-
-#define align_datasize(size) ((((size) + 7) / 8) * 8)
-/* 8 bytes is sufficient in both 32- and 64-bit environments */
-#endif
+struct DMP
+{     /* dynamic memory pool */
+      void *avail[32];
+      /* avail[k], 0 <= k <= 31, is a pointer to first available (free)
+       * atom of (k+1)*8 bytes long; at the beginning of each free atom
+       * there is a pointer to another free atom of the same size */
+      void *block;
+      /* pointer to most recently allocated memory block; at the
+       * beginning of each allocated memory block there is a pointer to
+       * previously allocated memory block */
+      int used;
+      /* number of bytes used in most recently allocated memory block */
+      size_t count;
+      /* number of atoms which are currently in use */
+};
 
-#ifdef GLP_DEBUG
-struct info
-{     DMP *pool;
+#define DMP_BLK_SIZE 8000
+/* size of memory blocks, in bytes, allocated for memory pools */
+
+struct prefix
+{     /* atom prefix (for debugging only) */
+      DMP *pool;
+      /* dynamic memory pool */
       int size;
+      /* original atom size, in bytes */
 };
-#endif
+
+#define prefix_size ((sizeof(struct prefix) + 7) & ~7)
+/* size of atom prefix rounded up to multiple of 8 bytes */
+
+int dmp_debug;
+/* debug mode flag */
 
 /***********************************************************************
 *  NAME
 *
 *  dmp_create_pool - create dynamic memory pool
 *
 *  SYNOPSIS
 *
-*  #include "glpdmp.h"
+*  #include "dmp.h"
 *  DMP *dmp_create_pool(void);
 *
 *  DESCRIPTION
 *
 *  The routine dmp_create_pool creates a dynamic memory pool.
 *
 *  RETURNS
 *
 *  The routine returns a pointer to the memory pool created. */
 
 DMP *dmp_create_pool(void)
 {     DMP *pool;
       int k;
-#ifdef GLP_DEBUG
-      xprintf("dmp_create_pool: warning: debug mode enabled\n");
-#endif
-      pool = xmalloc(sizeof(DMP));
-#if 0
-      pool->size = 0;
-#endif
-      for (k = 0; k <= 31; k++) pool->avail[k] = NULL;
+      xassert(sizeof(void *) <= 8);
+      if (dmp_debug)
+         xprintf("dmp_create_pool: warning: debug mode is on\n");
+      pool = talloc(1, DMP);
+      for (k = 0; k <= 31; k++)
+         pool->avail[k] = NULL;
       pool->block = NULL;
       pool->used = DMP_BLK_SIZE;
-      pool->count.lo = pool->count.hi = 0;
+      pool->count = 0;
       return pool;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  dmp_get_atom - get free atom from dynamic memory pool
 *
 *  SYNOPSIS
 *
-*  #include "glpdmp.h"
+*  #include "dmp.h"
 *  void *dmp_get_atom(DMP *pool, int size);
 *
 *  DESCRIPTION
 *
-*  The routine dmp_get_atom obtains a free atom (memory block) from the
+*  The routine dmp_get_atom obtains a free atom (memory space) from the
 *  specified memory pool.
 *
 *  The parameter size is the atom size, in bytes, 1 <= size <= 256.
 *
 *  Note that the free atom contains arbitrary data, not binary zeros.
 *
 *  RETURNS
 *
 *  The routine returns a pointer to the free atom obtained. */
 
 void *dmp_get_atom(DMP *pool, int size)
 {     void *atom;
-      int k;
-#ifdef GLP_DEBUG
-      int orig_size = size;
-#endif
-      if (!(1 <= size && size <= 256))
-         xerror("dmp_get_atom: size = %d; invalid atom size\n", size);
-#if 0
-      if (!(pool->size == 0 || pool->size == size))
-         xerror("dmp_get_atom: size = %d; wrong atom size\n", size);
-#endif
-      /* adjust the size to provide the proper data alignment */
-      size = align_datasize(size);
-#ifdef GLP_DEBUG
-      size += align_datasize(sizeof(struct info));
-#endif
-      /* adjust the size to make it multiple of 8 bytes, if needed */
-      size = ((size + 7) / 8) * 8;
-      /* determine the corresponding list of free cells */
-      k = size / 8 - 1;
-      xassert(0 <= k && k <= 31);
-      /* obtain a free atom */
+      int k, need;
+      xassert(1 <= size && size <= 256);
+      /* round up atom size to multiple of 8 bytes */
+      need = (size + 7) & ~7;
+      /* determine number of corresponding list of free atoms */
+      k = (need >> 3) - 1;
+      /* obtain free atom */
       if (pool->avail[k] == NULL)
-      {  /* the list of free cells is empty */
-         if (pool->used + size > DMP_BLK_SIZE)
-         {  /* allocate a new memory block */
-            void *block = xmalloc(DMP_BLK_SIZE);
+      {  /* corresponding list of free atoms is empty */
+         /* if debug mode is on, add atom prefix size */
+         if (dmp_debug)
+            need += prefix_size;
+         if (pool->used + need > DMP_BLK_SIZE)
+         {  /* allocate new memory block */
+            void *block = talloc(DMP_BLK_SIZE, char);
             *(void **)block = pool->block;
             pool->block = block;
-            pool->used = align_datasize(sizeof(void *));
+            pool->used = 8; /* sufficient to store pointer */
          }
-         /* place the atom in the current memory block */
+         /* allocate new atom in current memory block */
          atom = (char *)pool->block + pool->used;
-         pool->used += size;
+         pool->used += need;
       }
       else
-      {  /* obtain the atom from the list of free cells */
-         atom = pool->avail[k];
+      {  /* obtain atom from corresponding list of free atoms */
+         atom  = pool->avail[k];
          pool->avail[k] = *(void **)atom;
       }
-      memset(atom, '?', size);
-      /* increase the number of atoms which are currently in use */
-      pool->count.lo++;
-      if (pool->count.lo == 0) pool->count.hi++;
-#ifdef GLP_DEBUG
-      ((struct info *)atom)->pool = pool;
-      ((struct info *)atom)->size = orig_size;
-      atom = (char *)atom + align_datasize(sizeof(struct info));
-#endif
+      /* if debug mode is on, fill atom prefix */
+      if (dmp_debug)
+      {  ((struct prefix *)atom)->pool = pool;
+         ((struct prefix *)atom)->size = size;
+         atom = (char *)atom + prefix_size;
+      }
+      /* increase number of allocated atoms */
+      pool->count++;
       return atom;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  dmp_free_atom - return atom to dynamic memory pool
 *
 *  SYNOPSIS
 *
-*  #include "glpdmp.h"
+*  #include "dmp.h"
 *  void dmp_free_atom(DMP *pool, void *atom, int size);
 *
 *  DESCRIPTION
 *
-*  The routine dmp_free_atom returns the specified atom (memory block)
-*  to the specified memory pool, making it free.
+*  The routine dmp_free_atom returns the specified atom (memory space)
+*  to the specified memory pool, making the atom free.
 *
 *  The parameter size is the atom size, in bytes, 1 <= size <= 256.
 *
 *  Note that the atom can be returned only to the pool, from which it
 *  was obtained, and its size must be exactly the same as on obtaining
 *  it from the pool. */
 
 void dmp_free_atom(DMP *pool, void *atom, int size)
 {     int k;
-      if (!(1 <= size && size <= 256))
-         xerror("dmp_free_atom: size = %d; invalid atom size\n", size);
-#if 0
-      if (!(pool->size == 0 || pool->size == size))
-         xerror("dmp_free_atom: size = %d; wrong atom size\n", size);
-#endif
-      if (pool->count.lo == 0 && pool->count.hi == 0)
-         xerror("dmp_free_atom: pool allocation error\n");
-#ifdef GLP_DEBUG
-      atom = (char *)atom - align_datasize(sizeof(struct info));
-      xassert(((struct info *)atom)->pool == pool);
-      xassert(((struct info *)atom)->size == size);
-#endif
-      /* adjust the size to provide the proper data alignment */
-      size = align_datasize(size);
-#ifdef GLP_DEBUG
-      size += align_datasize(sizeof(struct info));
-#endif
-      /* adjust the size to make it multiple of 8 bytes, if needed */
-      size = ((size + 7) / 8) * 8;
-      /* determine the corresponding list of free cells */
-      k = size / 8 - 1;
-      xassert(0 <= k && k <= 31);
-      /* return the atom to the list of free cells */
+      xassert(1 <= size && size <= 256);
+      /* determine number of corresponding list of free atoms */
+      k = ((size + 7) >> 3) - 1;
+      /* if debug mode is on, check atom prefix */
+      if (dmp_debug)
+      {  atom = (char *)atom - prefix_size;
+         xassert(((struct prefix *)atom)->pool == pool);
+         xassert(((struct prefix *)atom)->size == size);
+      }
+      /* return atom to corresponding list of free atoms */
       *(void **)atom = pool->avail[k];
       pool->avail[k] = atom;
-      /* decrease the number of atoms which are currently in use */
-      pool->count.lo--;
-      if (pool->count.lo == 0xFFFFFFFF) pool->count.hi--;
+      /* decrease number of allocated atoms */
+      xassert(pool->count > 0);
+      pool->count--;
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  dmp_in_use - determine how many atoms are still in use
 *
 *  SYNOPSIS
 *
-*  #include "glpdmp.h"
-*  glp_long dmp_in_use(DMP *pool);
-*
-*  DESCRIPTION
-*
-*  The routine dmp_in_use determines how many atoms allocated from the
-*  specified memory pool with the routine dmp_get_atom are still in use,
-*  i.e. not returned to the pool with the routine dmp_free_atom.
+*  #include "dmp.h"
+*  size_t dmp_in_use(DMP *pool);
 *
 *  RETURNS
 *
-*  The routine returns the number of atoms which are still in use. */
+*  The routine returns the number of atoms of the specified memory pool
+*  which are still in use. */
 
-glp_long dmp_in_use(DMP *pool)
+size_t dmp_in_use(DMP *pool)
 {     return
          pool->count;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  dmp_delete_pool - delete dynamic memory pool
 *
 *  SYNOPSIS
 *
-*  #include "glpdmp.h"
+*  #include "dmp.h"
 *  void dmp_delete_pool(DMP *pool);
 *
 *  DESCRIPTION
 *
 *  The routine dmp_delete_pool deletes the specified dynamic memory
-*  pool and frees all the memory allocated to this object. */
+*  pool freeing all the memory allocated to this object. */
 
 void dmp_delete_pool(DMP *pool)
 {     while (pool->block != NULL)
       {  void *block = pool->block;
          pool->block = *(void **)block;
-         xfree(block);
+         tfree(block);
       }
-      xfree(pool);
+      tfree(pool);
       return;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpdmp.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/dmp.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpdmp.h (dynamic memory pool) */
+/* dmp.h (dynamic memory pool) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,61 +15,45 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPDMP_H
-#define GLPDMP_H
+#ifndef DMP_H
+#define DMP_H
 
-#include "glpenv.h"
+#include "stdc.h"
 
 typedef struct DMP DMP;
 
-#define DMP_BLK_SIZE 8000
-/* size of memory blocks, in bytes, allocated for memory pools */
-
-struct DMP
-{     /* dynamic memory pool */
-#if 0
-      int size;
-      /* size of atoms, in bytes, 1 <= size <= 256; if size = 0, atoms
-         may have different sizes */
-#endif
-      void *avail[32];
-      /* avail[k], 0 <= k <= 31, is a pointer to the first available
-         (free) cell of (k+1)*8 bytes long; in the beginning of each
-         free cell there is a pointer to another free cell of the same
-         length */
-      void *block;
-      /* pointer to the most recently allocated memory block; in the
-         beginning of each allocated memory block there is a pointer to
-         the previously allocated memory block */
-      int used;
-      /* number of bytes used in the most recently allocated memory
-         block */
-      glp_long count;
-      /* number of atoms which are currently in use */
-};
+#define dmp_debug _glp_dmp_debug
+extern int dmp_debug;
+/* debug mode flag */
 
 #define dmp_create_pool _glp_dmp_create_pool
 DMP *dmp_create_pool(void);
 /* create dynamic memory pool */
 
+#define dmp_talloc(pool, type) \
+      ((type *)dmp_get_atom(pool, sizeof(type)))
+
 #define dmp_get_atom _glp_dmp_get_atom
 void *dmp_get_atom(DMP *pool, int size);
 /* get free atom from dynamic memory pool */
 
+#define dmp_tfree(pool, atom) \
+      dmp_free_atom(pool, atom, sizeof(*(atom)))
+
 #define dmp_free_atom _glp_dmp_free_atom
 void dmp_free_atom(DMP *pool, void *atom, int size);
 /* return atom to dynamic memory pool */
 
 #define dmp_in_use _glp_dmp_in_use
-glp_long dmp_in_use(DMP *pool);
+size_t dmp_in_use(DMP *pool);
 /* determine how many atoms are still in use */
 
 #define dmp_delete_pool _glp_dmp_delete_pool
 void dmp_delete_pool(DMP *pool);
 /* delete dynamic memory pool */
 
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpdmx.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxprim.c`

 * *Files 26% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpdmx.c (reading/writing data in DIMACS format) */
+/* spxprim.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2015-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,1455 +15,1844 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
+#if 1 /* 18/VII-2017 */
+#define SCALE_Z 1
 #endif
 
-#define _GLPSTD_STDIO
-#include "glpapi.h"
+#include "env.h"
+#include "simplex.h"
+#include "spxat.h"
+#include "spxnt.h"
+#include "spxchuzc.h"
+#include "spxchuzr.h"
+#include "spxprob.h"
+
+#define CHECK_ACCURACY 0
+/* (for debugging) */
 
 struct csa
 {     /* common storage area */
-      jmp_buf jump;
-      /* label for go to in case of error */
-      const char *fname;
-      /* name of input text file */
-      XFILE *fp;
-      /* stream assigned to input text file */
-      int count;
-      /* line count */
-      int c;
-      /* current character */
-      char field[255+1];
-      /* data field */
-      int empty;
-      /* warning 'empty line ignored' was printed */
-      int nonint;
-      /* warning 'non-integer data detected' was printed */
+      SPXLP *lp;
+      /* LP problem data and its (current) basis; this LP has m rows
+       * and n columns */
+      int dir;
+      /* original optimization direction:
+       * +1 - minimization
+       * -1 - maximization */
+#if SCALE_Z
+      double fz;
+      /* factor used to scale original objective */
+#endif
+      double *orig_c; /* double orig_c[1+n]; */
+      /* copy of original objective coefficients */
+      double *orig_l; /* double orig_l[1+n]; */
+      /* copy of original lower bounds */
+      double *orig_u; /* double orig_u[1+n]; */
+      /* copy of original upper bounds */
+      SPXAT *at;
+      /* mxn-matrix A of constraint coefficients, in sparse row-wise
+       * format (NULL if not used) */
+      SPXNT *nt;
+      /* mx(n-m)-matrix N composed of non-basic columns of constraint
+       * matrix A, in sparse row-wise format (NULL if not used) */
+      int phase;
+      /* search phase:
+       * 0 - not determined yet
+       * 1 - searching for primal feasible solution
+       * 2 - searching for optimal solution */
+      double *beta; /* double beta[1+m]; */
+      /* beta[i] is a primal value of basic variable xB[i] */
+      int beta_st;
+      /* status of the vector beta:
+       * 0 - undefined
+       * 1 - just computed
+       * 2 - updated */
+      double *d; /* double d[1+n-m]; */
+      /* d[j] is a reduced cost of non-basic variable xN[j] */
+      int d_st;
+      /* status of the vector d:
+       * 0 - undefined
+       * 1 - just computed
+       * 2 - updated */
+      SPXSE *se;
+      /* projected steepest edge and Devex pricing data block (NULL if
+       * not used) */
+      int num;
+      /* number of eligible non-basic variables */
+      int *list; /* int list[1+n-m]; */
+      /* list[1], ..., list[num] are indices j of eligible non-basic
+       * variables xN[j] */
+      int q;
+      /* xN[q] is a non-basic variable chosen to enter the basis */
+#if 0 /* 11/VI-2017 */
+      double *tcol; /* double tcol[1+m]; */
+#else
+      FVS tcol; /* FVS tcol[1:m]; */
+#endif
+      /* q-th (pivot) column of the simplex table */
+#if 1 /* 23/VI-2017 */
+      SPXBP *bp; /* SPXBP bp[1+2*m+1]; */
+      /* penalty function break points */
+#endif
+      int p;
+      /* xB[p] is a basic variable chosen to leave the basis;
+       * p = 0 means that no basic variable reaches its bound;
+       * p < 0 means that non-basic variable xN[q] reaches its opposite
+       * bound before any basic variable */
+      int p_flag;
+      /* if this flag is set, the active bound of xB[p] in the adjacent
+       * basis should be set to the upper bound */
+#if 0 /* 11/VI-2017 */
+      double *trow; /* double trow[1+n-m]; */
+#else
+      FVS trow; /* FVS trow[1:n-m]; */
+#endif
+      /* p-th (pivot) row of the simplex table */
+#if 0 /* 09/VII-2017 */
+      double *work; /* double work[1+m]; */
+      /* working array */
+#else
+      FVS work; /* FVS work[1:m]; */
+      /* working vector */
+#endif
+      int p_stat, d_stat;
+      /* primal and dual solution statuses */
+      /*--------------------------------------------------------------*/
+      /* control parameters (see struct glp_smcp) */
+      int msg_lev;
+      /* message level */
+#if 0 /* 23/VI-2017 */
+      int harris;
+      /* ratio test technique:
+       * 0 - textbook ratio test
+       * 1 - Harris' two pass ratio test */
+#else
+      int r_test;
+      /* ratio test technique:
+       * GLP_RT_STD  - textbook ratio test
+       * GLP_RT_HAR  - Harris' two pass ratio test
+       * GLP_RT_FLIP - long-step ratio test (only for phase I) */
+#endif
+      double tol_bnd, tol_bnd1;
+      /* primal feasibility tolerances */
+      double tol_dj, tol_dj1;
+      /* dual feasibility tolerances */
+      double tol_piv;
+      /* pivot tolerance */
+      int it_lim;
+      /* iteration limit */
+      int tm_lim;
+      /* time limit, milliseconds */
+      int out_frq;
+#if 0 /* 15/VII-2017 */
+      /* display output frequency, iterations */
+#else
+      /* display output frequency, milliseconds */
+#endif
+      int out_dly;
+      /* display output delay, milliseconds */
+      /*--------------------------------------------------------------*/
+      /* working parameters */
+      double tm_beg;
+      /* time value at the beginning of the search */
+      int it_beg;
+      /* simplex iteration count at the beginning of the search */
+      int it_cnt;
+      /* simplex iteration count; it increases by one every time the
+       * basis changes (including the case when a non-basic variable
+       * jumps to its opposite bound) */
+      int it_dpy;
+      /* simplex iteration count at most recent display output */
+#if 1 /* 15/VII-2017 */
+      double tm_dpy;
+      /* time value at most recent display output */
+#endif
+      int inv_cnt;
+      /* basis factorization count since most recent display output */
+#if 1 /* 01/VII-2017 */
+      int degen;
+      /* count of successive degenerate iterations; this count is used
+       * to detect stalling */
+#endif
+#if 1 /* 23/VI-2017 */
+      int ns_cnt, ls_cnt;
+      /* normal and long-step iteration counts */
+#endif
 };
 
-static void error(struct csa *csa, const char *fmt, ...)
-{     /* print error message and terminate processing */
-      va_list arg;
-      xprintf("%s:%d: error: ", csa->fname, csa->count);
-      va_start(arg, fmt);
-      xvprintf(fmt, arg);
-      va_end(arg);
-      xprintf("\n");
-      longjmp(csa->jump, 1);
-      /* no return */
-}
-
-static void warning(struct csa *csa, const char *fmt, ...)
-{     /* print warning message and continue processing */
-      va_list arg;
-      xprintf("%s:%d: warning: ", csa->fname, csa->count);
-      va_start(arg, fmt);
-      xvprintf(fmt, arg);
-      va_end(arg);
-      xprintf("\n");
-      return;
-}
-
-static void read_char(struct csa *csa)
-{     /* read character from input text file */
-      int c;
-      if (csa->c == '\n') csa->count++;
-      c = xfgetc(csa->fp);
-      if (c < 0)
-      {  if (xferror(csa->fp))
-            error(csa, "read error - %s", xerrmsg());
-         else if (csa->c == '\n')
-            error(csa, "unexpected end of file");
-         else
-         {  warning(csa, "missing final end of line");
-            c = '\n';
+/***********************************************************************
+*  set_penalty - set penalty function coefficients
+*
+*  This routine sets up objective coefficients of the penalty function,
+*  which is the sum of primal infeasibilities, as follows:
+*
+*     if beta[i] < l[k] - eps1, set c[k] = -1,
+*
+*     if beta[i] > u[k] + eps2, set c[k] = +1,
+*
+*     otherwise, set c[k] = 0,
+*
+*  where beta[i] is current value of basic variable xB[i] = x[k], l[k]
+*  and u[k] are original bounds of x[k], and
+*
+*     eps1 = tol + tol1 * |l[k]|,
+*
+*     eps2 = tol + tol1 * |u[k]|.
+*
+*  The routine returns the number of non-zero objective coefficients,
+*  which is the number of basic variables violating their bounds. Thus,
+*  if the value returned is zero, the current basis is primal feasible
+*  within the specified tolerances. */
+
+static int set_penalty(struct csa *csa, double tol, double tol1)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      double *beta = csa->beta;
+      int i, k, count = 0;
+      double t, eps;
+      /* reset objective coefficients */
+      for (k = 0; k <= n; k++)
+         c[k] = 0.0;
+      /* walk thru the list of basic variables */
+      for (i = 1; i <= m; i++)
+      {  k = head[i]; /* x[k] = xB[i] */
+         /* check lower bound */
+         if ((t = l[k]) != -DBL_MAX)
+         {  eps = tol + tol1 * (t >= 0.0 ? +t : -t);
+            if (beta[i] < t - eps)
+            {  /* lower bound is violated */
+               c[k] = -1.0, count++;
+            }
+         }
+         /* check upper bound */
+         if ((t = u[k]) != +DBL_MAX)
+         {  eps = tol + tol1 * (t >= 0.0 ? +t : -t);
+            if (beta[i] > t + eps)
+            {  /* upper bound is violated */
+               c[k] = +1.0, count++;
+            }
          }
       }
-      else if (c == '\n')
-         ;
-      else if (isspace(c))
-         c = ' ';
-      else if (iscntrl(c))
-         error(csa, "invalid control character 0x%02X", c);
-      csa->c = c;
-      return;
+      return count;
 }
 
-static void read_designator(struct csa *csa)
-{     /* read one-character line designator */
-      xassert(csa->c == '\n');
-      read_char(csa);
-      for (;;)
-      {  /* skip preceding white-space characters */
-         while (csa->c == ' ')
-            read_char(csa);
-         if (csa->c == '\n')
-         {  /* ignore empty line */
-            if (!csa->empty)
-            {  warning(csa, "empty line ignored");
-               csa->empty = 1;
-            }
-            read_char(csa);
-         }
-         else if (csa->c == 'c')
-         {  /* skip comment line */
-            while (csa->c != '\n')
-               read_char(csa);
-            read_char(csa);
+/***********************************************************************
+*  check_feas - check primal feasibility of basic solution
+*
+*  This routine checks if the specified values of all basic variables
+*  beta = (beta[i]) are within their bounds.
+*
+*  Let l[k] and u[k] be original bounds of basic variable xB[i] = x[k].
+*  The actual bounds of x[k] are determined as follows:
+*
+*  1) if phase = 1 and c[k] < 0, x[k] violates its lower bound, so its
+*     actual bounds are artificial: -inf < x[k] <= l[k];
+*
+*  2) if phase = 1 and c[k] > 0, x[k] violates its upper bound, so its
+*     actual bounds are artificial: u[k] <= x[k] < +inf;
+*
+*  3) in all other cases (if phase = 1 and c[k] = 0, or if phase = 2)
+*     actual bounds are original: l[k] <= x[k] <= u[k].
+*
+*  The parameters tol and tol1 are bound violation tolerances. The
+*  actual bounds l'[k] and u'[k] are considered as non-violated within
+*  the specified tolerance if
+*
+*     l'[k] - eps1 <= beta[i] <= u'[k] + eps2,
+*
+*  where eps1 = tol + tol1 * |l'[k]|, eps2 = tol + tol1 * |u'[k]|.
+*
+*  The routine returns one of the following codes:
+*
+*  0 - solution is feasible (no actual bounds are violated);
+*
+*  1 - solution is infeasible, however, only artificial bounds are
+*      violated (this is possible only if phase = 1);
+*
+*  2 - solution is infeasible and at least one original bound is
+*      violated. */
+
+static int check_feas(struct csa *csa, int phase, double tol, double
+      tol1)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      double *beta = csa->beta;
+      int i, k, orig, ret = 0;
+      double lk, uk, eps;
+      xassert(phase == 1 || phase == 2);
+      /* walk thru the list of basic variables */
+      for (i = 1; i <= m; i++)
+      {  k = head[i]; /* x[k] = xB[i] */
+         /* determine actual bounds of x[k] */
+         if (phase == 1 && c[k] < 0.0)
+         {  /* -inf < x[k] <= l[k] */
+            lk = -DBL_MAX, uk = l[k];
+            orig = 0; /* artificial bounds */
+         }
+         else if (phase == 1 && c[k] > 0.0)
+         {  /* u[k] <= x[k] < +inf */
+            lk = u[k], uk = +DBL_MAX;
+            orig = 0; /* artificial bounds */
          }
          else
-         {  /* hmm... looks like a line designator */
-            csa->field[0] = (char)csa->c, csa->field[1] = '\0';
-            /* check that it is followed by a white-space character */
-            read_char(csa);
-            if (!(csa->c == ' ' || csa->c == '\n'))
-               error(csa, "line designator missing or invalid");
-            break;
+         {  /* l[k] <= x[k] <= u[k] */
+            lk = l[k], uk = u[k];
+            orig = 1; /* original bounds */
+         }
+         /* check actual lower bound */
+         if (lk != -DBL_MAX)
+         {  eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
+            if (beta[i] < lk - eps)
+            {  /* actual lower bound is violated */
+               if (orig)
+               {  ret = 2;
+                  break;
+               }
+               ret = 1;
+            }
+         }
+         /* check actual upper bound */
+         if (uk != +DBL_MAX)
+         {  eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
+            if (beta[i] > uk + eps)
+            {  /* actual upper bound is violated */
+               if (orig)
+               {  ret = 2;
+                  break;
+               }
+               ret = 1;
+            }
          }
       }
-      return;
+      return ret;
 }
 
-static void read_field(struct csa *csa)
-{     /* read data field */
-      int len = 0;
-      /* skip preceding white-space characters */
-      while (csa->c == ' ')
-         read_char(csa);
-      /* scan data field */
-      if (csa->c == '\n')
-         error(csa, "unexpected end of line");
-      while (!(csa->c == ' ' || csa->c == '\n'))
-      {  if (len == sizeof(csa->field)-1)
-            error(csa, "data field `%.15s...' too long", csa->field);
-         csa->field[len++] = (char)csa->c;
-         read_char(csa);
+/***********************************************************************
+*  adjust_penalty - adjust penalty function coefficients
+*
+*  On searching for primal feasible solution it may happen that some
+*  basic variable xB[i] = x[k] has non-zero objective coefficient c[k]
+*  indicating that xB[i] violates its lower (if c[k] < 0) or upper (if
+*  c[k] > 0) original bound, but due to primal degenarcy the violation
+*  is close to zero.
+*
+*  This routine identifies such basic variables and sets objective
+*  coefficients at these variables to zero that allows avoiding zero-
+*  step simplex iterations.
+*
+*  The parameters tol and tol1 are bound violation tolerances. The
+*  original bounds l[k] and u[k] are considered as non-violated within
+*  the specified tolerance if
+*
+*     l[k] - eps1 <= beta[i] <= u[k] + eps2,
+*
+*  where beta[i] is value of basic variable xB[i] = x[k] in the current
+*  basis, eps1 = tol + tol1 * |l[k]|, eps2 = tol + tol1 * |u[k]|.
+*
+*  The routine returns the number of objective coefficients which were
+*  set to zero. */
+
+#if 0
+static int adjust_penalty(struct csa *csa, double tol, double tol1)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      double *beta = csa->beta;
+      int i, k, count = 0;
+      double t, eps;
+      xassert(csa->phase == 1);
+      /* walk thru the list of basic variables */
+      for (i = 1; i <= m; i++)
+      {  k = head[i]; /* x[k] = xB[i] */
+         if (c[k] < 0.0)
+         {  /* x[k] violates its original lower bound l[k] */
+            xassert((t = l[k]) != -DBL_MAX);
+            eps = tol + tol1 * (t >= 0.0 ? +t : -t);
+            if (beta[i] >= t - eps)
+            {  /* however, violation is close to zero */
+               c[k] = 0.0, count++;
+            }
+         }
+         else if (c[k] > 0.0)
+         {  /* x[k] violates its original upper bound u[k] */
+            xassert((t = u[k]) != +DBL_MAX);
+            eps = tol + tol1 * (t >= 0.0 ? +t : -t);
+            if (beta[i] <= t + eps)
+            {  /* however, violation is close to zero */
+               c[k] = 0.0, count++;
+            }
+         }
       }
-      csa->field[len] = '\0';
-      return;
+      return count;
 }
-
-static void end_of_line(struct csa *csa)
-{     /* skip white-space characters until end of line */
-      while (csa->c == ' ')
-         read_char(csa);
-      if (csa->c != '\n')
-         error(csa, "too many data fields specified");
-      return;
-}
-
-static void check_int(struct csa *csa, double num)
-{     /* print a warning if non-integer data are detected */
-      if (!csa->nonint && num != floor(num))
-      {  warning(csa, "non-integer data detected");
-         csa->nonint = 1;
+#else
+static int adjust_penalty(struct csa *csa, int num, const int
+      ind[/*1+num*/], double tol, double tol1)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      double *beta = csa->beta;
+      int i, k, t, cnt = 0;
+      double lk, uk, eps;
+      xassert(csa->phase == 1);
+      /* walk thru the specified list of basic variables */
+      for (t = 1; t <= num; t++)
+      {  i = ind[t];
+         xassert(1 <= i && i <= m);
+         k = head[i]; /* x[k] = xB[i] */
+         if (c[k] < 0.0)
+         {  /* x[k] violates its original lower bound */
+            lk = l[k];
+            xassert(lk != -DBL_MAX);
+            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
+            if (beta[i] >= lk - eps)
+            {  /* however, violation is close to zero */
+               c[k] = 0.0, cnt++;
+            }
+         }
+         else if (c[k] > 0.0)
+         {  /* x[k] violates its original upper bound */
+            uk = u[k];
+            xassert(uk != +DBL_MAX);
+            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
+            if (beta[i] <= uk + eps)
+            {  /* however, violation is close to zero */
+               c[k] = 0.0, cnt++;
+            }
+         }
       }
-      return;
+      return cnt;
 }
+#endif
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  NAME
+*  err_in_vec - compute maximal relative error between two vectors
 *
-*  glp_read_mincost - read min-cost flow problem data in DIMACS format
+*  This routine computes and returns maximal relative error between
+*  n-vectors x and y:
 *
-*  SYNOPSIS
+*     err_max = max |x[i] - y[i]| / (1 + |x[i]|).
 *
-*  int glp_read_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,
-*     int a_cost, const char *fname);
-*
-*  DESCRIPTION
-*
-*  The routine glp_read_mincost reads minimum cost flow problem data in
-*  DIMACS format from a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_read_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,
-      int a_cost, const char *fname)
-{     struct csa _csa, *csa = &_csa;
-      glp_vertex *v;
-      glp_arc *a;
-      int i, j, k, nv, na, ret = 0;
-      double rhs, low, cap, cost;
-      char *flag = NULL;
-      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))
-         xerror("glp_read_mincost: v_rhs = %d; invalid offset\n",
-            v_rhs);
-      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))
-         xerror("glp_read_mincost: a_low = %d; invalid offset\n",
-            a_low);
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_read_mincost: a_cap = %d; invalid offset\n",
-            a_cap);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_read_mincost: a_cost = %d; invalid offset\n",
-            a_cost);
-      glp_erase_graph(G, G->v_size, G->a_size);
-      if (setjmp(csa->jump))
-      {  ret = 1;
-         goto done;
+*  NOTE: This routine is intended only for debugginig purposes. */
+
+static double err_in_vec(int n, const double x[], const double y[])
+{     int i;
+      double err, err_max;
+      err_max = 0.0;
+      for (i = 1; i <= n; i++)
+      {  err = fabs(x[i] - y[i]) / (1.0 + fabs(x[i]));
+         if (err_max < err)
+            err_max = err;
       }
-      csa->fname = fname;
-      csa->fp = NULL;
-      csa->count = 0;
-      csa->c = '\n';
-      csa->field[0] = '\0';
-      csa->empty = csa->nonint = 0;
-      xprintf("Reading min-cost flow problem data from `%s'...\n",
-         fname);
-      csa->fp = xfopen(fname, "r");
-      if (csa->fp == NULL)
-      {  xprintf("Unable to open `%s' - %s\n", fname, xerrmsg());
-         longjmp(csa->jump, 1);
-      }
-      /* read problem line */
-      read_designator(csa);
-      if (strcmp(csa->field, "p") != 0)
-         error(csa, "problem line missing or invalid");
-      read_field(csa);
-      if (strcmp(csa->field, "min") != 0)
-         error(csa, "wrong problem designator; `min' expected");
-      read_field(csa);
-      if (!(str2int(csa->field, &nv) == 0 && nv >= 0))
-         error(csa, "number of nodes missing or invalid");
-      read_field(csa);
-      if (!(str2int(csa->field, &na) == 0 && na >= 0))
-         error(csa, "number of arcs missing or invalid");
-      xprintf("Flow network has %d node%s and %d arc%s\n",
-         nv, nv == 1 ? "" : "s", na, na == 1 ? "" : "s");
-      if (nv > 0) glp_add_vertices(G, nv);
-      end_of_line(csa);
-      /* read node descriptor lines */
-      flag = xcalloc(1+nv, sizeof(char));
-      memset(&flag[1], 0, nv * sizeof(char));
-      if (v_rhs >= 0)
-      {  rhs = 0.0;
-         for (i = 1; i <= nv; i++)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_rhs, &rhs, sizeof(double));
-         }
-      }
-      for (;;)
-      {  read_designator(csa);
-         if (strcmp(csa->field, "n") != 0) break;
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "node number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "node number %d out of range", i);
-         if (flag[i])
-            error(csa, "duplicate descriptor of node %d", i);
-         read_field(csa);
-         if (str2num(csa->field, &rhs) != 0)
-            error(csa, "node supply/demand missing or invalid");
-         check_int(csa, rhs);
-         if (v_rhs >= 0)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_rhs, &rhs, sizeof(double));
-         }
-         flag[i] = 1;
-         end_of_line(csa);
-      }
-      xfree(flag), flag = NULL;
-      /* read arc descriptor lines */
-      for (k = 1; k <= na; k++)
-      {  if (k > 1) read_designator(csa);
-         if (strcmp(csa->field, "a") != 0)
-            error(csa, "wrong line designator; `a' expected");
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "starting node number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "starting node number %d out of range", i);
-         read_field(csa);
-         if (str2int(csa->field, &j) != 0)
-            error(csa, "ending node number missing or invalid");
-         if (!(1 <= j && j <= nv))
-            error(csa, "ending node number %d out of range", j);
-         read_field(csa);
-         if (!(str2num(csa->field, &low) == 0 && low >= 0.0))
-            error(csa, "lower bound of arc flow missing or invalid");
-         check_int(csa, low);
-         read_field(csa);
-         if (!(str2num(csa->field, &cap) == 0 && cap >= low))
-            error(csa, "upper bound of arc flow missing or invalid");
-         check_int(csa, cap);
-         read_field(csa);
-         if (str2num(csa->field, &cost) != 0)
-            error(csa, "per-unit cost of arc flow missing or invalid");
-         check_int(csa, cost);
-         a = glp_add_arc(G, i, j);
-         if (a_low >= 0)
-            memcpy((char *)a->data + a_low, &low, sizeof(double));
-         if (a_cap >= 0)
-            memcpy((char *)a->data + a_cap, &cap, sizeof(double));
-         if (a_cost >= 0)
-            memcpy((char *)a->data + a_cost, &cost, sizeof(double));
-         end_of_line(csa);
-      }
-      xprintf("%d lines were read\n", csa->count);
-done: if (ret) glp_erase_graph(G, G->v_size, G->a_size);
-      if (csa->fp != NULL) xfclose(csa->fp);
-      if (flag != NULL) xfree(flag);
-      return ret;
+      return err_max;
 }
+#endif
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  NAME
+*  err_in_beta - compute maximal relative error in vector beta
 *
-*  glp_write_mincost - write min-cost flow problem data in DIMACS format
+*  This routine computes and returns maximal relative error in vector
+*  of values of basic variables beta = (beta[i]).
 *
-*  SYNOPSIS
-*
-*  int glp_write_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,
-*     int a_cost, const char *fname);
-*
-*  DESCRIPTION
-*
-*  The routine glp_write_mincost writes minimum cost flow problem data
-*  in DIMACS format to a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_write_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,
-      int a_cost, const char *fname)
-{     XFILE *fp;
-      glp_vertex *v;
-      glp_arc *a;
-      int i, count = 0, ret;
-      double rhs, low, cap, cost;
-      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))
-         xerror("glp_write_mincost: v_rhs = %d; invalid offset\n",
-            v_rhs);
-      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))
-         xerror("glp_write_mincost: a_low = %d; invalid offset\n",
-            a_low);
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_write_mincost: a_cap = %d; invalid offset\n",
-            a_cap);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_write_mincost: a_cost = %d; invalid offset\n",
-            a_cost);
-      xprintf("Writing min-cost flow problem data to `%s'...\n",
-         fname);
-      fp = xfopen(fname, "w");
-      if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      xfprintf(fp, "c %s\n",
-         G->name == NULL ? "unknown" : G->name), count++;
-      xfprintf(fp, "p min %d %d\n", G->nv, G->na), count++;
-      if (v_rhs >= 0)
-      {  for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            memcpy(&rhs, (char *)v->data + v_rhs, sizeof(double));
-            if (rhs != 0.0)
-               xfprintf(fp, "n %d %.*g\n", i, DBL_DIG, rhs), count++;
-         }
-      }
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  if (a_low >= 0)
-               memcpy(&low, (char *)a->data + a_low, sizeof(double));
-            else
-               low = 0.0;
-            if (a_cap >= 0)
-               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));
-            else
-               cap = 1.0;
-            if (a_cost >= 0)
-               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));
-            else
-               cost = 0.0;
-            xfprintf(fp, "a %d %d %.*g %.*g %.*g\n",
-               a->tail->i, a->head->i, DBL_DIG, low, DBL_DIG, cap,
-               DBL_DIG, cost), count++;
-         }
-      }
-      xfprintf(fp, "c eof\n"), count++;
-      xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      xprintf("%d lines were written\n", count);
-      ret = 0;
-done: if (fp != NULL) xfclose(fp);
-      return ret;
+*  NOTE: This routine is intended only for debugginig purposes. */
+
+static double err_in_beta(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      double err, *beta;
+      beta = talloc(1+m, double);
+      spx_eval_beta(lp, beta);
+      err = err_in_vec(m, beta, csa->beta);
+      tfree(beta);
+      return err;
 }
+#endif
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  NAME
-*
-*  glp_read_maxflow - read maximum flow problem data in DIMACS format
-*
-*  SYNOPSIS
-*
-*  int glp_read_maxflow(glp_graph *G, int *s, int *t, int a_cap,
-*     const char *fname);
+*  err_in_d - compute maximal relative error in vector d
 *
-*  DESCRIPTION
+*  This routine computes and returns maximal relative error in vector
+*  of reduced costs of non-basic variables d = (d[j]).
 *
-*  The routine glp_read_maxflow reads maximum flow problem data in
-*  DIMACS format from a text file.
+*  NOTE: This routine is intended only for debugginig purposes. */
+
+static double err_in_d(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      int j;
+      double err, *pi, *d;
+      pi = talloc(1+m, double);
+      d = talloc(1+n-m, double);
+      spx_eval_pi(lp, pi);
+      for (j = 1; j <= n-m; j++)
+         d[j] = spx_eval_dj(lp, pi, j);
+      err = err_in_vec(n-m, d, csa->d);
+      tfree(pi);
+      tfree(d);
+      return err;
+}
+#endif
+
+#if CHECK_ACCURACY
+/***********************************************************************
+*  err_in_gamma - compute maximal relative error in vector gamma
 *
-*  RETURNS
+*  This routine computes and returns maximal relative error in vector
+*  of projected steepest edge weights gamma = (gamma[j]).
 *
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
+*  NOTE: This routine is intended only for debugginig purposes. */
 
-int glp_read_maxflow(glp_graph *G, int *_s, int *_t, int a_cap,
-      const char *fname)
-{     struct csa _csa, *csa = &_csa;
-      glp_arc *a;
-      int i, j, k, s, t, nv, na, ret = 0;
-      double cap;
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_read_maxflow: a_cap = %d; invalid offset\n",
-            a_cap);
-      glp_erase_graph(G, G->v_size, G->a_size);
-      if (setjmp(csa->jump))
-      {  ret = 1;
-         goto done;
-      }
-      csa->fname = fname;
-      csa->fp = NULL;
-      csa->count = 0;
-      csa->c = '\n';
-      csa->field[0] = '\0';
-      csa->empty = csa->nonint = 0;
-      xprintf("Reading maximum flow problem data from `%s'...\n",
-         fname);
-      csa->fp = xfopen(fname, "r");
-      if (csa->fp == NULL)
-      {  xprintf("Unable to open `%s' - %s\n", fname, xerrmsg());
-         longjmp(csa->jump, 1);
-      }
-      /* read problem line */
-      read_designator(csa);
-      if (strcmp(csa->field, "p") != 0)
-         error(csa, "problem line missing or invalid");
-      read_field(csa);
-      if (strcmp(csa->field, "max") != 0)
-         error(csa, "wrong problem designator; `max' expected");
-      read_field(csa);
-      if (!(str2int(csa->field, &nv) == 0 && nv >= 2))
-         error(csa, "number of nodes missing or invalid");
-      read_field(csa);
-      if (!(str2int(csa->field, &na) == 0 && na >= 0))
-         error(csa, "number of arcs missing or invalid");
-      xprintf("Flow network has %d node%s and %d arc%s\n",
-         nv, nv == 1 ? "" : "s", na, na == 1 ? "" : "s");
-      if (nv > 0) glp_add_vertices(G, nv);
-      end_of_line(csa);
-      /* read node descriptor lines */
-      s = t = 0;
-      for (;;)
-      {  read_designator(csa);
-         if (strcmp(csa->field, "n") != 0) break;
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "node number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "node number %d out of range", i);
-         read_field(csa);
-         if (strcmp(csa->field, "s") == 0)
-         {  if (s > 0)
-               error(csa, "only one source node allowed");
-            s = i;
-         }
-         else if (strcmp(csa->field, "t") == 0)
-         {  if (t > 0)
-               error(csa, "only one sink node allowed");
-            t = i;
-         }
-         else
-            error(csa, "wrong node designator; `s' or `t' expected");
-         if (s > 0 && s == t)
-            error(csa, "source and sink nodes must be distinct");
-         end_of_line(csa);
-      }
-      if (s == 0)
-         error(csa, "source node descriptor missing\n");
-      if (t == 0)
-         error(csa, "sink node descriptor missing\n");
-      if (_s != NULL) *_s = s;
-      if (_t != NULL) *_t = t;
-      /* read arc descriptor lines */
-      for (k = 1; k <= na; k++)
-      {  if (k > 1) read_designator(csa);
-         if (strcmp(csa->field, "a") != 0)
-            error(csa, "wrong line designator; `a' expected");
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "starting node number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "starting node number %d out of range", i);
-         read_field(csa);
-         if (str2int(csa->field, &j) != 0)
-            error(csa, "ending node number missing or invalid");
-         if (!(1 <= j && j <= nv))
-            error(csa, "ending node number %d out of range", j);
-         read_field(csa);
-         if (!(str2num(csa->field, &cap) == 0 && cap >= 0.0))
-            error(csa, "arc capacity missing or invalid");
-         check_int(csa, cap);
-         a = glp_add_arc(G, i, j);
-         if (a_cap >= 0)
-            memcpy((char *)a->data + a_cap, &cap, sizeof(double));
-         end_of_line(csa);
-      }
-      xprintf("%d lines were read\n", csa->count);
-done: if (ret) glp_erase_graph(G, G->v_size, G->a_size);
-      if (csa->fp != NULL) xfclose(csa->fp);
-      return ret;
+static double err_in_gamma(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      SPXSE *se = csa->se;
+      int j;
+      double err, *gamma;
+      xassert(se != NULL);
+      gamma = talloc(1+n-m, double);
+      for (j = 1; j <= n-m; j++)
+         gamma[j] = spx_eval_gamma_j(lp, se, j);
+      err = err_in_vec(n-m, gamma, se->gamma);
+      tfree(gamma);
+      return err;
 }
+#endif
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  NAME
-*
-*  glp_write_maxflow - write maximum flow problem data in DIMACS format
+*  check_accuracy - check accuracy of basic solution components
 *
-*  SYNOPSIS
+*  This routine checks accuracy of current basic solution components.
 *
-*  int glp_write_maxflow(glp_graph *G, int s, int t, int a_cap,
-*     const char *fname);
+*  NOTE: This routine is intended only for debugginig purposes. */
+
+static void check_accuracy(struct csa *csa)
+{     double e_beta, e_d, e_gamma;
+      e_beta = err_in_beta(csa);
+      e_d = err_in_d(csa);
+      if (csa->se == NULL)
+         e_gamma = 0.;
+      else
+         e_gamma = err_in_gamma(csa);
+      xprintf("e_beta = %10.3e; e_d = %10.3e; e_gamma = %10.3e\n",
+         e_beta, e_d, e_gamma);
+      xassert(e_beta <= 1e-5 && e_d <= 1e-5 && e_gamma <= 1e-3);
+      return;
+}
+#endif
+
+/***********************************************************************
+*  choose_pivot - choose xN[q] and xB[p]
 *
-*  DESCRIPTION
-*
-*  The routine glp_write_maxflow writes maximum flow problem data in
-*  DIMACS format to a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_write_maxflow(glp_graph *G, int s, int t, int a_cap,
-      const char *fname)
-{     XFILE *fp;
-      glp_vertex *v;
-      glp_arc *a;
-      int i, count = 0, ret;
-      double cap;
-      if (!(1 <= s && s <= G->nv))
-         xerror("glp_write_maxflow: s = %d; source node number out of r"
-            "ange\n", s);
-      if (!(1 <= t && t <= G->nv))
-         xerror("glp_write_maxflow: t = %d: sink node number out of ran"
-            "ge\n", t);
-      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-         xerror("glp_write_mincost: a_cap = %d; invalid offset\n",
-            a_cap);
-      xprintf("Writing maximum flow problem data to `%s'...\n",
-         fname);
-      fp = xfopen(fname, "w");
-      if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
+*  Given the list of eligible non-basic variables this routine first
+*  chooses non-basic variable xN[q]. This choice is always possible,
+*  because the list is assumed to be non-empty. Then the routine
+*  computes q-th column T[*,q] of the simplex table T[i,j] and chooses
+*  basic variable xB[p]. If the pivot T[p,q] is small in magnitude,
+*  the routine attempts to choose another xN[q] and xB[p] in order to
+*  avoid badly conditioned adjacent bases. */
+
+#if 1 /* 17/III-2016 */
+#define MIN_RATIO 0.0001
+
+static int choose_pivot(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *beta = csa->beta;
+      double *d = csa->d;
+      SPXSE *se = csa->se;
+      int *list = csa->list;
+#if 0 /* 09/VII-2017 */
+      double *tcol = csa->work;
+#else
+      double *tcol = csa->work.vec;
+#endif
+      double tol_piv = csa->tol_piv;
+      int try, nnn, /*i,*/ p, p_flag, q, t;
+      double big, /*temp,*/ best_ratio;
+#if 1 /* 23/VI-2017 */
+      double *c = lp->c;
+      int *head = lp->head;
+      SPXBP *bp = csa->bp;
+      int nbp, t_best, ret, k;
+      double dz_best;
+#endif
+      xassert(csa->beta_st);
+      xassert(csa->d_st);
+more: /* initial number of eligible non-basic variables */
+      nnn = csa->num;
+      /* nothing has been chosen so far */
+      csa->q = 0;
+      best_ratio = 0.0;
+#if 0 /* 23/VI-2017 */
+      try = 0;
+#else
+      try = ret = 0;
+#endif
+try:  /* choose non-basic variable xN[q] */
+      xassert(nnn > 0);
+      try++;
+      if (se == NULL)
+      {  /* Dantzig's rule */
+         q = spx_chuzc_std(lp, d, nnn, list);
+      }
+      else
+      {  /* projected steepest edge */
+         q = spx_chuzc_pse(lp, se, d, nnn, list);
+      }
+      xassert(1 <= q && q <= n-m);
+      /* compute q-th column of the simplex table */
+      spx_eval_tcol(lp, q, tcol);
+#if 0
+      /* big := max(1, |tcol[1]|, ..., |tcol[m]|) */
+      big = 1.0;
+      for (i = 1; i <= m; i++)
+      {  temp = tcol[i];
+         if (temp < 0.0)
+            temp = - temp;
+         if (big < temp)
+            big = temp;
+      }
+#else
+      /* this still puzzles me */
+      big = 1.0;
+#endif
+      /* choose basic variable xB[p] */
+#if 1 /* 23/VI-2017 */
+      if (csa->phase == 1 && csa->r_test == GLP_RT_FLIP && try <= 2)
+      {  /* long-step ratio test */
+         int t, num, num1;
+         double slope, teta_lim;
+         /* determine penalty function break points */
+         nbp = spx_ls_eval_bp(lp, beta, q, d[q], tcol, tol_piv, bp);
+         if (nbp < 2)
+            goto skip;
+         /* set initial slope */
+         slope = - fabs(d[q]);
+         /* estimate initial teta_lim */
+         teta_lim = DBL_MAX;
+         for (t = 1; t <= nbp; t++)
+         {  if (teta_lim > bp[t].teta)
+               teta_lim = bp[t].teta;
+         }
+         xassert(teta_lim >= 0.0);
+         if (teta_lim < 1e-3)
+            teta_lim = 1e-3;
+         /* nothing has been chosen so far */
+         t_best = 0, dz_best = 0.0, num = 0;
+         /* choose appropriate break point */
+         while (num < nbp)
+         {  /* select and process a new portion of break points */
+            num1 = spx_ls_select_bp(lp, tcol, nbp, bp, num, &slope,
+               teta_lim);
+            for (t = num+1; t <= num1; t++)
+            {  int i = (bp[t].i >= 0 ? bp[t].i : -bp[t].i);
+               xassert(0 <= i && i <= m);
+               if (i == 0 || fabs(tcol[i]) / big >= MIN_RATIO)
+               {  if (dz_best > bp[t].dz)
+                     t_best = t, dz_best = bp[t].dz;
+               }
+#if 0
+               if (i == 0)
+               {  /* do not consider further break points beyond this
+                   * point, where xN[q] reaches its opposite bound;
+                   * in principle (see spx_ls_eval_bp), this break
+                   * point should be the last one, however, due to
+                   * round-off errors there may be other break points
+                   * with the same teta beyond this one */
+                  slope = +1.0;
+               }
+#endif
+            }
+            if (slope > 0.0)
+            {  /* penalty function starts increasing */
+               break;
+            }
+            /* penalty function continues decreasing */
+            num = num1;
+            teta_lim += teta_lim;
+         }
+         if (dz_best == 0.0)
+            goto skip;
+         /* the choice has been made */
+         xassert(1 <= t_best && t_best <= num1);
+         if (t_best == 1)
+         {  /* the very first break point was chosen; it is reasonable
+             * to use the short-step ratio test */
+            goto skip;
+         }
+         csa->q = q;
+         memcpy(&csa->tcol.vec[1], &tcol[1], m * sizeof(double));
+         fvs_gather_vec(&csa->tcol, DBL_EPSILON);
+         if (bp[t_best].i == 0)
+         {  /* xN[q] goes to its opposite bound */
+            csa->p = -1;
+            csa->p_flag = 0;
+            best_ratio = 1.0;
+         }
+         else if (bp[t_best].i > 0)
+         {  /* xB[p] leaves the basis and goes to its lower bound */
+            csa->p = + bp[t_best].i;
+            xassert(1 <= csa->p && csa->p <= m);
+            csa->p_flag = 0;
+            best_ratio = fabs(tcol[csa->p]) / big;
+         }
+         else
+         {  /* xB[p] leaves the basis and goes to its upper bound */
+            csa->p = - bp[t_best].i;
+            xassert(1 <= csa->p && csa->p <= m);
+            csa->p_flag = 1;
+            best_ratio = fabs(tcol[csa->p]) / big;
+         }
+#if 0
+         xprintf("num1 = %d; t_best = %d; dz = %g\n", num1, t_best,
+            bp[t_best].dz);
+#endif
          ret = 1;
          goto done;
+skip:    ;
       }
-      xfprintf(fp, "c %s\n",
-         G->name == NULL ? "unknown" : G->name), count++;
-      xfprintf(fp, "p max %d %d\n", G->nv, G->na), count++;
-      xfprintf(fp, "n %d s\n", s), count++;
-      xfprintf(fp, "n %d t\n", t), count++;
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  if (a_cap >= 0)
-               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));
-            else
-               cap = 1.0;
-            xfprintf(fp, "a %d %d %.*g\n",
-               a->tail->i, a->head->i, DBL_DIG, cap), count++;
-         }
+#endif
+#if 0 /* 23/VI-2017 */
+      if (!csa->harris)
+#else
+      if (csa->r_test == GLP_RT_STD)
+#endif
+      {  /* textbook ratio test */
+         p = spx_chuzr_std(lp, csa->phase, beta, q,
+            d[q] < 0.0 ? +1. : -1., tcol, &p_flag, tol_piv,
+            .30 * csa->tol_bnd, .30 * csa->tol_bnd1);
       }
-      xfprintf(fp, "c eof\n"), count++;
-      xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
+      else
+      {  /* Harris' two-pass ratio test */
+         p = spx_chuzr_harris(lp, csa->phase, beta, q,
+            d[q] < 0.0 ? +1. : -1., tcol, &p_flag , tol_piv,
+            .50 * csa->tol_bnd, .50 * csa->tol_bnd1);
+      }
+      if (p <= 0)
+      {  /* primal unboundedness or special case */
+         csa->q = q;
+#if 0 /* 11/VI-2017 */
+         memcpy(&csa->tcol[1], &tcol[1], m * sizeof(double));
+#else
+         memcpy(&csa->tcol.vec[1], &tcol[1], m * sizeof(double));
+         fvs_gather_vec(&csa->tcol, DBL_EPSILON);
+#endif
+         csa->p = p;
+         csa->p_flag = p_flag;
+         best_ratio = 1.0;
          goto done;
       }
-      xprintf("%d lines were written\n", count);
-      ret = 0;
-done: if (fp != NULL) xfclose(fp);
-      return ret;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  glp_read_asnprob - read assignment problem data in DIMACS format
-*
-*  SYNOPSIS
-*
-*  int glp_read_asnprob(glp_graph *G, int v_set, int a_cost,
-*     const char *fname);
-*
-*  DESCRIPTION
-*
-*  The routine glp_read_asnprob reads assignment problem data in DIMACS
-*  format from a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_read_asnprob(glp_graph *G, int v_set, int a_cost, const char
-      *fname)
-{     struct csa _csa, *csa = &_csa;
-      glp_vertex *v;
-      glp_arc *a;
-      int nv, na, n1, i, j, k, ret = 0;
-      double cost;
-      char *flag = NULL;
-      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))
-         xerror("glp_read_asnprob: v_set = %d; invalid offset\n",
-            v_set);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_read_asnprob: a_cost = %d; invalid offset\n",
-            a_cost);
-      glp_erase_graph(G, G->v_size, G->a_size);
-      if (setjmp(csa->jump))
-      {  ret = 1;
+      /* either keep previous choice or accept new choice depending on
+       * which one is better */
+      if (best_ratio < fabs(tcol[p]) / big)
+      {  csa->q = q;
+#if 0 /* 11/VI-2017 */
+         memcpy(&csa->tcol[1], &tcol[1], m * sizeof(double));
+#else
+         memcpy(&csa->tcol.vec[1], &tcol[1], m * sizeof(double));
+         fvs_gather_vec(&csa->tcol, DBL_EPSILON);
+#endif
+         csa->p = p;
+         csa->p_flag = p_flag;
+         best_ratio = fabs(tcol[p]) / big;
+      }
+      /* check if the current choice is acceptable */
+      if (best_ratio >= MIN_RATIO || nnn == 1 || try == 5)
          goto done;
+      /* try to choose other xN[q] and xB[p] */
+      /* find xN[q] in the list */
+      for (t = 1; t <= nnn; t++)
+         if (list[t] == q) break;
+      xassert(t <= nnn);
+      /* move xN[q] to the end of the list */
+      list[t] = list[nnn], list[nnn] = q;
+      /* and exclude it from consideration */
+      nnn--;
+      /* repeat the choice */
+      goto try;
+done: /* the choice has been made */
+#if 1 /* FIXME: currently just to avoid badly conditioned basis */
+      if (best_ratio < .001 * MIN_RATIO)
+      {  /* looks like this helps */
+         if (bfd_get_count(lp->bfd) > 0)
+            return -1;
+         /* didn't help; last chance to improve the choice */
+         if (tol_piv == csa->tol_piv)
+         {  tol_piv *= 1000.;
+            goto more;
+         }
+      }
+#endif
+#if 0 /* 23/VI-2017 */
+      return 0;
+#else /* FIXME */
+      if (ret)
+      {  /* invalidate dual basic solution components */
+         csa->d_st = 0;
+         /* change penalty function coefficients at basic variables for
+          * all break points preceding the chosen one */
+         for (t = 1; t < t_best; t++)
+         {  int i = (bp[t].i >= 0 ? bp[t].i : -bp[t].i);
+            xassert(0 <= i && i <= m);
+            if (i == 0)
+            {  /* xN[q] crosses its opposite bound */
+               xassert(1 <= csa->q && csa->q <= n-m);
+               k = head[m+csa->q];
+            }
+            else
+            {  /* xB[i] crosses its (lower or upper) bound */
+               k = head[i]; /* x[k] = xB[i] */
+            }
+            c[k] += bp[t].dc;
+            xassert(c[k] == 0.0 || c[k] == +1.0 || c[k] == -1.0);
+         }
       }
-      csa->fname = fname;
-      csa->fp = NULL;
-      csa->count = 0;
-      csa->c = '\n';
-      csa->field[0] = '\0';
-      csa->empty = csa->nonint = 0;
-      xprintf("Reading assignment problem data from `%s'...\n", fname);
-      csa->fp = xfopen(fname, "r");
-      if (csa->fp == NULL)
-      {  xprintf("Unable to open `%s' - %s\n", fname, xerrmsg());
-         longjmp(csa->jump, 1);
-      }
-      /* read problem line */
-      read_designator(csa);
-      if (strcmp(csa->field, "p") != 0)
-         error(csa, "problem line missing or invalid");
-      read_field(csa);
-      if (strcmp(csa->field, "asn") != 0)
-         error(csa, "wrong problem designator; `asn' expected");
-      read_field(csa);
-      if (!(str2int(csa->field, &nv) == 0 && nv >= 0))
-         error(csa, "number of nodes missing or invalid");
-      read_field(csa);
-      if (!(str2int(csa->field, &na) == 0 && na >= 0))
-         error(csa, "number of arcs missing or invalid");
-      if (nv > 0) glp_add_vertices(G, nv);
-      end_of_line(csa);
-      /* read node descriptor lines */
-      flag = xcalloc(1+nv, sizeof(char));
-      memset(&flag[1], 0, nv * sizeof(char));
-      n1 = 0;
-      for (;;)
-      {  read_designator(csa);
-         if (strcmp(csa->field, "n") != 0) break;
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "node number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "node number %d out of range", i);
-         if (flag[i])
-            error(csa, "duplicate descriptor of node %d", i);
-         flag[i] = 1, n1++;
-         end_of_line(csa);
-      }
-      xprintf(
-         "Assignment problem has %d + %d = %d node%s and %d arc%s\n",
-         n1, nv - n1, nv, nv == 1 ? "" : "s", na, na == 1 ? "" : "s");
-      if (v_set >= 0)
-      {  for (i = 1; i <= nv; i++)
-         {  v = G->v[i];
-            k = (flag[i] ? 0 : 1);
-            memcpy((char *)v->data + v_set, &k, sizeof(int));
-         }
-      }
-      /* read arc descriptor lines */
-      for (k = 1; k <= na; k++)
-      {  if (k > 1) read_designator(csa);
-         if (strcmp(csa->field, "a") != 0)
-            error(csa, "wrong line designator; `a' expected");
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "starting node number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "starting node number %d out of range", i);
-         if (!flag[i])
-            error(csa, "node %d cannot be a starting node", i);
-         read_field(csa);
-         if (str2int(csa->field, &j) != 0)
-            error(csa, "ending node number missing or invalid");
-         if (!(1 <= j && j <= nv))
-            error(csa, "ending node number %d out of range", j);
-         if (flag[j])
-            error(csa, "node %d cannot be an ending node", j);
-         read_field(csa);
-         if (str2num(csa->field, &cost) != 0)
-            error(csa, "arc cost missing or invalid");
-         check_int(csa, cost);
-         a = glp_add_arc(G, i, j);
-         if (a_cost >= 0)
-            memcpy((char *)a->data + a_cost, &cost, sizeof(double));
-         end_of_line(csa);
-      }
-      xprintf("%d lines were read\n", csa->count);
-done: if (ret) glp_erase_graph(G, G->v_size, G->a_size);
-      if (csa->fp != NULL) xfclose(csa->fp);
-      if (flag != NULL) xfree(flag);
       return ret;
+#endif
 }
+#endif
 
 /***********************************************************************
-*  NAME
-*
-*  glp_write_asnprob - write assignment problem data in DIMACS format
+*  play_bounds - play bounds of primal variables
 *
-*  SYNOPSIS
+*  This routine is called after the primal values of basic variables
+*  beta[i] were updated and the basis was changed to the adjacent one.
 *
-*  int glp_write_asnprob(glp_graph *G, int v_set, int a_cost,
-*     const char *fname);
-*
-*  DESCRIPTION
-*
-*  The routine glp_write_asnprob writes assignment problem data in
-*  DIMACS format to a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_write_asnprob(glp_graph *G, int v_set, int a_cost, const char
-      *fname)
-{     XFILE *fp;
-      glp_vertex *v;
-      glp_arc *a;
-      int i, k, count = 0, ret;
-      double cost;
-      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))
-         xerror("glp_write_asnprob: v_set = %d; invalid offset\n",
-            v_set);
-      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-         xerror("glp_write_asnprob: a_cost = %d; invalid offset\n",
-            a_cost);
-      xprintf("Writing assignment problem data to `%s'...\n", fname);
-      fp = xfopen(fname, "w");
-      if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      xfprintf(fp, "c %s\n",
-         G->name == NULL ? "unknown" : G->name), count++;
-      xfprintf(fp, "p asn %d %d\n", G->nv, G->na), count++;
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         if (v_set >= 0)
-            memcpy(&k, (char *)v->data + v_set, sizeof(int));
-         else
-            k = (v->out != NULL ? 0 : 1);
-         if (k == 0)
-            xfprintf(fp, "n %d\n", i), count++;
-      }
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (a = v->out; a != NULL; a = a->t_next)
-         {  if (a_cost >= 0)
-               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));
-            else
-               cost = 1.0;
-            xfprintf(fp, "a %d %d %.*g\n",
-               a->tail->i, a->head->i, DBL_DIG, cost), count++;
+*  It is assumed that before updating all the primal values beta[i]
+*  were strongly feasible, so in the adjacent basis beta[i] remain
+*  feasible within a tolerance, i.e. if some beta[i] violates its lower
+*  or upper bound, the violation is insignificant.
+*
+*  If some beta[i] violates its lower or upper bound, this routine
+*  changes (perturbs) the bound to remove such violation, i.e. to make
+*  all beta[i] strongly feasible. Otherwise, if beta[i] has a feasible
+*  value, this routine attempts to reduce (or remove) perturbation of
+*  corresponding lower/upper bound keeping strong feasibility. */
+
+/* FIXME: what to do if l[k] = u[k]? */
+
+/* FIXME: reduce/remove perturbation if x[k] becomes non-basic? */
+
+static void play_bounds(struct csa *csa, int all)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      double *orig_l = csa->orig_l;
+      double *orig_u = csa->orig_u;
+      double *beta = csa->beta;
+#if 0 /* 11/VI-2017 */
+      const double *tcol = csa->tcol; /* was used to update beta */
+#else
+      const double *tcol = csa->tcol.vec;
+#endif
+      int i, k;
+      xassert(csa->phase == 1 || csa->phase == 2);
+      /* primal values beta = (beta[i]) should be valid */
+      xassert(csa->beta_st);
+      /* walk thru the list of basic variables xB = (xB[i]) */
+      for (i = 1; i <= m; i++)
+      {  if (all || tcol[i] != 0.0)
+         {  /* beta[i] has changed in the adjacent basis */
+            k = head[i]; /* x[k] = xB[i] */
+            if (csa->phase == 1 && c[k] < 0.0)
+            {  /* -inf < xB[i] <= lB[i] (artificial bounds) */
+               if (beta[i] < l[k] - 1e-9)
+                  continue;
+               /* restore actual bounds */
+               c[k] = 0.0;
+               csa->d_st = 0; /* since c[k] = cB[i] has changed */
+            }
+            if (csa->phase == 1 && c[k] > 0.0)
+            {  /* uB[i] <= xB[i] < +inf (artificial bounds) */
+               if (beta[i] > u[k] + 1e-9)
+                  continue;
+               /* restore actual bounds */
+               c[k] = 0.0;
+               csa->d_st = 0; /* since c[k] = cB[i] has changed */
+            }
+            /* lB[i] <= xB[i] <= uB[i] */
+            if (csa->phase == 1)
+               xassert(c[k] == 0.0);
+            if (l[k] != -DBL_MAX)
+            {  /* xB[i] has lower bound */
+               if (beta[i] < l[k])
+               {  /* strong feasibility means xB[i] >= lB[i] */
+#if 0 /* 11/VI-2017 */
+                  l[k] = beta[i];
+#else
+                  l[k] = beta[i] - 1e-9;
+#endif
+               }
+               else if (l[k] < orig_l[k])
+               {  /* remove/reduce perturbation of lB[i] */
+                  if (beta[i] >= orig_l[k])
+                     l[k] = orig_l[k];
+                  else
+                     l[k] = beta[i];
+               }
+            }
+            if (u[k] != +DBL_MAX)
+            {  /* xB[i] has upper bound */
+               if (beta[i] > u[k])
+               {  /* strong feasibility means xB[i] <= uB[i] */
+#if 0 /* 11/VI-2017 */
+                  u[k] = beta[i];
+#else
+                  u[k] = beta[i] + 1e-9;
+#endif
+               }
+               else if (u[k] > orig_u[k])
+               {  /* remove/reduce perturbation of uB[i] */
+                  if (beta[i] <= orig_u[k])
+                     u[k] = orig_u[k];
+                  else
+                     u[k] = beta[i];
+               }
+            }
          }
       }
-      xfprintf(fp, "c eof\n"), count++;
-      xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      xprintf("%d lines were written\n", count);
-      ret = 0;
-done: if (fp != NULL) xfclose(fp);
-      return ret;
+      return;
+}
+
+static void remove_perturb(struct csa *csa)
+{     /* remove perturbation */
+      SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      double *orig_l = csa->orig_l;
+      double *orig_u = csa->orig_u;
+      int j, k;
+      /* restore original bounds of variables */
+      memcpy(l, orig_l, (1+n) * sizeof(double));
+      memcpy(u, orig_u, (1+n) * sizeof(double));
+      /* adjust flags of fixed non-basic variables, because in the
+       * perturbed problem such variables might be changed to double-
+       * bounded type */
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         if (l[k] == u[k])
+            flag[j] = 0;
+      }
+      /* removing perturbation changes primal solution components */
+      csa->phase = csa->beta_st = 0;
+#if 1
+      if (csa->msg_lev >= GLP_MSG_ALL)
+         xprintf("Removing LP perturbation [%d]...\n",
+            csa->it_cnt);
+#endif
+      return;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  glp_read_ccdata - read graph in DIMACS clique/coloring format
-*
-*  SYNOPSIS
+*  sum_infeas - compute sum of primal infeasibilities
 *
-*  int glp_read_ccdata(glp_graph *G, int v_wgt, const char *fname);
-*
-*  DESCRIPTION
-*
-*  The routine glp_read_ccdata reads an (undirected) graph in DIMACS
-*  clique/coloring format from a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
+*  This routine compute the sum of primal infeasibilities, which is the
+*  current penalty function value. */
 
-int glp_read_ccdata(glp_graph *G, int v_wgt, const char *fname)
-{     struct csa _csa, *csa = &_csa;
-      glp_vertex *v;
-      int i, j, k, nv, ne, ret = 0;
-      double w;
-      char *flag = NULL;
-      if (v_wgt >= 0 && v_wgt > G->v_size - (int)sizeof(double))
-         xerror("glp_read_ccdata: v_wgt = %d; invalid offset\n",
-            v_wgt);
-      glp_erase_graph(G, G->v_size, G->a_size);
-      if (setjmp(csa->jump))
-      {  ret = 1;
-         goto done;
+static double sum_infeas(SPXLP *lp, const double beta[/*1+m*/])
+{     int m = lp->m;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      int i, k;
+      double sum = 0.0;
+      for (i = 1; i <= m; i++)
+      {  k = head[i]; /* x[k] = xB[i] */
+         if (l[k] != -DBL_MAX && beta[i] < l[k])
+            sum += l[k] - beta[i];
+         if (u[k] != +DBL_MAX && beta[i] > u[k])
+            sum += beta[i] - u[k];
       }
-      csa->fname = fname;
-      csa->fp = NULL;
-      csa->count = 0;
-      csa->c = '\n';
-      csa->field[0] = '\0';
-      csa->empty = csa->nonint = 0;
-      xprintf("Reading graph from `%s'...\n", fname);
-      csa->fp = xfopen(fname, "r");
-      if (csa->fp == NULL)
-      {  xprintf("Unable to open `%s' - %s\n", fname, xerrmsg());
-         longjmp(csa->jump, 1);
-      }
-      /* read problem line */
-      read_designator(csa);
-      if (strcmp(csa->field, "p") != 0)
-         error(csa, "problem line missing or invalid");
-      read_field(csa);
-      if (strcmp(csa->field, "edge") != 0)
-         error(csa, "wrong problem designator; `edge' expected");
-      read_field(csa);
-      if (!(str2int(csa->field, &nv) == 0 && nv >= 0))
-         error(csa, "number of vertices missing or invalid");
-      read_field(csa);
-      if (!(str2int(csa->field, &ne) == 0 && ne >= 0))
-         error(csa, "number of edges missing or invalid");
-      xprintf("Graph has %d vert%s and %d edge%s\n",
-         nv, nv == 1 ? "ex" : "ices", ne, ne == 1 ? "" : "s");
-      if (nv > 0) glp_add_vertices(G, nv);
-      end_of_line(csa);
-      /* read node descriptor lines */
-      flag = xcalloc(1+nv, sizeof(char));
-      memset(&flag[1], 0, nv * sizeof(char));
-      if (v_wgt >= 0)
-      {  w = 1.0;
-         for (i = 1; i <= nv; i++)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_wgt, &w, sizeof(double));
-         }
-      }
-      for (;;)
-      {  read_designator(csa);
-         if (strcmp(csa->field, "n") != 0) break;
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "vertex number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "vertex number %d out of range", i);
-         if (flag[i])
-            error(csa, "duplicate descriptor of vertex %d", i);
-         read_field(csa);
-         if (str2num(csa->field, &w) != 0)
-            error(csa, "vertex weight missing or invalid");
-         check_int(csa, w);
-         if (v_wgt >= 0)
-         {  v = G->v[i];
-            memcpy((char *)v->data + v_wgt, &w, sizeof(double));
-         }
-         flag[i] = 1;
-         end_of_line(csa);
-      }
-      xfree(flag), flag = NULL;
-      /* read edge descriptor lines */
-      for (k = 1; k <= ne; k++)
-      {  if (k > 1) read_designator(csa);
-         if (strcmp(csa->field, "e") != 0)
-            error(csa, "wrong line designator; `e' expected");
-         read_field(csa);
-         if (str2int(csa->field, &i) != 0)
-            error(csa, "first vertex number missing or invalid");
-         if (!(1 <= i && i <= nv))
-            error(csa, "first vertex number %d out of range", i);
-         read_field(csa);
-         if (str2int(csa->field, &j) != 0)
-            error(csa, "second vertex number missing or invalid");
-         if (!(1 <= j && j <= nv))
-            error(csa, "second vertex number %d out of range", j);
-         glp_add_arc(G, i, j);
-         end_of_line(csa);
-      }
-      xprintf("%d lines were read\n", csa->count);
-done: if (ret) glp_erase_graph(G, G->v_size, G->a_size);
-      if (csa->fp != NULL) xfclose(csa->fp);
-      if (flag != NULL) xfree(flag);
-      return ret;
+      return sum;
 }
 
 /***********************************************************************
-*  NAME
+*  display - display search progress
 *
-*  glp_write_ccdata - write graph in DIMACS clique/coloring format
+*  This routine displays some information about the search progress
+*  that includes:
 *
-*  SYNOPSIS
+*  search phase;
 *
-*  int glp_write_ccdata(glp_graph *G, int v_wgt, const char *fname);
+*  number of simplex iterations performed by the solver;
 *
-*  DESCRIPTION
+*  original objective value;
 *
-*  The routine glp_write_ccdata writes the specified graph in DIMACS
-*  clique/coloring format to a text file.
+*  sum of (scaled) primal infeasibilities;
 *
-*  RETURNS
+*  number of infeasibilities (phase I) or non-optimalities (phase II);
 *
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
+*  number of basic factorizations since last display output. */
 
-int glp_write_ccdata(glp_graph *G, int v_wgt, const char *fname)
-{     XFILE *fp;
-      glp_vertex *v;
-      glp_arc *e;
-      int i, count = 0, ret;
-      double w;
-      if (v_wgt >= 0 && v_wgt > G->v_size - (int)sizeof(double))
-         xerror("glp_write_ccdata: v_wgt = %d; invalid offset\n",
-            v_wgt);
-      xprintf("Writing graph to `%s'\n", fname);
-      fp = xfopen(fname, "w");
-      if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
+static void display(struct csa *csa, int spec)
+{     int nnn, k;
+      double obj, sum, *save, *save1;
+#if 1 /* 15/VII-2017 */
+      double tm_cur;
+#endif
+      /* check if the display output should be skipped */
+      if (csa->msg_lev < GLP_MSG_ON) goto skip;
+#if 1 /* 15/VII-2017 */
+      tm_cur = xtime();
+#endif
+      if (csa->out_dly > 0 &&
+#if 0 /* 15/VII-2017 */
+         1000.0 * xdifftime(xtime(), csa->tm_beg) < csa->out_dly)
+#else
+         1000.0 * xdifftime(tm_cur, csa->tm_beg) < csa->out_dly)
+#endif
+         goto skip;
+      if (csa->it_cnt == csa->it_dpy) goto skip;
+#if 0 /* 15/VII-2017 */
+      if (!spec && csa->it_cnt % csa->out_frq != 0) goto skip;
+#else
+      if (!spec &&
+         1000.0 * xdifftime(tm_cur, csa->tm_dpy) < csa->out_frq)
+         goto skip;
+#endif
+      /* compute original objective value */
+      save = csa->lp->c;
+      csa->lp->c = csa->orig_c;
+      obj = csa->dir * spx_eval_obj(csa->lp, csa->beta);
+      csa->lp->c = save;
+#if SCALE_Z
+      obj *= csa->fz;
+#endif
+      /* compute sum of (scaled) primal infeasibilities */
+#if 1 /* 01/VII-2017 */
+      save = csa->lp->l;
+      save1 = csa->lp->u;
+      csa->lp->l = csa->orig_l;
+      csa->lp->u = csa->orig_u;
+#endif
+      sum = sum_infeas(csa->lp, csa->beta);
+#if 1 /* 01/VII-2017 */
+      csa->lp->l = save;
+      csa->lp->u = save1;
+#endif
+      /* compute number of infeasibilities/non-optimalities */
+      switch (csa->phase)
+      {  case 1:
+            nnn = 0;
+            for (k = 1; k <= csa->lp->n; k++)
+               if (csa->lp->c[k] != 0.0) nnn++;
+            break;
+         case 2:
+            xassert(csa->d_st);
+            nnn = spx_chuzc_sel(csa->lp, csa->d, csa->tol_dj,
+               csa->tol_dj1, NULL);
+            break;
+         default:
+            xassert(csa != csa);
       }
-      xfprintf(fp, "c %s\n",
-         G->name == NULL ? "unknown" : G->name), count++;
-      xfprintf(fp, "p edge %d %d\n", G->nv, G->na), count++;
-      if (v_wgt >= 0)
-      {  for (i = 1; i <= G->nv; i++)
-         {  v = G->v[i];
-            memcpy(&w, (char *)v->data + v_wgt, sizeof(double));
-            if (w != 1.0)
-               xfprintf(fp, "n %d %.*g\n", i, DBL_DIG, w), count++;
-         }
-      }
-      for (i = 1; i <= G->nv; i++)
-      {  v = G->v[i];
-         for (e = v->out; e != NULL; e = e->t_next)
-            xfprintf(fp, "e %d %d\n", e->tail->i, e->head->i), count++;
-      }
-      xfprintf(fp, "c eof\n"), count++;
-      xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
+      /* display search progress */
+      xprintf("%c%6d: obj = %17.9e inf = %11.3e (%d)",
+         csa->phase == 2 ? '*' : ' ', csa->it_cnt, obj, sum, nnn);
+      if (csa->inv_cnt)
+      {  /* number of basis factorizations performed */
+         xprintf(" %d", csa->inv_cnt);
+         csa->inv_cnt = 0;
+      }
+#if 1 /* 23/VI-2017 */
+      if (csa->phase == 1 && csa->r_test == GLP_RT_FLIP)
+      {  /*xprintf("   %d,%d", csa->ns_cnt, csa->ls_cnt);*/
+         if (csa->ns_cnt + csa->ls_cnt)
+            xprintf(" %d%%",
+               (100 * csa->ls_cnt) / (csa->ns_cnt + csa->ls_cnt));
+         csa->ns_cnt = csa->ls_cnt = 0;
       }
-      xprintf("%d lines were written\n", count);
-      ret = 0;
-done: if (fp != NULL) xfclose(fp);
-      return ret;
+#endif
+      xprintf("\n");
+      csa->it_dpy = csa->it_cnt;
+#if 1 /* 15/VII-2017 */
+      csa->tm_dpy = tm_cur;
+#endif
+skip: return;
 }
 
 /***********************************************************************
-*  NAME
+*  spx_primal - driver to the primal simplex method
 *
-*  glp_read_prob - read problem data in GLPK format
+*  This routine is a driver to the two-phase primal simplex method.
 *
-*  SYNOPSIS
+*  On exit this routine returns one of the following codes:
 *
-*  int glp_read_prob(glp_prob *P, int flags, const char *fname);
+*  0  LP instance has been successfully solved.
 *
-*  The routine glp_read_prob reads problem data in GLPK LP/MIP format
-*  from a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_read_prob(glp_prob *P, int flags, const char *fname)
-{     struct csa _csa, *csa = &_csa;
-      int mip, m, n, nnz, ne, i, j, k, type, kind, ret, *ln = NULL,
-         *ia = NULL, *ja = NULL;
-      double lb, ub, temp, *ar = NULL;
-      char *rf = NULL, *cf = NULL;
-      if (P == NULL || P->magic != GLP_PROB_MAGIC)
-         xerror("glp_read_prob: P = %p; invalid problem object\n",
-            P);
-      if (flags != 0)
-         xerror("glp_read_prob: flags = %d; invalid parameter\n",
-            flags);
-      if (fname == NULL)
-         xerror("glp_read_prob: fname = %d; invalid parameter\n",
-            fname);
-      glp_erase_prob(P);
-      if (setjmp(csa->jump))
-      {  ret = 1;
-         goto done;
-      }
-      csa->fname = fname;
-      csa->fp = NULL;
-      csa->count = 0;
-      csa->c = '\n';
-      csa->field[0] = '\0';
-      csa->empty = csa->nonint = 0;
-      xprintf("Reading problem data from `%s'...\n", fname);
-      csa->fp = xfopen(fname, "r");
-      if (csa->fp == NULL)
-      {  xprintf("Unable to open `%s' - %s\n", fname, xerrmsg());
-         longjmp(csa->jump, 1);
-      }
-      /* read problem line */
-      read_designator(csa);
-      if (strcmp(csa->field, "p") != 0)
-         error(csa, "problem line missing or invalid");
-      read_field(csa);
-      if (strcmp(csa->field, "lp") == 0)
-         mip = 0;
-      else if (strcmp(csa->field, "mip") == 0)
-         mip = 1;
-      else
-         error(csa, "wrong problem designator; `lp' or `mip' expected\n"
-            );
-      read_field(csa);
-      if (strcmp(csa->field, "min") == 0)
-         glp_set_obj_dir(P, GLP_MIN);
-      else if (strcmp(csa->field, "max") == 0)
-         glp_set_obj_dir(P, GLP_MAX);
-      else
-         error(csa, "objective sense missing or invalid");
-      read_field(csa);
-      if (!(str2int(csa->field, &m) == 0 && m >= 0))
-         error(csa, "number of rows missing or invalid");
-      read_field(csa);
-      if (!(str2int(csa->field, &n) == 0 && n >= 0))
-         error(csa, "number of columns missing or invalid");
-      read_field(csa);
-      if (!(str2int(csa->field, &nnz) == 0 && nnz >= 0))
-         error(csa, "number of constraint coefficients missing or inval"
-            "id");
-      if (m > 0)
-      {  glp_add_rows(P, m);
-         for (i = 1; i <= m; i++)
-            glp_set_row_bnds(P, i, GLP_FX, 0.0, 0.0);
-      }
-      if (n > 0)
-      {  glp_add_cols(P, n);
-         for (j = 1; j <= n; j++)
-         {  if (!mip)
-               glp_set_col_bnds(P, j, GLP_LO, 0.0, 0.0);
-            else
-               glp_set_col_kind(P, j, GLP_BV);
-         }
-      }
-      end_of_line(csa);
-      /* allocate working arrays */
-      rf = xcalloc(1+m, sizeof(char));
-      memset(rf, 0, 1+m);
-      cf = xcalloc(1+n, sizeof(char));
-      memset(cf, 0, 1+n);
-      ln = xcalloc(1+nnz, sizeof(int));
-      ia = xcalloc(1+nnz, sizeof(int));
-      ja = xcalloc(1+nnz, sizeof(int));
-      ar = xcalloc(1+nnz, sizeof(double));
-      /* read descriptor lines */
-      ne = 0;
-      for (;;)
-      {  read_designator(csa);
-         if (strcmp(csa->field, "i") == 0)
-         {  /* row descriptor */
-            read_field(csa);
-            if (str2int(csa->field, &i) != 0)
-               error(csa, "row number missing or invalid");
-            if (!(1 <= i && i <= m))
-               error(csa, "row number out of range");
-            read_field(csa);
-            if (strcmp(csa->field, "f") == 0)
-               type = GLP_FR;
-            else if (strcmp(csa->field, "l") == 0)
-               type = GLP_LO;
-            else if (strcmp(csa->field, "u") == 0)
-               type = GLP_UP;
-            else if (strcmp(csa->field, "d") == 0)
-               type = GLP_DB;
-            else if (strcmp(csa->field, "s") == 0)
-               type = GLP_FX;
-            else
-               error(csa, "row type missing or invalid");
-            if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
-            {  read_field(csa);
-               if (str2num(csa->field, &lb) != 0)
-                  error(csa, "row lower bound/fixed value missing or in"
-                     "valid");
+*  GLP_EITLIM
+*     Iteration limit has been exhausted.
+*
+*  GLP_ETMLIM
+*     Time limit has been exhausted.
+*
+*  GLP_EFAIL
+*     The solver failed to solve LP instance. */
+
+static int primal_simplex(struct csa *csa)
+{     /* primal simplex method main logic routine */
+      SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *c = lp->c;
+      int *head = lp->head;
+      SPXAT *at = csa->at;
+      SPXNT *nt = csa->nt;
+      double *beta = csa->beta;
+      double *d = csa->d;
+      SPXSE *se = csa->se;
+      int *list = csa->list;
+#if 0 /* 11/VI-2017 */
+      double *tcol = csa->tcol;
+      double *trow = csa->trow;
+#endif
+#if 0 /* 09/VII-2017 */
+      double *pi = csa->work;
+      double *rho = csa->work;
+#else
+      double *pi = csa->work.vec;
+      double *rho = csa->work.vec;
+#endif
+      int msg_lev = csa->msg_lev;
+      double tol_bnd = csa->tol_bnd;
+      double tol_bnd1 = csa->tol_bnd1;
+      double tol_dj = csa->tol_dj;
+      double tol_dj1 = csa->tol_dj1;
+      int perturb = -1;
+      /* -1 = perturbation is not used, but enabled
+       *  0 = perturbation is not used and disabled
+       * +1 = perturbation is being used */
+      int j, refct, ret;
+loop: /* main loop starts here */
+      /* compute factorization of the basis matrix */
+      if (!lp->valid)
+      {  double cond;
+         ret = spx_factorize(lp);
+         csa->inv_cnt++;
+         if (ret != 0)
+         {  if (msg_lev >= GLP_MSG_ERR)
+               xprintf("Error: unable to factorize the basis matrix (%d"
+                  ")\n", ret);
+            csa->p_stat = csa->d_stat = GLP_UNDEF;
+            ret = GLP_EFAIL;
+            goto fini;
+         }
+         /* check condition of the basis matrix */
+         cond = bfd_condest(lp->bfd);
+         if (cond > 1.0 / DBL_EPSILON)
+         {  if (msg_lev >= GLP_MSG_ERR)
+               xprintf("Error: basis matrix is singular to working prec"
+                  "ision (cond = %.3g)\n", cond);
+            csa->p_stat = csa->d_stat = GLP_UNDEF;
+            ret = GLP_EFAIL;
+            goto fini;
+         }
+         if (cond > 0.001 / DBL_EPSILON)
+         {  if (msg_lev >= GLP_MSG_ERR)
+               xprintf("Warning: basis matrix is ill-conditioned (cond "
+                  "= %.3g)\n", cond);
+         }
+         /* invalidate basic solution components */
+         csa->beta_st = csa->d_st = 0;
+      }
+      /* compute values of basic variables beta = (beta[i]) */
+      if (!csa->beta_st)
+      {  spx_eval_beta(lp, beta);
+         csa->beta_st = 1; /* just computed */
+         /* determine the search phase, if not determined yet */
+         if (!csa->phase)
+         {  if (set_penalty(csa, 0.97 * tol_bnd, 0.97 * tol_bnd1))
+            {  /* current basic solution is primal infeasible */
+               /* start to minimize the sum of infeasibilities */
+               csa->phase = 1;
             }
             else
-               lb = 0.0;
-            if (type == GLP_UP || type == GLP_DB)
-            {  read_field(csa);
-               if (str2num(csa->field, &ub) != 0)
-                  error(csa, "row upper bound missing or invalid");
+            {  /* current basic solution is primal feasible */
+               /* start to minimize the original objective function */
+               csa->phase = 2;
+               memcpy(c, csa->orig_c, (1+n) * sizeof(double));
             }
-            else
-               ub = 0.0;
-            if (rf[i] & 0x01)
-               error(csa, "duplicate row descriptor");
-            glp_set_row_bnds(P, i, type, lb, ub), rf[i] |= 0x01;
-         }
-         else if (strcmp(csa->field, "j") == 0)
-         {  /* column descriptor */
-            read_field(csa);
-            if (str2int(csa->field, &j) != 0)
-               error(csa, "column number missing or invalid");
-            if (!(1 <= j && j <= n))
-               error(csa, "column number out of range");
-            if (!mip)
-               kind = GLP_CV;
-            else
-            {  read_field(csa);
-               if (strcmp(csa->field, "c") == 0)
-                  kind = GLP_CV;
-               else if (strcmp(csa->field, "i") == 0)
-                  kind = GLP_IV;
-               else if (strcmp(csa->field, "b") == 0)
-               {  kind = GLP_IV;
-                  type = GLP_DB, lb = 0.0, ub = 1.0;
-                  goto skip;
+            /* working objective coefficients have been changed, so
+             * invalidate reduced costs */
+            csa->d_st = 0;
+         }
+         /* make sure that the current basic solution remains primal
+          * feasible (or pseudo-feasible on phase I) */
+         if (perturb <= 0)
+         {  if (check_feas(csa, csa->phase, tol_bnd, tol_bnd1))
+            {  /* excessive bound violations due to round-off errors */
+#if 1 /* 01/VII-2017 */
+               if (perturb < 0)
+               {  if (msg_lev >= GLP_MSG_ALL)
+                     xprintf("Perturbing LP to avoid instability [%d].."
+                        ".\n", csa->it_cnt);
+                  perturb = 1;
+                  goto loop;
                }
-               else
-                  error(csa, "column kind missing or invalid");
+#endif
+               if (msg_lev >= GLP_MSG_ERR)
+                  xprintf("Warning: numerical instability (primal simpl"
+                     "ex, phase %s)\n", csa->phase == 1 ? "I" : "II");
+               /* restart the search */
+               lp->valid = 0;
+               csa->phase = 0;
+               goto loop;
             }
-            read_field(csa);
-            if (strcmp(csa->field, "f") == 0)
-               type = GLP_FR;
-            else if (strcmp(csa->field, "l") == 0)
-               type = GLP_LO;
-            else if (strcmp(csa->field, "u") == 0)
-               type = GLP_UP;
-            else if (strcmp(csa->field, "d") == 0)
-               type = GLP_DB;
-            else if (strcmp(csa->field, "s") == 0)
-               type = GLP_FX;
-            else
-               error(csa, "column type missing or invalid");
-            if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
-            {  read_field(csa);
-               if (str2num(csa->field, &lb) != 0)
-                  error(csa, "column lower bound/fixed value missing or"
-                     " invalid");
+            if (csa->phase == 1)
+            {  int i, cnt;
+               for (i = 1; i <= m; i++)
+                  csa->tcol.ind[i] = i;
+               cnt = adjust_penalty(csa, m, csa->tcol.ind,
+                  0.99 * tol_bnd, 0.99 * tol_bnd1);
+               if (cnt)
+               {  /*xprintf("*** cnt = %d\n", cnt);*/
+                  csa->d_st = 0;
+               }
             }
-            else
-               lb = 0.0;
-            if (type == GLP_UP || type == GLP_DB)
-            {  read_field(csa);
-               if (str2num(csa->field, &ub) != 0)
-                  error(csa, "column upper bound missing or invalid");
+         }
+         else
+         {  /* FIXME */
+            play_bounds(csa, 1);
+         }
+      }
+      /* at this point the search phase is determined */
+      xassert(csa->phase == 1 || csa->phase == 2);
+      /* compute reduced costs of non-basic variables d = (d[j]) */
+      if (!csa->d_st)
+      {  spx_eval_pi(lp, pi);
+         for (j = 1; j <= n-m; j++)
+            d[j] = spx_eval_dj(lp, pi, j);
+         csa->d_st = 1; /* just computed */
+      }
+      /* reset the reference space, if necessary */
+      if (se != NULL && !se->valid)
+         spx_reset_refsp(lp, se), refct = 1000;
+      /* at this point the basis factorization and all basic solution
+       * components are valid */
+      xassert(lp->valid && csa->beta_st && csa->d_st);
+#if CHECK_ACCURACY
+      /* check accuracy of current basic solution components (only for
+       * debugging) */
+      check_accuracy(csa);
+#endif
+      /* check if the iteration limit has been exhausted */
+      if (csa->it_cnt - csa->it_beg >= csa->it_lim)
+      {  if (perturb > 0)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         display(csa, 1);
+         if (msg_lev >= GLP_MSG_ALL)
+            xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
+         csa->p_stat = (csa->phase == 2 ? GLP_FEAS : GLP_INFEAS);
+         csa->d_stat = GLP_UNDEF; /* will be set below */
+         ret = GLP_EITLIM;
+         goto fini;
+      }
+      /* check if the time limit has been exhausted */
+      if (1000.0 * xdifftime(xtime(), csa->tm_beg) >= csa->tm_lim)
+      {  if (perturb > 0)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         display(csa, 1);
+         if (msg_lev >= GLP_MSG_ALL)
+            xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
+         csa->p_stat = (csa->phase == 2 ? GLP_FEAS : GLP_INFEAS);
+         csa->d_stat = GLP_UNDEF; /* will be set below */
+         ret = GLP_ETMLIM;
+         goto fini;
+      }
+      /* display the search progress */
+      display(csa, 0);
+      /* select eligible non-basic variables */
+      switch (csa->phase)
+      {  case 1:
+            csa->num = spx_chuzc_sel(lp, d, 1e-8, 0.0, list);
+            break;
+         case 2:
+            csa->num = spx_chuzc_sel(lp, d, tol_dj, tol_dj1, list);
+            break;
+         default:
+            xassert(csa != csa);
+      }
+      /* check for optimality */
+      if (csa->num == 0)
+      {  if (perturb > 0 && csa->phase == 2)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         /* current basis is optimal */
+         display(csa, 1);
+         switch (csa->phase)
+         {  case 1:
+               /* check for primal feasibility */
+               if (!check_feas(csa, 2, tol_bnd, tol_bnd1))
+               {  /* feasible solution found; switch to phase II */
+                  memcpy(c, csa->orig_c, (1+n) * sizeof(double));
+                  csa->phase = 2;
+                  csa->d_st = 0;
+                  goto loop;
+               }
+               /* no feasible solution exists */
+#if 1 /* 09/VII-2017 */
+               /* FIXME: remove perturbation */
+#endif
+               if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("LP HAS NO PRIMAL FEASIBLE SOLUTION\n");
+               csa->p_stat = GLP_NOFEAS;
+               csa->d_stat = GLP_UNDEF; /* will be set below */
+               ret = 0;
+               goto fini;
+            case 2:
+               /* optimal solution found */
+               if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("OPTIMAL LP SOLUTION FOUND\n");
+               csa->p_stat = csa->d_stat = GLP_FEAS;
+               ret = 0;
+               goto fini;
+            default:
+               xassert(csa != csa);
+         }
+      }
+      /* choose xN[q] and xB[p] */
+#if 0 /* 23/VI-2017 */
+#if 0 /* 17/III-2016 */
+      choose_pivot(csa);
+#else
+      if (choose_pivot(csa) < 0)
+      {  lp->valid = 0;
+         goto loop;
+      }
+#endif
+#else
+      ret = choose_pivot(csa);
+      if (ret < 0)
+      {  lp->valid = 0;
+         goto loop;
+      }
+      if (ret == 0)
+         csa->ns_cnt++;
+      else
+         csa->ls_cnt++;
+#endif
+      /* check for unboundedness */
+      if (csa->p == 0)
+      {  if (perturb > 0)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         display(csa, 1);
+         switch (csa->phase)
+         {  case 1:
+               /* this should never happen */
+               if (msg_lev >= GLP_MSG_ERR)
+                  xprintf("Error: primal simplex failed\n");
+               csa->p_stat = csa->d_stat = GLP_UNDEF;
+               ret = GLP_EFAIL;
+               goto fini;
+            case 2:
+               /* primal unboundedness detected */
+               if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("LP HAS UNBOUNDED PRIMAL SOLUTION\n");
+               csa->p_stat = GLP_FEAS;
+               csa->d_stat = GLP_NOFEAS;
+               ret = 0;
+               goto fini;
+            default:
+               xassert(csa != csa);
+         }
+      }
+#if 1 /* 01/VII-2017 */
+      /* check for stalling */
+      if (csa->p > 0)
+      {  int k;
+         xassert(1 <= csa->p && csa->p <= m);
+         k = head[csa->p]; /* x[k] = xB[p] */
+         if (lp->l[k] != lp->u[k])
+         {  if (csa->p_flag)
+            {  /* xB[p] goes to its upper bound */
+               xassert(lp->u[k] != +DBL_MAX);
+               if (fabs(beta[csa->p] - lp->u[k]) >= 1e-6)
+               {  csa->degen = 0;
+                  goto skip1;
+               }
             }
-            else
-               ub = 0.0;
-skip:       if (cf[j] & 0x01)
-               error(csa, "duplicate column descriptor");
-            glp_set_col_kind(P, j, kind);
-            glp_set_col_bnds(P, j, type, lb, ub), cf[j] |= 0x01;
-         }
-         else if (strcmp(csa->field, "a") == 0)
-         {  /* coefficient descriptor */
-            read_field(csa);
-            if (str2int(csa->field, &i) != 0)
-               error(csa, "row number missing or invalid");
-            if (!(0 <= i && i <= m))
-               error(csa, "row number out of range");
-            read_field(csa);
-            if (str2int(csa->field, &j) != 0)
-               error(csa, "column number missing or invalid");
-            if (!((i == 0 ? 0 : 1) <= j && j <= n))
-               error(csa, "column number out of range");
-            read_field(csa);
-            if (i == 0)
-            {  if (str2num(csa->field, &temp) != 0)
-                  error(csa, "objective %s missing or invalid",
-                     j == 0 ? "constant term" : "coefficient");
-               if (cf[j] & 0x10)
-                  error(csa, "duplicate objective %s",
-                     j == 0 ? "constant term" : "coefficient");
-               glp_set_obj_coef(P, j, temp), cf[j] |= 0x10;
+            else if (lp->l[k] == -DBL_MAX)
+            {  /* unusual case */
+               goto skip1;
             }
             else
-            {  if (str2num(csa->field, &temp) != 0)
-                  error(csa, "constraint coefficient missing or invalid"
-                     );
-               if (ne == nnz)
-                  error(csa, "too many constraint coefficient descripto"
-                     "rs");
-               ln[++ne] = csa->count;
-               ia[ne] = i, ja[ne] = j, ar[ne] = temp;
-            }
-         }
-         else if (strcmp(csa->field, "n") == 0)
-         {  /* symbolic name descriptor */
-            read_field(csa);
-            if (strcmp(csa->field, "p") == 0)
-            {  /* problem name */
-               read_field(csa);
-               if (P->name != NULL)
-                  error(csa, "duplicate problem name");
-               glp_set_prob_name(P, csa->field);
-            }
-            else if (strcmp(csa->field, "z") == 0)
-            {  /* objective name */
-               read_field(csa);
-               if (P->obj != NULL)
-                  error(csa, "duplicate objective name");
-               glp_set_obj_name(P, csa->field);
-            }
-            else if (strcmp(csa->field, "i") == 0)
-            {  /* row name */
-               read_field(csa);
-               if (str2int(csa->field, &i) != 0)
-                  error(csa, "row number missing or invalid");
-               if (!(1 <= i && i <= m))
-                  error(csa, "row number out of range");
-               read_field(csa);
-               if (P->row[i]->name != NULL)
-                  error(csa, "duplicate row name");
-               glp_set_row_name(P, i, csa->field);
-            }
-            else if (strcmp(csa->field, "j") == 0)
-            {  /* column name */
-               read_field(csa);
-               if (str2int(csa->field, &j) != 0)
-                  error(csa, "column number missing or invalid");
-               if (!(1 <= j && j <= n))
-                  error(csa, "column number out of range");
-               read_field(csa);
-               if (P->col[j]->name != NULL)
-                  error(csa, "duplicate column name");
-               glp_set_col_name(P, j, csa->field);
+            {  /* xB[p] goes to its lower bound */
+               xassert(lp->l[k] != -DBL_MAX);
+               if (fabs(beta[csa->p] - lp->l[k]) >= 1e-6)
+               {  csa->degen = 0;
+                  goto skip1;
+               }
             }
-            else
-               error(csa, "object designator missing or invalid");
+            /* degenerate iteration has been detected */
+            csa->degen++;
+            if (perturb < 0 && csa->degen >= 200)
+            {  if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("Perturbing LP to avoid stalling [%d]...\n",
+                     csa->it_cnt);
+               perturb = 1;
+            }
+skip1:      ;
          }
-         else if (strcmp(csa->field, "e") == 0)
-            break;
-         else
-            error(csa, "line designator missing or invalid");
-         end_of_line(csa);
       }
-      if (ne < nnz)
-         error(csa, "too few constraint coefficient descriptors");
-      xassert(ne == nnz);
-      k = glp_check_dup(m, n, ne, ia, ja);
-      xassert(0 <= k && k <= nnz);
-      if (k > 0)
-      {  csa->count = ln[k];
-         error(csa, "duplicate constraint coefficient");
-      }
-      glp_load_matrix(P, ne, ia, ja, ar);
-      /* print some statistics */
-      if (P->name != NULL)
-         xprintf("Problem: %s\n", P->name);
-      if (P->obj != NULL)
-         xprintf("Objective: %s\n", P->obj);
-      xprintf("%d row%s, %d column%s, %d non-zero%s\n",
-         m, m == 1 ? "" : "s", n, n == 1 ? "" : "s", nnz, nnz == 1 ?
-         "" : "s");
-      if (glp_get_num_int(P) > 0)
-      {  int ni = glp_get_num_int(P);
-         int nb = glp_get_num_bin(P);
-         if (ni == 1)
-         {  if (nb == 0)
-               xprintf("One variable is integer\n");
+#endif
+      /* update values of basic variables for adjacent basis */
+#if 0 /* 11/VI-2017 */
+      spx_update_beta(lp, beta, csa->p, csa->p_flag, csa->q, tcol);
+#else
+      spx_update_beta_s(lp, beta, csa->p, csa->p_flag, csa->q,
+         &csa->tcol);
+#endif
+      csa->beta_st = 2;
+      /* p < 0 means that xN[q] jumps to its opposite bound */
+      if (csa->p < 0)
+         goto skip;
+      /* xN[q] enters and xB[p] leaves the basis */
+      /* compute p-th row of inv(B) */
+      spx_eval_rho(lp, csa->p, rho);
+      /* compute p-th (pivot) row of the simplex table */
+#if 0 /* 11/VI-2017 */
+      if (at != NULL)
+         spx_eval_trow1(lp, at, rho, trow);
+      else
+         spx_nt_prod(lp, nt, trow, 1, -1.0, rho);
+#else
+      if (at != NULL)
+         spx_eval_trow1(lp, at, rho, csa->trow.vec);
+      else
+         spx_nt_prod(lp, nt, csa->trow.vec, 1, -1.0, rho);
+      fvs_gather_vec(&csa->trow, DBL_EPSILON);
+#endif
+      /* FIXME: tcol[p] and trow[q] should be close to each other */
+#if 0 /* 26/V-2017 by cmatraki */
+      xassert(trow[csa->q] != 0.0);
+#else
+      if (csa->trow.vec[csa->q] == 0.0)
+      {  if (msg_lev >= GLP_MSG_ERR)
+            xprintf("Error: trow[q] = 0.0\n");
+         csa->p_stat = csa->d_stat = GLP_UNDEF;
+         ret = GLP_EFAIL;
+         goto fini;
+      }
+#endif
+      /* update reduced costs of non-basic variables for adjacent
+       * basis */
+#if 1 /* 23/VI-2017 */
+      /* dual solution may be invalidated due to long step */
+      if (csa->d_st)
+#endif
+#if 0 /* 11/VI-2017 */
+      if (spx_update_d(lp, d, csa->p, csa->q, trow, tcol) <= 1e-9)
+#else
+      if (spx_update_d_s(lp, d, csa->p, csa->q, &csa->trow, &csa->tcol)
+         <= 1e-9)
+#endif
+      {  /* successful updating */
+         csa->d_st = 2;
+         if (csa->phase == 1)
+         {  /* adjust reduced cost of xN[q] in adjacent basis, since
+             * its penalty coefficient changes (see below) */
+            d[csa->q] -= c[head[csa->p]];
+         }
+      }
+      else
+      {  /* new reduced costs are inaccurate */
+         csa->d_st = 0;
+      }
+      if (csa->phase == 1)
+      {  /* xB[p] leaves the basis replacing xN[q], so set its penalty
+          * coefficient to zero */
+         c[head[csa->p]] = 0.0;
+      }
+      /* update steepest edge weights for adjacent basis, if used */
+      if (se != NULL)
+      {  if (refct > 0)
+#if 0 /* 11/VI-2017 */
+         {  if (spx_update_gamma(lp, se, csa->p, csa->q, trow, tcol)
+               <= 1e-3)
+#else /* FIXME: spx_update_gamma_s */
+         {  if (spx_update_gamma(lp, se, csa->p, csa->q, csa->trow.vec,
+               csa->tcol.vec) <= 1e-3)
+#endif
+            {  /* successful updating */
+               refct--;
+            }
             else
-               xprintf("One variable is binary\n");
+            {  /* new weights are inaccurate; reset reference space */
+               se->valid = 0;
+            }
          }
          else
-         {  xprintf("%d integer variables, ", ni);
-            if (nb == 0)
-               xprintf("none");
-            else if (nb == 1)
-               xprintf("one");
-            else if (nb == ni)
-               xprintf("all");
-            else
-               xprintf("%d", nb);
-            xprintf(" of which %s binary\n", nb == 1 ? "is" : "are");
+         {  /* too many updates; reset reference space */
+            se->valid = 0;
+         }
+      }
+      /* update matrix N for adjacent basis, if used */
+      if (nt != NULL)
+         spx_update_nt(lp, nt, csa->p, csa->q);
+skip: /* change current basis header to adjacent one */
+      spx_change_basis(lp, csa->p, csa->p_flag, csa->q);
+      /* and update factorization of the basis matrix */
+      if (csa->p > 0)
+         spx_update_invb(lp, csa->p, head[csa->p]);
+#if 1
+      if (perturb <= 0)
+      {  if (csa->phase == 1)
+         {  int cnt;
+            /* adjust penalty function coefficients */
+            cnt = adjust_penalty(csa, csa->tcol.nnz, csa->tcol.ind,
+               0.99 * tol_bnd, 0.99 * tol_bnd1);
+            if (cnt)
+            {  /* some coefficients were changed, so invalidate reduced
+                * costs of non-basic variables */
+               /*xprintf("... cnt = %d\n", cnt);*/
+               csa->d_st = 0;
+            }
          }
       }
-      xprintf("%d lines were read\n", csa->count);
-      /* problem data has been successfully read */
-      glp_sort_matrix(P);
-      ret = 0;
-done: if (csa->fp != NULL) xfclose(csa->fp);
-      if (rf != NULL) xfree(rf);
-      if (cf != NULL) xfree(cf);
-      if (ln != NULL) xfree(ln);
-      if (ia != NULL) xfree(ia);
-      if (ja != NULL) xfree(ja);
-      if (ar != NULL) xfree(ar);
-      if (ret) glp_erase_prob(P);
+      else
+      {  /* FIXME */
+         play_bounds(csa, 0);
+      }
+#endif
+      /* simplex iteration complete */
+      csa->it_cnt++;
+      goto loop;
+fini: /* restore original objective function */
+      memcpy(c, csa->orig_c, (1+n) * sizeof(double));
+      /* compute reduced costs of non-basic variables and determine
+       * solution dual status, if necessary */
+      if (csa->p_stat != GLP_UNDEF && csa->d_stat == GLP_UNDEF)
+      {  xassert(ret != GLP_EFAIL);
+         spx_eval_pi(lp, pi);
+         for (j = 1; j <= n-m; j++)
+            d[j] = spx_eval_dj(lp, pi, j);
+         csa->num = spx_chuzc_sel(lp, d, tol_dj, tol_dj1, NULL);
+         csa->d_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
+      }
       return ret;
 }
 
-/***********************************************************************
-*  NAME
-*
-*  glp_write_prob - write problem data in GLPK format
-*
-*  SYNOPSIS
-*
-*  int glp_write_prob(glp_prob *P, int flags, const char *fname);
-*
-*  The routine glp_write_prob writes problem data in GLPK LP/MIP format
-*  to a text file.
-*
-*  RETURNS
-*
-*  If the operation was successful, the routine returns zero. Otherwise
-*  it prints an error message and returns non-zero. */
-
-int glp_write_prob(glp_prob *P, int flags, const char *fname)
-{     XFILE *fp;
-      GLPROW *row;
-      GLPCOL *col;
-      GLPAIJ *aij;
-      int mip, i, j, count, ret;
-      if (P == NULL || P->magic != GLP_PROB_MAGIC)
-         xerror("glp_write_prob: P = %p; invalid problem object\n",
-            P);
-      if (flags != 0)
-         xerror("glp_write_prob: flags = %d; invalid parameter\n",
-            flags);
-      if (fname == NULL)
-         xerror("glp_write_prob: fname = %d; invalid parameter\n",
-            fname);
-      xprintf("Writing problem data to `%s'...\n", fname);
-      fp = xfopen(fname, "w"), count = 0;
-      if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
+int spx_primal(glp_prob *P, const glp_smcp *parm)
+{     /* driver to the primal simplex method */
+      struct csa csa_, *csa = &csa_;
+      SPXLP lp;
+      SPXAT at;
+      SPXNT nt;
+      SPXSE se;
+      int ret, *map, *daeh;
+#if SCALE_Z
+      int i, j, k;
+#endif
+      /* build working LP and its initial basis */
+      memset(csa, 0, sizeof(struct csa));
+      csa->lp = &lp;
+      spx_init_lp(csa->lp, P, parm->excl);
+      spx_alloc_lp(csa->lp);
+      map = talloc(1+P->m+P->n, int);
+      spx_build_lp(csa->lp, P, parm->excl, parm->shift, map);
+      spx_build_basis(csa->lp, P, map);
+      switch (P->dir)
+      {  case GLP_MIN:
+            csa->dir = +1;
+            break;
+         case GLP_MAX:
+            csa->dir = -1;
+            break;
+         default:
+            xassert(P != P);
       }
-      /* write problem line */
-      mip = (glp_get_num_int(P) > 0);
-      xfprintf(fp, "p %s %s %d %d %d\n", !mip ? "lp" : "mip",
-         P->dir == GLP_MIN ? "min" : P->dir == GLP_MAX ? "max" : "???",
-         P->m, P->n, P->nnz), count++;
-      if (P->name != NULL)
-         xfprintf(fp, "n p %s\n", P->name), count++;
-      if (P->obj != NULL)
-         xfprintf(fp, "n z %s\n", P->obj), count++;
-      /* write row descriptors */
-      for (i = 1; i <= P->m; i++)
-      {  row = P->row[i];
-         if (row->type == GLP_FX && row->lb == 0.0)
-            goto skip1;
-         xfprintf(fp, "i %d ", i), count++;
-         if (row->type == GLP_FR)
-            xfprintf(fp, "f\n");
-         else if (row->type == GLP_LO)
-            xfprintf(fp, "l %.*g\n", DBL_DIG, row->lb);
-         else if (row->type == GLP_UP)
-            xfprintf(fp, "u %.*g\n", DBL_DIG, row->ub);
-         else if (row->type == GLP_DB)
-            xfprintf(fp, "d %.*g %.*g\n", DBL_DIG, row->lb, DBL_DIG,
-                  row->ub);
-         else if (row->type == GLP_FX)
-            xfprintf(fp, "s %.*g\n", DBL_DIG, row->lb);
-         else
-            xassert(row != row);
-skip1:   if (row->name != NULL)
-            xfprintf(fp, "n i %d %s\n", i, row->name), count++;
-      }
-      /* write column descriptors */
-      for (j = 1; j <= P->n; j++)
-      {  col = P->col[j];
-         if (!mip && col->type == GLP_LO && col->lb == 0.0)
-            goto skip2;
-         if (mip && col->kind == GLP_IV && col->type == GLP_DB &&
-             col->lb == 0.0 && col->ub == 1.0)
-            goto skip2;
-         xfprintf(fp, "j %d ", j), count++;
-         if (mip)
-         {  if (col->kind == GLP_CV)
-               xfprintf(fp, "c ");
-            else if (col->kind == GLP_IV)
-               xfprintf(fp, "i ");
-            else
-               xassert(col != col);
+#if SCALE_Z
+      csa->fz = 0.0;
+      for (k = 1; k <= csa->lp->n; k++)
+      {  double t = fabs(csa->lp->c[k]);
+         if (csa->fz < t)
+            csa->fz = t;
+      }
+      if (csa->fz <= 1000.0)
+         csa->fz = 1.0;
+      else
+         csa->fz /= 1000.0;
+      /*xprintf("csa->fz = %g\n", csa->fz);*/
+      for (k = 0; k <= csa->lp->n; k++)
+         csa->lp->c[k] /= csa->fz;
+#endif
+      csa->orig_c = talloc(1+csa->lp->n, double);
+      memcpy(csa->orig_c, csa->lp->c, (1+csa->lp->n) * sizeof(double));
+#if 1 /*PERTURB*/
+      csa->orig_l = talloc(1+csa->lp->n, double);
+      memcpy(csa->orig_l, csa->lp->l, (1+csa->lp->n) * sizeof(double));
+      csa->orig_u = talloc(1+csa->lp->n, double);
+      memcpy(csa->orig_u, csa->lp->u, (1+csa->lp->n) * sizeof(double));
+#else
+      csa->orig_l = csa->orig_u = NULL;
+#endif
+      switch (parm->aorn)
+      {  case GLP_USE_AT:
+            /* build matrix A in row-wise format */
+            csa->at = &at;
+            csa->nt = NULL;
+            spx_alloc_at(csa->lp, csa->at);
+            spx_build_at(csa->lp, csa->at);
+            break;
+         case GLP_USE_NT:
+            /* build matrix N in row-wise format for initial basis */
+            csa->at = NULL;
+            csa->nt = &nt;
+            spx_alloc_nt(csa->lp, csa->nt);
+            spx_init_nt(csa->lp, csa->nt);
+            spx_build_nt(csa->lp, csa->nt);
+            break;
+         default:
+            xassert(parm != parm);
+      }
+      /* allocate and initialize working components */
+      csa->phase = 0;
+      csa->beta = talloc(1+csa->lp->m, double);
+      csa->beta_st = 0;
+      csa->d = talloc(1+csa->lp->n-csa->lp->m, double);
+      csa->d_st = 0;
+      switch (parm->pricing)
+      {  case GLP_PT_STD:
+            csa->se = NULL;
+            break;
+         case GLP_PT_PSE:
+            csa->se = &se;
+            spx_alloc_se(csa->lp, csa->se);
+            break;
+         default:
+            xassert(parm != parm);
+      }
+      csa->list = talloc(1+csa->lp->n-csa->lp->m, int);
+#if 0 /* 11/VI-2017 */
+      csa->tcol = talloc(1+csa->lp->m, double);
+      csa->trow = talloc(1+csa->lp->n-csa->lp->m, double);
+#else
+      fvs_alloc_vec(&csa->tcol, csa->lp->m);
+      fvs_alloc_vec(&csa->trow, csa->lp->n-csa->lp->m);
+#endif
+#if 1 /* 23/VI-2017 */
+      csa->bp = NULL;
+#endif
+#if 0 /* 09/VII-2017 */
+      csa->work = talloc(1+csa->lp->m, double);
+#else
+      fvs_alloc_vec(&csa->work, csa->lp->m);
+#endif
+      /* initialize control parameters */
+      csa->msg_lev = parm->msg_lev;
+#if 0 /* 23/VI-2017 */
+      switch (parm->r_test)
+      {  case GLP_RT_STD:
+            csa->harris = 0;
+            break;
+         case GLP_RT_HAR:
+#if 1 /* 16/III-2016 */
+         case GLP_RT_FLIP:
+            /* FIXME */
+            /* currently for primal simplex GLP_RT_FLIP is equivalent
+             * to GLP_RT_HAR */
+#endif
+            csa->harris = 1;
+            break;
+         default:
+            xassert(parm != parm);
+      }
+#else
+      switch (parm->r_test)
+      {  case GLP_RT_STD:
+         case GLP_RT_HAR:
+            break;
+         case GLP_RT_FLIP:
+            csa->bp = talloc(1+2*csa->lp->m+1, SPXBP);
+            break;
+         default:
+            xassert(parm != parm);
+      }
+      csa->r_test = parm->r_test;
+#endif
+      csa->tol_bnd = parm->tol_bnd;
+      csa->tol_bnd1 = .001 * parm->tol_bnd;
+      csa->tol_dj = parm->tol_dj;
+      csa->tol_dj1 = .001 * parm->tol_dj;
+      csa->tol_piv = parm->tol_piv;
+      csa->it_lim = parm->it_lim;
+      csa->tm_lim = parm->tm_lim;
+      csa->out_frq = parm->out_frq;
+      csa->out_dly = parm->out_dly;
+      /* initialize working parameters */
+      csa->tm_beg = xtime();
+      csa->it_beg = csa->it_cnt = P->it_cnt;
+      csa->it_dpy = -1;
+#if 1 /* 15/VII-2017 */
+      csa->tm_dpy = 0.0;
+#endif
+      csa->inv_cnt = 0;
+#if 1 /* 01/VII-2017 */
+      csa->degen = 0;
+#endif
+#if 1 /* 23/VI-2017 */
+      csa->ns_cnt = csa->ls_cnt = 0;
+#endif
+      /* try to solve working LP */
+      ret = primal_simplex(csa);
+      /* return basis factorization back to problem object */
+      P->valid = csa->lp->valid;
+      P->bfd = csa->lp->bfd;
+      /* set solution status */
+      P->pbs_stat = csa->p_stat;
+      P->dbs_stat = csa->d_stat;
+      /* if the solver failed, do not store basis header and basic
+       * solution components to problem object */
+      if (ret == GLP_EFAIL)
+         goto skip;
+      /* convert working LP basis to original LP basis and store it to
+       * problem object */
+      daeh = talloc(1+csa->lp->n, int);
+      spx_store_basis(csa->lp, P, map, daeh);
+      /* compute simplex multipliers for final basic solution found by
+       * the solver */
+#if 0 /* 09/VII-2017 */
+      spx_eval_pi(csa->lp, csa->work);
+#else
+      spx_eval_pi(csa->lp, csa->work.vec);
+#endif
+      /* convert working LP solution to original LP solution and store
+       * it into the problem object */
+#if SCALE_Z
+      for (i = 1; i <= csa->lp->m; i++)
+         csa->work.vec[i] *= csa->fz;
+      for (j = 1; j <= csa->lp->n-csa->lp->m; j++)
+         csa->d[j] *= csa->fz;
+#endif
+#if 0 /* 09/VII-2017 */
+      spx_store_sol(csa->lp, P, SHIFT, map, daeh, csa->beta, csa->work,
+         csa->d);
+#else
+      spx_store_sol(csa->lp, P, parm->shift, map, daeh, csa->beta,
+         csa->work.vec, csa->d);
+#endif
+      tfree(daeh);
+      /* save simplex iteration count */
+      P->it_cnt = csa->it_cnt;
+      /* report auxiliary/structural variable causing unboundedness */
+      P->some = 0;
+      if (csa->p_stat == GLP_FEAS && csa->d_stat == GLP_NOFEAS)
+      {  int k, kk;
+         /* xN[q] = x[k] causes unboundedness */
+         xassert(1 <= csa->q && csa->q <= csa->lp->n - csa->lp->m);
+         k = csa->lp->head[csa->lp->m + csa->q];
+         xassert(1 <= k && k <= csa->lp->n);
+         /* convert to number of original variable */
+         for (kk = 1; kk <= P->m + P->n; kk++)
+         {  if (abs(map[kk]) == k)
+            {  P->some = kk;
+               break;
+            }
          }
-         if (col->type == GLP_FR)
-            xfprintf(fp, "f\n");
-         else if (col->type == GLP_LO)
-            xfprintf(fp, "l %.*g\n", DBL_DIG, col->lb);
-         else if (col->type == GLP_UP)
-            xfprintf(fp, "u %.*g\n", DBL_DIG, col->ub);
-         else if (col->type == GLP_DB)
-            xfprintf(fp, "d %.*g %.*g\n", DBL_DIG, col->lb, DBL_DIG,
-                  col->ub);
-         else if (col->type == GLP_FX)
-            xfprintf(fp, "s %.*g\n", DBL_DIG, col->lb);
-         else
-            xassert(col != col);
-skip2:   if (col->name != NULL)
-            xfprintf(fp, "n j %d %s\n", j, col->name), count++;
-      }
-      /* write objective coefficient descriptors */
-      if (P->c0 != 0.0)
-         xfprintf(fp, "a 0 0 %.*g\n", DBL_DIG, P->c0), count++;
-      for (j = 1; j <= P->n; j++)
-      {  col = P->col[j];
-         if (col->coef != 0.0)
-            xfprintf(fp, "a 0 %d %.*g\n", j, DBL_DIG, col->coef),
-               count++;
-      }
-      /* write constraint coefficient descriptors */
-      for (i = 1; i <= P->m; i++)
-      {  row = P->row[i];
-         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
-            xfprintf(fp, "a %d %d %.*g\n", i, aij->col->j, DBL_DIG,
-               aij->val), count++;
-      }
-      /* write end line */
-      xfprintf(fp, "e o f\n"), count++;
-      xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
+         xassert(P->some != 0);
       }
-      xprintf("%d lines were written\n", count);
-      ret = 0;
-done: if (fp != NULL) xfclose(fp);
+skip: /* deallocate working objects and arrays */
+      spx_free_lp(csa->lp);
+      tfree(map);
+      tfree(csa->orig_c);
+#if 1 /*PERTURB*/
+      tfree(csa->orig_l);
+      tfree(csa->orig_u);
+#endif
+      if (csa->at != NULL)
+         spx_free_at(csa->lp, csa->at);
+      if (csa->nt != NULL)
+         spx_free_nt(csa->lp, csa->nt);
+      tfree(csa->beta);
+      tfree(csa->d);
+      if (csa->se != NULL)
+         spx_free_se(csa->lp, csa->se);
+      tfree(csa->list);
+#if 0 /* 11/VI-2017 */
+      tfree(csa->tcol);
+      tfree(csa->trow);
+#else
+      fvs_free_vec(&csa->tcol);
+      fvs_free_vec(&csa->trow);
+#endif
+#if 1 /* 23/VI-2017 */
+      if (csa->bp != NULL)
+         tfree(csa->bp);
+#endif
+#if 0 /* 09/VII-2017 */
+      tfree(csa->work);
+#else
+      fvs_free_vec(&csa->work);
+#endif
+      /* return to calling program */
       return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/env.h`

 * *Files 25% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpenv.h (GLPK environment) */
+/* env.h (GLPK environment) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,211 +15,262 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPENV_H
-#define GLPENV_H
+#ifndef ENV_H
+#define ENV_H
+
+#include "stdc.h"
 
-#include "glpstd.h"
-#include "glplib.h"
+#include "igraph_error.h" /* IGRAPH_FILE_BASENAME */
 
 typedef struct ENV ENV;
-typedef struct MEM MEM;
-typedef struct XFILE XFILE;
+typedef struct MBD MBD;
 
-#define ENV_MAGIC 0x454E5631
-/* environment block magic value */
+#ifndef SIZE_T_MAX
+#define SIZE_T_MAX (~(size_t)0)
+#endif
+/* largest value of size_t type */
 
-#define TERM_BUF_SIZE 4096
+#define TBUF_SIZE 4096
 /* terminal output buffer size, in bytes */
 
-#define IOERR_MSG_SIZE 1024
-/* i/o error message buffer size, in bytes */
+#define EBUF_SIZE 1024
+/* error message buffer size, in bytes */
 
-#define MEM_MAGIC 0x4D454D31
-/* memory block descriptor magic value */
+/* enable/disable flag: */
+#define GLP_ON  1
+#define GLP_OFF 0
 
 struct ENV
-{     /* environment block */
-      int magic;
-      /* magic value used for debugging */
+{     /* GLPK environment block */
+#if 0 /* 14/I-2007 */
       char version[7+1];
       /* version string returned by the routine glp_version */
+#endif
+      ENV *self;
+      /* pointer to this block to check its validity */
       /*--------------------------------------------------------------*/
       /* terminal output */
-      char *term_buf; /* char term_buf[TERM_BUF_SIZE]; */
+      char *term_buf; /* char term_buf[TBUF_SIZE]; */
       /* terminal output buffer */
       int term_out;
       /* flag to enable/disable terminal output */
       int (*term_hook)(void *info, const char *s);
       /* user-defined routine to intercept terminal output */
       void *term_info;
       /* transit pointer (cookie) passed to the routine term_hook */
       FILE *tee_file;
       /* output stream used to copy terminal output */
       /*--------------------------------------------------------------*/
       /* error handling */
+#if 1 /* 07/XI-2015 */
+      int err_st;
+      /* error state flag; set on entry to glp_error */
+#endif
       const char *err_file;
       /* value of the __FILE__ macro passed to glp_error */
       int err_line;
       /* value of the __LINE__ macro passed to glp_error */
       void (*err_hook)(void *info);
       /* user-defined routine to intercept abnormal termination */
       void *err_info;
       /* transit pointer (cookie) passed to the routine err_hook */
+      char *err_buf; /* char err_buf[EBUF_SIZE]; */
+      /* buffer to store error messages (used by I/O routines) */
       /*--------------------------------------------------------------*/
-      /* memory allocation */
-      glp_long mem_limit;
-      /* maximal amount of memory (in bytes) available for dynamic
-         allocation */
-      MEM *mem_ptr;
+      /* dynamic memory allocation */
+      size_t mem_limit;
+      /* maximal amount of memory, in bytes, available for dynamic
+       * allocation */
+      MBD *mem_ptr;
       /* pointer to the linked list of allocated memory blocks */
       int mem_count;
       /* total number of currently allocated memory blocks */
       int mem_cpeak;
       /* peak value of mem_count */
-      glp_long mem_total;
-      /* total amount of currently allocated memory (in bytes; is the
-         sum of the size field over all memory block descriptors) */
-      glp_long mem_tpeak;
+      size_t mem_total;
+      /* total amount of currently allocated memory, in bytes; it is
+       * the sum of the size field over all memory block descriptors */
+      size_t mem_tpeak;
       /* peak value of mem_total */
+#if 1 /* 23/XI-2015 */
       /*--------------------------------------------------------------*/
-      /* stream input/output */
-      XFILE *file_ptr;
-      /* pointer to the linked list of active stream descriptors */
-      char *ioerr_msg; /* char ioerr_msg[IOERR_MSG_SIZE]; */
-      /* input/output error message buffer */
+      /* bignum module working area */
+      void *gmp_pool; /* DMP *gmp_pool; */
+      /* working memory pool */
+      int gmp_size;
+      /* size of working array */
+      unsigned short *gmp_work; /* ushort gmp_work[gmp_size]; */
+      /* working array */
+#endif
       /*--------------------------------------------------------------*/
-      /* shared libraries support */
+      /* dynamic linking support (optional) */
       void *h_odbc;
       /* handle to ODBC shared library */
       void *h_mysql;
       /* handle to MySQL shared library */
 };
 
-struct MEM
+struct MBD
 {     /* memory block descriptor */
-      int flag;
-      /* descriptor flag */
-      int size;
-      /* size of block (in bytes, including descriptor) */
-      MEM *prev;
+      size_t size;
+      /* size of block, in bytes, including descriptor */
+      MBD *self;
+      /* pointer to this descriptor to check its validity */
+      MBD *prev;
       /* pointer to previous memory block descriptor */
-      MEM *next;
+      MBD *next;
       /* pointer to next memory block descriptor */
 };
 
-struct XFILE
-{     /* input/output stream descriptor */
-      int type;
-      /* stream handle type: */
-#define FH_FILE   0x11  /* FILE   */
-#define FH_ZLIB   0x22  /* gzFile */
-      void *fh;
-      /* pointer to stream handle */
-      XFILE *prev;
-      /* pointer to previous stream descriptor */
-      XFILE *next;
-      /* pointer to next stream descriptor */
-};
-
-#define XEOF (-1)
-
 #define get_env_ptr _glp_get_env_ptr
 ENV *get_env_ptr(void);
 /* retrieve pointer to environment block */
 
 #define tls_set_ptr _glp_tls_set_ptr
 void tls_set_ptr(void *ptr);
 /* store global pointer in TLS */
 
 #define tls_get_ptr _glp_tls_get_ptr
 void *tls_get_ptr(void);
 /* retrieve global pointer from TLS */
 
+#define xputs glp_puts
+void glp_puts(const char *s);
+/* write string on terminal */
+
 #define xprintf glp_printf
 void glp_printf(const char *fmt, ...);
-/* write formatted output to the terminal */
+/* write formatted output on terminal */
 
 #define xvprintf glp_vprintf
 void glp_vprintf(const char *fmt, va_list arg);
-/* write formatted output to the terminal */
+/* write formatted output on terminal */
+
+int glp_term_out(int flag);
+/* enable/disable terminal output */
+
+void glp_term_hook(int (*func)(void *info, const char *s), void *info);
+/* install hook to intercept terminal output */
+
+int glp_open_tee(const char *fname);
+/* start copying terminal output to text file */
+
+int glp_close_tee(void);
+/* stop copying terminal output to text file */
 
-#ifndef GLP_ERROR_DEFINED
-#define GLP_ERROR_DEFINED
-typedef void (*_glp_error)(const char *fmt, ...);
+#ifndef GLP_ERRFUNC_DEFINED
+#define GLP_ERRFUNC_DEFINED
+typedef void (*glp_errfunc)(const char *fmt, ...);
 #endif
 
-#define xerror glp_error_(__FILE__, __LINE__)
-_glp_error glp_error_(const char *file, int line);
-/* display error message and terminate execution */
+#define xerror glp_error_(IGRAPH_FILE_BASENAME, __LINE__)
+glp_errfunc glp_error_(const char *file, int line);
+/* display fatal error message and terminate execution */
 
 #define xassert(expr) \
-      ((void)((expr) || (glp_assert_(#expr, __FILE__, __LINE__), 1)))
+      ((void)((expr) || (glp_assert_(#expr, IGRAPH_FILE_BASENAME, __LINE__), 1)))
 void glp_assert_(const char *expr, const char *file, int line);
 /* check for logical condition */
 
-#define xmalloc glp_malloc
-void *glp_malloc(int size);
-/* allocate memory block */
+void glp_error_hook(void (*func)(void *info), void *info);
+/* install hook to intercept abnormal termination */
 
-#define xcalloc glp_calloc
-void *glp_calloc(int n, int size);
+#define put_err_msg _glp_put_err_msg
+void put_err_msg(const char *msg);
+/* provide error message string */
+
+#define get_err_msg _glp_get_err_msg
+const char *get_err_msg(void);
+/* obtain error message string */
+
+#define xmalloc(size) glp_alloc(1, size)
+/* allocate memory block (obsolete) */
+
+#define xcalloc(n, size) glp_alloc(n, size)
+/* allocate memory block (obsolete) */
+
+#define xalloc(n, size) glp_alloc(n, size)
+#define talloc(n, type) ((type *)glp_alloc(n, sizeof(type)))
+void *glp_alloc(int n, int size);
 /* allocate memory block */
 
-#define xfree glp_free
+#define xrealloc(ptr, n, size) glp_realloc(ptr, n, size)
+#define trealloc(ptr, n, type) ((type *)glp_realloc(ptr, n, \
+      sizeof(type)))
+void *glp_realloc(void *ptr, int n, int size);
+/* reallocate memory block */
+
+#define xfree(ptr) glp_free(ptr)
+#define tfree(ptr) glp_free(ptr)
 void glp_free(void *ptr);
 /* free memory block */
 
+void glp_mem_limit(int limit);
+/* set memory usage limit */
+
+void glp_mem_usage(int *count, int *cpeak, size_t *total,
+      size_t *tpeak);
+/* get memory usage information */
+
+typedef struct glp_file glp_file;
+/* sequential stream descriptor */
+
+#define glp_open _glp_open
+glp_file *glp_open(const char *name, const char *mode);
+/* open stream */
+
+#define glp_eof _glp_eof
+int glp_eof(glp_file *f);
+/* test end-of-file indicator */
+
+#define glp_ioerr _glp_ioerr
+int glp_ioerr(glp_file *f);
+/* test I/O error indicator */
+
+#define glp_read _glp_read
+int glp_read(glp_file *f, void *buf, int nnn);
+/* read data from stream */
+
+#define glp_getc _glp_getc
+int glp_getc(glp_file *f);
+/* read character from stream */
+
+#define glp_write _glp_write
+int glp_write(glp_file *f, const void *buf, int nnn);
+/* write data to stream */
+
+#define glp_format _glp_format
+int glp_format(glp_file *f, const char *fmt, ...);
+/* write formatted data to stream */
+
+#define glp_close _glp_close
+int glp_close(glp_file *f);
+/* close stream */
+
 #define xtime glp_time
-glp_long glp_time(void);
+double glp_time(void);
 /* determine current universal time */
 
 #define xdifftime glp_difftime
-double glp_difftime(glp_long t1, glp_long t0);
-/* compute difference between two time values, in seconds */
-
-#define lib_err_msg _glp_lib_err_msg
-void lib_err_msg(const char *msg);
-
-#define xerrmsg _glp_lib_xerrmsg
-const char *xerrmsg(void);
-
-#define xfopen _glp_lib_xfopen
-XFILE *xfopen(const char *fname, const char *mode);
-
-#define xferror _glp_lib_xferror
-int xferror(XFILE *file);
-
-#define xfeof _glp_lib_xfeof
-int xfeof(XFILE *file);
-
-#define xfgetc _glp_lib_xfgetc
-int xfgetc(XFILE *file);
-
-#define xfputc _glp_lib_xfputc
-int xfputc(int c, XFILE *file);
-
-#define xfflush _glp_lib_xfflush
-int xfflush(XFILE *fp);
-
-#define xfclose _glp_lib_xfclose
-int xfclose(XFILE *file);
-
-#define xfprintf _glp_lib_xfprintf
-int xfprintf(XFILE *file, const char *fmt, ...);
+double glp_difftime(double t1, double t0);
+/* compute difference between two time values */
 
-#define xdlopen _glp_xdlopen
+#define xdlopen _glp_dlopen
 void *xdlopen(const char *module);
+/* open dynamically linked library */
 
-#define xdlsym _glp_xdlsym
+#define xdlsym _glp_dlsym
 void *xdlsym(void *h, const char *symbol);
+/* obtain address of symbol from dynamically linked library */
 
-#define xdlclose _glp_xdlclose
+#define xdlclose _glp_dlclose
 void xdlclose(void *h);
+/* close dynamically linked library */
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/strtrim.c`

 * *Files 26% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpenv02.c (thread local storage) */
+/* strtrim.c (remove trailing spaces from string) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,57 +15,46 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpenv.h"
-#include "config.h"
-
-static IGRAPH_THREAD_LOCAL void *tls = NULL;
-/* in a re-entrant version of the package this variable must be placed
-   in the Thread Local Storage (TLS) */
+#include "misc.h"
+#include "stdc.h"
 
 /***********************************************************************
 *  NAME
 *
-*  tls_set_ptr - store global pointer in TLS
+*  strtrim - remove trailing spaces from character string
 *
 *  SYNOPSIS
 *
-*  #include "glpenv.h"
-*  void tls_set_ptr(void *ptr);
+*  #include "misc.h"
+*  char *strtrim(char *str);
 *
 *  DESCRIPTION
 *
-*  The routine tls_set_ptr stores a pointer specified by the parameter
-*  ptr in the Thread Local Storage (TLS). */
-
-void tls_set_ptr(void *ptr)
-{     tls = ptr;
-      return;
-}
-
-/***********************************************************************
-*  NAME
+*  The routine strtrim removes trailing spaces from the character
+*  string str.
 *
-*  tls_get_ptr - retrieve global pointer from TLS
+*  RETURNS
 *
-*  SYNOPSIS
+*  The routine returns a pointer to the character string.
 *
-*  #include "glpenv.h"
-*  void *tls_get_ptr(void);
+*  EXAMPLES
 *
-*  RETURNS
+*  strtrim("Errare humanum est   ") => "Errare humanum est"
 *
-*  The routine tls_get_ptr returns a pointer previously stored by the
-*  routine tls_set_ptr. If the latter has not been called yet, NULL is
-*  returned. */
+*  strtrim("      ")                => ""                             */
 
-void *tls_get_ptr(void)
-{     void *ptr;
-      ptr = tls;
-      return ptr;
+char *strtrim(char *str)
+{     char *t;
+      for (t = strrchr(str, '\0') - 1; t >= str; t--)
+      {  if (*t != ' ')
+            break;
+         *t = '\0';
+      }
+      return str;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/stdout.c`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpenv03.c (terminal output) */
+/* stdout.c (terminal output) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,79 +15,111 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wunused-label"
-#pragma clang diagnostic ignored "-Wunused-variable"
-#endif
+/*
+#undef NDEBUG
+#include <assert.h>
+*/
+#include "env.h"
+
+#include "igraph_error.h" /* IGRAPH_ASSERT */
 
-#include "glpapi.h"
+/***********************************************************************
+*  NAME
+*
+*  glp_puts - write string on terminal
+*
+*  SYNOPSIS
+*
+*  void glp_puts(const char *s);
+*
+*  The routine glp_puts writes the string s on the terminal. */
+
+void glp_puts(const char *s)
+{     ENV *env = get_env_ptr();
+      /* if terminal output is disabled, do nothing */
+      if (!env->term_out)
+         goto skip;
+      /* pass the string to the hook routine, if defined */
+      if (env->term_hook != NULL)
+      {  if (env->term_hook(env->term_info, s) != 0)
+            goto skip;
+      }
+      /* write the string on the terminal */
+      fputs(s, stdout);
+      fflush(stdout);
+      /* write the string on the tee file, if required */
+      if (env->tee_file != NULL)
+      {  fputs(s, env->tee_file);
+         fflush(env->tee_file);
+      }
+skip: return;
+}
 
 /***********************************************************************
 *  NAME
 *
-*  glp_printf - write formatted output to terminal
+*  glp_printf - write formatted output on terminal
 *
 *  SYNOPSIS
 *
 *  void glp_printf(const char *fmt, ...);
 *
 *  DESCRIPTION
 *
 *  The routine glp_printf uses the format control string fmt to format
-*  its parameters and writes the formatted output to the terminal. */
+*  its parameters and writes the formatted output on the terminal. */
 
 void glp_printf(const char *fmt, ...)
-{     va_list arg;
+{     ENV *env = get_env_ptr();
+      va_list arg;
+      /* if terminal output is disabled, do nothing */
+      if (!env->term_out)
+         goto skip;
+      /* format the output */
       va_start(arg, fmt);
-      xvprintf(fmt, arg);
+      vsprintf(env->term_buf, fmt, arg);
+      /* (do not use xassert) */
+      IGRAPH_ASSERT(strlen(env->term_buf) < TBUF_SIZE);
       va_end(arg);
-      return;
+      /* write the formatted output on the terminal */
+      glp_puts(env->term_buf);
+skip: return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  glp_vprintf - write formatted output to terminal
+*  glp_vprintf - write formatted output on terminal
 *
 *  SYNOPSIS
 *
 *  void glp_vprintf(const char *fmt, va_list arg);
 *
 *  DESCRIPTION
 *
 *  The routine glp_vprintf uses the format control string fmt to format
 *  its parameters specified by the list arg and writes the formatted
-*  output to the terminal. */
+*  output on the terminal. */
 
 void glp_vprintf(const char *fmt, va_list arg)
 {     ENV *env = get_env_ptr();
       /* if terminal output is disabled, do nothing */
-      if (!env->term_out) goto skip;
+      if (!env->term_out)
+         goto skip;
       /* format the output */
       vsprintf(env->term_buf, fmt, arg);
-      /* pass the output to the user-defined routine */
-      if (env->term_hook != NULL)
-      {  if (env->term_hook(env->term_info, env->term_buf) != 0)
-            goto skip;
-      }
-#if 0
-      /* send the output to the terminal */
-      fputs(env->term_buf, stdout);
-      fflush(stdout);
-      /* copy the output to the text file */
-      if (env->tee_file != NULL)
-      {  fputs(env->term_buf, env->tee_file);
-         fflush(env->tee_file);
-      }
-#endif
+      /* (do not use xassert) */
+      IGRAPH_ASSERT(strlen(env->term_buf) < TBUF_SIZE);
+      /* write the formatted output on the terminal */
+      glp_puts(env->term_buf);
 skip: return;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  glp_term_out - enable/disable terminal output
@@ -112,15 +141,15 @@
 *  The routine glp_term_out returns the previous value of the terminal
 *  output flag. */
 
 int glp_term_out(int flag)
 {     ENV *env = get_env_ptr();
       int old = env->term_out;
       if (!(flag == GLP_ON || flag == GLP_OFF))
-         xerror("glp_term_out: flag = %d; invalid value\n", flag);
+         xerror("glp_term_out: flag = %d; invalid parameter\n", flag);
       env->term_out = flag;
       return old;
 }
 
 /***********************************************************************
 *  NAME
 *
@@ -169,35 +198,35 @@
 /***********************************************************************
 *  NAME
 *
 *  glp_open_tee - start copying terminal output to text file
 *
 *  SYNOPSIS
 *
-*  int glp_open_tee(const char *fname);
+*  int glp_open_tee(const char *name);
 *
 *  DESCRIPTION
 *
 *  The routine glp_open_tee starts copying all the terminal output to
 *  an output text file, whose name is specified by the character string
-*  fname.
+*  name.
 *
 *  RETURNS
 *
 *  0 - operation successful
 *  1 - copying terminal output is already active
 *  2 - unable to create output file */
 
-int glp_open_tee(const char *fname)
+int glp_open_tee(const char *name)
 {     ENV *env = get_env_ptr();
       if (env->tee_file != NULL)
       {  /* copying terminal output is already active */
          return 1;
       }
-      env->tee_file = fopen(fname, "w");
+      env->tee_file = fopen(name, "w");
       if (env->tee_file == NULL)
       {  /* unable to create output file */
          return 2;
       }
       return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv04.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/clqcut.c`

 * *Files 27% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpenv04.c (error handling) */
+/* clqcut.c (clique cut generator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2008-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,116 +15,118 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
-#include "igraph_error.h"
+#include "cfg.h"
+#include "env.h"
+#include "prob.h"
 
 /***********************************************************************
 *  NAME
 *
-*  glp_error - display error message and terminate execution
+*  glp_clq_cut - generate clique cut from conflict graph
 *
 *  SYNOPSIS
 *
-*  void glp_error(const char *fmt, ...);
+*  int glp_clq_cut(glp_prob *P, glp_cfg *G, int ind[], double val[]);
 *
 *  DESCRIPTION
 *
-*  The routine glp_error (implemented as a macro) formats its
-*  parameters using the format control string fmt, writes the formatted
-*  message to the terminal, and abnormally terminates the program. */
-
-static void error(const char *fmt, ...)
-{     ENV *env = get_env_ptr();
-      va_list arg;
-      env->term_out = GLP_ON;
-      va_start(arg, fmt);
-      xvprintf(fmt, arg);
-      va_end(arg);
-      xprintf("Error detected in file %s at line %d\n", env->err_file,
-         env->err_line);
-      if (env->err_hook != NULL)
-         env->err_hook(env->err_info);
-      IGRAPH_FATAL("Unexpected return from GLPK error hook.");
-      /* no return */
-}
-
-_glp_error glp_error_(const char *file, int line)
-{     ENV *env = get_env_ptr();
-      env->err_file = file;
-      env->err_line = line;
-      return error;
-}
-
-
-/* igraph-specific hack;
- * glp_at_error() is not present in this old GLPK version
- * but we need it for proper error reporting */
-int glp_at_error(void) {
-    ENV *env = get_env_ptr();
-    return (env->err_line != 0);
-}
-
-/***********************************************************************
-*  NAME
+*  This routine attempts to generate a clique cut.
 *
-*  glp_assert - check for logical condition
+*  The cut generated by the routine is the following inequality:
 *
-*  SYNOPSIS
+*     sum a[j] * x[j] <= b,
 *
-*  #include "glplib.h"
-*  void glp_assert(int expr);
+*  which is expected to be violated at the current basic solution.
 *
-*  DESCRIPTION
-*
-*  The routine glp_assert (implemented as a macro) checks for a logical
-*  condition specified by the parameter expr. If the condition is false
-*  (i.e. the value of expr is zero), the routine writes a message to
-*  the terminal and abnormally terminates the program. */
-
-void glp_assert_(const char *expr, const char *file, int line)
-{     glp_error_(file, line)("Assertion failed: %s\n", expr);
-      /* no return */
-}
-
-/***********************************************************************
-*  NAME
-*
-*  glp_error_hook - install hook to intercept abnormal termination
-*
-*  SYNOPSIS
-*
-*  void glp_error_hook(void (*func)(void *info), void *info);
-*
-*  DESCRIPTION
-*
-*  The routine glp_error_hook installs a user-defined hook routine to
-*  intercept abnormal termination.
-*
-*  The parameter func specifies the user-defined hook routine. It is
-*  called from the routine glp_error before the latter calls the abort
-*  function to abnormally terminate the application program because of
-*  fatal error. The parameter info is a transit pointer, specified in
-*  the corresponding call to the routine glp_error_hook; it may be used
-*  to pass some information to the hook routine.
-*
-*  To uninstall the hook routine the parameters func and info should be
-*  specified as NULL. */
-
-void glp_error_hook(void (*func)(void *info), void *info)
-{     ENV *env = get_env_ptr();
-      if (func == NULL)
-      {  env->err_hook = NULL;
-         env->err_info = NULL;
+*  If the cut has been successfully generated, the routine stores its
+*  non-zero coefficients a[j] and corresponding column indices j in the
+*  array locations val[1], ..., val[len] and ind[1], ..., ind[len],
+*  where 1 <= len <= n is the number of non-zero coefficients. The
+*  right-hand side value b is stored in val[0], and ind[0] is set to 0.
+*
+*  RETURNS
+*
+*  If the cut has been successfully generated, the routine returns
+*  len, the number of non-zero coefficients in the cut, 1 <= len <= n.
+*  Otherwise, the routine returns a non-positive value. */
+
+int glp_clq_cut(glp_prob *P, glp_cfg *G, int ind[], double val[])
+{     int n = P->n;
+      int *pos = G->pos;
+      int *neg = G->neg;
+      int nv = G->nv;
+      int *ref = G->ref;
+      int j, k, v, len;
+      double rhs, sum;
+      xassert(G->n == n);
+      /* find maximum weight clique in conflict graph */
+      len = cfg_find_clique(P, G, ind, &sum);
+#ifdef GLP_DEBUG
+      xprintf("len = %d; sum = %g\n", len, sum);
+      cfg_check_clique(G, len, ind);
+#endif
+      /* check if clique inequality is violated */
+      if (sum < 1.07)
+         return 0;
+      /* expand clique to maximal one */
+      len = cfg_expand_clique(G, len, ind);
+#ifdef GLP_DEBUG
+      xprintf("maximal clique size = %d\n", len);
+      cfg_check_clique(G, len, ind);
+#endif
+      /* construct clique cut (fixed binary variables are removed, so
+         this cut is only locally valid) */
+      rhs = 1.0;
+      for (j = 1; j <= n; j++)
+         val[j] = 0.0;
+      for (k = 1; k <= len; k++)
+      {  /* v is clique vertex */
+         v = ind[k];
+         xassert(1 <= v && v <= nv);
+         /* j is number of corresponding binary variable */
+         j = ref[v];
+         xassert(1 <= j && j <= n);
+         if (pos[j] == v)
+         {  /* v corresponds to x[j] */
+            if (P->col[j]->type == GLP_FX)
+            {  /* x[j] is fixed */
+               rhs -= P->col[j]->prim;
+            }
+            else
+            {  /* x[j] is not fixed */
+               val[j] += 1.0;
+            }
+         }
+         else if (neg[j] == v)
+         {  /* v corresponds to (1 - x[j]) */
+            if (P->col[j]->type == GLP_FX)
+            {  /* x[j] is fixed */
+               rhs -= (1.0 - P->col[j]->prim);
+            }
+            else
+            {  /* x[j] is not fixed */
+               val[j] -= 1.0;
+               rhs -= 1.0;
+            }
+         }
+         else
+            xassert(v != v);
       }
-      else
-      {  env->err_hook = func;
-         env->err_info = info;
+      /* convert cut inequality to sparse format */
+      len = 0;
+      for (j = 1; j <= n; j++)
+      {  if (val[j] != 0.0)
+         {  len++;
+            ind[len] = j;
+            val[len] = val[j];
+         }
       }
-      return;
+      ind[0] = 0, val[0] = rhs;
+      return len;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv05.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/alloc.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpenv05.c (memory allocation) */
+/* alloc.c (dynamic memory allocation) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,151 +15,169 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpapi.h"
-
-/* some processors need data to be properly aligned; the macro
-   align_datasize enlarges the specified size of a data item to provide
-   a proper alignment of immediately following data */
-
-#define align_datasize(size) ((((size) + 15) / 16) * 16)
-/* 16 bytes is sufficient in both 32- and 64-bit environments
-   (8 bytes is not sufficient in 64-bit environment due to jmp_buf) */
+#include "env.h"
+
+#define ALIGN 16
+/* some processors need data to be properly aligned, so this macro
+ * defines the alignment boundary, in bytes, provided by glpk memory
+ * allocation routines; looks like 16-byte alignment boundary is
+ * sufficient for all 32- and 64-bit platforms (8-byte boundary is not
+ * sufficient for some 64-bit platforms because of jmp_buf) */
+
+#define MBD_SIZE (((sizeof(MBD) + (ALIGN - 1)) / ALIGN) * ALIGN)
+/* size of memory block descriptor, in bytes, rounded up to multiple
+ * of the alignment boundary */
 
 /***********************************************************************
-*  NAME
-*
-*  glp_malloc - allocate memory block
-*
-*  SYNOPSIS
-*
-*  void *glp_malloc(int size);
-*
-*  DESCRIPTION
-*
-*  The routine glp_malloc allocates a memory block of size bytes long.
-*
-*  Note that being allocated the memory block contains arbitrary data
-*  (not binary zeros).
-*
-*  RETURNS
+*  dma - dynamic memory allocation (basic routine)
 *
-*  The routine glp_malloc returns a pointer to the allocated block.
-*  To free this block the routine glp_free (not free!) must be used. */
+*  This routine performs dynamic memory allocation. It is similar to
+*  the standard realloc function, however, it provides every allocated
+*  memory block with a descriptor, which is used for sanity checks on
+*  reallocating/freeing previously allocated memory blocks as well as
+*  for book-keeping the memory usage statistics. */
 
-void *glp_malloc(int size)
+static void *dma(const char *func, void *ptr, size_t size)
 {     ENV *env = get_env_ptr();
-      MEM *desc;
-      int size_of_desc = align_datasize(sizeof(MEM));
-      if (size < 1 || size > INT_MAX - size_of_desc)
-         xerror("glp_malloc: size = %d; invalid parameter\n", size);
-      size += size_of_desc;
-      if (xlcmp(xlset(size),
-          xlsub(env->mem_limit, env->mem_total)) > 0)
-         xerror("glp_malloc: memory limit exceeded\n");
+      MBD *mbd;
+      if (ptr == NULL)
+      {  /* new memory block will be allocated */
+         mbd = NULL;
+      }
+      else
+      {  /* allocated memory block will be reallocated or freed */
+         /* get pointer to the block descriptor */
+         mbd = (MBD *)((char *)ptr - MBD_SIZE);
+         /* make sure that the block descriptor is valid */
+         if (mbd->self != mbd)
+            xerror("%s: ptr = %p; invalid pointer\n", func, ptr);
+         /* remove the block from the linked list */
+         mbd->self = NULL;
+         if (mbd->prev == NULL)
+            env->mem_ptr = mbd->next;
+         else
+            mbd->prev->next = mbd->next;
+         if (mbd->next == NULL)
+            ;
+         else
+            mbd->next->prev = mbd->prev;
+         /* decrease usage counts */
+         if (!(env->mem_count >= 1 && env->mem_total >= mbd->size))
+            xerror("%s: memory allocation error\n", func);
+         env->mem_count--;
+         env->mem_total -= mbd->size;
+         if (size == 0)
+         {  /* free the memory block */
+            free(mbd);
+            return NULL;
+         }
+      }
+      /* allocate/reallocate memory block */
+      if (size > SIZE_T_MAX - MBD_SIZE)
+         xerror("%s: block too large\n", func);
+      size += MBD_SIZE;
+      if (size > env->mem_limit - env->mem_total)
+         xerror("%s: memory allocation limit exceeded\n", func);
       if (env->mem_count == INT_MAX)
-         xerror("glp_malloc: too many memory blocks allocated\n");
-      desc = malloc(size);
-      if (desc == NULL)
-         xerror("glp_malloc: no memory available\n");
-      memset(desc, '?', size);
-      desc->flag = MEM_MAGIC;
-      desc->size = size;
-      desc->prev = NULL;
-      desc->next = env->mem_ptr;
-      if (desc->next != NULL) desc->next->prev = desc;
-      env->mem_ptr = desc;
+         xerror("%s: too many memory blocks allocated\n", func);
+      mbd = (mbd == NULL ? malloc(size) : realloc(mbd, size));
+      if (mbd == NULL)
+         xerror("%s: no memory available\n", func);
+      /* setup the block descriptor */
+      mbd->size = size;
+      mbd->self = mbd;
+      mbd->prev = NULL;
+      mbd->next = env->mem_ptr;
+      /* add the block to the beginning of the linked list */
+      if (mbd->next != NULL)
+         mbd->next->prev = mbd;
+      env->mem_ptr = mbd;
+      /* increase usage counts */
       env->mem_count++;
       if (env->mem_cpeak < env->mem_count)
          env->mem_cpeak = env->mem_count;
-      env->mem_total = xladd(env->mem_total, xlset(size));
-      if (xlcmp(env->mem_tpeak, env->mem_total) < 0)
+      env->mem_total += size;
+      if (env->mem_tpeak < env->mem_total)
          env->mem_tpeak = env->mem_total;
-      return (void *)((char *)desc + size_of_desc);
+      return (char *)mbd + MBD_SIZE;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  glp_calloc - allocate memory block
+*  glp_alloc - allocate memory block
 *
 *  SYNOPSIS
 *
-*  void *glp_calloc(int n, int size);
+*  void *glp_alloc(int n, int size);
 *
 *  DESCRIPTION
 *
-*  The routine glp_calloc allocates a memory block of (n*size) bytes
+*  The routine glp_alloc allocates a memory block of n * size bytes
 *  long.
 *
 *  Note that being allocated the memory block contains arbitrary data
-*  (not binary zeros).
+*  (not binary zeros!).
 *
 *  RETURNS
 *
-*  The routine glp_calloc returns a pointer to the allocated block.
+*  The routine glp_alloc returns a pointer to the block allocated.
 *  To free this block the routine glp_free (not free!) must be used. */
 
-void *glp_calloc(int n, int size)
+void *glp_alloc(int n, int size)
 {     if (n < 1)
-         xerror("glp_calloc: n = %d; invalid parameter\n", n);
+         xerror("glp_alloc: n = %d; invalid parameter\n", n);
+      if (size < 1)
+         xerror("glp_alloc: size = %d; invalid parameter\n", size);
+      if ((size_t)n > SIZE_T_MAX / (size_t)size)
+         xerror("glp_alloc: n = %d, size = %d; block too large\n",
+            n, size);
+      return dma("glp_alloc", NULL, (size_t)n * (size_t)size);
+}
+
+/**********************************************************************/
+
+void *glp_realloc(void *ptr, int n, int size)
+{     /* reallocate memory block */
+      if (ptr == NULL)
+         xerror("glp_realloc: ptr = %p; invalid pointer\n", ptr);
+      if (n < 1)
+         xerror("glp_realloc: n = %d; invalid parameter\n", n);
       if (size < 1)
-         xerror("glp_calloc: size = %d; invalid parameter\n", size);
-      if (n > INT_MAX / size)
-         xerror("glp_calloc: n = %d; size = %d; array too big\n", n,
-            size);
-      return xmalloc(n * size);
+         xerror("glp_realloc: size = %d; invalid parameter\n", size);
+      if ((size_t)n > SIZE_T_MAX / (size_t)size)
+         xerror("glp_realloc: n = %d, size = %d; block too large\n",
+            n, size);
+      return dma("glp_realloc", ptr, (size_t)n * (size_t)size);
 }
 
 /***********************************************************************
 *  NAME
 *
-*  glp_free - free memory block
+*  glp_free - free (deallocate) memory block
 *
 *  SYNOPSIS
 *
 *  void glp_free(void *ptr);
 *
 *  DESCRIPTION
 *
-*  The routine glp_free frees a memory block pointed to by ptr, which
-*  was previuosly allocated by the routine glp_malloc or glp_calloc. */
+*  The routine glp_free frees (deallocates) a memory block pointed to
+*  by ptr, which was previuosly allocated by the routine glp_alloc or
+*  reallocated by the routine glp_realloc. */
 
 void glp_free(void *ptr)
-{     ENV *env = get_env_ptr();
-      MEM *desc;
-      int size_of_desc = align_datasize(sizeof(MEM));
-      if (ptr == NULL)
-         xerror("glp_free: ptr = %p; null pointer\n", ptr);
-      desc = (void *)((char *)ptr - size_of_desc);
-      if (desc->flag != MEM_MAGIC)
+{     if (ptr == NULL)
          xerror("glp_free: ptr = %p; invalid pointer\n", ptr);
-      if (env->mem_count == 0 ||
-          xlcmp(env->mem_total, xlset(desc->size)) < 0)
-         xerror("glp_free: memory allocation error\n");
-      if (desc->prev == NULL)
-         env->mem_ptr = desc->next;
-      else
-         desc->prev->next = desc->next;
-      if (desc->next == NULL)
-         ;
-      else
-         desc->next->prev = desc->prev;
-      env->mem_count--;
-      env->mem_total = xlsub(env->mem_total, xlset(desc->size));
-      memset(desc, '?', size_of_desc);
-      free(desc);
+      dma("glp_free", ptr, 0);
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  glp_mem_limit - set memory usage limit
@@ -174,56 +189,62 @@
 *  DESCRIPTION
 *
 *  The routine glp_mem_limit limits the amount of memory available for
 *  dynamic allocation (in GLPK routines) to limit megabytes. */
 
 void glp_mem_limit(int limit)
 {     ENV *env = get_env_ptr();
-      if (limit < 0)
+      if (limit < 1)
          xerror("glp_mem_limit: limit = %d; invalid parameter\n",
             limit);
-      env->mem_limit = xlmul(xlset(limit), xlset(1 << 20));
+      if ((size_t)limit <= (SIZE_T_MAX >> 20))
+         env->mem_limit = (size_t)limit << 20;
+      else
+         env->mem_limit = SIZE_T_MAX;
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  glp_mem_usage - get memory usage information
 *
 *  SYNOPSIS
 *
-*  void glp_mem_usage(int *count, int *cpeak, glp_long *total,
-*     glp_long *tpeak);
+*  void glp_mem_usage(int *count, int *cpeak, size_t *total,
+*     size_t *tpeak);
 *
 *  DESCRIPTION
 *
 *  The routine glp_mem_usage reports some information about utilization
 *  of the memory by GLPK routines. Information is stored to locations
 *  specified by corresponding parameters (see below). Any parameter can
-*  be specified as NULL, in which case corresponding information is not
-*  stored.
+*  be specified as NULL, in which case its value is not stored.
 *
 *  *count is the number of the memory blocks currently allocated by the
-*  routines xmalloc and xcalloc (one call to xmalloc or xcalloc results
-*  in allocating one memory block).
+*  routines glp_malloc and glp_calloc (one call to glp_malloc or
+*  glp_calloc results in allocating one memory block).
 *
 *  *cpeak is the peak value of *count reached since the initialization
 *  of the GLPK library environment.
 *
 *  *total is the total amount, in bytes, of the memory blocks currently
-*  allocated by the routines xmalloc and xcalloc.
+*  allocated by the routines glp_malloc and glp_calloc.
 *
 *  *tpeak is the peak value of *total reached since the initialization
 *  of the GLPK library envirionment. */
 
-void glp_mem_usage(int *count, int *cpeak, glp_long *total,
-      glp_long *tpeak)
+void glp_mem_usage(int *count, int *cpeak, size_t *total,
+      size_t *tpeak)
 {     ENV *env = get_env_ptr();
-      if (count != NULL) *count = env->mem_count;
-      if (cpeak != NULL) *cpeak = env->mem_cpeak;
-      if (total != NULL) *total = env->mem_total;
-      if (tpeak != NULL) *tpeak = env->mem_tpeak;
+      if (count != NULL)
+         *count = env->mem_count;
+      if (cpeak != NULL)
+         *cpeak = env->mem_cpeak;
+      if (total != NULL)
+         *total = env->mem_total;
+      if (tpeak != NULL)
+         *tpeak = env->mem_tpeak;
       return;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpenv08.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/env/dlsup.c`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpenv08.c (shared library support) */
+/* dlsup.c (dynamic linking support) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2008-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -22,135 +19,147 @@
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "glpenv.h"
+#include "env.h"
 
 /* GNU version ********************************************************/
 
 #if defined(HAVE_LTDL)
 
 #include <ltdl.h>
 
 void *xdlopen(const char *module)
-{     void *h = NULL;
+{     /* open dynamically linked library */
+      void *h = NULL;
       if (lt_dlinit() != 0)
-      {  lib_err_msg(lt_dlerror());
+      {  put_err_msg(lt_dlerror());
          goto done;
       }
       h = lt_dlopen(module);
       if (h == NULL)
-      {  lib_err_msg(lt_dlerror());
+      {  put_err_msg(lt_dlerror());
          if (lt_dlexit() != 0)
             xerror("xdlopen: %s\n", lt_dlerror());
       }
 done: return h;
 }
 
 void *xdlsym(void *h, const char *symbol)
-{     void *ptr;
+{     /* obtain address of symbol from dynamically linked library */
+      void *ptr;
       xassert(h != NULL);
       ptr = lt_dlsym(h, symbol);
       if (ptr == NULL)
          xerror("xdlsym: %s: %s\n", symbol, lt_dlerror());
       return ptr;
 }
 
 void xdlclose(void *h)
-{     xassert(h != NULL);
+{     /* close dynamically linked library */
+      xassert(h != NULL);
       if (lt_dlclose(h) != 0)
          xerror("xdlclose: %s\n", lt_dlerror());
       if (lt_dlexit() != 0)
          xerror("xdlclose: %s\n", lt_dlerror());
       return;
 }
 
 /* POSIX version ******************************************************/
 
 #elif defined(HAVE_DLFCN)
 
 #include <dlfcn.h>
 
 void *xdlopen(const char *module)
-{     void *h;
+{     /* open dynamically linked library */
+      void *h;
       h = dlopen(module, RTLD_NOW);
       if (h == NULL)
-         lib_err_msg(dlerror());
+         put_err_msg(dlerror());
       return h;
 }
 
 void *xdlsym(void *h, const char *symbol)
-{     void *ptr;
+{     /* obtain address of symbol from dynamically linked library */
+      void *ptr;
       xassert(h != NULL);
       ptr = dlsym(h, symbol);
       if (ptr == NULL)
          xerror("xdlsym: %s: %s\n", symbol, dlerror());
       return ptr;
 }
 
 void xdlclose(void *h)
-{     xassert(h != NULL);
+{     /* close dynamically linked library */
+      xassert(h != NULL);
       if (dlclose(h) != 0)
          xerror("xdlclose: %s\n", dlerror());
       return;
 }
 
-/* Windows version ****************************************************/
+/* MS Windows version *************************************************/
 
 #elif defined(__WOE__)
 
 #include <windows.h>
 
 void *xdlopen(const char *module)
-{     void *h;
+{     /* open dynamically linked library */
+      void *h;
       h = LoadLibrary(module);
       if (h == NULL)
       {  char msg[20];
          sprintf(msg, "Error %d", GetLastError());
-         lib_err_msg(msg);
+         put_err_msg(msg);
       }
       return h;
 }
 
 void *xdlsym(void *h, const char *symbol)
-{     void *ptr;
+{     /* obtain address of symbol from dynamically linked library */
+      void *ptr;
       xassert(h != NULL);
       ptr = GetProcAddress(h, symbol);
       if (ptr == NULL)
          xerror("xdlsym: %s: Error %d\n", symbol, GetLastError());
       return ptr;
 }
 
 void xdlclose(void *h)
-{     xassert(h != NULL);
+{     /* close dynamically linked library */
+      xassert(h != NULL);
       if (!FreeLibrary(h))
          xerror("xdlclose: Error %d\n", GetLastError());
       return;
 }
 
 /* NULL version *******************************************************/
 
 #else
 
 void *xdlopen(const char *module)
-{     xassert(module == module);
-      lib_err_msg("Shared libraries not supported");
+{     /* open dynamically linked library */
+      xassert(module == module);
+      put_err_msg("Shared libraries not supported");
       return NULL;
 }
 
 void *xdlsym(void *h, const char *symbol)
-{     xassert(h != h);
+{     /* obtain address of symbol from dynamically linked library */
+      xassert(h != h);
       xassert(symbol != symbol);
       return NULL;
 }
 
 void xdlclose(void *h)
-{     xassert(h != h);
+{     /* close dynamically linked library */
+      xassert(h != h);
       return;
 }
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpfhv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios02.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpfhv.c (LP basis factorization, FHV eta file version) */
+/* glpios02.c (preprocess current subproblem) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,761 +15,809 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpfhv.h"
-#include "glpenv.h"
-#define xfault xerror
-
-/* CAUTION: DO NOT CHANGE THE LIMIT BELOW */
-
-#define M_MAX 100000000 /* = 100*10^6 */
-/* maximal order of the basis matrix */
+#include "env.h"
+#include "ios.h"
 
 /***********************************************************************
-*  NAME
+*  prepare_row_info - prepare row info to determine implied bounds
 *
-*  fhv_create_it - create LP basis factorization
+*  Given a row (linear form)
 *
-*  SYNOPSIS
+*      n
+*     sum a[j] * x[j]                                                (1)
+*     j=1
 *
-*  #include "glpfhv.h"
-*  FHV *fhv_create_it(void);
+*  and bounds of columns (variables)
 *
-*  DESCRIPTION
+*     l[j] <= x[j] <= u[j]                                           (2)
 *
-*  The routine fhv_create_it creates a program object, which represents
-*  a factorization of LP basis.
+*  this routine computes f_min, j_min, f_max, j_max needed to determine
+*  implied bounds.
 *
-*  RETURNS
+*  ALGORITHM
 *
-*  The routine fhv_create_it returns a pointer to the object created. */
-
-FHV *fhv_create_it(void)
-{     FHV *fhv;
-      fhv = xmalloc(sizeof(FHV));
-      fhv->m_max = fhv->m = 0;
-      fhv->valid = 0;
-      fhv->luf = luf_create_it();
-      fhv->hh_max = 50;
-      fhv->hh_nfs = 0;
-      fhv->hh_ind = fhv->hh_ptr = fhv->hh_len = NULL;
-      fhv->p0_row = fhv->p0_col = NULL;
-      fhv->cc_ind = NULL;
-      fhv->cc_val = NULL;
-      fhv->upd_tol = 1e-6;
-      fhv->nnz_h = 0;
-      return fhv;
+*  Let J+ = {j : a[j] > 0} and J- = {j : a[j] < 0}.
+*
+*  Parameters f_min and j_min are computed as follows:
+*
+*  1) if there is no x[k] such that k in J+ and l[k] = -inf or k in J-
+*     and u[k] = +inf, then
+*
+*     f_min :=   sum   a[j] * l[j] +   sum   a[j] * u[j]
+*              j in J+               j in J-
+*                                                                    (3)
+*     j_min := 0
+*
+*  2) if there is exactly one x[k] such that k in J+ and l[k] = -inf
+*     or k in J- and u[k] = +inf, then
+*
+*     f_min :=   sum       a[j] * l[j] +   sum       a[j] * u[j]
+*              j in J+\{k}               j in J-\{k}
+*                                                                    (4)
+*     j_min := k
+*
+*  3) if there are two or more x[k] such that k in J+ and l[k] = -inf
+*     or k in J- and u[k] = +inf, then
+*
+*     f_min := -inf
+*                                                                    (5)
+*     j_min := 0
+*
+*  Parameters f_max and j_max are computed in a similar way as follows:
+*
+*  1) if there is no x[k] such that k in J+ and u[k] = +inf or k in J-
+*     and l[k] = -inf, then
+*
+*     f_max :=   sum   a[j] * u[j] +   sum   a[j] * l[j]
+*              j in J+               j in J-
+*                                                                    (6)
+*     j_max := 0
+*
+*  2) if there is exactly one x[k] such that k in J+ and u[k] = +inf
+*     or k in J- and l[k] = -inf, then
+*
+*     f_max :=   sum       a[j] * u[j] +   sum       a[j] * l[j]
+*              j in J+\{k}               j in J-\{k}
+*                                                                    (7)
+*     j_max := k
+*
+*  3) if there are two or more x[k] such that k in J+ and u[k] = +inf
+*     or k in J- and l[k] = -inf, then
+*
+*     f_max := +inf
+*                                                                    (8)
+*     j_max := 0                                                      */
+
+struct f_info
+{     int j_min, j_max;
+      double f_min, f_max;
+};
+
+static void prepare_row_info(int n, const double a[], const double l[],
+      const double u[], struct f_info *f)
+{     int j, j_min, j_max;
+      double f_min, f_max;
+      xassert(n >= 0);
+      /* determine f_min and j_min */
+      f_min = 0.0, j_min = 0;
+      for (j = 1; j <= n; j++)
+      {  if (a[j] > 0.0)
+         {  if (l[j] == -DBL_MAX)
+            {  if (j_min == 0)
+                  j_min = j;
+               else
+               {  f_min = -DBL_MAX, j_min = 0;
+                  break;
+               }
+            }
+            else
+               f_min += a[j] * l[j];
+         }
+         else if (a[j] < 0.0)
+         {  if (u[j] == +DBL_MAX)
+            {  if (j_min == 0)
+                  j_min = j;
+               else
+               {  f_min = -DBL_MAX, j_min = 0;
+                  break;
+               }
+            }
+            else
+               f_min += a[j] * u[j];
+         }
+         else
+            xassert(a != a);
+      }
+      f->f_min = f_min, f->j_min = j_min;
+      /* determine f_max and j_max */
+      f_max = 0.0, j_max = 0;
+      for (j = 1; j <= n; j++)
+      {  if (a[j] > 0.0)
+         {  if (u[j] == +DBL_MAX)
+            {  if (j_max == 0)
+                  j_max = j;
+               else
+               {  f_max = +DBL_MAX, j_max = 0;
+                  break;
+               }
+            }
+            else
+               f_max += a[j] * u[j];
+         }
+         else if (a[j] < 0.0)
+         {  if (l[j] == -DBL_MAX)
+            {  if (j_max == 0)
+                  j_max = j;
+               else
+               {  f_max = +DBL_MAX, j_max = 0;
+                  break;
+               }
+            }
+            else
+               f_max += a[j] * l[j];
+         }
+         else
+            xassert(a != a);
+      }
+      f->f_max = f_max, f->j_max = j_max;
+      return;
 }
 
 /***********************************************************************
-*  NAME
+*  row_implied_bounds - determine row implied bounds
 *
-*  fhv_factorize - compute LP basis factorization
+*  Given a row (linear form)
 *
-*  SYNOPSIS
+*      n
+*     sum a[j] * x[j]
+*     j=1
 *
-*  #include "glpfhv.h"
-*  int fhv_factorize(FHV *fhv, int m, int (*col)(void *info, int j,
-*     int ind[], double val[]), void *info);
+*  and bounds of columns (variables)
 *
-*  DESCRIPTION
+*     l[j] <= x[j] <= u[j]
 *
-*  The routine fhv_factorize computes the factorization of the basis
-*  matrix B specified by the routine col.
+*  this routine determines implied bounds of the row.
 *
-*  The parameter fhv specified the basis factorization data structure
-*  created by the routine fhv_create_it.
+*  ALGORITHM
 *
-*  The parameter m specifies the order of B, m > 0.
+*  Let J+ = {j : a[j] > 0} and J- = {j : a[j] < 0}.
 *
-*  The formal routine col specifies the matrix B to be factorized. To
-*  obtain j-th column of A the routine fhv_factorize calls the routine
-*  col with the parameter j (1 <= j <= n). In response the routine col
-*  should store row indices and numerical values of non-zero elements
-*  of j-th column of B to locations ind[1,...,len] and val[1,...,len],
-*  respectively, where len is the number of non-zeros in j-th column
-*  returned on exit. Neither zero nor duplicate elements are allowed.
+*  The implied lower bound of the row is computed as follows:
 *
-*  The parameter info is a transit pointer passed to the routine col.
+*     L' :=   sum   a[j] * l[j] +   sum   a[j] * u[j]                (9)
+*           j in J+               j in J-
 *
-*  RETURNS
+*  and as it follows from (3), (4), and (5):
 *
-*  0  The factorization has been successfully computed.
+*     L' := if j_min = 0 then f_min else -inf                       (10)
 *
-*  FHV_ESING
-*     The specified matrix is singular within the working precision.
+*  The implied upper bound of the row is computed as follows:
 *
-*  FHV_ECOND
-*     The specified matrix is ill-conditioned.
+*     U' :=   sum   a[j] * u[j] +   sum   a[j] * l[j]               (11)
+*           j in J+               j in J-
 *
-*  For more details see comments to the routine luf_factorize.
+*  and as it follows from (6), (7), and (8):
 *
-*  ALGORITHM
+*     U' := if j_max = 0 then f_max else +inf                       (12)
 *
-*  The routine fhv_factorize calls the routine luf_factorize (see the
-*  module GLPLUF), which actually computes LU-factorization of the basis
-*  matrix B in the form
-*
-*     [B] = (F, V, P, Q),
-*
-*  where F and V are such matrices that
-*
-*     B = F * V,
-*
-*  and P and Q are such permutation matrices that the matrix
-*
-*     L = P * F * inv(P)
-*
-*  is lower triangular with unity diagonal, and the matrix
-*
-*     U = P * V * Q
-*
-*  is upper triangular.
-*
-*  In order to build the complete representation of the factorization
-*  (see formula (1) in the file glpfhv.h) the routine fhv_factorize just
-*  additionally sets H = I and P0 = P. */
-
-int fhv_factorize(FHV *fhv, int m, int (*col)(void *info, int j,
-      int ind[], double val[]), void *info)
-{     int ret;
-      if (m < 1)
-         xfault("fhv_factorize: m = %d; invalid parameter\n", m);
-      if (m > M_MAX)
-         xfault("fhv_factorize: m = %d; matrix too big\n", m);
-      fhv->m = m;
-      /* invalidate the factorization */
-      fhv->valid = 0;
-      /* allocate/reallocate arrays, if necessary */
-      if (fhv->hh_ind == NULL)
-         fhv->hh_ind = xcalloc(1+fhv->hh_max, sizeof(int));
-      if (fhv->hh_ptr == NULL)
-         fhv->hh_ptr = xcalloc(1+fhv->hh_max, sizeof(int));
-      if (fhv->hh_len == NULL)
-         fhv->hh_len = xcalloc(1+fhv->hh_max, sizeof(int));
-      if (fhv->m_max < m)
-      {  if (fhv->p0_row != NULL) xfree(fhv->p0_row);
-         if (fhv->p0_col != NULL) xfree(fhv->p0_col);
-         if (fhv->cc_ind != NULL) xfree(fhv->cc_ind);
-         if (fhv->cc_val != NULL) xfree(fhv->cc_val);
-         fhv->m_max = m + 100;
-         fhv->p0_row = xcalloc(1+fhv->m_max, sizeof(int));
-         fhv->p0_col = xcalloc(1+fhv->m_max, sizeof(int));
-         fhv->cc_ind = xcalloc(1+fhv->m_max, sizeof(int));
-         fhv->cc_val = xcalloc(1+fhv->m_max, sizeof(double));
-      }
-      /* try to factorize the basis matrix */
-      switch (luf_factorize(fhv->luf, m, col, info))
-      {  case 0:
-            break;
-         case LUF_ESING:
-            ret = FHV_ESING;
-            goto done;
-         case LUF_ECOND:
-            ret = FHV_ECOND;
-            goto done;
-         default:
-            xassert(fhv != fhv);
-      }
-      /* the basis matrix has been successfully factorized */
-      fhv->valid = 1;
-      /* H := I */
-      fhv->hh_nfs = 0;
-      /* P0 := P */
-      memcpy(&fhv->p0_row[1], &fhv->luf->pp_row[1], sizeof(int) * m);
-      memcpy(&fhv->p0_col[1], &fhv->luf->pp_col[1], sizeof(int) * m);
-      /* currently H has no factors */
-      fhv->nnz_h = 0;
-      ret = 0;
-done: /* return to the calling program */
-      return ret;
+*  The implied bounds are stored in locations LL and UU. */
+
+static void row_implied_bounds(const struct f_info *f, double *LL,
+      double *UU)
+{     *LL = (f->j_min == 0 ? f->f_min : -DBL_MAX);
+      *UU = (f->j_max == 0 ? f->f_max : +DBL_MAX);
+      return;
 }
 
 /***********************************************************************
-*  NAME
+*  col_implied_bounds - determine column implied bounds
 *
-*  fhv_h_solve - solve system H*x = b or H'*x = b
+*  Given a row (constraint)
 *
-*  SYNOPSIS
+*           n
+*     L <= sum a[j] * x[j] <= U                                     (13)
+*          j=1
 *
-*  #include "glpfhv.h"
-*  void fhv_h_solve(FHV *fhv, int tr, double x[]);
+*  and bounds of columns (variables)
 *
-*  DESCRIPTION
+*     l[j] <= x[j] <= u[j]
+*
+*  this routine determines implied bounds of variable x[k].
+*
+*  It is assumed that if L != -inf, the lower bound of the row can be
+*  active, and if U != +inf, the upper bound of the row can be active.
+*
+*  ALGORITHM
 *
-*  The routine fhv_h_solve solves either the system H*x = b (if the
-*  flag tr is zero) or the system H'*x = b (if the flag tr is non-zero),
-*  where the matrix H is a component of the factorization specified by
-*  the parameter fhv, H' is a matrix transposed to H.
-*
-*  On entry the array x should contain elements of the right-hand side
-*  vector b in locations x[1], ..., x[m], where m is the order of the
-*  matrix H. On exit this array will contain elements of the solution
-*  vector x in the same locations. */
-
-void fhv_h_solve(FHV *fhv, int tr, double x[])
-{     int nfs = fhv->hh_nfs;
-      int *hh_ind = fhv->hh_ind;
-      int *hh_ptr = fhv->hh_ptr;
-      int *hh_len = fhv->hh_len;
-      int *sv_ind = fhv->luf->sv_ind;
-      double *sv_val = fhv->luf->sv_val;
-      int i, k, beg, end, ptr;
-      double temp;
-      if (!fhv->valid)
-         xfault("fhv_h_solve: the factorization is not valid\n");
-      if (!tr)
-      {  /* solve the system H*x = b */
-         for (k = 1; k <= nfs; k++)
-         {  i = hh_ind[k];
-            temp = x[i];
-            beg = hh_ptr[k];
-            end = beg + hh_len[k] - 1;
-            for (ptr = beg; ptr <= end; ptr++)
-               temp -= sv_val[ptr] * x[sv_ind[ptr]];
-            x[i] = temp;
+*  From (13) it follows that
+*
+*     L <= sum a[j] * x[j] + a[k] * x[k] <= U
+*          j!=k
+*  or
+*
+*     L - sum a[j] * x[j] <= a[k] * x[k] <= U - sum a[j] * x[j]
+*         j!=k                                  j!=k
+*
+*  Thus, if the row lower bound L can be active, implied lower bound of
+*  term a[k] * x[k] can be determined as follows:
+*
+*     ilb(a[k] * x[k]) = min(L - sum a[j] * x[j]) =
+*                                j!=k
+*                                                                   (14)
+*                      = L - max sum a[j] * x[j]
+*                            j!=k
+*
+*  where, as it follows from (6), (7), and (8)
+*
+*                           / f_max - a[k] * u[k], j_max = 0, a[k] > 0
+*                           |
+*                           | f_max - a[k] * l[k], j_max = 0, a[k] < 0
+*     max sum a[j] * x[j] = {
+*         j!=k              | f_max,               j_max = k
+*                           |
+*                           \ +inf,                j_max != 0
+*
+*  and if the upper bound U can be active, implied upper bound of term
+*  a[k] * x[k] can be determined as follows:
+*
+*     iub(a[k] * x[k]) = max(U - sum a[j] * x[j]) =
+*                                j!=k
+*                                                                   (15)
+*                      = U - min sum a[j] * x[j]
+*                            j!=k
+*
+*  where, as it follows from (3), (4), and (5)
+*
+*                           / f_min - a[k] * l[k], j_min = 0, a[k] > 0
+*                           |
+*                           | f_min - a[k] * u[k], j_min = 0, a[k] < 0
+*     min sum a[j] * x[j] = {
+*         j!=k              | f_min,               j_min = k
+*                           |
+*                           \ -inf,                j_min != 0
+*
+*  Since
+*
+*     ilb(a[k] * x[k]) <= a[k] * x[k] <= iub(a[k] * x[k])
+*
+*  implied lower and upper bounds of x[k] are determined as follows:
+*
+*     l'[k] := if a[k] > 0 then ilb / a[k] else ulb / a[k]          (16)
+*
+*     u'[k] := if a[k] > 0 then ulb / a[k] else ilb / a[k]          (17)
+*
+*  The implied bounds are stored in locations ll and uu. */
+
+static void col_implied_bounds(const struct f_info *f, int n,
+      const double a[], double L, double U, const double l[],
+      const double u[], int k, double *ll, double *uu)
+{     double ilb, iub;
+      xassert(n >= 0);
+      xassert(1 <= k && k <= n);
+      /* determine implied lower bound of term a[k] * x[k] (14) */
+      if (L == -DBL_MAX || f->f_max == +DBL_MAX)
+         ilb = -DBL_MAX;
+      else if (f->j_max == 0)
+      {  if (a[k] > 0.0)
+         {  xassert(u[k] != +DBL_MAX);
+            ilb = L - (f->f_max - a[k] * u[k]);
+         }
+         else if (a[k] < 0.0)
+         {  xassert(l[k] != -DBL_MAX);
+            ilb = L - (f->f_max - a[k] * l[k]);
          }
+         else
+            xassert(a != a);
       }
+      else if (f->j_max == k)
+         ilb = L - f->f_max;
       else
-      {  /* solve the system H'*x = b */
-         for (k = nfs; k >= 1; k--)
-         {  i = hh_ind[k];
-            temp = x[i];
-            if (temp == 0.0) continue;
-            beg = hh_ptr[k];
-            end = beg + hh_len[k] - 1;
-            for (ptr = beg; ptr <= end; ptr++)
-               x[sv_ind[ptr]] -= sv_val[ptr] * temp;
+         ilb = -DBL_MAX;
+      /* determine implied upper bound of term a[k] * x[k] (15) */
+      if (U == +DBL_MAX || f->f_min == -DBL_MAX)
+         iub = +DBL_MAX;
+      else if (f->j_min == 0)
+      {  if (a[k] > 0.0)
+         {  xassert(l[k] != -DBL_MAX);
+            iub = U - (f->f_min - a[k] * l[k]);
+         }
+         else if (a[k] < 0.0)
+         {  xassert(u[k] != +DBL_MAX);
+            iub = U - (f->f_min - a[k] * u[k]);
          }
+         else
+            xassert(a != a);
       }
+      else if (f->j_min == k)
+         iub = U - f->f_min;
+      else
+         iub = +DBL_MAX;
+      /* determine implied bounds of x[k] (16) and (17) */
+#if 1
+      /* do not use a[k] if it has small magnitude to prevent wrong
+         implied bounds; for example, 1e-15 * x1 >= x2 + x3, where
+         x1 >= -10, x2, x3 >= 0, would lead to wrong conclusion that
+         x1 >= 0 */
+      if (fabs(a[k]) < 1e-6)
+         *ll = -DBL_MAX, *uu = +DBL_MAX; else
+#endif
+      if (a[k] > 0.0)
+      {  *ll = (ilb == -DBL_MAX ? -DBL_MAX : ilb / a[k]);
+         *uu = (iub == +DBL_MAX ? +DBL_MAX : iub / a[k]);
+      }
+      else if (a[k] < 0.0)
+      {  *ll = (iub == +DBL_MAX ? -DBL_MAX : iub / a[k]);
+         *uu = (ilb == -DBL_MAX ? +DBL_MAX : ilb / a[k]);
+      }
+      else
+         xassert(a != a);
       return;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  fhv_ftran - perform forward transformation (solve system B*x = b)
+*  check_row_bounds - check and relax original row bounds
 *
-*  SYNOPSIS
-*
-*  #include "glpfhv.h"
-*  void fhv_ftran(FHV *fhv, double x[]);
+*  Given a row (constraint)
 *
-*  DESCRIPTION
-*
-*  The routine fhv_ftran performs forward transformation, i.e. solves
-*  the system B*x = b, where B is the basis matrix, x is the vector of
-*  unknowns to be computed, b is the vector of right-hand sides.
-*
-*  On entry elements of the vector b should be stored in dense format
-*  in locations x[1], ..., x[m], where m is the number of rows. On exit
-*  the routine stores elements of the vector x in the same locations. */
-
-void fhv_ftran(FHV *fhv, double x[])
-{     int *pp_row = fhv->luf->pp_row;
-      int *pp_col = fhv->luf->pp_col;
-      int *p0_row = fhv->p0_row;
-      int *p0_col = fhv->p0_col;
-      if (!fhv->valid)
-         xfault("fhv_ftran: the factorization is not valid\n");
-      /* B = F*H*V, therefore inv(B) = inv(V)*inv(H)*inv(F) */
-      fhv->luf->pp_row = p0_row;
-      fhv->luf->pp_col = p0_col;
-      luf_f_solve(fhv->luf, 0, x);
-      fhv->luf->pp_row = pp_row;
-      fhv->luf->pp_col = pp_col;
-      fhv_h_solve(fhv, 0, x);
-      luf_v_solve(fhv->luf, 0, x);
-      return;
+*           n
+*     L <= sum a[j] * x[j] <= U
+*          j=1
+*
+*  and bounds of columns (variables)
+*
+*     l[j] <= x[j] <= u[j]
+*
+*  this routine checks the original row bounds L and U for feasibility
+*  and redundancy. If the original lower bound L or/and upper bound U
+*  cannot be active due to bounds of variables, the routine remove them
+*  replacing by -inf or/and +inf, respectively.
+*
+*  If no primal infeasibility is detected, the routine returns zero,
+*  otherwise non-zero. */
+
+static int check_row_bounds(const struct f_info *f, double *L_,
+      double *U_)
+{     int ret = 0;
+      double L = *L_, U = *U_, LL, UU;
+      /* determine implied bounds of the row */
+      row_implied_bounds(f, &LL, &UU);
+      /* check if the original lower bound is infeasible */
+      if (L != -DBL_MAX)
+      {  double eps = 1e-3 * (1.0 + fabs(L));
+         if (UU < L - eps)
+         {  ret = 1;
+            goto done;
+         }
+      }
+      /* check if the original upper bound is infeasible */
+      if (U != +DBL_MAX)
+      {  double eps = 1e-3 * (1.0 + fabs(U));
+         if (LL > U + eps)
+         {  ret = 1;
+            goto done;
+         }
+      }
+      /* check if the original lower bound is redundant */
+      if (L != -DBL_MAX)
+      {  double eps = 1e-12 * (1.0 + fabs(L));
+         if (LL > L - eps)
+         {  /* it cannot be active, so remove it */
+            *L_ = -DBL_MAX;
+         }
+      }
+      /* check if the original upper bound is redundant */
+      if (U != +DBL_MAX)
+      {  double eps = 1e-12 * (1.0 + fabs(U));
+         if (UU < U + eps)
+         {  /* it cannot be active, so remove it */
+            *U_ = +DBL_MAX;
+         }
+      }
+done: return ret;
 }
 
 /***********************************************************************
-*  NAME
+*  check_col_bounds - check and tighten original column bounds
 *
-*  fhv_btran - perform backward transformation (solve system B'*x = b)
-*
-*  SYNOPSIS
+*  Given a row (constraint)
 *
-*  #include "glpfhv.h"
-*  void fhv_btran(FHV *fhv, double x[]);
-*
-*  DESCRIPTION
-*
-*  The routine fhv_btran performs backward transformation, i.e. solves
-*  the system B'*x = b, where B' is a matrix transposed to the basis
-*  matrix B, x is the vector of unknowns to be computed, b is the vector
-*  of right-hand sides.
-*
-*  On entry elements of the vector b should be stored in dense format
-*  in locations x[1], ..., x[m], where m is the number of rows. On exit
-*  the routine stores elements of the vector x in the same locations. */
-
-void fhv_btran(FHV *fhv, double x[])
-{     int *pp_row = fhv->luf->pp_row;
-      int *pp_col = fhv->luf->pp_col;
-      int *p0_row = fhv->p0_row;
-      int *p0_col = fhv->p0_col;
-      if (!fhv->valid)
-         xfault("fhv_btran: the factorization is not valid\n");
-      /* B = F*H*V, therefore inv(B') = inv(F')*inv(H')*inv(V') */
-      luf_v_solve(fhv->luf, 1, x);
-      fhv_h_solve(fhv, 1, x);
-      fhv->luf->pp_row = p0_row;
-      fhv->luf->pp_col = p0_col;
-      luf_f_solve(fhv->luf, 1, x);
-      fhv->luf->pp_row = pp_row;
-      fhv->luf->pp_col = pp_col;
-      return;
+*           n
+*     L <= sum a[j] * x[j] <= U
+*          j=1
+*
+*  and bounds of columns (variables)
+*
+*     l[j] <= x[j] <= u[j]
+*
+*  for column (variable) x[j] this routine checks the original column
+*  bounds l[j] and u[j] for feasibility and redundancy. If the original
+*  lower bound l[j] or/and upper bound u[j] cannot be active due to
+*  bounds of the constraint and other variables, the routine tighten
+*  them replacing by corresponding implied bounds, if possible.
+*
+*  NOTE: It is assumed that if L != -inf, the row lower bound can be
+*        active, and if U != +inf, the row upper bound can be active.
+*
+*  The flag means that variable x[j] is required to be integer.
+*
+*  New actual bounds for x[j] are stored in locations lj and uj.
+*
+*  If no primal infeasibility is detected, the routine returns zero,
+*  otherwise non-zero. */
+
+static int check_col_bounds(const struct f_info *f, int n,
+      const double a[], double L, double U, const double l[],
+      const double u[], int flag, int j, double *_lj, double *_uj)
+{     int ret = 0;
+      double lj, uj, ll, uu;
+      xassert(n >= 0);
+      xassert(1 <= j && j <= n);
+      lj = l[j], uj = u[j];
+      /* determine implied bounds of the column */
+      col_implied_bounds(f, n, a, L, U, l, u, j, &ll, &uu);
+      /* if x[j] is integral, round its implied bounds */
+      if (flag)
+      {  if (ll != -DBL_MAX)
+            ll = (ll - floor(ll) < 1e-3 ? floor(ll) : ceil(ll));
+         if (uu != +DBL_MAX)
+            uu = (ceil(uu) - uu < 1e-3 ? ceil(uu) : floor(uu));
+      }
+      /* check if the original lower bound is infeasible */
+      if (lj != -DBL_MAX)
+      {  double eps = 1e-3 * (1.0 + fabs(lj));
+         if (uu < lj - eps)
+         {  ret = 1;
+            goto done;
+         }
+      }
+      /* check if the original upper bound is infeasible */
+      if (uj != +DBL_MAX)
+      {  double eps = 1e-3 * (1.0 + fabs(uj));
+         if (ll > uj + eps)
+         {  ret = 1;
+            goto done;
+         }
+      }
+      /* check if the original lower bound is redundant */
+      if (ll != -DBL_MAX)
+      {  double eps = 1e-3 * (1.0 + fabs(ll));
+         if (lj < ll - eps)
+         {  /* it cannot be active, so tighten it */
+            lj = ll;
+         }
+      }
+      /* check if the original upper bound is redundant */
+      if (uu != +DBL_MAX)
+      {  double eps = 1e-3 * (1.0 + fabs(uu));
+         if (uj > uu + eps)
+         {  /* it cannot be active, so tighten it */
+            uj = uu;
+         }
+      }
+      /* due to round-off errors it may happen that lj > uj (although
+         lj < uj + eps, since no primal infeasibility is detected), so
+         adjuct the new actual bounds to provide lj <= uj */
+      if (!(lj == -DBL_MAX || uj == +DBL_MAX))
+      {  double t1 = fabs(lj), t2 = fabs(uj);
+         double eps = 1e-10 * (1.0 + (t1 <= t2 ? t1 : t2));
+         if (lj > uj - eps)
+         {  if (lj == l[j])
+               uj = lj;
+            else if (uj == u[j])
+               lj = uj;
+            else if (t1 <= t2)
+               uj = lj;
+            else
+               lj = uj;
+         }
+      }
+      *_lj = lj, *_uj = uj;
+done: return ret;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  fhv_update_it - update LP basis factorization
+*  check_efficiency - check if change in column bounds is efficient
 *
-*  SYNOPSIS
-*
-*  #include "glpfhv.h"
-*  int fhv_update_it(FHV *fhv, int j, int len, const int ind[],
-*     const double val[]);
-*
-*  DESCRIPTION
-*
-*  The routine fhv_update_it updates the factorization of the basis
-*  matrix B after replacing its j-th column by a new vector.
-*
-*  The parameter j specifies the number of column of B, which has been
-*  replaced, 1 <= j <= m, where m is the order of B.
-*
-*  Row indices and numerical values of non-zero elements of the new
-*  column of B should be placed in locations ind[1], ..., ind[len] and
-*  val[1], ..., val[len], resp., where len is the number of non-zeros
-*  in the column. Neither zero nor duplicate elements are allowed.
-*
-*  RETURNS
-*
-*  0  The factorization has been successfully updated.
-*
-*  FHV_ESING
-*     The adjacent basis matrix is structurally singular, since after
-*     changing j-th column of matrix V by the new column (see algorithm
-*     below) the case k1 > k2 occured.
-*
-*  FHV_ECHECK
-*     The factorization is inaccurate, since after transforming k2-th
-*     row of matrix U = P*V*Q, its diagonal element u[k2,k2] is zero or
-*     close to zero,
-*
-*  FHV_ELIMIT
-*     Maximal number of H factors has been reached.
-*
-*  FHV_EROOM
-*     Overflow of the sparse vector area.
-*
-*  In case of non-zero return code the factorization becomes invalid.
-*  It should not be used until it has been recomputed with the routine
-*  fhv_factorize.
+*  Given the original bounds of a column l and u and its new actual
+*  bounds l' and u' (possibly tighten by the routine check_col_bounds)
+*  this routine checks if the change in the column bounds is efficient
+*  enough. If so, the routine returns non-zero, otherwise zero.
+*
+*  The flag means that the variable is required to be integer. */
+
+static int check_efficiency(int flag, double l, double u, double ll,
+      double uu)
+{     int eff = 0;
+      /* check efficiency for lower bound */
+      if (l < ll)
+      {  if (flag || l == -DBL_MAX)
+            eff++;
+         else
+         {  double r;
+            if (u == +DBL_MAX)
+               r = 1.0 + fabs(l);
+            else
+               r = 1.0 + (u - l);
+            if (ll - l >= 0.25 * r)
+               eff++;
+         }
+      }
+      /* check efficiency for upper bound */
+      if (u > uu)
+      {  if (flag || u == +DBL_MAX)
+            eff++;
+         else
+         {  double r;
+            if (l == -DBL_MAX)
+               r = 1.0 + fabs(u);
+            else
+               r = 1.0 + (u - l);
+            if (u - uu >= 0.25 * r)
+               eff++;
+         }
+      }
+      return eff;
+}
+
+/***********************************************************************
+*  basic_preprocessing - perform basic preprocessing
 *
-*  ALGORITHM
+*  This routine performs basic preprocessing of the specified MIP that
+*  includes relaxing some row bounds and tightening some column bounds.
 *
-*  The routine fhv_update_it is based on the transformation proposed by
-*  Forrest and Tomlin.
+*  On entry the arrays L and U contains original row bounds, and the
+*  arrays l and u contains original column bounds:
 *
-*  Let j-th column of the basis matrix B have been replaced by new
-*  column B[j]. In order to keep the equality B = F*H*V j-th column of
-*  matrix V should be replaced by the column inv(F*H)*B[j].
-*
-*  From the standpoint of matrix U = P*V*Q, replacement of j-th column
-*  of matrix V is equivalent to replacement of k1-th column of matrix U,
-*  where k1 is determined by permutation matrix Q. Thus, matrix U loses
-*  its upper triangular form and becomes the following:
-*
-*         1   k1       k2   m
-*     1   x x * x x x x x x x
-*         . x * x x x x x x x
-*     k1  . . * x x x x x x x
-*         . . * x x x x x x x
-*         . . * . x x x x x x
-*         . . * . . x x x x x
-*         . . * . . . x x x x
-*     k2  . . * . . . . x x x
-*         . . . . . . . . x x
-*     m   . . . . . . . . . x
-*
-*  where row index k2 corresponds to the lowest non-zero element of
-*  k1-th column.
-*
-*  The routine moves rows and columns k1+1, k1+2, ..., k2 of matrix U
-*  by one position to the left and upwards and moves k1-th row and k1-th
-*  column to position k2. As the result of such symmetric permutations
-*  matrix U becomes the following:
-*
-*         1   k1       k2   m
-*     1   x x x x x x x * x x
-*         . x x x x x x * x x
-*     k1  . . x x x x x * x x
-*         . . . x x x x * x x
-*         . . . . x x x * x x
-*         . . . . . x x * x x
-*         . . . . . . x * x x
-*     k2  . . x x x x x * x x
-*         . . . . . . . . x x
-*     m   . . . . . . . . . x
-*
-*  Then the routine performs gaussian elimination to eliminate elements
-*  u[k2,k1], u[k2,k1+1], ..., u[k2,k2-1] using diagonal elements
-*  u[k1,k1], u[k1+1,k1+1], ..., u[k2-1,k2-1] as pivots in the same way
-*  as described in comments to the routine luf_factorize (see the module
-*  GLPLUF). Note that actually all operations are performed on matrix V,
-*  not on matrix U. During the elimination process the routine permutes
-*  neither rows nor columns, so only k2-th row of matrix U is changed.
-*
-*  To keep the main equality B = F*H*V, each time when the routine
-*  applies elementary gaussian transformation to the transformed row of
-*  matrix V (which corresponds to k2-th row of matrix U), it also adds
-*  a new element (gaussian multiplier) to the current row-like factor
-*  of matrix H, which corresponds to the transformed row of matrix V. */
-
-int fhv_update_it(FHV *fhv, int j, int len, const int ind[],
-      const double val[])
-{     int m = fhv->m;
-      LUF *luf = fhv->luf;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      int *vr_cap = luf->vr_cap;
-      double *vr_piv = luf->vr_piv;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *vc_cap = luf->vc_cap;
-      int *pp_row = luf->pp_row;
-      int *pp_col = luf->pp_col;
-      int *qq_row = luf->qq_row;
-      int *qq_col = luf->qq_col;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      double *work = luf->work;
-      double eps_tol = luf->eps_tol;
-      int *hh_ind = fhv->hh_ind;
-      int *hh_ptr = fhv->hh_ptr;
-      int *hh_len = fhv->hh_len;
-      int *p0_row = fhv->p0_row;
-      int *p0_col = fhv->p0_col;
-      int *cc_ind = fhv->cc_ind;
-      double *cc_val = fhv->cc_val;
-      double upd_tol = fhv->upd_tol;
-      int i, i_beg, i_end, i_ptr, j_beg, j_end, j_ptr, k, k1, k2, p, q,
-         p_beg, p_end, p_ptr, ptr, ret;
-      double f, temp;
-      if (!fhv->valid)
-         xfault("fhv_update_it: the factorization is not valid\n");
-      if (!(1 <= j && j <= m))
-         xfault("fhv_update_it: j = %d; column number out of range\n",
-            j);
-      /* check if the new factor of matrix H can be created */
-      if (fhv->hh_nfs == fhv->hh_max)
-      {  /* maximal number of updates has been reached */
-         fhv->valid = 0;
-         ret = FHV_ELIMIT;
-         goto done;
-      }
-      /* convert new j-th column of B to dense format */
-      for (i = 1; i <= m; i++)
-         cc_val[i] = 0.0;
-      for (k = 1; k <= len; k++)
-      {  i = ind[k];
-         if (!(1 <= i && i <= m))
-            xfault("fhv_update_it: ind[%d] = %d; row number out of rang"
-               "e\n", k, i);
-         if (cc_val[i] != 0.0)
-            xfault("fhv_update_it: ind[%d] = %d; duplicate row index no"
-               "t allowed\n", k, i);
-         if (val[k] == 0.0)
-            xfault("fhv_update_it: val[%d] = %g; zero element not allow"
-               "ed\n", k, val[k]);
-         cc_val[i] = val[k];
-      }
-      /* new j-th column of V := inv(F * H) * (new B[j]) */
-      fhv->luf->pp_row = p0_row;
-      fhv->luf->pp_col = p0_col;
-      luf_f_solve(fhv->luf, 0, cc_val);
-      fhv->luf->pp_row = pp_row;
-      fhv->luf->pp_col = pp_col;
-      fhv_h_solve(fhv, 0, cc_val);
-      /* convert new j-th column of V to sparse format */
-      len = 0;
-      for (i = 1; i <= m; i++)
-      {  temp = cc_val[i];
-         if (temp == 0.0 || fabs(temp) < eps_tol) continue;
-         len++, cc_ind[len] = i, cc_val[len] = temp;
-      }
-      /* clear old content of j-th column of matrix V */
-      j_beg = vc_ptr[j];
-      j_end = j_beg + vc_len[j] - 1;
-      for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
-      {  /* get row index of v[i,j] */
-         i = sv_ind[j_ptr];
-         /* find v[i,j] in the i-th row */
-         i_beg = vr_ptr[i];
-         i_end = i_beg + vr_len[i] - 1;
-         for (i_ptr = i_beg; sv_ind[i_ptr] != j; i_ptr++) /* nop */;
-         xassert(i_ptr <= i_end);
-         /* remove v[i,j] from the i-th row */
-         sv_ind[i_ptr] = sv_ind[i_end];
-         sv_val[i_ptr] = sv_val[i_end];
-         vr_len[i]--;
-      }
-      /* now j-th column of matrix V is empty */
-      luf->nnz_v -= vc_len[j];
-      vc_len[j] = 0;
-      /* add new elements of j-th column of matrix V to corresponding
-         row lists; determine indices k1 and k2 */
-      k1 = qq_row[j], k2 = 0;
-      for (ptr = 1; ptr <= len; ptr++)
-      {  /* get row index of v[i,j] */
-         i = cc_ind[ptr];
-         /* at least one unused location is needed in i-th row */
-         if (vr_len[i] + 1 > vr_cap[i])
-         {  if (luf_enlarge_row(luf, i, vr_len[i] + 10))
-            {  /* overflow of the sparse vector area */
-               fhv->valid = 0;
-               luf->new_sva = luf->sv_size + luf->sv_size;
-               xassert(luf->new_sva > luf->sv_size);
-               ret = FHV_EROOM;
-               goto done;
+*  L[0] is the lower bound of the objective row;
+*  L[i], i = 1,...,m, is the lower bound of i-th row;
+*  U[0] is the upper bound of the objective row;
+*  U[i], i = 1,...,m, is the upper bound of i-th row;
+*  l[0] is not used;
+*  l[j], j = 1,...,n, is the lower bound of j-th column;
+*  u[0] is not used;
+*  u[j], j = 1,...,n, is the upper bound of j-th column.
+*
+*  On exit the arrays L, U, l, and u contain new actual bounds of rows
+*  and column in the same locations.
+*
+*  The parameters nrs and num specify an initial list of rows to be
+*  processed:
+*
+*  nrs is the number of rows in the initial list, 0 <= nrs <= m+1;
+*  num[0] is not used;
+*  num[1,...,nrs] are row numbers (0 means the objective row).
+*
+*  The parameter max_pass specifies the maximal number of times that
+*  each row can be processed, max_pass > 0.
+*
+*  If no primal infeasibility is detected, the routine returns zero,
+*  otherwise non-zero. */
+
+static int basic_preprocessing(glp_prob *mip, double L[], double U[],
+      double l[], double u[], int nrs, const int num[], int max_pass)
+{     int m = mip->m;
+      int n = mip->n;
+      struct f_info f;
+      int i, j, k, len, size, ret = 0;
+      int *ind, *list, *mark, *pass;
+      double *val, *lb, *ub;
+      xassert(0 <= nrs && nrs <= m+1);
+      xassert(max_pass > 0);
+      /* allocate working arrays */
+      ind = xcalloc(1+n, sizeof(int));
+      list = xcalloc(1+m+1, sizeof(int));
+      mark = xcalloc(1+m+1, sizeof(int));
+      memset(&mark[0], 0, (m+1) * sizeof(int));
+      pass = xcalloc(1+m+1, sizeof(int));
+      memset(&pass[0], 0, (m+1) * sizeof(int));
+      val = xcalloc(1+n, sizeof(double));
+      lb = xcalloc(1+n, sizeof(double));
+      ub = xcalloc(1+n, sizeof(double));
+      /* initialize the list of rows to be processed */
+      size = 0;
+      for (k = 1; k <= nrs; k++)
+      {  i = num[k];
+         xassert(0 <= i && i <= m);
+         /* duplicate row numbers are not allowed */
+         xassert(!mark[i]);
+         list[++size] = i, mark[i] = 1;
+      }
+      xassert(size == nrs);
+      /* process rows in the list until it becomes empty */
+      while (size > 0)
+      {  /* get a next row from the list */
+         i = list[size--], mark[i] = 0;
+         /* increase the row processing count */
+         pass[i]++;
+         /* if the row is free, skip it */
+         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;
+         /* obtain coefficients of the row */
+         len = 0;
+         if (i == 0)
+         {  for (j = 1; j <= n; j++)
+            {  GLPCOL *col = mip->col[j];
+               if (col->coef != 0.0)
+                  len++, ind[len] = j, val[len] = col->coef;
             }
          }
-         /* add v[i,j] to i-th row */
-         i_ptr = vr_ptr[i] + vr_len[i];
-         sv_ind[i_ptr] = j;
-         sv_val[i_ptr] = cc_val[ptr];
-         vr_len[i]++;
-         /* adjust index k2 */
-         if (k2 < pp_col[i]) k2 = pp_col[i];
-      }
-      /* capacity of j-th column (which is currently empty) should be
-         not less than len locations */
-      if (vc_cap[j] < len)
-      {  if (luf_enlarge_col(luf, j, len))
-         {  /* overflow of the sparse vector area */
-            fhv->valid = 0;
-            luf->new_sva = luf->sv_size + luf->sv_size;
-            xassert(luf->new_sva > luf->sv_size);
-            ret = FHV_EROOM;
-            goto done;
+         else
+         {  GLPROW *row = mip->row[i];
+            GLPAIJ *aij;
+            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+               len++, ind[len] = aij->col->j, val[len] = aij->val;
          }
-      }
-      /* add new elements of matrix V to j-th column list */
-      j_ptr = vc_ptr[j];
-      memmove(&sv_ind[j_ptr], &cc_ind[1], len * sizeof(int));
-      memmove(&sv_val[j_ptr], &cc_val[1], len * sizeof(double));
-      vc_len[j] = len;
-      luf->nnz_v += len;
-      /* if k1 > k2, diagonal element u[k2,k2] of matrix U is zero and
-         therefore the adjacent basis matrix is structurally singular */
-      if (k1 > k2)
-      {  fhv->valid = 0;
-         ret = FHV_ESING;
-         goto done;
-      }
-      /* perform implicit symmetric permutations of rows and columns of
-         matrix U */
-      i = pp_row[k1], j = qq_col[k1];
-      for (k = k1; k < k2; k++)
-      {  pp_row[k] = pp_row[k+1], pp_col[pp_row[k]] = k;
-         qq_col[k] = qq_col[k+1], qq_row[qq_col[k]] = k;
-      }
-      pp_row[k2] = i, pp_col[i] = k2;
-      qq_col[k2] = j, qq_row[j] = k2;
-      /* now i-th row of the matrix V is k2-th row of matrix U; since
-         no pivoting is used, only this row will be transformed */
-      /* copy elements of i-th row of matrix V to the working array and
-         remove these elements from matrix V */
-      for (j = 1; j <= m; j++) work[j] = 0.0;
-      i_beg = vr_ptr[i];
-      i_end = i_beg + vr_len[i] - 1;
-      for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-      {  /* get column index of v[i,j] */
-         j = sv_ind[i_ptr];
-         /* store v[i,j] to the working array */
-         work[j] = sv_val[i_ptr];
-         /* find v[i,j] in the j-th column */
-         j_beg = vc_ptr[j];
-         j_end = j_beg + vc_len[j] - 1;
-         for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++) /* nop */;
-         xassert(j_ptr <= j_end);
-         /* remove v[i,j] from the j-th column */
-         sv_ind[j_ptr] = sv_ind[j_end];
-         sv_val[j_ptr] = sv_val[j_end];
-         vc_len[j]--;
-      }
-      /* now i-th row of matrix V is empty */
-      luf->nnz_v -= vr_len[i];
-      vr_len[i] = 0;
-      /* create the next row-like factor of the matrix H; this factor
-         corresponds to i-th (transformed) row */
-      fhv->hh_nfs++;
-      hh_ind[fhv->hh_nfs] = i;
-      /* hh_ptr[] will be set later */
-      hh_len[fhv->hh_nfs] = 0;
-      /* up to (k2 - k1) free locations are needed to add new elements
-         to the non-trivial row of the row-like factor */
-      if (luf->sv_end - luf->sv_beg < k2 - k1)
-      {  luf_defrag_sva(luf);
-         if (luf->sv_end - luf->sv_beg < k2 - k1)
-         {  /* overflow of the sparse vector area */
-            fhv->valid = luf->valid = 0;
-            luf->new_sva = luf->sv_size + luf->sv_size;
-            xassert(luf->new_sva > luf->sv_size);
-            ret = FHV_EROOM;
+         /* determine lower and upper bounds of columns corresponding
+            to non-zero row coefficients */
+         for (k = 1; k <= len; k++)
+            j = ind[k], lb[k] = l[j], ub[k] = u[j];
+         /* prepare the row info to determine implied bounds */
+         prepare_row_info(len, val, lb, ub, &f);
+         /* check and relax bounds of the row */
+         if (check_row_bounds(&f, &L[i], &U[i]))
+         {  /* the feasible region is empty */
+            ret = 1;
             goto done;
          }
-      }
-      /* eliminate subdiagonal elements of matrix U */
-      for (k = k1; k < k2; k++)
-      {  /* v[p,q] = u[k,k] */
-         p = pp_row[k], q = qq_col[k];
-         /* this is the crucial point, where even tiny non-zeros should
-            not be dropped */
-         if (work[q] == 0.0) continue;
-         /* compute gaussian multiplier f = v[i,q] / v[p,q] */
-         f = work[q] / vr_piv[p];
-         /* perform gaussian transformation:
-            (i-th row) := (i-th row) - f * (p-th row)
-            in order to eliminate v[i,q] = u[k2,k] */
-         p_beg = vr_ptr[p];
-         p_end = p_beg + vr_len[p] - 1;
-         for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)
-            work[sv_ind[p_ptr]] -= f * sv_val[p_ptr];
-         /* store new element (gaussian multiplier that corresponds to
-            p-th row) in the current row-like factor */
-         luf->sv_end--;
-         sv_ind[luf->sv_end] = p;
-         sv_val[luf->sv_end] = f;
-         hh_len[fhv->hh_nfs]++;
-      }
-      /* set pointer to the current row-like factor of the matrix H
-         (if no elements were added to this factor, it is unity matrix
-         and therefore can be discarded) */
-      if (hh_len[fhv->hh_nfs] == 0)
-         fhv->hh_nfs--;
-      else
-      {  hh_ptr[fhv->hh_nfs] = luf->sv_end;
-         fhv->nnz_h += hh_len[fhv->hh_nfs];
-      }
-      /* store new pivot which corresponds to u[k2,k2] */
-      vr_piv[i] = work[qq_col[k2]];
-      /* new elements of i-th row of matrix V (which are non-diagonal
-         elements u[k2,k2+1], ..., u[k2,m] of matrix U = P*V*Q) now are
-         contained in the working array; add them to matrix V */
-      len = 0;
-      for (k = k2+1; k <= m; k++)
-      {  /* get column index and value of v[i,j] = u[k2,k] */
-         j = qq_col[k];
-         temp = work[j];
-         /* if v[i,j] is close to zero, skip it */
-         if (fabs(temp) < eps_tol) continue;
-         /* at least one unused location is needed in j-th column */
-         if (vc_len[j] + 1 > vc_cap[j])
-         {  if (luf_enlarge_col(luf, j, vc_len[j] + 10))
-            {  /* overflow of the sparse vector area */
-               fhv->valid = 0;
-               luf->new_sva = luf->sv_size + luf->sv_size;
-               xassert(luf->new_sva > luf->sv_size);
-               ret = FHV_EROOM;
+         /* if the row became free, drop it */
+         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;
+         /* process columns having non-zero coefficients in the row */
+         for (k = 1; k <= len; k++)
+         {  GLPCOL *col;
+            int flag, eff;
+            double ll, uu;
+            /* take a next column in the row */
+            j = ind[k], col = mip->col[j];
+            flag = col->kind != GLP_CV;
+            /* check and tighten bounds of the column */
+            if (check_col_bounds(&f, len, val, L[i], U[i], lb, ub,
+                flag, k, &ll, &uu))
+            {  /* the feasible region is empty */
+               ret = 1;
                goto done;
             }
+            /* check if change in the column bounds is efficient */
+            eff = check_efficiency(flag, l[j], u[j], ll, uu);
+            /* set new actual bounds of the column */
+            l[j] = ll, u[j] = uu;
+            /* if the change is efficient, add all rows affected by the
+               corresponding column, to the list */
+            if (eff > 0)
+            {  GLPAIJ *aij;
+               for (aij = col->ptr; aij != NULL; aij = aij->c_next)
+               {  int ii = aij->row->i;
+                  /* if the row was processed maximal number of times,
+                     skip it */
+                  if (pass[ii] >= max_pass) continue;
+                  /* if the row is free, skip it */
+                  if (L[ii] == -DBL_MAX && U[ii] == +DBL_MAX) continue;
+                  /* put the row into the list */
+                  if (mark[ii] == 0)
+                  {  xassert(size <= m);
+                     list[++size] = ii, mark[ii] = 1;
+                  }
+               }
+            }
          }
-         /* add v[i,j] to j-th column */
-         j_ptr = vc_ptr[j] + vc_len[j];
-         sv_ind[j_ptr] = i;
-         sv_val[j_ptr] = temp;
-         vc_len[j]++;
-         /* also store v[i,j] to the auxiliary array */
-         len++, cc_ind[len] = j, cc_val[len] = temp;
-      }
-      /* capacity of i-th row (which is currently empty) should be not
-         less than len locations */
-      if (vr_cap[i] < len)
-      {  if (luf_enlarge_row(luf, i, len))
-         {  /* overflow of the sparse vector area */
-            fhv->valid = 0;
-            luf->new_sva = luf->sv_size + luf->sv_size;
-            xassert(luf->new_sva > luf->sv_size);
-            ret = FHV_EROOM;
-            goto done;
-         }
-      }
-      /* add new elements to i-th row list */
-      i_ptr = vr_ptr[i];
-      memmove(&sv_ind[i_ptr], &cc_ind[1], len * sizeof(int));
-      memmove(&sv_val[i_ptr], &cc_val[1], len * sizeof(double));
-      vr_len[i] = len;
-      luf->nnz_v += len;
-      /* updating is finished; check that diagonal element u[k2,k2] is
-         not very small in absolute value among other elements in k2-th
-         row and k2-th column of matrix U = P*V*Q */
-      /* temp = max(|u[k2,*]|, |u[*,k2]|) */
-      temp = 0.0;
-      /* walk through k2-th row of U which is i-th row of V */
-      i = pp_row[k2];
-      i_beg = vr_ptr[i];
-      i_end = i_beg + vr_len[i] - 1;
-      for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-         if (temp < fabs(sv_val[i_ptr])) temp = fabs(sv_val[i_ptr]);
-      /* walk through k2-th column of U which is j-th column of V */
-      j = qq_col[k2];
-      j_beg = vc_ptr[j];
-      j_end = j_beg + vc_len[j] - 1;
-      for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
-         if (temp < fabs(sv_val[j_ptr])) temp = fabs(sv_val[j_ptr]);
-      /* check that u[k2,k2] is not very small */
-      if (fabs(vr_piv[i]) < upd_tol * temp)
-      {  /* the factorization seems to be inaccurate and therefore must
-            be recomputed */
-         fhv->valid = 0;
-         ret = FHV_ECHECK;
-         goto done;
       }
-      /* the factorization has been successfully updated */
-      ret = 0;
-done: /* return to the calling program */
+done: /* free working arrays */
+      xfree(ind);
+      xfree(list);
+      xfree(mark);
+      xfree(pass);
+      xfree(val);
+      xfree(lb);
+      xfree(ub);
       return ret;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  fhv_delete_it - delete LP basis factorization
+*  ios_preprocess_node - preprocess current subproblem
 *
 *  SYNOPSIS
 *
-*  #include "glpfhv.h"
-*  void fhv_delete_it(FHV *fhv);
+*  #include "glpios.h"
+*  int ios_preprocess_node(glp_tree *tree, int max_pass);
 *
 *  DESCRIPTION
 *
-*  The routine fhv_delete_it deletes LP basis factorization specified
-*  by the parameter fhv and frees all memory allocated to this program
-*  object. */
-
-void fhv_delete_it(FHV *fhv)
-{     luf_delete_it(fhv->luf);
-      if (fhv->hh_ind != NULL) xfree(fhv->hh_ind);
-      if (fhv->hh_ptr != NULL) xfree(fhv->hh_ptr);
-      if (fhv->hh_len != NULL) xfree(fhv->hh_len);
-      if (fhv->p0_row != NULL) xfree(fhv->p0_row);
-      if (fhv->p0_col != NULL) xfree(fhv->p0_col);
-      if (fhv->cc_ind != NULL) xfree(fhv->cc_ind);
-      if (fhv->cc_val != NULL) xfree(fhv->cc_val);
-      xfree(fhv);
-      return;
+*  The routine ios_preprocess_node performs basic preprocessing of the
+*  current subproblem.
+*
+*  RETURNS
+*
+*  If no primal infeasibility is detected, the routine returns zero,
+*  otherwise non-zero. */
+
+int ios_preprocess_node(glp_tree *tree, int max_pass)
+{     glp_prob *mip = tree->mip;
+      int m = mip->m;
+      int n = mip->n;
+      int i, j, nrs, *num, ret = 0;
+      double *L, *U, *l, *u;
+      /* the current subproblem must exist */
+      xassert(tree->curr != NULL);
+      /* determine original row bounds */
+      L = xcalloc(1+m, sizeof(double));
+      U = xcalloc(1+m, sizeof(double));
+      switch (mip->mip_stat)
+      {  case GLP_UNDEF:
+            L[0] = -DBL_MAX, U[0] = +DBL_MAX;
+            break;
+         case GLP_FEAS:
+            switch (mip->dir)
+            {  case GLP_MIN:
+                  L[0] = -DBL_MAX, U[0] = mip->mip_obj - mip->c0;
+                  break;
+               case GLP_MAX:
+                  L[0] = mip->mip_obj - mip->c0, U[0] = +DBL_MAX;
+                  break;
+               default:
+                  xassert(mip != mip);
+            }
+            break;
+         default:
+            xassert(mip != mip);
+      }
+      for (i = 1; i <= m; i++)
+      {  L[i] = glp_get_row_lb(mip, i);
+         U[i] = glp_get_row_ub(mip, i);
+      }
+      /* determine original column bounds */
+      l = xcalloc(1+n, sizeof(double));
+      u = xcalloc(1+n, sizeof(double));
+      for (j = 1; j <= n; j++)
+      {  l[j] = glp_get_col_lb(mip, j);
+         u[j] = glp_get_col_ub(mip, j);
+      }
+      /* build the initial list of rows to be analyzed */
+      nrs = m + 1;
+      num = xcalloc(1+nrs, sizeof(int));
+      for (i = 1; i <= nrs; i++) num[i] = i - 1;
+      /* perform basic preprocessing */
+      if (basic_preprocessing(mip , L, U, l, u, nrs, num, max_pass))
+      {  ret = 1;
+         goto done;
+      }
+      /* set new actual (relaxed) row bounds */
+      for (i = 1; i <= m; i++)
+      {  /* consider only non-active rows to keep dual feasibility */
+         if (glp_get_row_stat(mip, i) == GLP_BS)
+         {  if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)
+               glp_set_row_bnds(mip, i, GLP_FR, 0.0, 0.0);
+            else if (U[i] == +DBL_MAX)
+               glp_set_row_bnds(mip, i, GLP_LO, L[i], 0.0);
+            else if (L[i] == -DBL_MAX)
+               glp_set_row_bnds(mip, i, GLP_UP, 0.0, U[i]);
+         }
+      }
+      /* set new actual (tightened) column bounds */
+      for (j = 1; j <= n; j++)
+      {  int type;
+         if (l[j] == -DBL_MAX && u[j] == +DBL_MAX)
+            type = GLP_FR;
+         else if (u[j] == +DBL_MAX)
+            type = GLP_LO;
+         else if (l[j] == -DBL_MAX)
+            type = GLP_UP;
+         else if (l[j] != u[j])
+            type = GLP_DB;
+         else
+            type = GLP_FX;
+         glp_set_col_bnds(mip, j, type, l[j], u[j]);
+      }
+done: /* free working arrays and return */
+      xfree(L);
+      xfree(U);
+      xfree(l);
+      xfree(u);
+      xfree(num);
+      return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpfhv.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/scf.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpfhv.h (LP basis factorization, FHV eta file version) */
+/* scf.h (sparse updatable Schur-complement-based factorization) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2013-2014 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,153 +15,195 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPFHV_H
-#define GLPFHV_H
+#ifndef SCF_H
+#define SCF_H
 
-#include "glpluf.h"
+#include "btf.h"
+#include "ifu.h"
+#include "luf.h"
 
 /***********************************************************************
-*  The structure FHV defines the factorization of the basis mxm-matrix
-*  B, where m is the number of rows in corresponding problem instance.
+*  The structure SCF describes sparse updatable factorization based on
+*  Schur complement.
+*
+*  The SCF-factorization has the following format:
+*
+*     ( A   A1~ )     ( A0  A1 )       ( R0    ) ( S0  S )
+*     (         ) = P (        ) Q = P (       ) (       ) Q,        (1)
+*     ( A2~ A3~ )     ( A2  A3 )       ( R   I ) (     C )
+*
+*  where:
+*
+*  A is current (unsymmetric) square matrix (not stored);
 *
-*  This factorization is the following sextet:
+*  A1~, A2~, A3~ are some additional matrices (not stored);
 *
-*     [B] = (F, H, V, P0, P, Q),                                     (1)
+*  A0 is initial (unsymmetric) square matrix (not stored);
 *
-*  where F, H, and V are such matrices that
+*  A1, A2, A3 are some additional matrices (not stored);
 *
-*     B = F * H * V,                                                 (2)
-*
-*  and P0, P, and Q are such permutation matrices that the matrix
-*
-*     L = P0 * F * inv(P0)                                           (3)
-*
-*  is lower triangular with unity diagonal, and the matrix
-*
-*     U = P * V * Q                                                  (4)
-*
-*  is upper triangular. All the matrices have the same order m, which
-*  is the order of the basis matrix B.
-*
-*  The matrices F, V, P, and Q are stored in the structure LUF (see the
-*  module GLPLUF), which is a member of the structure FHV.
-*
-*  The matrix H is stored in the form of eta file using row-like format
-*  as follows:
-*
-*     H = H[1] * H[2] * ... * H[nfs],                                (5)
-*
-*  where H[k], k = 1, 2, ..., nfs, is a row-like factor, which differs
-*  from the unity matrix only by one row, nfs is current number of row-
-*  like factors. After the factorization has been built for some given
-*  basis matrix B the matrix H has no factors and thus it is the unity
-*  matrix. Then each time when the factorization is recomputed for an
-*  adjacent basis matrix, the next factor H[k], k = 1, 2, ... is built
-*  and added to the end of the eta file H.
-*
-*  Being sparse vectors non-trivial rows of the factors H[k] are stored
-*  in the right part of the sparse vector area (SVA) in the same manner
-*  as rows and columns of the matrix F.
-*
-*  For more details see the program documentation. */
-
-typedef struct FHV FHV;
-
-struct FHV
-{     /* LP basis factorization */
-      int m_max;
-      /* maximal value of m (increased automatically, if necessary) */
-      int m;
-      /* the order of matrices B, F, H, V, P0, P, Q */
-      int valid;
-      /* the factorization is valid only if this flag is set */
-      LUF *luf;
-      /* LU-factorization (contains the matrices F, V, P, Q) */
-      /*--------------------------------------------------------------*/
-      /* matrix H in the form of eta file */
-      int hh_max;
-      /* maximal number of row-like factors (which limits the number of
-         updates of the factorization) */
-      int hh_nfs;
-      /* current number of row-like factors (0 <= hh_nfs <= hh_max) */
-      int *hh_ind; /* int hh_ind[1+hh_max]; */
-      /* hh_ind[k], k = 1, ..., nfs, is the number of a non-trivial row
-         of factor H[k] */
-      int *hh_ptr; /* int hh_ptr[1+hh_max]; */
-      /* hh_ptr[k], k = 1, ..., nfs, is a pointer to the first element
-         of the non-trivial row of factor H[k] in the SVA */
-      int *hh_len; /* int hh_len[1+hh_max]; */
-      /* hh_len[k], k = 1, ..., nfs, is the number of non-zero elements
-         in the non-trivial row of factor H[k] */
-      /*--------------------------------------------------------------*/
-      /* matrix P0 */
-      int *p0_row; /* int p0_row[1+m_max]; */
-      /* p0_row[i] = j means that p0[i,j] = 1 */
-      int *p0_col; /* int p0_col[1+m_max]; */
-      /* p0_col[j] = i means that p0[i,j] = 1 */
-      /* if i-th row or column of the matrix F corresponds to i'-th row
-         or column of the matrix L = P0*F*inv(P0), then p0_row[i'] = i
-         and p0_col[i] = i' */
-      /*--------------------------------------------------------------*/
-      /* working arrays */
-      int *cc_ind; /* int cc_ind[1+m_max]; */
-      /* integer working array */
-      double *cc_val; /* double cc_val[1+m_max]; */
-      /* floating-point working array */
-      /*--------------------------------------------------------------*/
-      /* control parameters */
-      double upd_tol;
-      /* update tolerance; if after updating the factorization absolute
-         value of some diagonal element u[k,k] of matrix U = P*V*Q is
-         less than upd_tol * max(|u[k,*]|, |u[*,k]|), the factorization
-         is considered as inaccurate */
-      /*--------------------------------------------------------------*/
-      /* some statistics */
-      int nnz_h;
-      /* current number of non-zeros in all factors of matrix H */
+*  R0 and S0 are matrices that define factorization of the initial
+*  matrix A0 = R0 * S0 (stored in an invertable form);
+*
+*  R is a matrix defined from R * S0 = A2, so R = A2 * inv(S0) (stored
+*  in row-wise sparse format);
+*
+*  S is a matrix defined from R0 * S = A1, so S = inv(R0) * A1 (stored
+*  in column-wise sparse format);
+*
+*  C is Schur complement (to matrix A0) defined from R * S + C = A3,
+*  so C = A3 - R * S = A3 - A2 * inv(A0) * A1 (stored in an invertable
+*  form).
+*
+*  P, Q are permutation matrices (stored in both row- and column-like
+*  formats). */
+
+typedef struct SCF SCF;
+
+struct SCF
+{     /* Schur-complement-based factorization */
+      int n;
+      /* order of current matrix A */
+      /*--------------------------------------------------------------*/
+      /* initial matrix A0 = R0 * S0 of order n0 in invertable form */
+      int n0;
+      /* order of matrix A0 */
+      int type;
+      /* type of factorization used:
+       * 1 - LU-factorization (R0 = F0, S0 = V0)
+       * 2 - BT-factorization (R0 = I, S0 = A0) */
+      union
+      {  LUF *luf; /* type = 1 */
+         BTF *btf; /* type = 2 */
+      }  a0;
+      /* factorization of matrix A0 */
+      /*--------------------------------------------------------------*/
+      /* augmented matrix (A0, A1; A2, A3) of order n0+nn */
+      int nn_max;
+      /* maximal number of additional rows and columns in the augmented
+       * matrix (this limits the number of updates) */
+      int nn;
+      /* current number of additional rows and columns in the augmented
+       * matrix, 0 <= nn <= nn_max */
+      SVA *sva;
+      /* associated sparse vector area (SVA) used to store rows of
+       * matrix R and columns of matrix S */
+      /*--------------------------------------------------------------*/
+      /* nn*n0-matrix R in row-wise format */
+      int rr_ref;
+      /* reference number of sparse vector in SVA, which is the first
+       * row of matrix R */
+#if 0 + 0
+      int *rr_ptr = &sva->ptr[rr_ref-1];
+      /* rr_ptr[0] is not used;
+       * rr_ptr[i], 1 <= i <= nn, is pointer to i-th row in SVA;
+       * rr_ptr[nn+1,...,nn_max] are reserved locations */
+      int *rr_len = &sva->len[rr_ref-1];
+      /* rr_len[0] is not used;
+       * rr_len[i], 1 <= i <= nn, is length of i-th row;
+       * rr_len[nn+1,...,nn_max] are reserved locations */
+#endif
+      /*--------------------------------------------------------------*/
+      /* n0*nn-matrix S in column-wise format */
+      int ss_ref;
+      /* reference number of sparse vector in SVA, which is the first
+       * column of matrix S */
+#if 0 + 0
+      int *ss_ptr = &sva->ptr[ss_ref-1];
+      /* ss_ptr[0] is not used;
+       * ss_ptr[j], 1 <= j <= nn, is pointer to j-th column in SVA;
+       * ss_ptr[nn+1,...,nn_max] are reserved locations */
+      int *ss_len = &sva->len[ss_ref-1];
+      /* ss_len[0] is not used;
+       * ss_len[j], 1 <= j <= nn, is length of j-th column;
+       * ss_len[nn+1,...,nn_max] are reserved locations */
+#endif
+      /*--------------------------------------------------------------*/
+      /* Schur complement C of order nn in invertable form */
+      IFU ifu;
+      /* IFU-factorization of matrix C */
+      /*--------------------------------------------------------------*/
+      /* permutation matrix P of order n0+nn */
+      int *pp_ind; /* int pp_ind[1+n0+nn_max]; */
+      /* pp_ind[i] = j means that P[i,j] = 1 */
+      int *pp_inv; /* int pp_inv[1+n0+nn_max]; */
+      /* pp_inv[j] = i means that P[i,j] = 1 */
+      /*--------------------------------------------------------------*/
+      /* permutation matrix Q of order n0+nn */
+      int *qq_ind; /* int qq_ind[1+n0+nn_max]; */
+      /* qq_ind[i] = j means that Q[i,j] = 1 */
+      int *qq_inv; /* int qq_inv[1+n0+nn_max]; */
+      /* qq_inv[j] = i means that Q[i,j] = 1 */
 };
 
-/* return codes: */
-#define FHV_ESING    1  /* singular matrix */
-#define FHV_ECOND    2  /* ill-conditioned matrix */
-#define FHV_ECHECK   3  /* insufficient accuracy */
-#define FHV_ELIMIT   4  /* update limit reached */
-#define FHV_EROOM    5  /* SVA overflow */
-
-#define fhv_create_it _glp_fhv_create_it
-FHV *fhv_create_it(void);
-/* create LP basis factorization */
-
-#define fhv_factorize _glp_fhv_factorize
-int fhv_factorize(FHV *fhv, int m, int (*col)(void *info, int j,
-      int ind[], double val[]), void *info);
-/* compute LP basis factorization */
-
-#define fhv_h_solve _glp_fhv_h_solve
-void fhv_h_solve(FHV *fhv, int tr, double x[]);
-/* solve system H*x = b or H'*x = b */
-
-#define fhv_ftran _glp_fhv_ftran
-void fhv_ftran(FHV *fhv, double x[]);
-/* perform forward transformation (solve system B*x = b) */
-
-#define fhv_btran _glp_fhv_btran
-void fhv_btran(FHV *fhv, double x[]);
-/* perform backward transformation (solve system B'*x = b) */
-
-#define fhv_update_it _glp_fhv_update_it
-int fhv_update_it(FHV *fhv, int j, int len, const int ind[],
-      const double val[]);
-/* update LP basis factorization */
-
-#define fhv_delete_it _glp_fhv_delete_it
-void fhv_delete_it(FHV *fhv);
-/* delete LP basis factorization */
+#define scf_swap_q_cols(j1, j2) \
+      do \
+      {  int i1, i2; \
+         i1 = qq_inv[j1], i2 = qq_inv[j2]; \
+         qq_ind[i1] = j2, qq_inv[j2] = i1; \
+         qq_ind[i2] = j1, qq_inv[j1] = i2; \
+      }  while (0)
+/* swap columns j1 and j2 of permutation matrix Q */
+
+#define scf_r0_solve _glp_scf_r0_solve
+void scf_r0_solve(SCF *scf, int tr, double x[/*1+n0*/]);
+/* solve system R0 * x = b or R0'* x = b */
+
+#define scf_s0_solve _glp_scf_s0_solve
+void scf_s0_solve(SCF *scf, int tr, double x[/*1+n0*/],
+      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/]);
+/* solve system S0 * x = b or S0'* x = b */
+
+#define scf_r_prod _glp_scf_r_prod
+void scf_r_prod(SCF *scf, double y[/*1+nn*/], double a, const double
+      x[/*1+n0*/]);
+/* compute product y := y + alpha * R * x */
+
+#define scf_rt_prod _glp_scf_rt_prod
+void scf_rt_prod(SCF *scf, double y[/*1+n0*/], double a, const double
+      x[/*1+nn*/]);
+/* compute product y := y + alpha * R'* x */
+
+#define scf_s_prod _glp_scf_s_prod
+void scf_s_prod(SCF *scf, double y[/*1+n0*/], double a, const double
+      x[/*1+nn*/]);
+/* compute product y := y + alpha * S * x */
+
+#define scf_st_prod _glp_scf_st_prod
+void scf_st_prod(SCF *scf, double y[/*1+nn*/], double a, const double
+      x[/*1+n0*/]);
+/* compute product y := y + alpha * S'* x */
+
+#define scf_a_solve _glp_scf_a_solve
+void scf_a_solve(SCF *scf, double x[/*1+n*/],
+      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],
+      double work2[/*1+n*/], double work3[/*1+n*/]);
+/* solve system A * x = b */
+
+#define scf_at_solve _glp_scf_at_solve
+void scf_at_solve(SCF *scf, double x[/*1+n*/],
+      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],
+      double work2[/*1+n*/], double work3[/*1+n*/]);
+/* solve system A'* x = b */
+
+#define scf_add_r_row _glp_scf_add_r_row
+void scf_add_r_row(SCF *scf, const double w[/*1+n0*/]);
+/* add new row to matrix R */
+
+#define scf_add_s_col _glp_scf_add_s_col
+void scf_add_s_col(SCF *scf, const double v[/*1+n0*/]);
+/* add new column to matrix S */
+
+#define scf_update_aug _glp_scf_update_aug
+int scf_update_aug(SCF *scf, double b[/*1+n0*/], double d[/*1+n0*/],
+      double f[/*1+nn*/], double g[/*1+nn*/], double h, int upd,
+      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/]);
+/* update factorization of augmented matrix */
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpgmp.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mygmp.c`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpgmp.c */
+/* mygmp.c (integer and rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2008-2015 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,85 +15,87 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#define _GLPSTD_STDIO
-#include "glpdmp.h"
-#include "glpgmp.h"
-#define xfault xerror
+#include "mygmp.h"
 
-#ifdef HAVE_GMP               /* use GNU MP bignum library */
+#ifdef HAVE_GMP               /* use GNU MP library */
 
-int gmp_pool_count(void) { return 0; }
+/* nothing is needed */
 
-void gmp_free_mem(void) { return; }
+#else                         /* use GLPK MP module */
 
-#else                         /* use GLPK bignum module */
+#include "bignum.h"
+#include "dmp.h"
+#include "env.h"
 
-static DMP *gmp_pool = NULL;
-static int gmp_size = 0;
-static unsigned short *gmp_work = NULL;
+#define gmp_pool env->gmp_pool
+#define gmp_size env->gmp_size
+#define gmp_work env->gmp_work
 
 void *gmp_get_atom(int size)
-{     if (gmp_pool == NULL)
+{     ENV *env = get_env_ptr();
+      if (gmp_pool == NULL)
          gmp_pool = dmp_create_pool();
       return dmp_get_atom(gmp_pool, size);
 }
 
 void gmp_free_atom(void *ptr, int size)
-{     xassert(gmp_pool != NULL);
+{     ENV *env = get_env_ptr();
+      xassert(gmp_pool != NULL);
       dmp_free_atom(gmp_pool, ptr, size);
       return;
 }
 
 int gmp_pool_count(void)
-{     if (gmp_pool == NULL)
+{     ENV *env = get_env_ptr();
+      if (gmp_pool == NULL)
          return 0;
       else
-         return dmp_in_use(gmp_pool).lo;
+         return dmp_in_use(gmp_pool);
 }
 
 unsigned short *gmp_get_work(int size)
-{     xassert(size > 0);
+{     ENV *env = get_env_ptr();
+      xassert(size > 0);
       if (gmp_size < size)
       {  if (gmp_size == 0)
          {  xassert(gmp_work == NULL);
             gmp_size = 100;
          }
          else
          {  xassert(gmp_work != NULL);
             xfree(gmp_work);
          }
-         while (gmp_size < size) gmp_size += gmp_size;
+         while (gmp_size < size)
+            gmp_size += gmp_size;
          gmp_work = xcalloc(gmp_size, sizeof(unsigned short));
       }
       return gmp_work;
 }
 
 void gmp_free_mem(void)
-{     if (gmp_pool != NULL) dmp_delete_pool(gmp_pool);
-      if (gmp_work != NULL) xfree(gmp_work);
+{     ENV *env = get_env_ptr();
+      if (gmp_pool != NULL)
+         dmp_delete_pool(gmp_pool);
+      if (gmp_work != NULL)
+         xfree(gmp_work);
       gmp_pool = NULL;
       gmp_size = 0;
       gmp_work = NULL;
       return;
 }
 
-/*====================================================================*/
+/*--------------------------------------------------------------------*/
 
 mpz_t _mpz_init(void)
-{     /* initialize x, and set its value to 0 */
+{     /* initialize x and set its value to 0 */
       mpz_t x;
       x = gmp_get_atom(sizeof(struct mpz));
       x->val = 0;
       x->ptr = NULL;
       return x;
 }
 
@@ -168,41 +167,43 @@
          deg = 1.0;
          for (e = x->ptr; e != NULL; e = e->next)
          {  for (j = 0; j <= 5; j++)
             {  val += deg * (double)((int)e->d[j]);
                deg *= 65536.0;
             }
          }
-         if (x->val < 0) val = - val;
+         if (x->val < 0)
+            val = - val;
       }
       return val;
 }
 
 double mpz_get_d_2exp(int *exp, mpz_t x)
 {     /* convert x to a double, truncating if necessary (i.e. rounding
-         towards zero), and returning the exponent separately;
-         the return value is in the range 0.5 <= |d| < 1 and the
-         exponent is stored to *exp; d*2^exp is the (truncated) x value;
-         if x is zero, the return is 0.0 and 0 is stored to *exp;
-         this is similar to the standard C frexp function */
+       * towards zero), and returning the exponent separately;
+       * the return value is in the range 0.5 <= |d| < 1 and the
+       * exponent is stored to *exp; d*2^exp is the (truncated) x value;
+       * if x is zero, the return is 0.0 and 0 is stored to *exp;
+       * this is similar to the standard C frexp function */
       struct mpz_seg *e;
       int j, n, n1;
       double val;
       if (x->ptr == NULL)
          val = (double)x->val, n = 0;
       else
       {  xassert(x->val != 0);
          val = 0.0, n = 0;
          for (e = x->ptr; e != NULL; e = e->next)
          {  for (j = 0; j <= 5; j++)
             {  val += (double)((int)e->d[j]);
                val /= 65536.0, n += 16;
             }
          }
-         if (x->val < 0) val = - val;
+         if (x->val < 0)
+            val = - val;
       }
       val = frexp(val, &n1);
       *exp = n + n1;
       return val;
 }
 
 void mpz_swap(mpz_t x, mpz_t y)
@@ -213,27 +214,28 @@
       x->val = y->val, x->ptr = y->ptr;
       y->val = val, y->ptr = ptr;
       return;
 }
 
 static void normalize(mpz_t x)
 {     /* normalize integer x that includes removing non-significant
-         (leading) zeros and converting to short format, if possible */
+       * (leading) zeros and converting to short format, if possible */
       struct mpz_seg *es, *e;
       /* if the integer is in short format, it remains unchanged */
       if (x->ptr == NULL)
       {  xassert(x->val != 0x80000000);
          goto done;
       }
       xassert(x->val == +1 || x->val == -1);
       /* find the last (most significant) non-zero segment */
       es = NULL;
       for (e = x->ptr; e != NULL; e = e->next)
       {  if (e->d[0] || e->d[1] || e->d[2] ||
-             e->d[3] || e->d[4] || e->d[5]) es = e;
+             e->d[3] || e->d[4] || e->d[5])
+            es = e;
       }
       /* if all segments contain zeros, the integer is zero */
       if (es == NULL)
       {  mpz_set_si(x, 0);
          goto done;
       }
       /* remove non-significant (leading) zero segments */
@@ -244,15 +246,16 @@
       }
       /* convert the integer to short format, if possible */
       e = x->ptr;
       if (e->next == NULL && e->d[1] <= 0x7FFF &&
          !e->d[2] && !e->d[3] && !e->d[4] && !e->d[5])
       {  int val;
          val = (int)e->d[0] + ((int)e->d[1] << 16);
-         if (x->val < 0) val = - val;
+         if (x->val < 0)
+            val = - val;
          mpz_set_si(x, val);
       }
 done: return;
 }
 
 void mpz_add(mpz_t z, mpz_t x, mpz_t y)
 {     /* set z to x + y */
@@ -329,16 +332,18 @@
       /* main fragment */
       sz = sx;
       ez = es = NULL;
       if (sx > 0 && sy > 0 || sx < 0 && sy < 0)
       {  /* [x] and [y] have identical signs -- addition */
          t = 0;
          for (; ex || ey; ex = ex->next, ey = ey->next)
-         {  if (ex == NULL) ex = &zero;
-            if (ey == NULL) ey = &zero;
+         {  if (ex == NULL)
+               ex = &zero;
+            if (ey == NULL)
+               ey = &zero;
             ee = gmp_get_atom(sizeof(struct mpz_seg));
             for (k = 0; k <= 5; k++)
             {  t += (unsigned int)ex->d[k];
                t += (unsigned int)ey->d[k];
                ee->d[k] = (unsigned short)t;
                t >>= 16;
             }
@@ -359,16 +364,18 @@
             es->next = ee;
          }
       }
       else
       {  /* [x] and [y] have different signs -- subtraction */
          t = 1;
          for (; ex || ey; ex = ex->next, ey = ey->next)
-         {  if (ex == NULL) ex = &zero;
-            if (ey == NULL) ey = &zero;
+         {  if (ex == NULL)
+               ex = &zero;
+            if (ey == NULL)
+               ey = &zero;
             ee = gmp_get_atom(sizeof(struct mpz_seg));
             for (k = 0; k <= 5; k++)
             {  t += (unsigned int)ex->d[k];
                t += (0xFFFF - (unsigned int)ey->d[k]);
                ee->d[k] = (unsigned short)t;
                t >>= 16;
             }
@@ -380,18 +387,19 @@
             es = ee;
          }
          if (!t)
          {  /* |[x]| < |[y]| -- result in complement coding */
             sz = - sz;
             t = 1;
             for (ee = ez; ee != NULL; ee = ee->next)
-            for (k = 0; k <= 5; k++)
-            {  t += (0xFFFF - (unsigned int)ee->d[k]);
-               ee->d[k] = (unsigned short)t;
-               t >>= 16;
+            {  for (k = 0; k <= 5; k++)
+               {  t += (0xFFFF - (unsigned int)ee->d[k]);
+                  ee->d[k] = (unsigned short)t;
+                  t >>= 16;
+               }
             }
          }
       }
       /* contruct and normalize result */
       mpz_set_si(z, 0);
       z->val = sz;
       z->ptr = ez;
@@ -402,15 +410,16 @@
 void mpz_sub(mpz_t z, mpz_t x, mpz_t y)
 {     /* set z to x - y */
       if (x == y)
          mpz_set_si(z, 0);
       else
       {  y->val = - y->val;
          mpz_add(z, x, y);
-         if (y != z) y->val = - y->val;
+         if (y != z)
+            y->val = - y->val;
       }
       return;
 }
 
 void mpz_mul(mpz_t z, mpz_t x, mpz_t y)
 {     /* set z to x * y */
       struct mpz_seg dumx, dumy, *ex, *ey, *es, *e;
@@ -429,16 +438,18 @@
          mpz_set_si(z, 0);
          goto done;
       }
       /* special case when both [x] and [y] are in short format */
       if (x->ptr == NULL && y->ptr == NULL)
       {  int xval = x->val, yval = y->val, sz = +1;
          xassert(xval != 0x80000000 && yval != 0x80000000);
-         if (xval < 0) xval = - xval, sz = - sz;
-         if (yval < 0) yval = - yval, sz = - sz;
+         if (xval < 0)
+            xval = - xval, sz = - sz;
+         if (yval < 0)
+            yval = - yval, sz = - sz;
          if (xval <= 0x7FFFFFFF / yval)
          {  mpz_set_si(z, sz * (xval * yval));
             goto done;
          }
       }
       /* convert [x] to long format, if necessary */
       if (x->ptr == NULL)
@@ -483,41 +494,52 @@
       {  sy = y->val;
          xassert(sy == +1 || sy == -1);
          ey = y->ptr;
       }
       /* determine the number of digits of [x] */
       nx = n = 0;
       for (e = ex; e != NULL; e = e->next)
-      for (k = 0; k <= 5; k++)
-      {  n++;
-         if (e->d[k]) nx = n;
+      {  for (k = 0; k <= 5; k++)
+         {  n++;
+            if (e->d[k])
+               nx = n;
+         }
       }
       xassert(nx > 0);
       /* determine the number of digits of [y] */
       ny = n = 0;
       for (e = ey; e != NULL; e = e->next)
-      for (k = 0; k <= 5; k++)
-      {  n++;
-         if (e->d[k]) ny = n;
+      {  for (k = 0; k <= 5; k++)
+         {  n++;
+            if (e->d[k])
+               ny = n;
+         }
       }
       xassert(ny > 0);
       /* we need working array containing at least nx+ny+ny places */
       work = gmp_get_work(nx+ny+ny);
       /* load digits of [x] */
       wx = &work[0];
-      for (n = 0; n < nx; n++) wx[ny+n] = 0;
+      for (n = 0; n < nx; n++)
+         wx[ny+n] = 0;
       for (n = 0, e = ex; e != NULL; e = e->next)
-         for (k = 0; k <= 5; k++, n++)
-            if (e->d[k]) wx[ny+n] = e->d[k];
+      {  for (k = 0; k <= 5; k++, n++)
+         {  if (e->d[k])
+               wx[ny+n] = e->d[k];
+         }
+      }
       /* load digits of [y] */
       wy = &work[nx+ny];
       for (n = 0; n < ny; n++) wy[n] = 0;
       for (n = 0, e = ey; e != NULL; e = e->next)
-         for (k = 0; k <= 5; k++, n++)
-            if (e->d[k]) wy[n] = e->d[k];
+      {  for (k = 0; k <= 5; k++, n++)
+         {  if (e->d[k])
+               wy[n] = e->d[k];
+         }
+      }
       /* compute [x] * [y] */
       bigmul(nx, ny, wx, wy);
       /* construct and normalize result */
       mpz_set_si(z, 0);
       z->val = sx * sy;
       es = NULL;
       k = 6;
@@ -546,50 +568,56 @@
       z->val = - z->val;
       return;
 }
 
 void mpz_abs(mpz_t z, mpz_t x)
 {     /* set z to the absolute value of x */
       mpz_set(z, x);
-      if (z->val < 0) z->val = - z->val;
+      if (z->val < 0)
+         z->val = - z->val;
       return;
 }
 
 void mpz_div(mpz_t q, mpz_t r, mpz_t x, mpz_t y)
 {     /* divide x by y, forming quotient q and/or remainder r
-         if q = NULL then quotient is not stored; if r = NULL then
-         remainder is not stored
-         the sign of quotient is determined as in algebra while the
-         sign of remainder is the same as the sign of dividend:
-         +26 : +7 = +3, remainder is +5
-         -26 : +7 = -3, remainder is -5
-         +26 : -7 = -3, remainder is +5
-         -26 : -7 = +3, remainder is -5 */
+       * if q = NULL then quotient is not stored; if r = NULL then
+       * remainder is not stored
+       * the sign of quotient is determined as in algebra while the
+       * sign of remainder is the same as the sign of dividend:
+       * +26 : +7 = +3, remainder is +5
+       * -26 : +7 = -3, remainder is -5
+       * +26 : -7 = -3, remainder is +5
+       * -26 : -7 = +3, remainder is -5 */
       struct mpz_seg dumx, dumy, *ex, *ey, *es, *e;
       int sx, sy, k, nx, ny, n;
       unsigned int t;
       unsigned short *work, *wx, *wy;
       /* divide by zero is not allowed */
       if (y->val == 0)
       {  xassert(y->ptr == NULL);
-         xfault("mpz_div: divide by zero not allowed\n");
+         xerror("mpz_div: divide by zero not allowed\n");
       }
       /* if [x] = 0 then [q] = [r] = 0 */
       if (x->val == 0)
       {  xassert(x->ptr == NULL);
-         if (q != NULL) mpz_set_si(q, 0);
-         if (r != NULL) mpz_set_si(r, 0);
+         if (q != NULL)
+            mpz_set_si(q, 0);
+         if (r != NULL)
+            mpz_set_si(r, 0);
          goto done;
       }
       /* special case when both [x] and [y] are in short format */
       if (x->ptr == NULL && y->ptr == NULL)
       {  int xval = x->val, yval = y->val;
          xassert(xval != 0x80000000 && yval != 0x80000000);
-         if (q != NULL) mpz_set_si(q, xval / yval);
-         if (r != NULL) mpz_set_si(r, xval % yval);
+         /* FIXME: use div function */
+         if (q != NULL)
+            mpz_set_si(q, xval / yval);
+         if (r != NULL)
+            mpz_set_si(r, xval % yval);
          goto done;
       }
       /* convert [x] to long format, if necessary */
       if (x->ptr == NULL)
       {  xassert(x->val != 0x80000000);
          if (x->val >= 0)
          {  sx = +1;
@@ -631,47 +659,57 @@
       {  sy = y->val;
          xassert(sy == +1 || sy == -1);
          ey = y->ptr;
       }
       /* determine the number of digits of [x] */
       nx = n = 0;
       for (e = ex; e != NULL; e = e->next)
-      for (k = 0; k <= 5; k++)
-      {  n++;
-         if (e->d[k]) nx = n;
+      {  for (k = 0; k <= 5; k++)
+         {  n++;
+            if (e->d[k])
+               nx = n;
+         }
       }
       xassert(nx > 0);
       /* determine the number of digits of [y] */
       ny = n = 0;
       for (e = ey; e != NULL; e = e->next)
-      for (k = 0; k <= 5; k++)
-      {  n++;
-         if (e->d[k]) ny = n;
+      {  for (k = 0; k <= 5; k++)
+         {  n++;
+            if (e->d[k])
+               ny = n;
+         }
       }
       xassert(ny > 0);
       /* if nx < ny then [q] = 0 and [r] = [x] */
       if (nx < ny)
-      {  if (r != NULL) mpz_set(r, x);
-         if (q != NULL) mpz_set_si(q, 0);
+      {  if (r != NULL)
+            mpz_set(r, x);
+         if (q != NULL)
+            mpz_set_si(q, 0);
          goto done;
       }
       /* we need working array containing at least nx+ny+1 places */
       work = gmp_get_work(nx+ny+1);
       /* load digits of [x] */
       wx = &work[0];
-      for (n = 0; n < nx; n++) wx[n] = 0;
+      for (n = 0; n < nx; n++)
+         wx[n] = 0;
       for (n = 0, e = ex; e != NULL; e = e->next)
-         for (k = 0; k <= 5; k++, n++)
+      {  for (k = 0; k <= 5; k++, n++)
             if (e->d[k]) wx[n] = e->d[k];
+      }
       /* load digits of [y] */
       wy = &work[nx+1];
-      for (n = 0; n < ny; n++) wy[n] = 0;
+      for (n = 0; n < ny; n++)
+         wy[n] = 0;
       for (n = 0, e = ey; e != NULL; e = e->next)
-         for (k = 0; k <= 5; k++, n++)
+      {  for (k = 0; k <= 5; k++, n++)
             if (e->d[k]) wy[n] = e->d[k];
+      }
       /* compute quotient and remainder */
       xassert(wy[ny-1] != 0);
       bigdiv(nx-ny, ny, wx, wy);
       /* construct and normalize quotient */
       if (q != NULL)
       {  mpz_set_si(q, 0);
          q->val = sx * sy;
@@ -719,15 +757,15 @@
       }
 done: return;
 }
 
 void mpz_gcd(mpz_t z, mpz_t x, mpz_t y)
 {     /* set z to the greatest common divisor of x and y */
       /* in case of arbitrary integers GCD(x, y) = GCD(|x|, |y|), and,
-         in particular, GCD(0, 0) = 0 */
+       * in particular, GCD(0, 0) = 0 */
       mpz_t u, v, r;
       mpz_init(u);
       mpz_init(v);
       mpz_init(r);
       mpz_abs(u, x);
       mpz_abs(v, y);
       while (mpz_sgn(v))
@@ -740,15 +778,15 @@
       mpz_clear(v);
       mpz_clear(r);
       return;
 }
 
 int mpz_cmp(mpz_t x, mpz_t y)
 {     /* compare x and y; return a positive value if x > y, zero if
-         x = y, or a nefative value if x < y */
+       * x = y, or a nefative value if x < y */
       static struct mpz_seg zero = { { 0, 0, 0, 0, 0, 0 }, NULL };
       struct mpz_seg dumx, dumy, *ex, *ey;
       int cc, sx, sy, k;
       unsigned int t;
       if (x == y)
       {  cc = 0;
          goto done;
@@ -813,19 +851,23 @@
          xassert(sy == +1 || sy == -1);
          ey = y->ptr;
       }
       /* main fragment */
       xassert(sx > 0 && sy > 0 || sx < 0 && sy < 0);
       cc = 0;
       for (; ex || ey; ex = ex->next, ey = ey->next)
-      {  if (ex == NULL) ex = &zero;
-         if (ey == NULL) ey = &zero;
+      {  if (ex == NULL)
+            ex = &zero;
+         if (ey == NULL)
+            ey = &zero;
          for (k = 0; k <= 5; k++)
-         {  if (ex->d[k] > ey->d[k]) cc = +1;
-            if (ex->d[k] < ey->d[k]) cc = -1;
+         {  if (ex->d[k] > ey->d[k])
+               cc = +1;
+            if (ex->d[k] < ey->d[k])
+               cc = -1;
          }
       }
       if (sx < 0) cc = - cc;
 done: return cc;
 }
 
 int mpz_sgn(mpz_t x)
@@ -833,24 +875,24 @@
       int s;
       s = (x->val > 0 ? +1 : x->val < 0 ? -1 : 0);
       return s;
 }
 
 int mpz_out_str(void *_fp, int base, mpz_t x)
 {     /* output x on stream fp, as a string in given base; the base
-         may vary from 2 to 36;
-         return the number of bytes written, or if an error occurred,
-         return 0 */
+       * may vary from 2 to 36;
+       * return the number of bytes written, or if an error occurred,
+       * return 0 */
       FILE *fp = _fp;
       mpz_t b, y, r;
       int n, j, nwr = 0;
       unsigned char *d;
       static char *set = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
       if (!(2 <= base && base <= 36))
-         xfault("mpz_out_str: base = %d; invalid base\n", base);
+         xerror("mpz_out_str: base = %d; invalid base\n", base);
       mpz_init(b);
       mpz_set_si(b, base);
       mpz_init(y);
       mpz_init(r);
       /* determine the number of digits */
       mpz_abs(y, x);
       for (n = 0; mpz_sgn(y) != 0; n++)
@@ -861,28 +903,30 @@
       mpz_abs(y, x);
       for (j = 0; j < n; j++)
       {  mpz_div(y, r, y, b);
          xassert(0 <= r->val && r->val < base && r->ptr == NULL);
          d[j] = (unsigned char)r->val;
       }
       /* output the integer to the stream */
-      /* if (fp == NULL) fp = stdout; */
+      if (fp == NULL)
+         fp = stdout;
       if (mpz_sgn(x) < 0)
          fputc('-', fp), nwr++;
       for (j = n-1; j >= 0; j--)
          fputc(set[d[j]], fp), nwr++;
-      if (ferror(fp)) nwr = 0;
+      if (ferror(fp))
+         nwr = 0;
       mpz_clear(b);
       mpz_clear(y);
       mpz_clear(r);
       xfree(d);
       return nwr;
 }
 
-/*====================================================================*/
+/*--------------------------------------------------------------------*/
 
 mpq_t _mpq_init(void)
 {     /* initialize x, and set its value to 0/1 */
       mpq_t x;
       x = gmp_get_atom(sizeof(struct mpq));
       x->p.val = 0;
       x->p.ptr = NULL;
@@ -900,15 +944,15 @@
       /* free the number descriptor */
       gmp_free_atom(x, sizeof(struct mpq));
       return;
 }
 
 void mpq_canonicalize(mpq_t x)
 {     /* remove any factors that are common to the numerator and
-         denominator of x, and make the denominator positive */
+       * denominator of x, and make the denominator positive */
       mpz_t f;
       xassert(x->q.val != 0);
       if (x->q.val < 0)
       {  mpz_neg(&x->p, &x->p);
          mpz_neg(&x->q, &x->q);
       }
       mpz_init(f);
@@ -929,15 +973,15 @@
       }
       return;
 }
 
 void mpq_set_si(mpq_t x, int p, unsigned int q)
 {     /* set the value of x to p/q */
       if (q == 0)
-         xfault("mpq_set_si: zero denominator not allowed\n");
+         xerror("mpq_set_si: zero denominator not allowed\n");
       mpz_set_si(&x->p, p);
       xassert(q <= 0x7FFFFFFF);
       mpz_set_si(&x->q, q);
       return;
 }
 
 double mpq_get_d(mpq_t x)
@@ -983,15 +1027,16 @@
             mpz_add(&x->p, &x->p, &x->p);
       }
       else if (n < 0)
       {  for (j = 1; j <= -n; j++)
             mpz_add(&x->q, &x->q, &x->q);
          mpq_canonicalize(x);
       }
-      if (s < 0) mpq_neg(x, x);
+      if (s < 0)
+         mpq_neg(x, x);
 done: return;
 }
 
 void mpq_add(mpq_t z, mpq_t x, mpq_t y)
 {     /* set z to x + y */
       mpz_t p, q;
       mpz_init(p);
@@ -1033,15 +1078,15 @@
       return;
 }
 
 void mpq_div(mpq_t z, mpq_t x, mpq_t y)
 {     /* set z to x / y */
       mpz_t p, q;
       if (mpq_sgn(y) == 0)
-         xfault("mpq_div: zero divisor not allowed\n");
+         xerror("mpq_div: zero divisor not allowed\n");
       mpz_init(p);
       mpz_init(q);
       mpz_mul(p, &x->p, &y->q);
       mpz_mul(q, &x->q, &y->p);
       mpz_set(&z->p, p);
       mpz_set(&z->q, q);
       mpz_clear(p);
@@ -1063,15 +1108,15 @@
       mpz_abs(&z->p, &z->p);
       xassert(mpz_sgn(&x->q) > 0);
       return;
 }
 
 int mpq_cmp(mpq_t x, mpq_t y)
 {     /* compare x and y; return a positive value if x > y, zero if
-         x = y, or a nefative value if x < y */
+       * x = y, or a negative value if x < y */
       mpq_t temp;
       int s;
       mpq_init(temp);
       mpq_sub(temp, x, y);
       s = mpq_sgn(temp);
       mpq_clear(temp);
       return s;
@@ -1083,31 +1128,33 @@
       s = mpz_sgn(&x->p);
       xassert(mpz_sgn(&x->q) > 0);
       return s;
 }
 
 int mpq_out_str(void *_fp, int base, mpq_t x)
 {     /* output x on stream fp, as a string in given base; the base
-         may vary from 2 to 36; output is in the form 'num/den' or if
-         the denominator is 1 then just 'num';
-         if the parameter fp is a null pointer, stdout is assumed;
-         return the number of bytes written, or if an error occurred,
-         return 0 */
+       * may vary from 2 to 36; output is in the form 'num/den' or if
+       * the denominator is 1 then just 'num';
+       * if the parameter fp is a null pointer, stdout is assumed;
+       * return the number of bytes written, or if an error occurred,
+       * return 0 */
       FILE *fp = _fp;
       int nwr;
       if (!(2 <= base && base <= 36))
-         xfault("mpq_out_str: base = %d; invalid base\n", base);
-      /* if (fp == NULL) fp = stdout; */
+         xerror("mpq_out_str: base = %d; invalid base\n", base);
+      if (fp == NULL)
+         fp = stdout;
       nwr = mpz_out_str(fp, base, &x->p);
       if (x->q.val == 1 && x->q.ptr == NULL)
          ;
       else
       {  fputc('/', fp), nwr++;
          nwr += mpz_out_str(fp, base, &x->q);
       }
-      if (ferror(fp)) nwr = 0;
+      if (ferror(fp))
+         nwr = 0;
       return nwr;
 }
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpgmp.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mygmp.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpgmp.h (bignum arithmetic) */
+/* mygmp.h (integer and rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2008-2015 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,59 +15,57 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPGMP_H
-#define GLPGMP_H
+#ifndef MYGMP_H
+#define MYGMP_H
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#ifdef HAVE_GMP               /* use GNU MP bignum library */
+#ifdef HAVE_GMP               /* use GNU MP library */
 
 #include <gmp.h>
 
-#define gmp_pool_count        _glp_gmp_pool_count
-#define gmp_free_mem          _glp_gmp_free_mem
+#define gmp_pool_count() 0
 
-int gmp_pool_count(void);
-void gmp_free_mem(void);
+#define gmp_free_mem() ((void)0)
 
-#else                         /* use GLPK bignum module */
+#else                         /* use GLPK MP module */
 
-/*----------------------------------------------------------------------
-// INTEGER NUMBERS
-//
-// Depending on its magnitude an integer number of arbitrary precision
-// is represented either in short format or in long format.
-//
-// Short format corresponds to the int type and allows representing
-// integer numbers in the range [-(2^31-1), +(2^31-1)]. Note that for
-// the most negative number of int type the short format is not used.
-//
-// In long format integer numbers are represented using the positional
-// system with the base (radix) 2^16 = 65536:
-//
-//    x = (-1)^s sum{j in 0..n-1} d[j] * 65536^j,
-//
-// where x is the integer to be represented, s is its sign (+1 or -1),
-// d[j] are its digits (0 <= d[j] <= 65535).
-//
-// RATIONAL NUMBERS
-//
-// A rational number is represented as an irreducible fraction:
-//
-//    p / q,
-//
-// where p (numerator) and q (denominator) are integer numbers (q > 0)
-// having no common divisors. */
+/***********************************************************************
+*  INTEGER NUMBERS
+*  ---------------
+*  Depending on its magnitude an integer number of arbitrary precision
+*  is represented either in short format or in long format.
+*
+*  Short format corresponds to the int type and allows representing
+*  integer numbers in the range [-(2^31-1), +(2^31-1)]. Note that for
+*  the most negative number of int type the short format is not used.
+*
+*  In long format integer numbers are represented using the positional
+*  system with the base (radix) 2^16 = 65536:
+*
+*     x = (-1)^s sum{j in 0..n-1} d[j] * 65536^j,
+*
+*  where x is the integer to be represented, s is its sign (+1 or -1),
+*  d[j] are its digits (0 <= d[j] <= 65535).
+*
+*  RATIONAL NUMBERS
+*  ----------------
+*  A rational number is represented as an irreducible fraction:
+*
+*     p / q,
+*
+*  where p (numerator) and q (denominator) are integer numbers (q > 0)
+*  having no common divisors. */
 
 struct mpz
 {     /* integer number */
       int val;
       /* if ptr is a null pointer, the number is in short format, and
          val is its value; otherwise, the number is in long format, and
          val is its sign (+1 or -1) */
@@ -95,96 +90,163 @@
       struct mpz q;
       /* denominator */
 };
 
 typedef struct mpz *mpz_t;
 typedef struct mpq *mpq_t;
 
-#define gmp_get_atom          _glp_gmp_get_atom
-#define gmp_free_atom         _glp_gmp_free_atom
-#define gmp_pool_count        _glp_gmp_pool_count
-#define gmp_get_work          _glp_gmp_get_work
-#define gmp_free_mem          _glp_gmp_free_mem
-
-#define _mpz_init             _glp_mpz_init
-#define mpz_clear             _glp_mpz_clear
-#define mpz_set               _glp_mpz_set
-#define mpz_set_si            _glp_mpz_set_si
-#define mpz_get_d             _glp_mpz_get_d
-#define mpz_get_d_2exp        _glp_mpz_get_d_2exp
-#define mpz_swap              _glp_mpz_swap
-#define mpz_add               _glp_mpz_add
-#define mpz_sub               _glp_mpz_sub
-#define mpz_mul               _glp_mpz_mul
-#define mpz_neg               _glp_mpz_neg
-#define mpz_abs               _glp_mpz_abs
-#define mpz_div               _glp_mpz_div
-#define mpz_gcd               _glp_mpz_gcd
-#define mpz_cmp               _glp_mpz_cmp
-#define mpz_sgn               _glp_mpz_sgn
-#define mpz_out_str           _glp_mpz_out_str
-
-#define _mpq_init             _glp_mpq_init
-#define mpq_clear             _glp_mpq_clear
-#define mpq_canonicalize      _glp_mpq_canonicalize
-#define mpq_set               _glp_mpq_set
-#define mpq_set_si            _glp_mpq_set_si
-#define mpq_get_d             _glp_mpq_get_d
-#define mpq_set_d             _glp_mpq_set_d
-#define mpq_add               _glp_mpq_add
-#define mpq_sub               _glp_mpq_sub
-#define mpq_mul               _glp_mpq_mul
-#define mpq_div               _glp_mpq_div
-#define mpq_neg               _glp_mpq_neg
-#define mpq_abs               _glp_mpq_abs
-#define mpq_cmp               _glp_mpq_cmp
-#define mpq_sgn               _glp_mpq_sgn
-#define mpq_out_str           _glp_mpq_out_str
-
+#define gmp_get_atom _glp_gmp_get_atom
 void *gmp_get_atom(int size);
+
+#define gmp_free_atom _glp_gmp_free_atom
 void gmp_free_atom(void *ptr, int size);
+
+#define gmp_pool_count _glp_gmp_pool_count
 int gmp_pool_count(void);
+
+#define gmp_get_work _glp_gmp_get_work
 unsigned short *gmp_get_work(int size);
+
+#define gmp_free_mem _glp_gmp_free_mem
 void gmp_free_mem(void);
 
-mpz_t _mpz_init(void);
 #define mpz_init(x) (void)((x) = _mpz_init())
+
+#define _mpz_init _glp_mpz_init
+mpz_t _mpz_init(void);
+/* initialize x and set its value to 0 */
+
+#define mpz_clear _glp_mpz_clear
 void mpz_clear(mpz_t x);
+/* free the space occupied by x */
+
+#define mpz_set _glp_mpz_set
 void mpz_set(mpz_t z, mpz_t x);
+/* set the value of z from x */
+
+#define mpz_set_si _glp_mpz_set_si
 void mpz_set_si(mpz_t x, int val);
+/* set the value of x to val */
+
+#define mpz_get_d _glp_mpz_get_d
 double mpz_get_d(mpz_t x);
+/* convert x to a double, truncating if necessary */
+
+#define mpz_get_d_2exp _glp_mpz_get_d_2exp
 double mpz_get_d_2exp(int *exp, mpz_t x);
+/* convert x to a double, returning the exponent separately */
+
+#define mpz_swap _glp_mpz_swap
 void mpz_swap(mpz_t x, mpz_t y);
+/* swap the values x and y efficiently */
+
+#define mpz_add _glp_mpz_add
 void mpz_add(mpz_t, mpz_t, mpz_t);
+/* set z to x + y */
+
+#define mpz_sub _glp_mpz_sub
 void mpz_sub(mpz_t, mpz_t, mpz_t);
+/* set z to x - y */
+
+#define mpz_mul _glp_mpz_mul
 void mpz_mul(mpz_t, mpz_t, mpz_t);
+/* set z to x * y */
+
+#define mpz_neg _glp_mpz_neg
 void mpz_neg(mpz_t z, mpz_t x);
+/* set z to 0 - x */
+
+#define mpz_abs _glp_mpz_abs
 void mpz_abs(mpz_t z, mpz_t x);
+/* set z to the absolute value of x */
+
+#define mpz_div _glp_mpz_div
 void mpz_div(mpz_t q, mpz_t r, mpz_t x, mpz_t y);
+/* divide x by y, forming quotient q and/or remainder r */
+
+#define mpz_gcd _glp_mpz_gcd
 void mpz_gcd(mpz_t z, mpz_t x, mpz_t y);
+/* set z to the greatest common divisor of x and y */
+
+#define mpz_cmp _glp_mpz_cmp
 int mpz_cmp(mpz_t x, mpz_t y);
+/* compare x and y */
+
+#define mpz_sgn _glp_mpz_sgn
 int mpz_sgn(mpz_t x);
+/* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */
+
+#define mpz_out_str _glp_mpz_out_str
 int mpz_out_str(void *fp, int base, mpz_t x);
+/* output x on stream fp, as a string in given base */
 
-mpq_t _mpq_init(void);
 #define mpq_init(x) (void)((x) = _mpq_init())
+
+#define _mpq_init _glp_mpq_init
+mpq_t _mpq_init(void);
+/* initialize x, and set its value to 0/1 */
+
+#define mpq_clear _glp_mpq_clear
 void mpq_clear(mpq_t x);
+/* free the space occupied by x */
+
+#define mpq_canonicalize _glp_mpq_canonicalize
 void mpq_canonicalize(mpq_t x);
+/* canonicalize x */
+
+#define mpq_set _glp_mpq_set
 void mpq_set(mpq_t z, mpq_t x);
+/* set the value of z from x */
+
+#define mpq_set_si _glp_mpq_set_si
 void mpq_set_si(mpq_t x, int p, unsigned int q);
+/* set the value of x to p/q */
+
+#define mpq_get_d _glp_mpq_get_d
 double mpq_get_d(mpq_t x);
+/* convert x to a double, truncating if necessary */
+
+#define mpq_set_d _glp_mpq_set_d
 void mpq_set_d(mpq_t x, double val);
+/* set x to val; there is no rounding, the conversion is exact */
+
+#define mpq_add _glp_mpq_add
 void mpq_add(mpq_t z, mpq_t x, mpq_t y);
+/* set z to x + y */
+
+#define mpq_sub _glp_mpq_sub
 void mpq_sub(mpq_t z, mpq_t x, mpq_t y);
+/* set z to x - y */
+
+#define mpq_mul _glp_mpq_mul
 void mpq_mul(mpq_t z, mpq_t x, mpq_t y);
+/* set z to x * y */
+
+#define mpq_div _glp_mpq_div
 void mpq_div(mpq_t z, mpq_t x, mpq_t y);
+/* set z to x / y */
+
+#define mpq_neg _glp_mpq_neg
 void mpq_neg(mpq_t z, mpq_t x);
+/* set z to 0 - x */
+
+#define mpq_abs _glp_mpq_abs
 void mpq_abs(mpq_t z, mpq_t x);
+/* set z to the absolute value of x */
+
+#define mpq_cmp _glp_mpq_cmp
 int mpq_cmp(mpq_t x, mpq_t y);
+/* compare x and y */
+
+#define mpq_sgn _glp_mpq_sgn
 int mpq_sgn(mpq_t x);
+/* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */
+
+#define mpq_out_str _glp_mpq_out_str
 int mpq_out_str(void *fp, int base, mpq_t x);
+/* output x on stream fp, as a string in given base */
 
 #endif
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glphbm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/hbm.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glphbm.c */
+/* hbm.c (Harwell-Boeing sparse matrix format) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2004-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,18 +15,17 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#define _GLPSTD_ERRNO
-#define _GLPSTD_STDIO
-#include "glphbm.h"
-#include "glpenv.h"
+#include "env.h"
+#include "hbm.h"
+#include "misc.h"
 
 /***********************************************************************
 *  NAME
 *
 *  hbm_read_mat - read sparse matrix in Harwell-Boeing format
 *
 *  SYNOPSIS
@@ -79,51 +75,62 @@
 /***********************************************************************
 *  read_card - read next data card
 *
 *  This routine reads the next 80-column card from the input text file
 *  and stores its image into the character string card. If the card was
 *  read successfully, the routine returns zero, otherwise non-zero. */
 
+#if 1 /* 11/III-2012 */
 static int read_card(struct dsa *dsa)
-{     int k, c;
+{     int c, len = 0;
+      char buf[255+1];
       dsa->seqn++;
-      memset(dsa->card, ' ', 80), dsa->card[80] = '\0';
-      k = 0;
       for (;;)
       {  c = fgetc(dsa->fp);
-         if (ferror(dsa->fp))
-         {  xprintf("%s:%d: read error - %s\n", dsa->fname, dsa->seqn,
-               strerror(errno));
-            return 1;
-         }
-         if (feof(dsa->fp))
-         {  if (k == 0)
-               xprintf("%s:%d: unexpected EOF\n", dsa->fname,
-                  dsa->seqn);
+         if (c == EOF)
+         {  if (ferror(dsa->fp))
+               xprintf("%s:%d: read error\n",
+                  dsa->fname, dsa->seqn);
             else
-               xprintf("%s:%d: missing final LF\n", dsa->fname,
-                  dsa->seqn);
+               xprintf("%s:%d: unexpected end-of-file\n",
+                  dsa->fname, dsa->seqn);
             return 1;
          }
-         if (c == '\r') continue;
-         if (c == '\n') break;
-         if (iscntrl(c))
-         {  xprintf("%s:%d: invalid control character 0x%02X\n",
+         else if (c == '\r')
+            /* nop */;
+         else if (c == '\n')
+            break;
+         else if (iscntrl(c))
+         {  xprintf("%s:%d: invalid control character\n",
                dsa->fname, dsa->seqn, c);
             return 1;
          }
-         if (k == 80)
-         {  xprintf("%s:%d: card image too long\n", dsa->fname,
-               dsa->seqn);
-            return 1;
+         else
+         {  if (len == sizeof(buf)-1)
+               goto err;
+            buf[len++] = (char)c;
          }
-         dsa->card[k++] = (char)c;
       }
+      /* remove trailing spaces */
+      while (len > 80 && buf[len-1] == ' ')
+         len--;
+      buf[len] = '\0';
+      /* line should not be longer than 80 chars */
+      if (len > 80)
+err:  {  xerror("%s:%d: card image too long\n",
+            dsa->fname, dsa->seqn);
+         return 1;
+      }
+      /* padd by spaces to 80-column card image */
+      strcpy(dsa->card, buf);
+      memset(&dsa->card[len], ' ', 80 - len);
+      dsa->card[80] = '\0';
       return 0;
 }
+#endif
 
 /***********************************************************************
 *  scan_int - scan integer value from the current card
 *
 *  This routine scans an integer value from the current card, where fld
 *  is the name of the field, pos is the position of the field, width is
 *  the width of the field, val points to a location to which the scanned
@@ -132,15 +139,15 @@
 
 static int scan_int(struct dsa *dsa, char *fld, int pos, int width,
       int *val)
 {     char str[80+1];
       xassert(1 <= width && width <= 80);
       memcpy(str, dsa->card + pos, width), str[width] = '\0';
       if (str2int(strspx(str), val))
-      {  xprintf("%s:%d: field `%s' contains invalid value `%s'\n",
+      {  xprintf("%s:%d: field '%s' contains invalid value '%s'\n",
             dsa->fname, dsa->seqn, fld, str);
          return 1;
       }
       return 0;
 }
 
 /***********************************************************************
@@ -153,15 +160,15 @@
 *  was recognised, the routine returns zero, otherwise non-zero. */
 
 static int parse_fmt(struct dsa *dsa, char *fmt)
 {     int k, s, val;
       char str[80+1];
       /* first character should be left parenthesis */
       if (fmt[0] != '(')
-fail: {  xprintf("hbm_read_mat: format `%s' not recognised\n", fmt);
+fail: {  xprintf("hbm_read_mat: format '%s' not recognised\n", fmt);
          return 1;
       }
       k = 1;
       /* optional scale factor */
       dsa->fmt_p = 0;
       if (isdigit((unsigned char)fmt[k]))
       {  s = 0;
@@ -237,29 +244,29 @@
       int n, int val[])
 {     int k, pos;
       char str[80+1];
       if (parse_fmt(dsa, fmt)) return 1;
       if (!(dsa->fmt_f == 'I' && dsa->fmt_w <= 80 &&
             dsa->fmt_k * dsa->fmt_w <= 80))
       {  xprintf(
-            "%s:%d: can't read array `%s' - invalid format `%s'\n",
+            "%s:%d: can't read array '%s' - invalid format '%s'\n",
             dsa->fname, dsa->seqn, name, fmt);
          return 1;
       }
       for (k = 1, pos = INT_MAX; k <= n; k++, pos++)
       {  if (pos >= dsa->fmt_k)
          {  if (read_card(dsa)) return 1;
             pos = 0;
          }
          memcpy(str, dsa->card + dsa->fmt_w * pos, dsa->fmt_w);
          str[dsa->fmt_w] = '\0';
          strspx(str);
          if (str2int(str, &val[k]))
          {  xprintf(
-               "%s:%d: can't read array `%s' - invalid value `%s'\n",
+               "%s:%d: can't read array '%s' - invalid value '%s'\n",
                dsa->fname, dsa->seqn, name, str);
             return 1;
          }
       }
       return 0;
 }
 
@@ -276,28 +283,28 @@
       int n, double val[])
 {     int k, pos;
       char str[80+1], *ptr;
       if (parse_fmt(dsa, fmt)) return 1;
       if (!(dsa->fmt_f != 'I' && dsa->fmt_w <= 80 &&
             dsa->fmt_k * dsa->fmt_w <= 80))
       {  xprintf(
-            "%s:%d: can't read array `%s' - invalid format `%s'\n",
+            "%s:%d: can't read array '%s' - invalid format '%s'\n",
             dsa->fname, dsa->seqn, name, fmt);
          return 1;
       }
       for (k = 1, pos = INT_MAX; k <= n; k++, pos++)
       {  if (pos >= dsa->fmt_k)
          {  if (read_card(dsa)) return 1;
             pos = 0;
          }
          memcpy(str, dsa->card + dsa->fmt_w * pos, dsa->fmt_w);
          str[dsa->fmt_w] = '\0';
          strspx(str);
          if (strchr(str, '.') == NULL && strcmp(str, "0"))
-         {  xprintf("%s(%d): can't read array `%s' - value `%s' has no "
+         {  xprintf("%s(%d): can't read array '%s' - value '%s' has no "
                "decimal point\n", dsa->fname, dsa->seqn, name, str);
             return 1;
          }
          /* sometimes lower case letters appear */
          for (ptr = str; *ptr; ptr++)
             *ptr = (char)toupper((unsigned char)*ptr);
          ptr = strchr(str, 'D');
@@ -310,32 +317,36 @@
          if (ptr != NULL && *(ptr-1) != 'E')
          {  xassert(strlen(str) < 80);
             memmove(ptr+1, ptr, strlen(ptr)+1);
             *ptr = 'E';
          }
          if (str2num(str, &val[k]))
          {  xprintf(
-               "%s:%d: can't read array `%s' - invalid value `%s'\n",
+               "%s:%d: can't read array '%s' - invalid value '%s'\n",
                dsa->fname, dsa->seqn, name, str);
             return 1;
          }
       }
       return 0;
 }
 
 HBM *hbm_read_mat(const char *fname)
 {     struct dsa _dsa, *dsa = &_dsa;
       HBM *hbm = NULL;
       dsa->fname = fname;
-      xprintf("hbm_read_mat: reading matrix from `%s'...\n",
+      xprintf("hbm_read_mat: reading matrix from '%s'...\n",
          dsa->fname);
       dsa->fp = fopen(dsa->fname, "r");
       if (dsa->fp == NULL)
-      {  xprintf("hbm_read_mat: unable to open `%s' - %s\n",
+      {  xprintf("hbm_read_mat: unable to open '%s' - %s\n",
+#if 0 /* 29/I-2017 */
             dsa->fname, strerror(errno));
+#else
+            dsa->fname, xstrerr(errno));
+#endif
          goto fail;
       }
       dsa->seqn = 0;
       hbm = xmalloc(sizeof(HBM));
       memset(hbm, 0, sizeof(HBM));
       /* read the first heading card */
       if (read_card(dsa)) goto fail;
@@ -357,15 +368,15 @@
          hbm->valcrd, hbm->rhscrd);
       /* read the third heading card */
       if (read_card(dsa)) goto fail;
       memcpy(hbm->mxtype, dsa->card, 3), hbm->mxtype[3] = '\0';
       if (strchr("RCP",   hbm->mxtype[0]) == NULL ||
           strchr("SUHZR", hbm->mxtype[1]) == NULL ||
           strchr("AE",    hbm->mxtype[2]) == NULL)
-      {  xprintf("%s:%d: matrix type `%s' not recognised\n",
+      {  xprintf("%s:%d: matrix type '%s' not recognised\n",
             dsa->fname, dsa->seqn, hbm->mxtype);
          goto fail;
       }
       if (scan_int(dsa, "nrow", 14, 14, &hbm->nrow)) goto fail;
       if (scan_int(dsa, "ncol", 28, 14, &hbm->ncol)) goto fail;
       if (scan_int(dsa, "nnzero", 42, 14, &hbm->nnzero)) goto fail;
       if (scan_int(dsa, "neltvl", 56, 14, &hbm->neltvl)) goto fail;
@@ -391,15 +402,15 @@
          hbm->nrhsix = 0;
       }
       else
       {  if (read_card(dsa)) goto fail;
          memcpy(hbm->rhstyp, dsa->card, 3), hbm->rhstyp[3] = '\0';
          if (scan_int(dsa, "nrhs", 14, 14, &hbm->nrhs)) goto fail;
          if (scan_int(dsa, "nrhsix", 28, 14, &hbm->nrhsix)) goto fail;
-         xprintf("rhstyp = `%s'; nrhs = %d; nrhsix = %d\n",
+         xprintf("rhstyp = '%s'; nrhs = %d; nrhsix = %d\n",
             hbm->rhstyp, hbm->nrhs, hbm->nrhsix);
       }
       /* read matrix structure */
       hbm->colptr = xcalloc(1+hbm->ncol+1, sizeof(int));
       if (read_int_array(dsa, "colptr", hbm->ptrfmt, hbm->ncol+1,
          hbm->colptr)) goto fail;
       hbm->rowind = xcalloc(1+hbm->nnzero, sizeof(int));
@@ -446,15 +457,15 @@
       else if (hbm->rhstyp[0] == 'M' && hbm->mxtype[2] == 'E')
       {  /* elemental format */
          hbm->rhsval = xcalloc(1+hbm->nrhsvl, sizeof(double));
          if (read_real_array(dsa, "rhsval", hbm->rhsfmt, hbm->nrhsvl,
             hbm->rhsval)) goto fail;
       }
       else
-      {  xprintf("%s:%d: right-hand side type `%c' not recognised\n",
+      {  xprintf("%s:%d: right-hand side type '%c' not recognised\n",
             dsa->fname, dsa->seqn, hbm->rhstyp[0]);
          goto fail;
       }
       /* read starting guesses */
       if (hbm->rhstyp[1] == 'G')
       {  hbm->nguess = hbm->nrow * hbm->nrhs;
          hbm->sguess = xcalloc(1+hbm->nguess, sizeof(double));
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glphbm.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/hbm.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glphbm.h (Harwell-Boeing sparse matrix format) */
+/* hbm.h (Harwell-Boeing sparse matrix format) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2004-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,16 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPHBM_H
-#define GLPHBM_H
+#ifndef HBM_H
+#define HBM_H
 
 typedef struct HBM HBM;
 
 struct HBM
 {     /* sparse matrix in Harwell-Boeing format; for details see the
          report: I.S.Duff, R.G.Grimes, J.G.Lewis. User's Guide for the
          Harwell-Boeing Sparse Matrix Collection (Release I), 1992 */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpini01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl5.c`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,14 @@
-/* glpini01.c */
+/* mpl5.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org> and Heinrich Schuchardt
+*  <xypron.glpk@gmx.de>
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,564 +16,547 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wself-assign"
+#if 1 /* 11/VI-2013 */
+#include "jd.h"
 #endif
+#include "mpl.h"
 
-#include "glpapi.h"
+double fn_gmtime(MPL *mpl)
+{     /* obtain the current calendar time (UTC) */
+      time_t timer;
+      struct tm *tm;
+      int j;
+      time(&timer);
+      if (timer == (time_t)(-1))
+err:     error(mpl, "gmtime(); unable to obtain current calendar time");
+#if 0 /* 29/I-2017 */
+      tm = gmtime(&timer);
+#else
+      tm = xgmtime(&timer);
+#endif
+      if (tm == NULL) goto err;
+      j = jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);
+      if (j < 0) goto err;
+      return (((double)(j - jday(1, 1, 1970)) * 24.0 +
+         (double)tm->tm_hour) * 60.0 + (double)tm->tm_min) * 60.0 +
+         (double)tm->tm_sec;
+}
 
-/*----------------------------------------------------------------------
--- triang - find maximal triangular part of a rectangular matrix.
---
--- *Synopsis*
---
--- int triang(int m, int n,
---    void *info, int (*mat)(void *info, int k, int ndx[]),
---    int rn[], int cn[]);
---
--- *Description*
---
--- For a given rectangular (sparse) matrix A with m rows and n columns
--- the routine triang tries to find such permutation matrices P and Q
--- that the first rows and columns of the matrix B = P*A*Q form a lower
--- triangular submatrix of as greatest size as possible:
---
---                   1                       n
---                1  * . . . . . . x x x x x x
---                   * * . . . . . x x x x x x
---                   * * * . . . . x x x x x x
---                   * * * * . . . x x x x x x
---    B = P*A*Q =    * * * * * . . x x x x x x
---                   * * * * * * . x x x x x x
---                   * * * * * * * x x x x x x
---                   x x x x x x x x x x x x x
---                   x x x x x x x x x x x x x
---                m  x x x x x x x x x x x x x
---
--- where: '*' - elements of the lower triangular part, '.' - structural
--- zeros, 'x' - other (either non-zero or zero) elements.
---
--- The parameter info is a transit pointer passed to the formal routine
--- mat (see below).
---
--- The formal routine mat specifies the given matrix A in both row- and
--- column-wise formats. In order to obtain an i-th row of the matrix A
--- the routine triang calls the routine mat with the parameter k = +i,
--- 1 <= i <= m. In response the routine mat should store column indices
--- of (non-zero) elements of the i-th row to the locations ndx[1], ...,
--- ndx[len], where len is number of non-zeros in the i-th row returned
--- on exit. Analogously, in order to obtain a j-th column of the matrix
--- A, the routine mat is called with the parameter k = -j, 1 <= j <= n,
--- and should return pattern of the j-th column in the same way as for
--- row patterns. Note that the routine mat may be called more than once
--- for the same rows and columns.
---
--- On exit the routine computes two resultant arrays rn and cn, which
--- define the permutation matrices P and Q, respectively. The array rn
--- should have at least 1+m locations, where rn[i] = i' (1 <= i <= m)
--- means that i-th row of the original matrix A corresponds to i'-th row
--- of the matrix B = P*A*Q. Similarly, the array cn should have at least
--- 1+n locations, where cn[j] = j' (1 <= j <= n) means that j-th column
--- of the matrix A corresponds to j'-th column of the matrix B.
---
--- *Returns*
---
--- The routine triang returns the size of the lower tringular part of
--- the matrix B = P*A*Q (see the figure above).
---
--- *Complexity*
---
--- The time complexity of the routine triang is O(nnz), where nnz is
--- number of non-zeros in the given matrix A.
---
--- *Algorithm*
---
--- The routine triang starts from the matrix B = P*Q*A, where P and Q
--- are unity matrices, so initially B = A.
---
--- Before the next iteration B = (B1 | B2 | B3), where B1 is partially
--- built a lower triangular submatrix, B2 is the active submatrix, and
--- B3 is a submatrix that contains rejected columns. Thus, the current
--- matrix B looks like follows (initially k1 = 1 and k2 = n):
---
---       1         k1         k2         n
---    1  x . . . . . . . . . . . . . # # #
---       x x . . . . . . . . . . . . # # #
---       x x x . . . . . . . . . . # # # #
---       x x x x . . . . . . . . . # # # #
---       x x x x x . . . . . . . # # # # #
---    k1 x x x x x * * * * * * * # # # # #
---       x x x x x * * * * * * * # # # # #
---       x x x x x * * * * * * * # # # # #
---       x x x x x * * * * * * * # # # # #
---    m  x x x x x * * * * * * * # # # # #
---       <--B1---> <----B2-----> <---B3-->
---
--- On each iteartion the routine looks for a singleton row, i.e. some
--- row that has the only non-zero in the active submatrix B2. If such
--- row exists and the corresponding non-zero is b[i,j], where (by the
--- definition) k1 <= i <= m and k1 <= j <= k2, the routine permutes
--- k1-th and i-th rows and k1-th and j-th columns of the matrix B (in
--- order to place the element in the position b[k1,k1]), removes the
--- k1-th column from the active submatrix B2, and adds this column to
--- the submatrix B1. If no row singletons exist, but B2 is not empty
--- yet, the routine chooses a j-th column, which has maximal number of
--- non-zeros among other columns of B2, removes this column from B2 and
--- adds it to the submatrix B3 in the hope that new row singletons will
--- appear in the active submatrix. */
-
-static int triang(int m, int n,
-      void *info, int (*mat)(void *info, int k, int ndx[]),
-      int rn[], int cn[])
-{     int *ndx; /* int ndx[1+max(m,n)]; */
-      /* this array is used for querying row and column patterns of the
-         given matrix A (the third parameter to the routine mat) */
-      int *rs_len; /* int rs_len[1+m]; */
-      /* rs_len[0] is not used;
-         rs_len[i], 1 <= i <= m, is number of non-zeros in the i-th row
-         of the matrix A, which (non-zeros) belong to the current active
-         submatrix */
-      int *rs_head; /* int rs_head[1+n]; */
-      /* rs_head[len], 0 <= len <= n, is the number i of the first row
-         of the matrix A, for which rs_len[i] = len */
-      int *rs_prev; /* int rs_prev[1+m]; */
-      /* rs_prev[0] is not used;
-         rs_prev[i], 1 <= i <= m, is a number i' of the previous row of
-         the matrix A, for which rs_len[i] = rs_len[i'] (zero marks the
-         end of this linked list) */
-      int *rs_next; /* int rs_next[1+m]; */
-      /* rs_next[0] is not used;
-         rs_next[i], 1 <= i <= m, is a number i' of the next row of the
-         matrix A, for which rs_len[i] = rs_len[i'] (zero marks the end
-         this linked list) */
-      int cs_head;
-      /* is a number j of the first column of the matrix A, which has
-         maximal number of non-zeros among other columns */
-      int *cs_prev; /* cs_prev[1+n]; */
-      /* cs_prev[0] is not used;
-         cs_prev[j], 1 <= j <= n, is a number of the previous column of
-         the matrix A with the same or greater number of non-zeros than
-         in the j-th column (zero marks the end of this linked list) */
-      int *cs_next; /* cs_next[1+n]; */
-      /* cs_next[0] is not used;
-         cs_next[j], 1 <= j <= n, is a number of the next column of
-         the matrix A with the same or lesser number of non-zeros than
-         in the j-th column (zero marks the end of this linked list) */
-      int i, j, ii, jj, k1, k2, len, t, size = 0;
-      int *head, *rn_inv, *cn_inv;
-      if (!(m > 0 && n > 0))
-         xerror("triang: m = %d; n = %d; invalid dimension\n", m, n);
-      /* allocate working arrays */
-      ndx = xcalloc(1+(m >= n ? m : n), sizeof(int));
-      rs_len = xcalloc(1+m, sizeof(int));
-      rs_head = xcalloc(1+n, sizeof(int));
-      rs_prev = xcalloc(1+m, sizeof(int));
-      rs_next = xcalloc(1+m, sizeof(int));
-      cs_prev = xcalloc(1+n, sizeof(int));
-      cs_next = xcalloc(1+n, sizeof(int));
-      /* build linked lists of columns of the matrix A with the same
-         number of non-zeros */
-      head = rs_len; /* currently rs_len is used as working array */
-      for (len = 0; len <= m; len ++) head[len] = 0;
-      for (j = 1; j <= n; j++)
-      {  /* obtain length of the j-th column */
-         len = mat(info, -j, ndx);
-         xassert(0 <= len && len <= m);
-         /* include the j-th column in the corresponding linked list */
-         cs_prev[j] = head[len];
-         head[len] = j;
-      }
-      /* merge all linked lists of columns in one linked list, where
-         columns are ordered by descending of their lengths */
-      cs_head = 0;
-      for (len = 0; len <= m; len++)
-      {  for (j = head[len]; j != 0; j = cs_prev[j])
-         {  cs_next[j] = cs_head;
-            cs_head = j;
-         }
-      }
-      jj = 0;
-      for (j = cs_head; j != 0; j = cs_next[j])
-      {  cs_prev[j] = jj;
-         jj = j;
-      }
-      /* build initial doubly linked lists of rows of the matrix A with
-         the same number of non-zeros */
-      for (len = 0; len <= n; len++) rs_head[len] = 0;
-      for (i = 1; i <= m; i++)
-      {  /* obtain length of the i-th row */
-         rs_len[i] = len = mat(info, +i, ndx);
-         xassert(0 <= len && len <= n);
-         /* include the i-th row in the correspondng linked list */
-         rs_prev[i] = 0;
-         rs_next[i] = rs_head[len];
-         if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;
-         rs_head[len] = i;
-      }
-      /* initially all rows and columns of the matrix A are active */
-      for (i = 1; i <= m; i++) rn[i] = 0;
-      for (j = 1; j <= n; j++) cn[j] = 0;
-      /* set initial bounds of the active submatrix */
-      k1 = 1, k2 = n;
-      /* main loop starts here */
-      while (k1 <= k2)
-      {  i = rs_head[1];
-         if (i != 0)
-         {  /* the i-th row of the matrix A is a row singleton, since
-               it has the only non-zero in the active submatrix */
-            xassert(rs_len[i] == 1);
-            /* determine the number j of an active column of the matrix
-               A, in which this non-zero is placed */
-            j = 0;
-            t = mat(info, +i, ndx);
-            xassert(0 <= t && t <= n);
-            for (t = t; t >= 1; t--)
-            {  jj = ndx[t];
-               xassert(1 <= jj && jj <= n);
-               if (cn[jj] == 0)
-               {  xassert(j == 0);
-                  j = jj;
+static char *week[] = { "Monday", "Tuesday", "Wednesday", "Thursday",
+      "Friday", "Saturday", "Sunday" };
+
+static char *moon[] = { "January", "February", "March", "April", "May",
+      "June", "July", "August", "September", "October", "November",
+      "December" };
+
+static void error1(MPL *mpl, const char *str, const char *s,
+      const char *fmt, const char *f, const char *msg)
+{     xprintf("Input string passed to str2time:\n");
+      xprintf("%s\n", str);
+      xprintf("%*s\n", (s - str) + 1, "^");
+      xprintf("Format string passed to str2time:\n");
+      xprintf("%s\n", fmt);
+      xprintf("%*s\n", (f - fmt) + 1, "^");
+      error(mpl, "%s", msg);
+      /* no return */
+}
+
+double fn_str2time(MPL *mpl, const char *str, const char *fmt)
+{     /* convert character string to the calendar time */
+      int j, year, month, day, hh, mm, ss, zone;
+      const char *s, *f;
+      year = month = day = hh = mm = ss = -1, zone = INT_MAX;
+      s = str;
+      for (f = fmt; *f != '\0'; f++)
+      {  if (*f == '%')
+         {  f++;
+            if (*f == 'b' || *f == 'h')
+            {  /* the abbreviated month name */
+               int k;
+               char *name;
+               if (month >= 0)
+                  error1(mpl, str, s, fmt, f, "month multiply specified"
+                     );
+               while (*s == ' ') s++;
+               for (month = 1; month <= 12; month++)
+               {  name = moon[month-1];
+                  for (k = 0; k <= 2; k++)
+                  {  if (toupper((unsigned char)s[k]) !=
+                         toupper((unsigned char)name[k])) goto next;
+                  }
+                  s += 3;
+                  for (k = 3; name[k] != '\0'; k++)
+                  {  if (toupper((unsigned char)*s) !=
+                         toupper((unsigned char)name[k])) break;
+                     s++;
+                  }
+                  break;
+next:             ;
                }
+               if (month > 12)
+                  error1(mpl, str, s, fmt, f, "abbreviated month name m"
+                     "issing or invalid");
+            }
+            else if (*f == 'd')
+            {  /* the day of the month as a decimal number (01..31) */
+               if (day >= 0)
+                  error1(mpl, str, s, fmt, f, "day multiply specified");
+               while (*s == ' ') s++;
+               if (!('0' <= *s && *s <= '9'))
+                  error1(mpl, str, s, fmt, f, "day missing or invalid");
+               day = (*s++) - '0';
+               if ('0' <= *s && *s <= '9')
+                  day = 10 * day + ((*s++) - '0');
+               if (!(1 <= day && day <= 31))
+                  error1(mpl, str, s, fmt, f, "day out of range");
+            }
+            else if (*f == 'H')
+            {  /* the hour as a decimal number, using a 24-hour clock
+                  (00..23) */
+               if (hh >= 0)
+                  error1(mpl, str, s, fmt, f, "hour multiply specified")
+                     ;
+               while (*s == ' ') s++;
+               if (!('0' <= *s && *s <= '9'))
+                  error1(mpl, str, s, fmt, f, "hour missing or invalid")
+                     ;
+               hh = (*s++) - '0';
+               if ('0' <= *s && *s <= '9')
+                  hh = 10 * hh + ((*s++) - '0');
+               if (!(0 <= hh && hh <= 23))
+                  error1(mpl, str, s, fmt, f, "hour out of range");
+            }
+            else if (*f == 'm')
+            {  /* the month as a decimal number (01..12) */
+               if (month >= 0)
+                  error1(mpl, str, s, fmt, f, "month multiply specified"
+                     );
+               while (*s == ' ') s++;
+               if (!('0' <= *s && *s <= '9'))
+                  error1(mpl, str, s, fmt, f, "month missing or invalid"
+                     );
+               month = (*s++) - '0';
+               if ('0' <= *s && *s <= '9')
+                  month = 10 * month + ((*s++) - '0');
+               if (!(1 <= month && month <= 12))
+                  error1(mpl, str, s, fmt, f, "month out of range");
+            }
+            else if (*f == 'M')
+            {  /* the minute as a decimal number (00..59) */
+               if (mm >= 0)
+                  error1(mpl, str, s, fmt, f, "minute multiply specifie"
+                     "d");
+               while (*s == ' ') s++;
+               if (!('0' <= *s && *s <= '9'))
+                  error1(mpl, str, s, fmt, f, "minute missing or invali"
+                     "d");
+               mm = (*s++) - '0';
+               if ('0' <= *s && *s <= '9')
+                  mm = 10 * mm + ((*s++) - '0');
+               if (!(0 <= mm && mm <= 59))
+                  error1(mpl, str, s, fmt, f, "minute out of range");
+            }
+            else if (*f == 'S')
+            {  /* the second as a decimal number (00..60) */
+               if (ss >= 0)
+                  error1(mpl, str, s, fmt, f, "second multiply specifie"
+                     "d");
+               while (*s == ' ') s++;
+               if (!('0' <= *s && *s <= '9'))
+                  error1(mpl, str, s, fmt, f, "second missing or invali"
+                     "d");
+               ss = (*s++) - '0';
+               if ('0' <= *s && *s <= '9')
+                  ss = 10 * ss + ((*s++) - '0');
+               if (!(0 <= ss && ss <= 60))
+                  error1(mpl, str, s, fmt, f, "second out of range");
+            }
+            else if (*f == 'y')
+            {  /* the year without a century as a decimal number
+                  (00..99); the values 00 to 68 mean the years 2000 to
+                  2068 while the values 69 to 99 mean the years 1969 to
+                  1999 */
+               if (year >= 0)
+                  error1(mpl, str, s, fmt, f, "year multiply specified")
+                     ;
+               while (*s == ' ') s++;
+               if (!('0' <= *s && *s <= '9'))
+                  error1(mpl, str, s, fmt, f, "year missing or invalid")
+                     ;
+               year = (*s++) - '0';
+               if ('0' <= *s && *s <= '9')
+                  year = 10 * year + ((*s++) - '0');
+               year += (year >= 69 ? 1900 : 2000);
+            }
+            else if (*f == 'Y')
+            {  /* the year as a decimal number, using the Gregorian
+                  calendar */
+               if (year >= 0)
+                  error1(mpl, str, s, fmt, f, "year multiply specified")
+                     ;
+               while (*s == ' ') s++;
+               if (!('0' <= *s && *s <= '9'))
+                  error1(mpl, str, s, fmt, f, "year missing or invalid")
+                     ;
+               year = 0;
+               for (j = 1; j <= 4; j++)
+               {  if (!('0' <= *s && *s <= '9')) break;
+                  year = 10 * year + ((*s++) - '0');
+               }
+               if (!(1 <= year && year <= 4000))
+                  error1(mpl, str, s, fmt, f, "year out of range");
+            }
+            else if (*f == 'z')
+            {  /* time zone offset in the form zhhmm */
+               int z, hh, mm;
+               if (zone != INT_MAX)
+                  error1(mpl, str, s, fmt, f, "time zone offset multipl"
+                     "y specified");
+               while (*s == ' ') s++;
+               if (*s == 'Z')
+               {  z = hh = mm = 0, s++;
+                  goto skip;
+               }
+               if (*s == '+')
+                  z = +1, s++;
+               else if (*s == '-')
+                  z = -1, s++;
+               else
+                  error1(mpl, str, s, fmt, f, "time zone offset sign mi"
+                     "ssing");
+               hh = 0;
+               for (j = 1; j <= 2; j++)
+               {  if (!('0' <= *s && *s <= '9'))
+err1:                error1(mpl, str, s, fmt, f, "time zone offset valu"
+                        "e incomplete or invalid");
+                  hh = 10 * hh + ((*s++) - '0');
+               }
+               if (hh > 23)
+err2:             error1(mpl, str, s, fmt, f, "time zone offset value o"
+                     "ut of range");
+               if (*s == ':')
+               {  s++;
+                  if (!('0' <= *s && *s <= '9')) goto err1;
+               }
+               mm = 0;
+               if (!('0' <= *s && *s <= '9')) goto skip;
+               for (j = 1; j <= 2; j++)
+               {  if (!('0' <= *s && *s <= '9')) goto err1;
+                  mm = 10 * mm + ((*s++) - '0');
+               }
+               if (mm > 59) goto err2;
+skip:          zone = z * (60 * hh + mm);
+            }
+            else if (*f == '%')
+            {  /* literal % character */
+               goto test;
             }
-            xassert(j != 0);
-            /* the singleton is a[i,j]; move a[i,j] to the position
-               b[k1,k1] of the matrix B */
-            rn[i] = cn[j] = k1;
-            /* shift the left bound of the active submatrix */
-            k1++;
-            /* increase the size of the lower triangular part */
-            size++;
-         }
-         else
-         {  /* the current active submatrix has no row singletons */
-            /* remove an active column with maximal number of non-zeros
-               from the active submatrix */
-            j = cs_head;
-            xassert(j != 0);
-            cn[j] = k2;
-            /* shift the right bound of the active submatrix */
-            k2--;
-         }
-         /* the j-th column of the matrix A has been removed from the
-            active submatrix */
-         /* remove the j-th column from the linked list */
-         if (cs_prev[j] == 0)
-            cs_head = cs_next[j];
-         else
-            cs_next[cs_prev[j]] = cs_next[j];
-         if (cs_next[j] == 0)
-            /* nop */;
-         else
-            cs_prev[cs_next[j]] = cs_prev[j];
-         /* go through non-zeros of the j-th columns and update active
-            lengths of the corresponding rows */
-         t = mat(info, -j, ndx);
-         xassert(0 <= t && t <= m);
-         for (t = t; t >= 1; t--)
-         {  i = ndx[t];
-            xassert(1 <= i && i <= m);
-            /* the non-zero a[i,j] has left the active submatrix */
-            len = rs_len[i];
-            xassert(len >= 1);
-            /* remove the i-th row from the linked list of rows with
-               active length len */
-            if (rs_prev[i] == 0)
-               rs_head[len] = rs_next[i];
-            else
-               rs_next[rs_prev[i]] = rs_next[i];
-            if (rs_next[i] == 0)
-               /* nop */;
             else
-               rs_prev[rs_next[i]] = rs_prev[i];
-            /* decrease the active length of the i-th row */
-            rs_len[i] = --len;
-            /* return the i-th row to the corresponding linked list */
-            rs_prev[i] = 0;
-            rs_next[i] = rs_head[len];
-            if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;
-            rs_head[len] = i;
+               error1(mpl, str, s, fmt, f, "invalid conversion specifie"
+                  "r");
          }
-      }
-      /* other rows of the matrix A, which are still active, correspond
-         to rows k1, ..., m of the matrix B (in arbitrary order) */
-      for (i = 1; i <= m; i++) if (rn[i] == 0) rn[i] = k1++;
-      /* but for columns this is not needed, because now the submatrix
-         B2 has no columns */
-      for (j = 1; j <= n; j++) xassert(cn[j] != 0);
-      /* perform some optional checks */
-      /* make sure that rn is a permutation of {1, ..., m} and cn is a
-         permutation of {1, ..., n} */
-      rn_inv = rs_len; /* used as working array */
-      for (ii = 1; ii <= m; ii++) rn_inv[ii] = 0;
-      for (i = 1; i <= m; i++)
-      {  ii = rn[i];
-         xassert(1 <= ii && ii <= m);
-         xassert(rn_inv[ii] == 0);
-         rn_inv[ii] = i;
-      }
-      cn_inv = rs_head; /* used as working array */
-      for (jj = 1; jj <= n; jj++) cn_inv[jj] = 0;
-      for (j = 1; j <= n; j++)
-      {  jj = cn[j];
-         xassert(1 <= jj && jj <= n);
-         xassert(cn_inv[jj] == 0);
-         cn_inv[jj] = j;
-      }
-      /* make sure that the matrix B = P*A*Q really has the form, which
-         was declared */
-      for (ii = 1; ii <= size; ii++)
-      {  int diag = 0;
-         i = rn_inv[ii];
-         t = mat(info, +i, ndx);
-         xassert(0 <= t && t <= n);
-         for (t = t; t >= 1; t--)
-         {  j = ndx[t];
-            xassert(1 <= j && j <= n);
-            jj = cn[j];
-            if (jj <= size) xassert(jj <= ii);
-            if (jj == ii)
-            {  xassert(!diag);
-               diag = 1;
-            }
+         else if (*f == ' ')
+            ;
+         else
+test:    {  /* check a matching character in the input string */
+            if (*s != *f)
+               error1(mpl, str, s, fmt, f, "character mismatch");
+            s++;
          }
-         xassert(diag);
       }
-      /* free working arrays */
-      xfree(ndx);
-      xfree(rs_len);
-      xfree(rs_head);
-      xfree(rs_prev);
-      xfree(rs_next);
-      xfree(cs_prev);
-      xfree(cs_next);
-      /* return to the calling program */
-      return size;
+      if (year < 0) year = 1970;
+      if (month < 0) month = 1;
+      if (day < 0) day = 1;
+      if (hh < 0) hh = 0;
+      if (mm < 0) mm = 0;
+      if (ss < 0) ss = 0;
+      if (zone == INT_MAX) zone = 0;
+      j = jday(day, month, year);
+      xassert(j >= 0);
+      return (((double)(j - jday(1, 1, 1970)) * 24.0 + (double)hh) *
+         60.0 + (double)mm) * 60.0 + (double)ss - 60.0 * (double)zone;
 }
 
-/*----------------------------------------------------------------------
--- adv_basis - construct advanced initial LP basis.
---
--- *Synopsis*
---
--- #include "glpini.h"
--- void adv_basis(glp_prob *lp);
---
--- *Description*
---
--- The routine adv_basis constructs an advanced initial basis for an LP
--- problem object, which the parameter lp points to.
---
--- In order to build the initial basis the routine does the following:
---
--- 1) includes in the basis all non-fixed auxiliary variables;
---
--- 2) includes in the basis as many as possible non-fixed structural
---    variables preserving triangular form of the basis matrix;
---
--- 3) includes in the basis appropriate (fixed) auxiliary variables
---    in order to complete the basis.
---
--- As a result the initial basis has minimum of fixed variables and the
--- corresponding basis matrix is triangular. */
-
-static int mat(void *info, int k, int ndx[])
-{     /* this auxiliary routine returns the pattern of a given row or
-         a given column of the augmented constraint matrix A~ = (I|-A),
-         in which columns of fixed variables are implicitly cleared */
-      LPX *lp = info;
-      int m = lpx_get_num_rows(lp);
-      int n = lpx_get_num_cols(lp);
-      int typx, i, j, lll, len = 0;
-      if (k > 0)
-      {  /* the pattern of the i-th row is required */
-         i = +k;
-         xassert(1 <= i && i <= m);
-#if 0 /* 22/XII-2003 */
-         /* if the auxiliary variable x[i] is non-fixed, include its
-            element (placed in the i-th column) in the pattern */
-         lpx_get_row_bnds(lp, i, &typx, NULL, NULL);
-         if (typx != LPX_FX) ndx[++len] = i;
-         /* include in the pattern elements placed in columns, which
-            correspond to non-fixed structural varables */
-         i_beg = aa_ptr[i];
-         i_end = i_beg + aa_len[i] - 1;
-         for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-         {  j = m + sv_ndx[i_ptr];
-            lpx_get_col_bnds(lp, j-m, &typx, NULL, NULL);
-            if (typx != LPX_FX) ndx[++len] = j;
-         }
-#else
-         lll = lpx_get_mat_row(lp, i, ndx, NULL);
-         for (k = 1; k <= lll; k++)
-         {  lpx_get_col_bnds(lp, ndx[k], &typx, NULL, NULL);
-            if (typx != LPX_FX) ndx[++len] = m + ndx[k];
-         }
-         lpx_get_row_bnds(lp, i, &typx, NULL, NULL);
-         if (typx != LPX_FX) ndx[++len] = i;
-#endif
-      }
-      else
-      {  /* the pattern of the j-th column is required */
-         j = -k;
-         xassert(1 <= j && j <= m+n);
-         /* if the (auxiliary or structural) variable x[j] is fixed,
-            the pattern of its column is empty */
-         if (j <= m)
-            lpx_get_row_bnds(lp, j, &typx, NULL, NULL);
-         else
-            lpx_get_col_bnds(lp, j-m, &typx, NULL, NULL);
-         if (typx != LPX_FX)
-         {  if (j <= m)
-            {  /* x[j] is non-fixed auxiliary variable */
-               ndx[++len] = j;
-            }
-            else
-            {  /* x[j] is non-fixed structural variables */
-#if 0 /* 22/XII-2003 */
-               j_beg = aa_ptr[j];
-               j_end = j_beg + aa_len[j] - 1;
-               for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
-                  ndx[++len] = sv_ndx[j_ptr];
-#else
-               len = lpx_get_mat_col(lp, j-m, ndx, NULL);
-#endif
-            }
-         }
-      }
-      /* return the length of the row/column pattern */
-      return len;
+static void error2(MPL *mpl, const char *fmt, const char *f,
+      const char *msg)
+{     xprintf("Format string passed to time2str:\n");
+      xprintf("%s\n", fmt);
+      xprintf("%*s\n", (f - fmt) + 1, "^");
+      error(mpl, "%s", msg);
+      /* no return */
 }
 
-static void adv_basis(glp_prob *lp)
-{     int m = lpx_get_num_rows(lp);
-      int n = lpx_get_num_cols(lp);
-      int i, j, jj, k, size;
-      int *rn, *cn, *rn_inv, *cn_inv;
-      int typx, *tagx = xcalloc(1+m+n, sizeof(int));
-      double lb, ub;
-      xprintf("Constructing initial basis...\n");
-#if 0 /* 13/V-2009 */
-      if (m == 0)
-         xerror("glp_adv_basis: problem has no rows\n");
-      if (n == 0)
-         xerror("glp_adv_basis: problem has no columns\n");
-#else
-      if (m == 0 || n == 0)
-      {  glp_std_basis(lp);
-         return;
+static int weekday(int j)
+{     /* determine weekday number (1 = Mon, ..., 7 = Sun) */
+      return (j + jday(1, 1, 1970)) % 7 + 1;
+}
+
+static int firstday(int year)
+{     /* determine the first day of the first week for a specified year
+         according to ISO 8601 */
+      int j;
+      /* if 1 January is Monday, Tuesday, Wednesday or Thursday, it is
+         in week 01; if 1 January is Friday, Saturday or Sunday, it is
+         in week 52 or 53 of the previous year */
+      j = jday(1, 1, year) - jday(1, 1, 1970);
+      switch (weekday(j))
+      {  case 1: /* 1 Jan is Mon */ j += 0; break;
+         case 2: /* 1 Jan is Tue */ j -= 1; break;
+         case 3: /* 1 Jan is Wed */ j -= 2; break;
+         case 4: /* 1 Jan is Thu */ j -= 3; break;
+         case 5: /* 1 Jan is Fri */ j += 3; break;
+         case 6: /* 1 Jan is Sat */ j += 2; break;
+         case 7: /* 1 Jan is Sun */ j += 1; break;
+         default: xassert(j != j);
+      }
+      /* the first day of the week must be Monday */
+      xassert(weekday(j) == 1);
+      return j;
+}
+
+void fn_time2str(MPL *mpl, char *str, double t, const char *fmt)
+{     /* convert the calendar time to character string */
+      int j, year, month, day, hh, mm, ss, len;
+      double temp;
+      const char *f;
+      char buf[MAX_LENGTH+1];
+      if (!(-62135596800.0 <= t && t <= 64092211199.0))
+         error(mpl, "time2str(%.*g,...); argument out of range",
+            DBL_DIG, t);
+      t = floor(t + 0.5);
+      temp = fabs(t) / 86400.0;
+      j = (int)floor(temp);
+      if (t < 0.0)
+      {  if (temp == floor(temp))
+            j = - j;
+         else
+            j = - (j + 1);
       }
+      xassert(jdate(j + jday(1, 1, 1970), &day, &month, &year) == 0);
+      ss = (int)(t - 86400.0 * (double)j);
+      xassert(0 <= ss && ss < 86400);
+      mm = ss / 60, ss %= 60;
+      hh = mm / 60, mm %= 60;
+      len = 0;
+      for (f = fmt; *f != '\0'; f++)
+      {  if (*f == '%')
+         {  f++;
+            if (*f == 'a')
+            {  /* the abbreviated weekday name */
+               memcpy(buf, week[weekday(j)-1], 3), buf[3] = '\0';
+            }
+            else if (*f == 'A')
+            {  /* the full weekday name */
+               strcpy(buf, week[weekday(j)-1]);
+            }
+            else if (*f == 'b' || *f == 'h')
+            {  /* the abbreviated month name */
+               memcpy(buf, moon[month-1], 3), buf[3] = '\0';
+            }
+            else if (*f == 'B')
+            {  /* the full month name */
+               strcpy(buf, moon[month-1]);
+            }
+            else if (*f == 'C')
+            {  /* the century of the year */
+               sprintf(buf, "%02d", year / 100);
+            }
+            else if (*f == 'd')
+            {  /* the day of the month as a decimal number (01..31) */
+               sprintf(buf, "%02d", day);
+            }
+            else if (*f == 'D')
+            {  /* the date using the format %m/%d/%y */
+               sprintf(buf, "%02d/%02d/%02d", month, day, year % 100);
+            }
+            else if (*f == 'e')
+            {  /* the day of the month like with %d, but padded with
+                  blank (1..31) */
+               sprintf(buf, "%2d", day);
+            }
+            else if (*f == 'F')
+            {  /* the date using the format %Y-%m-%d */
+               sprintf(buf, "%04d-%02d-%02d", year, month, day);
+            }
+            else if (*f == 'g')
+            {  /* the year corresponding to the ISO week number, but
+                  without the century (range 00 through 99); this has
+                  the same format and value as %y, except that if the
+                  ISO week number (see %V) belongs to the previous or
+                  next year, that year is used instead */
+               int iso;
+               if (j < firstday(year))
+                  iso = year - 1;
+               else if (j < firstday(year + 1))
+                  iso = year;
+               else
+                  iso = year + 1;
+               sprintf(buf, "%02d", iso % 100);
+            }
+            else if (*f == 'G')
+            {  /* the year corresponding to the ISO week number; this
+                  has the same format and value as %Y, excepth that if
+                  the ISO week number (see %V) belongs to the previous
+                  or next year, that year is used instead */
+               int iso;
+               if (j < firstday(year))
+                  iso = year - 1;
+               else if (j < firstday(year + 1))
+                  iso = year;
+               else
+                  iso = year + 1;
+               sprintf(buf, "%04d", iso);
+            }
+            else if (*f == 'H')
+            {  /* the hour as a decimal number, using a 24-hour clock
+                  (00..23) */
+               sprintf(buf, "%02d", hh);
+            }
+            else if (*f == 'I')
+            {  /* the hour as a decimal number, using a 12-hour clock
+                  (01..12) */
+               sprintf(buf, "%02d",
+                  hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);
+            }
+            else if (*f == 'j')
+            {  /* the day of the year as a decimal number (001..366) */
+               sprintf(buf, "%03d",
+                  jday(day, month, year) - jday(1, 1, year) + 1);
+            }
+            else if (*f == 'k')
+            {  /* the hour as a decimal number, using a 24-hour clock
+                  like %H, but padded with blank (0..23) */
+               sprintf(buf, "%2d", hh);
+            }
+            else if (*f == 'l')
+            {  /* the hour as a decimal number, using a 12-hour clock
+                  like %I, but padded with blank (1..12) */
+               sprintf(buf, "%2d",
+                  hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);
+            }
+            else if (*f == 'm')
+            {  /* the month as a decimal number (01..12) */
+               sprintf(buf, "%02d", month);
+            }
+            else if (*f == 'M')
+            {  /* the minute as a decimal number (00..59) */
+               sprintf(buf, "%02d", mm);
+            }
+            else if (*f == 'p')
+            {  /* either AM or PM, according to the given time value;
+                  noon is treated as PM and midnight as AM */
+               strcpy(buf, hh <= 11 ? "AM" : "PM");
+            }
+            else if (*f == 'P')
+            {  /* either am or pm, according to the given time value;
+                  noon is treated as pm and midnight as am */
+               strcpy(buf, hh <= 11 ? "am" : "pm");
+            }
+            else if (*f == 'r')
+            {  /* the calendar time using the format %I:%M:%S %p */
+               sprintf(buf, "%02d:%02d:%02d %s",
+                  hh == 0 ? 12 : hh <= 12 ? hh : hh - 12,
+                  mm, ss, hh <= 11 ? "AM" : "PM");
+            }
+            else if (*f == 'R')
+            {  /* the hour and minute using the format %H:%M */
+               sprintf(buf, "%02d:%02d", hh, mm);
+            }
+            else if (*f == 'S')
+            {  /* the second as a decimal number (00..59) */
+               sprintf(buf, "%02d", ss);
+            }
+            else if (*f == 'T')
+            {  /* the time of day using the format %H:%M:%S */
+               sprintf(buf, "%02d:%02d:%02d", hh, mm, ss);
+            }
+            else if (*f == 'u')
+            {  /* the day of the week as a decimal number (1..7),
+                  Monday being 1 */
+               sprintf(buf, "%d", weekday(j));
+            }
+            else if (*f == 'U')
+            {  /* the week number of the current year as a decimal
+                  number (range 00 through 53), starting with the first
+                  Sunday as the first day of the first week; days
+                  preceding the first Sunday in the year are considered
+                  to be in week 00 */
+#if 1 /* 09/I-2009 */
+#undef sun
+/* causes compilation error in SunOS */
 #endif
-      /* use the routine triang (see above) to find maximal triangular
-         part of the augmented constraint matrix A~ = (I|-A); in order
-         to prevent columns of fixed variables to be included in the
-         triangular part, such columns are implictly removed from the
-         matrix A~ by the routine adv_mat */
-      rn = xcalloc(1+m, sizeof(int));
-      cn = xcalloc(1+m+n, sizeof(int));
-      size = triang(m, m+n, lp, mat, rn, cn);
-      if (lpx_get_int_parm(lp, LPX_K_MSGLEV) >= 3)
-         xprintf("Size of triangular part = %d\n", size);
-      /* the first size rows and columns of the matrix P*A~*Q (where
-         P and Q are permutation matrices defined by the arrays rn and
-         cn) form a lower triangular matrix; build the arrays (rn_inv
-         and cn_inv), which define the matrices inv(P) and inv(Q) */
-      rn_inv = xcalloc(1+m, sizeof(int));
-      cn_inv = xcalloc(1+m+n, sizeof(int));
-      for (i = 1; i <= m; i++) rn_inv[rn[i]] = i;
-      for (j = 1; j <= m+n; j++) cn_inv[cn[j]] = j;
-      /* include the columns of the matrix A~, which correspond to the
-         first size columns of the matrix P*A~*Q, in the basis */
-      for (k = 1; k <= m+n; k++) tagx[k] = -1;
-      for (jj = 1; jj <= size; jj++)
-      {  j = cn_inv[jj];
-         /* the j-th column of A~ is the jj-th column of P*A~*Q */
-         tagx[j] = LPX_BS;
-      }
-      /* if size < m, we need to add appropriate columns of auxiliary
-         variables to the basis */
-      for (jj = size + 1; jj <= m; jj++)
-      {  /* the jj-th column of P*A~*Q should be replaced by the column
-            of the auxiliary variable, for which the only unity element
-            is placed in the position [jj,jj] */
-         i = rn_inv[jj];
-         /* the jj-th row of P*A~*Q is the i-th row of A~, but in the
-            i-th row of A~ the unity element belongs to the i-th column
-            of A~; therefore the disired column corresponds to the i-th
-            auxiliary variable (note that this column doesn't belong to
-            the triangular part found by the routine triang) */
-         xassert(1 <= i && i <= m);
-         xassert(cn[i] > size);
-         tagx[i] = LPX_BS;
-      }
-      /* free working arrays */
-      xfree(rn);
-      xfree(cn);
-      xfree(rn_inv);
-      xfree(cn_inv);
-      /* build tags of non-basic variables */
-      for (k = 1; k <= m+n; k++)
-      {  if (tagx[k] != LPX_BS)
-         {  if (k <= m)
-               lpx_get_row_bnds(lp, k, &typx, &lb, &ub);
-            else
-               lpx_get_col_bnds(lp, k-m, &typx, &lb, &ub);
-            switch (typx)
-            {  case LPX_FR:
-                  tagx[k] = LPX_NF; break;
-               case LPX_LO:
-                  tagx[k] = LPX_NL; break;
-               case LPX_UP:
-                  tagx[k] = LPX_NU; break;
-               case LPX_DB:
-                  tagx[k] =
-                     (fabs(lb) <= fabs(ub) ? LPX_NL : LPX_NU);
-                  break;
-               case LPX_FX:
-                  tagx[k] = LPX_NS; break;
-               default:
-                  xassert(typx != typx);
+               int sun;
+               /* sun = the first Sunday of the year */
+               sun = jday(1, 1, year) - jday(1, 1, 1970);
+               sun += (7 - weekday(sun));
+               sprintf(buf, "%02d", (j + 7 - sun) / 7);
+            }
+            else if (*f == 'V')
+            {  /* the ISO week number as a decimal number (range 01
+                  through 53); ISO weeks start with Monday and end with
+                  Sunday; week 01 of a year is the first week which has
+                  the majority of its days in that year; week 01 of
+                  a year can contain days from the previous year; the
+                  week before week 01 of a year is the last week (52 or
+                  53) of the previous year even if it contains days
+                  from the new year */
+               int iso;
+               if (j < firstday(year))
+                  iso = j - firstday(year - 1);
+               else if (j < firstday(year + 1))
+                  iso = j - firstday(year);
+               else
+                  iso = j - firstday(year + 1);
+               sprintf(buf, "%02d", iso / 7 + 1);
+            }
+            else if (*f == 'w')
+            {  /* the day of the week as a decimal number (0..6),
+                  Sunday being 0 */
+               sprintf(buf, "%d", weekday(j) % 7);
+            }
+            else if (*f == 'W')
+            {  /* the week number of the current year as a decimal
+                  number (range 00 through 53), starting with the first
+                  Monday as the first day of the first week; days
+                  preceding the first Monday in the year are considered
+                  to be in week 00 */
+               int mon;
+               /* mon = the first Monday of the year */
+               mon = jday(1, 1, year) - jday(1, 1, 1970);
+               mon += (8 - weekday(mon)) % 7;
+               sprintf(buf, "%02d", (j + 7 - mon) / 7);
+            }
+            else if (*f == 'y')
+            {  /* the year without a century as a decimal number
+                  (00..99) */
+               sprintf(buf, "%02d", year % 100);
+            }
+            else if (*f == 'Y')
+            {  /* the year as a decimal number, using the Gregorian
+                  calendar */
+               sprintf(buf, "%04d", year);
+            }
+            else if (*f == '%')
+            {  /* a literal % character */
+               buf[0] = '%', buf[1] = '\0';
             }
+            else
+               error2(mpl, fmt, f, "invalid conversion specifier");
          }
-      }
-      for (k = 1; k <= m+n; k++)
-      {  if (k <= m)
-            lpx_set_row_stat(lp, k, tagx[k]);
          else
-            lpx_set_col_stat(lp, k-m, tagx[k]);
+            buf[0] = *f, buf[1] = '\0';
+         if (len + strlen(buf) > MAX_LENGTH)
+            error(mpl, "time2str; output string length exceeds %d chara"
+               "cters", MAX_LENGTH);
+         memcpy(str+len, buf, strlen(buf));
+         len += strlen(buf);
       }
-      xfree(tagx);
-      return;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  glp_adv_basis - construct advanced initial LP basis
-*
-*  SYNOPSIS
-*
-*  void glp_adv_basis(glp_prob *lp, int flags);
-*
-*  DESCRIPTION
-*
-*  The routine glp_adv_basis constructs an advanced initial basis for
-*  the specified problem object.
-*
-*  The parameter flags is reserved for use in the future and must be
-*  specified as zero. */
-
-void glp_adv_basis(glp_prob *lp, int flags)
-{     if (flags != 0)
-         xerror("glp_adv_basis: flags = %d; invalid flags\n", flags);
-      if (lp->m == 0 || lp->n == 0)
-         glp_std_basis(lp);
-      else
-         adv_basis(lp);
+      str[len] = '\0';
       return;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpini02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/api/cpxbas.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpini02.c */
+/* cpxbas.c (construct Bixby's initial LP basis) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2008-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,29 +15,26 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpapi.h"
+#include "env.h"
+#include "prob.h"
 
 struct var
 {     /* structural variable */
       int j;
       /* ordinal number */
       double q;
       /* penalty value */
 };
 
-static int fcmp(const void *ptr1, const void *ptr2)
+static int CDECL fcmp(const void *ptr1, const void *ptr2)
 {     /* this routine is passed to the qsort() function */
       struct var *col1 = (void *)ptr1, *col2 = (void *)ptr2;
       if (col1->q < col2->q) return -1;
       if (col1->q > col2->q) return +1;
       return 0;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/ios.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios.h (integer optimization suite) */
+/* ios.h (integer optimization suite) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,30 +15,40 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPIOS_H
-#define GLPIOS_H
+#ifndef IOS_H
+#define IOS_H
 
-#define GLP_TREE_DEFINED
-typedef struct glp_tree glp_tree;
+#include "prob.h"
 
-#include "glpapi.h"
+#if 1 /* 02/II-2018 */
+#define NEW_LOCAL 1
+#endif
+
+#if 1 /* 15/II-2018 */
+#define NEW_COVER 1
+#endif
 
 typedef struct IOSLOT IOSLOT;
 typedef struct IOSNPD IOSNPD;
 typedef struct IOSBND IOSBND;
 typedef struct IOSTAT IOSTAT;
 typedef struct IOSROW IOSROW;
 typedef struct IOSAIJ IOSAIJ;
+#ifdef NEW_LOCAL /* 02/II-2018 */
+typedef glp_prob IOSPOOL;
+typedef GLPROW IOSCUT;
+#else
 typedef struct IOSPOOL IOSPOOL;
 typedef struct IOSCUT IOSCUT;
+#endif
 
 struct glp_tree
 {     /* branch-and-bound tree */
       int magic;
       /* magic value used for debugging */
       DMP *pool;
       /* memory pool to store all IOS components */
@@ -147,37 +154,51 @@
       /* upper bounds of all variables */
       unsigned char *pred_stat; /* uchar pred_stat[1+pred_m+n]; */
       /* statuses of all variables */
       /****************************************************************/
       /* built-in cut generators segment */
       IOSPOOL *local;
       /* local cut pool */
-      void *mir_gen;
+#if 1 /* 13/II-2018 */
+      glp_cov *cov_gen;
+      /* pointer to working area used by the cover cut generator */
+#endif
+      glp_mir *mir_gen;
       /* pointer to working area used by the MIR cut generator */
-      void *clq_gen;
-      /* pointer to working area used by the clique cut generator */
+      glp_cfg *clq_gen;
+      /* pointer to conflict graph used by the clique cut generator */
       /*--------------------------------------------------------------*/
       void *pcost;
       /* pointer to working area used on pseudocost branching */
       int *iwrk; /* int iwrk[1+n]; */
       /* working array */
       double *dwrk; /* double dwrk[1+n]; */
       /* working array */
       /*--------------------------------------------------------------*/
       /* control parameters and statistics */
       const glp_iocp *parm;
       /* copy of control parameters passed to the solver */
-      glp_long tm_beg;
+      double tm_beg;
       /* starting time of the search, in seconds; the total time of the
          search is the difference between xtime() and tm_beg */
-      glp_long tm_lag;
+      double tm_lag;
       /* the most recent time, in seconds, at which the progress of the
          the search was displayed */
       int sol_cnt;
       /* number of integer feasible solutions found */
+#if 1 /* 11/VII-2013 */
+      void *P; /* glp_prob *P; */
+      /* problem passed to glp_intopt */
+      void *npp; /* NPP *npp; */
+      /* preprocessor workspace or NULL */
+      const char *save_sol;
+      /* filename (template) to save every new solution */
+      int save_cnt;
+      /* count to generate filename */
+#endif
       /*--------------------------------------------------------------*/
       /* advanced solver interface */
       int reason;
       /* flag indicating the reason why the callback routine is being
          called (see glpk.h) */
       int stop;
       /* flag indicating that the callback routine requires premature
@@ -345,28 +366,31 @@
       /* variable (column) number, 1 <= j <= n */
       double val;
       /* non-zero coefficient value */
       IOSAIJ *next;
       /* pointer to next coefficient for the same row */
 };
 
+#ifndef NEW_LOCAL /* 02/II-2018 */
 struct IOSPOOL
 {     /* cut pool */
       int size;
       /* pool size = number of cuts in the pool */
       IOSCUT *head;
       /* pointer to the first cut */
       IOSCUT *tail;
       /* pointer to the last cut */
       int ord;
       /* ordinal number of the current cut, 1 <= ord <= size */
       IOSCUT *curr;
       /* pointer to the current cut */
 };
+#endif
 
+#ifndef NEW_LOCAL /* 02/II-2018 */
 struct IOSCUT
 {     /* cut (cutting plane constraint) */
       char *name;
       /* cut name or NULL */
       unsigned char klass;
       /* cut class descriptor (see glp_attr.klass) */
       IOSAIJ *ptr;
@@ -379,14 +403,15 @@
       double rhs;
       /* cut right-hand side */
       IOSCUT *prev;
       /* pointer to previous cut */
       IOSCUT *next;
       /* pointer to next cut */
 };
+#endif
 
 #define ios_create_tree _glp_ios_create_tree
 glp_tree *ios_create_tree(glp_prob *mip, const glp_iocp *parm);
 /* create branch-and-bound tree */
 
 #define ios_revive_node _glp_ios_revive_node
 void ios_revive_node(glp_tree *tree, int p);
@@ -454,112 +479,32 @@
 void ios_clear_pool(glp_tree *tree, IOSPOOL *pool);
 /* remove all rows (constraints) from the cut pool */
 
 #define ios_delete_pool _glp_ios_delete_pool
 void ios_delete_pool(glp_tree *tree, IOSPOOL *pool);
 /* delete cut pool */
 
+#if 1 /* 11/VII-2013 */
+#define ios_process_sol _glp_ios_process_sol
+void ios_process_sol(glp_tree *T);
+/* process integer feasible solution just found */
+#endif
+
 #define ios_preprocess_node _glp_ios_preprocess_node
 int ios_preprocess_node(glp_tree *tree, int max_pass);
 /* preprocess current subproblem */
 
 #define ios_driver _glp_ios_driver
 int ios_driver(glp_tree *tree);
 /* branch-and-bound driver */
 
-/**********************************************************************/
-
-typedef struct IOSVEC IOSVEC;
-
-struct IOSVEC
-{     /* sparse vector v = (v[j]) */
-      int n;
-      /* dimension, n >= 0 */
-      int nnz;
-      /* number of non-zero components, 0 <= nnz <= n */
-      int *pos; /* int pos[1+n]; */
-      /* pos[j] = k, 1 <= j <= n, is position of (non-zero) v[j] in the
-         arrays ind and val, where 1 <= k <= nnz; pos[j] = 0 means that
-         v[j] is structural zero */
-      int *ind; /* int ind[1+n]; */
-      /* ind[k] = j, 1 <= k <= nnz, is index of v[j] */
-      double *val; /* double val[1+n]; */
-      /* val[k], 1 <= k <= nnz, is a numeric value of v[j] */
-};
-
-#define ios_create_vec _glp_ios_create_vec
-IOSVEC *ios_create_vec(int n);
-/* create sparse vector */
-
-#define ios_check_vec _glp_ios_check_vec
-void ios_check_vec(IOSVEC *v);
-/* check that sparse vector has correct representation */
-
-#define ios_get_vj _glp_ios_get_vj
-double ios_get_vj(IOSVEC *v, int j);
-/* retrieve component of sparse vector */
-
-#define ios_set_vj _glp_ios_set_vj
-void ios_set_vj(IOSVEC *v, int j, double val);
-/* set/change component of sparse vector */
-
-#define ios_clear_vec _glp_ios_clear_vec
-void ios_clear_vec(IOSVEC *v);
-/* set all components of sparse vector to zero */
-
-#define ios_clean_vec _glp_ios_clean_vec
-void ios_clean_vec(IOSVEC *v, double eps);
-/* remove zero or small components from sparse vector */
-
-#define ios_copy_vec _glp_ios_copy_vec
-void ios_copy_vec(IOSVEC *x, IOSVEC *y);
-/* copy sparse vector (x := y) */
-
-#define ios_linear_comb _glp_ios_linear_comb
-void ios_linear_comb(IOSVEC *x, double a, IOSVEC *y);
-/* compute linear combination (x := x + a * y) */
-
-#define ios_delete_vec _glp_ios_delete_vec
-void ios_delete_vec(IOSVEC *v);
-/* delete sparse vector */
-
-/**********************************************************************/
-
-#define ios_gmi_gen _glp_ios_gmi_gen
-void ios_gmi_gen(glp_tree *tree);
-/* generate Gomory's mixed integer cuts */
-
-#define ios_mir_init _glp_ios_mir_init
-void *ios_mir_init(glp_tree *tree);
-/* initialize MIR cut generator */
-
-#define ios_mir_gen _glp_ios_mir_gen
-void ios_mir_gen(glp_tree *tree, void *gen);
-/* generate MIR cuts */
-
-#define ios_mir_term _glp_ios_mir_term
-void ios_mir_term(void *gen);
-/* terminate MIR cut generator */
-
 #define ios_cov_gen _glp_ios_cov_gen
 void ios_cov_gen(glp_tree *tree);
 /* generate mixed cover cuts */
 
-#define ios_clq_init _glp_ios_clq_init
-void *ios_clq_init(glp_tree *tree);
-/* initialize clique cut generator */
-
-#define ios_clq_gen _glp_ios_clq_gen
-void ios_clq_gen(glp_tree *tree, void *gen);
-/* generate clique cuts */
-
-#define ios_clq_term _glp_ios_clq_term
-void ios_clq_term(void *gen);
-/* terminate clique cut generator */
-
 #define ios_pcost_init _glp_ios_pcost_init
 void *ios_pcost_init(glp_tree *tree);
 /* initialize working data used on pseudocost branching */
 
 #define ios_pcost_branch _glp_ios_pcost_branch
 int ios_pcost_branch(glp_tree *T, int *next);
 /* choose branching variable with pseudocost branching */
@@ -572,14 +517,20 @@
 void ios_pcost_free(glp_tree *tree);
 /* free working area used on pseudocost branching */
 
 #define ios_feas_pump _glp_ios_feas_pump
 void ios_feas_pump(glp_tree *T);
 /* feasibility pump heuristic */
 
+#if 1 /* 25/V-2013 */
+#define ios_proxy_heur _glp_ios_proxy_heur
+void ios_proxy_heur(glp_tree *T);
+/* proximity search heuristic */
+#endif
+
 #define ios_process_cuts _glp_ios_process_cuts
 void ios_process_cuts(glp_tree *T);
 /* process cuts stored in the local cut pool */
 
 #define ios_choose_node _glp_ios_choose_node
 int ios_choose_node(glp_tree *T);
 /* select subproblem to continue the search */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios01.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpios01.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,22 +15,32 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#pragma clang diagnostic ignored "-Wself-assign"
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#endif
-
-#include "glpios.h"
+#include "env.h"
+#include "ios.h"
+#include "misc.h"
+
+static int lpx_eval_tab_row(glp_prob *lp, int k, int ind[],
+      double val[])
+{     /* compute row of the simplex tableau */
+      return glp_eval_tab_row(lp, k, ind, val);
+}
+
+static int lpx_dual_ratio_test(glp_prob *lp, int len, const int ind[],
+      const double val[], int how, double tol)
+{     /* perform dual ratio test */
+      int piv;
+      piv = glp_dual_rtest(lp, len, ind, val, how, tol);
+      xassert(0 <= piv && piv <= len);
+      return piv == 0 ? 0 : ind[piv];
+}
 
 /***********************************************************************
 *  NAME
 *
 *  ios_create_tree - create branch-and-bound tree
 *
 *  SYNOPSIS
@@ -111,21 +118,24 @@
       memset(&tree->non_int[1], 0, n);
       /* arrays to save parent subproblem components will be allocated
          later */
       tree->pred_m = tree->pred_max = 0;
       tree->pred_type = NULL;
       tree->pred_lb = tree->pred_ub = NULL;
       tree->pred_stat = NULL;
-      /* cut generator */
+      /* cut generators */
       tree->local = ios_create_pool(tree);
       /*tree->first_attempt = 1;*/
       /*tree->max_added_cuts = 0;*/
       /*tree->min_eff = 0.0;*/
       /*tree->miss = 0;*/
       /*tree->just_selected = 0;*/
+#ifdef NEW_COVER /* 13/II-2018 */
+      tree->cov_gen = NULL;
+#endif
       tree->mir_gen = NULL;
       tree->clq_gen = NULL;
       /*tree->round = 0;*/
 #if 0
       /* create the conflict graph */
       tree->n_ref = xcalloc(1+n, sizeof(int));
       memset(&tree->n_ref[1], 0, n * sizeof(int));
@@ -137,16 +147,26 @@
       /* pseudocost branching */
       tree->pcost = NULL;
       tree->iwrk = xcalloc(1+n, sizeof(int));
       tree->dwrk = xcalloc(1+n, sizeof(double));
       /* initialize control parameters */
       tree->parm = parm;
       tree->tm_beg = xtime();
+#if 0 /* 10/VI-2013 */
       tree->tm_lag = xlset(0);
+#else
+      tree->tm_lag = 0.0;
+#endif
       tree->sol_cnt = 0;
+#if 1 /* 11/VII-2013 */
+      tree->P = NULL;
+      tree->npp = NULL;
+      tree->save_sol = parm->save_sol;
+      tree->save_cnt = 0;
+#endif
       /* initialize advanced solver interface */
       tree->reason = 0;
       tree->reopt = 0;
       tree->reinv = 0;
       tree->br_var = 0;
       tree->br_sel = 0;
       tree->child = 0;
@@ -1312,14 +1332,23 @@
             parm.msg_lev = GLP_MSG_ON; break;
          case GLP_MSG_DBG:
             parm.msg_lev = GLP_MSG_ALL; break;
          default:
             xassert(tree != tree);
       }
       parm.meth = GLP_DUALP;
+#if 1 /* 16/III-2016 */
+      if (tree->parm->flip)
+         parm.r_test = GLP_RT_FLIP;
+#endif
+      /* respect time limit */
+      if (tree->parm->tm_lim < INT_MAX)
+         parm.tm_lim = tree->parm->tm_lim - (glp_time() - tree->tm_beg);
+      if (parm.tm_lim < 0)
+         parm.tm_lim = 0;
       if (tree->parm->msg_lev < GLP_MSG_DBG)
          parm.out_dly = tree->parm->out_dly;
       else
          parm.out_dly = 0;
       /* if the incumbent objective value is already known, use it to
          prematurely terminate the dual simplex search */
       if (mip->mip_stat == GLP_FEAS)
@@ -1332,41 +1361,76 @@
                break;
             default:
                xassert(mip != mip);
          }
       }
       /* try to solve/re-optimize the LP relaxation */
       ret = glp_simplex(mip, &parm);
+#if 1 /* 21/II-2016 by Chris */
+      if (ret == GLP_EFAIL)
+      {  /* retry with a new basis */
+         glp_adv_basis(mip, 0);
+         ret = glp_simplex(mip, &parm);
+      }
+#endif
       tree->curr->solved++;
 #if 0
       xprintf("ret = %d; status = %d; pbs = %d; dbs = %d; some = %d\n",
          ret, glp_get_status(mip), mip->pbs_stat, mip->dbs_stat,
          mip->some);
       lpx_print_sol(mip, "sol");
 #endif
       return ret;
 }
 
 /**********************************************************************/
 
+#ifdef NEW_LOCAL /* 02/II-2018 */
+IOSPOOL *ios_create_pool(glp_tree *tree)
+{     /* create cut pool */
+      IOSPOOL *pool;
+      pool = glp_create_prob();
+#if 1 /* 14/VII-2020 */
+      if (tree->mip->n)
+#endif
+      glp_add_cols(pool, tree->mip->n);
+      return pool;
+}
+#else
 IOSPOOL *ios_create_pool(glp_tree *tree)
 {     /* create cut pool */
       IOSPOOL *pool;
 #if 0
       pool = dmp_get_atom(tree->pool, sizeof(IOSPOOL));
 #else
       xassert(tree == tree);
       pool = xmalloc(sizeof(IOSPOOL));
 #endif
       pool->size = 0;
       pool->head = pool->tail = NULL;
       pool->ord = 0, pool->curr = NULL;
       return pool;
 }
+#endif
 
+#ifdef NEW_LOCAL /* 02/II-2018 */
+int ios_add_row(glp_tree *tree, IOSPOOL *pool,
+      const char *name, int klass, int flags, int len, const int ind[],
+      const double val[], int type, double rhs)
+{     /* add row (constraint) to the cut pool */
+      int i;
+      i = glp_add_rows(pool, 1);
+      glp_set_row_name(pool, i, name);
+      pool->row[i]->klass = klass;
+      xassert(flags == 0);
+      glp_set_mat_row(pool, i, len, ind, val);
+      glp_set_row_bnds(pool, i, type, rhs, rhs);
+      return i;
+}
+#else
 int ios_add_row(glp_tree *tree, IOSPOOL *pool,
       const char *name, int klass, int flags, int len, const int ind[],
       const double val[], int type, double rhs)
 {     /* add row (constraint) to the cut pool */
       IOSCUT *cut;
       IOSAIJ *aij;
       int k;
@@ -1417,15 +1481,22 @@
          pool->head = cut;
       else
          cut->prev->next = cut;
       pool->tail = cut;
       pool->size++;
       return pool->size;
 }
+#endif
 
+#ifdef NEW_LOCAL /* 02/II-2018 */
+IOSCUT *ios_find_row(IOSPOOL *pool, int i)
+{     /* find row (constraint) in the cut pool */
+      xassert(0);
+}
+#else
 IOSCUT *ios_find_row(IOSPOOL *pool, int i)
 {     /* find row (constraint) in the cut pool */
       /* (smart linear search) */
       xassert(pool != NULL);
       xassert(1 <= i && i <= pool->size);
       if (pool->ord == 0)
       {  xassert(pool->curr == NULL);
@@ -1469,15 +1540,22 @@
             }
          }
       }
       xassert(pool->ord == i);
       xassert(pool->curr != NULL);
       return pool->curr;
 }
+#endif
 
+#ifdef NEW_LOCAL /* 02/II-2018 */
+void ios_del_row(glp_tree *tree, IOSPOOL *pool, int i)
+{     /* remove row (constraint) from the cut pool */
+      xassert(0);
+}
+#else
 void ios_del_row(glp_tree *tree, IOSPOOL *pool, int i)
 {     /* remove row (constraint) from the cut pool */
       IOSCUT *cut;
       IOSAIJ *aij;
       xassert(pool != NULL);
       if (!(1 <= i && i <= pool->size))
          xerror("glp_ios_del_row: i = %d; cut number out of range\n",
@@ -1513,15 +1591,30 @@
          cut->ptr = aij->next;
          dmp_free_atom(tree->pool, aij, sizeof(IOSAIJ));
       }
       dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));
       pool->size--;
       return;
 }
+#endif
 
+#ifdef NEW_LOCAL /* 02/II-2018 */
+void ios_clear_pool(glp_tree *tree, IOSPOOL *pool)
+{     /* remove all rows (constraints) from the cut pool */
+      if (pool->m > 0)
+      {  int i, *num;
+         num = talloc(1+pool->m, int);
+         for (i = 1; i <= pool->m; i++)
+            num[i] = i;
+         glp_del_rows(pool, pool->m, num);
+         tfree(num);
+      }
+      return;
+}
+#else
 void ios_clear_pool(glp_tree *tree, IOSPOOL *pool)
 {     /* remove all rows (constraints) from the cut pool */
       xassert(pool != NULL);
       while (pool->head != NULL)
       {  IOSCUT *cut = pool->head;
          pool->head = cut->next;
          if (cut->name != NULL)
@@ -1534,85 +1627,59 @@
          dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));
       }
       pool->size = 0;
       pool->head = pool->tail = NULL;
       pool->ord = 0, pool->curr = NULL;
       return;
 }
+#endif
 
+#ifdef NEW_LOCAL /* 02/II-2018 */
+void ios_delete_pool(glp_tree *tree, IOSPOOL *pool)
+{     /* delete cut pool */
+      xassert(pool != NULL);
+      glp_delete_prob(pool);
+      return;
+}
+#else
 void ios_delete_pool(glp_tree *tree, IOSPOOL *pool)
 {     /* delete cut pool */
       xassert(pool != NULL);
       ios_clear_pool(tree, pool);
       xfree(pool);
       return;
 }
+#endif
 
-/**********************************************************************/
+#if 1 /* 11/VII-2013 */
+#include "npp.h"
 
-#if 0
-static int refer_to_node(glp_tree *tree, int j)
-{     /* determine node number corresponding to binary variable x[j] or
-         its complement */
-      glp_prob *mip = tree->mip;
-      int n = mip->n;
-      int *ref;
-      if (j > 0)
-         ref = tree->n_ref;
-      else
-         ref = tree->c_ref, j = - j;
-      xassert(1 <= j && j <= n);
-      if (ref[j] == 0)
-      {  /* new node is needed */
-         SCG *g = tree->g;
-         int n_max = g->n_max;
-         ref[j] = scg_add_nodes(g, 1);
-         if (g->n_max > n_max)
-         {  int *save = tree->j_ref;
-            tree->j_ref = xcalloc(1+g->n_max, sizeof(int));
-            memcpy(&tree->j_ref[1], &save[1], g->n * sizeof(int));
-            xfree(save);
+void ios_process_sol(glp_tree *T)
+{     /* process integer feasible solution just found */
+      if (T->npp != NULL)
+      {  /* postprocess solution from transformed mip */
+         npp_postprocess(T->npp, T->mip);
+         /* store solution to problem passed to glp_intopt */
+         npp_unload_sol(T->npp, T->P);
+      }
+      xassert(T->P != NULL);
+      /* save solution to text file, if requested */
+      if (T->save_sol != NULL)
+      {  char *fn, *mark;
+         fn = talloc(strlen(T->save_sol) + 50, char);
+         mark = strrchr(T->save_sol, '*');
+         if (mark == NULL)
+            strcpy(fn, T->save_sol);
+         else
+         {  memcpy(fn, T->save_sol, mark - T->save_sol);
+            fn[mark - T->save_sol] = '\0';
+            sprintf(fn + strlen(fn), "%03d", ++(T->save_cnt));
+            strcat(fn, &mark[1]);
          }
-         xassert(ref[j] == g->n);
-         tree->j_ref[ref[j]] = j;
-         xassert(tree->curr != NULL);
-         if (tree->curr->level > 0) tree->curr->own_nn++;
-      }
-      return ref[j];
-}
-#endif
-
-#if 0
-void ios_add_edge(glp_tree *tree, int j1, int j2)
-{     /* add new edge to the conflict graph */
-      glp_prob *mip = tree->mip;
-      int n = mip->n;
-      SCGRIB *e;
-      int first, i1, i2;
-      xassert(-n <= j1 && j1 <= +n && j1 != 0);
-      xassert(-n <= j2 && j2 <= +n && j2 != 0);
-      xassert(j1 != j2);
-      /* determine number of the first node, which was added for the
-         current subproblem */
-      xassert(tree->curr != NULL);
-      first = tree->g->n - tree->curr->own_nn + 1;
-      /* determine node numbers for both endpoints */
-      i1 = refer_to_node(tree, j1);
-      i2 = refer_to_node(tree, j2);
-      /* add edge (i1,i2) to the conflict graph */
-      e = scg_add_edge(tree->g, i1, i2);
-      /* if the current subproblem is not the root and both endpoints
-         were created on some previous levels, save the edge */
-      if (tree->curr->level > 0 && i1 < first && i2 < first)
-      {  IOSRIB *rib;
-         rib = dmp_get_atom(tree->pool, sizeof(IOSRIB));
-         rib->j1 = j1;
-         rib->j2 = j2;
-         rib->e = e;
-         rib->next = tree->curr->e_ptr;
-         tree->curr->e_ptr = rib;
+         /* glp_write_mip(T->P, fn); */
+         tfree(fn);
       }
       return;
 }
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/cfg1.c`

 * *Files 21% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios02.c (preprocess current subproblem) */
+/* cfg1.c (conflict graph) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2012-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,812 +15,687 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpios.h"
+#include "cfg.h"
+#include "env.h"
+#include "prob.h"
+#include "wclique.h"
+#include "wclique1.h"
 
 /***********************************************************************
-*  prepare_row_info - prepare row info to determine implied bounds
+*  cfg_build_graph - build conflict graph
 *
-*  Given a row (linear form)
+*  This routine builds the conflict graph. It analyzes the specified
+*  problem object to discover original and implied packing inequalities
+*  and adds corresponding cliques to the conflict graph.
 *
-*      n
-*     sum a[j] * x[j]                                                (1)
-*     j=1
+*  Packing inequality has the form:
 *
-*  and bounds of columns (variables)
+*      sum z[j] <= 1,                                                (1)
+*     j in J
 *
-*     l[j] <= x[j] <= u[j]                                           (2)
+*  where z[j] = x[j] or z[j] = 1 - x[j], x[j] is an original binary
+*  variable. Every packing inequality (1) is equivalent to a set of
+*  edge inequalities:
 *
-*  this routine computes f_min, j_min, f_max, j_max needed to determine
-*  implied bounds.
+*     z[i] + z[j] <= 1   for all i, j in J, i != j,                  (2)
 *
-*  ALGORITHM
+*  and since every edge inequality (2) defines an edge in the conflict
+*  graph, corresponding packing inequality (1) defines a clique.
 *
-*  Let J+ = {j : a[j] > 0} and J- = {j : a[j] < 0}.
+*  To discover packing inequalities the routine analyzes constraints
+*  of the specified MIP. To simplify the analysis each constraint is
+*  analyzed separately. The analysis is performed as follows.
 *
-*  Parameters f_min and j_min are computed as follows:
+*  Let some original constraint be the following:
 *
-*  1) if there is no x[k] such that k in J+ and l[k] = -inf or k in J-
-*     and u[k] = +inf, then
+*     L <= sum a[j] x[j] <= U.                                       (3)
 *
-*     f_min :=   sum   a[j] * l[j] +   sum   a[j] * u[j]
-*              j in J+               j in J-
-*                                                                    (3)
-*     j_min := 0
+*  To analyze it the routine analyzes two constraints of "not greater
+*  than" type:
 *
-*  2) if there is exactly one x[k] such that k in J+ and l[k] = -inf
-*     or k in J- and u[k] = +inf, then
+*     sum (-a[j]) x[j] <= -L,                                        (4)
 *
-*     f_min :=   sum       a[j] * l[j] +   sum       a[j] * u[j]
-*              j in J+\{k}               j in J-\{k}
-*                                                                    (4)
-*     j_min := k
+*     sum (+a[j]) x[j] <= +U,                                        (5)
 *
-*  3) if there are two or more x[k] such that k in J+ and l[k] = -inf
-*     or k in J- and u[k] = +inf, then
+*  which are relaxations of the original constraint (3). (If, however,
+*  L = -oo, or U = +oo, corresponding constraint being redundant is not
+*  analyzed.)
 *
-*     f_min := -inf
-*                                                                    (5)
-*     j_min := 0
+*  Let a constraint of "not greater than" type be the following:
 *
-*  Parameters f_max and j_max are computed in a similar way as follows:
+*      sum  a[j] x[j] + sum  a[j] x[j] <= b,                         (6)
+*     j in J           j in J'
 *
-*  1) if there is no x[k] such that k in J+ and u[k] = +inf or k in J-
-*     and l[k] = -inf, then
+*  where J is a subset of binary variables, J' is a subset of other
+*  (continues and non-binary integer) variables. The constraint (6) is
+*  is relaxed as follows, to eliminate non-binary variables:
 *
-*     f_max :=   sum   a[j] * u[j] +   sum   a[j] * l[j]
-*              j in J+               j in J-
-*                                                                    (6)
-*     j_max := 0
+*      sum  a[j] x[j] <= b -  sum  a[j] x[j] <= b',                  (7)
+*     j in J                 j in J'
 *
-*  2) if there is exactly one x[k] such that k in J+ and u[k] = +inf
-*     or k in J- and l[k] = -inf, then
+*     b' = sup(b -  sum  a[j] x[j]) =
+*                  j in J'
 *
-*     f_max :=   sum       a[j] * u[j] +   sum       a[j] * l[j]
-*              j in J+\{k}               j in J-\{k}
-*                                                                    (7)
-*     j_max := k
+*        = b - inf(sum a[j] x[j]) =
 *
-*  3) if there are two or more x[k] such that k in J+ and u[k] = +inf
-*     or k in J- and l[k] = -inf, then
+*        = b - sum inf(a[j] x[j]) =                                  (8)
 *
-*     f_max := +inf
-*                                                                    (8)
-*     j_max := 0                                                      */
-
-struct f_info
-{     int j_min, j_max;
-      double f_min, f_max;
-};
-
-static void prepare_row_info(int n, const double a[], const double l[],
-      const double u[], struct f_info *f)
-{     int j, j_min, j_max;
-      double f_min, f_max;
-      xassert(n >= 0);
-      /* determine f_min and j_min */
-      f_min = 0.0, j_min = 0;
-      for (j = 1; j <= n; j++)
-      {  if (a[j] > 0.0)
-         {  if (l[j] == -DBL_MAX)
-            {  if (j_min == 0)
-                  j_min = j;
-               else
-               {  f_min = -DBL_MAX, j_min = 0;
-                  break;
-               }
-            }
-            else
-               f_min += a[j] * l[j];
-         }
-         else if (a[j] < 0.0)
-         {  if (u[j] == +DBL_MAX)
-            {  if (j_min == 0)
-                  j_min = j;
-               else
-               {  f_min = -DBL_MAX, j_min = 0;
-                  break;
-               }
-            }
-            else
-               f_min += a[j] * u[j];
-         }
-         else
-            xassert(a != a);
-      }
-      f->f_min = f_min, f->j_min = j_min;
-      /* determine f_max and j_max */
-      f_max = 0.0, j_max = 0;
-      for (j = 1; j <= n; j++)
-      {  if (a[j] > 0.0)
-         {  if (u[j] == +DBL_MAX)
-            {  if (j_max == 0)
-                  j_max = j;
-               else
-               {  f_max = +DBL_MAX, j_max = 0;
-                  break;
-               }
-            }
-            else
-               f_max += a[j] * u[j];
-         }
-         else if (a[j] < 0.0)
-         {  if (l[j] == -DBL_MAX)
-            {  if (j_max == 0)
-                  j_max = j;
-               else
-               {  f_max = +DBL_MAX, j_max = 0;
-                  break;
-               }
-            }
-            else
-               f_max += a[j] * l[j];
-         }
-         else
-            xassert(a != a);
-      }
-      f->f_max = f_max, f->j_max = j_max;
-      return;
-}
-
-/***********************************************************************
-*  row_implied_bounds - determine row implied bounds
-*
-*  Given a row (linear form)
-*
-*      n
-*     sum a[j] * x[j]
-*     j=1
+*        = b -  sum  a[j] inf(x[j]) -  sum  a[j] sup(x[j]) =
+*              a[j]>0                 a[j]<0
 *
-*  and bounds of columns (variables)
+*        = b -  sum  a[j] l[j] -  sum  a[j] u[j],
+*              a[j]>0            a[j]<0
 *
-*     l[j] <= x[j] <= u[j]
+*  where l[j] and u[j] are, resp., lower and upper bounds of x[j].
 *
-*  this routine determines implied bounds of the row.
+*  Then the routine transforms the relaxed constraint containing only
+*  binary variables:
 *
-*  ALGORITHM
+*     sum a[j] x[j] <= b                                             (9)
 *
-*  Let J+ = {j : a[j] > 0} and J- = {j : a[j] < 0}.
+*  to an equivalent 0-1 knapsack constraint as follows:
 *
-*  The implied lower bound of the row is computed as follows:
+*     sum  a[j] x[j] + sum  a[j] x[j] <= b   ==>
+*    a[j]>0           a[j]<0
 *
-*     L' :=   sum   a[j] * l[j] +   sum   a[j] * u[j]                (9)
-*           j in J+               j in J-
+*     sum  a[j] x[j] + sum  a[j] (1 - x[j]) <= b   ==>
+*    a[j]>0           a[j]<0                                        (10)
 *
-*  and as it follows from (3), (4), and (5):
+*     sum  (+a[j]) x[j] + sum  (-a[j]) x[j] <= b + sum  (-a[j])   ==>
+*    a[j]>0              a[j]<0                   a[j]<0
 *
-*     L' := if j_min = 0 then f_min else -inf                       (10)
+*     sum a'[j] z[j] <= b',
 *
-*  The implied upper bound of the row is computed as follows:
+*  where a'[j] = |a[j]| > 0, and
 *
-*     U' :=   sum   a[j] * u[j] +   sum   a[j] * l[j]               (11)
-*           j in J+               j in J-
+*            ( x[j]      if a[j] > 0
+*     z[j] = <
+*            ( 1 - x[j]  if a[j] < 0
 *
-*  and as it follows from (6), (7), and (8):
+*  is a binary variable, which is either original binary variable x[j]
+*  or its complement.
 *
-*     U' := if j_max = 0 then f_max else +inf                       (12)
-*
-*  The implied bounds are stored in locations LL and UU. */
-
-static void row_implied_bounds(const struct f_info *f, double *LL,
-      double *UU)
-{     *LL = (f->j_min == 0 ? f->f_min : -DBL_MAX);
-      *UU = (f->j_max == 0 ? f->f_max : +DBL_MAX);
-      return;
-}
-
-/***********************************************************************
-*  col_implied_bounds - determine column implied bounds
+*  Finally, the routine analyzes the resultant 0-1 knapsack inequality:
 *
-*  Given a row (constraint)
+*       sum a[j] z[j] <= b,                                         (11)
+*     j in J
 *
-*           n
-*     L <= sum a[j] * x[j] <= U                                     (13)
-*          j=1
+*  where all a[j] are positive, to discover clique inequalities (1),
+*  which are valid for (11) and therefore valid for (3). (It is assumed
+*  that the original MIP has been preprocessed, so it is not checked,
+*  for example, that b > 0 or that a[j] <= b.)
 *
-*  and bounds of columns (variables)
+*  In principle, to discover any edge inequalities valid for (11) it
+*  is sufficient to check whether a[i] + a[j] > b for all i, j in J,
+*  i < j. However, this way requires O(|J|^2) checks, so the routine
+*  analyses (11) in the following way, which is much more efficient in
+*  many practical cases.
 *
-*     l[j] <= x[j] <= u[j]
+*  1. Let a[p] and a[q] be two minimal coefficients:
 *
-*  this routine determines implied bounds of variable x[k].
+*     a[p] = min a[j],                                              (12)
 *
-*  It is assumed that if L != -inf, the lower bound of the row can be
-*  active, and if U != +inf, the upper bound of the row can be active.
+*     a[q] = min a[j], j != p,                                      (13)
 *
-*  ALGORITHM
+*  such that
 *
-*  From (13) it follows that
+*     a[p] + a[q] > b.                                              (14)
 *
-*     L <= sum a[j] * x[j] + a[k] * x[k] <= U
-*          j!=k
-*  or
+*  This means that a[i] + a[j] > b for any i, j in J, i != j, so
 *
-*     L - sum a[j] * x[j] <= a[k] * x[k] <= U - sum a[j] * x[j]
-*         j!=k                                  j!=k
+*     z[i] + z[j] <= 1                                              (15)
 *
-*  Thus, if the row lower bound L can be active, implied lower bound of
-*  term a[k] * x[k] can be determined as follows:
+*  are valid for (11) for any i, j in J, i != j. This case means that
+*  J define a clique in the conflict graph.
 *
-*     ilb(a[k] * x[k]) = min(L - sum a[j] * x[j]) =
-*                                j!=k
-*                                                                   (14)
-*                      = L - max sum a[j] * x[j]
-*                            j!=k
+*  2. Otherwise, let a[p] and [q] be two maximal coefficients:
 *
-*  where, as it follows from (6), (7), and (8)
+*     a[p] = max a[j],                                              (16)
 *
-*                           / f_max - a[k] * u[k], j_max = 0, a[k] > 0
-*                           |
-*                           | f_max - a[k] * l[k], j_max = 0, a[k] < 0
-*     max sum a[j] * x[j] = {
-*         j!=k              | f_max,               j_max = k
-*                           |
-*                           \ +inf,                j_max != 0
+*     a[q] = max a[j], j != p,                                      (17)
 *
-*  and if the upper bound U can be active, implied upper bound of term
-*  a[k] * x[k] can be determined as follows:
+*  such that
 *
-*     iub(a[k] * x[k]) = max(U - sum a[j] * x[j]) =
-*                                j!=k
-*                                                                   (15)
-*                      = U - min sum a[j] * x[j]
-*                            j!=k
+*     a[p] + a[q] <= b.                                             (18)
 *
-*  where, as it follows from (3), (4), and (5)
+*  This means that a[i] + a[j] <= b for any i, j in J, i != j, so in
+*  this case no valid edge inequalities for (11) exist.
 *
-*                           / f_min - a[k] * l[k], j_min = 0, a[k] > 0
-*                           |
-*                           | f_min - a[k] * u[k], j_min = 0, a[k] < 0
-*     min sum a[j] * x[j] = {
-*         j!=k              | f_min,               j_min = k
-*                           |
-*                           \ -inf,                j_min != 0
+*  3. Otherwise, let all a[j] be ordered by descending their values:
 *
-*  Since
+*     a[1] >= a[2] >= ... >= a[p-1] >= a[p] >= a[p+1] >= ...        (19)
 *
-*     ilb(a[k] * x[k]) <= a[k] * x[k] <= iub(a[k] * x[k])
+*  where p is such that
 *
-*  implied lower and upper bounds of x[k] are determined as follows:
+*     a[p-1] + a[p] >  b,                                           (20)
 *
-*     l'[k] := if a[k] > 0 then ilb / a[k] else ulb / a[k]          (16)
+*     a[p] + a[p+1] <= b.                                           (21)
 *
-*     u'[k] := if a[k] > 0 then ulb / a[k] else ilb / a[k]          (17)
+*  (May note that due to the former two cases in this case we always
+*  have 2 <= p <= |J|-1.)
 *
-*  The implied bounds are stored in locations ll and uu. */
+*  Since a[p] and a[p-1] are two minimal coefficients in the set
+*  J' = {1, ..., p}, J' define a clique in the conflict graph for the
+*  same reason as in the first case. Similarly, since a[p] and a[p+1]
+*  are two maximal coefficients in the set J" = {p, ..., |J|}, no edge
+*  inequalities exist for all i, j in J" for the same reason as in the
+*  second case. Thus, to discover other edge inequalities (15) valid
+*  for (11), the routine checks if a[i] + a[j] > b for all i in J',
+*  j in J", i != j. */
 
-static void col_implied_bounds(const struct f_info *f, int n,
-      const double a[], double L, double U, const double l[],
-      const double u[], int k, double *ll, double *uu)
-{     double ilb, iub;
-      xassert(n >= 0);
-      xassert(1 <= k && k <= n);
-      /* determine implied lower bound of term a[k] * x[k] (14) */
-      if (L == -DBL_MAX || f->f_max == +DBL_MAX)
-         ilb = -DBL_MAX;
-      else if (f->j_max == 0)
-      {  if (a[k] > 0.0)
-         {  xassert(u[k] != +DBL_MAX);
-            ilb = L - (f->f_max - a[k] * u[k]);
-         }
-         else if (a[k] < 0.0)
-         {  xassert(l[k] != -DBL_MAX);
-            ilb = L - (f->f_max - a[k] * l[k]);
-         }
-         else
-            xassert(a != a);
-      }
-      else if (f->j_max == k)
-         ilb = L - f->f_max;
-      else
-         ilb = -DBL_MAX;
-      /* determine implied upper bound of term a[k] * x[k] (15) */
-      if (U == +DBL_MAX || f->f_min == -DBL_MAX)
-         iub = +DBL_MAX;
-      else if (f->j_min == 0)
-      {  if (a[k] > 0.0)
-         {  xassert(l[k] != -DBL_MAX);
-            iub = U - (f->f_min - a[k] * l[k]);
-         }
-         else if (a[k] < 0.0)
-         {  xassert(u[k] != +DBL_MAX);
-            iub = U - (f->f_min - a[k] * u[k]);
-         }
-         else
-            xassert(a != a);
-      }
-      else if (f->j_min == k)
-         iub = U - f->f_min;
-      else
-         iub = +DBL_MAX;
-      /* determine implied bounds of x[k] (16) and (17) */
-#if 1
-      /* do not use a[k] if it has small magnitude to prevent wrong
-         implied bounds; for example, 1e-15 * x1 >= x2 + x3, where
-         x1 >= -10, x2, x3 >= 0, would lead to wrong conclusion that
-         x1 >= 0 */
-      if (fabs(a[k]) < 1e-6)
-         *ll = -DBL_MAX, *uu = +DBL_MAX; else
-#endif
-      if (a[k] > 0.0)
-      {  *ll = (ilb == -DBL_MAX ? -DBL_MAX : ilb / a[k]);
-         *uu = (iub == +DBL_MAX ? +DBL_MAX : iub / a[k]);
-      }
-      else if (a[k] < 0.0)
-      {  *ll = (iub == +DBL_MAX ? -DBL_MAX : iub / a[k]);
-         *uu = (ilb == -DBL_MAX ? +DBL_MAX : ilb / a[k]);
-      }
+#define is_binary(j) \
+      (P->col[j]->kind == GLP_IV && P->col[j]->type == GLP_DB && \
+      P->col[j]->lb == 0.0 && P->col[j]->ub == 1.0)
+/* check if x[j] is binary variable */
+
+struct term { int ind; double val; };
+/* term a[j] * z[j] used to sort a[j]'s */
+
+static int CDECL fcmp(const void *e1, const void *e2)
+{     /* auxiliary routine called from qsort */
+      const struct term *t1 = e1, *t2 = e2;
+      if (t1->val > t2->val)
+         return -1;
+      else if (t1->val < t2->val)
+         return +1;
       else
-         xassert(a != a);
-      return;
+         return 0;
 }
 
-/***********************************************************************
-*  check_row_bounds - check and relax original row bounds
-*
-*  Given a row (constraint)
-*
-*           n
-*     L <= sum a[j] * x[j] <= U
-*          j=1
-*
-*  and bounds of columns (variables)
-*
-*     l[j] <= x[j] <= u[j]
-*
-*  this routine checks the original row bounds L and U for feasibility
-*  and redundancy. If the original lower bound L or/and upper bound U
-*  cannot be active due to bounds of variables, the routine remove them
-*  replacing by -inf or/and +inf, respectively.
-*
-*  If no primal infeasibility is detected, the routine returns zero,
-*  otherwise non-zero. */
-
-static int check_row_bounds(const struct f_info *f, double *L_,
-      double *U_)
-{     int ret = 0;
-      double L = *L_, U = *U_, LL, UU;
-      /* determine implied bounds of the row */
-      row_implied_bounds(f, &LL, &UU);
-      /* check if the original lower bound is infeasible */
-      if (L != -DBL_MAX)
-      {  double eps = 1e-3 * (1.0 + fabs(L));
-         if (UU < L - eps)
-         {  ret = 1;
-            goto done;
+static void analyze_ineq(glp_prob *P, CFG *G, int len, int ind[],
+      double val[], double rhs, struct term t[])
+{     /* analyze inequality constraint (6) */
+      /* P is the original MIP
+       * G is the conflict graph to be built
+       * len is the number of terms in the constraint
+       * ind[1], ..., ind[len] are indices of variables x[j]
+       * val[1], ..., val[len] are constraint coefficients a[j]
+       * rhs is the right-hand side b
+       * t[1+len] is a working array */
+      int j, k, kk, p, q, type, new_len;
+      /* eliminate non-binary variables; see (7) and (8) */
+      new_len = 0;
+      for (k = 1; k <= len; k++)
+      {  /* get index of variable x[j] */
+         j = ind[k];
+         if (is_binary(j))
+         {  /* x[j] remains in relaxed constraint */
+            new_len++;
+            ind[new_len] = j;
+            val[new_len] = val[k];
+         }
+         else if (val[k] > 0.0)
+         {  /* eliminate non-binary x[j] in case a[j] > 0 */
+            /* b := b - a[j] * l[j]; see (8) */
+            type = P->col[j]->type;
+            if (type == GLP_FR || type == GLP_UP)
+            {  /* x[j] has no lower bound */
+               goto done;
+            }
+            rhs -= val[k] * P->col[j]->lb;
          }
-      }
-      /* check if the original upper bound is infeasible */
-      if (U != +DBL_MAX)
-      {  double eps = 1e-3 * (1.0 + fabs(U));
-         if (LL > U + eps)
-         {  ret = 1;
-            goto done;
+         else /* val[j] < 0.0 */
+         {  /* eliminate non-binary x[j] in case a[j] < 0 */
+            /* b := b - a[j] * u[j]; see (8) */
+            type = P->col[j]->type;
+            if (type == GLP_FR || type == GLP_LO)
+            {  /* x[j] has no upper bound */
+               goto done;
+            }
+            rhs -= val[k] * P->col[j]->ub;
          }
       }
-      /* check if the original lower bound is redundant */
-      if (L != -DBL_MAX)
-      {  double eps = 1e-12 * (1.0 + fabs(L));
-         if (LL > L - eps)
-         {  /* it cannot be active, so remove it */
-            *L_ = -DBL_MAX;
-         }
+      len = new_len;
+      /* now we have the constraint (9) */
+      if (len <= 1)
+      {  /* at least two terms are needed */
+         goto done;
+      }
+      /* make all constraint coefficients positive; see (10) */
+      for (k = 1; k <= len; k++)
+      {  if (val[k] < 0.0)
+         {  /* a[j] < 0; substitute x[j] = 1 - x'[j], where x'[j] is
+             * a complement binary variable */
+            ind[k] = -ind[k];
+            val[k] = -val[k];
+            rhs += val[k];
+         }
+      }
+      /* now we have 0-1 knapsack inequality (11) */
+      /* increase the right-hand side a bit to avoid false checks due
+       * to rounding errors */
+      rhs += 0.001 * (1.0 + fabs(rhs));
+      /*** first case ***/
+      /* find two minimal coefficients a[p] and a[q] */
+      p = 0;
+      for (k = 1; k <= len; k++)
+      {  if (p == 0 || val[p] > val[k])
+            p = k;
+      }
+      q = 0;
+      for (k = 1; k <= len; k++)
+      {  if (k != p && (q == 0 || val[q] > val[k]))
+            q = k;
+      }
+      xassert(p != 0 && q != 0 && p != q);
+      /* check condition (14) */
+      if (val[p] + val[q] > rhs)
+      {  /* all z[j] define a clique in the conflict graph */
+         cfg_add_clique(G, len, ind);
+         goto done;
+      }
+      /*** second case ***/
+      /* find two maximal coefficients a[p] and a[q] */
+      p = 0;
+      for (k = 1; k <= len; k++)
+      {  if (p == 0 || val[p] < val[k])
+            p = k;
+      }
+      q = 0;
+      for (k = 1; k <= len; k++)
+      {  if (k != p && (q == 0 || val[q] < val[k]))
+            q = k;
+      }
+      xassert(p != 0 && q != 0 && p != q);
+      /* check condition (18) */
+      if (val[p] + val[q] <= rhs)
+      {  /* no valid edge inequalities exist */
+         goto done;
+      }
+      /*** third case ***/
+      xassert(len >= 3);
+      /* sort terms in descending order of coefficient values */
+      for (k = 1; k <= len; k++)
+      {  t[k].ind = ind[k];
+         t[k].val = val[k];
+      }
+      qsort(&t[1], len, sizeof(struct term), fcmp);
+      for (k = 1; k <= len; k++)
+      {  ind[k] = t[k].ind;
+         val[k] = t[k].val;
+      }
+      /* now a[1] >= a[2] >= ... >= a[len-1] >= a[len] */
+      /* note that a[1] + a[2] > b and a[len-1] + a[len] <= b due two
+       * the former two cases */
+      xassert(val[1] + val[2] > rhs);
+      xassert(val[len-1] + val[len] <= rhs);
+      /* find p according to conditions (20) and (21) */
+      for (p = 2; p < len; p++)
+      {  if (val[p] + val[p+1] <= rhs)
+            break;
       }
-      /* check if the original upper bound is redundant */
-      if (U != +DBL_MAX)
-      {  double eps = 1e-12 * (1.0 + fabs(U));
-         if (UU < U + eps)
-         {  /* it cannot be active, so remove it */
-            *U_ = +DBL_MAX;
+      xassert(p < len);
+      /* z[1], ..., z[p] define a clique in the conflict graph */
+      cfg_add_clique(G, p, ind);
+      /* discover other edge inequalities */
+      for (k = 1; k <= p; k++)
+      {  for (kk = p; kk <= len; kk++)
+         {  if (k != kk && val[k] + val[kk] > rhs)
+            {  int iii[1+2];
+               iii[1] = ind[k];
+               iii[2] = ind[kk];
+               cfg_add_clique(G, 2, iii);
+            }
          }
       }
-done: return ret;
+done: return;
 }
 
-/***********************************************************************
-*  check_col_bounds - check and tighten original column bounds
-*
-*  Given a row (constraint)
-*
-*           n
-*     L <= sum a[j] * x[j] <= U
-*          j=1
-*
-*  and bounds of columns (variables)
-*
-*     l[j] <= x[j] <= u[j]
-*
-*  for column (variable) x[j] this routine checks the original column
-*  bounds l[j] and u[j] for feasibility and redundancy. If the original
-*  lower bound l[j] or/and upper bound u[j] cannot be active due to
-*  bounds of the constraint and other variables, the routine tighten
-*  them replacing by corresponding implied bounds, if possible.
-*
-*  NOTE: It is assumed that if L != -inf, the row lower bound can be
-*        active, and if U != +inf, the row upper bound can be active.
-*
-*  The flag means that variable x[j] is required to be integer.
-*
-*  New actual bounds for x[j] are stored in locations lj and uj.
-*
-*  If no primal infeasibility is detected, the routine returns zero,
-*  otherwise non-zero. */
-
-static int check_col_bounds(const struct f_info *f, int n,
-      const double a[], double L, double U, const double l[],
-      const double u[], int flag, int j, double *_lj, double *_uj)
-{     int ret = 0;
-      double lj, uj, ll, uu;
-      xassert(n >= 0);
-      xassert(1 <= j && j <= n);
-      lj = l[j], uj = u[j];
-      /* determine implied bounds of the column */
-      col_implied_bounds(f, n, a, L, U, l, u, j, &ll, &uu);
-      /* if x[j] is integral, round its implied bounds */
-      if (flag)
-      {  if (ll != -DBL_MAX)
-            ll = (ll - floor(ll) < 1e-3 ? floor(ll) : ceil(ll));
-         if (uu != +DBL_MAX)
-            uu = (ceil(uu) - uu < 1e-3 ? ceil(uu) : floor(uu));
-      }
-      /* check if the original lower bound is infeasible */
-      if (lj != -DBL_MAX)
-      {  double eps = 1e-3 * (1.0 + fabs(lj));
-         if (uu < lj - eps)
-         {  ret = 1;
-            goto done;
-         }
-      }
-      /* check if the original upper bound is infeasible */
-      if (uj != +DBL_MAX)
-      {  double eps = 1e-3 * (1.0 + fabs(uj));
-         if (ll > uj + eps)
-         {  ret = 1;
-            goto done;
-         }
-      }
-      /* check if the original lower bound is redundant */
-      if (ll != -DBL_MAX)
-      {  double eps = 1e-3 * (1.0 + fabs(ll));
-         if (lj < ll - eps)
-         {  /* it cannot be active, so tighten it */
-            lj = ll;
-         }
-      }
-      /* check if the original upper bound is redundant */
-      if (uu != +DBL_MAX)
-      {  double eps = 1e-3 * (1.0 + fabs(uu));
-         if (uj > uu + eps)
-         {  /* it cannot be active, so tighten it */
-            uj = uu;
-         }
-      }
-      /* due to round-off errors it may happen that lj > uj (although
-         lj < uj + eps, since no primal infeasibility is detected), so
-         adjuct the new actual bounds to provide lj <= uj */
-      if (!(lj == -DBL_MAX || uj == +DBL_MAX))
-      {  double t1 = fabs(lj), t2 = fabs(uj);
-         double eps = 1e-10 * (1.0 + (t1 <= t2 ? t1 : t2));
-         if (lj > uj - eps)
-         {  if (lj == l[j])
-               uj = lj;
-            else if (uj == u[j])
-               lj = uj;
-            else if (t1 <= t2)
-               uj = lj;
-            else
-               lj = uj;
-         }
-      }
-      *_lj = lj, *_uj = uj;
-done: return ret;
+CFG *cfg_build_graph(void *P_)
+{     glp_prob *P = P_;
+      int m = P->m;
+      int n = P->n;
+      CFG *G;
+      int i, k, type, len, *ind;
+      double *val;
+      struct term *t;
+      /* create the conflict graph (number of its vertices cannot be
+       * greater than double number of binary variables) */
+      G = cfg_create_graph(n, 2 * glp_get_num_bin(P));
+      /* allocate working arrays */
+      ind = talloc(1+n, int);
+      val = talloc(1+n, double);
+      t = talloc(1+n, struct term);
+      /* analyze constraints to discover edge inequalities */
+      for (i = 1; i <= m; i++)
+      {  type = P->row[i]->type;
+         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
+         {  /* i-th row has lower bound */
+            /* analyze inequality sum (-a[j]) * x[j] <= -lb */
+            len = glp_get_mat_row(P, i, ind, val);
+            for (k = 1; k <= len; k++)
+               val[k] = -val[k];
+            analyze_ineq(P, G, len, ind, val, -P->row[i]->lb, t);
+         }
+         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)
+         {  /* i-th row has upper bound */
+            /* analyze inequality sum (+a[j]) * x[j] <= +ub */
+            len = glp_get_mat_row(P, i, ind, val);
+            analyze_ineq(P, G, len, ind, val, +P->row[i]->ub, t);
+         }
+      }
+      /* free working arrays */
+      tfree(ind);
+      tfree(val);
+      tfree(t);
+      return G;
 }
 
 /***********************************************************************
-*  check_efficiency - check if change in column bounds is efficient
+*  cfg_find_clique - find maximum weight clique in conflict graph
 *
-*  Given the original bounds of a column l and u and its new actual
-*  bounds l' and u' (possibly tighten by the routine check_col_bounds)
-*  this routine checks if the change in the column bounds is efficient
-*  enough. If so, the routine returns non-zero, otherwise zero.
-*
-*  The flag means that the variable is required to be integer. */
-
-static int check_efficiency(int flag, double l, double u, double ll,
-      double uu)
-{     int eff = 0;
-      /* check efficiency for lower bound */
-      if (l < ll)
-      {  if (flag || l == -DBL_MAX)
-            eff++;
-         else
-         {  double r;
-            if (u == +DBL_MAX)
-               r = 1.0 + fabs(l);
-            else
-               r = 1.0 + (u - l);
-            if (ll - l >= 0.25 * r)
-               eff++;
+*  This routine finds a maximum weight clique in the conflict graph
+*  G = (V, E), where the weight of vertex v in V is the value of
+*  corresponding binary variable z (which is either an original binary
+*  variable or its complement) in the optimal solution to LP relaxation
+*  provided in the problem object. The goal is to find a clique in G,
+*  whose weight is greater than 1, in which case corresponding packing
+*  inequality is violated at the optimal point.
+*
+*  On exit the routine stores vertex indices of the conflict graph
+*  included in the clique found to locations ind[1], ..., ind[len], and
+*  returns len, which is the clique size. The clique weight is stored
+*  in location pointed to by the parameter sum. If no clique has been
+*  found, the routine returns 0.
+*
+*  Since the conflict graph may have a big number of vertices and be
+*  quite dense, the routine uses an induced subgraph G' = (V', E'),
+*  which is constructed as follows:
+*
+*  1. If the weight of some vertex v in V is zero (close to zero), it
+*     is not included in V'. Obviously, including in a clique
+*     zero-weight vertices does not change its weight, so if in G there
+*     exist a clique of a non-zero weight, in G' exists a clique of the
+*     same weight. This point is extremely important, because dropping
+*     out zero-weight vertices can be done without retrieving lists of
+*     adjacent vertices whose size may be very large.
+*
+*  2. Cumulative weight of vertex v in V is the sum of the weight of v
+*     and weights of all vertices in V adjacent to v. Obviously, if
+*     a clique includes a vertex v, the clique weight cannot be greater
+*     than the cumulative weight of v. Since we are interested only in
+*     cliques whose weight is greater than 1, vertices of V, whose
+*     cumulative weight is not greater than 1, are not included in V'.
+*
+*  May note that in many practical cases the size of the induced
+*  subgraph G' is much less than the size of the original conflict
+*  graph G due to many binary variables, whose optimal values are zero
+*  or close to zero. For example, it may happen that |V| = 100,000 and
+*  |E| = 1e9 while |V'| = 50 and |E'| = 1000. */
+
+struct csa
+{     /* common storage area */
+      glp_prob *P;
+      /* original MIP */
+      CFG *G;
+      /* original conflict graph G = (V, E), |V| = nv */
+      int *ind; /* int ind[1+nv]; */
+      /* working array */
+      /*--------------------------------------------------------------*/
+      /* induced subgraph G' = (V', E') of original conflict graph */
+      int nn;
+      /* number of vertices in V' */
+      int *vtoi; /* int vtoi[1+nv]; */
+      /* vtoi[v] = i, 1 <= v <= nv, means that vertex v in V is vertex
+       * i in V'; vtoi[v] = 0 means that vertex v is not included in
+       * the subgraph */
+      int *itov; /* int itov[1+nv]; */
+      /* itov[i] = v, 1 <= i <= nn, means that vertex i in V' is vertex
+       * v in V */
+      double *wgt; /* double wgt[1+nv]; */
+      /* wgt[i], 1 <= i <= nn, is a weight of vertex i in V', which is
+       * the value of corresponding binary variable in optimal solution
+       * to LP relaxation */
+};
+
+static void build_subgraph(struct csa *csa)
+{     /* build induced subgraph */
+      glp_prob *P = csa->P;
+      int n = P->n;
+      CFG *G = csa->G;
+      int *ind = csa->ind;
+      int *pos = G->pos;
+      int *neg = G->neg;
+      int nv = G->nv;
+      int *ref = G->ref;
+      int *vtoi = csa->vtoi;
+      int *itov = csa->itov;
+      double *wgt = csa->wgt;
+      int j, k, v, w, nn, len;
+      double z, sum;
+      /* initially induced subgraph is empty */
+      nn = 0;
+      /* walk thru vertices of original conflict graph */
+      for (v = 1; v <= nv; v++)
+      {  /* determine value of binary variable z[j] that corresponds to
+          * vertex v */
+         j = ref[v];
+         xassert(1 <= j && j <= n);
+         if (pos[j] == v)
+         {  /* z[j] = x[j], where x[j] is original variable */
+            z = P->col[j]->prim;
+         }
+         else if (neg[j] == v)
+         {  /* z[j] = 1 - x[j], where x[j] is original variable */
+            z = 1.0 - P->col[j]->prim;
          }
-      }
-      /* check efficiency for upper bound */
-      if (u > uu)
-      {  if (flag || u == +DBL_MAX)
-            eff++;
          else
-         {  double r;
-            if (l == -DBL_MAX)
-               r = 1.0 + fabs(u);
+            xassert(v != v);
+         /* if z[j] is close to zero, do not include v in the induced
+          * subgraph */
+         if (z < 0.001)
+         {  vtoi[v] = 0;
+            continue;
+         }
+         /* calculate cumulative weight of vertex v */
+         sum = z;
+         /* walk thru all vertices adjacent to v */
+         len = cfg_get_adjacent(G, v, ind);
+         for (k = 1; k <= len; k++)
+         {  /* there is an edge (v,w) in the conflict graph */
+            w = ind[k];
+            xassert(w != v);
+            /* add value of z[j] that corresponds to vertex w */
+            j = ref[w];
+            xassert(1 <= j && j <= n);
+            if (pos[j] == w)
+               sum += P->col[j]->prim;
+            else if (neg[j] == w)
+               sum += 1.0 - P->col[j]->prim;
             else
-               r = 1.0 + (u - l);
-            if (u - uu >= 0.25 * r)
-               eff++;
+               xassert(w != w);
          }
+         /* cumulative weight of vertex v is an upper bound of weight
+          * of any clique containing v; so if it not greater than 1, do
+          * not include v in the induced subgraph */
+         if (sum < 1.010)
+         {  vtoi[v] = 0;
+            continue;
+         }
+         /* include vertex v in the induced subgraph */
+         nn++;
+         vtoi[v] = nn;
+         itov[nn] = v;
+         wgt[nn] = z;
       }
-      return eff;
+      /* induced subgraph has been built */
+      csa->nn = nn;
+      return;
 }
 
-/***********************************************************************
-*  basic_preprocessing - perform basic preprocessing
-*
-*  This routine performs basic preprocessing of the specified MIP that
-*  includes relaxing some row bounds and tightening some column bounds.
-*
-*  On entry the arrays L and U contains original row bounds, and the
-*  arrays l and u contains original column bounds:
-*
-*  L[0] is the lower bound of the objective row;
-*  L[i], i = 1,...,m, is the lower bound of i-th row;
-*  U[0] is the upper bound of the objective row;
-*  U[i], i = 1,...,m, is the upper bound of i-th row;
-*  l[0] is not used;
-*  l[j], j = 1,...,n, is the lower bound of j-th column;
-*  u[0] is not used;
-*  u[j], j = 1,...,n, is the upper bound of j-th column.
-*
-*  On exit the arrays L, U, l, and u contain new actual bounds of rows
-*  and column in the same locations.
-*
-*  The parameters nrs and num specify an initial list of rows to be
-*  processed:
-*
-*  nrs is the number of rows in the initial list, 0 <= nrs <= m+1;
-*  num[0] is not used;
-*  num[1,...,nrs] are row numbers (0 means the objective row).
-*
-*  The parameter max_pass specifies the maximal number of times that
-*  each row can be processed, max_pass > 0.
-*
-*  If no primal infeasibility is detected, the routine returns zero,
-*  otherwise non-zero. */
-
-static int basic_preprocessing(glp_prob *mip, double L[], double U[],
-      double l[], double u[], int nrs, const int num[], int max_pass)
-{     int m = mip->m;
-      int n = mip->n;
-      struct f_info f;
-      int i, j, k, len, size, ret = 0;
-      int *ind, *list, *mark, *pass;
-      double *val, *lb, *ub;
-      xassert(0 <= nrs && nrs <= m+1);
-      xassert(max_pass > 0);
-      /* allocate working arrays */
-      ind = xcalloc(1+n, sizeof(int));
-      list = xcalloc(1+m+1, sizeof(int));
-      mark = xcalloc(1+m+1, sizeof(int));
-      memset(&mark[0], 0, (m+1) * sizeof(int));
-      pass = xcalloc(1+m+1, sizeof(int));
-      memset(&pass[0], 0, (m+1) * sizeof(int));
-      val = xcalloc(1+n, sizeof(double));
-      lb = xcalloc(1+n, sizeof(double));
-      ub = xcalloc(1+n, sizeof(double));
-      /* initialize the list of rows to be processed */
-      size = 0;
-      for (k = 1; k <= nrs; k++)
-      {  i = num[k];
-         xassert(0 <= i && i <= m);
-         /* duplicate row numbers are not allowed */
-         xassert(!mark[i]);
-         list[++size] = i, mark[i] = 1;
-      }
-      xassert(size == nrs);
-      /* process rows in the list until it becomes empty */
-      while (size > 0)
-      {  /* get a next row from the list */
-         i = list[size--], mark[i] = 0;
-         /* increase the row processing count */
-         pass[i]++;
-         /* if the row is free, skip it */
-         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;
-         /* obtain coefficients of the row */
-         len = 0;
-         if (i == 0)
-         {  for (j = 1; j <= n; j++)
-            {  GLPCOL *col = mip->col[j];
-               if (col->coef != 0.0)
-                  len++, ind[len] = j, val[len] = col->coef;
-            }
-         }
-         else
-         {  GLPROW *row = mip->row[i];
-            GLPAIJ *aij;
-            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
-               len++, ind[len] = aij->col->j, val[len] = aij->val;
-         }
-         /* determine lower and upper bounds of columns corresponding
-            to non-zero row coefficients */
-         for (k = 1; k <= len; k++)
-            j = ind[k], lb[k] = l[j], ub[k] = u[j];
-         /* prepare the row info to determine implied bounds */
-         prepare_row_info(len, val, lb, ub, &f);
-         /* check and relax bounds of the row */
-         if (check_row_bounds(&f, &L[i], &U[i]))
-         {  /* the feasible region is empty */
-            ret = 1;
-            goto done;
-         }
-         /* if the row became free, drop it */
-         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;
-         /* process columns having non-zero coefficients in the row */
-         for (k = 1; k <= len; k++)
-         {  GLPCOL *col;
-            int flag, eff;
-            double ll, uu;
-            /* take a next column in the row */
-            j = ind[k], col = mip->col[j];
-            flag = col->kind != GLP_CV;
-            /* check and tighten bounds of the column */
-            if (check_col_bounds(&f, len, val, L[i], U[i], lb, ub,
-                flag, k, &ll, &uu))
-            {  /* the feasible region is empty */
-               ret = 1;
-               goto done;
-            }
-            /* check if change in the column bounds is efficient */
-            eff = check_efficiency(flag, l[j], u[j], ll, uu);
-            /* set new actual bounds of the column */
-            l[j] = ll, u[j] = uu;
-            /* if the change is efficient, add all rows affected by the
-               corresponding column, to the list */
-            if (eff > 0)
-            {  GLPAIJ *aij;
-               for (aij = col->ptr; aij != NULL; aij = aij->c_next)
-               {  int ii = aij->row->i;
-                  /* if the row was processed maximal number of times,
-                     skip it */
-                  if (pass[ii] >= max_pass) continue;
-                  /* if the row is free, skip it */
-                  if (L[ii] == -DBL_MAX && U[ii] == +DBL_MAX) continue;
-                  /* put the row into the list */
-                  if (mark[ii] == 0)
-                  {  xassert(size <= m);
-                     list[++size] = ii, mark[ii] = 1;
-                  }
-               }
-            }
+static int sub_adjacent(struct csa *csa, int i, int adj[])
+{     /* retrieve vertices of induced subgraph adjacent to specified
+       * vertex */
+      CFG *G = csa->G;
+      int nv = G->nv;
+      int *ind = csa->ind;
+      int nn = csa->nn;
+      int *vtoi = csa->vtoi;
+      int *itov = csa->itov;
+      int j, k, v, w, len, len1;
+      /* determine original vertex v corresponding to vertex i */
+      xassert(1 <= i && i <= nn);
+      v = itov[i];
+      /* retrieve vertices adjacent to vertex v in original graph */
+      len1 = cfg_get_adjacent(G, v, ind);
+      /* keep only adjacent vertices which are in induced subgraph and
+       * change their numbers appropriately */
+      len = 0;
+      for (k = 1; k <= len1; k++)
+      {  /* there exists edge (v, w) in original graph */
+         w = ind[k];
+         xassert(1 <= w && w <= nv && w != v);
+         j = vtoi[w];
+         if (j != 0)
+         {  /* vertex w is vertex j in induced subgraph */
+            xassert(1 <= j && j <= nn && j != i);
+            adj[++len] = j;
          }
       }
-done: /* free working arrays */
-      xfree(ind);
-      xfree(list);
-      xfree(mark);
-      xfree(pass);
-      xfree(val);
-      xfree(lb);
-      xfree(ub);
-      return ret;
+      return len;
 }
 
-/***********************************************************************
-*  NAME
-*
-*  ios_preprocess_node - preprocess current subproblem
-*
-*  SYNOPSIS
-*
-*  #include "glpios.h"
-*  int ios_preprocess_node(glp_tree *tree, int max_pass);
-*
-*  DESCRIPTION
-*
-*  The routine ios_preprocess_node performs basic preprocessing of the
-*  current subproblem.
-*
-*  RETURNS
-*
-*  If no primal infeasibility is detected, the routine returns zero,
-*  otherwise non-zero. */
-
-int ios_preprocess_node(glp_tree *tree, int max_pass)
-{     glp_prob *mip = tree->mip;
-      int m = mip->m;
-      int n = mip->n;
-      int i, j, nrs, *num, ret = 0;
-      double *L, *U, *l, *u;
-      /* the current subproblem must exist */
-      xassert(tree->curr != NULL);
-      /* determine original row bounds */
-      L = xcalloc(1+m, sizeof(double));
-      U = xcalloc(1+m, sizeof(double));
-      switch (mip->mip_stat)
-      {  case GLP_UNDEF:
-            L[0] = -DBL_MAX, U[0] = +DBL_MAX;
-            break;
-         case GLP_FEAS:
-            switch (mip->dir)
-            {  case GLP_MIN:
-                  L[0] = -DBL_MAX, U[0] = mip->mip_obj - mip->c0;
-                  break;
-               case GLP_MAX:
-                  L[0] = mip->mip_obj - mip->c0, U[0] = +DBL_MAX;
-                  break;
-               default:
-                  xassert(mip != mip);
-            }
-            break;
-         default:
-            xassert(mip != mip);
-      }
-      for (i = 1; i <= m; i++)
-      {  L[i] = glp_get_row_lb(mip, i);
-         U[i] = glp_get_row_ub(mip, i);
-      }
-      /* determine original column bounds */
-      l = xcalloc(1+n, sizeof(double));
-      u = xcalloc(1+n, sizeof(double));
-      for (j = 1; j <= n; j++)
-      {  l[j] = glp_get_col_lb(mip, j);
-         u[j] = glp_get_col_ub(mip, j);
-      }
-      /* build the initial list of rows to be analyzed */
-      nrs = m + 1;
-      num = xcalloc(1+nrs, sizeof(int));
-      for (i = 1; i <= nrs; i++) num[i] = i - 1;
-      /* perform basic preprocessing */
-      if (basic_preprocessing(mip , L, U, l, u, nrs, num, max_pass))
-      {  ret = 1;
-         goto done;
+static int find_clique(struct csa *csa, int c_ind[])
+{     /* find maximum weight clique in induced subgraph with exact
+       * Ostergard's algorithm */
+      int nn = csa->nn;
+      double *wgt = csa->wgt;
+      int i, j, k, p, q, t, ne, nb, len, *iwt, *ind;
+      unsigned char *a;
+      xassert(nn >= 2);
+      /* allocate working array */
+      ind = talloc(1+nn, int);
+      /* calculate the number of elements in lower triangle (without
+       * diagonal) of adjacency matrix of induced subgraph */
+      ne = (nn * (nn - 1)) / 2;
+      /* calculate the number of bytes needed to store lower triangle
+       * of adjacency matrix */
+      nb = (ne + (CHAR_BIT - 1)) / CHAR_BIT;
+      /* allocate lower triangle of adjacency matrix */
+      a = talloc(nb, unsigned char);
+      /* fill lower triangle of adjacency matrix */
+      memset(a, 0, nb);
+      for (p = 1; p <= nn; p++)
+      {  /* retrieve vertices adjacent to vertex p */
+         len = sub_adjacent(csa, p, ind);
+         for (k = 1; k <= len; k++)
+         {  /* there exists edge (p, q) in induced subgraph */
+            q = ind[k];
+            xassert(1 <= q && q <= nn && q != p);
+            /* determine row and column indices of this edge in lower
+             * triangle of adjacency matrix */
+            if (p > q)
+               i = p, j = q;
+            else /* p < q */
+               i = q, j = p;
+            /* set bit a[i,j] to 1, i > j */
+            t = ((i - 1) * (i - 2)) / 2 + (j - 1);
+            a[t / CHAR_BIT] |=
+               (unsigned char)(1 << ((CHAR_BIT - 1) - t % CHAR_BIT));
+         }
+      }
+      /* scale vertex weights by 1000 and convert them to integers as
+       * required by Ostergard's algorithm */
+      iwt = ind;
+      for (i = 1; i <= nn; i++)
+      {  /* it is assumed that 0 <= wgt[i] <= 1 */
+         t = (int)(1000.0 * wgt[i] + 0.5);
+         if (t < 0)
+            t = 0;
+         else if (t > 1000)
+            t = 1000;
+         iwt[i] = t;
+      }
+      /* find maximum weight clique */
+      len = wclique(nn, iwt, a, c_ind);
+      /* free working arrays */
+      tfree(ind);
+      tfree(a);
+      /* return clique size to calling routine */
+      return len;
+}
+
+static int func(void *info, int i, int ind[])
+{     /* auxiliary routine used by routine find_clique1 */
+      struct csa *csa = info;
+      xassert(1 <= i && i <= csa->nn);
+      return sub_adjacent(csa, i, ind);
+}
+
+static int find_clique1(struct csa *csa, int c_ind[])
+{     /* find maximum weight clique in induced subgraph with greedy
+       * heuristic */
+      int nn = csa->nn;
+      double *wgt = csa->wgt;
+      int len;
+      xassert(nn >= 2);
+      len = wclique1(nn, wgt, func, csa, c_ind);
+      /* return clique size to calling routine */
+      return len;
+}
+
+int cfg_find_clique(void *P, CFG *G, int ind[], double *sum_)
+{     int nv = G->nv;
+      struct csa csa;
+      int i, k, len;
+      double sum;
+      /* initialize common storage area */
+      csa.P = P;
+      csa.G = G;
+      csa.ind = talloc(1+nv, int);
+      csa.nn = -1;
+      csa.vtoi = talloc(1+nv, int);
+      csa.itov = talloc(1+nv, int);
+      csa.wgt = talloc(1+nv, double);
+      /* build induced subgraph */
+      build_subgraph(&csa);
+#ifdef GLP_DEBUG
+      xprintf("nn = %d\n", csa.nn);
+#endif
+      /* if subgraph has less than two vertices, do nothing */
+      if (csa.nn < 2)
+      {  len = 0;
+         sum = 0.0;
+         goto skip;
+      }
+      /* find maximum weight clique in induced subgraph */
+#if 1 /* FIXME */
+      if (csa.nn <= 50)
+#endif
+      {  /* induced subgraph is small; use exact algorithm */
+         len = find_clique(&csa, ind);
       }
-      /* set new actual (relaxed) row bounds */
-      for (i = 1; i <= m; i++)
-      {  /* consider only non-active rows to keep dual feasibility */
-         if (glp_get_row_stat(mip, i) == GLP_BS)
-         {  if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)
-               glp_set_row_bnds(mip, i, GLP_FR, 0.0, 0.0);
-            else if (U[i] == +DBL_MAX)
-               glp_set_row_bnds(mip, i, GLP_LO, L[i], 0.0);
-            else if (L[i] == -DBL_MAX)
-               glp_set_row_bnds(mip, i, GLP_UP, 0.0, U[i]);
-         }
-      }
-      /* set new actual (tightened) column bounds */
-      for (j = 1; j <= n; j++)
-      {  int type;
-         if (l[j] == -DBL_MAX && u[j] == +DBL_MAX)
-            type = GLP_FR;
-         else if (u[j] == +DBL_MAX)
-            type = GLP_LO;
-         else if (l[j] == -DBL_MAX)
-            type = GLP_UP;
-         else if (l[j] != u[j])
-            type = GLP_DB;
-         else
-            type = GLP_FX;
-         glp_set_col_bnds(mip, j, type, l[j], u[j]);
+      else
+      {  /* induced subgraph is large; use greedy heuristic */
+         len = find_clique1(&csa, ind);
       }
-done: /* free working arrays and return */
-      xfree(L);
-      xfree(U);
-      xfree(l);
-      xfree(u);
-      xfree(num);
-      return ret;
+      /* do not report clique, if it has less than two vertices */
+      if (len < 2)
+      {  len = 0;
+         sum = 0.0;
+         goto skip;
+      }
+      /* convert indices of clique vertices from induced subgraph to
+       * original conflict graph and compute clique weight */
+      sum = 0.0;
+      for (k = 1; k <= len; k++)
+      {  i = ind[k];
+         xassert(1 <= i && i <= csa.nn);
+         sum += csa.wgt[i];
+         ind[k] = csa.itov[i];
+      }
+skip: /* free working arrays */
+      tfree(csa.ind);
+      tfree(csa.vtoi);
+      tfree(csa.itov);
+      tfree(csa.wgt);
+      /* return to calling routine */
+      *sum_ = sum;
+      return len;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios03.c`

 * *Files 14% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpios03.c (branch-and-cut driver) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2005-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#endif
-
-#include "glpios.h"
+#include "env.h"
+#include "ios.h"
 
 /***********************************************************************
 *  show_progress - display current progress of the search
 *
 *  This routine displays some information about current progress of the
 *  search.
 *
@@ -72,15 +65,18 @@
       else
       {  temp = T->slot[p].node->bound;
          if (temp == -DBL_MAX)
             sprintf(best_bound, "%17s", "-inf");
          else if (temp == +DBL_MAX)
             sprintf(best_bound, "%17s", "+inf");
          else
+         {  if (fabs(temp) < 1e-9)
+               temp = 0;
             sprintf(best_bound, "%17.9e", temp);
+         }
       }
       /* choose the relation sign between global bounds */
       if (T->mip->dir == GLP_MIN)
          rho = ">=";
       else if (T->mip->dir == GLP_MAX)
          rho = "<=";
       else
@@ -561,16 +557,187 @@
             xprintf("One hopeless branch has been pruned\n");
          else if (count > 1)
             xprintf("%d hopeless branches have been pruned\n", count);
       }
       return;
 }
 
+/***********************************************************************
+*  round_heur - simple rounding heuristic
+*
+*  This routine attempts to guess an integer feasible solution by
+*  simple rounding values of all integer variables in basic solution to
+*  nearest integers. */
+
+static int round_heur(glp_tree *T)
+{     glp_prob *P = T->mip;
+      /*int m = P->m;*/
+      int n = P->n;
+      int i, j, ret;
+      double *x;
+      /* compute rounded values of variables */
+      x = talloc(1+n, double);
+      for (j = 1; j <= n; j++)
+      {  GLPCOL *col = P->col[j];
+         if (col->kind == GLP_IV)
+         {  /* integer variable */
+            x[j] = floor(col->prim + 0.5);
+         }
+         else if (col->type == GLP_FX)
+         {  /* fixed variable */
+            x[j] = col->prim;
+         }
+         else
+         {  /* non-integer non-fixed variable */
+            ret = 3;
+            goto done;
+         }
+      }
+      /* check that no constraints are violated */
+      for (i = 1; i <= T->orig_m; i++)
+      {  int type = T->orig_type[i];
+         GLPAIJ *aij;
+         double sum;
+         if (type == GLP_FR)
+            continue;
+         /* compute value of linear form */
+         sum = 0.0;
+         for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)
+            sum += aij->val * x[aij->col->j];
+         /* check lower bound */
+         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)
+         {  if (sum < T->orig_lb[i] - 1e-9)
+            {  /* lower bound is violated */
+               ret = 2;
+               goto done;
+            }
+         }
+         /* check upper bound */
+         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)
+         {  if (sum > T->orig_ub[i] + 1e-9)
+            {  /* upper bound is violated */
+               ret = 2;
+               goto done;
+            }
+         }
+      }
+      /* rounded solution is integer feasible */
+      if (glp_ios_heur_sol(T, x) == 0)
+      {  /* solution is accepted */
+         ret = 0;
+      }
+      else
+      {  /* solution is rejected */
+         ret = 1;
+      }
+done: tfree(x);
+      return ret;
+}
+
 /**********************************************************************/
 
+#if 1 /* 08/III-2016 */
+static void gmi_gen(glp_tree *T)
+{     /* generate Gomory's mixed integer cuts */
+      glp_prob *P, *pool;
+      P = T->mip;
+      pool = glp_create_prob();
+      glp_add_cols(pool, P->n);
+      glp_gmi_gen(P, pool, 50);
+      if (pool->m > 0)
+      {  int i, len, *ind;
+         double *val;
+         ind = xcalloc(1+P->n, sizeof(int));
+         val = xcalloc(1+P->n, sizeof(double));
+         for (i = 1; i <= pool->m; i++)
+         {  len = glp_get_mat_row(pool, i, ind, val);
+            glp_ios_add_row(T, NULL, GLP_RF_GMI, 0, len, ind, val,
+               GLP_LO, pool->row[i]->lb);
+         }
+         xfree(ind);
+         xfree(val);
+      }
+      glp_delete_prob(pool);
+      return;
+}
+#endif
+
+#ifdef NEW_COVER /* 13/II-2018 */
+static void cov_gen(glp_tree *T)
+{     /* generate cover cuts */
+      glp_prob *P, *pool;
+      if (T->cov_gen == NULL)
+         return;
+      P = T->mip;
+      pool = glp_create_prob();
+      glp_add_cols(pool, P->n);
+      glp_cov_gen1(P, T->cov_gen, pool);
+      if (pool->m > 0)
+      {  int i, len, *ind;
+         double *val;
+         ind = xcalloc(1+P->n, sizeof(int));
+         val = xcalloc(1+P->n, sizeof(double));
+         for (i = 1; i <= pool->m; i++)
+         {  len = glp_get_mat_row(pool, i, ind, val);
+            glp_ios_add_row(T, NULL, GLP_RF_COV, 0, len, ind, val,
+               GLP_UP, pool->row[i]->ub);
+         }
+         xfree(ind);
+         xfree(val);
+      }
+      glp_delete_prob(pool);
+      return;
+}
+#endif
+
+#if 1 /* 08/III-2016 */
+static void mir_gen(glp_tree *T)
+{     /* generate mixed integer rounding cuts */
+      glp_prob *P, *pool;
+      P = T->mip;
+      pool = glp_create_prob();
+      glp_add_cols(pool, P->n);
+      glp_mir_gen(P, T->mir_gen, pool);
+      if (pool->m > 0)
+      {  int i, len, *ind;
+         double *val;
+         ind = xcalloc(1+P->n, sizeof(int));
+         val = xcalloc(1+P->n, sizeof(double));
+         for (i = 1; i <= pool->m; i++)
+         {  len = glp_get_mat_row(pool, i, ind, val);
+            glp_ios_add_row(T, NULL, GLP_RF_MIR, 0, len, ind, val,
+               GLP_UP, pool->row[i]->ub);
+         }
+         xfree(ind);
+         xfree(val);
+      }
+      glp_delete_prob(pool);
+      return;
+}
+#endif
+
+#if 1 /* 08/III-2016 */
+static void clq_gen(glp_tree *T, glp_cfg *G)
+{     /* generate clique cut from conflict graph */
+      glp_prob *P = T->mip;
+      int n = P->n;
+      int len, *ind;
+      double *val;
+      ind = talloc(1+n, int);
+      val = talloc(1+n, double);
+      len = glp_clq_cut(T->mip, G, ind, val);
+      if (len > 0)
+         glp_ios_add_row(T, NULL, GLP_RF_CLQ, 0, len, ind, val, GLP_UP,
+            val[0]);
+      tfree(ind);
+      tfree(val);
+      return;
+}
+#endif
+
 static void generate_cuts(glp_tree *T)
 {     /* generate generic cuts with built-in generators */
       if (!(T->parm->mir_cuts == GLP_ON ||
             T->parm->gmi_cuts == GLP_ON ||
             T->parm->cov_cuts == GLP_ON ||
             T->parm->clq_cuts == GLP_ON)) goto done;
 #if 1 /* 20/IX-2008 */
@@ -584,31 +751,51 @@
          }
          /* xprintf("added_cuts = %d\n", added_cuts); */
          if (added_cuts >= max_cuts) goto done;
       }
 #endif
       /* generate and add to POOL all cuts violated by x* */
       if (T->parm->gmi_cuts == GLP_ON)
-      {  if (T->curr->changed < 5)
+      {  if (T->curr->changed < 7)
+#if 0 /* 08/III-2016 */
             ios_gmi_gen(T);
+#else
+            gmi_gen(T);
+#endif
       }
       if (T->parm->mir_cuts == GLP_ON)
       {  xassert(T->mir_gen != NULL);
+#if 0 /* 08/III-2016 */
          ios_mir_gen(T, T->mir_gen);
+#else
+         mir_gen(T);
+#endif
       }
       if (T->parm->cov_cuts == GLP_ON)
       {  /* cover cuts works well along with mir cuts */
-         /*if (T->round <= 5)*/
-            ios_cov_gen(T);
+#ifdef NEW_COVER /* 13/II-2018 */
+         cov_gen(T);
+#else
+         ios_cov_gen(T);
+#endif
       }
       if (T->parm->clq_cuts == GLP_ON)
       {  if (T->clq_gen != NULL)
+#if 0 /* 29/VI-2013 */
          {  if (T->curr->level == 0 && T->curr->changed < 50 ||
                 T->curr->level >  0 && T->curr->changed < 5)
+#else /* FIXME */
+         {  if (T->curr->level == 0 && T->curr->changed < 500 ||
+                T->curr->level >  0 && T->curr->changed < 50)
+#endif
+#if 0 /* 08/III-2016 */
                ios_clq_gen(T, T->clq_gen);
+#else
+               clq_gen(T, T->clq_gen);
+#endif
          }
       }
 done: return;
 }
 
 /**********************************************************************/
 
@@ -711,29 +898,49 @@
 {     int p, curr_p, p_stat, d_stat, ret;
 #if 1 /* carry out to glp_tree */
       int pred_p = 0;
       /* if the current subproblem has been just created due to
          branching, pred_p is the reference number of its parent
          subproblem, otherwise pred_p is zero */
 #endif
+#if 1 /* 18/VII-2013 */
+      int bad_cut;
+      double old_obj;
+#endif
+#if 0 /* 10/VI-2013 */
       glp_long ttt = T->tm_beg;
+#else
+      double ttt = T->tm_beg;
+#endif
+#if 1 /* 27/II-2016 by Chris */
+      int root_done = 0;
+#endif
 #if 0
       ((glp_iocp *)T->parm)->msg_lev = GLP_MSG_DBG;
 #endif
+#if 1 /* 01/III-2018 */
+      if (((glp_iocp *)T->parm)->flip)
+         if (T->parm->msg_lev >= GLP_MSG_ALL)
+            xprintf("Long-step dual simplex will be used\n");
+#endif
       /* on entry to the B&B driver it is assumed that the active list
          contains the only active (i.e. root) subproblem, which is the
          original MIP problem to be solved */
 loop: /* main loop starts here */
       /* at this point the current subproblem does not exist */
       xassert(T->curr == NULL);
       /* if the active list is empty, the search is finished */
       if (T->head == NULL)
       {  if (T->parm->msg_lev >= GLP_MSG_DBG)
             xprintf("Active list is empty!\n");
+#if 0 /* 10/VI-2013 */
          xassert(dmp_in_use(T->pool).lo == 0);
+#else
+         xassert(dmp_in_use(T->pool) == 0);
+#endif
          ret = 0;
          goto done;
       }
       /* select some active subproblem to continue the search */
       xassert(T->next_p == 0);
       /* let the application program select subproblem */
       if (T->parm->cb_func != NULL)
@@ -774,54 +981,90 @@
       /* determine the reference number of the current subproblem */
       p = T->curr->p;
       if (T->parm->msg_lev >= GLP_MSG_DBG)
       {  xprintf("-----------------------------------------------------"
             "-------------------\n");
          xprintf("Processing node %d at level %d\n", p, T->curr->level);
       }
+#if 0
+      if (p == 1)
+         glp_write_lp(T->mip, NULL, "root.lp");
+#endif
+#if 1 /* 24/X-2015 */
+      if (p == 1)
+      {  if (T->parm->sr_heur == GLP_OFF)
+         {  if (T->parm->msg_lev >= GLP_MSG_ALL)
+               xprintf("Simple rounding heuristic disabled\n");
+         }
+      }
+#endif
       /* if it is the root subproblem, initialize cut generators */
       if (p == 1)
       {  if (T->parm->gmi_cuts == GLP_ON)
          {  if (T->parm->msg_lev >= GLP_MSG_ALL)
                xprintf("Gomory's cuts enabled\n");
          }
          if (T->parm->mir_cuts == GLP_ON)
          {  if (T->parm->msg_lev >= GLP_MSG_ALL)
                xprintf("MIR cuts enabled\n");
             xassert(T->mir_gen == NULL);
+#if 0 /* 06/III-2016 */
             T->mir_gen = ios_mir_init(T);
+#else
+            T->mir_gen = glp_mir_init(T->mip);
+#endif
          }
          if (T->parm->cov_cuts == GLP_ON)
          {  if (T->parm->msg_lev >= GLP_MSG_ALL)
                xprintf("Cover cuts enabled\n");
+#ifdef NEW_COVER /* 13/II-2018 */
+            xassert(T->cov_gen == NULL);
+            T->cov_gen = glp_cov_init(T->mip);
+#endif
          }
          if (T->parm->clq_cuts == GLP_ON)
          {  xassert(T->clq_gen == NULL);
             if (T->parm->msg_lev >= GLP_MSG_ALL)
                xprintf("Clique cuts enabled\n");
+#if 0 /* 08/III-2016 */
             T->clq_gen = ios_clq_init(T);
+#else
+            T->clq_gen = glp_cfg_init(T->mip);
+#endif
          }
       }
+#if 1 /* 18/VII-2013 */
+      bad_cut = 0;
+#endif
 more: /* minor loop starts here */
       /* at this point the current subproblem needs either to be solved
          for the first time or re-optimized due to reformulation */
       /* display current progress of the search */
       if (T->parm->msg_lev >= GLP_MSG_DBG ||
           T->parm->msg_lev >= GLP_MSG_ON &&
         (double)(T->parm->out_frq - 1) <=
             1000.0 * xdifftime(xtime(), T->tm_lag))
          show_progress(T, 0);
       if (T->parm->msg_lev >= GLP_MSG_ALL &&
             xdifftime(xtime(), ttt) >= 60.0)
+#if 0 /* 16/II-2012 */
       {  glp_long total;
          glp_mem_usage(NULL, NULL, &total, NULL);
          xprintf("Time used: %.1f secs.  Memory used: %.1f Mb.\n",
             xdifftime(xtime(), T->tm_beg), xltod(total) / 1048576.0);
          ttt = xtime();
       }
+#else
+      {  size_t total;
+         glp_mem_usage(NULL, NULL, &total, NULL);
+         xprintf("Time used: %.1f secs.  Memory used: %.1f Mb.\n",
+            xdifftime(xtime(), T->tm_beg), (double)total / 1048576.0);
+         ttt = xtime();
+      }
+#endif
       /* check the mip gap */
       if (T->parm->mip_gap > 0.0 &&
           ios_relative_gap(T) <= T->parm->mip_gap)
       {  if (T->parm->msg_lev >= GLP_MSG_DBG)
             xprintf("Relative gap tolerance reached; search terminated "
                "\n");
          ret = GLP_EMIPGAP;
@@ -847,35 +1090,45 @@
             goto done;
          }
       }
       /* perform basic preprocessing */
       if (T->parm->pp_tech == GLP_PP_NONE)
          ;
       else if (T->parm->pp_tech == GLP_PP_ROOT)
+#if 0 /* 27/II-2016 by Chris */
       {  if (T->curr->level == 0)
+#else
+      {  if (!root_done)
+#endif
          {  if (ios_preprocess_node(T, 100))
                goto fath;
          }
       }
       else if (T->parm->pp_tech == GLP_PP_ALL)
+#if 0 /* 27/II-2016 by Chris */
       {  if (ios_preprocess_node(T, T->curr->level == 0 ? 100 : 10))
+#else
+      {  if (ios_preprocess_node(T, !root_done ? 100 : 10))
+#endif
             goto fath;
       }
       else
          xassert(T != T);
       /* preprocessing may improve the global bound */
       if (!is_branch_hopeful(T, p))
       {  xprintf("*** not tested yet ***\n");
          goto fath;
       }
       /* solve LP relaxation of the current subproblem */
       if (T->parm->msg_lev >= GLP_MSG_DBG)
          xprintf("Solving LP relaxation...\n");
       ret = ios_solve_node(T);
-      if (!(ret == 0 || ret == GLP_EOBJLL || ret == GLP_EOBJUL))
+      if (ret == GLP_ETMLIM)
+         goto done;
+      else if (!(ret == 0 || ret == GLP_EOBJLL || ret == GLP_EOBJUL))
       {  if (T->parm->msg_lev >= GLP_MSG_ERR)
             xprintf("ios_driver: unable to solve current LP relaxation;"
                " glp_simplex returned %d\n", ret);
          ret = GLP_EFAIL;
          goto done;
       }
       /* analyze status of the basic solution to LP relaxation found */
@@ -982,14 +1235,17 @@
       {  if (T->parm->msg_lev >= GLP_MSG_DBG)
             xprintf("New integer feasible solution found\n");
          if (T->parm->msg_lev >= GLP_MSG_ALL)
             display_cut_info(T);
          record_solution(T);
          if (T->parm->msg_lev >= GLP_MSG_ON)
             show_progress(T, 1);
+#if 1 /* 11/VII-2013 */
+         ios_process_sol(T);
+#endif
          /* make the application program happy */
          if (T->parm->cb_func != NULL)
          {  xassert(T->reason == 0);
             T->reason = GLP_IBINGO;
             T->parm->cb_func(T, T->parm->cb_info);
             T->reason = 0;
             if (T->stop)
@@ -1023,57 +1279,124 @@
          {  if (T->parm->msg_lev >= GLP_MSG_DBG)
                xprintf("Current branch became hopeless and can be prune"
                   "d\n");
             goto fath;
          }
       }
       /* try to find solution with the feasibility pump heuristic */
+#if 0 /* 27/II-2016 by Chris */
       if (T->parm->fp_heur)
+#else
+      if (T->parm->fp_heur && !root_done)
+#endif
       {  xassert(T->reason == 0);
          T->reason = GLP_IHEUR;
          ios_feas_pump(T);
          T->reason = 0;
          /* check if the current branch became hopeless */
          if (!is_branch_hopeful(T, p))
          {  if (T->parm->msg_lev >= GLP_MSG_DBG)
                xprintf("Current branch became hopeless and can be prune"
                   "d\n");
             goto fath;
          }
       }
+#if 1 /* 25/V-2013 */
+      /* try to find solution with the proximity search heuristic */
+#if 0 /* 27/II-2016 by Chris */
+      if (T->parm->ps_heur)
+#else
+      if (T->parm->ps_heur && !root_done)
+#endif
+      {  xassert(T->reason == 0);
+         T->reason = GLP_IHEUR;
+         ios_proxy_heur(T);
+         T->reason = 0;
+         /* check if the current branch became hopeless */
+         if (!is_branch_hopeful(T, p))
+         {  if (T->parm->msg_lev >= GLP_MSG_DBG)
+               xprintf("Current branch became hopeless and can be prune"
+                  "d\n");
+            goto fath;
+         }
+      }
+#endif
+#if 1 /* 24/X-2015 */
+      /* try to find solution with a simple rounding heuristic */
+      if (T->parm->sr_heur)
+      {  xassert(T->reason == 0);
+         T->reason = GLP_IHEUR;
+         round_heur(T);
+         T->reason = 0;
+         /* check if the current branch became hopeless */
+         if (!is_branch_hopeful(T, p))
+         {  if (T->parm->msg_lev >= GLP_MSG_DBG)
+               xprintf("Current branch became hopeless and can be prune"
+                  "d\n");
+            goto fath;
+         }
+      }
+#endif
       /* it's time to generate cutting planes */
       xassert(T->local != NULL);
+#ifdef NEW_LOCAL /* 02/II-2018 */
+      xassert(T->local->m == 0);
+#else
       xassert(T->local->size == 0);
+#endif
       /* let the application program generate some cuts; note that it
          can add cuts either to the local cut pool or directly to the
          current subproblem */
       if (T->parm->cb_func != NULL)
       {  xassert(T->reason == 0);
          T->reason = GLP_ICUTGEN;
          T->parm->cb_func(T, T->parm->cb_info);
          T->reason = 0;
          if (T->stop)
          {  ret = GLP_ESTOP;
             goto done;
          }
       }
+#if 1 /* 18/VII-2013 */
+      if (T->curr->changed > 0)
+      {  double degrad = fabs(T->curr->lp_obj - old_obj);
+         if (degrad < 1e-4 * (1.0 + fabs(old_obj)))
+            bad_cut++;
+         else
+            bad_cut = 0;
+      }
+      old_obj = T->curr->lp_obj;
+#if 0 /* 27/II-2016 by Chris */
+      if (bad_cut == 0 || (T->curr->level == 0 && bad_cut <= 3))
+#else
+      if (bad_cut == 0 || (!root_done && bad_cut <= 3))
+#endif
+#endif
       /* try to generate generic cuts with built-in generators
-         (as suggested by Matteo Fischetti et al. the built-in cuts
-         are not generated at each branching node; an intense attempt
-         of generating new cuts is only made at the root node, and then
+         (as suggested by Prof. Fischetti et al. the built-in cuts are
+         not generated at each branching node; an intense attempt of
+         generating new cuts is only made at the root node, and then
          a moderate effort is spent after each backtracking step) */
+#if 0 /* 27/II-2016 by Chris */
       if (T->curr->level == 0 || pred_p == 0)
+#else
+      if (!root_done || pred_p == 0)
+#endif
       {  xassert(T->reason == 0);
          T->reason = GLP_ICUTGEN;
          generate_cuts(T);
          T->reason = 0;
       }
       /* if the local cut pool is not empty, select useful cuts and add
          them to the current subproblem */
+#ifdef NEW_LOCAL /* 02/II-2018 */
+      if (T->local->m > 0)
+#else
       if (T->local->size > 0)
+#endif
       {  xassert(T->reason == 0);
          T->reason = GLP_ICUTGEN;
          ios_process_cuts(T);
          T->reason = 0;
       }
       /* clear the local cut pool */
       ios_clear_pool(T, T->local);
@@ -1081,16 +1404,24 @@
       if (T->reopt)
       {  T->reopt = 0;
          T->curr->changed++;
          goto more;
       }
       /* no cuts were generated; remove inactive cuts */
       remove_cuts(T);
+#if 0 /* 27/II-2016 by Chris */
       if (T->parm->msg_lev >= GLP_MSG_ALL && T->curr->level == 0)
+#else
+      if (T->parm->msg_lev >= GLP_MSG_ALL && !root_done)
+#endif
          display_cut_info(T);
+#if 1 /* 27/II-2016 by Chris */
+      /* the first node will not be treated as root any more */
+      if (!root_done) root_done = 1;
+#endif
       /* update history information used on pseudocost branching */
       if (T->pcost != NULL) ios_pcost_update(T);
       /* it's time to perform branching */
       xassert(T->br_var == 0);
       xassert(T->br_sel == 0);
       /* let the application program choose variable to branch on */
       if (T->parm->cb_func != NULL)
@@ -1120,14 +1451,17 @@
       }
       else if (ret == 1)
       {  /* one branch is hopeless and has been pruned, so now the
             current subproblem is other branch */
          /* the current subproblem should be considered as a new one,
             since one bound of the branching variable was changed */
          T->curr->solved = T->curr->changed = 0;
+#if 1 /* 18/VII-2013 */
+         /* bad_cut = 0; */
+#endif
          goto more;
       }
       else if (ret == 2)
       {  /* both branches are hopeless and have been pruned; new
             subproblem selection is needed to continue the search */
          goto fath;
       }
@@ -1146,15 +1480,27 @@
       /* new subproblem selection is needed due to backtracking */
       pred_p = 0;
       goto loop;
 done: /* display progress of the search on exit from the solver */
       if (T->parm->msg_lev >= GLP_MSG_ON)
          show_progress(T, 0);
       if (T->mir_gen != NULL)
+#if 0 /* 06/III-2016 */
          ios_mir_term(T->mir_gen), T->mir_gen = NULL;
+#else
+         glp_mir_free(T->mir_gen), T->mir_gen = NULL;
+#endif
+#ifdef NEW_COVER /* 13/II-2018 */
+      if (T->cov_gen != NULL)
+         glp_cov_free(T->cov_gen), T->cov_gen = NULL;
+#endif
       if (T->clq_gen != NULL)
+#if 0 /* 08/III-2016 */
          ios_clq_term(T->clq_gen), T->clq_gen = NULL;
+#else
+         glp_cfg_free(T->clq_gen), T->clq_gen = NULL;
+#endif
       /* return to the calling program */
       return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios04.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/spv.c`

 * *Files 12% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios04.c (operations on sparse vectors) */
+/* spv.c (operations on sparse vectors) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2007-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,72 +15,69 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpios.h"
+#include "env.h"
+#include "spv.h"
 
 /***********************************************************************
 *  NAME
 *
-*  ios_create_vec - create sparse vector
+*  spv_create_vec - create sparse vector
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  IOSVEC *ios_create_vec(int n);
+*  SPV *spv_create_vec(int n);
 *
 *  DESCRIPTION
 *
-*  The routine ios_create_vec creates a sparse vector of dimension n,
+*  The routine spv_create_vec creates a sparse vector of dimension n,
 *  which initially is a null vector.
 *
 *  RETURNS
 *
 *  The routine returns a pointer to the vector created. */
 
-IOSVEC *ios_create_vec(int n)
-{     IOSVEC *v;
+SPV *spv_create_vec(int n)
+{     SPV *v;
       xassert(n >= 0);
-      v = xmalloc(sizeof(IOSVEC));
+      v = xmalloc(sizeof(SPV));
       v->n = n;
       v->nnz = 0;
       v->pos = xcalloc(1+n, sizeof(int));
       memset(&v->pos[1], 0, n * sizeof(int));
       v->ind = xcalloc(1+n, sizeof(int));
       v->val = xcalloc(1+n, sizeof(double));
       return v;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_check_vec - check that sparse vector has correct representation
+*  spv_check_vec - check that sparse vector has correct representation
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  void ios_check_vec(IOSVEC *v);
+*  void spv_check_vec(SPV *v);
 *
 *  DESCRIPTION
 *
-*  The routine ios_check_vec checks that a sparse vector specified by
+*  The routine spv_check_vec checks that a sparse vector specified by
 *  the parameter v has correct representation.
 *
 *  NOTE
 *
 *  Complexity of this operation is O(n). */
 
-void ios_check_vec(IOSVEC *v)
+void spv_check_vec(SPV *v)
 {     int j, k, nnz;
       xassert(v->n >= 0);
       nnz = 0;
       for (j = v->n; j >= 1; j--)
       {  k = v->pos[j];
          xassert(0 <= k && k <= v->nnz);
          if (k != 0)
@@ -94,50 +88,50 @@
       xassert(v->nnz == nnz);
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_get_vj - retrieve component of sparse vector
+*  spv_get_vj - retrieve component of sparse vector
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  double ios_get_vj(IOSVEC *v, int j);
+*  double spv_get_vj(SPV *v, int j);
 *
 *  RETURNS
 *
-*  The routine ios_get_vj returns j-th component of a sparse vector
+*  The routine spv_get_vj returns j-th component of a sparse vector
 *  specified by the parameter v. */
 
-double ios_get_vj(IOSVEC *v, int j)
+double spv_get_vj(SPV *v, int j)
 {     int k;
       xassert(1 <= j && j <= v->n);
       k = v->pos[j];
       xassert(0 <= k && k <= v->nnz);
       return (k == 0 ? 0.0 : v->val[k]);
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_set_vj - set/change component of sparse vector
+*  spv_set_vj - set/change component of sparse vector
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  void ios_set_vj(IOSVEC *v, int j, double val);
+*  void spv_set_vj(SPV *v, int j, double val);
 *
 *  DESCRIPTION
 *
-*  The routine ios_set_vj assigns val to j-th component of a sparse
+*  The routine spv_set_vj assigns val to j-th component of a sparse
 *  vector specified by the parameter v. */
 
-void ios_set_vj(IOSVEC *v, int j, double val)
+void spv_set_vj(SPV *v, int j, double val)
 {     int k;
       xassert(1 <= j && j <= v->n);
       k = v->pos[j];
       if (val == 0.0)
       {  if (k != 0)
          {  /* remove j-th component */
             v->pos[j] = 0;
@@ -160,51 +154,51 @@
       }
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_clear_vec - set all components of sparse vector to zero
+*  spv_clear_vec - set all components of sparse vector to zero
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  void ios_clear_vec(IOSVEC *v);
+*  void spv_clear_vec(SPV *v);
 *
 *  DESCRIPTION
 *
-*  The routine ios_clear_vec sets all components of a sparse vector
+*  The routine spv_clear_vec sets all components of a sparse vector
 *  specified by the parameter v to zero. */
 
-void ios_clear_vec(IOSVEC *v)
+void spv_clear_vec(SPV *v)
 {     int k;
       for (k = 1; k <= v->nnz; k++)
          v->pos[v->ind[k]] = 0;
       v->nnz = 0;
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_clean_vec - remove zero or small components from sparse vector
+*  spv_clean_vec - remove zero or small components from sparse vector
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  void ios_clean_vec(IOSVEC *v, double eps);
+*  void spv_clean_vec(SPV *v, double eps);
 *
 *  DESCRIPTION
 *
-*  The routine ios_clean_vec removes zero components and components
+*  The routine spv_clean_vec removes zero components and components
 *  whose magnitude is less than eps from a sparse vector specified by
 *  the parameter v. If eps is 0.0, only zero components are removed. */
 
-void ios_clean_vec(IOSVEC *v, double eps)
+void spv_clean_vec(SPV *v, double eps)
 {     int k, nnz;
       nnz = 0;
       for (k = 1; k <= v->nnz; k++)
       {  if (fabs(v->val[k]) == 0.0 || fabs(v->val[k]) < eps)
          {  /* remove component */
             v->pos[v->ind[k]] = 0;
          }
@@ -219,87 +213,87 @@
       v->nnz = nnz;
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_copy_vec - copy sparse vector (x := y)
+*  spv_copy_vec - copy sparse vector (x := y)
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  void ios_copy_vec(IOSVEC *x, IOSVEC *y);
+*  void spv_copy_vec(SPV *x, SPV *y);
 *
 *  DESCRIPTION
 *
-*  The routine ios_copy_vec copies a sparse vector specified by the
+*  The routine spv_copy_vec copies a sparse vector specified by the
 *  parameter y to a sparse vector specified by the parameter x. */
 
-void ios_copy_vec(IOSVEC *x, IOSVEC *y)
+void spv_copy_vec(SPV *x, SPV *y)
 {     int j;
       xassert(x != y);
       xassert(x->n == y->n);
-      ios_clear_vec(x);
+      spv_clear_vec(x);
       x->nnz = y->nnz;
       memcpy(&x->ind[1], &y->ind[1], x->nnz * sizeof(int));
       memcpy(&x->val[1], &y->val[1], x->nnz * sizeof(double));
       for (j = 1; j <= x->nnz; j++)
          x->pos[x->ind[j]] = j;
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_linear_comb - compute linear combination (x := x + a * y)
+*  spv_linear_comb - compute linear combination (x := x + a * y)
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  void ios_linear_comb(IOSVEC *x, double a, IOSVEC *y);
+*  void spv_linear_comb(SPV *x, double a, SPV *y);
 *
 *  DESCRIPTION
 *
-*  The routine ios_linear_comb computes the linear combination
+*  The routine spv_linear_comb computes the linear combination
 *
 *     x := x + a * y,
 *
 *  where x and y are sparse vectors, a is a scalar. */
 
-void ios_linear_comb(IOSVEC *x, double a, IOSVEC *y)
+void spv_linear_comb(SPV *x, double a, SPV *y)
 {     int j, k;
       double xj, yj;
       xassert(x != y);
       xassert(x->n == y->n);
       for (k = 1; k <= y->nnz; k++)
       {  j = y->ind[k];
-         xj = ios_get_vj(x, j);
+         xj = spv_get_vj(x, j);
          yj = y->val[k];
-         ios_set_vj(x, j, xj + a * yj);
+         spv_set_vj(x, j, xj + a * yj);
       }
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_delete_vec - delete sparse vector
+*  spv_delete_vec - delete sparse vector
 *
 *  SYNOPSIS
 *
 *  #include "glpios.h"
-*  void ios_delete_vec(IOSVEC *v);
+*  void spv_delete_vec(SPV *v);
 *
 *  DESCRIPTION
 *
-*  The routine ios_delete_vec deletes a sparse vector specified by the
+*  The routine spv_delete_vec deletes a sparse vector specified by the
 *  parameter v freeing all the memory allocated to this object. */
 
-void ios_delete_vec(IOSVEC *v)
+void spv_delete_vec(SPV *v)
 {     /* delete sparse vector */
       xfree(v->pos);
       xfree(v->ind);
       xfree(v->val);
       xfree(v);
       return;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios05.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/keller.c`

 * *Files 26% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios05.c (Gomory's mixed integer cut generator) */
+/* keller.c (cover edges by cliques, Kellerman's heuristic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,268 +15,219 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpios.h"
+#include "glpk.h"
+#include "env.h"
+#include "keller.h"
 
 /***********************************************************************
 *  NAME
 *
-*  ios_gmi_gen - generate Gomory's mixed integer cuts.
+*  kellerman - cover edges by cliques with Kellerman's heuristic
 *
 *  SYNOPSIS
 *
-*  #include "glpios.h"
-*  void ios_gmi_gen(glp_tree *tree, IOSPOOL *pool);
+*  #include "keller.h"
+*  int kellerman(int n, int (*func)(void *info, int i, int ind[]),
+*     void *info, glp_graph *H);
 *
 *  DESCRIPTION
 *
-*  The routine ios_gmi_gen generates Gomory's mixed integer cuts for
-*  the current point and adds them to the cut pool. */
-
-#define MAXCUTS 50
-/* maximal number of cuts to be generated for one round */
-
-struct worka
-{     /* Gomory's cut generator working area */
-      int *ind; /* int ind[1+n]; */
-      double *val; /* double val[1+n]; */
-      double *phi; /* double phi[1+m+n]; */
+*  The routine kellerman implements Kellerman's heuristic algorithm
+*  to find a minimal set of cliques which cover all edges of specified
+*  graph G = (V, E).
+*
+*  The parameter n specifies the number of vertices |V|, n >= 0.
+*
+*  Formal routine func specifies the set of edges E in the following
+*  way. Running the routine kellerman calls the routine func and passes
+*  to it parameter i, which is the number of some vertex, 1 <= i <= n.
+*  In response the routine func should store numbers of all vertices
+*  adjacent to vertex i to locations ind[1], ind[2], ..., ind[len] and
+*  return the value of len, which is the number of adjacent vertices,
+*  0 <= len <= n. Self-loops are allowed, but ignored. Multiple edges
+*  are not allowed.
+*
+*  The parameter info is a transit pointer (magic cookie) passed to the
+*  formal routine func as its first parameter.
+*
+*  The result provided by the routine kellerman is the bipartite graph
+*  H = (V union C, F), which defines the covering found. (The program
+*  object of type glp_graph specified by the parameter H should be
+*  previously created with the routine glp_create_graph. On entry the
+*  routine kellerman erases the content of this object with the routine
+*  glp_erase_graph.) Vertices of first part V correspond to vertices of
+*  the graph G and have the same ordinal numbers 1, 2, ..., n. Vertices
+*  of second part C correspond to cliques and have ordinal numbers
+*  n+1, n+2, ..., n+k, where k is the total number of cliques in the
+*  edge covering found. Every edge f in F in the program object H is
+*  represented as arc f = (i->j), where i in V and j in C, which means
+*  that vertex i of the graph G is in clique C[j], 1 <= j <= k. (Thus,
+*  if two vertices of the graph G are in the same clique, these vertices
+*  are adjacent in G, and corresponding edge is covered by that clique.)
+*
+*  RETURNS
+*
+*  The routine Kellerman returns k, the total number of cliques in the
+*  edge covering found.
+*
+*  REFERENCE
+*
+*  For more details see: glpk/doc/notes/keller.pdf (in Russian). */
+
+struct set
+{     /* set of vertices */
+      int size;
+      /* size (cardinality) of the set, 0 <= card <= n */
+      int *list; /* int list[1+n]; */
+      /* the set contains vertices list[1,...,size] */
+      int *pos; /* int pos[1+n]; */
+      /* pos[i] > 0 means that vertex i is in the set and
+       * list[pos[i]] = i; pos[i] = 0 means that vertex i is not in
+       * the set */
 };
 
-#define f(x) ((x) - floor(x))
-/* compute fractional part of x */
-
-static void gen_cut(glp_tree *tree, struct worka *worka, int j)
-{     /* this routine tries to generate Gomory's mixed integer cut for
-         specified structural variable x[m+j] of integer kind, which is
-         basic and has fractional value in optimal solution to current
-         LP relaxation */
-      glp_prob *mip = tree->mip;
-      int m = mip->m;
-      int n = mip->n;
-      int *ind = worka->ind;
-      double *val = worka->val;
-      double *phi = worka->phi;
-      int i, k, len, kind, stat;
-      double lb, ub, alfa, beta, ksi, phi1, rhs;
-      /* compute row of the simplex tableau, which (row) corresponds
-         to specified basic variable xB[i] = x[m+j]; see (23) */
-      len = glp_eval_tab_row(mip, m+j, ind, val);
-      /* determine beta[i], which a value of xB[i] in optimal solution
-         to current LP relaxation; note that this value is the same as
-         if it would be computed with formula (27); it is assumed that
-         beta[i] is fractional enough */
-      beta = mip->col[j]->prim;
-      /* compute cut coefficients phi and right-hand side rho, which
-         correspond to formula (30); dense format is used, because rows
-         of the simplex tableau is usually dense */
-      for (k = 1; k <= m+n; k++) phi[k] = 0.0;
-      rhs = f(beta); /* initial value of rho; see (28), (32) */
-      for (j = 1; j <= len; j++)
-      {  /* determine original number of non-basic variable xN[j] */
-         k = ind[j];
-         xassert(1 <= k && k <= m+n);
-         /* determine the kind, bounds and current status of xN[j] in
-            optimal solution to LP relaxation */
-         if (k <= m)
-         {  /* auxiliary variable */
-            GLPROW *row = mip->row[k];
-            kind = GLP_CV;
-            lb = row->lb;
-            ub = row->ub;
-            stat = row->stat;
-         }
-         else
-         {  /* structural variable */
-            GLPCOL *col = mip->col[k-m];
-            kind = col->kind;
-            lb = col->lb;
-            ub = col->ub;
-            stat = col->stat;
-         }
-         /* xN[j] cannot be basic */
-         xassert(stat != GLP_BS);
-         /* determine row coefficient ksi[i,j] at xN[j]; see (23) */
-         ksi = val[j];
-         /* if ksi[i,j] is too large in the magnitude, do not generate
-            the cut */
-         if (fabs(ksi) > 1e+05) goto fini;
-         /* if ksi[i,j] is too small in the magnitude, skip it */
-         if (fabs(ksi) < 1e-10) goto skip;
-         /* compute row coefficient alfa[i,j] at y[j]; see (26) */
-         switch (stat)
-         {  case GLP_NF:
-               /* xN[j] is free (unbounded) having non-zero ksi[i,j];
-                  do not generate the cut */
-               goto fini;
-            case GLP_NL:
-               /* xN[j] has active lower bound */
-               alfa = - ksi;
-               break;
-            case GLP_NU:
-               /* xN[j] has active upper bound */
-               alfa = + ksi;
-               break;
-            case GLP_NS:
-               /* xN[j] is fixed; skip it */
-               goto skip;
-            default:
-               xassert(stat != stat);
-         }
-         /* compute cut coefficient phi'[j] at y[j]; see (21), (28) */
-         switch (kind)
-         {  case GLP_IV:
-               /* y[j] is integer */
-               if (fabs(alfa - floor(alfa + 0.5)) < 1e-10)
-               {  /* alfa[i,j] is close to nearest integer; skip it */
-                  goto skip;
+int kellerman(int n, int (*func)(void *info, int i, int ind[]),
+      void *info, void /* glp_graph */ *H_)
+{     glp_graph *H = H_;
+      struct set W_, *W = &W_, V_, *V = &V_;
+      glp_arc *a;
+      int i, j, k, m, t, len, card, best;
+      xassert(n >= 0);
+      /* H := (V, 0; 0), where V is the set of vertices of graph G */
+      glp_erase_graph(H, H->v_size, H->a_size);
+      glp_add_vertices(H, n);
+      /* W := 0 */
+      W->size = 0;
+      W->list = xcalloc(1+n, sizeof(int));
+      W->pos = xcalloc(1+n, sizeof(int));
+      memset(&W->pos[1], 0, sizeof(int) * n);
+      /* V := 0 */
+      V->size = 0;
+      V->list = xcalloc(1+n, sizeof(int));
+      V->pos = xcalloc(1+n, sizeof(int));
+      memset(&V->pos[1], 0, sizeof(int) * n);
+      /* main loop */
+      for (i = 1; i <= n; i++)
+      {  /* W must be empty */
+         xassert(W->size == 0);
+         /* W := { j : i > j and (i,j) in E } */
+         len = func(info, i, W->list);
+         xassert(0 <= len && len <= n);
+         for (t = 1; t <= len; t++)
+         {  j = W->list[t];
+            xassert(1 <= j && j <= n);
+            if (j >= i) continue;
+            xassert(W->pos[j] == 0);
+            W->list[++W->size] = j, W->pos[j] = W->size;
+         }
+         /* on i-th iteration we need to cover edges (i,j) for all
+          * j in W */
+         /* if W is empty, it is a special case */
+         if (W->size == 0)
+         {  /* set k := k + 1 and create new clique C[k] = { i } */
+            k = glp_add_vertices(H, 1) - n;
+            glp_add_arc(H, i, n + k);
+            continue;
+         }
+         /* try to include vertex i into existing cliques */
+         /* V must be empty */
+         xassert(V->size == 0);
+         /* k is the number of cliques found so far */
+         k = H->nv - n;
+         for (m = 1; m <= k; m++)
+         {  /* do while V != W; since here V is within W, we can use
+             * equivalent condition: do while |V| < |W| */
+            if (V->size == W->size) break;
+            /* check if C[m] is within W */
+            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)
+            {  j = a->tail->i;
+               if (W->pos[j] == 0) break;
+            }
+            if (a != NULL) continue;
+            /* C[m] is within W, expand clique C[m] with vertex i */
+            /* C[m] := C[m] union {i} */
+            glp_add_arc(H, i, n + m);
+            /* V is a set of vertices whose incident edges are already
+             * covered by existing cliques */
+            /* V := V union C[m] */
+            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)
+            {  j = a->tail->i;
+               if (V->pos[j] == 0)
+                  V->list[++V->size] = j, V->pos[j] = V->size;
+            }
+         }
+         /* remove from set W the vertices whose incident edges are
+          * already covered by existing cliques */
+         /* W := W \ V, V := 0 */
+         for (t = 1; t <= V->size; t++)
+         {  j = V->list[t], V->pos[j] = 0;
+            if (W->pos[j] != 0)
+            {  /* remove vertex j from W */
+               if (W->pos[j] != W->size)
+               {  int jj = W->list[W->size];
+                  W->list[W->pos[j]] = jj;
+                  W->pos[jj] = W->pos[j];
                }
-               else if (f(alfa) <= f(beta))
-                  phi1 = f(alfa);
-               else
-                  phi1 = (f(beta) / (1.0 - f(beta))) * (1.0 - f(alfa));
-               break;
-            case GLP_CV:
-               /* y[j] is continuous */
-               if (alfa >= 0.0)
-                  phi1 = + alfa;
-               else
-                  phi1 = (f(beta) / (1.0 - f(beta))) * (- alfa);
-               break;
-            default:
-               xassert(kind != kind);
-         }
-         /* compute cut coefficient phi[j] at xN[j] and update right-
-            hand side rho; see (31), (32) */
-         switch (stat)
-         {  case GLP_NL:
-               /* xN[j] has active lower bound */
-               phi[k] = + phi1;
-               rhs += phi1 * lb;
-               break;
-            case GLP_NU:
-               /* xN[j] has active upper bound */
-               phi[k] = - phi1;
-               rhs -= phi1 * ub;
-               break;
-            default:
-               xassert(stat != stat);
-         }
-skip:    ;
-      }
-      /* now the cut has the form sum_k phi[k] * x[k] >= rho, where cut
-         coefficients are stored in the array phi in dense format;
-         x[1,...,m] are auxiliary variables, x[m+1,...,m+n] are struc-
-         tural variables; see (30) */
-      /* eliminate auxiliary variables in order to express the cut only
-         through structural variables; see (33) */
-      for (i = 1; i <= m; i++)
-      {  GLPROW *row;
-         GLPAIJ *aij;
-         if (fabs(phi[i]) < 1e-10) continue;
-         /* auxiliary variable x[i] has non-zero cut coefficient */
-         row = mip->row[i];
-         /* x[i] cannot be fixed */
-         xassert(row->type != GLP_FX);
-         /* substitute x[i] = sum_j a[i,j] * x[m+j] */
-         for (aij = row->ptr; aij != NULL; aij = aij->r_next)
-            phi[m+aij->col->j] += phi[i] * aij->val;
-      }
-      /* convert the final cut to sparse format and substitute fixed
-         (structural) variables */
-      len = 0;
-      for (j = 1; j <= n; j++)
-      {  GLPCOL *col;
-         if (fabs(phi[m+j]) < 1e-10) continue;
-         /* structural variable x[m+j] has non-zero cut coefficient */
-         col = mip->col[j];
-         if (col->type == GLP_FX)
-         {  /* eliminate x[m+j] */
-            rhs -= phi[m+j] * col->lb;
+               W->size--, W->pos[j] = 0;
+            }
          }
-         else
-         {  len++;
-            ind[len] = j;
-            val[len] = phi[m+j];
+         V->size = 0;
+         /* now set W contains only vertices whose incident edges are
+          * still not covered by existing cliques; create new cliques
+          * to cover remaining edges until set W becomes empty */
+         while (W->size > 0)
+         {  /* find clique C[m], 1 <= m <= k, which shares maximal
+             * number of vertices with W; to break ties choose clique
+             * having smallest number m */
+            m = 0, best = -1;
+            k = H->nv - n;
+            for (t = 1; t <= k; t++)
+            {  /* compute cardinality of intersection of W and C[t] */
+               card = 0;
+               for (a = H->v[n + t]->in; a != NULL; a = a->h_next)
+               {  j = a->tail->i;
+                  if (W->pos[j] != 0) card++;
+               }
+               if (best < card)
+                  m = t, best = card;
+            }
+            xassert(m > 0);
+            /* set k := k + 1 and create new clique:
+             * C[k] := (W intersect C[m]) union { i }, which covers all
+             * edges incident to vertices from (W intersect C[m]) */
+            k = glp_add_vertices(H, 1) - n;
+            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)
+            {  j = a->tail->i;
+               if (W->pos[j] != 0)
+               {  /* vertex j is in both W and C[m]; include it in new
+                   * clique C[k] */
+                  glp_add_arc(H, j, n + k);
+                  /* remove vertex j from W, since edge (i,j) will be
+                   * covered by new clique C[k] */
+                  if (W->pos[j] != W->size)
+                  {  int jj = W->list[W->size];
+                     W->list[W->pos[j]] = jj;
+                     W->pos[jj] = W->pos[j];
+                  }
+                  W->size--, W->pos[j] = 0;
+               }
+            }
+            /* include vertex i to new clique C[k] to cover edges (i,j)
+             * incident to all vertices j just removed from W */
+            glp_add_arc(H, i, n + k);
          }
       }
-      if (fabs(rhs) < 1e-12) rhs = 0.0;
-      /* if the cut inequality seems to be badly scaled, reject it to
-         avoid numeric difficulties */
-      for (k = 1; k <= len; k++)
-      {  if (fabs(val[k]) < 1e-03) goto fini;
-         if (fabs(val[k]) > 1e+03) goto fini;
-      }
-      /* add the cut to the cut pool for further consideration */
-#if 0
-      ios_add_cut_row(tree, pool, GLP_RF_GMI, len, ind, val, GLP_LO,
-         rhs);
-#else
-      glp_ios_add_row(tree, NULL, GLP_RF_GMI, 0, len, ind, val, GLP_LO,
-         rhs);
-#endif
-fini: return;
-}
-
-struct var { int j; double f; };
-
-static int fcmp(const void *p1, const void *p2)
-{     const struct var *v1 = p1, *v2 = p2;
-      if (v1->f > v2->f) return -1;
-      if (v1->f < v2->f) return +1;
-      return 0;
-}
-
-void ios_gmi_gen(glp_tree *tree)
-{     /* main routine to generate Gomory's cuts */
-      glp_prob *mip = tree->mip;
-      int m = mip->m;
-      int n = mip->n;
-      struct var *var;
-      int k, nv, j, size;
-      struct worka _worka, *worka = &_worka;
-      /* allocate working arrays */
-      var = xcalloc(1+n, sizeof(struct var));
-      worka->ind = xcalloc(1+n, sizeof(int));
-      worka->val = xcalloc(1+n, sizeof(double));
-      worka->phi = xcalloc(1+m+n, sizeof(double));
-      /* build the list of integer structural variables, which are
-         basic and have fractional value in optimal solution to current
-         LP relaxation */
-      nv = 0;
-      for (j = 1; j <= n; j++)
-      {  GLPCOL *col = mip->col[j];
-         double frac;
-         if (col->kind != GLP_IV) continue;
-         if (col->type == GLP_FX) continue;
-         if (col->stat != GLP_BS) continue;
-         frac = f(col->prim);
-         if (!(0.05 <= frac && frac <= 0.95)) continue;
-         /* add variable to the list */
-         nv++, var[nv].j = j, var[nv].f = frac;
-      }
-      /* order the list by descending fractionality */
-      qsort(&var[1], nv, sizeof(struct var), fcmp);
-      /* try to generate cuts by one for each variable in the list, but
-         not more than MAXCUTS cuts */
-      size = glp_ios_pool_size(tree);
-      for (k = 1; k <= nv; k++)
-      {  if (glp_ios_pool_size(tree) - size >= MAXCUTS) break;
-         gen_cut(tree, worka, var[k].j);
-      }
       /* free working arrays */
-      xfree(var);
-      xfree(worka->ind);
-      xfree(worka->val);
-      xfree(worka->phi);
-      return;
+      xfree(W->list);
+      xfree(W->pos);
+      xfree(V->list);
+      xfree(V->pos);
+      /* return the number of cliques in the edge covering found */
+      return H->nv - n;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios06.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/mirgen.c`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios06.c (MIR cut generator) */
+/* mirgen.c (mixed integer rounding cuts generator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2007-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,28 +15,48 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#include "glpios.h"
+#if 1 /* 29/II-2016 by Chris */
+/*----------------------------------------------------------------------
+Subject: Mir cut generation performance improvement
+From: Chris Matrakidis <cmatraki@gmail.com>
+To: Andrew Makhorin <mao@gnu.org>, help-glpk <help-glpk@gnu.org>
+
+Andrew,
+
+I noticed that mir cut generation takes considerable time on some large
+problems (like rocII-4-11 from miplib). The attached patch makes two
+improvements that considerably improve performance in such instances:
+1. A lot of time was spent on generating a temporary vector in function
+aggregate_row. It is a lot faster to reuse an existing vector.
+2. A search for an element in the same function was done in row order,
+where using the elements in the order they are in the column is more
+efficient. This changes the generated cuts in some cases, but seems
+neutral overall (0.3% less cuts in a test set of 64 miplib instances).
+
+Best Regards,
+
+Chris Matrakidis
+----------------------------------------------------------------------*/
+#endif
+
+#include "env.h"
+#include "prob.h"
+#include "spv.h"
 
-#define _MIR_DEBUG 0
+#define MIR_DEBUG 0
 
 #define MAXAGGR 5
-/* maximal number of rows which can be aggregated */
+/* maximal number of rows that can be aggregated */
 
-struct MIR
+struct glp_mir
 {     /* MIR cut generator working area */
       /*--------------------------------------------------------------*/
       /* global information valid for the root subproblem */
       int m;
       /* number of rows (in the root subproblem) */
       int n;
       /* number of columns */
@@ -75,15 +92,15 @@
          by introducing auxiliary variables */
       int agg_cnt;
       /* number of rows (original constraints) used to build aggregated
          constraint, 1 <= agg_cnt <= MAXAGGR */
       int *agg_row; /* int agg_row[1+MAXAGGR]; */
       /* agg_row[k], 1 <= k <= agg_cnt, is the row number used to build
          aggregated constraint */
-      IOSVEC *agg_vec; /* IOSVEC agg_vec[1:m+n]; */
+      SPV *agg_vec; /* SPV agg_vec[1:m+n]; */
       /* sparse vector of aggregated constraint coefficients, a[k] */
       double agg_rhs;
       /* right-hand side of the aggregated constraint, b */
       /*--------------------------------------------------------------*/
       /* bound substitution flags for modified constraint */
       char *subst; /* char subst[1+m+n]; */
       /* subst[k], 1 <= k <= m+n, is a bound substitution flag used for
@@ -92,49 +109,46 @@
          'L' - x[k] = (lower bound) + x'[k]
          'U' - x[k] = (upper bound) - x'[k] */
       /*--------------------------------------------------------------*/
       /* modified constraint sum a'[k] * x'[k] = b', where x'[k] >= 0,
          derived from aggregated constraint by substituting bounds;
          note that due to substitution of variable bounds there may be
          additional terms in the modified constraint */
-      IOSVEC *mod_vec; /* IOSVEC mod_vec[1:m+n]; */
+      SPV *mod_vec; /* SPV mod_vec[1:m+n]; */
       /* sparse vector of modified constraint coefficients, a'[k] */
       double mod_rhs;
       /* right-hand side of the modified constraint, b' */
       /*--------------------------------------------------------------*/
       /* cutting plane sum alpha[k] * x[k] <= beta */
-      IOSVEC *cut_vec; /* IOSVEC cut_vec[1:m+n]; */
+      SPV *cut_vec; /* SPV cut_vec[1:m+n]; */
       /* sparse vector of cutting plane coefficients, alpha[k] */
       double cut_rhs;
       /* right-hand size of the cutting plane, beta */
 };
 
 /***********************************************************************
 *  NAME
 *
-*  ios_mir_init - initialize MIR cut generator
+*  glp_mir_init - create and initialize MIR cut generator
 *
 *  SYNOPSIS
 *
-*  #include "glpios.h"
-*  void *ios_mir_init(glp_tree *tree);
+*  glp_mir *glp_mir_init(glp_prob *P);
 *
 *  DESCRIPTION
 *
-*  The routine ios_mir_init initializes the MIR cut generator assuming
-*  that the current subproblem is the root subproblem.
+*  This routine creates and initializes the MIR cut generator for the
+*  specified problem object.
 *
 *  RETURNS
 *
-*  The routine ios_mir_init returns a pointer to the MIR cut generator
-*  working area. */
+*  The routine returns a pointer to the MIR cut generator workspace. */
 
-static void set_row_attrib(glp_tree *tree, struct MIR *mir)
+static void set_row_attrib(glp_prob *mip, glp_mir *mir)
 {     /* set global row attributes */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       int k;
       for (k = 1; k <= m; k++)
       {  GLPROW *row = mip->row[k];
          mir->skip[k] = 0;
          mir->isint[k] = 0;
          switch (row->type)
@@ -152,17 +166,16 @@
                xassert(row != row);
          }
          mir->vlb[k] = mir->vub[k] = 0;
       }
       return;
 }
 
-static void set_col_attrib(glp_tree *tree, struct MIR *mir)
+static void set_col_attrib(glp_prob *mip, glp_mir *mir)
 {     /* set global column attributes */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       int n = mir->n;
       int k;
       for (k = m+1; k <= m+n; k++)
       {  GLPCOL *col = mip->col[k-m];
          switch (col->kind)
          {  case GLP_CV:
@@ -187,17 +200,16 @@
                xassert(col != col);
          }
          mir->vlb[k] = mir->vub[k] = 0;
       }
       return;
 }
 
-static void set_var_bounds(glp_tree *tree, struct MIR *mir)
+static void set_var_bounds(glp_prob *mip, glp_mir *mir)
 {     /* set variable bounds */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       GLPAIJ *aij;
       int i, k1, k2;
       double a1, a2;
       for (i = 1; i <= m; i++)
       {  /* we need the row to be '>= 0' or '<= 0' */
          if (!(mir->lb[i] == 0.0 && mir->ub[i] == +DBL_MAX ||
@@ -250,17 +262,16 @@
                mir->skip[i] = 1;
             }
          }
       }
       return;
 }
 
-static void mark_useless_rows(glp_tree *tree, struct MIR *mir)
+static void mark_useless_rows(glp_prob *mip, glp_mir *mir)
 {     /* mark rows which should not be used */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       GLPAIJ *aij;
       int i, k, nv;
       for (i = 1; i <= m; i++)
       {  /* free rows should not be used */
          if (mir->lb[i] == -DBL_MAX && mir->ub[i] == +DBL_MAX)
          {  mir->skip[i] = 1;
@@ -290,80 +301,85 @@
          {  mir->skip[i] = 1;
             continue;
          }
       }
       return;
 }
 
-void *ios_mir_init(glp_tree *tree)
-{     /* initialize MIR cut generator */
-      glp_prob *mip = tree->mip;
+glp_mir *glp_mir_init(glp_prob *mip)
+{     /* create and initialize MIR cut generator */
       int m = mip->m;
       int n = mip->n;
-      struct MIR *mir;
-#if _MIR_DEBUG
+      glp_mir *mir;
+#if MIR_DEBUG
       xprintf("ios_mir_init: warning: debug mode enabled\n");
 #endif
       /* allocate working area */
-      mir = xmalloc(sizeof(struct MIR));
+      mir = xmalloc(sizeof(glp_mir));
       mir->m = m;
       mir->n = n;
       mir->skip = xcalloc(1+m, sizeof(char));
       mir->isint = xcalloc(1+m+n, sizeof(char));
       mir->lb = xcalloc(1+m+n, sizeof(double));
       mir->vlb = xcalloc(1+m+n, sizeof(int));
       mir->ub = xcalloc(1+m+n, sizeof(double));
       mir->vub = xcalloc(1+m+n, sizeof(int));
       mir->x = xcalloc(1+m+n, sizeof(double));
       mir->agg_row = xcalloc(1+MAXAGGR, sizeof(int));
-      mir->agg_vec = ios_create_vec(m+n);
+      mir->agg_vec = spv_create_vec(m+n);
       mir->subst = xcalloc(1+m+n, sizeof(char));
-      mir->mod_vec = ios_create_vec(m+n);
-      mir->cut_vec = ios_create_vec(m+n);
+      mir->mod_vec = spv_create_vec(m+n);
+      mir->cut_vec = spv_create_vec(m+n);
       /* set global row attributes */
-      set_row_attrib(tree, mir);
+      set_row_attrib(mip, mir);
       /* set global column attributes */
-      set_col_attrib(tree, mir);
+      set_col_attrib(mip, mir);
       /* set variable bounds */
-      set_var_bounds(tree, mir);
+      set_var_bounds(mip, mir);
       /* mark rows which should not be used */
-      mark_useless_rows(tree, mir);
+      mark_useless_rows(mip, mir);
       return mir;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_mir_gen - generate MIR cuts
+*  glp_mir_gen - generate mixed integer rounding (MIR) cuts
 *
 *  SYNOPSIS
 *
-*  #include "glpios.h"
-*  void ios_mir_gen(glp_tree *tree, void *gen, IOSPOOL *pool);
+*  int glp_mir_gen(glp_prob *P, glp_mir *mir, glp_prob *pool);
 *
 *  DESCRIPTION
 *
-*  The routine ios_mir_gen generates MIR cuts for the current point and
-*  adds them to the cut pool. */
+*  This routine attempts to generate mixed integer rounding (MIR) cuts
+*  for current basic solution to the specified problem object.
+*
+*  The cutting plane inequalities generated by the routine are added to
+*  the specified cut pool.
+*
+*  RETURNS
+*
+*  The routine returns the number of cuts that have been generated and
+*  added to the cut pool. */
 
-static void get_current_point(glp_tree *tree, struct MIR *mir)
+static void get_current_point(glp_prob *mip, glp_mir *mir)
 {     /* obtain current point */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       int n = mir->n;
       int k;
       for (k = 1; k <= m; k++)
          mir->x[k] = mip->row[k]->prim;
       for (k = m+1; k <= m+n; k++)
          mir->x[k] = mip->col[k-m]->prim;
       return;
 }
 
-#if _MIR_DEBUG
-static void check_current_point(struct MIR *mir)
+#if MIR_DEBUG
+static void check_current_point(glp_mir *mir)
 {     /* check current point */
       int m = mir->m;
       int n = mir->n;
       int k, kk;
       double lb, ub, eps;
       for (k = 1; k <= m+n; k++)
       {  /* determine lower bound */
@@ -395,41 +411,40 @@
             xassert(mir->x[k] <= ub + eps);
          }
       }
       return;
 }
 #endif
 
-static void initial_agg_row(glp_tree *tree, struct MIR *mir, int i)
+static void initial_agg_row(glp_prob *mip, glp_mir *mir, int i)
 {     /* use original i-th row as initial aggregated constraint */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       GLPAIJ *aij;
       xassert(1 <= i && i <= m);
       xassert(!mir->skip[i]);
       /* mark i-th row in order not to use it in the same aggregated
          constraint */
       mir->skip[i] = 2;
       mir->agg_cnt = 1;
       mir->agg_row[1] = i;
       /* use x[i] - sum a[i,j] * x[m+j] = 0, where x[i] is auxiliary
          variable of row i, x[m+j] are structural variables */
-      ios_clear_vec(mir->agg_vec);
-      ios_set_vj(mir->agg_vec, i, 1.0);
+      spv_clear_vec(mir->agg_vec);
+      spv_set_vj(mir->agg_vec, i, 1.0);
       for (aij = mip->row[i]->ptr; aij != NULL; aij = aij->r_next)
-         ios_set_vj(mir->agg_vec, m + aij->col->j, - aij->val);
+         spv_set_vj(mir->agg_vec, m + aij->col->j, - aij->val);
       mir->agg_rhs = 0.0;
-#if _MIR_DEBUG
-      ios_check_vec(mir->agg_vec);
+#if MIR_DEBUG
+      spv_check_vec(mir->agg_vec);
 #endif
       return;
 }
 
-#if _MIR_DEBUG
-static void check_agg_row(struct MIR *mir)
+#if MIR_DEBUG
+static void check_agg_row(glp_mir *mir)
 {     /* check aggregated constraint */
       int m = mir->m;
       int n = mir->n;
       int j, k;
       double r, big;
       /* compute the residual r = sum a[k] * x[k] - b and determine
          big = max(1, |a[k]|, |b|) */
@@ -446,15 +461,15 @@
          big = fabs(mir->agg_rhs);
       /* the residual must be close to zero */
       xassert(fabs(r) <= 1e-6 * big);
       return;
 }
 #endif
 
-static void subst_fixed_vars(struct MIR *mir)
+static void subst_fixed_vars(glp_mir *mir)
 {     /* substitute fixed variables into aggregated constraint */
       int m = mir->m;
       int n = mir->n;
       int j, k;
       for (j = 1; j <= mir->agg_vec->nnz; j++)
       {  k = mir->agg_vec->ind[j];
          xassert(1 <= k && k <= m+n);
@@ -462,22 +477,22 @@
              mir->lb[k] == mir->ub[k])
          {  /* x[k] is fixed */
             mir->agg_rhs -= mir->agg_vec->val[j] * mir->lb[k];
             mir->agg_vec->val[j] = 0.0;
          }
       }
       /* remove terms corresponding to fixed variables */
-      ios_clean_vec(mir->agg_vec, DBL_EPSILON);
-#if _MIR_DEBUG
-      ios_check_vec(mir->agg_vec);
+      spv_clean_vec(mir->agg_vec, DBL_EPSILON);
+#if MIR_DEBUG
+      spv_check_vec(mir->agg_vec);
 #endif
       return;
 }
 
-static void bound_subst_heur(struct MIR *mir)
+static void bound_subst_heur(glp_mir *mir)
 {     /* bound substitution heuristic */
       int m = mir->m;
       int n = mir->n;
       int j, k, kk;
       double d1, d2;
       for (j = 1; j <= mir->agg_vec->nnz; j++)
       {  k = mir->agg_vec->ind[j];
@@ -519,24 +534,24 @@
             mir->subst[k] = 'L';
          else
             mir->subst[k] = 'U';
       }
       return;
 }
 
-static void build_mod_row(struct MIR *mir)
+static void build_mod_row(glp_mir *mir)
 {     /* substitute bounds and build modified constraint */
       int m = mir->m;
       int n = mir->n;
       int j, jj, k, kk;
       /* initially modified constraint is aggregated constraint */
-      ios_copy_vec(mir->mod_vec, mir->agg_vec);
+      spv_copy_vec(mir->mod_vec, mir->agg_vec);
       mir->mod_rhs = mir->agg_rhs;
-#if _MIR_DEBUG
-      ios_check_vec(mir->mod_vec);
+#if MIR_DEBUG
+      spv_check_vec(mir->mod_vec);
 #endif
       /* substitute bounds for continuous variables; note that due to
          substitution of variable bounds additional terms may appear in
          modified constraint */
       for (j = mir->mod_vec->nnz; j >= 1; j--)
       {  k = mir->mod_vec->ind[j];
          xassert(1 <= k && k <= m+n);
@@ -550,15 +565,15 @@
                mir->mod_rhs -= mir->mod_vec->val[j] * mir->lb[k];
             }
             else
             {  /* x[k] = lb[k] * x[kk] + x'[k] */
                xassert(mir->isint[kk]);
                jj = mir->mod_vec->pos[kk];
                if (jj == 0)
-               {  ios_set_vj(mir->mod_vec, kk, 1.0);
+               {  spv_set_vj(mir->mod_vec, kk, 1.0);
                   jj = mir->mod_vec->pos[kk];
                   mir->mod_vec->val[jj] = 0.0;
                }
                mir->mod_vec->val[jj] +=
                   mir->mod_vec->val[j] * mir->lb[k];
             }
          }
@@ -571,28 +586,28 @@
                mir->mod_rhs -= mir->mod_vec->val[j] * mir->ub[k];
             }
             else
             {  /* x[k] = ub[k] * x[kk] - x'[k] */
                xassert(mir->isint[kk]);
                jj = mir->mod_vec->pos[kk];
                if (jj == 0)
-               {  ios_set_vj(mir->mod_vec, kk, 1.0);
+               {  spv_set_vj(mir->mod_vec, kk, 1.0);
                   jj = mir->mod_vec->pos[kk];
                   mir->mod_vec->val[jj] = 0.0;
                }
                mir->mod_vec->val[jj] +=
                   mir->mod_vec->val[j] * mir->ub[k];
             }
             mir->mod_vec->val[j] = - mir->mod_vec->val[j];
          }
          else
             xassert(k != k);
       }
-#if _MIR_DEBUG
-      ios_check_vec(mir->mod_vec);
+#if MIR_DEBUG
+      spv_check_vec(mir->mod_vec);
 #endif
       /* substitute bounds for integer variables */
       for (j = 1; j <= mir->mod_vec->nnz; j++)
       {  k = mir->mod_vec->ind[j];
          xassert(1 <= k && k <= m+n);
          if (!mir->isint[k]) continue; /* skip continuous variable */
          xassert(mir->subst[k] == '?');
@@ -606,22 +621,22 @@
          else
          {  /* x[k] = ub[k] - x'[k] */
             mir->subst[k] = 'U';
             mir->mod_rhs -= mir->mod_vec->val[j] * mir->ub[k];
             mir->mod_vec->val[j] = - mir->mod_vec->val[j];
          }
       }
-#if _MIR_DEBUG
-      ios_check_vec(mir->mod_vec);
+#if MIR_DEBUG
+      spv_check_vec(mir->mod_vec);
 #endif
       return;
 }
 
-#if _MIR_DEBUG
-static void check_mod_row(struct MIR *mir)
+#if MIR_DEBUG
+static void check_mod_row(glp_mir *mir)
 {     /* check modified constraint */
       int m = mir->m;
       int n = mir->n;
       int j, k, kk;
       double r, big, x;
       /* compute the residual r = sum a'[k] * x'[k] - b' and determine
          big = max(1, |a[k]|, |b|) */
@@ -777,15 +792,15 @@
 *     sum   alpha[j] * x [j] - beta - gamma * s ,
 *    j in N
 *
 *  which is positive. In case of failure the routine returns zero. */
 
 struct vset { int j; double v; };
 
-static int cmir_cmp(const void *p1, const void *p2)
+static int CDECL cmir_cmp(const void *p1, const void *p2)
 {     const struct vset *v1 = p1, *v2 = p2;
       if (v1->v < v2->v) return -1;
       if (v1->v > v2->v) return +1;
       return 0;
 }
 
 static double cmir_sep(const int n, const double a[], const double b,
@@ -871,38 +886,38 @@
 done: /* free working arrays */
       xfree(cset);
       xfree(vset);
       /* return to the calling routine */
       return r_best;
 }
 
-static double generate(struct MIR *mir)
+static double generate(glp_mir *mir)
 {     /* try to generate violated c-MIR cut for modified constraint */
       int m = mir->m;
       int n = mir->n;
       int j, k, kk, nint;
       double s, *u, *x, *alpha, r_best = 0.0, b, beta, gamma;
-      ios_copy_vec(mir->cut_vec, mir->mod_vec);
+      spv_copy_vec(mir->cut_vec, mir->mod_vec);
       mir->cut_rhs = mir->mod_rhs;
       /* remove small terms, which can appear due to substitution of
          variable bounds */
-      ios_clean_vec(mir->cut_vec, DBL_EPSILON);
-#if _MIR_DEBUG
-      ios_check_vec(mir->cut_vec);
+      spv_clean_vec(mir->cut_vec, DBL_EPSILON);
+#if MIR_DEBUG
+      spv_check_vec(mir->cut_vec);
 #endif
       /* remove positive continuous terms to obtain MK relaxation */
       for (j = 1; j <= mir->cut_vec->nnz; j++)
       {  k = mir->cut_vec->ind[j];
          xassert(1 <= k && k <= m+n);
          if (!mir->isint[k] && mir->cut_vec->val[j] > 0.0)
             mir->cut_vec->val[j] = 0.0;
       }
-      ios_clean_vec(mir->cut_vec, 0.0);
-#if _MIR_DEBUG
-      ios_check_vec(mir->cut_vec);
+      spv_clean_vec(mir->cut_vec, 0.0);
+#if MIR_DEBUG
+      spv_check_vec(mir->cut_vec);
 #endif
       /* move integer terms to the beginning of the sparse vector and
          determine the number of integer variables */
       nint = 0;
       for (j = 1; j <= mir->cut_vec->nnz; j++)
       {  k = mir->cut_vec->ind[j];
          xassert(1 <= k && k <= m+n);
@@ -916,16 +931,16 @@
             mir->cut_vec->ind[nint] = k;
             mir->cut_vec->ind[j] = kk;
             temp = mir->cut_vec->val[nint];
             mir->cut_vec->val[nint] = mir->cut_vec->val[j];
             mir->cut_vec->val[j] = temp;
          }
       }
-#if _MIR_DEBUG
-      ios_check_vec(mir->cut_vec);
+#if MIR_DEBUG
+      spv_check_vec(mir->cut_vec);
 #endif
       /* if there is no integer variable, nothing to generate */
       if (nint == 0) goto done;
       /* allocate working arrays */
       u = xcalloc(1+nint, sizeof(double));
       x = xcalloc(1+nint, sizeof(double));
       alpha = xcalloc(1+nint, sizeof(double));
@@ -938,15 +953,23 @@
          xassert(u[j] >= 1.0);
          if (mir->subst[k] == 'L')
             x[j] = mir->x[k] - mir->lb[k];
          else if (mir->subst[k] == 'U')
             x[j] = mir->ub[k] - mir->x[k];
          else
             xassert(k != k);
+#if 0 /* 06/III-2016; notorious bug reported many times */
          xassert(x[j] >= -0.001);
+#else
+         if (x[j] < -0.001)
+         {  xprintf("glp_mir_gen: warning: x[%d] = %g\n", j, x[j]);
+            r_best = 0.0;
+            goto skip;
+         }
+#endif
          if (x[j] < 0.0) x[j] = 0.0;
       }
       /* compute s = - sum of continuous terms */
       s = 0.0;
       for (j = nint+1; j <= mir->cut_vec->nnz; j++)
       {  double x;
          k = mir->cut_vec->ind[j];
@@ -967,15 +990,23 @@
             if (kk == 0)
                x = mir->ub[k] - mir->x[k];
             else
                x = mir->ub[k] * mir->x[kk] - mir->x[k];
          }
          else
             xassert(k != k);
+#if 0 /* 06/III-2016; notorious bug reported many times */
          xassert(x >= -0.001);
+#else
+         if (x < -0.001)
+         {  xprintf("glp_mir_gen: warning: x = %g\n", x);
+            r_best = 0.0;
+            goto skip;
+         }
+#endif
          if (x < 0.0) x = 0.0;
          s -= mir->cut_vec->val[j] * x;
       }
       xassert(s >= 0.0);
       /* apply heuristic to obtain most violated c-MIR inequality */
       b = mir->cut_rhs;
       r_best = cmir_sep(nint, mir->cut_vec->val, b, u, x, s, alpha,
@@ -987,26 +1018,26 @@
       for (j = 1; j <= nint; j++)
          mir->cut_vec->val[j] = alpha[j];
       for (j = nint+1; j <= mir->cut_vec->nnz; j++)
       {  k = mir->cut_vec->ind[j];
          if (k <= m+n) mir->cut_vec->val[j] *= gamma;
       }
       mir->cut_rhs = beta;
-#if _MIR_DEBUG
-      ios_check_vec(mir->cut_vec);
+#if MIR_DEBUG
+      spv_check_vec(mir->cut_vec);
 #endif
 skip: /* free working arrays */
       xfree(u);
       xfree(x);
       xfree(alpha);
 done: return r_best;
 }
 
-#if _MIR_DEBUG
-static void check_raw_cut(struct MIR *mir, double r_best)
+#if MIR_DEBUG
+static void check_raw_cut(glp_mir *mir, double r_best)
 {     /* check raw cut before back bound substitution */
       int m = mir->m;
       int n = mir->n;
       int j, k, kk;
       double r, big, x;
       /* compute the residual r = sum a[k] * x[k] - b and determine
          big = max(1, |a[k]|, |b|) */
@@ -1041,15 +1072,15 @@
          big = fabs(mir->cut_rhs);
       /* the residual must be close to r_best */
       xassert(fabs(r - r_best) <= 1e-6 * big);
       return;
 }
 #endif
 
-static void back_subst(struct MIR *mir)
+static void back_subst(glp_mir *mir)
 {     /* back substitution of original bounds */
       int m = mir->m;
       int n = mir->n;
       int j, jj, k, kk;
       /* at first, restore bounds of integer variables (because on
          restoring variable bounds of continuous variables we need
          original, not shifted, bounds of integer variables) */
@@ -1089,15 +1120,15 @@
             else
             {  /* x'[k] = x[k] - lb[k] * x[kk] */
                jj = mir->cut_vec->pos[kk];
 #if 0
                xassert(jj != 0);
 #else
                if (jj == 0)
-               {  ios_set_vj(mir->cut_vec, kk, 1.0);
+               {  spv_set_vj(mir->cut_vec, kk, 1.0);
                   jj = mir->cut_vec->pos[kk];
                   xassert(jj != 0);
                   mir->cut_vec->val[jj] = 0.0;
                }
 #endif
                mir->cut_vec->val[jj] -= mir->cut_vec->val[j] *
                   mir->lb[k];
@@ -1111,35 +1142,35 @@
             {  /* x'[k] = ub[k] - x[k] */
                mir->cut_rhs -= mir->cut_vec->val[j] * mir->ub[k];
             }
             else
             {  /* x'[k] = ub[k] * x[kk] - x[k] */
                jj = mir->cut_vec->pos[kk];
                if (jj == 0)
-               {  ios_set_vj(mir->cut_vec, kk, 1.0);
+               {  spv_set_vj(mir->cut_vec, kk, 1.0);
                   jj = mir->cut_vec->pos[kk];
                   xassert(jj != 0);
                   mir->cut_vec->val[jj] = 0.0;
                }
                mir->cut_vec->val[jj] += mir->cut_vec->val[j] *
                   mir->ub[k];
             }
             mir->cut_vec->val[j] = - mir->cut_vec->val[j];
          }
          else
             xassert(k != k);
       }
-#if _MIR_DEBUG
-      ios_check_vec(mir->cut_vec);
+#if MIR_DEBUG
+      spv_check_vec(mir->cut_vec);
 #endif
       return;
 }
 
-#if _MIR_DEBUG
-static void check_cut_row(struct MIR *mir, double r_best)
+#if MIR_DEBUG
+static void check_cut_row(glp_mir *mir, double r_best)
 {     /* check the cut after back bound substitution or elimination of
          auxiliary variables */
       int m = mir->m;
       int n = mir->n;
       int j, k;
       double r, big;
       /* compute the residual r = sum a[k] * x[k] - b and determine
@@ -1157,73 +1188,85 @@
          big = fabs(mir->cut_rhs);
       /* the residual must be close to r_best */
       xassert(fabs(r - r_best) <= 1e-6 * big);
       return;
 }
 #endif
 
-static void subst_aux_vars(glp_tree *tree, struct MIR *mir)
+static void subst_aux_vars(glp_prob *mip, glp_mir *mir)
 {     /* final substitution to eliminate auxiliary variables */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       int n = mir->n;
       GLPAIJ *aij;
       int j, k, kk, jj;
       for (j = mir->cut_vec->nnz; j >= 1; j--)
       {  k = mir->cut_vec->ind[j];
          xassert(1 <= k && k <= m+n);
          if (k > m) continue; /* skip structurals */
          for (aij = mip->row[k]->ptr; aij != NULL; aij = aij->r_next)
          {  kk = m + aij->col->j; /* structural */
             jj = mir->cut_vec->pos[kk];
             if (jj == 0)
-            {  ios_set_vj(mir->cut_vec, kk, 1.0);
+            {  spv_set_vj(mir->cut_vec, kk, 1.0);
                jj = mir->cut_vec->pos[kk];
                mir->cut_vec->val[jj] = 0.0;
             }
             mir->cut_vec->val[jj] += mir->cut_vec->val[j] * aij->val;
          }
          mir->cut_vec->val[j] = 0.0;
       }
-      ios_clean_vec(mir->cut_vec, 0.0);
+      spv_clean_vec(mir->cut_vec, 0.0);
       return;
 }
 
-static void add_cut(glp_tree *tree, struct MIR *mir)
+static void add_cut(glp_mir *mir, glp_prob *pool)
 {     /* add constructed cut inequality to the cut pool */
       int m = mir->m;
       int n = mir->n;
       int j, k, len;
       int *ind = xcalloc(1+n, sizeof(int));
       double *val = xcalloc(1+n, sizeof(double));
       len = 0;
       for (j = mir->cut_vec->nnz; j >= 1; j--)
       {  k = mir->cut_vec->ind[j];
          xassert(m+1 <= k && k <= m+n);
          len++, ind[len] = k - m, val[len] = mir->cut_vec->val[j];
       }
 #if 0
+#if 0
       ios_add_cut_row(tree, pool, GLP_RF_MIR, len, ind, val, GLP_UP,
          mir->cut_rhs);
 #else
       glp_ios_add_row(tree, NULL, GLP_RF_MIR, 0, len, ind, val, GLP_UP,
          mir->cut_rhs);
 #endif
+#else
+      {  int i;
+         i = glp_add_rows(pool, 1);
+         glp_set_row_bnds(pool, i, GLP_UP, 0, mir->cut_rhs);
+         glp_set_mat_row(pool, i, len, ind, val);
+      }
+#endif
       xfree(ind);
       xfree(val);
       return;
 }
 
-static int aggregate_row(glp_tree *tree, struct MIR *mir)
+#if 0 /* 29/II-2016 by Chris */
+static int aggregate_row(glp_prob *mip, glp_mir *mir)
+#else
+static int aggregate_row(glp_prob *mip, glp_mir *mir, SPV *v)
+#endif
 {     /* try to aggregate another row */
-      glp_prob *mip = tree->mip;
       int m = mir->m;
       int n = mir->n;
       GLPAIJ *aij;
-      IOSVEC *v;
+#if 0 /* 29/II-2016 by Chris */
+      SPV *v;
+#endif
       int ii, j, jj, k, kk, kappa = 0, ret = 0;
       double d1, d2, d, d_max = 0.0;
       /* choose appropriate structural variable in the aggregated row
          to be substituted */
       for (j = 1; j <= mir->agg_vec->nnz; j++)
       {  k = mir->agg_vec->ind[j];
          xassert(1 <= k && k <= m+n);
@@ -1273,181 +1316,212 @@
          goto done;
       }
       /* x[kappa] has been chosen */
       xassert(m+1 <= kappa && kappa <= m+n);
       xassert(!mir->isint[kappa]);
       /* find another row, which have not been used yet, to eliminate
          x[kappa] from the aggregated row */
+#if 0 /* 29/II-2016 by Chris */
       for (ii = 1; ii <= m; ii++)
       {  if (mir->skip[ii]) continue;
          for (aij = mip->row[ii]->ptr; aij != NULL; aij = aij->r_next)
             if (aij->col->j == kappa - m) break;
          if (aij != NULL && fabs(aij->val) >= 0.001) break;
+#else
+      ii = 0;
+      for (aij = mip->col[kappa - m]->ptr; aij != NULL;
+         aij = aij->c_next)
+      {  if (aij->row->i > m) continue;
+         if (mir->skip[aij->row->i]) continue;
+         if (fabs(aij->val) >= 0.001)
+         {  ii = aij->row->i;
+            break;
+         }
+#endif
       }
+#if 0 /* 29/II-2016 by Chris */
       if (ii > m)
+#else
+      if (ii == 0)
+#endif
       {  /* nothing found */
          ret = 2;
          goto done;
       }
       /* row ii has been found; include it in the aggregated list */
       mir->agg_cnt++;
       xassert(mir->agg_cnt <= MAXAGGR);
       mir->agg_row[mir->agg_cnt] = ii;
       mir->skip[ii] = 2;
       /* v := new row */
+#if 0 /* 29/II-2016 by Chris */
       v = ios_create_vec(m+n);
-      ios_set_vj(v, ii, 1.0);
+#else
+      spv_clear_vec(v);
+#endif
+      spv_set_vj(v, ii, 1.0);
       for (aij = mip->row[ii]->ptr; aij != NULL; aij = aij->r_next)
-         ios_set_vj(v, m + aij->col->j, - aij->val);
-#if _MIR_DEBUG
-      ios_check_vec(v);
+         spv_set_vj(v, m + aij->col->j, - aij->val);
+#if MIR_DEBUG
+      spv_check_vec(v);
 #endif
       /* perform gaussian elimination to remove x[kappa] */
       j = mir->agg_vec->pos[kappa];
       xassert(j != 0);
       jj = v->pos[kappa];
       xassert(jj != 0);
-      ios_linear_comb(mir->agg_vec,
+      spv_linear_comb(mir->agg_vec,
          - mir->agg_vec->val[j] / v->val[jj], v);
+#if 0 /* 29/II-2016 by Chris */
       ios_delete_vec(v);
-      ios_set_vj(mir->agg_vec, kappa, 0.0);
-#if _MIR_DEBUG
-      ios_check_vec(mir->agg_vec);
+#endif
+      spv_set_vj(mir->agg_vec, kappa, 0.0);
+#if MIR_DEBUG
+      spv_check_vec(mir->agg_vec);
 #endif
 done: return ret;
 }
 
-void ios_mir_gen(glp_tree *tree, void *gen)
+int glp_mir_gen(glp_prob *mip, glp_mir *mir, glp_prob *pool)
 {     /* main routine to generate MIR cuts */
-      glp_prob *mip = tree->mip;
-      struct MIR *mir = gen;
       int m = mir->m;
       int n = mir->n;
-      int i;
+      int i, nnn = 0;
       double r_best;
+#if 1 /* 29/II-2016 by Chris */
+      SPV *work;
+#endif
       xassert(mip->m >= m);
       xassert(mip->n == n);
       /* obtain current point */
-      get_current_point(tree, mir);
-#if _MIR_DEBUG
+      get_current_point(mip, mir);
+#if MIR_DEBUG
       /* check current point */
       check_current_point(mir);
 #endif
       /* reset bound substitution flags */
       memset(&mir->subst[1], '?', m+n);
+#if 1 /* 29/II-2016 by Chris */
+      work = spv_create_vec(m+n);
+#endif
       /* try to generate a set of violated MIR cuts */
       for (i = 1; i <= m; i++)
       {  if (mir->skip[i]) continue;
          /* use original i-th row as initial aggregated constraint */
-         initial_agg_row(tree, mir, i);
+         initial_agg_row(mip, mir, i);
 loop:    ;
-#if _MIR_DEBUG
+#if MIR_DEBUG
          /* check aggregated row */
          check_agg_row(mir);
 #endif
          /* substitute fixed variables into aggregated constraint */
          subst_fixed_vars(mir);
-#if _MIR_DEBUG
+#if MIR_DEBUG
          /* check aggregated row */
          check_agg_row(mir);
 #endif
-#if _MIR_DEBUG
+#if MIR_DEBUG
          /* check bound substitution flags */
          {  int k;
             for (k = 1; k <= m+n; k++)
                xassert(mir->subst[k] == '?');
          }
 #endif
          /* apply bound substitution heuristic */
          bound_subst_heur(mir);
          /* substitute bounds and build modified constraint */
          build_mod_row(mir);
-#if _MIR_DEBUG
+#if MIR_DEBUG
          /* check modified row */
          check_mod_row(mir);
 #endif
          /* try to generate violated c-MIR cut for modified row */
          r_best = generate(mir);
          if (r_best > 0.0)
          {  /* success */
-#if _MIR_DEBUG
+#if MIR_DEBUG
             /* check raw cut before back bound substitution */
             check_raw_cut(mir, r_best);
 #endif
             /* back substitution of original bounds */
             back_subst(mir);
-#if _MIR_DEBUG
+#if MIR_DEBUG
             /* check the cut after back bound substitution */
             check_cut_row(mir, r_best);
 #endif
             /* final substitution to eliminate auxiliary variables */
-            subst_aux_vars(tree, mir);
-#if _MIR_DEBUG
+            subst_aux_vars(mip, mir);
+#if MIR_DEBUG
             /* check the cut after elimination of auxiliaries */
             check_cut_row(mir, r_best);
 #endif
             /* add constructed cut inequality to the cut pool */
-            add_cut(tree, mir);
+            add_cut(mir, pool), nnn++;
          }
          /* reset bound substitution flags */
          {  int j, k;
             for (j = 1; j <= mir->mod_vec->nnz; j++)
             {  k = mir->mod_vec->ind[j];
                xassert(1 <= k && k <= m+n);
                xassert(mir->subst[k] != '?');
                mir->subst[k] = '?';
             }
          }
          if (r_best == 0.0)
          {  /* failure */
             if (mir->agg_cnt < MAXAGGR)
             {  /* try to aggregate another row */
-               if (aggregate_row(tree, mir) == 0) goto loop;
+#if 0 /* 29/II-2016 by Chris */
+               if (aggregate_row(mip, mir) == 0) goto loop;
+#else
+               if (aggregate_row(mip, mir, work) == 0) goto loop;
+#endif
             }
          }
          /* unmark rows used in the aggregated constraint */
          {  int k, ii;
             for (k = 1; k <= mir->agg_cnt; k++)
             {  ii = mir->agg_row[k];
                xassert(1 <= ii && ii <= m);
                xassert(mir->skip[ii] == 2);
                mir->skip[ii] = 0;
             }
          }
       }
-      return;
+#if 1 /* 29/II-2016 by Chris */
+      spv_delete_vec(work);
+#endif
+      return nnn;
 }
 
 /***********************************************************************
 *  NAME
 *
-*  ios_mir_term - terminate MIR cut generator
+*  glp_mir_free - delete MIR cut generator workspace
 *
 *  SYNOPSIS
 *
-*  #include "glpios.h"
-*  void ios_mir_term(void *gen);
+*  void glp_mir_free(glp_mir *mir);
 *
 *  DESCRIPTION
 *
-*  The routine ios_mir_term deletes the MIR cut generator working area
-*  freeing all the memory allocated to it. */
+*  This routine deletes the MIR cut generator workspace and frees all
+*  the memory allocated to it. */
 
-void ios_mir_term(void *gen)
-{     struct MIR *mir = gen;
-      xfree(mir->skip);
+void glp_mir_free(glp_mir *mir)
+{     xfree(mir->skip);
       xfree(mir->isint);
       xfree(mir->lb);
       xfree(mir->vlb);
       xfree(mir->ub);
       xfree(mir->vub);
       xfree(mir->x);
       xfree(mir->agg_row);
-      ios_delete_vec(mir->agg_vec);
+      spv_delete_vec(mir->agg_vec);
       xfree(mir->subst);
-      ios_delete_vec(mir->mod_vec);
-      ios_delete_vec(mir->cut_vec);
+      spv_delete_vec(mir->mod_vec);
+      spv_delete_vec(mir->cut_vec);
       xfree(mir);
       return;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios07.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios07.c`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpios07.c (mixed cover cut generator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2005-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpios.h"
+#include "env.h"
+#include "ios.h"
 
 /*----------------------------------------------------------------------
 -- COVER INEQUALITIES
 --
 -- Consider the set of feasible solutions to 0-1 knapsack problem:
 --
 --    sum a[j]*x[j] <= b,                                            (1)
@@ -278,15 +276,14 @@
 }
 
 /*----------------------------------------------------------------------
 -- lpx_cover_cut - generate mixed cover cut.
 --
 -- SYNOPSIS
 --
--- #include "glplpx.h"
 -- int lpx_cover_cut(LPX *lp, int len, int ind[], double val[],
 --    double work[]);
 --
 -- DESCRIPTION
 --
 -- The routine lpx_cover_cut generates a mixed cover cut for a given
 -- row of the MIP problem.
@@ -311,41 +308,38 @@
 --
 -- RETURNS
 --
 -- If the cutting plane has been successfully generated, the routine
 -- returns 1 <= len' <= n, which is the number of non-zero coefficients
 -- in the inequality constraint. Otherwise, the routine returns zero. */
 
-static int lpx_cover_cut(LPX *lp, int len, int ind[], double val[],
-      double work[])
+static int lpx_cover_cut(glp_prob *lp, int len, int ind[],
+      double val[], double work[])
 {     int cov[1+4], j, k, nb, newlen, r;
       double f_min, f_max, alfa, beta, u, *x = work, y;
       /* substitute and remove fixed variables */
       newlen = 0;
       for (k = 1; k <= len; k++)
       {  j = ind[k];
-         if (lpx_get_col_type(lp, j) == LPX_FX)
-            val[0] -= val[k] * lpx_get_col_lb(lp, j);
+         if (glp_get_col_type(lp, j) == GLP_FX)
+            val[0] -= val[k] * glp_get_col_lb(lp, j);
          else
          {  newlen++;
             ind[newlen] = ind[k];
             val[newlen] = val[k];
          }
       }
       len = newlen;
       /* move binary variables to the beginning of the list so that
          elements 1, 2, ..., nb correspond to binary variables, and
          elements nb+1, nb+2, ..., len correspond to rest variables */
       nb = 0;
       for (k = 1; k <= len; k++)
       {  j = ind[k];
-         if (lpx_get_col_kind(lp, j) == LPX_IV &&
-             lpx_get_col_type(lp, j) == LPX_DB &&
-             lpx_get_col_lb(lp, j) == 0.0 &&
-             lpx_get_col_ub(lp, j) == 1.0)
+         if (glp_get_col_kind(lp, j) == GLP_BV)
          {  /* binary variable */
             int ind_k;
             double val_k;
             nb++;
             ind_k = ind[nb], val_k = val[nb];
             ind[nb] = ind[k], val[nb] = val[k];
             ind[k] = ind_k, val[k] = val_k;
@@ -357,48 +351,48 @@
       /* at least two binary variables are needed */
       if (nb < 2) return 0;
       /* compute implied lower and upper bounds for sum a[j]*y[j] */
       f_min = f_max = 0.0;
       for (k = nb+1; k <= len; k++)
       {  j = ind[k];
          /* both bounds must be finite */
-         if (lpx_get_col_type(lp, j) != LPX_DB) return 0;
+         if (glp_get_col_type(lp, j) != GLP_DB) return 0;
          if (val[k] > 0.0)
-         {  f_min += val[k] * lpx_get_col_lb(lp, j);
-            f_max += val[k] * lpx_get_col_ub(lp, j);
+         {  f_min += val[k] * glp_get_col_lb(lp, j);
+            f_max += val[k] * glp_get_col_ub(lp, j);
          }
          else
-         {  f_min += val[k] * lpx_get_col_ub(lp, j);
-            f_max += val[k] * lpx_get_col_lb(lp, j);
+         {  f_min += val[k] * glp_get_col_ub(lp, j);
+            f_max += val[k] * glp_get_col_lb(lp, j);
          }
       }
       /* sum a[j]*x[j] + sum a[j]*y[j] <= b ===>
          sum a[j]*x[j] + (sum a[j]*y[j] - f_min) <= b - f_min ===>
          sum a[j]*x[j] + y <= b - f_min,
          where y = sum a[j]*y[j] - f_min;
          note that 0 <= y <= u, u = f_max - f_min */
       /* determine upper bound of y */
       u = f_max - f_min;
       /* determine value of y at the current point */
       y = 0.0;
       for (k = nb+1; k <= len; k++)
       {  j = ind[k];
-         y += val[k] * lpx_get_col_prim(lp, j);
+         y += val[k] * glp_get_col_prim(lp, j);
       }
       y -= f_min;
       if (y < 0.0) y = 0.0;
       if (y > u) y = u;
       /* modify the right-hand side b */
       val[0] -= f_min;
       /* now the transformed row has the form:
          sum a[j]*x[j] + y <= b, where 0 <= y <= u */
       /* determine values of x[j] at the current point */
       for (k = 1; k <= nb; k++)
       {  j = ind[k];
-         x[k] = lpx_get_col_prim(lp, j);
+         x[k] = glp_get_col_prim(lp, j);
          if (x[k] < 0.0) x[k] = 0.0;
          if (x[k] > 1.0) x[k] = 1.0;
       }
       /* if a[j] < 0, replace x[j] by its complement 1 - x'[j] */
       for (k = 1; k <= nb; k++)
       {  if (val[k] < 0.0)
          {  ind[k] = - ind[k];
@@ -444,15 +438,14 @@
 }
 
 /*----------------------------------------------------------------------
 -- lpx_eval_row - compute explictily specified row.
 --
 -- SYNOPSIS
 --
--- #include "glplpx.h"
 -- double lpx_eval_row(LPX *lp, int len, int ind[], double val[]);
 --
 -- DESCRIPTION
 --
 -- The routine lpx_eval_row computes the primal value of an explicitly
 -- specified row using current values of structural variables.
 --
@@ -469,26 +462,27 @@
 -- The array ind and val are not changed on exit.
 --
 -- RETURNS
 --
 -- The routine returns a computed value of y, the auxiliary variable of
 -- the specified row. */
 
-static double lpx_eval_row(LPX *lp, int len, int ind[], double val[])
-{     int n = lpx_get_num_cols(lp);
+static double lpx_eval_row(glp_prob *lp, int len, int ind[],
+      double val[])
+{     int n = glp_get_num_cols(lp);
       int j, k;
       double sum = 0.0;
       if (len < 0)
          xerror("lpx_eval_row: len = %d; invalid row length\n", len);
       for (k = 1; k <= len; k++)
       {  j = ind[k];
          if (!(1 <= j && j <= n))
             xerror("lpx_eval_row: j = %d; column number out of range\n",
                j);
-         sum += val[k] * lpx_get_col_prim(lp, j);
+         sum += val[k] * glp_get_col_prim(lp, j);
       }
       return sum;
 }
 
 /***********************************************************************
 *  NAME
 *
@@ -502,39 +496,39 @@
 *  DESCRIPTION
 *
 *  The routine ios_cov_gen generates mixed cover cuts for the current
 *  point and adds them to the cut pool. */
 
 void ios_cov_gen(glp_tree *tree)
 {     glp_prob *prob = tree->mip;
-      int m = lpx_get_num_rows(prob);
-      int n = lpx_get_num_cols(prob);
+      int m = glp_get_num_rows(prob);
+      int n = glp_get_num_cols(prob);
       int i, k, type, kase, len, *ind;
       double r, *val, *work;
-      xassert(lpx_get_status(prob) == LPX_OPT);
+      xassert(glp_get_status(prob) == GLP_OPT);
       /* allocate working arrays */
       ind = xcalloc(1+n, sizeof(int));
       val = xcalloc(1+n, sizeof(double));
       work = xcalloc(1+n, sizeof(double));
       /* look through all rows */
       for (i = 1; i <= m; i++)
       for (kase = 1; kase <= 2; kase++)
-      {  type = lpx_get_row_type(prob, i);
+      {  type = glp_get_row_type(prob, i);
          if (kase == 1)
          {  /* consider rows of '<=' type */
-            if (!(type == LPX_UP || type == LPX_DB)) continue;
-            len = lpx_get_mat_row(prob, i, ind, val);
-            val[0] = lpx_get_row_ub(prob, i);
+            if (!(type == GLP_UP || type == GLP_DB)) continue;
+            len = glp_get_mat_row(prob, i, ind, val);
+            val[0] = glp_get_row_ub(prob, i);
          }
          else
          {  /* consider rows of '>=' type */
-            if (!(type == LPX_LO || type == LPX_DB)) continue;
-            len = lpx_get_mat_row(prob, i, ind, val);
+            if (!(type == GLP_LO || type == GLP_DB)) continue;
+            len = glp_get_mat_row(prob, i, ind, val);
             for (k = 1; k <= len; k++) val[k] = - val[k];
-            val[0] = - lpx_get_row_lb(prob, i);
+            val[0] = - glp_get_row_lb(prob, i);
          }
          /* generate mixed cover cut:
             sum{j in J} a[j] * x[j] <= b */
          len = lpx_cover_cut(prob, len, ind, val, work);
          if (len == 0) continue;
          /* at the current point the cut inequality is violated, i.e.
             sum{j in J} a[j] * x[j] - b > 0 */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios08.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxlp.c`

 * *Files 20% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios08.c (clique cut generator) */
+/* spxlp.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2015 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,895 +15,803 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#endif
+#include "env.h"
+#include "spxlp.h"
 
-#include "glpios.h"
+/***********************************************************************
+*  spx_factorize - compute factorization of current basis matrix
+*
+*  This routine computes factorization of the current basis matrix B.
+*
+*  If the factorization has been successfully computed, the routine
+*  validates it and returns zero. Otherwise, the routine invalidates
+*  the factorization and returns the code provided by the factorization
+*  driver (bfd_factorize). */
+
+static int jth_col(void *info, int j, int ind[], double val[])
+{     /* provide column B[j] */
+      SPXLP *lp = info;
+      int m = lp->m;
+      int *A_ptr = lp->A_ptr;
+      int *head = lp->head;
+      int k, ptr, len;
+      xassert(1 <= j && j <= m);
+      k = head[j]; /* x[k] = xB[j] */
+      ptr = A_ptr[k];
+      len = A_ptr[k+1] - ptr;
+      memcpy(&ind[1], &lp->A_ind[ptr], len * sizeof(int));
+      memcpy(&val[1], &lp->A_val[ptr], len * sizeof(double));
+      return len;
+}
 
-static double get_row_lb(LPX *lp, int i)
-{     /* this routine returns lower bound of row i or -DBL_MAX if the
-         row has no lower bound */
-      double lb;
-      switch (lpx_get_row_type(lp, i))
-      {  case LPX_FR:
-         case LPX_UP:
-            lb = -DBL_MAX;
-            break;
-         case LPX_LO:
-         case LPX_DB:
-         case LPX_FX:
-            lb = lpx_get_row_lb(lp, i);
-            break;
-         default:
-            xassert(lp != lp);
-      }
-      return lb;
-}
-
-static double get_row_ub(LPX *lp, int i)
-{     /* this routine returns upper bound of row i or +DBL_MAX if the
-         row has no upper bound */
-      double ub;
-      switch (lpx_get_row_type(lp, i))
-      {  case LPX_FR:
-         case LPX_LO:
-            ub = +DBL_MAX;
-            break;
-         case LPX_UP:
-         case LPX_DB:
-         case LPX_FX:
-            ub = lpx_get_row_ub(lp, i);
-            break;
-         default:
-            xassert(lp != lp);
-      }
-      return ub;
-}
-
-static double get_col_lb(LPX *lp, int j)
-{     /* this routine returns lower bound of column j or -DBL_MAX if
-         the column has no lower bound */
-      double lb;
-      switch (lpx_get_col_type(lp, j))
-      {  case LPX_FR:
-         case LPX_UP:
-            lb = -DBL_MAX;
-            break;
-         case LPX_LO:
-         case LPX_DB:
-         case LPX_FX:
-            lb = lpx_get_col_lb(lp, j);
-            break;
-         default:
-            xassert(lp != lp);
-      }
-      return lb;
-}
-
-static double get_col_ub(LPX *lp, int j)
-{     /* this routine returns upper bound of column j or +DBL_MAX if
-         the column has no upper bound */
-      double ub;
-      switch (lpx_get_col_type(lp, j))
-      {  case LPX_FR:
-         case LPX_LO:
-            ub = +DBL_MAX;
-            break;
-         case LPX_UP:
-         case LPX_DB:
-         case LPX_FX:
-            ub = lpx_get_col_ub(lp, j);
-            break;
-         default:
-            xassert(lp != lp);
-      }
-      return ub;
-}
-
-static int is_binary(LPX *lp, int j)
-{     /* this routine checks if variable x[j] is binary */
-      return
-         lpx_get_col_kind(lp, j) == LPX_IV &&
-         lpx_get_col_type(lp, j) == LPX_DB &&
-         lpx_get_col_lb(lp, j) == 0.0 && lpx_get_col_ub(lp, j) == 1.0;
-}
-
-static double eval_lf_min(LPX *lp, int len, int ind[], double val[])
-{     /* this routine computes the minimum of a specified linear form
-
-            sum a[j]*x[j]
-             j
-
-         using the formula:
-
-            min =   sum   a[j]*lb[j] +   sum   a[j]*ub[j],
-                  j in J+              j in J-
-
-         where J+ = {j: a[j] > 0}, J- = {j: a[j] < 0}, lb[j] and ub[j]
-         are lower and upper bound of variable x[j], resp. */
-      int j, t;
-      double lb, ub, sum;
-      sum = 0.0;
-      for (t = 1; t <= len; t++)
-      {  j = ind[t];
-         if (val[t] > 0.0)
-         {  lb = get_col_lb(lp, j);
-            if (lb == -DBL_MAX)
-            {  sum = -DBL_MAX;
-               break;
-            }
-            sum += val[t] * lb;
-         }
-         else if (val[t] < 0.0)
-         {  ub = get_col_ub(lp, j);
-            if (ub == +DBL_MAX)
-            {  sum = -DBL_MAX;
-               break;
-            }
-            sum += val[t] * ub;
-         }
-         else
-            xassert(val != val);
-      }
-      return sum;
+int spx_factorize(SPXLP *lp)
+{     int ret;
+      ret = bfd_factorize(lp->bfd, lp->m, jth_col, lp);
+      lp->valid = (ret == 0);
+      return ret;
 }
 
-static double eval_lf_max(LPX *lp, int len, int ind[], double val[])
-{     /* this routine computes the maximum of a specified linear form
+/***********************************************************************
+*  spx_eval_beta - compute current values of basic variables
+*
+*  This routine computes vector beta = (beta[i]) of current values of
+*  basic variables xB = (xB[i]). (Factorization of the current basis
+*  matrix should be valid.)
+*
+*  First the routine computes a modified vector of right-hand sides:
+*
+*                         n-m
+*     y = b - N * f = b - sum N[j] * f[j],
+*                         j=1
+*
+*  where b = (b[i]) is the original vector of right-hand sides, N is
+*  a matrix composed from columns of the original constraint matrix A,
+*  which (columns) correspond to non-basic variables, f = (f[j]) is the
+*  vector of active bounds of non-basic variables xN = (xN[j]),
+*  N[j] = A[k] is a column of matrix A corresponding to non-basic
+*  variable xN[j] = x[k], f[j] is current active bound lN[j] = l[k] or
+*  uN[j] = u[k] of non-basic variable xN[j] = x[k]. The matrix-vector
+*  product N * f is computed as a linear combination of columns of N,
+*  so if f[j] = 0, column N[j] can be skipped.
+*
+*  Then the routine performs FTRAN to compute the vector beta:
+*
+*     beta = inv(B) * y.
+*
+*  On exit the routine stores components of the vector beta to array
+*  locations beta[1], ..., beta[m]. */
 
-            sum a[j]*x[j]
-             j
-
-         using the formula:
-
-            max =   sum   a[j]*ub[j] +   sum   a[j]*lb[j],
-                  j in J+              j in J-
-
-         where J+ = {j: a[j] > 0}, J- = {j: a[j] < 0}, lb[j] and ub[j]
-         are lower and upper bound of variable x[j], resp. */
-      int j, t;
-      double lb, ub, sum;
-      sum = 0.0;
-      for (t = 1; t <= len; t++)
-      {  j = ind[t];
-         if (val[t] > 0.0)
-         {  ub = get_col_ub(lp, j);
-            if (ub == +DBL_MAX)
-            {  sum = +DBL_MAX;
-               break;
-            }
-            sum += val[t] * ub;
-         }
-         else if (val[t] < 0.0)
-         {  lb = get_col_lb(lp, j);
-            if (lb == -DBL_MAX)
-            {  sum = +DBL_MAX;
-               break;
-            }
-            sum += val[t] * lb;
-         }
-         else
-            xassert(val != val);
-      }
-      return sum;
+void spx_eval_beta(SPXLP *lp, double beta[/*1+m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      double *A_val = lp->A_val;
+      double *b = lp->b;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      int j, k, ptr, end;
+      double fj, *y;
+      /* compute y = b - N * xN */
+      /* y := b */
+      y = beta;
+      memcpy(&y[1], &b[1], m * sizeof(double));
+      /* y := y - N * f */
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         /* f[j] := active bound of xN[j] */
+         fj = flag[j] ? u[k] : l[k];
+         if (fj == 0.0 || fj == -DBL_MAX)
+         {  /* either xN[j] has zero active bound or it is unbounded;
+             * in the latter case its value is assumed to be zero */
+            continue;
+         }
+         /* y := y - N[j] * f[j] */
+         ptr = A_ptr[k];
+         end = A_ptr[k+1];
+         for (; ptr < end; ptr++)
+            y[A_ind[ptr]] -= A_val[ptr] * fj;
+      }
+      /* compute beta = inv(B) * y */
+      xassert(lp->valid);
+      bfd_ftran(lp->bfd, beta);
+      return;
 }
 
-/*----------------------------------------------------------------------
--- probing - determine logical relation between binary variables.
---
--- This routine tentatively sets a binary variable to 0 and then to 1
--- and examines whether another binary variable is caused to be fixed.
---
--- The examination is based only on one row (constraint), which is the
--- following:
---
---    L <= sum a[j]*x[j] <= U.                                       (1)
---          j
---
--- Let x[p] be a probing variable, x[q] be an examined variable. Then
--- (1) can be written as:
---
---    L <=   sum  a[j]*x[j] + a[p]*x[p] + a[q]*x[q] <= U,            (2)
---         j in J'
---
--- where J' = {j: j != p and j != q}.
---
--- Let
---
---    L' = L - a[p]*x[p],                                            (3)
---
---    U' = U - a[p]*x[p],                                            (4)
---
--- where x[p] is assumed to be fixed at 0 or 1. So (2) can be rewritten
--- as follows:
---
---    L' <=   sum  a[j]*x[j] + a[q]*x[q] <= U',                      (5)
---          j in J'
---
--- from where we have:
---
---    L' -  sum  a[j]*x[j] <= a[q]*x[q] <= U' -  sum  a[j]*x[j].     (6)
---        j in J'                              j in J'
---
--- Thus,
---
---    min a[q]*x[q] = L' - MAX,                                      (7)
---
---    max a[q]*x[q] = U' - MIN,                                      (8)
---
--- where
---
---    MIN = min  sum  a[j]*x[j],                                     (9)
---             j in J'
---
---    MAX = max  sum  a[j]*x[j].                                    (10)
---             j in J'
---
--- Formulae (7) and (8) allows determining implied lower and upper
--- bounds of x[q].
---
--- Parameters len, val, L and U specify the constraint (1).
---
--- Parameters lf_min and lf_max specify implied lower and upper bounds
--- of the linear form (1). It is assumed that these bounds are computed
--- with the routines eval_lf_min and eval_lf_max (see above).
---
--- Parameter p specifies the probing variable x[p], which is set to 0
--- (if set is 0) or to 1 (if set is 1).
---
--- Parameter q specifies the examined variable x[q].
---
--- On exit the routine returns one of the following codes:
---
--- 0 - there is no logical relation between x[p] and x[q];
--- 1 - x[q] can take only on value 0;
--- 2 - x[q] can take only on value 1. */
-
-static int probing(int len, double val[], double L, double U,
-      double lf_min, double lf_max, int p, int set, int q)
-{     double temp;
-      xassert(1 <= p && p < q && q <= len);
-      /* compute L' (3) */
-      if (L != -DBL_MAX && set) L -= val[p];
-      /* compute U' (4) */
-      if (U != +DBL_MAX && set) U -= val[p];
-      /* compute MIN (9) */
-      if (lf_min != -DBL_MAX)
-      {  if (val[p] < 0.0) lf_min -= val[p];
-         if (val[q] < 0.0) lf_min -= val[q];
-      }
-      /* compute MAX (10) */
-      if (lf_max != +DBL_MAX)
-      {  if (val[p] > 0.0) lf_max -= val[p];
-         if (val[q] > 0.0) lf_max -= val[q];
-      }
-      /* compute implied lower bound of x[q]; see (7), (8) */
-      if (val[q] > 0.0)
-      {  if (L == -DBL_MAX || lf_max == +DBL_MAX)
-            temp = -DBL_MAX;
-         else
-            temp = (L - lf_max) / val[q];
-      }
-      else
-      {  if (U == +DBL_MAX || lf_min == -DBL_MAX)
-            temp = -DBL_MAX;
-         else
-            temp = (U - lf_min) / val[q];
-      }
-      if (temp > 0.001) return 2;
-      /* compute implied upper bound of x[q]; see (7), (8) */
-      if (val[q] > 0.0)
-      {  if (U == +DBL_MAX || lf_min == -DBL_MAX)
-            temp = +DBL_MAX;
-         else
-            temp = (U - lf_min) / val[q];
+/***********************************************************************
+*  spx_eval_obj - compute current value of objective function
+*
+*  This routine computes the value of the objective function in the
+*  current basic solution:
+*
+*     z = cB'* beta + cN'* f + c[0] =
+*
+*          m                    n-m
+*       = sum cB[i] * beta[i] + sum cN[j] * f[j] + c[0],
+*         i=1                   j=1
+*
+*  where cB = (cB[i]) is the vector of objective coefficients at basic
+*  variables, beta = (beta[i]) is the vector of current values of basic
+*  variables, cN = (cN[j]) is the vector of objective coefficients at
+*  non-basic variables, f = (f[j]) is the vector of current active
+*  bounds of non-basic variables, c[0] is the constant term of the
+*  objective function.
+*
+*  It as assumed that components of the vector beta are stored in the
+*  array locations beta[1], ..., beta[m]. */
+
+double spx_eval_obj(SPXLP *lp, const double beta[/*1+m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      int i, j, k;
+      double fj, z;
+      /* compute z = cB'* beta + cN'* f + c0 */
+      /* z := c0 */
+      z = c[0];
+      /* z := z + cB'* beta */
+      for (i = 1; i <= m; i++)
+      {  k = head[i]; /* x[k] = xB[i] */
+         z += c[k] * beta[i];
       }
-      else
-      {  if (L == -DBL_MAX || lf_max == +DBL_MAX)
-            temp = +DBL_MAX;
-         else
-            temp = (L - lf_max) / val[q];
+      /* z := z + cN'* f */
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         /* f[j] := active bound of xN[j] */
+         fj = flag[j] ? u[k] : l[k];
+         if (fj == 0.0 || fj == -DBL_MAX)
+         {  /* either xN[j] has zero active bound or it is unbounded;
+             * in the latter case its value is assumed to be zero */
+            continue;
+         }
+         z += c[k] * fj;
       }
-      if (temp < 0.999) return 1;
-      /* there is no logical relation between x[p] and x[q] */
-      return 0;
-}
-
-struct COG
-{     /* conflict graph; it represents logical relations between binary
-         variables and has a vertex for each binary variable and its
-         complement, and an edge between two vertices when at most one
-         of the variables represented by the vertices can equal one in
-         an optimal solution */
-      int n;
-      /* number of variables */
-      int nb;
-      /* number of binary variables represented in the graph (note that
-         not all binary variables can be represented); vertices which
-         correspond to binary variables have numbers 1, ..., nb while
-         vertices which correspond to complements of binary variables
-         have numbers nb+1, ..., nb+nb */
-      int ne;
-      /* number of edges in the graph */
-      int *vert; /* int vert[1+n]; */
-      /* if x[j] is a binary variable represented in the graph, vert[j]
-         is the vertex number corresponding to x[j]; otherwise vert[j]
-         is zero */
-      int *orig; /* int list[1:nb]; */
-      /* if vert[j] = k > 0, then orig[k] = j */
-      unsigned char *a;
-      /* adjacency matrix of the graph having 2*nb rows and columns;
-         only strict lower triangle is stored in dense packed form */
-};
-
-/*----------------------------------------------------------------------
--- lpx_create_cog - create the conflict graph.
---
--- SYNOPSIS
---
--- #include "glplpx.h"
--- void *lpx_create_cog(LPX *lp);
---
--- DESCRIPTION
---
--- The routine lpx_create_cog creates the conflict graph for a given
--- problem instance.
---
--- RETURNS
---
--- If the graph has been created, the routine returns a pointer to it.
--- Otherwise the routine returns NULL. */
-
-#define MAX_NB 4000
-#define MAX_ROW_LEN 500
-
-static void lpx_add_cog_edge(void *_cog, int i, int j);
-
-static void *lpx_create_cog(LPX *lp)
-{     struct COG *cog = NULL;
-      int m, n, nb, i, j, p, q, len, *ind, *vert, *orig;
-      double L, U, lf_min, lf_max, *val;
-      xprintf("Creating the conflict graph...\n");
-      m = lpx_get_num_rows(lp);
-      n = lpx_get_num_cols(lp);
-      /* determine which binary variables should be included in the
-         conflict graph */
-      nb = 0;
-      vert = xcalloc(1+n, sizeof(int));
-      for (j = 1; j <= n; j++) vert[j] = 0;
-      orig = xcalloc(1+n, sizeof(int));
-      ind = xcalloc(1+n, sizeof(int));
-      val = xcalloc(1+n, sizeof(double));
+      return z;
+}
+
+/***********************************************************************
+*  spx_eval_pi - compute simplex multipliers in current basis
+*
+*  This routine computes vector pi = (pi[i]) of simplex multipliers in
+*  the current basis. (Factorization of the current basis matrix should
+*  be valid.)
+*
+*  The vector pi is computed by performing BTRAN:
+*
+*     pi = inv(B') * cB,
+*
+*  where cB = (cB[i]) is the vector of objective coefficients at basic
+*  variables xB = (xB[i]).
+*
+*  On exit components of vector pi are stored in the array locations
+*  pi[1], ..., pi[m]. */
+
+void spx_eval_pi(SPXLP *lp, double pi[/*1+m*/])
+{     int m = lp->m;
+      double *c = lp->c;
+      int *head = lp->head;
+      int i;
+      double *cB;
+      /* construct cB */
+      cB = pi;
       for (i = 1; i <= m; i++)
-      {  L = get_row_lb(lp, i);
-         U = get_row_ub(lp, i);
-         if (L == -DBL_MAX && U == +DBL_MAX) continue;
-         len = lpx_get_mat_row(lp, i, ind, val);
-         if (len > MAX_ROW_LEN) continue;
-         lf_min = eval_lf_min(lp, len, ind, val);
-         lf_max = eval_lf_max(lp, len, ind, val);
-         for (p = 1; p <= len; p++)
-         {  if (!is_binary(lp, ind[p])) continue;
-            for (q = p+1; q <= len; q++)
-            {  if (!is_binary(lp, ind[q])) continue;
-               if (probing(len, val, L, U, lf_min, lf_max, p, 0, q) ||
-                   probing(len, val, L, U, lf_min, lf_max, p, 1, q))
-               {  /* there is a logical relation */
-                  /* include the first variable in the graph */
-                  j = ind[p];
-                  if (vert[j] == 0) nb++, vert[j] = nb, orig[nb] = j;
-                  /* incude the second variable in the graph */
-                  j = ind[q];
-                  if (vert[j] == 0) nb++, vert[j] = nb, orig[nb] = j;
-               }
-            }
-         }
-      }
-      /* if the graph is either empty or has too many vertices, do not
-         create it */
-      if (nb == 0 || nb > MAX_NB)
-      {  xprintf("The conflict graph is either empty or too big\n");
-         xfree(vert);
-         xfree(orig);
-         goto done;
-      }
-      /* create the conflict graph */
-      cog = xmalloc(sizeof(struct COG));
-      cog->n = n;
-      cog->nb = nb;
-      cog->ne = 0;
-      cog->vert = vert;
-      cog->orig = orig;
-      len = nb + nb; /* number of vertices */
-      len = (len * (len - 1)) / 2; /* number of entries in triangle */
-      len = (len + (CHAR_BIT - 1)) / CHAR_BIT; /* bytes needed */
-      cog->a = xmalloc(len);
-      memset(cog->a, 0, len);
-      for (j = 1; j <= nb; j++)
-      {  /* add edge between variable and its complement */
-         lpx_add_cog_edge(cog, +orig[j], -orig[j]);
-      }
+         cB[i] = c[head[i]];
+      /* compute pi = inv(B) * cB */
+      bfd_btran(lp->bfd, pi);
+      return;
+}
+
+/***********************************************************************
+*  spx_eval_dj - compute reduced cost of j-th non-basic variable
+*
+*  This routine computes reduced cost d[j] of non-basic variable
+*  xN[j] = x[k], 1 <= j <= n-m, in the current basic solution:
+*
+*     d[j] = c[k] - A'[k] * pi,
+*
+*  where c[k] is the objective coefficient at x[k], A[k] is k-th column
+*  of the constraint matrix, pi is the vector of simplex multipliers in
+*  the current basis.
+*
+*  It as assumed that components of the vector pi are stored in the
+*  array locations pi[1], ..., pi[m]. */
+
+double spx_eval_dj(SPXLP *lp, const double pi[/*1+m*/], int j)
+{     int m = lp->m;
+      int n = lp->n;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      double *A_val = lp->A_val;
+      int k, ptr, end;
+      double dj;
+      xassert(1 <= j && j <= n-m);
+      k = lp->head[m+j]; /* x[k] = xN[j] */
+      /* dj := c[k] */
+      dj = lp->c[k];
+      /* dj := dj - A'[k] * pi */
+      ptr = A_ptr[k];
+      end = A_ptr[k+1];
+      for (; ptr < end; ptr++)
+         dj -= A_val[ptr] * pi[A_ind[ptr]];
+      return dj;
+}
+
+/***********************************************************************
+*  spx_eval_tcol - compute j-th column of simplex table
+*
+*  This routine computes j-th column of the current simplex table
+*  T = (T[i,j]) = - inv(B) * N, 1 <= j <= n-m. (Factorization of the
+*  current basis matrix should be valid.)
+*
+*  The simplex table column is computed by performing FTRAN:
+*
+*     tcol = - inv(B) * N[j],
+*
+*  where B is the current basis matrix, N[j] = A[k] is a column of the
+*  constraint matrix corresponding to non-basic variable xN[j] = x[k].
+*
+*  On exit components of the simplex table column are stored in the
+*  array locations tcol[1], ... tcol[m]. */
+
+void spx_eval_tcol(SPXLP *lp, int j, double tcol[/*1+m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      double *A_val = lp->A_val;
+      int *head = lp->head;
+      int i, k, ptr, end;
+      xassert(1 <= j && j <= n-m);
+      k = head[m+j]; /* x[k] = xN[j] */
+      /* compute tcol = - inv(B) * N[j] */
       for (i = 1; i <= m; i++)
-      {  L = get_row_lb(lp, i);
-         U = get_row_ub(lp, i);
-         if (L == -DBL_MAX && U == +DBL_MAX) continue;
-         len = lpx_get_mat_row(lp, i, ind, val);
-         if (len > MAX_ROW_LEN) continue;
-         lf_min = eval_lf_min(lp, len, ind, val);
-         lf_max = eval_lf_max(lp, len, ind, val);
-         for (p = 1; p <= len; p++)
-         {  if (!is_binary(lp, ind[p])) continue;
-            for (q = p+1; q <= len; q++)
-            {  if (!is_binary(lp, ind[q])) continue;
-               /* set x[p] to 0 and examine x[q] */
-               switch (probing(len, val, L, U, lf_min, lf_max, p, 0, q))
-               {  case 0:
-                     /* no logical relation */
-                     break;
-                  case 1:
-                     /* x[p] = 0 implies x[q] = 0 */
-                     lpx_add_cog_edge(cog, -ind[p], +ind[q]);
-                     break;
-                  case 2:
-                     /* x[p] = 0 implies x[q] = 1 */
-                     lpx_add_cog_edge(cog, -ind[p], -ind[q]);
-                     break;
-                  default:
-                     xassert(lp != lp);
-               }
-               /* set x[p] to 1 and examine x[q] */
-               switch (probing(len, val, L, U, lf_min, lf_max, p, 1, q))
-               {  case 0:
-                     /* no logical relation */
-                     break;
-                  case 1:
-                     /* x[p] = 1 implies x[q] = 0 */
-                     lpx_add_cog_edge(cog, +ind[p], +ind[q]);
-                     break;
-                  case 2:
-                     /* x[p] = 1 implies x[q] = 1 */
-                     lpx_add_cog_edge(cog, +ind[p], -ind[q]);
-                     break;
-                  default:
-                     xassert(lp != lp);
-               }
-            }
-         }
-      }
-      xprintf("The conflict graph has 2*%d vertices and %d edges\n",
-         cog->nb, cog->ne);
-done: xfree(ind);
-      xfree(val);
-      return cog;
-}
-
-/*----------------------------------------------------------------------
--- lpx_add_cog_edge - add edge to the conflict graph.
---
--- SYNOPSIS
---
--- #include "glplpx.h"
--- void lpx_add_cog_edge(void *cog, int i, int j);
---
--- DESCRIPTION
---
--- The routine lpx_add_cog_edge adds an edge to the conflict graph.
--- The edge connects x[i] (if i > 0) or its complement (if i < 0) and
--- x[j] (if j > 0) or its complement (if j < 0), where i and j are
--- original ordinal numbers of corresponding variables. */
+         tcol[i] = 0.0;
+      ptr = A_ptr[k];
+      end = A_ptr[k+1];
+      for (; ptr < end; ptr++)
+         tcol[A_ind[ptr]] = -A_val[ptr];
+      bfd_ftran(lp->bfd, tcol);
+      return;
+}
 
-static void lpx_add_cog_edge(void *_cog, int i, int j)
-{     struct COG *cog = _cog;
-      int k;
-      xassert(i != j);
-      /* determine indices of corresponding vertices */
-      if (i > 0)
-      {  xassert(1 <= i && i <= cog->n);
-         i = cog->vert[i];
-         xassert(i != 0);
-      }
-      else
-      {  i = -i;
-         xassert(1 <= i && i <= cog->n);
-         i = cog->vert[i];
-         xassert(i != 0);
-         i += cog->nb;
-      }
-      if (j > 0)
-      {  xassert(1 <= j && j <= cog->n);
-         j = cog->vert[j];
-         xassert(j != 0);
-      }
-      else
-      {  j = -j;
-         xassert(1 <= j && j <= cog->n);
-         j = cog->vert[j];
-         xassert(j != 0);
-         j += cog->nb;
-      }
-      /* only lower triangle is stored, so we need i > j */
-      if (i < j) k = i, i = j, j = k;
-      k = ((i - 1) * (i - 2)) / 2 + (j - 1);
-      cog->a[k / CHAR_BIT] |=
-         (unsigned char)(1 << ((CHAR_BIT - 1) - k % CHAR_BIT));
-      cog->ne++;
+/***********************************************************************
+*  spx_eval_rho - compute i-th row of basis matrix inverse
+*
+*  This routine computes i-th row of the matrix inv(B), where B is
+*  the current basis matrix, 1 <= i <= m. (Factorization of the current
+*  basis matrix should be valid.)
+*
+*  The inverse row is computed by performing BTRAN:
+*
+*     rho = inv(B') * e[i],
+*
+*  where e[i] is i-th column of unity matrix.
+*
+*  On exit components of the row are stored in the array locations
+*  row[1], ..., row[m]. */
+
+void spx_eval_rho(SPXLP *lp, int i, double rho[/*1+m*/])
+{     int m = lp->m;
+      int j;
+      xassert(1 <= i && i <= m);
+      /* compute rho = inv(B') * e[i] */
+      for (j = 1; j <= m; j++)
+         rho[j] = 0.0;
+      rho[i] = 1.0;
+      bfd_btran(lp->bfd, rho);
       return;
 }
 
-/*----------------------------------------------------------------------
--- MAXIMUM WEIGHT CLIQUE
---
--- Two subroutines sub() and wclique() below are intended to find a
--- maximum weight clique in a given undirected graph. These subroutines
--- are slightly modified version of the program WCLIQUE developed by
--- Patric Ostergard <http://www.tcs.hut.fi/~pat/wclique.html> and based
--- on ideas from the article "P. R. J. Ostergard, A new algorithm for
--- the maximum-weight clique problem, submitted for publication", which
--- in turn is a generalization of the algorithm for unweighted graphs
--- presented in "P. R. J. Ostergard, A fast algorithm for the maximum
--- clique problem, submitted for publication".
---
--- USED WITH PERMISSION OF THE AUTHOR OF THE ORIGINAL CODE. */
-
-struct dsa
-{     /* dynamic storage area */
-      int n;
-      /* number of vertices */
-      int *wt; /* int wt[0:n-1]; */
-      /* weights */
-      unsigned char *a;
-      /* adjacency matrix (packed lower triangle without main diag.) */
-      int record;
-      /* weight of best clique */
-      int rec_level;
-      /* number of vertices in best clique */
-      int *rec; /* int rec[0:n-1]; */
-      /* best clique so far */
-      int *clique; /* int clique[0:n-1]; */
-      /* table for pruning */
-      int *set; /* int set[0:n-1]; */
-      /* current clique */
-};
-
-#define n         (dsa->n)
-#define wt        (dsa->wt)
-#define a         (dsa->a)
-#define record    (dsa->record)
-#define rec_level (dsa->rec_level)
-#define rec       (dsa->rec)
-#define clique    (dsa->clique)
-#define set       (dsa->set)
-
-#if 0
-static int is_edge(struct dsa *dsa, int i, int j)
-{     /* if there is arc (i,j), the routine returns true; otherwise
-         false; 0 <= i, j < n */
-      int k;
-      xassert(0 <= i && i < n);
-      xassert(0 <= j && j < n);
-      if (i == j) return 0;
-      if (i < j) k = i, i = j, j = k;
-      k = (i * (i - 1)) / 2 + j;
-      return a[k / CHAR_BIT] &
-         (unsigned char)(1 << ((CHAR_BIT - 1) - k % CHAR_BIT));
-}
-#else
-#define is_edge(dsa, i, j) ((i) == (j) ? 0 : \
-      (i) > (j) ? is_edge1(i, j) : is_edge1(j, i))
-#define is_edge1(i, j) is_edge2(((i) * ((i) - 1)) / 2 + (j))
-#define is_edge2(k) (a[(k) / CHAR_BIT] & \
-      (unsigned char)(1 << ((CHAR_BIT - 1) - (k) % CHAR_BIT)))
+#if 1 /* 31/III-2016 */
+void spx_eval_rho_s(SPXLP *lp, int i, FVS *rho)
+{     /* sparse version of spx_eval_rho */
+      int m = lp->m;
+      xassert(1 <= i && i <= m);
+      /* compute rho = inv(B') * e[i] */
+      xassert(rho->n == m);
+      fvs_clear_vec(rho);
+      rho->nnz = 1;
+      rho->ind[1] = i;
+      rho->vec[i] = 1.0;
+      bfd_btran_s(lp->bfd, rho);
+      return;
+}
 #endif
 
-static void sub(struct dsa *dsa, int ct, int table[], int level,
-      int weight, int l_weight)
-{     int i, j, k, curr_weight, left_weight, *p1, *p2, *newtable;
-      newtable = xcalloc(n, sizeof(int));
-      if (ct <= 0)
-      {  /* 0 or 1 elements left; include these */
-         if (ct == 0)
-         {  set[level++] = table[0];
-            weight += l_weight;
-         }
-         if (weight > record)
-         {  record = weight;
-            rec_level = level;
-            for (i = 0; i < level; i++) rec[i] = set[i];
-         }
-         goto done;
-      }
-      for (i = ct; i >= 0; i--)
-      {  if ((level == 0) && (i < ct)) goto done;
-         k = table[i];
-         if ((level > 0) && (clique[k] <= (record - weight)))
-            goto done; /* prune */
-         set[level] = k;
-         curr_weight = weight + wt[k];
-         l_weight -= wt[k];
-         if (l_weight <= (record - curr_weight))
-            goto done; /* prune */
-         p1 = newtable;
-         p2 = table;
-         left_weight = 0;
-         while (p2 < table + i)
-         {  j = *p2++;
-            if (is_edge(dsa, j, k))
-            {  *p1++ = j;
-               left_weight += wt[j];
-            }
-         }
-         if (left_weight <= (record - curr_weight)) continue;
-         sub(dsa, p1 - newtable - 1, newtable, level + 1, curr_weight,
-            left_weight);
+/***********************************************************************
+*  spx_eval_tij - compute element T[i,j] of simplex table
+*
+*  This routine computes element T[i,j] of the current simplex table
+*  T = - inv(B) * N, 1 <= i <= m, 1 <= j <= n-m, with the following
+*  formula:
+*
+*     T[i,j] = - N'[j] * rho,                                        (1)
+*
+*  where N[j] = A[k] is a column of the constraint matrix corresponding
+*  to non-basic variable xN[j] = x[k], rho is i-th row of the inverse
+*  matrix inv(B).
+*
+*  It as assumed that components of the inverse row rho = (rho[j]) are
+*  stored in the array locations rho[1], ..., rho[m]. */
+
+double spx_eval_tij(SPXLP *lp, const double rho[/*1+m*/], int j)
+{     int m = lp->m;
+      int n = lp->n;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      double *A_val = lp->A_val;
+      int k, ptr, end;
+      double tij;
+      xassert(1 <= j && j <= n-m);
+      k = lp->head[m+j]; /* x[k] = xN[j] */
+      /* compute t[i,j] = - N'[j] * pi */
+      tij = 0.0;
+      ptr = A_ptr[k];
+      end = A_ptr[k+1];
+      for (; ptr < end; ptr++)
+         tij -= A_val[ptr] * rho[A_ind[ptr]];
+      return tij;
+}
+
+/***********************************************************************
+*  spx_eval_trow - compute i-th row of simplex table
+*
+*  This routine computes i-th row of the current simplex table
+*  T = (T[i,j]) = - inv(B) * N, 1 <= i <= m.
+*
+*  Elements of the row T[i] = (T[i,j]), j = 1, ..., n-m, are computed
+*  directly with the routine spx_eval_tij.
+*
+*  The vector rho = (rho[j]), which is i-th row of the basis inverse
+*  inv(B), should be previously computed with the routine spx_eval_rho.
+*  It is assumed that elements of this vector are stored in the array
+*  locations rho[1], ..., rho[m].
+*
+*  On exit components of the simplex table row are stored in the array
+*  locations trow[1], ... trow[n-m].
+*
+*  NOTE: For testing/debugging only. */
+
+void spx_eval_trow(SPXLP *lp, const double rho[/*1+m*/], double
+      trow[/*1+n-m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      int j;
+      for (j = 1; j <= n-m; j++)
+         trow[j] = spx_eval_tij(lp, rho, j);
+      return;
+}
+
+/***********************************************************************
+*  spx_update_beta - update values of basic variables
+*
+*  This routine updates the vector beta = (beta[i]) of values of basic
+*  variables xB = (xB[i]) for the adjacent basis.
+*
+*  On entry to the routine components of the vector beta in the current
+*  basis should be placed in array locations beta[1], ..., beta[m].
+*
+*  The parameter 1 <= p <= m specifies basic variable xB[p] which
+*  becomes non-basic variable xN[q] in the adjacent basis. The special
+*  case p < 0 means that non-basic variable xN[q] goes from its current
+*  active bound to opposite one in the adjacent basis.
+*
+*  If the flag p_flag is set, the active bound of xB[p] in the adjacent
+*  basis is set to its upper bound. (In this case xB[p] should have its
+*  upper bound and should not be fixed.)
+*
+*  The parameter 1 <= q <= n-m specifies non-basic variable xN[q] which
+*  becomes basic variable xB[p] in the adjacent basis (if 1 <= p <= m),
+*  or goes to its opposite bound (if p < 0). (In the latter case xN[q]
+*  should have both lower and upper bounds and should not be fixed.)
+*
+*  It is assumed that the array tcol contains elements of q-th (pivot)
+*  column T[q] of the simple table in locations tcol[1], ..., tcol[m].
+*  (This column should be computed for the current basis.)
+*
+*  First, the routine determines the increment of basic variable xB[p]
+*  in the adjacent basis (but only if 1 <= p <= m):
+*
+*                   (       - beta[p], if -inf < xB[p] < +inf
+*                   (
+*     delta xB[p] = { lB[p] - beta[p], if p_flag = 0
+*                   (
+*                   ( uB[p] - beta[p], if p_flag = 1
+*
+*  where beta[p] is the value of xB[p] in the current basis, lB[p] and
+*  uB[p] are its lower and upper bounds. Then, the routine determines
+*  the increment of non-basic variable xN[q] in the adjacent basis:
+*
+*                   ( delta xB[p] / T[p,q], if 1 <= p <= m
+*                   (
+*     delta xN[q] = { uN[q] - lN[q],        if p < 0 and f[q] = lN[q]
+*                   (
+*                   ( lN[q] - uN[q],        if p < 0 and f[q] = uN[q]
+*
+*  where T[p,q] is the pivot element of the simplex table, f[q] is the
+*  active bound of xN[q] in the current basis.
+*
+*  If 1 <= p <= m, in the adjacent basis xN[q] becomes xB[p], so:
+*
+*     new beta[p] = f[q] + delta xN[q].
+*
+*  Values of other basic variables xB[i] for 1 <= i <= m, i != p, are
+*  updated as follows:
+*
+*     new beta[i] = beta[i] + T[i,q] * delta xN[q].
+*
+*  On exit the routine stores updated components of the vector beta to
+*  the same locations, where the input vector beta was stored. */
+
+void spx_update_beta(SPXLP *lp, double beta[/*1+m*/], int p,
+      int p_flag, int q, const double tcol[/*1+m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      int i, k;
+      double delta_p, delta_q;
+      if (p < 0)
+      {  /* special case: xN[q] goes to its opposite bound */
+         xassert(1 <= q && q <= n-m);
+         /* xN[q] should be double-bounded variable */
+         k = head[m+q]; /* x[k] = xN[q] */
+         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);
+         /* determine delta xN[q] */
+         if (flag[q])
+         {  /* xN[q] goes from its upper bound to its lower bound */
+            delta_q = l[k] - u[k];
+         }
+         else
+         {  /* xN[q] goes from its lower bound to its upper bound */
+            delta_q = u[k] - l[k];
+         }
+      }
+      else
+      {  /* xB[p] leaves the basis, xN[q] enters the basis */
+         xassert(1 <= p && p <= m);
+         xassert(1 <= q && q <= n-m);
+         /* determine delta xB[p] */
+         k = head[p]; /* x[k] = xB[p] */
+         if (p_flag)
+         {  /* xB[p] goes to its upper bound */
+            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
+            delta_p = u[k] - beta[p];
+         }
+         else if (l[k] == -DBL_MAX)
+         {  /* unbounded xB[p] becomes non-basic (unusual case) */
+            xassert(u[k] == +DBL_MAX);
+            delta_p = 0.0 - beta[p];
+         }
+         else
+         {  /* xB[p] goes to its lower bound or becomes fixed */
+            delta_p = l[k] - beta[p];
+         }
+         /* determine delta xN[q] */
+         delta_q = delta_p / tcol[p];
+         /* compute new beta[p], which is the value of xN[q] in the
+          * adjacent basis */
+         k = head[m+q]; /* x[k] = xN[q] */
+         if (flag[q])
+         {  /* xN[q] has its upper bound active */
+            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
+            beta[p] = u[k] + delta_q;
+         }
+         else if (l[k] == -DBL_MAX)
+         {  /* xN[q] is non-basic unbounded variable */
+            xassert(u[k] == +DBL_MAX);
+            beta[p] = 0.0 + delta_q;
+         }
+         else
+         {  /* xN[q] has its lower bound active or is fixed (latter
+             * case is unusual) */
+            beta[p] = l[k] + delta_q;
+         }
+      }
+      /* compute new beta[i] for all i != p */
+      for (i = 1; i <= m; i++)
+      {  if (i != p)
+            beta[i] += tcol[i] * delta_q;
       }
-done: xfree(newtable);
       return;
 }
 
-static int wclique(int _n, int w[], unsigned char _a[], int sol[])
-{     struct dsa _dsa, *dsa = &_dsa;
-      int i, j, p, max_wt, max_nwt, wth, *used, *nwt, *pos;
-      glp_long timer;
-      n = _n;
-      wt = &w[1];
-      a = _a;
-      record = 0;
-      rec_level = 0;
-      rec = &sol[1];
-      clique = xcalloc(n, sizeof(int));
-      set = xcalloc(n, sizeof(int));
-      used = xcalloc(n, sizeof(int));
-      nwt = xcalloc(n, sizeof(int));
-      pos = xcalloc(n, sizeof(int));
-      /* start timer */
-      timer = xtime();
-      /* order vertices */
-      for (i = 0; i < n; i++)
-      {  nwt[i] = 0;
-         for (j = 0; j < n; j++)
-            if (is_edge(dsa, i, j)) nwt[i] += wt[j];
-      }
-      for (i = 0; i < n; i++)
-         used[i] = 0;
-      for (i = n-1; i >= 0; i--)
-      {  max_wt = -1;
-         max_nwt = -1;
-         for (j = 0; j < n; j++)
-         {  if ((!used[j]) && ((wt[j] > max_wt) || (wt[j] == max_wt
-               && nwt[j] > max_nwt)))
-            {  max_wt = wt[j];
-               max_nwt = nwt[j];
-               p = j;
-            }
-         }
-         pos[i] = p;
-         used[p] = 1;
-         for (j = 0; j < n; j++)
-            if ((!used[j]) && (j != p) && (is_edge(dsa, p, j)))
-               nwt[j] -= wt[p];
-      }
-      /* main routine */
-      wth = 0;
-      for (i = 0; i < n; i++)
-      {  wth += wt[pos[i]];
-         sub(dsa, i, pos, 0, 0, wth);
-         clique[pos[i]] = record;
-#if 0
-         if (utime() >= timer + 5.0)
-#else
-         if (xdifftime(xtime(), timer) >= 5.0 - 0.001)
-#endif
-         {  /* print current record and reset timer */
-            xprintf("level = %d (%d); best = %d\n", i+1, n, record);
-#if 0
-            timer = utime();
-#else
-            timer = xtime();
+#if 1 /* 30/III-2016 */
+void spx_update_beta_s(SPXLP *lp, double beta[/*1+m*/], int p,
+      int p_flag, int q, const FVS *tcol)
+{     /* sparse version of spx_update_beta */
+      int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      int nnz = tcol->nnz;
+      int *ind = tcol->ind;
+      double *vec = tcol->vec;
+      int i, k;
+      double delta_p, delta_q;
+      xassert(tcol->n == m);
+      if (p < 0)
+      {  /* special case: xN[q] goes to its opposite bound */
+#if 0 /* 11/VI-2017 */
+         /* FIXME: not tested yet */
+         xassert(0);
 #endif
+         xassert(1 <= q && q <= n-m);
+         /* xN[q] should be double-bounded variable */
+         k = head[m+q]; /* x[k] = xN[q] */
+         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);
+         /* determine delta xN[q] */
+         if (flag[q])
+         {  /* xN[q] goes from its upper bound to its lower bound */
+            delta_q = l[k] - u[k];
+         }
+         else
+         {  /* xN[q] goes from its lower bound to its upper bound */
+            delta_q = u[k] - l[k];
          }
       }
-      xfree(clique);
-      xfree(set);
-      xfree(used);
-      xfree(nwt);
-      xfree(pos);
-      /* return the solution found */
-      for (i = 1; i <= rec_level; i++) sol[i]++;
-      return rec_level;
-}
-
-#undef n
-#undef wt
-#undef a
-#undef record
-#undef rec_level
-#undef rec
-#undef clique
-#undef set
-
-/*----------------------------------------------------------------------
--- lpx_clique_cut - generate cluque cut.
---
--- SYNOPSIS
---
--- #include "glplpx.h"
--- int lpx_clique_cut(LPX *lp, void *cog, int ind[], double val[]);
---
--- DESCRIPTION
---
--- The routine lpx_clique_cut generates a clique cut using the conflict
--- graph specified by the parameter cog.
---
--- If a violated clique cut has been found, it has the following form:
---
---    sum{j in J} a[j]*x[j] <= b.
---
--- Variable indices j in J are stored in elements ind[1], ..., ind[len]
--- while corresponding constraint coefficients are stored in elements
--- val[1], ..., val[len], where len is returned on exit. The right-hand
--- side b is stored in element val[0].
---
--- RETURNS
---
--- If the cutting plane has been successfully generated, the routine
--- returns 1 <= len <= n, which is the number of non-zero coefficients
--- in the inequality constraint. Otherwise, the routine returns zero. */
-
-static int lpx_clique_cut(LPX *lp, void *_cog, int ind[], double val[])
-{     struct COG *cog = _cog;
-      int n = lpx_get_num_cols(lp);
-      int j, t, v, card, temp, len = 0, *w, *sol;
-      double x, sum, b, *vec;
-      /* allocate working arrays */
-      w = xcalloc(1 + 2 * cog->nb, sizeof(int));
-      sol = xcalloc(1 + 2 * cog->nb, sizeof(int));
-      vec = xcalloc(1+n, sizeof(double));
-      /* assign weights to vertices of the conflict graph */
-      for (t = 1; t <= cog->nb; t++)
-      {  j = cog->orig[t];
-         x = lpx_get_col_prim(lp, j);
-         temp = (int)(100.0 * x + 0.5);
-         if (temp < 0) temp = 0;
-         if (temp > 100) temp = 100;
-         w[t] = temp;
-         w[cog->nb + t] = 100 - temp;
-      }
-      /* find a clique of maximum weight */
-      card = wclique(2 * cog->nb, w, cog->a, sol);
-      /* compute the clique weight for unscaled values */
-      sum = 0.0;
-      for ( t = 1; t <= card; t++)
-      {  v = sol[t];
-         xassert(1 <= v && v <= 2 * cog->nb);
-         if (v <= cog->nb)
-         {  /* vertex v corresponds to binary variable x[j] */
-            j = cog->orig[v];
-            x = lpx_get_col_prim(lp, j);
-            sum += x;
+      else
+      {  /* xB[p] leaves the basis, xN[q] enters the basis */
+         xassert(1 <= p && p <= m);
+         xassert(1 <= q && q <= n-m);
+         /* determine delta xB[p] */
+         k = head[p]; /* x[k] = xB[p] */
+         if (p_flag)
+         {  /* xB[p] goes to its upper bound */
+            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
+            delta_p = u[k] - beta[p];
+         }
+         else if (l[k] == -DBL_MAX)
+         {  /* unbounded xB[p] becomes non-basic (unusual case) */
+            xassert(u[k] == +DBL_MAX);
+            delta_p = 0.0 - beta[p];
          }
          else
-         {  /* vertex v corresponds to the complement of x[j] */
-            j = cog->orig[v - cog->nb];
-            x = lpx_get_col_prim(lp, j);
-            sum += 1.0 - x;
-         }
-      }
-      /* if the sum of binary variables and their complements in the
-         clique greater than 1, the clique cut is violated */
-      if (sum >= 1.01)
-      {  /* construct the inquality */
-         for (j = 1; j <= n; j++) vec[j] = 0;
-         b = 1.0;
-         for (t = 1; t <= card; t++)
-         {  v = sol[t];
-            if (v <= cog->nb)
-            {  /* vertex v corresponds to binary variable x[j] */
-               j = cog->orig[v];
-               xassert(1 <= j && j <= n);
-               vec[j] += 1.0;
-            }
-            else
-            {  /* vertex v corresponds to the complement of x[j] */
-               j = cog->orig[v - cog->nb];
-               xassert(1 <= j && j <= n);
-               vec[j] -= 1.0;
-               b -= 1.0;
-            }
-         }
-         xassert(len == 0);
-         for (j = 1; j <= n; j++)
-         {  if (vec[j] != 0.0)
-            {  len++;
-               ind[len] = j, val[len] = vec[j];
-            }
-         }
-         ind[0] = 0, val[0] = b;
-      }
-      /* free working arrays */
-      xfree(w);
-      xfree(sol);
-      xfree(vec);
-      /* return to the calling program */
-      return len;
+         {  /* xB[p] goes to its lower bound or becomes fixed */
+            delta_p = l[k] - beta[p];
+         }
+         /* determine delta xN[q] */
+         delta_q = delta_p / vec[p];
+         /* compute new beta[p], which is the value of xN[q] in the
+          * adjacent basis */
+         k = head[m+q]; /* x[k] = xN[q] */
+         if (flag[q])
+         {  /* xN[q] has its upper bound active */
+            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
+            beta[p] = u[k] + delta_q;
+         }
+         else if (l[k] == -DBL_MAX)
+         {  /* xN[q] is non-basic unbounded variable */
+            xassert(u[k] == +DBL_MAX);
+            beta[p] = 0.0 + delta_q;
+         }
+         else
+         {  /* xN[q] has its lower bound active or is fixed (latter
+             * case is unusual) */
+            beta[p] = l[k] + delta_q;
+         }
+      }
+      /* compute new beta[i] for all i != p */
+      for (k = 1; k <= nnz; k++)
+      {  i = ind[k];
+         if (i != p)
+            beta[i] += vec[i] * delta_q;
+      }
+      return;
 }
+#endif
+
+/***********************************************************************
+*  spx_update_d - update reduced costs of non-basic variables
+*
+*  This routine updates the vector d = (d[j]) of reduced costs of
+*  non-basic variables xN = (xN[j]) for the adjacent basis.
+*
+*  On entry to the routine components of the vector d in the current
+*  basis should be placed in locations d[1], ..., d[n-m].
+*
+*  The parameter 1 <= p <= m specifies basic variable xB[p] which
+*  becomes non-basic variable xN[q] in the adjacent basis.
+*
+*  The parameter 1 <= q <= n-m specified non-basic variable xN[q] which
+*  becomes basic variable xB[p] in the adjacent basis.
+*
+*  It is assumed that the array trow contains elements of p-th (pivot)
+*  row T'[p] of the simplex table in locations trow[1], ..., trow[n-m].
+*  It is also assumed that the array tcol contains elements of q-th
+*  (pivot) column T[q] of the simple table in locations tcol[1], ...,
+*  tcol[m]. (These row and column should be computed for the current
+*  basis.)
+*
+*  First, the routine computes more accurate reduced cost d[q] in the
+*  current basis using q-th column of the simplex table:
+*
+*                    n-m
+*     d[q] = cN[q] + sum t[i,q] * cB[i],
+*                    i=1
+*
+*  where cN[q] and cB[i] are objective coefficients at variables xN[q]
+*  and xB[i], resp. The routine also computes the relative error:
+*
+*     e = |d[q] - d'[q]| / (1 + |d[q]|),
+*
+*  where d'[q] is the reduced cost of xN[q] on entry to the routine,
+*  and returns e on exit. (If e happens to be large enough, the calling
+*  program may compute the reduced costs directly, since other reduced
+*  costs also may be inaccurate.)
+*
+*  In the adjacent basis xB[p] becomes xN[q], so:
+*
+*     new d[q] = d[q] / T[p,q],
+*
+*  where T[p,q] is the pivot element of the simplex table (it is taken
+*  from column T[q] as more accurate). Reduced costs of other non-basic
+*  variables xN[j] for 1 <= j <= n-m, j != q, are updated as follows:
+*
+*     new d[j] = d[j] + T[p,j] * new d[q].
+*
+*  On exit the routine stores updated components of the vector d to the
+*  same locations, where the input vector d was stored. */
 
-/*----------------------------------------------------------------------
--- lpx_delete_cog - delete the conflict graph.
---
--- SYNOPSIS
---
--- #include "glplpx.h"
--- void lpx_delete_cog(void *cog);
---
--- DESCRIPTION
---
--- The routine lpx_delete_cog deletes the conflict graph, which the
--- parameter cog points to, freeing all the memory allocated to this
--- object. */
-
-static void lpx_delete_cog(void *_cog)
-{     struct COG *cog = _cog;
-      xfree(cog->vert);
-      xfree(cog->orig);
-      xfree(cog->a);
-      xfree(cog);
-}
-
-/**********************************************************************/
-
-void *ios_clq_init(glp_tree *tree)
-{     /* initialize clique cut generator */
-      glp_prob *mip = tree->mip;
-      xassert(mip != NULL);
-      return lpx_create_cog(mip);
+double spx_update_d(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
+      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      double *c = lp->c;
+      int *head = lp->head;
+      int i, j, k;
+      double dq, e;
+      xassert(1 <= p && p <= m);
+      xassert(1 <= q && q <= n);
+      /* compute d[q] in current basis more accurately */
+      k = head[m+q]; /* x[k] = xN[q] */
+      dq = c[k];
+      for (i = 1; i <= m; i++)
+         dq += tcol[i] * c[head[i]];
+      /* compute relative error in d[q] */
+      e = fabs(dq - d[q]) / (1.0 + fabs(dq));
+      /* compute new d[q], which is the reduced cost of xB[p] in the
+       * adjacent basis */
+      d[q] = (dq /= tcol[p]);
+      /* compute new d[j] for all j != q */
+      for (j = 1; j <= n-m; j++)
+      {  if (j != q)
+            d[j] -= trow[j] * dq;
+      }
+      return e;
+}
+
+#if 1 /* 30/III-2016 */
+double spx_update_d_s(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
+      const FVS *trow, const FVS *tcol)
+{     /* sparse version of spx_update_d */
+      int m = lp->m;
+      int n = lp->n;
+      double *c = lp->c;
+      int *head = lp->head;
+      int trow_nnz = trow->nnz;
+      int *trow_ind = trow->ind;
+      double *trow_vec = trow->vec;
+      int tcol_nnz = tcol->nnz;
+      int *tcol_ind = tcol->ind;
+      double *tcol_vec = tcol->vec;
+      int i, j, k;
+      double dq, e;
+      xassert(1 <= p && p <= m);
+      xassert(1 <= q && q <= n);
+      xassert(trow->n == n-m);
+      xassert(tcol->n == m);
+      /* compute d[q] in current basis more accurately */
+      k = head[m+q]; /* x[k] = xN[q] */
+      dq = c[k];
+      for (k = 1; k <= tcol_nnz; k++)
+      {  i = tcol_ind[k];
+         dq += tcol_vec[i] * c[head[i]];
+      }
+      /* compute relative error in d[q] */
+      e = fabs(dq - d[q]) / (1.0 + fabs(dq));
+      /* compute new d[q], which is the reduced cost of xB[p] in the
+       * adjacent basis */
+      d[q] = (dq /= tcol_vec[p]);
+      /* compute new d[j] for all j != q */
+      for (k = 1; k <= trow_nnz; k++)
+      {  j = trow_ind[k];
+         if (j != q)
+            d[j] -= trow_vec[j] * dq;
+      }
+      return e;
 }
+#endif
 
 /***********************************************************************
-*  NAME
-*
-*  ios_clq_gen - generate clique cuts
-*
-*  SYNOPSIS
-*
-*  #include "glpios.h"
-*  void ios_clq_gen(glp_tree *tree, void *gen);
-*
-*  DESCRIPTION
-*
-*  The routine ios_clq_gen generates clique cuts for the current point
-*  and adds them to the clique pool. */
-
-void ios_clq_gen(glp_tree *tree, void *gen)
-{     int n = lpx_get_num_cols(tree->mip);
-      int len, *ind;
-      double *val;
-      xassert(gen != NULL);
-      ind = xcalloc(1+n, sizeof(int));
-      val = xcalloc(1+n, sizeof(double));
-      len = lpx_clique_cut(tree->mip, gen, ind, val);
-      if (len > 0)
-      {  /* xprintf("len = %d\n", len); */
-         glp_ios_add_row(tree, NULL, GLP_RF_CLQ, 0, len, ind, val,
-            GLP_UP, val[0]);
+*  spx_change_basis - change current basis to adjacent one
+*
+*  This routine changes the current basis to the adjacent one making
+*  necessary changes in lp->head and lp->flag members.
+*
+*  The parameters p, p_flag, and q have the same meaning as for the
+*  routine spx_update_beta. */
+
+void spx_change_basis(SPXLP *lp, int p, int p_flag, int q)
+{     int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      int k;
+      if (p < 0)
+      {  /* special case: xN[q] goes to its opposite bound */
+         xassert(1 <= q && q <= n-m);
+         /* xN[q] should be double-bounded variable */
+         k = head[m+q]; /* x[k] = xN[q] */
+         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);
+         /* change active bound flag */
+         flag[q] = 1 - flag[q];
+      }
+      else
+      {  /* xB[p] leaves the basis, xN[q] enters the basis */
+         xassert(1 <= p && p <= m);
+         xassert(p_flag == 0 || p_flag == 1);
+         xassert(1 <= q && q <= n-m);
+         k = head[p]; /* xB[p] = x[k] */
+         if (p_flag)
+         {  /* xB[p] goes to its upper bound */
+            xassert(l[k] != u[k] && u[k] != +DBL_MAX);
+         }
+         /* swap xB[p] and xN[q] in the basis */
+         head[p] = head[m+q], head[m+q] = k;
+         /* and set active bound flag for new xN[q] */
+         lp->flag[q] = p_flag;
       }
-      xfree(ind);
-      xfree(val);
       return;
 }
 
-/**********************************************************************/
-
-void ios_clq_term(void *gen)
-{     /* terminate clique cut generator */
-      xassert(gen != NULL);
-      lpx_delete_cog(gen);
-      return;
+/***********************************************************************
+*  spx_update_invb - update factorization of basis matrix
+*
+*  This routine updates factorization of the basis matrix B when i-th
+*  column of B is replaced by k-th column of the constraint matrix A.
+*
+*  The parameter 1 <= i <= m specifies the number of column of matrix B
+*  to be replaced by a new column.
+*
+*  The parameter 1 <= k <= n specifies the number of column of matrix A
+*  to be used for replacement.
+*
+*  If the factorization has been successfully updated, the routine
+*  validates it and returns zero. Otherwise, the routine invalidates
+*  the factorization and returns the code provided by the factorization
+*  driver (bfd_update). */
+
+int spx_update_invb(SPXLP *lp, int i, int k)
+{     int m = lp->m;
+      int n = lp->n;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      double *A_val = lp->A_val;
+      int ptr, len, ret;
+      xassert(1 <= i && i <= m);
+      xassert(1 <= k && k <= n);
+      ptr = A_ptr[k];
+      len = A_ptr[k+1] - ptr;
+      ret = bfd_update(lp->bfd, i, len, &A_ind[ptr-1], &A_val[ptr-1]);
+      lp->valid = (ret == 0);
+      return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios09.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios09.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpios09.c (branching heuristics) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2005-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,21 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#pragma clang diagnostic ignored "-Wpointer-sign"
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#endif
-
-#include "glpios.h"
+#include "env.h"
+#include "ios.h"
 
 /***********************************************************************
 *  NAME
 *
 *  ios_choose_var - select variable to branch on
 *
 *  SYNOPSIS
@@ -196,15 +188,15 @@
 *  one-step degradation (see the routine below) requires one BTRAN for
 *  each fractional-valued structural variable. */
 
 static int branch_drtom(glp_tree *T, int *_next)
 {     glp_prob *mip = T->mip;
       int m = mip->m;
       int n = mip->n;
-      char *non_int = T->non_int;
+      unsigned char *non_int = T->non_int;
       int j, jj, k, t, next, kase, len, stat, *ind;
       double x, dk, alfa, delta_j, delta_k, delta_z, dz_dn, dz_up,
          dd_dn, dd_up, degrad, *val;
       /* basic solution of LP relaxation must be optimal */
       xassert(glp_get_status(mip) == GLP_OPT);
       /* allocate working arrays */
       ind = xcalloc(1+n, sizeof(int));
@@ -375,20 +367,20 @@
 #endif
       if (T->parm->msg_lev >= GLP_MSG_DBG)
       {  xprintf("branch_drtom: column %d chosen to branch on\n", jj);
          if (fabs(dd_dn) == DBL_MAX)
             xprintf("branch_drtom: down-branch is infeasible\n");
          else
             xprintf("branch_drtom: down-branch bound is %.9e\n",
-               lpx_get_obj_val(mip) + dd_dn);
+               glp_get_obj_val(mip) + dd_dn);
          if (fabs(dd_up) == DBL_MAX)
             xprintf("branch_drtom: up-branch   is infeasible\n");
          else
             xprintf("branch_drtom: up-branch   bound is %.9e\n",
-               lpx_get_obj_val(mip) + dd_up);
+               glp_get_obj_val(mip) + dd_up);
       }
 done: *_next = next;
       return jj;
 }
 
 /**********************************************************************/
 
@@ -598,15 +590,19 @@
       xprintf("Pseudocosts initialized for %d of %d variables\n",
          ni, nv);
       return;
 }
 
 int ios_pcost_branch(glp_tree *T, int *_next)
 {     /* choose branching variable with pseudocost branching */
+#if 0 /* 10/VI-2013 */
       glp_long t = xtime();
+#else
+      double t = xtime();
+#endif
       int j, jjj, sel;
       double beta, psi, d1, d2, d, dmax;
       /* initialize the working arrays */
       if (T->pcost == NULL)
          T->pcost = ios_pcost_init(T);
       /* nothing has been chosen so far */
       jjj = 0, dmax = -1.0;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios10.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/intopt/fpump.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios10.c (feasibility pump heuristic) */
+/* fpump.c (feasibility pump heuristic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,21 +15,17 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpios.h"
-#include "glprng.h"
+#include "env.h"
+#include "ios.h"
+#include "rng.h"
 
 /***********************************************************************
 *  NAME
 *
 *  ios_feas_pump - feasibility pump heuristic
 *
 *  SYNOPSIS
@@ -56,15 +49,15 @@
       /* ordinal number */
       int x;
       /* value in the rounded solution (0 or 1) */
       double d;
       /* sorting key */
 };
 
-static int fcmp(const void *x, const void *y)
+static int CDECL fcmp(const void *x, const void *y)
 {     /* comparison routine */
       const struct VAR *vx = x, *vy = y;
       if (vx->d > vy->d)
          return -1;
       else if (vx->d < vy->d)
          return +1;
       else
@@ -289,32 +282,44 @@
          }
 #if 1 /* modified by xypron <xypron.glpk@gmx.de> */
          /* reset direction and right-hand side of objective */
          lp->c0  = P->c0;
          lp->dir = P->dir;
          /* fix integer variables */
          for (k = 1; k <= nv; k++)
+#if 0 /* 18/VI-2013; fixed by mao
+       * this bug causes numerical instability, because column statuses
+       * are not changed appropriately */
          {  lp->col[var[k].j]->lb   = x[var[k].j];
             lp->col[var[k].j]->ub   = x[var[k].j];
             lp->col[var[k].j]->type = GLP_FX;
          }
+#else
+            glp_set_col_bnds(lp, var[k].j, GLP_FX, x[var[k].j], 0.);
+#endif
          /* copy original objective function */
          for (j = 1; j <= n; j++)
             lp->col[j]->coef = P->col[j]->coef;
          /* solve original LP and copy result */
          ret = glp_simplex(lp, &parm);
          if (ret != 0)
          {  if (T->parm->msg_lev >= GLP_MSG_ERR)
                xprintf("Warning: glp_simplex returned %d\n", ret);
+#if 1 /* 17/III-2016: fix memory leak */
+            xfree(x);
+#endif
             goto done;
          }
          ret = glp_get_status(lp);
          if (ret != GLP_OPT)
          {  if (T->parm->msg_lev >= GLP_MSG_ERR)
                xprintf("Warning: glp_get_status returned %d\n", ret);
+#if 1 /* 17/III-2016: fix memory leak */
+            xfree(x);
+#endif
             goto done;
          }
          for (j = 1; j <= n; j++)
             if (P->col[j]->kind != GLP_IV) x[j] = lp->col[j]->prim;
 #endif
          ret = glp_ios_heur_sol(T, x);
          xfree(x);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios11.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/wclique1.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpios11.c (process cuts stored in the local cut pool) */
+/* wclique1.c (maximum weight clique, greedy heuristic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2012-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,267 +15,301 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpios.h"
+#include "env.h"
+#include "wclique1.h"
 
 /***********************************************************************
 *  NAME
 *
-*  ios_process_cuts - process cuts stored in the local cut pool
+*  wclique1 - find maximum weight clique with greedy heuristic
 *
 *  SYNOPSIS
 *
-*  #include "glpios.h"
-*  void ios_process_cuts(glp_tree *T);
+*  #include "wclique1.h"
+*  int wclique1(int n, const double w[],
+*     int (*func)(void *info, int i, int ind[]), void *info, int c[]);
 *
 *  DESCRIPTION
 *
-*  The routine ios_process_cuts analyzes each cut currently stored in
-*  the local cut pool, which must be non-empty, and either adds the cut
-*  to the current subproblem or just discards it. All cuts are assumed
-*  to be locally valid. On exit the local cut pool remains unchanged.
-*
-*  REFERENCES
-*
-*  1. E.Balas, S.Ceria, G.Cornuejols, "Mixed 0-1 Programming by
-*     Lift-and-Project in a Branch-and-Cut Framework", Management Sc.,
-*     42 (1996) 1229-1246.
-*
-*  2. G.Andreello, A.Caprara, and M.Fischetti, "Embedding Cuts in
-*     a Branch&Cut Framework: a Computational Study with {0,1/2}-Cuts",
-*     Preliminary Draft, October 28, 2003, pp.6-8. */
-
-struct info
-{     /* estimated cut efficiency */
-      IOSCUT *cut;
-      /* pointer to cut in the cut pool */
-      char flag;
-      /* if this flag is set, the cut is included into the current
-         subproblem */
-      double eff;
-      /* cut efficacy (normalized residual) */
-      double deg;
-      /* lower bound to objective degradation */
-};
-
-static int fcmp(const void *arg1, const void *arg2)
-{     const struct info *info1 = arg1, *info2 = arg2;
-      if (info1->deg == 0.0 && info2->deg == 0.0)
-      {  if (info1->eff > info2->eff) return -1;
-         if (info1->eff < info2->eff) return +1;
-      }
-      else
-      {  if (info1->deg > info2->deg) return -1;
-         if (info1->deg < info2->deg) return +1;
-      }
+*  The routine wclique1 implements a sequential greedy heuristic to
+*  find maximum weight clique in a given (undirected) graph G = (V, E).
+*
+*  The parameter n specifies the number of vertices |V| in the graph,
+*  n >= 0.
+*
+*  The array w specifies vertex weights in locations w[i], i = 1,...,n.
+*  All weights must be non-negative.
+*
+*  The formal routine func specifies the graph. For a given vertex i,
+*  1 <= i <= n, it stores indices of all vertices adjacent to vertex i
+*  in locations ind[1], ..., ind[deg], where deg is the degree of
+*  vertex i, 0 <= deg < n, returned on exit. Note that self-loops and
+*  multiple edges are not allowed.
+*
+*  The parameter info is a cookie passed to the routine func.
+*
+*  On exit the routine wclique1 stores vertex indices included in
+*  the clique found to locations c[1], ..., c[size], where size is the
+*  clique size returned by the routine, 0 <= size <= n.
+*
+*  RETURNS
+*
+*  The routine wclique1 returns the size of the clique found. */
+
+struct vertex { int i; double cw; };
+
+static int CDECL fcmp(const void *xx, const void *yy)
+{     const struct vertex *x = xx, *y = yy;
+      if (x->cw > y->cw) return -1;
+      if (x->cw < y->cw) return +1;
       return 0;
 }
 
-static double parallel(IOSCUT *a, IOSCUT *b, double work[]);
-
-void ios_process_cuts(glp_tree *T)
-{     IOSPOOL *pool;
-      IOSCUT *cut;
-      IOSAIJ *aij;
-      struct info *info;
-      int k, kk, max_cuts, len, ret, *ind;
-      double *val, *work;
-      /* the current subproblem must exist */
-      xassert(T->curr != NULL);
-      /* the pool must exist and be non-empty */
-      pool = T->local;
-      xassert(pool != NULL);
-      xassert(pool->size > 0);
+int wclique1(int n, const double w[],
+      int (*func)(void *info, int i, int ind[]), void *info, int c[])
+{     struct vertex *v_list;
+      int deg, c_size, d_size, i, j, k, kk, l, *ind, *c_list, *d_list,
+         size = 0;
+      double c_wght, d_wght, *sw, best = 0.0;
+      char *d_flag, *skip;
+      /* perform sanity checks */
+      xassert(n >= 0);
+      for (i = 1; i <= n; i++)
+         xassert(w[i] >= 0.0);
+      /* if the graph is empty, nothing to do */
+      if (n == 0) goto done;
       /* allocate working arrays */
-      info = xcalloc(1+pool->size, sizeof(struct info));
-      ind = xcalloc(1+T->n, sizeof(int));
-      val = xcalloc(1+T->n, sizeof(double));
-      work = xcalloc(1+T->n, sizeof(double));
-      for (k = 1; k <= T->n; k++) work[k] = 0.0;
-      /* build the list of cuts stored in the cut pool */
-      for (k = 0, cut = pool->head; cut != NULL; cut = cut->next)
-         k++, info[k].cut = cut, info[k].flag = 0;
-      xassert(k == pool->size);
-      /* estimate efficiency of all cuts in the cut pool */
-      for (k = 1; k <= pool->size; k++)
-      {  double temp, dy, dz;
-         cut = info[k].cut;
-         /* build the vector of cut coefficients and compute its
-            Euclidean norm */
-         len = 0; temp = 0.0;
-         for (aij = cut->ptr; aij != NULL; aij = aij->next)
-         {  xassert(1 <= aij->j && aij->j <= T->n);
-            len++, ind[len] = aij->j, val[len] = aij->val;
-            temp += aij->val * aij->val;
+      ind = xcalloc(1+n, sizeof(int));
+      v_list = xcalloc(1+n, sizeof(struct vertex));
+      c_list = xcalloc(1+n, sizeof(int));
+      d_list = xcalloc(1+n, sizeof(int));
+      d_flag = xcalloc(1+n, sizeof(char));
+      skip = xcalloc(1+n, sizeof(char));
+      sw = xcalloc(1+n, sizeof(double));
+      /* build the vertex list */
+      for (i = 1; i <= n; i++)
+      {  v_list[i].i = i;
+         /* compute the cumulative weight of each vertex i, which is
+          * cw[i] = w[i] + sum{j : (i,j) in E} w[j] */
+         v_list[i].cw = w[i];
+         deg = func(info, i, ind);
+         xassert(0 <= deg && deg < n);
+         for (k = 1; k <= deg; k++)
+         {  j = ind[k];
+            xassert(1 <= j && j <= n && j != i);
+            v_list[i].cw += w[j];
          }
-         if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;
-         /* transform the cut to express it only through non-basic
-            (auxiliary and structural) variables */
-         len = glp_transform_row(T->mip, len, ind, val);
-         /* determine change in the cut value and in the objective
-            value for the adjacent basis by simulating one step of the
-            dual simplex */
-         ret = _glp_analyze_row(T->mip, len, ind, val, cut->type,
-            cut->rhs, 1e-9, NULL, NULL, NULL, NULL, &dy, &dz);
-         /* determine normalized residual and lower bound to objective
-            degradation */
-         if (ret == 0)
-         {  info[k].eff = fabs(dy) / sqrt(temp);
-            /* if some reduced costs violates (slightly) their zero
-               bounds (i.e. have wrong signs) due to round-off errors,
-               dz also may have wrong sign being close to zero */
-            if (T->mip->dir == GLP_MIN)
-            {  if (dz < 0.0) dz = 0.0;
-               info[k].deg = + dz;
-            }
-            else /* GLP_MAX */
-            {  if (dz > 0.0) dz = 0.0;
-               info[k].deg = - dz;
-            }
+      }
+      /* sort the vertex list to access vertices in descending order of
+       * cumulative weights */
+      qsort(&v_list[1], n, sizeof(struct vertex), fcmp);
+      /* initially all vertices are unmarked */
+      memset(&skip[1], 0, sizeof(char) * n);
+      /* clear flags of all vertices */
+      memset(&d_flag[1], 0, sizeof(char) * n);
+      /* look through all vertices of the graph */
+      for (l = 1; l <= n; l++)
+      {  /* take vertex i */
+         i = v_list[l].i;
+         /* if this vertex was already included in one of previosuly
+          * constructed cliques, skip it */
+         if (skip[i]) continue;
+         /* use vertex i as the initial clique vertex */
+         c_size = 1;    /* size of current clique */
+         c_list[1] = i; /* list of vertices in current clique */
+         c_wght = w[i]; /* weight of current clique */
+         /* determine the candidate set D = { j : (i,j) in E } */
+         d_size = func(info, i, d_list);
+         xassert(0 <= d_size && d_size < n);
+         d_wght = 0.0;  /* weight of set D */
+         for (k = 1; k <= d_size; k++)
+         {  j = d_list[k];
+            xassert(1 <= j && j <= n && j != i);
+            xassert(!d_flag[j]);
+            d_flag[j] = 1;
+            d_wght += w[j];
          }
-         else if (ret == 1)
-         {  /* the constraint is not violated at the current point */
-            info[k].eff = info[k].deg = 0.0;
+         /* check an upper bound to the final clique weight */
+         if (c_wght + d_wght < best + 1e-5 * (1.0 + fabs(best)))
+         {  /* skip constructing the current clique */
+            goto next;
          }
-         else if (ret == 2)
-         {  /* no dual feasible adjacent basis exists */
-            info[k].eff = 1.0;
-            info[k].deg = DBL_MAX;
+         /* compute the summary weight of each vertex i in D, which is
+          * sw[i] = w[i] + sum{j in D and (i,j) in E} w[j] */
+         for (k = 1; k <= d_size; k++)
+         {  i = d_list[k];
+            sw[i] = w[i];
+            /* consider vertices adjacent to vertex i */
+            deg = func(info, i, ind);
+            xassert(0 <= deg && deg < n);
+            for (kk = 1; kk <= deg; kk++)
+            {  j = ind[kk];
+               xassert(1 <= j && j <= n && j != i);
+               if (d_flag[j]) sw[i] += w[j];
+            }
          }
-         else
-            xassert(ret != ret);
-         /* if the degradation is too small, just ignore it */
-         if (info[k].deg < 0.01) info[k].deg = 0.0;
-      }
-      /* sort the list of cuts by decreasing objective degradation and
-         then by decreasing efficacy */
-      qsort(&info[1], pool->size, sizeof(struct info), fcmp);
-      /* only first (most efficient) max_cuts in the list are qualified
-         as candidates to be added to the current subproblem */
-      max_cuts = (T->curr->level == 0 ? 90 : 10);
-      if (max_cuts > pool->size) max_cuts = pool->size;
-      /* add cuts to the current subproblem */
-#if 0
-      xprintf("*** adding cuts ***\n");
-#endif
-      for (k = 1; k <= max_cuts; k++)
-      {  int i, len;
-         /* if this cut seems to be inefficient, skip it */
-         if (info[k].deg < 0.01 && info[k].eff < 0.01) continue;
-         /* if the angle between this cut and every other cut included
-            in the current subproblem is small, skip this cut */
-         for (kk = 1; kk < k; kk++)
-         {  if (info[kk].flag)
-            {  if (parallel(info[k].cut, info[kk].cut, work) > 0.90)
-                  break;
+         /* grow the current clique by adding vertices from D */
+         while (d_size > 0)
+         {  /* check an upper bound to the final clique weight */
+            if (c_wght + d_wght < best + 1e-5 * (1.0 + fabs(best)))
+            {  /* skip constructing the current clique */
+               goto next;
+            }
+            /* choose vertex i in D having maximal summary weight */
+            i = d_list[1];
+            for (k = 2; k <= d_size; k++)
+            {  j = d_list[k];
+               if (sw[i] < sw[j]) i = j;
+            }
+            /* include vertex i in the current clique */
+            c_size++;
+            c_list[c_size] = i;
+            c_wght += w[i];
+            /* remove all vertices not adjacent to vertex i, including
+             * vertex i itself, from the candidate set D */
+            deg = func(info, i, ind);
+            xassert(0 <= deg && deg < n);
+            for (k = 1; k <= deg; k++)
+            {  j = ind[k];
+               xassert(1 <= j && j <= n && j != i);
+               /* vertex j is adjacent to vertex i */
+               if (d_flag[j])
+               {  xassert(d_flag[j] == 1);
+                  /* mark vertex j to keep it in D */
+                  d_flag[j] = 2;
+               }
+            }
+            kk = d_size, d_size = 0;
+            for (k = 1; k <= kk; k++)
+            {  j = d_list[k];
+               if (d_flag[j] == 1)
+               {  /* remove vertex j from D */
+                  d_flag[j] = 0;
+                  d_wght -= w[j];
+               }
+               else if (d_flag[j] == 2)
+               {  /* keep vertex j in D */
+                  d_list[++d_size] = j;
+                  d_flag[j] = 1;
+               }
+               else
+                  xassert(d_flag != d_flag);
             }
          }
-         if (kk < k) continue;
-         /* add this cut to the current subproblem */
-#if 0
-         xprintf("eff = %g; deg = %g\n", info[k].eff, info[k].deg);
-#endif
-         cut = info[k].cut, info[k].flag = 1;
-         i = glp_add_rows(T->mip, 1);
-         if (cut->name != NULL)
-            glp_set_row_name(T->mip, i, cut->name);
-         xassert(T->mip->row[i]->origin == GLP_RF_CUT);
-         T->mip->row[i]->klass = cut->klass;
-         len = 0;
-         for (aij = cut->ptr; aij != NULL; aij = aij->next)
-            len++, ind[len] = aij->j, val[len] = aij->val;
-         glp_set_mat_row(T->mip, i, len, ind, val);
-         xassert(cut->type == GLP_LO || cut->type == GLP_UP);
-         glp_set_row_bnds(T->mip, i, cut->type, cut->rhs, cut->rhs);
+         /* the current clique has been completely constructed */
+         if (best < c_wght)
+         {  best = c_wght;
+            size = c_size;
+            xassert(1 <= size && size <= n);
+            memcpy(&c[1], &c_list[1], size * sizeof(int));
+         }
+next:    /* mark the current clique vertices in order not to use them
+          * as initial vertices anymore */
+         for (k = 1; k <= c_size; k++)
+            skip[c_list[k]] = 1;
+         /* set D can be non-empty, so clean up vertex flags */
+         for (k = 1; k <= d_size; k++)
+            d_flag[d_list[k]] = 0;
       }
       /* free working arrays */
-      xfree(info);
       xfree(ind);
-      xfree(val);
-      xfree(work);
-      return;
+      xfree(v_list);
+      xfree(c_list);
+      xfree(d_list);
+      xfree(d_flag);
+      xfree(skip);
+      xfree(sw);
+done: /* return to the calling program */
+      return size;
 }
 
-#if 0
-/***********************************************************************
-*  Given a cut a * x >= b (<= b) the routine efficacy computes the cut
-*  efficacy as follows:
-*
-*     eff = d * (a * x~ - b) / ||a||,
-*
-*  where d is -1 (in case of '>= b') or +1 (in case of '<= b'), x~ is
-*  the vector of values of structural variables in optimal solution to
-*  LP relaxation of the current subproblem, ||a|| is the Euclidean norm
-*  of the vector of cut coefficients.
-*
-*  If the cut is violated at point x~, the efficacy eff is positive,
-*  and its value is the Euclidean distance between x~ and the cut plane
-*  a * x = b in the space of structural variables.
-*
-*  Following geometrical intuition, it is quite natural to consider
-*  this distance as a first-order measure of the expected efficacy of
-*  the cut: the larger the distance the better the cut [1]. */
-
-static double efficacy(glp_tree *T, IOSCUT *cut)
-{     glp_prob *mip = T->mip;
-      IOSAIJ *aij;
-      double s = 0.0, t = 0.0, temp;
-      for (aij = cut->ptr; aij != NULL; aij = aij->next)
-      {  xassert(1 <= aij->j && aij->j <= mip->n);
-         s += aij->val * mip->col[aij->j]->prim;
-         t += aij->val * aij->val;
+/**********************************************************************/
+
+#ifdef GLP_TEST
+#include "glpk.h"
+#include "rng.h"
+
+typedef struct { double w; } v_data;
+
+#define weight(v) (((v_data *)((v)->data))->w)
+
+glp_graph *G;
+
+char *flag;
+
+int func(void *info, int i, int ind[])
+{     glp_arc *e;
+      int j, k, deg = 0;
+      xassert(info == NULL);
+      xassert(1 <= i && i <= G->nv);
+      /* look through incoming arcs */
+      for (e = G->v[i]->in; e != NULL; e = e->h_next)
+      {  j = e->tail->i; /* j->i */
+         if (j != i && !flag[j]) ind[++deg] = j, flag[j] = 1;
       }
-      temp = sqrt(t);
-      if (temp < DBL_EPSILON) temp = DBL_EPSILON;
-      if (cut->type == GLP_LO)
-         temp = (s >= cut->rhs ? 0.0 : (cut->rhs - s) / temp);
-      else if (cut->type == GLP_UP)
-         temp = (s <= cut->rhs ? 0.0 : (s - cut->rhs) / temp);
-      else
-         xassert(cut != cut);
-      return temp;
+      /* look through outgoing arcs */
+      for (e = G->v[i]->out; e != NULL; e = e->t_next)
+      {  j = e->head->i; /* i->j */
+         if (j != i && !flag[j]) ind[++deg] = j, flag[j] = 1;
+      }
+      /* clear the flag array */
+      xassert(deg < G->nv);
+      for (k = 1; k <= deg; k++) flag[ind[k]] = 0;
+      return deg;
 }
-#endif
 
-/***********************************************************************
-*  Given two cuts a1 * x >= b1 (<= b1) and a2 * x >= b2 (<= b2) the
-*  routine parallel computes the cosine of angle between the cut planes
-*  a1 * x = b1 and a2 * x = b2 (which is the acute angle between two
-*  normals to these planes) in the space of structural variables as
-*  follows:
-*
-*     cos phi = (a1' * a2) / (||a1|| * ||a2||),
-*
-*  where (a1' * a2) is a dot product of vectors of cut coefficients,
-*  ||a1|| and ||a2|| are Euclidean norms of vectors a1 and a2.
-*
-*  Note that requirement cos phi = 0 forces the cuts to be orthogonal,
-*  i.e. with disjoint support, while requirement cos phi <= 0.999 means
-*  only avoiding duplicate (parallel) cuts [1]. */
-
-static double parallel(IOSCUT *a, IOSCUT *b, double work[])
-{     IOSAIJ *aij;
-      double s = 0.0, sa = 0.0, sb = 0.0, temp;
-      for (aij = a->ptr; aij != NULL; aij = aij->next)
-      {  work[aij->j] = aij->val;
-         sa += aij->val * aij->val;
-      }
-      for (aij = b->ptr; aij != NULL; aij = aij->next)
-      {  s += work[aij->j] * aij->val;
-         sb += aij->val * aij->val;
+int main(int argc, char *argv[])
+{     RNG *rand;
+      int i, k, kk, size, *c, *ind, deg;
+      double *w, sum, t;
+      /* read graph in DIMACS format */
+      G = glp_create_graph(sizeof(v_data), 0);
+      xassert(argc == 2);
+      xassert(glp_read_ccdata(G, offsetof(v_data, w), argv[1]) == 0);
+      /* print the number of connected components */
+      xprintf("nc = %d\n", glp_weak_comp(G, -1));
+      /* assign random weights unformly distributed in [1,100] */
+      w = xcalloc(1+G->nv, sizeof(double));
+      rand = rng_create_rand();
+      for (i = 1; i <= G->nv; i++)
+#if 0
+         w[i] = weight(G->v[i]) = 1.0;
+#else
+         w[i] = weight(G->v[i]) = rng_unif_rand(rand, 100) + 1;
+#endif
+      /* write graph in DIMACS format */
+      xassert(glp_write_ccdata(G, offsetof(v_data, w), "graph") == 0);
+      /* find maximum weight clique */
+      c = xcalloc(1+G->nv, sizeof(int));
+      flag = xcalloc(1+G->nv, sizeof(char));
+      memset(&flag[1], 0, G->nv);
+      t = xtime();
+      size = wclique1(G->nv, w, func, NULL, c);
+      xprintf("Time used: %.1f s\n", xdifftime(xtime(), t));
+      /* check the clique found */
+      ind = xcalloc(1+G->nv, sizeof(int));
+      for (k = 1; k <= size; k++)
+      {  i = c[k];
+         deg = func(NULL, i, ind);
+         for (kk = 1; kk <= size; kk++)
+            flag[c[kk]] = 1;
+         flag[i] = 0;
+         for (kk = 1; kk <= deg; kk++)
+            flag[ind[kk]] = 0;
+         for (kk = 1; kk <= size; kk++)
+            xassert(flag[c[kk]] == 0);
       }
-      for (aij = a->ptr; aij != NULL; aij = aij->next)
-         work[aij->j] = 0.0;
-      temp = sqrt(sa) * sqrt(sb);
-      if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;
-      return s / temp;
+      /* compute the clique weight */
+      sum = 0.0;
+      for (i = 1; i <= size; i++)
+         sum += w[c[i]];
+      xprintf("size = %d; sum = %g\n", size, sum);
+      return 0;
 }
+#endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpios12.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpios12.c`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpios12.c (node selection heuristics) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,19 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#include "glpios.h"
+#include "env.h"
+#include "ios.h"
 
 /***********************************************************************
 *  NAME
 *
 *  ios_choose_node - select subproblem to continue the search
 *
 *  SYNOPSIS
@@ -135,15 +129,15 @@
       double bound, eps;
       switch (T->mip->dir)
       {  case GLP_MIN:
             bound = +DBL_MAX;
             for (node = T->head; node != NULL; node = node->next)
                if (bound > node->bound) bound = node->bound;
             xassert(bound != +DBL_MAX);
-            eps = 0.001 * (1.0 + fabs(bound));
+            eps = 1e-10 * (1.0 + fabs(bound));
             for (node = T->head; node != NULL; node = node->next)
             {  if (node->bound <= bound + eps)
                {  xassert(node->up != NULL);
                   if (best == NULL ||
 #if 1
                   best->up->ii_sum > node->up->ii_sum) best = node;
 #else
@@ -153,15 +147,15 @@
             }
             break;
          case GLP_MAX:
             bound = -DBL_MAX;
             for (node = T->head; node != NULL; node = node->next)
                if (bound < node->bound) bound = node->bound;
             xassert(bound != -DBL_MAX);
-            eps = 0.001 * (1.0 + fabs(bound));
+            eps = 1e-10 * (1.0 + fabs(bound));
             for (node = T->head; node != NULL; node = node->next)
             {  if (node->bound >= bound - eps)
                {  xassert(node->up != NULL);
                   if (best == NULL ||
 #if 1
                   best->up->ii_sum > node->up->ii_sum) best = node;
 #else
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpipm.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpipm.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpipm.h (primal-dual interior-point method) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -21,15 +18,15 @@
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
 #ifndef GLPIPM_H
 #define GLPIPM_H
 
-#include "glpapi.h"
+#include "prob.h"
 
 #define ipm_solve _glp_ipm_solve
 int ipm_solve(glp_prob *P, const glp_iptcp *parm);
 /* core LP solver based on the interior-point method */
 
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplib01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/bignum.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glplib01.c (bignum arithmetic) */
+/* bignum.c (bignum arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2006-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,61 +15,61 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpenv.h"
-#include "glplib.h"
+#include "env.h"
+#include "bignum.h"
 
 /***********************************************************************
 *  Two routines below are intended to multiply and divide unsigned
 *  integer numbers of arbitrary precision.
-* 
+*
 *  The routines assume that an unsigned integer number is represented in
 *  the positional numeral system with the base 2^16 = 65536, i.e. each
 *  "digit" of the number is in the range [0, 65535] and represented as
 *  a 16-bit value of the unsigned short type. In other words, a number x
 *  has the following representation:
-* 
+*
 *         n-1
 *     x = sum d[j] * 65536^j,
 *         j=0
-* 
+*
 *  where n is the number of places (positions), and d[j] is j-th "digit"
 *  of x, 0 <= d[j] <= 65535.
 ***********************************************************************/
 
 /***********************************************************************
 *  NAME
 *
 *  bigmul - multiply unsigned integer numbers of arbitrary precision
-* 
+*
 *  SYNOPSIS
-* 
-*  #include "glplib.h"
+*
+*  #include "bignum.h"
 *  void bigmul(int n, int m, unsigned short x[], unsigned short y[]);
-* 
+*
 *  DESCRIPTION
-* 
+*
 *  The routine bigmul multiplies unsigned integer numbers of arbitrary
 *  precision.
-* 
+*
 *  n is the number of digits of multiplicand, n >= 1;
-* 
+*
 *  m is the number of digits of multiplier, m >= 1;
-* 
+*
 *  x is an array containing digits of the multiplicand in elements
 *  x[m], x[m+1], ..., x[n+m-1]. Contents of x[0], x[1], ..., x[m-1] are
 *  ignored on entry.
-* 
+*
 *  y is an array containing digits of the multiplier in elements y[0],
 *  y[1], ..., y[m-1].
-* 
+*
 *  On exit digits of the product are stored in elements x[0], x[1], ...,
 *  x[n+m-1]. The array y is not changed. */
 
 void bigmul(int n, int m, unsigned short x[], unsigned short y[])
 {     int i, j;
       unsigned int t;
       xassert(n >= 1);
@@ -93,36 +90,36 @@
       return;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  bigdiv - divide unsigned integer numbers of arbitrary precision
-* 
+*
 *  SYNOPSIS
-* 
-*  #include "glplib.h"
+*
+*  #include "bignum.h"
 *  void bigdiv(int n, int m, unsigned short x[], unsigned short y[]);
-* 
+*
 *  DESCRIPTION
-* 
+*
 *  The routine bigdiv divides one unsigned integer number of arbitrary
 *  precision by another with the algorithm described in [1].
-* 
+*
 *  n is the difference between the number of digits of dividend and the
 *  number of digits of divisor, n >= 0.
-* 
+*
 *  m is the number of digits of divisor, m >= 1.
-* 
+*
 *  x is an array containing digits of the dividend in elements x[0],
 *  x[1], ..., x[n+m-1].
-* 
+*
 *  y is an array containing digits of the divisor in elements y[0],
 *  y[1], ..., y[m-1]. The highest digit y[m-1] must be non-zero.
-* 
+*
 *  On exit n+1 digits of the quotient are stored in elements x[m],
 *  x[m+1], ..., x[n+m], and m digits of the remainder are stored in
 *  elements x[0], x[1], ..., x[m-1]. The array y is changed but then
 *  restored.
 *
 *  REFERENCES
 *
@@ -144,15 +141,15 @@
             x[i+1] = (unsigned short)(t / y[0]);
             d = (unsigned short)(t % y[0]);
          }
          x[0] = d;
          goto done;
       }
       /* multiply dividend and divisor by a normalizing coefficient in
-         order to provide the condition y[m-1] >= base / 2 */
+       * order to provide the condition y[m-1] >= base / 2 */
       d = (unsigned short)(0x10000 / ((unsigned int)y[m-1] + 1));
       if (d == 1)
          x[n+m] = 0;
       else
       {  t = 0;
          for (i = 0; i < n+m; i++)
          {  t += (unsigned int)x[i] * (unsigned int)d;
@@ -183,38 +180,38 @@
          r = (unsigned short)t;
          if (t > 0xFFFF) goto msub;
 test:    t = (unsigned int)y[m-2] * (unsigned int)q;
          if ((unsigned short)(t >> 16) > r) goto decr;
          if ((unsigned short)(t >> 16) < r) goto msub;
          if ((unsigned short)t > x[i+m-2]) goto decr;
 msub:    /* now subtract divisor multiplied by the current digit of
-            quotient from the current dividend */
+          * quotient from the current dividend */
          if (q == 0) goto putq;
          t = 0;
          for (j = 0; j < m; j++)
          {  t += (unsigned int)y[j] * (unsigned int)q;
             if (x[i+j] < (unsigned short)t) t += 0x10000;
             x[i+j] -= (unsigned short)t;
             t >>= 16;
          }
          if (x[i+m] >= (unsigned short)t) goto putq;
          /* perform correcting addition, because the current digit of
-            quotient is greater by one than its correct value */
+          * quotient is greater by one than its correct value */
          q--;
          t = 0;
          for (j = 0; j < m; j++)
          {  t += (unsigned int)x[i+j] + (unsigned int)y[j];
             x[i+j] = (unsigned short)t;
             t >>= 16;
          }
 putq:    /* store the current digit of quotient */
          x[i+m] = q;
       }
       /* divide divisor and remainder by the normalizing coefficient in
-         order to restore their original values */
+       * order to restore their original values */
       if (d > 1)
       {  t = 0;
          for (i = m-1; i >= 0; i--)
          {  t = (t << 16) + (unsigned int)x[i];
             x[i] = (unsigned short)(t / (unsigned int)d);
             t %= (unsigned int)d;
          }
@@ -226,19 +223,19 @@
          }
       }
 done: return;
 }
 
 /**********************************************************************/
 
-#if 0
+#ifdef GLP_TEST
 #include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include "glprng.h"
+#include "rng.h"
 
 #define N_MAX 7
 /* maximal number of digits in multiplicand */
 
 #define M_MAX 5
 /* maximal number of digits in multiplier */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplib03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/ks.c`

 * *Files 25% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glplib03.c (miscellaneous library routines) */
+/* ks.c (0-1 knapsack problem) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2017-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,679 +15,450 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#endif
-
-#include "glpenv.h"
-#include "glplib.h"
+#include "env.h"
+#include "ks.h"
+#include "mt1.h"
 
 /***********************************************************************
-*  NAME
-*
-*  str2int - convert character string to value of int type
-*
-*  SYNOPSIS
+*  0-1 knapsack problem has the following formulation:
 *
-*  #include "glplib.h"
-*  int str2int(const char *str, int *val);
+*     maximize z = sum{j in 1..n} c[j]x[j]                           (1)
 *
-*  DESCRIPTION
+*         s.t. sum{j in 1..n} a[j]x[j] <= b                          (2)
 *
-*  The routine str2int converts the character string str to a value of
-*  integer type and stores the value into location, which the parameter
-*  val points to (in the case of error content of this location is not
-*  changed).
+*              x[j] in {0, 1} for all j in 1..n                      (3)
 *
-*  RETURNS
+*  In general case it is assumed that the instance is non-normalized,
+*  i.e. parameters a, b, and c may have any sign.
+***********************************************************************/
+
+/***********************************************************************
+*  ks_enum - solve 0-1 knapsack problem by complete enumeration
 *
-*  The routine returns one of the following error codes:
+*  This routine finds optimal solution to 0-1 knapsack problem (1)-(3)
+*  by complete enumeration. It is intended mainly for testing purposes.
 *
-*  0 - no error;
-*  1 - value out of range;
-*  2 - character string is syntactically incorrect. */
-
-int str2int(const char *str, int *_val)
-{     int d, k, s, val = 0;
-      /* scan optional sign */
-      if (str[0] == '+')
-         s = +1, k = 1;
-      else if (str[0] == '-')
-         s = -1, k = 1;
-      else
-         s = +1, k = 0;
-      /* check for the first digit */
-      if (!isdigit((unsigned char)str[k])) return 2;
-      /* scan digits */
-      while (isdigit((unsigned char)str[k]))
-      {  d = str[k++] - '0';
-         if (s > 0)
-         {  if (val > INT_MAX / 10) return 1;
-            val *= 10;
-            if (val > INT_MAX - d) return 1;
-            val += d;
+*  The instance to be solved is specified by parameters n, a, b, and c.
+*  Note that these parameters can have any sign, i.e. normalization is
+*  not needed.
+*
+*  On exit the routine stores the optimal point found in locations
+*  x[1], ..., x[n] and returns the optimal objective value. However, if
+*  the instance is infeasible, the routine returns INT_MIN.
+*
+*  Since the complete enumeration is inefficient, this routine can be
+*  used only for small instances (n <= 20-30). */
+
+#define N_MAX 40
+
+int ks_enum(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],
+      char x[/*1+n*/])
+{     int j, s, z, z_best;
+      char x_best[1+N_MAX];
+      xassert(0 <= n && n <= N_MAX);
+      /* initialization */
+      memset(&x[1], 0, n * sizeof(char));
+      z_best = INT_MIN;
+loop: /* compute constraint and objective at current x */
+      s = z = 0;
+      for (j = 1; j <= n; j++)
+      {  if (x[j])
+            s += a[j], z += c[j];
+      }
+      /* check constraint violation */
+      if (s > b)
+         goto next;
+      /* check objective function */
+      if (z_best < z)
+      {  /* better solution has been found */
+         memcpy(&x_best[1], &x[1], n * sizeof(char));
+         z_best = z;
+      }
+next: /* generate next x */
+      for (j = 1; j <= n; j++)
+      {  if (!x[j])
+         {  x[j] = 1;
+            goto loop;
+         }
+         x[j] = 0;
+      }
+      /* report best (optimal) solution */
+      memcpy(&x[1], &x_best[1], n * sizeof(char));
+      return z_best;
+}
+
+/***********************************************************************
+*  reduce - prepare reduced instance of 0-1 knapsack
+*
+*  Given original instance of 0-1 knapsack (1)-(3) specified by the
+*  parameters n, a, b, and c this routine transforms it to equivalent
+*  reduced instance in the same format. The reduced instance is
+*  normalized, i.e. the following additional conditions are met:
+*
+*     n >= 2                                                         (4)
+*
+*     1 <= a[j] <= b for all j in 1..n                               (5)
+*
+*     sum{j in 1..n} a[j] >= b+1                                     (6)
+*
+*     c[j] >= 1      for all j in 1..n                               (7)
+*
+*  The routine creates the structure ks and stores there parameters n,
+*  a, b, and c of the reduced instance as well as template of solution
+*  to original instance.
+*
+*  Normally the routine returns a pointer to the structure ks created.
+*  However, if the original instance is infeasible, the routine returns
+*  a null pointer. */
+
+struct ks
+{     int orig_n;
+      /* original problem dimension */
+      int n;
+      /* reduced problem dimension */
+      int *a; /* int a[1+orig_n]; */
+      /* a{j in 1..n} are constraint coefficients (2) */
+      int b;
+      /* b is constraint right-hand side (2) */
+      int *c; /* int c[1+orig_n]; */
+      /* c{j in 1..n} are objective coefficients (1) */
+      int c0;
+      /* c0 is objective constant term */
+      char *x; /* char x[1+orig_n]; */
+      /* x{j in 1..orig_n} is solution template to original instance:
+       * x[j] = 0       x[j] is fixed at 0
+       * x[j] = 1       x[j] is fixed at 1
+       * x[j] = 0x10    x[j] = x[j']
+       * x[j] = 0x11    x[j] = 1 - x[j']
+       * where x[j'] is corresponding solution to reduced instance */
+};
+
+static void free_ks(struct ks *ks);
+
+static struct ks *reduce(const int n, const int a[/*1+n*/], int b,
+      const int c[/*1+n*/])
+{     struct ks *ks;
+      int j, s;
+      xassert(n >= 0);
+      /* initially reduced instance is the same as original one */
+      ks = talloc(1, struct ks);
+      ks->orig_n = n;
+      ks->n = 0;
+      ks->a = talloc(1+n, int);
+      memcpy(&ks->a[1], &a[1], n * sizeof(int));
+      ks->b = b;
+      ks->c = talloc(1+n, int);
+      memcpy(&ks->c[1], &c[1], n * sizeof(int));
+      ks->c0 = 0;
+      ks->x = talloc(1+n, char);
+      /* make all a[j] non-negative */
+      for (j = 1; j <= n; j++)
+      {  if (a[j] >= 0)
+         {  /* keep original x[j] */
+            ks->x[j] = 0x10;
+         }
+         else /* a[j] < 0 */
+         {  /* substitute x[j] = 1 - x'[j] */
+            ks->x[j] = 0x11;
+            /* ... + a[j]x[j]        + ... <= b
+             * ... + a[j](1 - x'[j]) + ... <= b
+             * ... - a[j]x'[j]       + ... <= b - a[j] */
+            ks->a[j] = - ks->a[j];
+            ks->b += ks->a[j];
+            /* z = ... + c[j]x[j]        + ... + c0 =
+             *   = ... + c[j](1 - x'[j]) + ... + c0 =
+             *   = ... - c[j]x'[j]       + ... + (c0 + c[j]) */
+            ks->c0 += ks->c[j];
+            ks->c[j] = - ks->c[j];
+         }
+      }
+      /* now a[j] >= 0 for all j in 1..n */
+      if (ks->b < 0)
+      {  /* instance is infeasible */
+         free_ks(ks);
+         return NULL;
+      }
+      /* build reduced instance */
+      for (j = 1; j <= n; j++)
+      {  if (ks->a[j] == 0)
+         {  if (ks->c[j] <= 0)
+            {  /* fix x[j] at 0 */
+               ks->x[j] ^= 0x10;
+            }
+            else
+            {  /* fix x[j] at 1 */
+               ks->x[j] ^= 0x11;
+               ks->c0 += ks->c[j];
+            }
+         }
+         else if (ks->a[j] > ks->b || ks->c[j] <= 0)
+         {  /* fix x[j] at 0 */
+            ks->x[j] ^= 0x10;
          }
          else
-         {  if (val < INT_MIN / 10) return 1;
-            val *= 10;
-            if (val < INT_MIN + d) return 1;
-            val -= d;
+         {  /* include x[j] in reduced instance */
+            ks->n++;
+            ks->a[ks->n] = ks->a[j];
+            ks->c[ks->n] = ks->c[j];
          }
       }
-      /* check for terminator */
-      if (str[k] != '\0') return 2;
-      /* conversion has been done */
-      *_val = val;
-      return 0;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  str2num - convert character string to value of double type
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  int str2num(const char *str, double *val);
-*
-*  DESCRIPTION
-*
-*  The routine str2num converts the character string str to a value of
-*  double type and stores the value into location, which the parameter
-*  val points to (in the case of error content of this location is not
-*  changed).
-*
-*  RETURNS
-*
-*  The routine returns one of the following error codes:
-*
-*  0 - no error;
-*  1 - value out of range;
-*  2 - character string is syntactically incorrect. */
-
-int str2num(const char *str, double *_val)
-{     int k;
-      double val;
-      /* scan optional sign */
-      k = (str[0] == '+' || str[0] == '-' ? 1 : 0);
-      /* check for decimal point */
-      if (str[k] == '.')
-      {  k++;
-         /* a digit should follow it */
-         if (!isdigit((unsigned char)str[k])) return 2;
-         k++;
-         goto frac;
-      }
-      /* integer part should start with a digit */
-      if (!isdigit((unsigned char)str[k])) return 2;
-      /* scan integer part */
-      while (isdigit((unsigned char)str[k])) k++;
-      /* check for decimal point */
-      if (str[k] == '.') k++;
-frac: /* scan optional fraction part */
-      while (isdigit((unsigned char)str[k])) k++;
-      /* check for decimal exponent */
-      if (str[k] == 'E' || str[k] == 'e')
-      {  k++;
-         /* scan optional sign */
-         if (str[k] == '+' || str[k] == '-') k++;
-         /* a digit should follow E, E+ or E- */
-         if (!isdigit((unsigned char)str[k])) return 2;
-      }
-      /* scan optional exponent part */
-      while (isdigit((unsigned char)str[k])) k++;
-      /* check for terminator */
-      if (str[k] != '\0') return 2;
-      /* perform conversion */
-      {  char *endptr;
-         val = strtod(str, &endptr);
-         if (*endptr != '\0') return 2;
-      }
-      /* check for overflow */
-      if (!(-DBL_MAX <= val && val <= +DBL_MAX)) return 1;
-      /* check for underflow */
-      if (-DBL_MIN < val && val < +DBL_MIN) val = 0.0;
-      /* conversion has been done */
-      *_val = val;
-      return 0;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  strspx - remove all spaces from character string
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  char *strspx(char *str);
-*
-*  DESCRIPTION
-*
-*  The routine strspx removes all spaces from the character string str.
-*
-*  RETURNS
-*
-*  The routine returns a pointer to the character string.
-*
-*  EXAMPLES
-*
-*  strspx("   Errare   humanum   est   ") => "Errarehumanumest"
-*
-*  strspx("      ")                       => "" */
-
-char *strspx(char *str)
-{     char *s, *t;
-      for (s = t = str; *s; s++) if (*s != ' ') *t++ = *s;
-      *t = '\0';
-      return str;
+      /* now conditions (5) and (7) are met */
+      /* check condition (6) */
+      s = 0;
+      for (j = 1; j <= ks->n; j++)
+      {  xassert(1 <= ks->a[j] && ks->a[j] <= ks->b);
+         xassert(ks->c[j] >= 1);
+         s += ks->a[j];
+      }
+      if (s <= ks->b)
+      {  /* sum{j in 1..n} a[j] <= b */
+         /* fix all remaining x[j] at 1 to obtain trivial solution */
+         for (j = 1; j <= n; j++)
+         {  if (ks->x[j] & 0x10)
+               ks->x[j] ^= 0x11;
+         }
+         for (j = 1; j <= ks->n; j++)
+            ks->c0 += ks->c[j];
+         /* reduced instance is empty */
+         ks->n = 0;
+      }
+      /* here n = 0 or n >= 2 due to condition (6) */
+      xassert(ks->n == 0 || ks->n >= 2);
+      return ks;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  strtrim - remove trailing spaces from character string
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  char *strtrim(char *str);
-*
-*  DESCRIPTION
-*
-*  The routine strtrim removes trailing spaces from the character
-*  string str.
-*
-*  RETURNS
-*
-*  The routine returns a pointer to the character string.
-*
-*  EXAMPLES
-*
-*  strtrim("Errare humanum est   ") => "Errare humanum est"
-*
-*  strtrim("      ")                => "" */
-
-char *strtrim(char *str)
-{     char *t;
-      for (t = strrchr(str, '\0') - 1; t >= str; t--)
-      {  if (*t != ' ') break;
-         *t = '\0';
+*  restore - restore solution to original 0-1 knapsack instance
+*
+*  Given optimal solution x{j in 1..ks->n} to the reduced 0-1 knapsack
+*  instance (previously prepared by the routine reduce) this routine
+*  constructs optimal solution to the original instance and stores it
+*  in the array ks->x{j in 1..ks->orig_n}.
+*
+*  On exit the routine returns optimal objective value for the original
+*  instance.
+*
+*  NOTE: This operation should be performed only once. */
+
+static int restore(struct ks *ks, char x[])
+{     int j, k, z;
+      z = ks->c0;
+      for (j = 1, k = 0; j <= ks->orig_n; j++)
+      {  if (ks->x[j] & 0x10)
+         {  k++;
+            xassert(k <= ks->n);
+            xassert(x[k] == 0 || x[k] == 1);
+            if (ks->x[j] & 1)
+               ks->x[j] = 1 - x[k];
+            else
+               ks->x[j] = x[k];
+            if (x[k])
+               z += ks->c[k];
+         }
       }
-      return str;
+      xassert(k == ks->n);
+      return z;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  strrev - reverse character string
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  char *strrev(char *s);
-*
-*  DESCRIPTION
-*
-*  The routine strrev changes characters in a character string s to the
-*  reverse order, except the terminating null character.
+*  free_ks - deallocate structure ks
 *
-*  RETURNS
-*
-*  The routine returns the pointer s.
-*
-*  EXAMPLES
-*
-*  strrev("")                => ""
-*
-*  strrev("Today is Monday") => "yadnoM si yadoT" */
-
-char *strrev(char *s)
-{     int i, j;
-      char t;
-      for (i = 0, j = strlen(s)-1; i < j; i++, j--)
-         t = s[i], s[i] = s[j], s[j] = t;
-      return s;
-}
+*  This routine frees memory previously allocated to the structure ks
+*  and all its components. */
 
-/***********************************************************************
-*  NAME
-*
-*  gcd - find greatest common divisor of two integers
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  int gcd(int x, int y);
-*
-*  RETURNS
-*
-*  The routine gcd returns gcd(x, y), the greatest common divisor of
-*  the two positive integers given.
-*
-*  ALGORITHM
-*
-*  The routine gcd is based on Euclid's algorithm.
-*
-*  REFERENCES
-*
-*  Don Knuth, The Art of Computer Programming, Vol.2: Seminumerical
-*  Algorithms, 3rd Edition, Addison-Wesley, 1997. Section 4.5.2: The
-*  Greatest Common Divisor, pp. 333-56. */
-
-int gcd(int x, int y)
-{     int r;
-      xassert(x > 0 && y > 0);
-      while (y > 0)
-         r = x % y, x = y, y = r;
-      return x;
+static void free_ks(struct ks *ks)
+{     xassert(ks != NULL);
+      tfree(ks->a);
+      tfree(ks->c);
+      tfree(ks->x);
+      tfree(ks);
 }
 
 /***********************************************************************
-*  NAME
-*
-*  gcdn - find greatest common divisor of n integers
+*  ks_mt1 - solve 0-1 knapsack problem with Martello & Toth algorithm
 *
-*  SYNOPSIS
+*  This routine finds optimal solution to 0-1 knapsack problem (1)-(3)
+*  with Martello & Toth algorithm MT1.
 *
-*  #include "glplib.h"
-*  int gcdn(int n, int x[]);
+*  The instance to be solved is specified by parameters n, a, b, and c.
+*  Note that these parameters can have any sign, i.e. normalization is
+*  not needed.
 *
-*  RETURNS
-*
-*  The routine gcdn returns gcd(x[1], x[2], ..., x[n]), the greatest
-*  common divisor of n positive integers given, n > 0.
-*
-*  BACKGROUND
-*
-*  The routine gcdn is based on the following identity:
-*
-*     gcd(x, y, z) = gcd(gcd(x, y), z).
+*  On exit the routine stores the optimal point found in locations
+*  x[1], ..., x[n] and returns the optimal objective value. However, if
+*  the instance is infeasible, the routine returns INT_MIN.
 *
 *  REFERENCES
 *
-*  Don Knuth, The Art of Computer Programming, Vol.2: Seminumerical
-*  Algorithms, 3rd Edition, Addison-Wesley, 1997. Section 4.5.2: The
-*  Greatest Common Divisor, pp. 333-56. */
-
-int gcdn(int n, int x[])
-{     int d, j;
-      xassert(n > 0);
-      for (j = 1; j <= n; j++)
-      {  xassert(x[j] > 0);
-         if (j == 1)
-            d = x[1];
-         else
-            d = gcd(d, x[j]);
-         if (d == 1) break;
-      }
-      return d;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  lcm - find least common multiple of two integers
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  int lcm(int x, int y);
-*
-*  RETURNS
-*
-*  The routine lcm returns lcm(x, y), the least common multiple of the
-*  two positive integers given. In case of integer overflow the routine
-*  returns zero.
-*
-*  BACKGROUND
-*
-*  The routine lcm is based on the following identity:
-*
-*     lcm(x, y) = (x * y) / gcd(x, y) = x * [y / gcd(x, y)],
-*
-*  where gcd(x, y) is the greatest common divisor of x and y. */
+*  S.Martello, P.Toth. Knapsack Problems: Algorithms and Computer Imp-
+*  lementations. John Wiley & Sons, 1990. */
 
-int lcm(int x, int y)
-{     xassert(x > 0);
-      xassert(y > 0);
-      y /= gcd(x, y);
-      if (x > INT_MAX / y) return 0;
-      return x * y;
+struct mt
+{     int j;
+      float r; /* r[j] = c[j] / a[j] */
+};
+
+static int CDECL fcmp(const void *p1, const void *p2)
+{     if (((struct mt *)p1)->r > ((struct mt *)p2)->r)
+         return -1;
+      else if (((struct mt *)p1)->r < ((struct mt *)p2)->r)
+         return +1;
+      else
+         return 0;
 }
 
-/***********************************************************************
-*  NAME
-*
-*  lcmn - find least common multiple of n integers
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  int lcmn(int n, int x[]);
-*
-*  RETURNS
-*
-*  The routine lcmn returns lcm(x[1], x[2], ..., x[n]), the least
-*  common multiple of n positive integers given, n > 0. In case of
-*  integer overflow the routine returns zero.
-*
-*  BACKGROUND
-*
-*  The routine lcmn is based on the following identity:
-*
-*     lcmn(x, y, z) = lcm(lcm(x, y), z),
-*
-*  where lcm(x, y) is the least common multiple of x and y. */
-
-int lcmn(int n, int x[])
-{     int m, j;
-      xassert(n > 0);
+static int mt1a(int n, const int a[], int b, const int c[], char x[])
+{     /* interface routine to MT1 */
+      struct mt *mt;
+      int j, z, *p, *w, *x1, *xx, *min, *psign, *wsign, *zsign;
+      xassert(n >= 2);
+      /* allocate working arrays */
+      mt = talloc(1+n, struct mt);
+      p = talloc(1+n+1, int);
+      w = talloc(1+n+1, int);
+      x1 = talloc(1+n+1, int);
+      xx = talloc(1+n+1, int);
+      min = talloc(1+n+1, int);
+      psign = talloc(1+n+1, int);
+      wsign = talloc(1+n+1, int);
+      zsign = talloc(1+n+1, int);
+      /* reorder items to provide c[j] / a[j] >= a[j+1] / a[j+1] */
       for (j = 1; j <= n; j++)
-      {  xassert(x[j] > 0);
-         if (j == 1)
-            m = x[1];
-         else
-            m = lcm(m, x[j]);
-         if (m == 0) break;
+      {  mt[j].j = j;
+         mt[j].r = (float)c[j] / (float)a[j];
       }
-      return m;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  round2n - round floating-point number to nearest power of two
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  double round2n(double x);
-*
-*  RETURNS
-*
-*  Given a positive floating-point value x the routine round2n returns
-*  2^n such that |x - 2^n| is minimal.
-*
-*  EXAMPLES
-*
-*  round2n(10.1) = 2^3 = 8
-*  round2n(15.3) = 2^4 = 16
-*  round2n(0.01) = 2^(-7) = 0.0078125
-*
-*  BACKGROUND
-*
-*  Let x = f * 2^e, where 0.5 <= f < 1 is a normalized fractional part,
-*  e is an integer exponent. Then, obviously, 0.5 * 2^e <= x < 2^e, so
-*  if x - 0.5 * 2^e <= 2^e - x, we choose 0.5 * 2^e = 2^(e-1), and 2^e
-*  otherwise. The latter condition can be written as 2 * x <= 1.5 * 2^e
-*  or 2 * f * 2^e <= 1.5 * 2^e or, finally, f <= 0.75. */
-
-double round2n(double x)
-{     int e;
-      double f;
-      xassert(x > 0.0);
-      f = frexp(x, &e);
-      return ldexp(1.0, f <= 0.75 ? e-1 : e);
-}
-
-/***********************************************************************
-*  NAME
-*
-*  fp2rat - convert floating-point number to rational number
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  int fp2rat(double x, double eps, double *p, double *q);
-*
-*  DESCRIPTION
-*
-*  Given a floating-point number 0 <= x < 1 the routine fp2rat finds
-*  its "best" rational approximation p / q, where p >= 0 and q > 0 are
-*  integer numbers, such that |x - p / q| <= eps.
-*
-*  RETURNS
-*
-*  The routine fp2rat returns the number of iterations used to achieve
-*  the specified precision eps.
-*
-*  EXAMPLES
-*
-*  For x = sqrt(2) - 1 = 0.414213562373095 and eps = 1e-6 the routine
-*  gives p = 408 and q = 985, where 408 / 985 = 0.414213197969543.
-*
-*  BACKGROUND
-*
-*  It is well known that every positive real number x can be expressed
-*  as the following continued fraction:
-*
-*     x = b[0] + a[1]
-*                ------------------------
-*                b[1] + a[2]
-*                       -----------------
-*                       b[2] + a[3]
-*                              ----------
-*                              b[3] + ...
-*
-*  where:
-*
-*     a[k] = 1,                  k = 0, 1, 2, ...
-*
-*     b[k] = floor(x[k]),        k = 0, 1, 2, ...
-*
-*     x[0] = x,
-*
-*     x[k] = 1 / frac(x[k-1]),   k = 1, 2, 3, ...
-*
-*  To find the "best" rational approximation of x the routine computes
-*  partial fractions f[k] by dropping after k terms as follows:
-*
-*     f[k] = A[k] / B[k],
-*
-*  where:
-*
-*     A[-1] = 1,   A[0] = b[0],   B[-1] = 0,   B[0] = 1,
-*
-*     A[k] = b[k] * A[k-1] + a[k] * A[k-2],
-*
-*     B[k] = b[k] * B[k-1] + a[k] * B[k-2].
-*
-*  Once the condition
-*
-*     |x - f[k]| <= eps
-*
-*  has been satisfied, the routine reports p = A[k] and q = B[k] as the
-*  final answer.
-*
-*  In the table below here is some statistics obtained for one million
-*  random numbers uniformly distributed in the range [0, 1).
-*
-*      eps      max p   mean p      max q    mean q  max k   mean k
-*     -------------------------------------------------------------
-*     1e-1          8      1.6          9       3.2    3      1.4
-*     1e-2         98      6.2         99      12.4    5      2.4
-*     1e-3        997     20.7        998      41.5    8      3.4
-*     1e-4       9959     66.6       9960     133.5   10      4.4
-*     1e-5      97403    211.7      97404     424.2   13      5.3
-*     1e-6     479669    669.9     479670    1342.9   15      6.3
-*     1e-7    1579030   2127.3    3962146    4257.8   16      7.3
-*     1e-8   26188823   6749.4   26188824   13503.4   19      8.2
-*
-*  REFERENCES
-*
-*  W. B. Jones and W. J. Thron, "Continued Fractions: Analytic Theory
-*  and Applications," Encyclopedia on Mathematics and Its Applications,
-*  Addison-Wesley, 1980. */
-
-int fp2rat(double x, double eps, double *p, double *q)
-{     int k;
-      double xk, Akm1, Ak, Bkm1, Bk, ak, bk, fk, temp;
-      if (!(0.0 <= x && x < 1.0))
-         xerror("fp2rat: x = %g; number out of range\n", x);
-      for (k = 0; ; k++)
-      {  xassert(k <= 100);
-         if (k == 0)
-         {  /* x[0] = x */
-            xk = x;
-            /* A[-1] = 1 */
-            Akm1 = 1.0;
-            /* A[0] = b[0] = floor(x[0]) = 0 */
-            Ak = 0.0;
-            /* B[-1] = 0 */
-            Bkm1 = 0.0;
-            /* B[0] = 1 */
-            Bk = 1.0;
-         }
-         else
-         {  /* x[k] = 1 / frac(x[k-1]) */
-            temp = xk - floor(xk);
-            xassert(temp != 0.0);
-            xk = 1.0 / temp;
-            /* a[k] = 1 */
-            ak = 1.0;
-            /* b[k] = floor(x[k]) */
-            bk = floor(xk);
-            /* A[k] = b[k] * A[k-1] + a[k] * A[k-2] */
-            temp = bk * Ak + ak * Akm1;
-            Akm1 = Ak, Ak = temp;
-            /* B[k] = b[k] * B[k-1] + a[k] * B[k-2] */
-            temp = bk * Bk + ak * Bkm1;
-            Bkm1 = Bk, Bk = temp;
-         }
-         /* f[k] = A[k] / B[k] */
-         fk = Ak / Bk;
-#if 0
-         print("%.*g / %.*g = %.*g", DBL_DIG, Ak, DBL_DIG, Bk, DBL_DIG,
-            fk);
-#endif
-         if (fabs(x - fk) <= eps) break;
-      }
-      *p = Ak;
-      *q = Bk;
-      return k;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  jday - convert calendar date to Julian day number
-*
-*  SYNOPSIS
-*
-*  #include "glplib.h"
-*  int jday(int d, int m, int y);
-*
-*  DESCRIPTION
-*
-*  The routine jday converts a calendar date, Gregorian calendar, to
-*  corresponding Julian day number j.
-*
-*  From the given day d, month m, and year y, the Julian day number j
-*  is computed without using tables.
-*
-*  The routine is valid for 1 <= y <= 4000.
-*
-*  RETURNS
-*
-*  The routine jday returns the Julian day number, or negative value if
-*  the specified date is incorrect.
-*
-*  REFERENCES
-*
-*  R. G. Tantzen, Algorithm 199: conversions between calendar date and
-*  Julian day number, Communications of the ACM, vol. 6, no. 8, p. 444,
-*  Aug. 1963. */
-
-int jday(int d, int m, int y)
-{     int c, ya, j, dd;
-      if (!(1 <= d && d <= 31 && 1 <= m && m <= 12 && 1 <= y &&
-            y <= 4000))
-      {  j = -1;
-         goto done;
-      }
-      if (m >= 3) m -= 3; else m += 9, y--;
-      c = y / 100;
-      ya = y - 100 * c;
-      j = (146097 * c) / 4 + (1461 * ya) / 4 + (153 * m + 2) / 5 + d +
-         1721119;
-      jdate(j, &dd, NULL, NULL);
-      if (d != dd) j = -1;
-done: return j;
+      qsort(&mt[1], n, sizeof(struct mt), fcmp);
+      /* load instance parameters */
+      for (j = 1; j <= n; j++)
+      {  p[j] = c[mt[j].j];
+         w[j] = a[mt[j].j];
+      }
+      /* find optimal solution */
+      z = mt1(n, p, w, b, x1, 1, xx, min, psign, wsign, zsign);
+      xassert(z >= 0);
+      /* store optimal point found */
+      for (j = 1; j <= n; j++)
+      {  xassert(x1[j] == 0 || x1[j] == 1);
+         x[mt[j].j] = x1[j];
+      }
+      /* free working arrays */
+      tfree(mt);
+      tfree(p);
+      tfree(w);
+      tfree(x1);
+      tfree(xx);
+      tfree(min);
+      tfree(psign);
+      tfree(wsign);
+      tfree(zsign);
+      return z;
+}
+
+int ks_mt1(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],
+      char x[/*1+n*/])
+{     struct ks *ks;
+      int j, s1, s2, z;
+      xassert(n >= 0);
+      /* prepare reduced instance */
+      ks = reduce(n, a, b, c);
+      if (ks == NULL)
+      {  /* original instance is infeasible */
+         return INT_MIN;
+      }
+      /* find optimal solution to reduced instance */
+      if (ks->n > 0)
+         mt1a(ks->n, ks->a, ks->b, ks->c, x);
+      /* restore solution to original instance */
+      z = restore(ks, x);
+      memcpy(&x[1], &ks->x[1], n * sizeof(char));
+      free_ks(ks);
+      /* check solution found */
+      s1 = s2 = 0;
+      for (j = 1; j <= n; j++)
+      {  xassert(x[j] == 0 || x[j] == 1);
+         if (x[j])
+            s1 += a[j], s2 += c[j];
+      }
+      xassert(s1 <= b);
+      xassert(s2 == z);
+      return z;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  jdate - convert Julian day number to calendar date
+*  ks_greedy - solve 0-1 knapsack problem with greedy heuristic
 *
-*  SYNOPSIS
+*  This routine finds (sub)optimal solution to 0-1 knapsack problem
+*  (1)-(3) with greedy heuristic.
 *
-*  #include "glplib.h"
-*  void jdate(int j, int *d, int *m, int *y);
+*  The instance to be solved is specified by parameters n, a, b, and c.
+*  Note that these parameters can have any sign, i.e. normalization is
+*  not needed.
 *
-*  DESCRIPTION
-*
-*  The routine jdate converts a Julian day number j to corresponding
-*  calendar date, Gregorian calendar.
-*
-*  The day d, month m, and year y are computed without using tables and
-*  stored in corresponding locations.
-*
-*  The routine is valid for 1721426 <= j <= 3182395.
-*
-*  RETURNS
-*
-*  If the conversion is successful, the routine returns zero, otherwise
-*  non-zero.
-*
-*  REFERENCES
-*
-*  R. G. Tantzen, Algorithm 199: conversions between calendar date and
-*  Julian day number, Communications of the ACM, vol. 6, no. 8, p. 444,
-*  Aug. 1963. */
-
-int jdate(int j, int *_d, int *_m, int *_y)
-{     int d, m, y, ret = 0;
-      if (!(1721426 <= j && j <= 3182395))
-      {  ret = 1;
-         goto done;
-      }
-      j -= 1721119;
-      y = (4 * j - 1) / 146097;
-      j = (4 * j - 1) % 146097;
-      d = j / 4;
-      j = (4 * d + 3) / 1461;
-      d = (4 * d + 3) % 1461;
-      d = (d + 4) / 4;
-      m = (5 * d - 3) / 153;
-      d = (5 * d - 3) % 153;
-      d = (d + 5) / 5;
-      y = 100 * y + j;
-      if (m <= 9) m += 3; else m -= 9, y++;
-      if (_d != NULL) *_d = d;
-      if (_m != NULL) *_m = m;
-      if (_y != NULL) *_y = y;
-done: return ret;
-}
+*  On exit the routine stores the optimal point found in locations
+*  x[1], ..., x[n] and returns the optimal objective value. However, if
+*  the instance is infeasible, the routine returns INT_MIN. */
 
-#if 0
-int main(void)
-{     int jbeg, jend, j, d, m, y;
-      jbeg = jday(1, 1, 1);
-      jend = jday(31, 12, 4000);
-      for (j = jbeg; j <= jend; j++)
-      {  xassert(jdate(j, &d, &m, &y) == 0);
-         xassert(jday(d, m, y) == j);
+static int greedy(int n, const int a[], int b, const int c[], char x[])
+{     /* core routine for normalized 0-1 knapsack instance */
+      struct mt *mt;
+      int j, s, z;
+      xassert(n >= 2);
+      /* reorder items to provide c[j] / a[j] >= a[j+1] / a[j+1] */
+      mt = talloc(1+n, struct mt);
+      for (j = 1; j <= n; j++)
+      {  mt[j].j = j;
+         mt[j].r = (float)c[j] / (float)a[j];
       }
-      xprintf("Routines jday and jdate work correctly.\n");
-      return 0;
+      qsort(&mt[1], n, sizeof(struct mt), fcmp);
+      /* take items starting from most valuable ones until the knapsack
+       * is full */
+      s = z = 0;
+      for (j = 1; j <= n; j++)
+      {  if (s + a[mt[j].j] > b)
+            break;
+         x[mt[j].j] = 1;
+         s += a[mt[j].j];
+         z += c[mt[j].j];
+      }
+      /* don't take remaining items */
+      for (j = j; j <= n; j++)
+         x[mt[j].j] = 0;
+      tfree(mt);
+      return z;
+}
+
+int ks_greedy(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],
+      char x[/*1+n*/])
+{     struct ks *ks;
+      int j, s1, s2, z;
+      xassert(n >= 0);
+      /* prepare reduced instance */
+      ks = reduce(n, a, b, c);
+      if (ks == NULL)
+      {  /* original instance is infeasible */
+         return INT_MIN;
+      }
+      /* find suboptimal solution to reduced instance */
+      if (ks->n > 0)
+         greedy(ks->n, ks->a, ks->b, ks->c, x);
+      /* restore solution to original instance */
+      z = restore(ks, x);
+      memcpy(&x[1], &ks->x[1], n * sizeof(char));
+      free_ks(ks);
+      /* check solution found */
+      s1 = s2 = 0;
+      for (j = 1; j <= n; j++)
+      {  xassert(x[j] == 0 || x[j] == 1);
+         if (x[j])
+            s1 += a[j], s2 += c[j];
+      }
+      xassert(s1 <= b);
+      xassert(s2 == z);
+      return z;
 }
-#endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplpf.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/luf.h`

 * *Files 17% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glplpf.h (LP basis factorization, Schur complement version) */
+/* luf.h (sparse LU-factorization) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2012-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,177 +15,211 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPLPF_H
-#define GLPLPF_H
+#ifndef LUF_H
+#define LUF_H
 
-#include "glpscf.h"
-#include "glpluf.h"
+#include "sva.h"
 
 /***********************************************************************
-*  The structure LPF defines the factorization of the basis mxm matrix
-*  B, where m is the number of rows in corresponding problem instance.
-*
-*  This factorization is the following septet:
-*
-*     [B] = (L0, U0, R, S, C, P, Q),                                 (1)
-*
-*  and is based on the following main equality:
-*
-*     ( B  F^)     ( B0 F )       ( L0 0 ) ( U0 R )
-*     (      ) = P (      ) Q = P (      ) (      ) Q,               (2)
-*     ( G^ H^)     ( G  H )       ( S  I ) ( 0  C )
-*
-*  where:
-*
-*  B is the current basis matrix (not stored);
-*
-*  F^, G^, H^ are some additional matrices (not stored);
-*
-*  B0 is some initial basis matrix (not stored);
+*  The structure LUF describes sparse LU-factorization.
 *
-*  F, G, H are some additional matrices (not stored);
+*  The LU-factorization has the following format:
 *
-*  P, Q are permutation matrices (stored in both row- and column-like
-*  formats);
+*     A = F * V = P * L * U * Q,                                     (1)
 *
-*  L0, U0 are some matrices that defines a factorization of the initial
-*  basis matrix B0 = L0 * U0 (stored in an invertable form);
+*     F = P * L * P',                                                (2)
 *
-*  R is a matrix defined from L0 * R = F, so R = inv(L0) * F (stored in
-*  a column-wise sparse format);
+*     V = P * U * Q,                                                 (3)
 *
-*  S is a matrix defined from S * U0 = G, so S = G * inv(U0) (stored in
-*  a row-wise sparse format);
+*  where A is a given (unsymmetric) square matrix, F and V are matrix
+*  factors actually computed, L is a lower triangular matrix with unity
+*  diagonal, U is an upper triangular matrix, P and Q are permutation
+*  matrices, P' is a matrix transposed to P. All the matrices have the
+*  same order n.
 *
-*  C is the Schur complement for matrix (B0 F G H). It is defined from
-*  S * R + C = H, so C = H - S * R = H - G * inv(U0) * inv(L0) * F =
-*  = H - G * inv(B0) * F. Matrix C is stored in an invertable form.
+*  Matrices F and V are stored in both row- and column-wise sparse
+*  formats in the associated sparse vector area (SVA). Unity diagonal
+*  elements of matrix F are not stored. Pivot elements of matrix V
+*  (which correspond to diagonal elements of matrix U) are stored in
+*  a separate ordinary array.
 *
-*  REFERENCES
+*  Permutation matrices P and Q are stored in ordinary arrays in both
+*  row- and column-like formats.
 *
-*  1. M.A.Saunders, "LUSOL: A basis package for constrained optimiza-
-*     tion," SCCM, Stanford University, 2006.
-*
-*  2. M.A.Saunders, "Notes 5: Basis Updates," CME 318, Stanford Univer-
-*     sity, Spring 2006.
-*
-*  3. M.A.Saunders, "Notes 6: LUSOL---a Basis Factorization Package,"
-*     ibid. */
+*  Matrices L and U are completely defined by matrices F, V, P, and Q,
+*  and therefore not stored explicitly. */
 
-typedef struct LPF LPF;
+typedef struct LUF LUF;
 
-struct LPF
-{     /* LP basis factorization */
-      int valid;
-      /* the factorization is valid only if this flag is set */
-      /*--------------------------------------------------------------*/
-      /* initial basis matrix B0 */
-      int m0_max;
-      /* maximal value of m0 (increased automatically, if necessary) */
-      int m0;
-      /* the order of B0 */
-      LUF *luf;
-      /* LU-factorization of B0 */
+struct LUF
+{     /* sparse LU-factorization */
+      int n;
+      /* order of matrices A, F, V, P, Q */
+      SVA *sva;
+      /* associated sparse vector area (SVA) used to store rows and
+       * columns of matrices F and V; note that different objects may
+       * share the same SVA */
+      /*--------------------------------------------------------------*/
+      /* matrix F in row-wise format */
+      /* during the factorization process this object is not used */
+      int fr_ref;
+      /* reference number of sparse vector in SVA, which is the first
+       * row of matrix F */
+#if 0 + 0
+      int *fr_ptr = &sva->ptr[fr_ref-1];
+      /* fr_ptr[0] is not used;
+       * fr_ptr[i], 1 <= i <= n, is pointer to i-th row in SVA */
+      int *fr_len = &sva->len[fr_ref-1];
+      /* fr_len[0] is not used;
+       * fr_len[i], 1 <= i <= n, is length of i-th row */
+#endif
       /*--------------------------------------------------------------*/
-      /* current basis matrix B */
-      int m;
-      /* the order of B */
-      double *B; /* double B[1+m*m]; */
-      /* B in dense format stored by rows and used only for debugging;
-         normally this array is not allocated */
+      /* matrix F in column-wise format */
+      /* during the factorization process this object is constructed
+       * by columns */
+      int fc_ref;
+      /* reference number of sparse vector in SVA, which is the first
+       * column of matrix F */
+#if 0 + 0
+      int *fc_ptr = &sva->ptr[fc_ref-1];
+      /* fc_ptr[0] is not used;
+       * fc_ptr[j], 1 <= j <= n, is pointer to j-th column in SVA */
+      int *fc_len = &sva->len[fc_ref-1];
+      /* fc_len[0] is not used;
+       * fc_len[j], 1 <= j <= n, is length of j-th column */
+#endif
       /*--------------------------------------------------------------*/
-      /* augmented matrix (B0 F G H) of the order m0+n */
-      int n_max;
-      /* maximal number of additional rows and columns */
-      int n;
-      /* current number of additional rows and columns */
+      /* matrix V in row-wise format */
+      int vr_ref;
+      /* reference number of sparse vector in SVA, which is the first
+       * row of matrix V */
+#if 0 + 0
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      /* vr_ptr[0] is not used;
+       * vr_ptr[i], 1 <= i <= n, is pointer to i-th row in SVA */
+      int *vr_len = &sva->len[vr_ref-1];
+      /* vr_len[0] is not used;
+       * vr_len[i], 1 <= i <= n, is length of i-th row */
+      int *vr_cap = &sva->cap[vr_ref-1];
+      /* vr_cap[0] is not used;
+       * vr_cap[i], 1 <= i <= n, is capacity of i-th row */
+#endif
+      double *vr_piv; /* double vr_piv[1+n]; */
+      /* vr_piv[0] is not used;
+       * vr_piv[i], 1 <= i <= n, is pivot element of i-th row */
+      /*--------------------------------------------------------------*/
+      /* matrix V in column-wise format */
+      /* during the factorization process this object contains only the
+       * patterns (row indices) of columns of the active submatrix */
+      int vc_ref;
+      /* reference number of sparse vector in SVA, which is the first
+       * column of matrix V */
+#if 0 + 0
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      /* vc_ptr[0] is not used;
+       * vc_ptr[j], 1 <= j <= n, is pointer to j-th column in SVA */
+      int *vc_len = &sva->len[vc_ref-1];
+      /* vc_len[0] is not used;
+       * vc_len[j], 1 <= j <= n, is length of j-th column */
+      int *vc_cap = &sva->cap[vc_ref-1];
+      /* vc_cap[0] is not used;
+       * vc_cap[j], 1 <= j <= n, is capacity of j-th column */
+#endif
       /*--------------------------------------------------------------*/
-      /* m0xn matrix R in column-wise format */
-      int *R_ptr; /* int R_ptr[1+n_max]; */
-      /* R_ptr[j], 1 <= j <= n, is a pointer to j-th column */
-      int *R_len; /* int R_len[1+n_max]; */
-      /* R_len[j], 1 <= j <= n, is the length of j-th column */
-      /*--------------------------------------------------------------*/
-      /* nxm0 matrix S in row-wise format */
-      int *S_ptr; /* int S_ptr[1+n_max]; */
-      /* S_ptr[i], 1 <= i <= n, is a pointer to i-th row */
-      int *S_len; /* int S_len[1+n_max]; */
-      /* S_len[i], 1 <= i <= n, is the length of i-th row */
-      /*--------------------------------------------------------------*/
-      /* Schur complement C of the order n */
-      SCF *scf; /* SCF scf[1:n_max]; */
-      /* factorization of the Schur complement */
-      /*--------------------------------------------------------------*/
-      /* matrix P of the order m0+n */
-      int *P_row; /* int P_row[1+m0_max+n_max]; */
-      /* P_row[i] = j means that P[i,j] = 1 */
-      int *P_col; /* int P_col[1+m0_max+n_max]; */
-      /* P_col[j] = i means that P[i,j] = 1 */
-      /*--------------------------------------------------------------*/
-      /* matrix Q of the order m0+n */
-      int *Q_row; /* int Q_row[1+m0_max+n_max]; */
-      /* Q_row[i] = j means that Q[i,j] = 1 */
-      int *Q_col; /* int Q_col[1+m0_max+n_max]; */
-      /* Q_col[j] = i means that Q[i,j] = 1 */
-      /*--------------------------------------------------------------*/
-      /* Sparse Vector Area (SVA) is a set of locations intended to
-         store sparse vectors which represent columns of matrix R and
-         rows of matrix S; each location is a doublet (ind, val), where
-         ind is an index, val is a numerical value of a sparse vector
-         element; in the whole each sparse vector is a set of adjacent
-         locations defined by a pointer to its first element and its
-         length, i.e. the number of its elements */
-      int v_size;
-      /* the SVA size, in locations; locations are numbered by integers
-         1, 2, ..., v_size, and location 0 is not used */
-      int v_ptr;
-      /* pointer to the first available location */
-      int *v_ind; /* int v_ind[1+v_size]; */
-      /* v_ind[k], 1 <= k <= v_size, is the index field of location k */
-      double *v_val; /* double v_val[1+v_size]; */
-      /* v_val[k], 1 <= k <= v_size, is the value field of location k */
-      /*--------------------------------------------------------------*/
-      double *work1; /* double work1[1+m0+n_max]; */
-      /* working array */
-      double *work2; /* double work2[1+m0+n_max]; */
-      /* working array */
+      /* matrix P */
+      int *pp_ind; /* int pp_ind[1+n]; */
+      /* pp_ind[i] = j means that P[i,j] = 1 */
+      int *pp_inv; /* int pp_inv[1+n]; */
+      /* pp_inv[j] = i means that P[i,j] = 1 */
+      /* if i-th row or column of matrix F is i'-th row or column of
+       * matrix L, or if i-th row of matrix V is i'-th row of matrix U,
+       * then pp_ind[i] = i' and pp_inv[i'] = i */
+      /*--------------------------------------------------------------*/
+      /* matrix Q */
+      int *qq_ind; /* int qq_ind[1+n]; */
+      /* qq_ind[i] = j means that Q[i,j] = 1 */
+      int *qq_inv; /* int qq_inv[1+n]; */
+      /* qq_inv[j] = i means that Q[i,j] = 1 */
+      /* if j-th column of matrix V is j'-th column of matrix U, then
+       * qq_ind[j'] = j and qq_inv[j] = j' */
 };
 
-/* return codes: */
-#define LPF_ESING    1  /* singular matrix */
-#define LPF_ECOND    2  /* ill-conditioned matrix */
-#define LPF_ELIMIT   3  /* update limit reached */
-
-#define lpf_create_it _glp_lpf_create_it
-LPF *lpf_create_it(void);
-/* create LP basis factorization */
-
-#define lpf_factorize _glp_lpf_factorize
-int lpf_factorize(LPF *lpf, int m, const int bh[], int (*col)
-      (void *info, int j, int ind[], double val[]), void *info);
-/* compute LP basis factorization */
-
-#define lpf_ftran _glp_lpf_ftran
-void lpf_ftran(LPF *lpf, double x[]);
-/* perform forward transformation (solve system B*x = b) */
-
-#define lpf_btran _glp_lpf_btran
-void lpf_btran(LPF *lpf, double x[]);
-/* perform backward transformation (solve system B'*x = b) */
-
-#define lpf_update_it _glp_lpf_update_it
-int lpf_update_it(LPF *lpf, int j, int bh, int len, const int ind[],
-      const double val[]);
-/* update LP basis factorization */
-
-#define lpf_delete_it _glp_lpf_delete_it
-void lpf_delete_it(LPF *lpf);
-/* delete LP basis factorization */
+#define luf_swap_u_rows(i1, i2) \
+      do \
+      {  int j1, j2; \
+         j1 = pp_inv[i1], j2 = pp_inv[i2]; \
+         pp_ind[j1] = i2, pp_inv[i2] = j1; \
+         pp_ind[j2] = i1, pp_inv[i1] = j2; \
+      } while (0)
+/* swap rows i1 and i2 of matrix U = P'* V * Q' */
+
+#define luf_swap_u_cols(j1, j2) \
+      do \
+      {  int i1, i2; \
+         i1 = qq_ind[j1], i2 = qq_ind[j2]; \
+         qq_ind[j1] = i2, qq_inv[i2] = j1; \
+         qq_ind[j2] = i1, qq_inv[i1] = j2; \
+      } while (0)
+/* swap columns j1 and j2 of matrix U = P'* V * Q' */
+
+#define luf_store_v_cols _glp_luf_store_v_cols
+int luf_store_v_cols(LUF *luf, int (*col)(void *info, int j, int ind[],
+      double val[]), void *info, int ind[], double val[]);
+/* store matrix V = A in column-wise format */
+
+#define luf_check_all _glp_luf_check_all
+void luf_check_all(LUF *luf, int k);
+/* check LU-factorization before k-th elimination step */
+
+#define luf_build_v_rows _glp_luf_build_v_rows
+void luf_build_v_rows(LUF *luf, int len[/*1+n*/]);
+/* build matrix V in row-wise format */
+
+#define luf_build_f_rows _glp_luf_build_f_rows
+void luf_build_f_rows(LUF *luf, int len[/*1+n*/]);
+/* build matrix F in row-wise format */
+
+#define luf_build_v_cols _glp_luf_build_v_cols
+void luf_build_v_cols(LUF *luf, int updat, int len[/*1+n*/]);
+/* build matrix V in column-wise format */
+
+#define luf_check_f_rc _glp_luf_check_f_rc
+void luf_check_f_rc(LUF *luf);
+/* check rows and columns of matrix F */
+
+#define luf_check_v_rc _glp_luf_check_v_rc
+void luf_check_v_rc(LUF *luf);
+/* check rows and columns of matrix V */
+
+#define luf_f_solve _glp_luf_f_solve
+void luf_f_solve(LUF *luf, double x[/*1+n*/]);
+/* solve system F * x = b */
+
+#define luf_ft_solve _glp_luf_ft_solve
+void luf_ft_solve(LUF *luf, double x[/*1+n*/]);
+/* solve system F' * x = b */
+
+#define luf_v_solve _glp_luf_v_solve
+void luf_v_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/]);
+/* solve system V * x = b */
+
+#define luf_vt_solve _glp_luf_vt_solve
+void luf_vt_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/]);
+/* solve system V' * x = b */
+
+#define luf_vt_solve1 _glp_luf_vt_solve1
+void luf_vt_solve1(LUF *luf, double e[/*1+n*/], double y[/*1+n*/]);
+/* solve system V' * y = e' to cause growth in y */
+
+#define luf_estimate_norm _glp_luf_estimate_norm
+double luf_estimate_norm(LUF *luf, double w1[/*1+n*/], double
+      w2[/*1+n*/]);
+/* estimate 1-norm of inv(A) */
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplpx03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxlp.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,18 +1,13 @@
-/* glplpx03.c (OPB format) */
+/* spxlp.h */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Author: Oscar Gustafsson <oscarg@isy.liu.se>.
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2015 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -20,283 +15,218 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#define _GLPSTD_ERRNO
-#define _GLPSTD_STDIO
-#include "glpapi.h"
-#if 0 /* 24/XII-2009; by mao */
-#include "glpipp.h"
+#ifndef SPXLP_H
+#define SPXLP_H
+
+#include "bfd.h"
+
+/***********************************************************************
+*  The structure SPXLP describes LP problem and its current basis.
+*
+*  It is assumed that LP problem has the following formulation (this is
+*  so called "working format"):
+*
+*     z = c'* x + c0 -> min                                          (1)
+*
+*     A * x = b                                                      (2)
+*
+*     l <= x <= u                                                    (3)
+*
+*  where:
+*
+*  x = (x[k]) is a n-vector of variables;
+*
+*  z is an objective function;
+*
+*  c = (c[k]) is a n-vector of objective coefficients;
+*
+*  c0 is a constant term of the objective function;
+*
+*  A = (a[i,k]) is a mxn-matrix of constraint coefficients;
+*
+*  b = (b[i]) is a m-vector of right-hand sides;
+*
+*  l = (l[k]) is a n-vector of lower bounds of variables;
+*
+*  u = (u[k]) is a n-vector of upper bounds of variables.
+*
+*  If variable x[k] has no lower (upper) bound, it is formally assumed
+*  that l[k] = -inf (u[k] = +inf). Variable having no bounds is called
+*  free (unbounded) variable. If l[k] = u[k], variable x[k] is assumed
+*  to be fixed.
+*
+*  It is also assumed that matrix A has full row rank: rank(A) = m,
+*  i.e. all its rows are linearly independent, so m <= n.
+*
+*  The (current) basis is defined by an appropriate permutation matrix
+*  P of order n such that:
+*
+*             ( xB )
+*     P * x = (    ),                                                (4)
+*             ( xN )
+*
+*  where xB = (xB[i]) is a m-vector of basic variables, xN = (xN[j]) is
+*  a (n-m)-vector of non-basic variables. If a non-basic variable xN[j]
+*  has both lower and upper bounds, there is used an additional flag to
+*  indicate which bound is active.
+*
+*  From (2) and (4) it follows that:
+*
+*     A * P'* P * x = b   <=>   B * xB + N * xN = b,                 (5)
+*
+*  where P' is a matrix transposed to P, and
+*
+*     A * P' = (B | N).                                              (6)
+*
+*  Here B is the basis matrix, which is a square non-singular matrix
+*  of order m composed from columns of matrix A that correspond to
+*  basic variables xB, and N is a mx(n-m) matrix composed from columns
+*  of matrix A that correspond to non-basic variables xN. */
+
+typedef struct SPXLP SPXLP;
+
+struct SPXLP
+{     /* LP problem data and its (current) basis */
+      int m;
+      /* number of equality constraints, m > 0 */
+      int n;
+      /* number of variables, n >= m */
+      int nnz;
+      /* number of non-zeros in constraint matrix A */
+      /*--------------------------------------------------------------*/
+      /* mxn-matrix A of constraint coefficients in sparse column-wise
+       * format */
+      int *A_ptr; /* int A_ptr[1+n+1]; */
+      /* A_ptr[0] is not used;
+       * A_ptr[k], 1 <= k <= n, is starting position of k-th column in
+       * arrays A_ind and A_val; note that A_ptr[1] is always 1;
+       * A_ptr[n+1] indicates the position after the last element in
+       * arrays A_ind and A_val, i.e. A_ptr[n+1] = nnz+1, where nnz is
+       * the number of non-zero elements in matrix A;
+       * the length of k-th column (the number of non-zero elements in
+       * that column) can be calculated as A_ptr[k+1] - A_ptr[k] */
+      int *A_ind; /* int A_ind[1+nnz]; */
+      /* row indices */
+      double *A_val; /* double A_val[1+nnz]; */
+      /* non-zero element values (constraint coefficients) */
+      /*--------------------------------------------------------------*/
+      /* principal vectors of LP formulation */
+      double *b; /* double b[1+m]; */
+      /* b[0] is not used;
+       * b[i], 1 <= i <= m, is the right-hand side of i-th equality
+       * constraint */
+      double *c; /* double c[1+n]; */
+      /* c[0] is the constant term of the objective function;
+       * c[k], 1 <= k <= n, is the objective function coefficient at
+       * variable x[k] */
+      double *l; /* double l[1+n]; */
+      /* l[0] is not used;
+       * l[k], 1 <= k <= n, is the lower bound of variable x[k];
+       * if x[k] has no lower bound, l[k] = -DBL_MAX */
+      double *u; /* double u[1+n]; */
+      /* u[0] is not used;
+       * u[k], 1 <= k <= n, is the upper bound of variable u[k];
+       * if x[k] has no upper bound, u[k] = +DBL_MAX;
+       * note that l[k] = u[k] means that x[k] is fixed variable */
+      /*--------------------------------------------------------------*/
+      /* LP basis */
+      int *head; /* int head[1+n]; */
+      /* basis header, which is permutation matrix P (4):
+       * head[0] is not used;
+       * head[i] = k means that xB[i] = x[k], 1 <= i <= m;
+       * head[m+j] = k, means that xN[j] = x[k], 1 <= j <= n-m */
+      char *flag; /* char flag[1+n-m]; */
+      /* flags of non-basic variables:
+       * flag[0] is not used;
+       * flag[j], 1 <= j <= n-m, indicates that non-basic variable
+       * xN[j] is non-fixed and has its upper bound active */
+      /*--------------------------------------------------------------*/
+      /* basis matrix B of order m stored in factorized form */
+      int valid;
+      /* factorization validity flag */
+      BFD *bfd;
+      /* driver to factorization of the basis matrix */
+};
+
+#define spx_factorize _glp_spx_factorize
+int spx_factorize(SPXLP *lp);
+/* compute factorization of current basis matrix */
+
+#define spx_eval_beta _glp_spx_eval_beta
+void spx_eval_beta(SPXLP *lp, double beta[/*1+m*/]);
+/* compute values of basic variables */
+
+#define spx_eval_obj _glp_spx_eval_obj
+double spx_eval_obj(SPXLP *lp, const double beta[/*1+m*/]);
+/* compute value of objective function */
+
+#define spx_eval_pi _glp_spx_eval_pi
+void spx_eval_pi(SPXLP *lp, double pi[/*1+m*/]);
+/* compute simplex multipliers */
+
+#define spx_eval_dj _glp_spx_eval_dj
+double spx_eval_dj(SPXLP *lp, const double pi[/*1+m*/], int j);
+/* compute reduced cost of j-th non-basic variable */
+
+#define spx_eval_tcol _glp_spx_eval_tcol
+void spx_eval_tcol(SPXLP *lp, int j, double tcol[/*1+m*/]);
+/* compute j-th column of simplex table */
+
+#define spx_eval_rho _glp_spx_eval_rho
+void spx_eval_rho(SPXLP *lp, int i, double rho[/*1+m*/]);
+/* compute i-th row of basis matrix inverse */
+
+#if 1 /* 31/III-2016 */
+#define spx_eval_rho_s _glp_spx_eval_rho_s
+void spx_eval_rho_s(SPXLP *lp, int i, FVS *rho);
+/* sparse version of spx_eval_rho */
+#endif
+
+#define spx_eval_tij _glp_spx_eval_tij
+double spx_eval_tij(SPXLP *lp, const double rho[/*1+m*/], int j);
+/* compute element T[i,j] of simplex table */
+
+#define spx_eval_trow _glp_spx_eval_trow
+void spx_eval_trow(SPXLP *lp, const double rho[/*1+m*/], double
+      trow[/*1+n-m*/]);
+/* compute i-th row of simplex table */
+
+#define spx_update_beta _glp_spx_update_beta
+void spx_update_beta(SPXLP *lp, double beta[/*1+m*/], int p,
+      int p_flag, int q, const double tcol[/*1+m*/]);
+/* update values of basic variables */
+
+#if 1 /* 30/III-2016 */
+#define spx_update_beta_s _glp_spx_update_beta_s
+void spx_update_beta_s(SPXLP *lp, double beta[/*1+m*/], int p,
+      int p_flag, int q, const FVS *tcol);
+/* sparse version of spx_update_beta */
+#endif
+
+#define spx_update_d _glp_spx_update_d
+double spx_update_d(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
+      const double trow[/*1+n-m*/], const double tcol[/*1+m*/]);
+/* update reduced costs of non-basic variables */
+
+#if 1 /* 30/III-2016 */
+#define spx_update_d_s _glp_spx_update_d_s
+double spx_update_d_s(SPXLP *lp, double d[/*1+n-m*/], int p, int q,
+      const FVS *trow, const FVS *tcol);
+/* sparse version of spx_update_d */
 #endif
 
-/*----------------------------------------------------------------------
--- lpx_write_pb - write problem data in (normalized) OPB format.
---
--- *Synopsis*
---
--- #include "glplpx.h"
--- int lpx_write_pb(LPX *lp, const char *fname, int normalized,
---    int binarize);
---
--- *Description*
---
--- The routine lpx_write_pb writes problem data in OPB format
--- to an output text file whose name is the character string fname.
--- If normalized is non-zero the output will be generated in a
--- normalized form with sequentially numbered variables, x1, x2 etc.
--- If binarize, any integer variable will be repalzec by binary ones,
--- see ipp_binarize
---
--- *Returns*
---
--- If the operation was successful, the routine returns zero. Otherwise
--- the routine prints an error message and returns non-zero. */
-
-#if 1 /* 24/XII-2009; by mao (disabled, because IPP was removed) */
-int lpx_write_pb(LPX *lp, const char *fname, int normalized,
-      int binarize)
-{     xassert(lp == lp);
-      xassert(fname == fname);
-      xassert(normalized == normalized);
-      xassert(binarize == binarize);
-      xprintf("lpx_write_pb: sorry, currently this operation is not ava"
-         "ilable\n");
-      return 1;
-}
-#else
-int lpx_write_pb(LPX *lp, const char *fname, int normalized,
-      int binarize)
-{
-  FILE* fp;
-  int m,n,i,j,k,o,nonfree=0, obj_dir, dbl, *ndx, row_type, emptylhs=0;
-  double coeff, *val, bound, constant/*=0.0*/;
-  char* objconstname = "dummy_one";
-  char* emptylhsname = "dummy_zero";
-
-  /* Variables needed for possible binarization */
-  /*LPX* tlp;*/
-  IPP *ipp = NULL;
-  /*tlp=lp;*/
-
-  if(binarize) /* Transform integer variables to binary ones */
-    {
-      ipp = ipp_create_wksp();
-      ipp_load_orig(ipp, lp);
-      ipp_binarize(ipp);
-      lp = ipp_build_prob(ipp);
-    }
-  fp = fopen(fname, "w");
-
-  if(fp!= NULL)
-    {
-      xprintf(
-          "lpx_write_pb: writing problem in %sOPB format to `%s'...\n",
-              (normalized?"normalized ":""), fname);
-
-      m = glp_get_num_rows(lp);
-      n = glp_get_num_cols(lp);
-      for(i=1;i<=m;i++)
-        {
-          switch(glp_get_row_type(lp,i))
-            {
-            case GLP_LO:
-            case GLP_UP:
-            case GLP_FX:
-              {
-                nonfree += 1;
-                break;
-              }
-            case GLP_DB:
-              {
-                nonfree += 2;
-                break;
-              }
-            }
-        }
-      constant=glp_get_obj_coef(lp,0);
-      fprintf(fp,"* #variables = %d #constraints = %d\n",
-         n + (constant == 0?1:0), nonfree + (constant == 0?1:0));
-      /* Objective function */
-      obj_dir = glp_get_obj_dir(lp);
-      fprintf(fp,"min: ");
-      for(i=1;i<=n;i++)
-        {
-          coeff = glp_get_obj_coef(lp,i);
-          if(coeff != 0.0)
-            {
-              if(obj_dir == GLP_MAX)
-                coeff=-coeff;
-              if(normalized)
-                fprintf(fp, " %d x%d", (int)coeff, i);
-              else
-                fprintf(fp, " %d*%s", (int)coeff,
-                  glp_get_col_name(lp,i));
-
-            }
-        }
-      if(constant)
-        {
-          if(normalized)
-            fprintf(fp, " %d x%d", (int)constant, n+1);
-          else
-            fprintf(fp, " %d*%s", (int)constant, objconstname);
-        }
-      fprintf(fp,";\n");
-
-      if(normalized && !binarize)  /* Name substitution */
-        {
-          fprintf(fp,"* Variable name substitution:\n");
-          for(j=1;j<=n;j++)
-            {
-              fprintf(fp, "* x%d = %s\n", j, glp_get_col_name(lp,j));
-            }
-          if(constant)
-            fprintf(fp, "* x%d = %s\n", n+1, objconstname);
-        }
-
-      ndx = xcalloc(1+n, sizeof(int));
-      val = xcalloc(1+n, sizeof(double));
-
-      /* Constraints */
-      for(j=1;j<=m;j++)
-        {
-          row_type=glp_get_row_type(lp,j);
-          if(row_type!=GLP_FR)
-            {
-              if(row_type == GLP_DB)
-                {
-                  dbl=2;
-                  row_type = GLP_UP;
-                }
-              else
-                {
-                  dbl=1;
-                }
-              k=glp_get_mat_row(lp, j, ndx, val);
-              for(o=1;o<=dbl;o++)
-                {
-                  if(o==2)
-                    {
-                      row_type = GLP_LO;
-                    }
-                  if(k==0) /* Empty LHS */
-                    {
-                      emptylhs = 1;
-                      if(normalized)
-                        {
-                          fprintf(fp, "0 x%d ", n+2);
-                        }
-                      else
-                        {
-                          fprintf(fp, "0*%s ", emptylhsname);
-                        }
-                    }
-
-                  for(i=1;i<=k;i++)
-                    {
-                      if(val[i] != 0.0)
-                        {
-
-                          if(normalized)
-                            {
-                              fprintf(fp, "%d x%d ",
-              (row_type==GLP_UP)?(-(int)val[i]):((int)val[i]), ndx[i]);
-                            }
-                          else
-                            {
-                              fprintf(fp, "%d*%s ", (int)val[i],
-                                      glp_get_col_name(lp,ndx[i]));
-                            }
-                        }
-                    }
-                  switch(row_type)
-                    {
-                    case GLP_LO:
-                      {
-                        fprintf(fp, ">=");
-                        bound = glp_get_row_lb(lp,j);
-                        break;
-                      }
-                    case GLP_UP:
-                      {
-                        if(normalized)
-                          {
-                            fprintf(fp, ">=");
-                            bound = -glp_get_row_ub(lp,j);
-                          }
-                        else
-                          {
-                            fprintf(fp, "<=");
-                            bound = glp_get_row_ub(lp,j);
-                          }
-
-                        break;
-                      }
-                    case GLP_FX:
-                      {
-                        fprintf(fp, "=");
-                        bound = glp_get_row_lb(lp,j);
-                        break;
-                      }
-                    }
-                  fprintf(fp," %d;\n",(int)bound);
-                }
-            }
-        }
-      xfree(ndx);
-      xfree(val);
-
-      if(constant)
-        {
-          xprintf(
-        "lpx_write_pb: adding constant objective function variable\n");
-
-          if(normalized)
-            fprintf(fp, "1 x%d = 1;\n", n+1);
-          else
-            fprintf(fp, "1*%s = 1;\n", objconstname);
-        }
-      if(emptylhs)
-        {
-          xprintf(
-            "lpx_write_pb: adding dummy variable for empty left-hand si"
-            "de constraint\n");
-
-          if(normalized)
-            fprintf(fp, "1 x%d = 0;\n", n+2);
-          else
-            fprintf(fp, "1*%s = 0;\n", emptylhsname);
-        }
-
-    }
-  else
-    {
-      xprintf("Problems opening file for writing: %s\n", fname);
-      return(1);
-    }
-  fflush(fp);
-  if (ferror(fp))
-    {  xprintf("lpx_write_pb: can't write to `%s' - %s\n", fname,
-               strerror(errno));
-    goto fail;
-    }
-  fclose(fp);
-
-
-  if(binarize)
-    {
-      /* delete the resultant problem object */
-      if (lp != NULL) lpx_delete_prob(lp);
-      /* delete MIP presolver workspace */
-      if (ipp != NULL) ipp_delete_wksp(ipp);
-      /*lp=tlp;*/
-    }
-  return 0;
- fail: if (fp != NULL) fclose(fp);
-  return 1;
-}
+#define spx_change_basis _glp_spx_change_basis
+void spx_change_basis(SPXLP *lp, int p, int p_flag, int q);
+/* change current basis to adjacent one */
+
+#define spx_update_invb _glp_spx_update_invb
+int spx_update_invb(SPXLP *lp, int i, int k);
+/* update factorization of basis matrix */
+
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpluf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spydual.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpluf.c (LU-factorization) */
+/* spydual.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2015-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,1834 +15,2085 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wself-assign"
-#pragma clang diagnostic ignored "-Wsign-conversion"
+#if 1 /* 18/VII-2017 */
+#define SCALE_Z 1
 #endif
 
-#include "glpenv.h"
-#include "glpluf.h"
-#define xfault xerror
+#include "env.h"
+#include "simplex.h"
+#include "spxat.h"
+#include "spxnt.h"
+#include "spxprob.h"
+#include "spychuzc.h"
+#include "spychuzr.h"
+#if 0 /* 11/VI-2017 */
+#if 1 /* 29/III-2016 */
+#include "fvs.h"
+#endif
+#endif
 
-/* CAUTION: DO NOT CHANGE THE LIMIT BELOW */
+#define CHECK_ACCURACY 0
+/* (for debugging) */
 
-#define N_MAX 100000000 /* = 100*10^6 */
-/* maximal order of the original matrix */
+struct csa
+{     /* common storage area */
+      SPXLP *lp;
+      /* LP problem data and its (current) basis; this LP has m rows
+       * and n columns */
+      int dir;
+      /* original optimization direction:
+       * +1 - minimization
+       * -1 - maximization */
+#if SCALE_Z
+      double fz;
+      /* factor used to scale original objective */
+#endif
+      double *orig_b; /* double orig_b[1+m]; */
+      /* copy of original right-hand sides */
+      double *orig_c; /* double orig_c[1+n]; */
+      /* copy of original objective coefficients */
+      double *orig_l; /* double orig_l[1+n]; */
+      /* copy of original lower bounds */
+      double *orig_u; /* double orig_u[1+n]; */
+      /* copy of original upper bounds */
+      SPXAT *at;
+      /* mxn-matrix A of constraint coefficients, in sparse row-wise
+       * format (NULL if not used) */
+      SPXNT *nt;
+      /* mx(n-m)-matrix N composed of non-basic columns of constraint
+       * matrix A, in sparse row-wise format (NULL if not used) */
+      int phase;
+      /* search phase:
+       * 0 - not determined yet
+       * 1 - searching for dual feasible solution
+       * 2 - searching for optimal solution */
+      double *beta; /* double beta[1+m]; */
+      /* beta[i] is primal value of basic variable xB[i] */
+      int beta_st;
+      /* status of the vector beta:
+       * 0 - undefined
+       * 1 - just computed
+       * 2 - updated */
+      double *d; /* double d[1+n-m]; */
+      /* d[j] is reduced cost of non-basic variable xN[j] */
+      int d_st;
+      /* status of the vector d:
+       * 0 - undefined
+       * 1 - just computed
+       * 2 - updated */
+      SPYSE *se;
+      /* dual projected steepest edge and Devex pricing data block
+       * (NULL if not used) */
+#if 0 /* 30/III-2016 */
+      int num;
+      /* number of eligible basic variables */
+      int *list; /* int list[1+m]; */
+      /* list[1], ..., list[num] are indices i of eligible basic
+       * variables xB[i] */
+#else
+      FVS r; /* FVS r[1:m]; */
+      /* vector of primal infeasibilities */
+      /* r->nnz = num; r->ind = list */
+      /* vector r has the same status as vector beta (see above) */
+#endif
+      int p;
+      /* xB[p] is a basic variable chosen to leave the basis */
+#if 0 /* 29/III-2016 */
+      double *trow; /* double trow[1+n-m]; */
+#else
+      FVS trow; /* FVS trow[1:n-m]; */
+#endif
+      /* p-th (pivot) row of the simplex table */
+#if 1 /* 16/III-2016 */
+      SPYBP *bp; /* SPYBP bp[1+n-m]; */
+      /* dual objective break-points */
+#endif
+      int q;
+      /* xN[q] is a non-basic variable chosen to enter the basis */
+#if 0 /* 29/III-2016 */
+      double *tcol; /* double tcol[1+m]; */
+#else
+      FVS tcol; /* FVS tcol[1:m]; */
+#endif
+      /* q-th (pivot) column of the simplex table */
+      double *work; /* double work[1+m]; */
+      /* working array */
+      double *work1; /* double work1[1+n-m]; */
+      /* another working array */
+#if 0 /* 11/VI-2017 */
+#if 1 /* 31/III-2016 */
+      FVS wrow; /* FVS wrow[1:n-m]; */
+      FVS wcol; /* FVS wcol[1:m]; */
+      /* working sparse vectors */
+#endif
+#endif
+      int p_stat, d_stat;
+      /* primal and dual solution statuses */
+      /*--------------------------------------------------------------*/
+      /* control parameters (see struct glp_smcp) */
+      int msg_lev;
+      /* message level */
+      int dualp;
+      /* if this flag is set, report failure in case of instability */
+#if 0 /* 16/III-2016 */
+      int harris;
+      /* dual ratio test technique:
+       * 0 - textbook ratio test
+       * 1 - Harris' two pass ratio test */
+#else
+      int r_test;
+      /* dual ratio test technique:
+       * GLP_RT_STD  - textbook ratio test
+       * GLP_RT_HAR  - Harris' two pass ratio test
+       * GLP_RT_FLIP - long-step (flip-flop) ratio test */
+#endif
+      double tol_bnd, tol_bnd1;
+      /* primal feasibility tolerances */
+      double tol_dj, tol_dj1;
+      /* dual feasibility tolerances */
+      double tol_piv;
+      /* pivot tolerance */
+      double obj_lim;
+      /* objective limit */
+      int it_lim;
+      /* iteration limit */
+      int tm_lim;
+      /* time limit, milliseconds */
+      int out_frq;
+#if 0 /* 15/VII-2017 */
+      /* display output frequency, iterations */
+#else
+      /* display output frequency, milliseconds */
+#endif
+      int out_dly;
+      /* display output delay, milliseconds */
+      /*--------------------------------------------------------------*/
+      /* working parameters */
+      double tm_beg;
+      /* time value at the beginning of the search */
+      int it_beg;
+      /* simplex iteration count at the beginning of the search */
+      int it_cnt;
+      /* simplex iteration count; it increases by one every time the
+       * basis changes */
+      int it_dpy;
+      /* simplex iteration count at most recent display output */
+#if 1 /* 15/VII-2017 */
+      double tm_dpy;
+      /* time value at most recent display output */
+#endif
+      int inv_cnt;
+      /* basis factorization count since most recent display output */
+#if 1 /* 11/VII-2017 */
+      int degen;
+      /* count of successive degenerate iterations; this count is used
+       * to detect stalling */
+#endif
+#if 1 /* 23/III-2016 */
+      int ns_cnt, ls_cnt;
+      /* normal and long-step iteration count */
+#endif
+};
 
 /***********************************************************************
-*  NAME
-*
-*  luf_create_it - create LU-factorization
+*  check_flags - check correctness of active bound flags
 *
-*  SYNOPSIS
+*  This routine checks that flags specifying active bounds of all
+*  non-basic variables are correct.
 *
-*  #include "glpluf.h"
-*  LUF *luf_create_it(void);
-*
-*  DESCRIPTION
-*
-*  The routine luf_create_it creates a program object, which represents
-*  LU-factorization of a square matrix.
-*
-*  RETURNS
-*
-*  The routine luf_create_it returns a pointer to the object created. */
-
-LUF *luf_create_it(void)
-{     LUF *luf;
-      luf = xmalloc(sizeof(LUF));
-      luf->n_max = luf->n = 0;
-      luf->valid = 0;
-      luf->fr_ptr = luf->fr_len = NULL;
-      luf->fc_ptr = luf->fc_len = NULL;
-      luf->vr_ptr = luf->vr_len = luf->vr_cap = NULL;
-      luf->vr_piv = NULL;
-      luf->vc_ptr = luf->vc_len = luf->vc_cap = NULL;
-      luf->pp_row = luf->pp_col = NULL;
-      luf->qq_row = luf->qq_col = NULL;
-      luf->sv_size = 0;
-      luf->sv_beg = luf->sv_end = 0;
-      luf->sv_ind = NULL;
-      luf->sv_val = NULL;
-      luf->sv_head = luf->sv_tail = 0;
-      luf->sv_prev = luf->sv_next = NULL;
-      luf->vr_max = NULL;
-      luf->rs_head = luf->rs_prev = luf->rs_next = NULL;
-      luf->cs_head = luf->cs_prev = luf->cs_next = NULL;
-      luf->flag = NULL;
-      luf->work = NULL;
-      luf->new_sva = 0;
-      luf->piv_tol = 0.10;
-      luf->piv_lim = 4;
-      luf->suhl = 1;
-      luf->eps_tol = 1e-15;
-      luf->max_gro = 1e+10;
-      luf->nnz_a = luf->nnz_f = luf->nnz_v = 0;
-      luf->max_a = luf->big_v = 0.0;
-      luf->rank = 0;
-      return luf;
+*  NOTE: It is important to note that if bounds of variables have been
+*  changed, active bound flags should be corrected accordingly. */
+
+static void check_flags(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      int j, k;
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)
+            xassert(!flag[j]);
+         else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)
+            xassert(!flag[j]);
+         else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)
+            xassert(flag[j]);
+         else if (l[k] == u[k])
+            xassert(!flag[j]);
+      }
+      return;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  luf_defrag_sva - defragment the sparse vector area
+*  set_art_bounds - set artificial right-hand sides and bounds
 *
-*  SYNOPSIS
-*
-*  #include "glpluf.h"
-*  void luf_defrag_sva(LUF *luf);
-*
-*  DESCRIPTION
-*
-*  The routine luf_defrag_sva defragments the sparse vector area (SVA)
-*  gathering all unused locations in one continuous extent. In order to
-*  do that the routine moves all unused locations from the left part of
-*  SVA (which contains rows and columns of the matrix V) to the middle
-*  part (which contains free locations). This is attained by relocating
-*  elements of rows and columns of the matrix V toward the beginning of
-*  the left part.
-*
-*  NOTE that this "garbage collection" involves changing row and column
-*  pointers of the matrix V. */
-
-void luf_defrag_sva(LUF *luf)
-{     int n = luf->n;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      int *vr_cap = luf->vr_cap;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *vc_cap = luf->vc_cap;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int *sv_next = luf->sv_next;
-      int sv_beg = 1;
+*  This routine sets artificial right-hand sides and artificial bounds
+*  for all variables to minimize the sum of dual infeasibilities on
+*  phase I. Given current reduced costs d = (d[j]) this routine also
+*  sets active artificial bounds of non-basic variables to provide dual
+*  feasibility (this is always possible because all variables have both
+*  lower and upper artificial bounds). */
+
+static void set_art_bounds(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *b = lp->b;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      double *d = csa->d;
       int i, j, k;
-      /* skip rows and columns, which do not need to be relocated */
-      for (k = luf->sv_head; k != 0; k = sv_next[k])
-      {  if (k <= n)
-         {  /* i-th row of the matrix V */
-            i = k;
-            if (vr_ptr[i] != sv_beg) break;
-            vr_cap[i] = vr_len[i];
-            sv_beg += vr_cap[i];
-         }
-         else
-         {  /* j-th column of the matrix V */
-            j = k - n;
-            if (vc_ptr[j] != sv_beg) break;
-            vc_cap[j] = vc_len[j];
-            sv_beg += vc_cap[j];
-         }
-      }
-      /* relocate other rows and columns in order to gather all unused
-         locations in one continuous extent */
-      for (k = k; k != 0; k = sv_next[k])
-      {  if (k <= n)
-         {  /* i-th row of the matrix V */
-            i = k;
-            memmove(&sv_ind[sv_beg], &sv_ind[vr_ptr[i]],
-               vr_len[i] * sizeof(int));
-            memmove(&sv_val[sv_beg], &sv_val[vr_ptr[i]],
-               vr_len[i] * sizeof(double));
-            vr_ptr[i] = sv_beg;
-            vr_cap[i] = vr_len[i];
-            sv_beg += vr_cap[i];
-         }
+#if 1 /* 31/III-2016: FIXME */
+      /* set artificial right-hand sides */
+      for (i = 1; i <= m; i++)
+         b[i] = 0.0;
+      /* set artificial bounds depending on types of variables */
+      for (k = 1; k <= n; k++)
+      {  if (csa->orig_l[k] == -DBL_MAX && csa->orig_u[k] == +DBL_MAX)
+         {  /* force free variables to enter the basis */
+            l[k] = -1e3, u[k] = +1e3;
+         }
+      else if (csa->orig_l[k] != -DBL_MAX && csa->orig_u[k] == +DBL_MAX)
+            l[k] = 0.0, u[k] = +1.0;
+      else if (csa->orig_l[k] == -DBL_MAX && csa->orig_u[k] != +DBL_MAX)
+            l[k] = -1.0, u[k] = 0.0;
          else
-         {  /* j-th column of the matrix V */
-            j = k - n;
-            memmove(&sv_ind[sv_beg], &sv_ind[vc_ptr[j]],
-               vc_len[j] * sizeof(int));
-            memmove(&sv_val[sv_beg], &sv_val[vc_ptr[j]],
-               vc_len[j] * sizeof(double));
-            vc_ptr[j] = sv_beg;
-            vc_cap[j] = vc_len[j];
-            sv_beg += vc_cap[j];
-         }
+            l[k] = u[k] = 0.0;
       }
-      /* set new pointer to the beginning of the free part */
-      luf->sv_beg = sv_beg;
+#endif
+      /* set active artificial bounds for non-basic variables */
+      xassert(csa->d_st == 1);
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         flag[j] = (l[k] != u[k] && d[j] < 0.0);
+      }
+      /* invalidate values of basic variables, since active bounds of
+       * non-basic variables have been changed */
+      csa->beta_st = 0;
       return;
 }
 
 /***********************************************************************
-*  NAME
+*  set_orig_bounds - restore original right-hand sides and bounds
 *
-*  luf_enlarge_row - enlarge row capacity
-*
-*  SYNOPSIS
+*  This routine restores original right-hand sides and original bounds
+*  for all variables. This routine also sets active original bounds for
+*  non-basic variables; for double-bounded non-basic variables current
+*  reduced costs d = (d[j]) are used to decide which bound (lower or
+*  upper) should be made active. */
+
+static void set_orig_bounds(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *b = lp->b;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      double *d = csa->d;
+      int j, k;
+      /* restore original right-hand sides */
+      memcpy(b, csa->orig_b, (1+m) * sizeof(double));
+      /* restore original bounds of all variables */
+      memcpy(l, csa->orig_l, (1+n) * sizeof(double));
+      memcpy(u, csa->orig_u, (1+n) * sizeof(double));
+      /* set active original bounds for non-basic variables */
+      xassert(csa->d_st == 1);
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)
+            flag[j] = 0;
+         else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)
+            flag[j] = 0;
+         else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)
+            flag[j] = 1;
+         else if (l[k] != u[k])
+            flag[j] = (d[j] < 0.0);
+         else
+            flag[j] = 0;
+      }
+      /* invalidate values of basic variables, since active bounds of
+       * non-basic variables have been changed */
+      csa->beta_st = 0;
+      return;
+}
+
+/***********************************************************************
+*  check_feas - check dual feasibility of basic solution
 *
-*  #include "glpluf.h"
-*  int luf_enlarge_row(LUF *luf, int i, int cap);
+*  This routine checks that reduced costs of all non-basic variables
+*  d = (d[j]) have correct signs.
 *
-*  DESCRIPTION
-*
-*  The routine luf_enlarge_row enlarges capacity of the i-th row of the
-*  matrix V to cap locations (assuming that its current capacity is less
-*  than cap). In order to do that the routine relocates elements of the
-*  i-th row to the end of the left part of SVA (which contains rows and
-*  columns of the matrix V) and then expands the left part by allocating
-*  cap free locations from the free part. If there are less than cap
-*  free locations, the routine defragments the sparse vector area.
-*
-*  Due to "garbage collection" this operation may change row and column
-*  pointers of the matrix V.
-*
-*  RETURNS
-*
-*  If no error occured, the routine returns zero. Otherwise, in case of
-*  overflow of the sparse vector area, the routine returns non-zero. */
-
-int luf_enlarge_row(LUF *luf, int i, int cap)
-{     int n = luf->n;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      int *vr_cap = luf->vr_cap;
-      int *vc_cap = luf->vc_cap;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int *sv_prev = luf->sv_prev;
-      int *sv_next = luf->sv_next;
-      int ret = 0;
-      int cur, k, kk;
-      xassert(1 <= i && i <= n);
-      xassert(vr_cap[i] < cap);
-      /* if there are less than cap free locations, defragment SVA */
-      if (luf->sv_end - luf->sv_beg < cap)
-      {  luf_defrag_sva(luf);
-         if (luf->sv_end - luf->sv_beg < cap)
-         {  ret = 1;
-            goto done;
-         }
-      }
-      /* save current capacity of the i-th row */
-      cur = vr_cap[i];
-      /* copy existing elements to the beginning of the free part */
-      memmove(&sv_ind[luf->sv_beg], &sv_ind[vr_ptr[i]],
-         vr_len[i] * sizeof(int));
-      memmove(&sv_val[luf->sv_beg], &sv_val[vr_ptr[i]],
-         vr_len[i] * sizeof(double));
-      /* set new pointer and new capacity of the i-th row */
-      vr_ptr[i] = luf->sv_beg;
-      vr_cap[i] = cap;
-      /* set new pointer to the beginning of the free part */
-      luf->sv_beg += cap;
-      /* now the i-th row starts in the rightmost location among other
-         rows and columns of the matrix V, so its node should be moved
-         to the end of the row/column linked list */
-      k = i;
-      /* remove the i-th row node from the linked list */
-      if (sv_prev[k] == 0)
-         luf->sv_head = sv_next[k];
-      else
-      {  /* capacity of the previous row/column can be increased at the
-            expense of old locations of the i-th row */
-         kk = sv_prev[k];
-         if (kk <= n) vr_cap[kk] += cur; else vc_cap[kk-n] += cur;
-         sv_next[sv_prev[k]] = sv_next[k];
+*  Reduced cost d[j] is considered as having correct sign within the
+*  specified tolerance depending on status of non-basic variable xN[j]
+*  if one of the following conditions is met:
+*
+*     xN[j] is free                       -eps <= d[j] <= +eps
+*
+*     xN[j] has its lower bound active    d[j] >= -eps
+*
+*     xN[j] has its upper bound active    d[j] <= +eps
+*
+*     xN[j] is fixed                      d[j] has any value
+*
+*  where eps = tol + tol1 * |cN[j]|, cN[j] is the objective coefficient
+*  at xN[j]. (See also the routine spx_chuzc_sel.)
+*
+*  The flag recov allows the routine to recover dual feasibility by
+*  changing active bounds of non-basic variables. (For example, if
+*  xN[j] has its lower bound active and d[j] < -eps, the feasibility
+*  can be recovered by making xN[j] active on its upper bound.)
+*
+*  If the basic solution is dual feasible, the routine returns zero.
+*  If the basic solution is dual infeasible, but its dual feasibility
+*  can be recovered (or has been recovered, if the flag recov is set),
+*  the routine returns a negative value. Otherwise, the routine returns
+*  the number j of some non-basic variable xN[j], whose reduced cost
+*  d[j] is dual infeasible and cannot be recovered. */
+
+static int check_feas(struct csa *csa, double tol, double tol1,
+      int recov)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      double *d = csa->d;
+      int j, k, ret = 0;
+      double eps;
+      /* reduced costs should be just computed */
+      xassert(csa->d_st == 1);
+      /* walk thru list of non-basic variables */
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         if (l[k] == u[k])
+         {  /* xN[j] is fixed variable; skip it */
+            continue;
+         }
+         /* determine absolute tolerance eps[j] */
+         eps = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);
+         /* check dual feasibility of xN[j] */
+         if (d[j] > +eps)
+         {  /* xN[j] should have its lower bound active */
+            if (l[k] == -DBL_MAX || flag[j])
+            {  /* but it either has no lower bound or its lower bound
+                * is inactive */
+               if (l[k] == -DBL_MAX)
+               {  /* cannot recover, since xN[j] has no lower bound */
+                  ret = j;
+                  break;
+               }
+               /* recovering is possible */
+               if (recov)
+                  flag[j] = 0;
+               ret = -1;
+            }
+         }
+         else if (d[j] < -eps)
+         {  /* xN[j] should have its upper bound active */
+            if (!flag[j])
+            {  /* but it either has no upper bound or its upper bound
+                * is inactive */
+               if (u[k] == +DBL_MAX)
+               {  /* cannot recover, since xN[j] has no upper bound */
+                  ret = j;
+                  break;
+               }
+               /* recovering is possible */
+               if (recov)
+                  flag[j] = 1;
+               ret = -1;
+            }
+         }
       }
-      if (sv_next[k] == 0)
-         luf->sv_tail = sv_prev[k];
-      else
-         sv_prev[sv_next[k]] = sv_prev[k];
-      /* insert the i-th row node to the end of the linked list */
-      sv_prev[k] = luf->sv_tail;
-      sv_next[k] = 0;
-      if (sv_prev[k] == 0)
-         luf->sv_head = k;
-      else
-         sv_next[sv_prev[k]] = k;
-      luf->sv_tail = k;
-done: return ret;
+      if (recov && ret)
+      {  /* invalidate values of basic variables, since active bounds
+          * of non-basic variables have been changed */
+         csa->beta_st = 0;
+      }
+      return ret;
 }
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  NAME
+*  err_in_vec - compute maximal relative error between two vectors
 *
-*  luf_enlarge_col - enlarge column capacity
+*  This routine computes and returns maximal relative error between
+*  n-vectors x and y:
 *
-*  SYNOPSIS
+*     err_max = max |x[i] - y[i]| / (1 + |x[i]|).
 *
-*  #include "glpluf.h"
-*  int luf_enlarge_col(LUF *luf, int j, int cap);
+*  NOTE: This routine is intended only for debugging purposes. */
+
+static double err_in_vec(int n, const double x[], const double y[])
+{     int i;
+      double err, err_max;
+      err_max = 0.0;
+      for (i = 1; i <= n; i++)
+      {  err = fabs(x[i] - y[i]) / (1.0 + fabs(x[i]));
+         if (err_max < err)
+            err_max = err;
+      }
+      return err_max;
+}
+#endif
+
+#if CHECK_ACCURACY
+/***********************************************************************
+*  err_in_beta - compute maximal relative error in vector beta
 *
-*  DESCRIPTION
-*
-*  The routine luf_enlarge_col enlarges capacity of the j-th column of
-*  the matrix V to cap locations (assuming that its current capacity is
-*  less than cap). In order to do that the routine relocates elements
-*  of the j-th column to the end of the left part of SVA (which contains
-*  rows and columns of the matrix V) and then expands the left part by
-*  allocating cap free locations from the free part. If there are less
-*  than cap free locations, the routine defragments the sparse vector
-*  area.
-*
-*  Due to "garbage collection" this operation may change row and column
-*  pointers of the matrix V.
-*
-*  RETURNS
-*
-*  If no error occured, the routine returns zero. Otherwise, in case of
-*  overflow of the sparse vector area, the routine returns non-zero. */
-
-int luf_enlarge_col(LUF *luf, int j, int cap)
-{     int n = luf->n;
-      int *vr_cap = luf->vr_cap;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *vc_cap = luf->vc_cap;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int *sv_prev = luf->sv_prev;
-      int *sv_next = luf->sv_next;
-      int ret = 0;
-      int cur, k, kk;
-      xassert(1 <= j && j <= n);
-      xassert(vc_cap[j] < cap);
-      /* if there are less than cap free locations, defragment SVA */
-      if (luf->sv_end - luf->sv_beg < cap)
-      {  luf_defrag_sva(luf);
-         if (luf->sv_end - luf->sv_beg < cap)
-         {  ret = 1;
-            goto done;
-         }
-      }
-      /* save current capacity of the j-th column */
-      cur = vc_cap[j];
-      /* copy existing elements to the beginning of the free part */
-      memmove(&sv_ind[luf->sv_beg], &sv_ind[vc_ptr[j]],
-         vc_len[j] * sizeof(int));
-      memmove(&sv_val[luf->sv_beg], &sv_val[vc_ptr[j]],
-         vc_len[j] * sizeof(double));
-      /* set new pointer and new capacity of the j-th column */
-      vc_ptr[j] = luf->sv_beg;
-      vc_cap[j] = cap;
-      /* set new pointer to the beginning of the free part */
-      luf->sv_beg += cap;
-      /* now the j-th column starts in the rightmost location among
-         other rows and columns of the matrix V, so its node should be
-         moved to the end of the row/column linked list */
-      k = n + j;
-      /* remove the j-th column node from the linked list */
-      if (sv_prev[k] == 0)
-         luf->sv_head = sv_next[k];
-      else
-      {  /* capacity of the previous row/column can be increased at the
-            expense of old locations of the j-th column */
-         kk = sv_prev[k];
-         if (kk <= n) vr_cap[kk] += cur; else vc_cap[kk-n] += cur;
-         sv_next[sv_prev[k]] = sv_next[k];
+*  This routine computes and returns maximal relative error in vector
+*  of values of basic variables beta = (beta[i]).
+*
+*  NOTE: This routine is intended only for debugging purposes. */
+
+static double err_in_beta(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      double err, *beta;
+      beta = talloc(1+m, double);
+      spx_eval_beta(lp, beta);
+      err = err_in_vec(m, beta, csa->beta);
+      tfree(beta);
+      return err;
+}
+#endif
+
+#if CHECK_ACCURACY
+static double err_in_r(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int i, k;
+      double err, *r;
+      r = talloc(1+m, double);
+      for (i = 1; i <= m; i++)
+      {  k = lp->head[i];
+         if (csa->beta[i] < lp->l[k])
+            r[i] = lp->l[k] - csa->beta[i];
+         else if (csa->beta[i] > lp->u[k])
+            r[i] = lp->u[k] - csa->beta[i];
+         else
+            r[i] = 0.0;
+
+if (fabs(r[i] - csa->r.vec[i]) > 1e-6)
+printf("i = %d; r = %g; csa->r = %g\n", i, r[i], csa->r.vec[i]);
+
+
       }
-      if (sv_next[k] == 0)
-         luf->sv_tail = sv_prev[k];
-      else
-         sv_prev[sv_next[k]] = sv_prev[k];
-      /* insert the j-th column node to the end of the linked list */
-      sv_prev[k] = luf->sv_tail;
-      sv_next[k] = 0;
-      if (sv_prev[k] == 0)
-         luf->sv_head = k;
-      else
-         sv_next[sv_prev[k]] = k;
-      luf->sv_tail = k;
-done: return ret;
+      err = err_in_vec(m, r, csa->r.vec);
+      tfree(r);
+      return err;
 }
+#endif
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  reallocate - reallocate LU-factorization arrays
+*  err_in_d - compute maximal relative error in vector d
 *
-*  This routine reallocates arrays, whose size depends of n, the order
-*  of the matrix A to be factorized. */
+*  This routine computes and returns maximal relative error in vector
+*  of reduced costs of non-basic variables d = (d[j]).
+*
+*  NOTE: This routine is intended only for debugging purposes. */
 
-static void reallocate(LUF *luf, int n)
-{     int n_max = luf->n_max;
-      luf->n = n;
-      if (n <= n_max) goto done;
-      if (luf->fr_ptr != NULL) xfree(luf->fr_ptr);
-      if (luf->fr_len != NULL) xfree(luf->fr_len);
-      if (luf->fc_ptr != NULL) xfree(luf->fc_ptr);
-      if (luf->fc_len != NULL) xfree(luf->fc_len);
-      if (luf->vr_ptr != NULL) xfree(luf->vr_ptr);
-      if (luf->vr_len != NULL) xfree(luf->vr_len);
-      if (luf->vr_cap != NULL) xfree(luf->vr_cap);
-      if (luf->vr_piv != NULL) xfree(luf->vr_piv);
-      if (luf->vc_ptr != NULL) xfree(luf->vc_ptr);
-      if (luf->vc_len != NULL) xfree(luf->vc_len);
-      if (luf->vc_cap != NULL) xfree(luf->vc_cap);
-      if (luf->pp_row != NULL) xfree(luf->pp_row);
-      if (luf->pp_col != NULL) xfree(luf->pp_col);
-      if (luf->qq_row != NULL) xfree(luf->qq_row);
-      if (luf->qq_col != NULL) xfree(luf->qq_col);
-      if (luf->sv_prev != NULL) xfree(luf->sv_prev);
-      if (luf->sv_next != NULL) xfree(luf->sv_next);
-      if (luf->vr_max != NULL) xfree(luf->vr_max);
-      if (luf->rs_head != NULL) xfree(luf->rs_head);
-      if (luf->rs_prev != NULL) xfree(luf->rs_prev);
-      if (luf->rs_next != NULL) xfree(luf->rs_next);
-      if (luf->cs_head != NULL) xfree(luf->cs_head);
-      if (luf->cs_prev != NULL) xfree(luf->cs_prev);
-      if (luf->cs_next != NULL) xfree(luf->cs_next);
-      if (luf->flag != NULL) xfree(luf->flag);
-      if (luf->work != NULL) xfree(luf->work);
-      luf->n_max = n_max = n + 100;
-      luf->fr_ptr = xcalloc(1+n_max, sizeof(int));
-      luf->fr_len = xcalloc(1+n_max, sizeof(int));
-      luf->fc_ptr = xcalloc(1+n_max, sizeof(int));
-      luf->fc_len = xcalloc(1+n_max, sizeof(int));
-      luf->vr_ptr = xcalloc(1+n_max, sizeof(int));
-      luf->vr_len = xcalloc(1+n_max, sizeof(int));
-      luf->vr_cap = xcalloc(1+n_max, sizeof(int));
-      luf->vr_piv = xcalloc(1+n_max, sizeof(double));
-      luf->vc_ptr = xcalloc(1+n_max, sizeof(int));
-      luf->vc_len = xcalloc(1+n_max, sizeof(int));
-      luf->vc_cap = xcalloc(1+n_max, sizeof(int));
-      luf->pp_row = xcalloc(1+n_max, sizeof(int));
-      luf->pp_col = xcalloc(1+n_max, sizeof(int));
-      luf->qq_row = xcalloc(1+n_max, sizeof(int));
-      luf->qq_col = xcalloc(1+n_max, sizeof(int));
-      luf->sv_prev = xcalloc(1+n_max+n_max, sizeof(int));
-      luf->sv_next = xcalloc(1+n_max+n_max, sizeof(int));
-      luf->vr_max = xcalloc(1+n_max, sizeof(double));
-      luf->rs_head = xcalloc(1+n_max, sizeof(int));
-      luf->rs_prev = xcalloc(1+n_max, sizeof(int));
-      luf->rs_next = xcalloc(1+n_max, sizeof(int));
-      luf->cs_head = xcalloc(1+n_max, sizeof(int));
-      luf->cs_prev = xcalloc(1+n_max, sizeof(int));
-      luf->cs_next = xcalloc(1+n_max, sizeof(int));
-      luf->flag = xcalloc(1+n_max, sizeof(int));
-      luf->work = xcalloc(1+n_max, sizeof(double));
-done: return;
+static double err_in_d(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      int j;
+      double err, *pi, *d;
+      pi = talloc(1+m, double);
+      d = talloc(1+n-m, double);
+      spx_eval_pi(lp, pi);
+      for (j = 1; j <= n-m; j++)
+         d[j] = spx_eval_dj(lp, pi, j);
+      err = err_in_vec(n-m, d, csa->d);
+      tfree(pi);
+      tfree(d);
+      return err;
 }
+#endif
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  initialize - initialize LU-factorization data structures
+*  err_in_gamma - compute maximal relative error in vector gamma
 *
-*  This routine initializes data structures for subsequent computing
-*  the LU-factorization of a given matrix A, which is specified by the
-*  formal routine col. On exit V = A and F = P = Q = I, where I is the
-*  unity matrix. (Row-wise representation of the matrix F is not used
-*  at the factorization stage and therefore is not initialized.)
-*
-*  If no error occured, the routine returns zero. Otherwise, in case of
-*  overflow of the sparse vector area, the routine returns non-zero. */
-
-static int initialize(LUF *luf, int (*col)(void *info, int j, int rn[],
-      double aj[]), void *info)
-{     int n = luf->n;
-      int *fc_ptr = luf->fc_ptr;
-      int *fc_len = luf->fc_len;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      int *vr_cap = luf->vr_cap;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *vc_cap = luf->vc_cap;
-      int *pp_row = luf->pp_row;
-      int *pp_col = luf->pp_col;
-      int *qq_row = luf->qq_row;
-      int *qq_col = luf->qq_col;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int *sv_prev = luf->sv_prev;
-      int *sv_next = luf->sv_next;
-      double *vr_max = luf->vr_max;
-      int *rs_head = luf->rs_head;
-      int *rs_prev = luf->rs_prev;
-      int *rs_next = luf->rs_next;
-      int *cs_head = luf->cs_head;
-      int *cs_prev = luf->cs_prev;
-      int *cs_next = luf->cs_next;
-      int *flag = luf->flag;
-      double *work = luf->work;
-      int ret = 0;
-      int i, i_ptr, j, j_beg, j_end, k, len, nnz, sv_beg, sv_end, ptr;
-      double big, val;
-      /* free all locations of the sparse vector area */
-      sv_beg = 1;
-      sv_end = luf->sv_size + 1;
-      /* (row-wise representation of the matrix F is not initialized,
-         because it is not used at the factorization stage) */
-      /* build the matrix F in column-wise format (initially F = I) */
-      for (j = 1; j <= n; j++)
-      {  fc_ptr[j] = sv_end;
-         fc_len[j] = 0;
-      }
-      /* clear rows of the matrix V; clear the flag array */
-      for (i = 1; i <= n; i++)
-         vr_len[i] = vr_cap[i] = 0, flag[i] = 0;
-      /* build the matrix V in column-wise format (initially V = A);
-         count non-zeros in rows of this matrix; count total number of
-         non-zeros; compute largest of absolute values of elements */
-      nnz = 0;
-      big = 0.0;
-      for (j = 1; j <= n; j++)
-      {  int *rn = pp_row;
-         double *aj = work;
-         /* obtain j-th column of the matrix A */
-         len = col(info, j, rn, aj);
-         if (!(0 <= len && len <= n))
-            xfault("luf_factorize: j = %d; len = %d; invalid column len"
-               "gth\n", j, len);
-         /* check for free locations */
-         if (sv_end - sv_beg < len)
-         {  /* overflow of the sparse vector area */
-            ret = 1;
-            goto done;
-         }
-         /* set pointer to the j-th column */
-         vc_ptr[j] = sv_beg;
-         /* set length of the j-th column */
-         vc_len[j] = vc_cap[j] = len;
-         /* count total number of non-zeros */
-         nnz += len;
-         /* walk through elements of the j-th column */
-         for (ptr = 1; ptr <= len; ptr++)
-         {  /* get row index and numerical value of a[i,j] */
-            i = rn[ptr];
-            val = aj[ptr];
-            if (!(1 <= i && i <= n))
-               xfault("luf_factorize: i = %d; j = %d; invalid row index"
-                  "\n", i, j);
-            if (flag[i])
-               xfault("luf_factorize: i = %d; j = %d; duplicate element"
-                  " not allowed\n", i, j);
-            if (val == 0.0)
-               xfault("luf_factorize: i = %d; j = %d; zero element not "
-                  "allowed\n", i, j);
-            /* add new element v[i,j] = a[i,j] to j-th column */
-            sv_ind[sv_beg] = i;
-            sv_val[sv_beg] = val;
-            sv_beg++;
-            /* big := max(big, |a[i,j]|) */
-            if (val < 0.0) val = - val;
-            if (big < val) big = val;
-            /* mark non-zero in the i-th position of the j-th column */
-            flag[i] = 1;
-            /* increase length of the i-th row */
-            vr_cap[i]++;
-         }
-         /* reset all non-zero marks */
-         for (ptr = 1; ptr <= len; ptr++) flag[rn[ptr]] = 0;
-      }
-      /* allocate rows of the matrix V */
-      for (i = 1; i <= n; i++)
-      {  /* get length of the i-th row */
-         len = vr_cap[i];
-         /* check for free locations */
-         if (sv_end - sv_beg < len)
-         {  /* overflow of the sparse vector area */
-            ret = 1;
-            goto done;
-         }
-         /* set pointer to the i-th row */
-         vr_ptr[i] = sv_beg;
-         /* reserve locations for the i-th row */
-         sv_beg += len;
-      }
-      /* build the matrix V in row-wise format using representation of
-         this matrix in column-wise format */
-      for (j = 1; j <= n; j++)
-      {  /* walk through elements of the j-th column */
-         j_beg = vc_ptr[j];
-         j_end = j_beg + vc_len[j] - 1;
-         for (k = j_beg; k <= j_end; k++)
-         {  /* get row index and numerical value of v[i,j] */
-            i = sv_ind[k];
-            val = sv_val[k];
-            /* store element in the i-th row */
-            i_ptr = vr_ptr[i] + vr_len[i];
-            sv_ind[i_ptr] = j;
-            sv_val[i_ptr] = val;
-            /* increase count of the i-th row */
-            vr_len[i]++;
-         }
-      }
-      /* initialize the matrices P and Q (initially P = Q = I) */
-      for (k = 1; k <= n; k++)
-         pp_row[k] = pp_col[k] = qq_row[k] = qq_col[k] = k;
-      /* set sva partitioning pointers */
-      luf->sv_beg = sv_beg;
-      luf->sv_end = sv_end;
-      /* the initial physical order of rows and columns of the matrix V
-         is n+1, ..., n+n, 1, ..., n (firstly columns, then rows) */
-      luf->sv_head = n+1;
-      luf->sv_tail = n;
-      for (i = 1; i <= n; i++)
-      {  sv_prev[i] = i-1;
-         sv_next[i] = i+1;
-      }
-      sv_prev[1] = n+n;
-      sv_next[n] = 0;
-      for (j = 1; j <= n; j++)
-      {  sv_prev[n+j] = n+j-1;
-         sv_next[n+j] = n+j+1;
-      }
-      sv_prev[n+1] = 0;
-      sv_next[n+n] = 1;
-      /* clear working arrays */
-      for (k = 1; k <= n; k++)
-      {  flag[k] = 0;
-         work[k] = 0.0;
-      }
-      /* initialize some statistics */
-      luf->nnz_a = nnz;
-      luf->nnz_f = 0;
-      luf->nnz_v = nnz;
-      luf->max_a = big;
-      luf->big_v = big;
-      luf->rank = -1;
-      /* initially the active submatrix is the entire matrix V */
-      /* largest of absolute values of elements in each active row is
-         unknown yet */
-      for (i = 1; i <= n; i++) vr_max[i] = -1.0;
-      /* build linked lists of active rows */
-      for (len = 0; len <= n; len++) rs_head[len] = 0;
-      for (i = 1; i <= n; i++)
-      {  len = vr_len[i];
-         rs_prev[i] = 0;
-         rs_next[i] = rs_head[len];
-         if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;
-         rs_head[len] = i;
-      }
-      /* build linked lists of active columns */
-      for (len = 0; len <= n; len++) cs_head[len] = 0;
-      for (j = 1; j <= n; j++)
-      {  len = vc_len[j];
-         cs_prev[j] = 0;
-         cs_next[j] = cs_head[len];
-         if (cs_next[j] != 0) cs_prev[cs_next[j]] = j;
-         cs_head[len] = j;
-      }
-done: /* return to the factorizing routine */
-      return ret;
+*  This routine computes and returns maximal relative error in vector
+*  of projected steepest edge weights gamma = (gamma[j]).
+*
+*  NOTE: This routine is intended only for debugging purposes. */
+
+static double err_in_gamma(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      SPYSE *se = csa->se;
+      int i;
+      double err, *gamma;
+      xassert(se != NULL);
+gamma = talloc(1+m, double);
+      for (i = 1; i <= m; i++)
+         gamma[i] = spy_eval_gamma_i(lp, se, i);
+      err = err_in_vec(m, gamma, se->gamma);
+      tfree(gamma);
+      return err;
 }
+#endif
 
+#if CHECK_ACCURACY
 /***********************************************************************
-*  find_pivot - choose a pivot element
+*  check_accuracy - check accuracy of basic solution components
 *
-*  This routine chooses a pivot element in the active submatrix of the
-*  matrix U = P*V*Q.
+*  This routine checks accuracy of current basic solution components.
 *
-*  It is assumed that on entry the matrix U has the following partially
-*  triangularized form:
-* 
-*        1       k         n
-*     1  x x x x x x x x x x
-*        . x x x x x x x x x
-*        . . x x x x x x x x
-*        . . . x x x x x x x
-*     k  . . . . * * * * * *
-*        . . . . * * * * * *
-*        . . . . * * * * * *
-*        . . . . * * * * * *
-*        . . . . * * * * * *
-*     n  . . . . * * * * * *
-* 
-*  where rows and columns k, k+1, ..., n belong to the active submatrix
-*  (elements of the active submatrix are marked by '*').
-*
-*  Since the matrix U = P*V*Q is not stored, the routine works with the
-*  matrix V. It is assumed that the row-wise representation corresponds
-*  to the matrix V, but the column-wise representation corresponds to
-*  the active submatrix of the matrix V, i.e. elements of the matrix V,
-*  which doesn't belong to the active submatrix, are missing from the
-*  column linked lists. It is also assumed that each active row of the
-*  matrix V is in the set R[len], where len is number of non-zeros in
-*  the row, and each active column of the matrix V is in the set C[len],
-*  where len is number of non-zeros in the column (in the latter case
-*  only elements of the active submatrix are counted; such elements are
-*  marked by '*' on the figure above).
-* 
-*  For the reason of numerical stability the routine applies so called
-*  threshold pivoting proposed by J.Reid. It is assumed that an element
-*  v[i,j] can be selected as a pivot candidate if it is not very small
-*  (in absolute value) among other elements in the same row, i.e. if it
-*  satisfies to the stability condition |v[i,j]| >= tol * max|v[i,*]|,
-*  where 0 < tol < 1 is a given tolerance.
-* 
-*  In order to keep sparsity of the matrix V the routine uses Markowitz
-*  strategy, trying to choose such element v[p,q], which satisfies to
-*  the stability condition (see above) and has smallest Markowitz cost
-*  (nr[p]-1) * (nc[q]-1), where nr[p] and nc[q] are numbers of non-zero
-*  elements, respectively, in the p-th row and in the q-th column of the
-*  active submatrix.
-* 
-*  In order to reduce the search, i.e. not to walk through all elements
-*  of the active submatrix, the routine exploits a technique proposed by
-*  I.Duff. This technique is based on using the sets R[len] and C[len]
-*  of active rows and columns.
-* 
-*  If the pivot element v[p,q] has been chosen, the routine stores its
-*  indices to the locations *p and *q and returns zero. Otherwise, if
-*  the active submatrix is empty and therefore the pivot element can't
-*  be chosen, the routine returns non-zero. */
-
-static int find_pivot(LUF *luf, int *_p, int *_q)
-{     int n = luf->n;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      double *vr_max = luf->vr_max;
-      int *rs_head = luf->rs_head;
-      int *rs_next = luf->rs_next;
-      int *cs_head = luf->cs_head;
-      int *cs_prev = luf->cs_prev;
-      int *cs_next = luf->cs_next;
-      double piv_tol = luf->piv_tol;
-      int piv_lim = luf->piv_lim;
-      int suhl = luf->suhl;
-      int p, q, len, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr,
-         ncand, next_j, min_p, min_q, min_len;
-      double best, cost, big, temp;
-      /* initially no pivot candidates have been found so far */
-      p = q = 0, best = DBL_MAX, ncand = 0;
-      /* if in the active submatrix there is a column that has the only
-         non-zero (column singleton), choose it as pivot */
-      j = cs_head[1];
-      if (j != 0)
-      {  xassert(vc_len[j] == 1);
-         p = sv_ind[vc_ptr[j]], q = j;
-         goto done;
-      }
-      /* if in the active submatrix there is a row that has the only
-         non-zero (row singleton), choose it as pivot */
-      i = rs_head[1];
-      if (i != 0)
-      {  xassert(vr_len[i] == 1);
-         p = i, q = sv_ind[vr_ptr[i]];
-         goto done;
-      }
-      /* there are no singletons in the active submatrix; walk through
-         other non-empty rows and columns */
-      for (len = 2; len <= n; len++)
-      {  /* consider active columns that have len non-zeros */
-         for (j = cs_head[len]; j != 0; j = next_j)
-         {  /* the j-th column has len non-zeros */
-            j_beg = vc_ptr[j];
-            j_end = j_beg + vc_len[j] - 1;
-            /* save pointer to the next column with the same length */
-            next_j = cs_next[j];
-            /* find an element in the j-th column, which is placed in a
-               row with minimal number of non-zeros and satisfies to the
-               stability condition (such element may not exist) */
-            min_p = min_q = 0, min_len = INT_MAX;
-            for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
-            {  /* get row index of v[i,j] */
-               i = sv_ind[j_ptr];
-               i_beg = vr_ptr[i];
-               i_end = i_beg + vr_len[i] - 1;
-               /* if the i-th row is not shorter than that one, where
-                  minimal element is currently placed, skip v[i,j] */
-               if (vr_len[i] >= min_len) continue;
-               /* determine the largest of absolute values of elements
-                  in the i-th row */
-               big = vr_max[i];
-               if (big < 0.0)
-               {  /* the largest value is unknown yet; compute it */
-                  for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-                  {  temp = sv_val[i_ptr];
-                     if (temp < 0.0) temp = - temp;
-                     if (big < temp) big = temp;
-                  }
-                  vr_max[i] = big;
-               }
-               /* find v[i,j] in the i-th row */
-               for (i_ptr = vr_ptr[i]; sv_ind[i_ptr] != j; i_ptr++);
-               xassert(i_ptr <= i_end);
-               /* if v[i,j] doesn't satisfy to the stability condition,
-                  skip it */
-               temp = sv_val[i_ptr];
-               if (temp < 0.0) temp = - temp;
-               if (temp < piv_tol * big) continue;
-               /* v[i,j] is better than the current minimal element */
-               min_p = i, min_q = j, min_len = vr_len[i];
-               /* if Markowitz cost of the current minimal element is
-                  not greater than (len-1)**2, it can be chosen right
-                  now; this heuristic reduces the search and works well
-                  in many cases */
-               if (min_len <= len)
-               {  p = min_p, q = min_q;
-                  goto done;
-               }
-            }
-            /* the j-th column has been scanned */
-            if (min_p != 0)
-            {  /* the minimal element is a next pivot candidate */
-               ncand++;
-               /* compute its Markowitz cost */
-               cost = (double)(min_len - 1) * (double)(len - 1);
-               /* choose between the minimal element and the current
-                  candidate */
-               if (cost < best) p = min_p, q = min_q, best = cost;
-               /* if piv_lim candidates have been considered, there are
-                  doubts that a much better candidate exists; therefore
-                  it's time to terminate the search */
-               if (ncand == piv_lim) goto done;
-            }
-            else
-            {  /* the j-th column has no elements, which satisfy to the
-                  stability condition; Uwe Suhl suggests to exclude such
-                  column from the further consideration until it becomes
-                  a column singleton; in hard cases this significantly
-                  reduces a time needed for pivot searching */
-               if (suhl)
-               {  /* remove the j-th column from the active set */
-                  if (cs_prev[j] == 0)
-                     cs_head[len] = cs_next[j];
-                  else
-                     cs_next[cs_prev[j]] = cs_next[j];
-                  if (cs_next[j] == 0)
-                     /* nop */;
-                  else
-                     cs_prev[cs_next[j]] = cs_prev[j];
-                  /* the following assignment is used to avoid an error
-                     when the routine eliminate (see below) will try to
-                     remove the j-th column from the active set */
-                  cs_prev[j] = cs_next[j] = j;
-               }
+*  NOTE: This routine is intended only for debugging purposes. */
+
+static void check_accuracy(struct csa *csa)
+{     double e_beta, e_r, e_d, e_gamma;
+      e_beta = err_in_beta(csa);
+      e_r = err_in_r(csa);
+      e_d = err_in_d(csa);
+      if (csa->se == NULL)
+         e_gamma = 0.;
+      else
+         e_gamma = err_in_gamma(csa);
+      xprintf("e_beta = %10.3e; e_r = %10.3e; e_d = %10.3e; e_gamma = %"
+         "10.3e\n", e_beta, e_r, e_d, e_gamma);
+      xassert(e_beta <= 1e-5 && e_d <= 1e-5 && e_gamma <= 1e-3);
+      return;
+}
+#endif
+
+#if 1 /* 30/III-2016 */
+static
+void spy_eval_r(SPXLP *lp, const double beta[/*1+m*/], double tol,
+      double tol1, FVS *r)
+{     /* this routine computes the vector of primal infeasibilities:
+       *
+       *        ( lB[i] - beta[i] > 0, if beta[i] < lb[i]
+       * r[i] = { 0,                   if lb[i] <= beta[i] <= ub[i]
+       *        ( ub[i] - beta[i] < 0, if beta[i] > ub[i]
+       *
+       * (this routine replaces spy_chuzr_sel) */
+      int m = lp->m;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      int *ind = r->ind;
+      double *vec = r->vec;
+      int i, k, nnz = 0;
+      double lk, uk, eps;
+      xassert(r->n == m);
+      /* walk thru the list of basic variables */
+      for (i = 1; i <= m; i++)
+      {  vec[i] = 0.0;
+         k = head[i]; /* x[k] = xB[i] */
+         lk = l[k], uk = u[k];
+         /* check primal feasibility */
+         if (beta[i] < lk)
+         {  /* determine absolute tolerance eps1[i] */
+            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
+            if (beta[i] < lk - eps)
+            {  /* lower bound is violated */
+               ind[++nnz] = i;
+               vec[i] = lk - beta[i];
             }
          }
-         /* consider active rows that have len non-zeros */
-         for (i = rs_head[len]; i != 0; i = rs_next[i])
-         {  /* the i-th row has len non-zeros */
-            i_beg = vr_ptr[i];
-            i_end = i_beg + vr_len[i] - 1;
-            /* determine the largest of absolute values of elements in
-               the i-th row */
-            big = vr_max[i];
-            if (big < 0.0)
-            {  /* the largest value is unknown yet; compute it */
-               for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-               {  temp = sv_val[i_ptr];
-                  if (temp < 0.0) temp = - temp;
-                  if (big < temp) big = temp;
-               }
-               vr_max[i] = big;
-            }
-            /* find an element in the i-th row, which is placed in a
-               column with minimal number of non-zeros and satisfies to
-               the stability condition (such element always exists) */
-            min_p = min_q = 0, min_len = INT_MAX;
-            for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-            {  /* get column index of v[i,j] */
-               j = sv_ind[i_ptr];
-               /* if the j-th column is not shorter than that one, where
-                  minimal element is currently placed, skip v[i,j] */
-               if (vc_len[j] >= min_len) continue;
-               /* if v[i,j] doesn't satisfy to the stability condition,
-                  skip it */
-               temp = sv_val[i_ptr];
-               if (temp < 0.0) temp = - temp;
-               if (temp < piv_tol * big) continue;
-               /* v[i,j] is better than the current minimal element */
-               min_p = i, min_q = j, min_len = vc_len[j];
-               /* if Markowitz cost of the current minimal element is
-                  not greater than (len-1)**2, it can be chosen right
-                  now; this heuristic reduces the search and works well
-                  in many cases */
-               if (min_len <= len)
-               {  p = min_p, q = min_q;
-                  goto done;
-               }
-            }
-            /* the i-th row has been scanned */
-            if (min_p != 0)
-            {  /* the minimal element is a next pivot candidate */
-               ncand++;
-               /* compute its Markowitz cost */
-               cost = (double)(len - 1) * (double)(min_len - 1);
-               /* choose between the minimal element and the current
-                  candidate */
-               if (cost < best) p = min_p, q = min_q, best = cost;
-               /* if piv_lim candidates have been considered, there are
-                  doubts that a much better candidate exists; therefore
-                  it's time to terminate the search */
-               if (ncand == piv_lim) goto done;
-            }
-            else
-            {  /* this can't be because this can never be */
-               xassert(min_p != min_p);
+         else if (beta[i] > uk)
+         {  /* determine absolute tolerance eps2[i] */
+            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
+            if (beta[i] > uk + eps)
+            {  /* upper bound is violated */
+               ind[++nnz] = i;
+               vec[i] = uk - beta[i];
             }
          }
       }
-done: /* bring the pivot to the factorizing routine */
-      *_p = p, *_q = q;
-      return (p == 0);
+      r->nnz = nnz;
+      return;
 }
+#endif
 
 /***********************************************************************
-*  eliminate - perform gaussian elimination.
-* 
-*  This routine performs elementary gaussian transformations in order
-*  to eliminate subdiagonal elements in the k-th column of the matrix
-*  U = P*V*Q using the pivot element u[k,k], where k is the number of
-*  the current elimination step.
-* 
-*  The parameters p and q are, respectively, row and column indices of
-*  the element v[p,q], which corresponds to the element u[k,k].
-* 
-*  Each time when the routine applies the elementary transformation to
-*  a non-pivot row of the matrix V, it stores the corresponding element
-*  to the matrix F in order to keep the main equality A = F*V.
-* 
-*  The routine assumes that on entry the matrices L = P*F*inv(P) and
-*  U = P*V*Q are the following:
-* 
-*        1       k                  1       k         n
-*     1  1 . . . . . . . . .     1  x x x x x x x x x x
-*        x 1 . . . . . . . .        . x x x x x x x x x
-*        x x 1 . . . . . . .        . . x x x x x x x x
-*        x x x 1 . . . . . .        . . . x x x x x x x
-*     k  x x x x 1 . . . . .     k  . . . . * * * * * *
-*        x x x x _ 1 . . . .        . . . . # * * * * *
-*        x x x x _ . 1 . . .        . . . . # * * * * *
-*        x x x x _ . . 1 . .        . . . . # * * * * *
-*        x x x x _ . . . 1 .        . . . . # * * * * *
-*     n  x x x x _ . . . . 1     n  . . . . # * * * * *
-* 
-*             matrix L                   matrix U
-* 
-*  where rows and columns of the matrix U with numbers k, k+1, ..., n
-*  form the active submatrix (eliminated elements are marked by '#' and
-*  other elements of the active submatrix are marked by '*'). Note that
-*  each eliminated non-zero element u[i,k] of the matrix U gives the
-*  corresponding element l[i,k] of the matrix L (marked by '_').
-* 
-*  Actually all operations are performed on the matrix V. Should note
-*  that the row-wise representation corresponds to the matrix V, but the
-*  column-wise representation corresponds to the active submatrix of the
-*  matrix V, i.e. elements of the matrix V, which doesn't belong to the
-*  active submatrix, are missing from the column linked lists.
-* 
-*  Let u[k,k] = v[p,q] be the pivot. In order to eliminate subdiagonal
-*  elements u[i',k] = v[i,q], i' = k+1, k+2, ..., n, the routine applies
-*  the following elementary gaussian transformations:
-* 
-*     (i-th row of V) := (i-th row of V) - f[i,p] * (p-th row of V),
-* 
-*  where f[i,p] = v[i,q] / v[p,q] is a gaussian multiplier.
-*
-*  Additionally, in order to keep the main equality A = F*V, each time
-*  when the routine applies the transformation to i-th row of the matrix
-*  V, it also adds f[i,p] as a new element to the matrix F.
-*
-*  IMPORTANT: On entry the working arrays flag and work should contain
-*  zeros. This status is provided by the routine on exit.
-*
-*  If no error occured, the routine returns zero. Otherwise, in case of
-*  overflow of the sparse vector area, the routine returns non-zero. */
-
-static int eliminate(LUF *luf, int p, int q)
-{     int n = luf->n;
-      int *fc_ptr = luf->fc_ptr;
-      int *fc_len = luf->fc_len;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      int *vr_cap = luf->vr_cap;
-      double *vr_piv = luf->vr_piv;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *vc_cap = luf->vc_cap;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int *sv_prev = luf->sv_prev;
-      int *sv_next = luf->sv_next;
-      double *vr_max = luf->vr_max;
-      int *rs_head = luf->rs_head;
-      int *rs_prev = luf->rs_prev;
-      int *rs_next = luf->rs_next;
-      int *cs_head = luf->cs_head;
-      int *cs_prev = luf->cs_prev;
-      int *cs_next = luf->cs_next;
-      int *flag = luf->flag;
-      double *work = luf->work;
-      double eps_tol = luf->eps_tol;
-      /* at this stage the row-wise representation of the matrix F is
-         not used, so fr_len can be used as a working array */
-      int *ndx = luf->fr_len;
-      int ret = 0;
-      int len, fill, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr, k,
-         p_beg, p_end, p_ptr, q_beg, q_end, q_ptr;
-      double fip, val, vpq, temp;
-      xassert(1 <= p && p <= n);
-      xassert(1 <= q && q <= n);
-      /* remove the p-th (pivot) row from the active set; this row will
-         never return there */
-      if (rs_prev[p] == 0)
-         rs_head[vr_len[p]] = rs_next[p];
-      else
-         rs_next[rs_prev[p]] = rs_next[p];
-      if (rs_next[p] == 0)
-         ;
-      else
-         rs_prev[rs_next[p]] = rs_prev[p];
-      /* remove the q-th (pivot) column from the active set; this column
-         will never return there */
-      if (cs_prev[q] == 0)
-         cs_head[vc_len[q]] = cs_next[q];
+*  choose_pivot - choose xB[p] and xN[q]
+*
+*  Given the list of eligible basic variables this routine first
+*  chooses basic variable xB[p]. This choice is always possible,
+*  because the list is assumed to be non-empty. Then the routine
+*  computes p-th row T[p,*] of the simplex table T[i,j] and chooses
+*  non-basic variable xN[q]. If the pivot T[p,q] is small in magnitude,
+*  the routine attempts to choose another xB[p] and xN[q] in order to
+*  avoid badly conditioned adjacent bases.
+*
+*  If the normal choice was made, the routine returns zero. Otherwise,
+*  if the long-step choice was made, the routine returns non-zero. */
+
+#ifdef TIMING /* 31/III-2016 */
+
+#include "choose_pivot.c"
+
+#else
+
+#define MIN_RATIO 0.0001
+
+static int choose_pivot(struct csa *csa)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      SPXAT *at = csa->at;
+      SPXNT *nt = csa->nt;
+      double *beta = csa->beta;
+      double *d = csa->d;
+      SPYSE *se = csa->se;
+#if 0 /* 30/III-2016 */
+      int *list = csa->list;
+#else
+      int *list = csa->r.ind;
+#endif
+      double *rho = csa->work;
+      double *trow = csa->work1;
+      SPYBP *bp = csa->bp;
+      double tol_piv = csa->tol_piv;
+      int try, nnn, j, k, p, q, t, t_best, nbp, ret;
+      double big, temp, r, best_ratio, dz_best;
+      xassert(csa->beta_st);
+      xassert(csa->d_st);
+more: /* initial number of eligible basic variables */
+#if 0 /* 30/III-2016 */
+      nnn = csa->num;
+#else
+      nnn = csa->r.nnz;
+#endif
+      /* nothing has been chosen so far */
+      csa->p = 0;
+      best_ratio = 0.0;
+      try = ret = 0;
+try:  /* choose basic variable xB[p] */
+      xassert(nnn > 0);
+      try++;
+      if (se == NULL)
+      {  /* dual Dantzig's rule */
+         p = spy_chuzr_std(lp, beta, nnn, list);
+      }
       else
-         cs_next[cs_prev[q]] = cs_next[q];
-      if (cs_next[q] == 0)
-         ;
+      {  /* dual projected steepest edge */
+         p = spy_chuzr_pse(lp, se, beta, nnn, list);
+      }
+      xassert(1 <= p && p <= m);
+      /* compute p-th row of inv(B) */
+      spx_eval_rho(lp, p, rho);
+      /* compute p-th row of the simplex table */
+      if (at != NULL)
+         spx_eval_trow1(lp, at, rho, trow);
       else
-         cs_prev[cs_next[q]] = cs_prev[q];
-      /* find the pivot v[p,q] = u[k,k] in the p-th row */
-      p_beg = vr_ptr[p];
-      p_end = p_beg + vr_len[p] - 1;
-      for (p_ptr = p_beg; sv_ind[p_ptr] != q; p_ptr++) /* nop */;
-      xassert(p_ptr <= p_end);
-      /* store value of the pivot */
-      vpq = (vr_piv[p] = sv_val[p_ptr]);
-      /* remove the pivot from the p-th row */
-      sv_ind[p_ptr] = sv_ind[p_end];
-      sv_val[p_ptr] = sv_val[p_end];
-      vr_len[p]--;
-      p_end--;
-      /* find the pivot v[p,q] = u[k,k] in the q-th column */
-      q_beg = vc_ptr[q];
-      q_end = q_beg + vc_len[q] - 1;
-      for (q_ptr = q_beg; sv_ind[q_ptr] != p; q_ptr++) /* nop */;
-      xassert(q_ptr <= q_end);
-      /* remove the pivot from the q-th column */
-      sv_ind[q_ptr] = sv_ind[q_end];
-      vc_len[q]--;
-      q_end--;
-      /* walk through the p-th (pivot) row, which doesn't contain the
-         pivot v[p,q] already, and do the following... */
-      for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)
-      {  /* get column index of v[p,j] */
-         j = sv_ind[p_ptr];
-         /* store v[p,j] to the working array */
-         flag[j] = 1;
-         work[j] = sv_val[p_ptr];
-         /* remove the j-th column from the active set; this column will
-            return there later with new length */
-         if (cs_prev[j] == 0)
-            cs_head[vc_len[j]] = cs_next[j];
-         else
-            cs_next[cs_prev[j]] = cs_next[j];
-         if (cs_next[j] == 0)
-            ;
-         else
-            cs_prev[cs_next[j]] = cs_prev[j];
-         /* find v[p,j] in the j-th column */
-         j_beg = vc_ptr[j];
-         j_end = j_beg + vc_len[j] - 1;
-         for (j_ptr = j_beg; sv_ind[j_ptr] != p; j_ptr++) /* nop */;
-         xassert(j_ptr <= j_end);
-         /* since v[p,j] leaves the active submatrix, remove it from the
-            j-th column; however, v[p,j] is kept in the p-th row */
-         sv_ind[j_ptr] = sv_ind[j_end];
-         vc_len[j]--;
-      }
-      /* walk through the q-th (pivot) column, which doesn't contain the
-         pivot v[p,q] already, and perform gaussian elimination */
-      while (q_beg <= q_end)
-      {  /* element v[i,q] should be eliminated */
-         /* get row index of v[i,q] */
-         i = sv_ind[q_beg];
-         /* remove the i-th row from the active set; later this row will
-            return there with new length */
-         if (rs_prev[i] == 0)
-            rs_head[vr_len[i]] = rs_next[i];
-         else
-            rs_next[rs_prev[i]] = rs_next[i];
-         if (rs_next[i] == 0)
-            ;
-         else
-            rs_prev[rs_next[i]] = rs_prev[i];
-         /* find v[i,q] in the i-th row */
-         i_beg = vr_ptr[i];
-         i_end = i_beg + vr_len[i] - 1;
-         for (i_ptr = i_beg; sv_ind[i_ptr] != q; i_ptr++) /* nop */;
-         xassert(i_ptr <= i_end);
-         /* compute gaussian multiplier f[i,p] = v[i,q] / v[p,q] */
-         fip = sv_val[i_ptr] / vpq;
-         /* since v[i,q] should be eliminated, remove it from the i-th
-            row */
-         sv_ind[i_ptr] = sv_ind[i_end];
-         sv_val[i_ptr] = sv_val[i_end];
-         vr_len[i]--;
-         i_end--;
-         /* and from the q-th column */
-         sv_ind[q_beg] = sv_ind[q_end];
-         vc_len[q]--;
-         q_end--;
-         /* perform gaussian transformation:
-            (i-th row) := (i-th row) - f[i,p] * (p-th row)
-            note that now the p-th row, which is in the working array,
-            doesn't contain the pivot v[p,q], and the i-th row doesn't
-            contain the eliminated element v[i,q] */
-         /* walk through the i-th row and transform existing non-zero
-            elements */
-         fill = vr_len[p];
-         for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-         {  /* get column index of v[i,j] */
-            j = sv_ind[i_ptr];
-            /* v[i,j] := v[i,j] - f[i,p] * v[p,j] */
-            if (flag[j])
-            {  /* v[p,j] != 0 */
-               temp = (sv_val[i_ptr] -= fip * work[j]);
-               if (temp < 0.0) temp = - temp;
-               flag[j] = 0;
-               fill--; /* since both v[i,j] and v[p,j] exist */
-               if (temp == 0.0 || temp < eps_tol)
-               {  /* new v[i,j] is closer to zero; replace it by exact
-                     zero, i.e. remove it from the active submatrix */
-                  /* remove v[i,j] from the i-th row */
-                  sv_ind[i_ptr] = sv_ind[i_end];
-                  sv_val[i_ptr] = sv_val[i_end];
-                  vr_len[i]--;
-                  i_ptr--;
-                  i_end--;
-                  /* find v[i,j] in the j-th column */
-                  j_beg = vc_ptr[j];
-                  j_end = j_beg + vc_len[j] - 1;
-                  for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++);
-                  xassert(j_ptr <= j_end);
-                  /* remove v[i,j] from the j-th column */
-                  sv_ind[j_ptr] = sv_ind[j_end];
-                  vc_len[j]--;
-               }
-               else
-               {  /* v_big := max(v_big, |v[i,j]|) */
-                  if (luf->big_v < temp) luf->big_v = temp;
-               }
+         spx_nt_prod(lp, nt, trow, 1, -1.0, rho);
+#if 1 /* 23/III-2016 */
+      /* big := max(1, |trow[1]|, ..., |trow[n-m]|) */
+      big = 1.0;
+      for (j = 1; j <= n-m; j++)
+      {  temp = trow[j];
+         if (temp < 0.0)
+            temp = - temp;
+         if (big < temp)
+            big = temp;
+      }
+#else
+      /* this still puzzles me */
+      big = 1.0;
+#endif
+      /* choose non-basic variable xN[q] */
+      k = head[p]; /* x[k] = xB[p] */
+      xassert(beta[p] < l[k] || beta[p] > u[k]);
+      r = beta[p] < l[k] ? l[k] - beta[p] : u[k] - beta[p];
+      if (csa->r_test == GLP_RT_FLIP && try <= 2)
+      {  /* long-step ratio test */
+#if 0 /* 23/III-2016 */
+         /* determine dual objective break-points */
+         nbp = spy_eval_bp(lp, d, r, trow, tol_piv, bp);
+         if (nbp <= 1)
+            goto skip;
+         /* choose appropriate break-point */
+         t_best = 0, dz_best = -DBL_MAX;
+         for (t = 1; t <= nbp; t++)
+         {  if (fabs(trow[bp[t].j]) / big >= MIN_RATIO)
+            {  if (dz_best < bp[t].dz)
+                  t_best = t, dz_best = bp[t].dz;
             }
          }
-         /* now flag is the pattern of the set v[p,*] \ v[i,*], and fill
-            is number of non-zeros in this set; therefore up to fill new
-            non-zeros may appear in the i-th row */
-         if (vr_len[i] + fill > vr_cap[i])
-         {  /* enlarge the i-th row */
-            if (luf_enlarge_row(luf, i, vr_len[i] + fill))
-            {  /* overflow of the sparse vector area */
-               ret = 1;
-               goto done;
-            }
-            /* defragmentation may change row and column pointers of the
-               matrix V */
-            p_beg = vr_ptr[p];
-            p_end = p_beg + vr_len[p] - 1;
-            q_beg = vc_ptr[q];
-            q_end = q_beg + vc_len[q] - 1;
-         }
-         /* walk through the p-th (pivot) row and create new elements
-            of the i-th row that appear due to fill-in; column indices
-            of these new elements are accumulated in the array ndx */
-         len = 0;
-         for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)
-         {  /* get column index of v[p,j], which may cause fill-in */
-            j = sv_ind[p_ptr];
-            if (flag[j])
-            {  /* compute new non-zero v[i,j] = 0 - f[i,p] * v[p,j] */
-               temp = (val = - fip * work[j]);
-               if (temp < 0.0) temp = - temp;
-               if (temp == 0.0 || temp < eps_tol)
-                  /* if v[i,j] is closer to zero; just ignore it */;
-               else
-               {  /* add v[i,j] to the i-th row */
-                  i_ptr = vr_ptr[i] + vr_len[i];
-                  sv_ind[i_ptr] = j;
-                  sv_val[i_ptr] = val;
-                  vr_len[i]++;
-                  /* remember column index of v[i,j] */
-                  ndx[++len] = j;
-                  /* big_v := max(big_v, |v[i,j]|) */
-                  if (luf->big_v < temp) luf->big_v = temp;
+         if (t_best == 0)
+            goto skip;
+#else
+         int t, num, num1;
+         double slope, teta_lim;
+         /* determine dual objective break-points */
+         nbp = spy_ls_eval_bp(lp, d, r, trow, tol_piv, bp);
+         if (nbp < 2)
+            goto skip;
+         /* set initial slope */
+         slope = fabs(r);
+         /* estimate initial teta_lim */
+         teta_lim = DBL_MAX;
+         for (t = 1; t <= nbp; t++)
+         {  if (teta_lim > bp[t].teta)
+               teta_lim = bp[t].teta;
+         }
+         xassert(teta_lim >= 0.0);
+         if (teta_lim < 1e-6)
+            teta_lim = 1e-6;
+         /* nothing has been chosen so far */
+         t_best = 0, dz_best = 0.0, num = 0;
+         /* choose appropriate break-point */
+         while (num < nbp)
+         {  /* select and process a new portion of break-points */
+            num1 = spy_ls_select_bp(lp, trow, nbp, bp, num, &slope,
+               teta_lim);
+            for (t = num+1; t <= num1; t++)
+            {  if (fabs(trow[bp[t].j]) / big >= MIN_RATIO)
+               {  if (dz_best < bp[t].dz)
+                     t_best = t, dz_best = bp[t].dz;
                }
             }
-            else
-            {  /* there is no fill-in, because v[i,j] already exists in
-                  the i-th row; restore the flag of the element v[p,j],
-                  which was reset before */
-               flag[j] = 1;
-            }
-         }
-         /* add new non-zeros v[i,j] to the corresponding columns */
-         for (k = 1; k <= len; k++)
-         {  /* get column index of new non-zero v[i,j] */
-            j = ndx[k];
-            /* one free location is needed in the j-th column */
-            if (vc_len[j] + 1 > vc_cap[j])
-            {  /* enlarge the j-th column */
-               if (luf_enlarge_col(luf, j, vc_len[j] + 10))
-               {  /* overflow of the sparse vector area */
-                  ret = 1;
-                  goto done;
-               }
-               /* defragmentation may change row and column pointers of
-                  the matrix V */
-               p_beg = vr_ptr[p];
-               p_end = p_beg + vr_len[p] - 1;
-               q_beg = vc_ptr[q];
-               q_end = q_beg + vc_len[q] - 1;
-            }
-            /* add new non-zero v[i,j] to the j-th column */
-            j_ptr = vc_ptr[j] + vc_len[j];
-            sv_ind[j_ptr] = i;
-            vc_len[j]++;
-         }
-         /* now the i-th row has been completely transformed, therefore
-            it can return to the active set with new length */
-         rs_prev[i] = 0;
-         rs_next[i] = rs_head[vr_len[i]];
-         if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;
-         rs_head[vr_len[i]] = i;
-         /* the largest of absolute values of elements in the i-th row
-            is currently unknown */
-         vr_max[i] = -1.0;
-         /* at least one free location is needed to store the gaussian
-            multiplier */
-         if (luf->sv_end - luf->sv_beg < 1)
-         {  /* there are no free locations at all; defragment SVA */
-            luf_defrag_sva(luf);
-            if (luf->sv_end - luf->sv_beg < 1)
-            {  /* overflow of the sparse vector area */
-               ret = 1;
-               goto done;
-            }
-            /* defragmentation may change row and column pointers of the
-               matrix V */
-            p_beg = vr_ptr[p];
-            p_end = p_beg + vr_len[p] - 1;
-            q_beg = vc_ptr[q];
-            q_end = q_beg + vc_len[q] - 1;
-         }
-         /* add the element f[i,p], which is the gaussian multiplier,
-            to the matrix F */
-         luf->sv_end--;
-         sv_ind[luf->sv_end] = i;
-         sv_val[luf->sv_end] = fip;
-         fc_len[p]++;
-         /* end of elimination loop */
-      }
-      /* at this point the q-th (pivot) column should be empty */
-      xassert(vc_len[q] == 0);
-      /* reset capacity of the q-th column */
-      vc_cap[q] = 0;
-      /* remove node of the q-th column from the addressing list */
-      k = n + q;
-      if (sv_prev[k] == 0)
-         luf->sv_head = sv_next[k];
-      else
-         sv_next[sv_prev[k]] = sv_next[k];
-      if (sv_next[k] == 0)
-         luf->sv_tail = sv_prev[k];
-      else
-         sv_prev[sv_next[k]] = sv_prev[k];
-      /* the p-th column of the matrix F has been completely built; set
-         its pointer */
-      fc_ptr[p] = luf->sv_end;
-      /* walk through the p-th (pivot) row and do the following... */
-      for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)
-      {  /* get column index of v[p,j] */
-         j = sv_ind[p_ptr];
-         /* erase v[p,j] from the working array */
-         flag[j] = 0;
-         work[j] = 0.0;
-         /* the j-th column has been completely transformed, therefore
-            it can return to the active set with new length; however
-            the special case c_prev[j] = c_next[j] = j means that the
-            routine find_pivot excluded the j-th column from the active
-            set due to Uwe Suhl's rule, and therefore in this case the
-            column can return to the active set only if it is a column
-            singleton */
-         if (!(vc_len[j] != 1 && cs_prev[j] == j && cs_next[j] == j))
-         {  cs_prev[j] = 0;
-            cs_next[j] = cs_head[vc_len[j]];
-            if (cs_next[j] != 0) cs_prev[cs_next[j]] = j;
-            cs_head[vc_len[j]] = j;
-         }
-      }
-done: /* return to the factorizing routine */
-      return ret;
-}
-
-/***********************************************************************
-*  build_v_cols - build the matrix V in column-wise format
-*
-*  This routine builds the column-wise representation of the matrix V
-*  using its row-wise representation.
-*
-*  If no error occured, the routine returns zero. Otherwise, in case of
-*  overflow of the sparse vector area, the routine returns non-zero. */
-
-static int build_v_cols(LUF *luf)
-{     int n = luf->n;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *vc_cap = luf->vc_cap;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int *sv_prev = luf->sv_prev;
-      int *sv_next = luf->sv_next;
-      int ret = 0;
-      int i, i_beg, i_end, i_ptr, j, j_ptr, k, nnz;
-      /* it is assumed that on entry all columns of the matrix V are
-         empty, i.e. vc_len[j] = vc_cap[j] = 0 for all j = 1, ..., n,
-         and have been removed from the addressing list */
-      /* count non-zeros in columns of the matrix V; count total number
-         of non-zeros in this matrix */
-      nnz = 0;
-      for (i = 1; i <= n; i++)
-      {  /* walk through elements of the i-th row and count non-zeros
-            in the corresponding columns */
-         i_beg = vr_ptr[i];
-         i_end = i_beg + vr_len[i] - 1;
-         for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-            vc_cap[sv_ind[i_ptr]]++;
-         /* count total number of non-zeros */
-         nnz += vr_len[i];
-      }
-      /* store total number of non-zeros */
-      luf->nnz_v = nnz;
-      /* check for free locations */
-      if (luf->sv_end - luf->sv_beg < nnz)
-      {  /* overflow of the sparse vector area */
+            if (slope < 0.0)
+            {  /* the dual objective starts decreasing */
+               break;
+            }
+            /* the dual objective continues increasing */
+            num = num1;
+            teta_lim += teta_lim;
+         }
+         if (dz_best == 0.0)
+            goto skip;
+         xassert(1 <= t_best && t_best <= num1);
+#endif
+         /* the choice has been made */
+         csa->p = p;
+#if 0 /* 29/III-2016 */
+         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));
+#else
+         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));
+         fvs_gather_vec(&csa->trow, DBL_EPSILON);
+#endif
+         csa->q = bp[t_best].j;
+         best_ratio = fabs(trow[bp[t_best].j]) / big;
+#if 0
+         xprintf("num = %d; t_best = %d; dz = %g\n", num, t_best,
+            bp[t_best].dz);
+#endif
          ret = 1;
          goto done;
+skip:    ;
       }
-      /* allocate columns of the matrix V */
-      for (j = 1; j <= n; j++)
-      {  /* set pointer to the j-th column */
-         vc_ptr[j] = luf->sv_beg;
-         /* reserve locations for the j-th column */
-         luf->sv_beg += vc_cap[j];
+      if (csa->r_test == GLP_RT_STD)
+      {  /* textbook dual ratio test */
+         q = spy_chuzc_std(lp, d, r, trow, tol_piv,
+            .30 * csa->tol_dj, .30 * csa->tol_dj1);
       }
-      /* build the matrix V in column-wise format using this matrix in
-         row-wise format */
-      for (i = 1; i <= n; i++)
-      {  /* walk through elements of the i-th row */
-         i_beg = vr_ptr[i];
-         i_end = i_beg + vr_len[i] - 1;
-         for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
-         {  /* get column index */
-            j = sv_ind[i_ptr];
-            /* store element in the j-th column */
-            j_ptr = vc_ptr[j] + vc_len[j];
-            sv_ind[j_ptr] = i;
-            sv_val[j_ptr] = sv_val[i_ptr];
-            /* increase length of the j-th column */
-            vc_len[j]++;
-         }
-      }
-      /* now columns are placed in the sparse vector area behind rows
-         in the order n+1, n+2, ..., n+n; so insert column nodes in the
-         addressing list using this order */
-      for (k = n+1; k <= n+n; k++)
-      {  sv_prev[k] = k-1;
-         sv_next[k] = k+1;
-      }
-      sv_prev[n+1] = luf->sv_tail;
-      sv_next[luf->sv_tail] = n+1;
-      sv_next[n+n] = 0;
-      luf->sv_tail = n+n;
-done: /* return to the factorizing routine */
-      return ret;
-}
-
-/***********************************************************************
-*  build_f_rows - build the matrix F in row-wise format
-*
-*  This routine builds the row-wise representation of the matrix F using
-*  its column-wise representation.
-*
-*  If no error occured, the routine returns zero. Otherwise, in case of
-*  overflow of the sparse vector area, the routine returns non-zero. */
-
-static int build_f_rows(LUF *luf)
-{     int n = luf->n;
-      int *fr_ptr = luf->fr_ptr;
-      int *fr_len = luf->fr_len;
-      int *fc_ptr = luf->fc_ptr;
-      int *fc_len = luf->fc_len;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int ret = 0;
-      int i, j, j_beg, j_end, j_ptr, ptr, nnz;
-      /* clear rows of the matrix F */
-      for (i = 1; i <= n; i++) fr_len[i] = 0;
-      /* count non-zeros in rows of the matrix F; count total number of
-         non-zeros in this matrix */
-      nnz = 0;
-      for (j = 1; j <= n; j++)
-      {  /* walk through elements of the j-th column and count non-zeros
-            in the corresponding rows */
-         j_beg = fc_ptr[j];
-         j_end = j_beg + fc_len[j] - 1;
-         for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
-            fr_len[sv_ind[j_ptr]]++;
-         /* increase total number of non-zeros */
-         nnz += fc_len[j];
-      }
-      /* store total number of non-zeros */
-      luf->nnz_f = nnz;
-      /* check for free locations */
-      if (luf->sv_end - luf->sv_beg < nnz)
-      {  /* overflow of the sparse vector area */
-         ret = 1;
+      else
+      {  /* Harris' two-pass dual ratio test */
+         q = spy_chuzc_harris(lp, d, r, trow, tol_piv,
+            .35 * csa->tol_dj, .35 * csa->tol_dj1);
+      }
+      if (q == 0)
+      {  /* dual unboundedness */
+         csa->p = p;
+#if 0 /* 29/III-2016 */
+         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));
+#else
+         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));
+         fvs_gather_vec(&csa->trow, DBL_EPSILON);
+#endif
+         csa->q = q;
+         best_ratio = 1.0;
          goto done;
       }
-      /* allocate rows of the matrix F */
-      for (i = 1; i <= n; i++)
-      {  /* set pointer to the end of the i-th row; later this pointer
-            will be set to the beginning of the i-th row */
-         fr_ptr[i] = luf->sv_end;
-         /* reserve locations for the i-th row */
-         luf->sv_end -= fr_len[i];
-      }
-      /* build the matrix F in row-wise format using this matrix in
-         column-wise format */
-      for (j = 1; j <= n; j++)
-      {  /* walk through elements of the j-th column */
-         j_beg = fc_ptr[j];
-         j_end = j_beg + fc_len[j] - 1;
-         for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
-         {  /* get row index */
-            i = sv_ind[j_ptr];
-            /* store element in the i-th row */
-            ptr = --fr_ptr[i];
-            sv_ind[ptr] = j;
-            sv_val[ptr] = sv_val[j_ptr];
+      /* either keep previous choice or accept new choice depending on
+       * which one is better */
+      if (best_ratio < fabs(trow[q]) / big)
+      {  csa->p = p;
+#if 0 /* 29/III-2016 */
+         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));
+#else
+         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));
+         fvs_gather_vec(&csa->trow, DBL_EPSILON);
+#endif
+         csa->q = q;
+         best_ratio = fabs(trow[q]) / big;
+      }
+      /* check if the current choice is acceptable */
+      if (best_ratio >= MIN_RATIO || nnn == 1 || try == 5)
+         goto done;
+      /* try to choose other xB[p] and xN[q] */
+      /* find xB[p] in the list */
+      for (t = 1; t <= nnn; t++)
+         if (list[t] == p) break;
+      xassert(t <= nnn);
+      /* move xB[p] to the end of the list */
+      list[t] = list[nnn], list[nnn] = p;
+      /* and exclude it from consideration */
+      nnn--;
+      /* repeat the choice */
+      goto try;
+done: /* the choice has been made */
+#if 1 /* FIXME: currently just to avoid badly conditioned basis */
+      if (best_ratio < .001 * MIN_RATIO)
+      {  /* looks like this helps */
+         if (bfd_get_count(lp->bfd) > 0)
+            return -1;
+         /* didn't help; last chance to improve the choice */
+         if (tol_piv == csa->tol_piv)
+         {  tol_piv *= 1000.;
+            goto more;
          }
       }
-done: /* return to the factorizing routine */
+#endif
+#if 1 /* FIXME */
+      if (ret)
+      {  /* invalidate basic solution components */
+#if 0 /* 28/III-2016 */
+         csa->beta_st = csa->d_st = 0;
+#else
+         /* dual solution remains valid */
+         csa->beta_st = 0;
+#endif
+         /* set double-bounded non-basic variables to opposite bounds
+          * for all break-points preceding the chosen one */
+         for (t = 1; t < t_best; t++)
+         {  k = head[m + bp[t].j];
+            xassert(-DBL_MAX < l[k] && l[k] < u[k] && u[k] < +DBL_MAX);
+            lp->flag[bp[t].j] = !(lp->flag[bp[t].j]);
+         }
+      }
+#endif
       return ret;
 }
 
+#endif
+
 /***********************************************************************
-*  NAME
-*
-*  luf_factorize - compute LU-factorization
+*  play_coef - play objective coefficients
 *
-*  SYNOPSIS
+*  This routine is called after the reduced costs d[j] was updated and
+*  the basis was changed to the adjacent one.
 *
-*  #include "glpluf.h"
-*  int luf_factorize(LUF *luf, int n, int (*col)(void *info, int j,
-*     int ind[], double val[]), void *info);
-*
-*  DESCRIPTION
-*
-*  The routine luf_factorize computes LU-factorization of a specified
-*  square matrix A.
-*
-*  The parameter luf specifies LU-factorization program object created
-*  by the routine luf_create_it.
-*
-*  The parameter n specifies the order of A, n > 0.
-*
-*  The formal routine col specifies the matrix A to be factorized. To
-*  obtain j-th column of A the routine luf_factorize calls the routine
-*  col with the parameter j (1 <= j <= n). In response the routine col
-*  should store row indices and numerical values of non-zero elements
-*  of j-th column of A to locations ind[1,...,len] and val[1,...,len],
-*  respectively, where len is the number of non-zeros in j-th column
-*  returned on exit. Neither zero nor duplicate elements are allowed.
-*
-*  The parameter info is a transit pointer passed to the routine col.
-*
-*  RETURNS
-*
-*  0  LU-factorization has been successfully computed.
-*
-*  LUF_ESING
-*     The specified matrix is singular within the working precision.
-*     (On some elimination step the active submatrix is exactly zero,
-*     so no pivot can be chosen.)
-*
-*  LUF_ECOND
-*     The specified matrix is ill-conditioned.
-*     (On some elimination step too intensive growth of elements of the
-*     active submatix has been detected.)
-*
-*  If matrix A is well scaled, the return code LUF_ECOND may also mean
-*  that the threshold pivoting tolerance piv_tol should be increased.
-*
-*  In case of non-zero return code the factorization becomes invalid.
-*  It should not be used in other operations until the cause of failure
-*  has been eliminated and the factorization has been recomputed again
-*  with the routine luf_factorize.
-*
-*  REPAIRING SINGULAR MATRIX
-*
-*  If the routine luf_factorize returns non-zero code, it provides all
-*  necessary information that can be used for "repairing" the matrix A,
-*  where "repairing" means replacing linearly dependent columns of the
-*  matrix A by appropriate columns of the unity matrix. This feature is
-*  needed when this routine is used for factorizing the basis matrix
-*  within the simplex method procedure.
-*
-*  On exit linearly dependent columns of the (partially transformed)
-*  matrix U have numbers rank+1, rank+2, ..., n, where rank is estimated
-*  rank of the matrix A stored by the routine to the member luf->rank.
-*  The correspondence between columns of A and U is the same as between
-*  columns of V and U. Thus, linearly dependent columns of the matrix A
-*  have numbers qq_col[rank+1], qq_col[rank+2], ..., qq_col[n], where
-*  qq_col is the column-like representation of the permutation matrix Q.
-*  It is understood that each j-th linearly dependent column of the
-*  matrix U should be replaced by the unity vector, where all elements
-*  are zero except the unity diagonal element u[j,j]. On the other hand
-*  j-th row of the matrix U corresponds to the row of the matrix V (and
-*  therefore of the matrix A) with the number pp_row[j], where pp_row is
-*  the row-like representation of the permutation matrix P. Thus, each
-*  j-th linearly dependent column of the matrix U should be replaced by
-*  column of the unity matrix with the number pp_row[j].
-*
-*  The code that repairs the matrix A may look like follows:
-*
-*     for (j = rank+1; j <= n; j++)
-*     {  replace the column qq_col[j] of the matrix A by the column
-*        pp_row[j] of the unity matrix;
-*     }
-*
-*  where rank, pp_row, and qq_col are members of the structure LUF. */
-
-int luf_factorize(LUF *luf, int n, int (*col)(void *info, int j,
-      int ind[], double val[]), void *info)
-{     int *pp_row, *pp_col, *qq_row, *qq_col;
-      double max_gro = luf->max_gro;
-      int i, j, k, p, q, t, ret;
-      if (n < 1)
-         xfault("luf_factorize: n = %d; invalid parameter\n", n);
-      if (n > N_MAX)
-         xfault("luf_factorize: n = %d; matrix too big\n", n);
-      /* invalidate the factorization */
-      luf->valid = 0;
-      /* reallocate arrays, if necessary */
-      reallocate(luf, n);
-      pp_row = luf->pp_row;
-      pp_col = luf->pp_col;
-      qq_row = luf->qq_row;
-      qq_col = luf->qq_col;
-      /* estimate initial size of the SVA, if not specified */
-      if (luf->sv_size == 0 && luf->new_sva == 0)
-         luf->new_sva = 5 * (n + 10);
-more: /* reallocate the sparse vector area, if required */
-      if (luf->new_sva > 0)
-      {  if (luf->sv_ind != NULL) xfree(luf->sv_ind);
-         if (luf->sv_val != NULL) xfree(luf->sv_val);
-         luf->sv_size = luf->new_sva;
-         luf->sv_ind = xcalloc(1+luf->sv_size, sizeof(int));
-         luf->sv_val = xcalloc(1+luf->sv_size, sizeof(double));
-         luf->new_sva = 0;
-      }
-      /* initialize LU-factorization data structures */
-      if (initialize(luf, col, info))
-      {  /* overflow of the sparse vector area */
-         luf->new_sva = luf->sv_size + luf->sv_size;
-         xassert(luf->new_sva > luf->sv_size);
-         goto more;
-      }
-      /* main elimination loop */
-      for (k = 1; k <= n; k++)
-      {  /* choose a pivot element v[p,q] */
-         if (find_pivot(luf, &p, &q))
-         {  /* no pivot can be chosen, because the active submatrix is
-               exactly zero */
-            luf->rank = k - 1;
-            ret = LUF_ESING;
-            goto done;
-         }
-         /* let v[p,q] correspond to u[i',j']; permute k-th and i'-th
-            rows and k-th and j'-th columns of the matrix U = P*V*Q to
-            move the element u[i',j'] to the position u[k,k] */
-         i = pp_col[p], j = qq_row[q];
-         xassert(k <= i && i <= n && k <= j && j <= n);
-         /* permute k-th and i-th rows of the matrix U */
-         t = pp_row[k];
-         pp_row[i] = t, pp_col[t] = i;
-         pp_row[k] = p, pp_col[p] = k;
-         /* permute k-th and j-th columns of the matrix U */
-         t = qq_col[k];
-         qq_col[j] = t, qq_row[t] = j;
-         qq_col[k] = q, qq_row[q] = k;
-         /* eliminate subdiagonal elements of k-th column of the matrix
-            U = P*V*Q using the pivot element u[k,k] = v[p,q] */
-         if (eliminate(luf, p, q))
-         {  /* overflow of the sparse vector area */
-            luf->new_sva = luf->sv_size + luf->sv_size;
-            xassert(luf->new_sva > luf->sv_size);
-            goto more;
-         }
-         /* check relative growth of elements of the matrix V */
-         if (luf->big_v > max_gro * luf->max_a)
-         {  /* the growth is too intensive, therefore most probably the
-               matrix A is ill-conditioned */
-            luf->rank = k - 1;
-            ret = LUF_ECOND;
-            goto done;
-         }
-      }
-      /* now the matrix U = P*V*Q is upper triangular, the matrix V has
-         been built in row-wise format, and the matrix F has been built
-         in column-wise format */
-      /* defragment the sparse vector area in order to merge all free
-         locations in one continuous extent */
-      luf_defrag_sva(luf);
-      /* build the matrix V in column-wise format */
-      if (build_v_cols(luf))
-      {  /* overflow of the sparse vector area */
-         luf->new_sva = luf->sv_size + luf->sv_size;
-         xassert(luf->new_sva > luf->sv_size);
-         goto more;
-      }
-      /* build the matrix F in row-wise format */
-      if (build_f_rows(luf))
-      {  /* overflow of the sparse vector area */
-         luf->new_sva = luf->sv_size + luf->sv_size;
-         xassert(luf->new_sva > luf->sv_size);
-         goto more;
-      }
-      /* the LU-factorization has been successfully computed */
-      luf->valid = 1;
-      luf->rank = n;
-      ret = 0;
-      /* if there are few free locations in the sparse vector area, try
-         increasing its size in the future */
-      t = 3 * (n + luf->nnz_v) + 2 * luf->nnz_f;
-      if (luf->sv_size < t)
-      {  luf->new_sva = luf->sv_size;
-         while (luf->new_sva < t)
-         {  k = luf->new_sva;
-            luf->new_sva = k + k;
-            xassert(luf->new_sva > k);
+*  It is assumed that before updating all the reduced costs d[j] were
+*  strongly feasible, so in the adjacent basis d[j] remain feasible
+*  within a tolerance, i.e. if some d[j] violates its zero bound, the
+*  violation is insignificant.
+*
+*  If some d[j] violates its zero bound, the routine changes (perturbs)
+*  objective coefficient cN[j] to provide d[j] = 0, i.e. to make all
+*  d[j] strongly feasible. Otherwise, if d[j] has a feasible value, the
+*  routine attempts to reduce (or remove) perturbation in cN[j] by
+*  shifting d[j] to its zero bound keeping strong feasibility. */
+
+static void play_coef(struct csa *csa, int all)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *c = lp->c;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      double *orig_c = csa->orig_c;
+      double *d = csa->d;
+      const double *trow = csa->trow.vec;
+      /* this vector was used to update d = (d[j]) */
+      int j, k;
+      static const double eps = 1e-9;
+      /* reduced costs d = (d[j]) should be valid */
+      xassert(csa->d_st);
+      /* walk thru the list of non-basic variables xN = (xN[j]) */
+      for (j = 1; j <= n-m; j++)
+      {  if (all || trow[j] != 0.0)
+         {  /* d[j] has changed in the adjacent basis */
+            k = head[m+j]; /* x[k] = xN[j] */
+            if (l[k] == u[k])
+            {  /* xN[j] is fixed variable */
+               /* d[j] may have any sign */
+            }
+            else if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)
+            {  /* xN[j] is free (unbounded) variable */
+               /* strong feasibility means d[j] = 0 */
+               c[k] -= d[j], d[j] = 0.0;
+               /* in this case dual degeneracy is not critical, since
+                * if xN[j] enters the basis, it never leaves it */
+            }
+            else if (!flag[j])
+            {  /* xN[j] has its lower bound active */
+               xassert(l[k] != -DBL_MAX);
+               /* first, we remove current perturbation to provide
+                * c[k] = orig_c[k] */
+               d[j] -= c[k] - orig_c[k], c[k] = orig_c[k];
+               /* strong feasibility means d[j] >= 0, but we provide
+                * d[j] >= +eps to prevent dual degeneracy */
+               if (d[j] < +eps)
+                  c[k] -= d[j] - eps, d[j] = +eps;
+            }
+            else
+            {  /* xN[j] has its upper bound active */
+               xassert(u[k] != +DBL_MAX);
+               /* similarly, we remove current perturbation to provide
+                * c[k] = orig_c[k] */
+               d[j] -= c[k] - orig_c[k], c[k] = orig_c[k];
+               /* strong feasibility means d[j] <= 0, but we provide
+                * d[j] <= -eps to prevent dual degeneracy */
+               if (d[j] > -eps)
+                  c[k] -= d[j] + eps, d[j] = -eps;
+            }
          }
       }
-done: /* return to the calling program */
-      return ret;
+      return;
 }
 
+#if 1 /* 11/VII-2017 */
+static void remove_perturb(struct csa *csa)
+{     /* remove perturbation */
+      SPXLP *lp = csa->lp;
+      int n = lp->n;
+      double *c = lp->c;
+      double *orig_c = csa->orig_c;
+      memcpy(c, orig_c, (1+n) * sizeof(double));
+      /* removing perturbation changes dual solution components */
+      csa->phase = csa->d_st = 0;
+#if 1
+      if (csa->msg_lev >= GLP_MSG_ALL)
+         xprintf("Removing LP perturbation [%d]...\n",
+            csa->it_cnt);
+#endif
+      return;
+}
+#endif
+
 /***********************************************************************
-*  NAME
+*  display - display search progress
 *
-*  luf_f_solve - solve system F*x = b or F'*x = b
+*  This routine displays some information about the search progress
+*  that includes:
 *
-*  SYNOPSIS
+*  search phase;
 *
-*  #include "glpluf.h"
-*  void luf_f_solve(LUF *luf, int tr, double x[]);
+*  number of simplex iterations performed by the solver;
 *
-*  DESCRIPTION
-*
-*  The routine luf_f_solve solves either the system F*x = b (if the
-*  flag tr is zero) or the system F'*x = b (if the flag tr is non-zero),
-*  where the matrix F is a component of LU-factorization specified by
-*  the parameter luf, F' is a matrix transposed to F.
-*
-*  On entry the array x should contain elements of the right-hand side
-*  vector b in locations x[1], ..., x[n], where n is the order of the
-*  matrix F. On exit this array will contain elements of the solution
-*  vector x in the same locations. */
-
-void luf_f_solve(LUF *luf, int tr, double x[])
-{     int n = luf->n;
-      int *fr_ptr = luf->fr_ptr;
-      int *fr_len = luf->fr_len;
-      int *fc_ptr = luf->fc_ptr;
-      int *fc_len = luf->fc_len;
-      int *pp_row = luf->pp_row;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      int i, j, k, beg, end, ptr;
-      double xk;
-      if (!luf->valid)
-         xfault("luf_f_solve: LU-factorization is not valid\n");
-      if (!tr)
-      {  /* solve the system F*x = b */
-         for (j = 1; j <= n; j++)
-         {  k = pp_row[j];
-            xk = x[k];
-            if (xk != 0.0)
-            {  beg = fc_ptr[k];
-               end = beg + fc_len[k] - 1;
-               for (ptr = beg; ptr <= end; ptr++)
-                  x[sv_ind[ptr]] -= sv_val[ptr] * xk;
+*  original objective value (only on phase II);
+*
+*  sum of (scaled) dual infeasibilities for original bounds;
+*
+*  number of dual infeasibilities (phase I) or primal infeasibilities
+*  (phase II);
+*
+*  number of basic factorizations since last display output. */
+
+static void display(struct csa *csa, int spec)
+{     SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      int *head = lp->head;
+      char *flag = lp->flag;
+      double *l = csa->orig_l; /* original lower bounds */
+      double *u = csa->orig_u; /* original upper bounds */
+      double *beta = csa->beta;
+      double *d = csa->d;
+      int j, k, nnn;
+      double sum;
+#if 1 /* 15/VII-2017 */
+      double tm_cur;
+#endif
+      /* check if the display output should be skipped */
+      if (csa->msg_lev < GLP_MSG_ON) goto skip;
+#if 1 /* 15/VII-2017 */
+      tm_cur = xtime();
+#endif
+      if (csa->out_dly > 0 &&
+#if 0 /* 15/VII-2017 */
+         1000.0 * xdifftime(xtime(), csa->tm_beg) < csa->out_dly)
+#else
+         1000.0 * xdifftime(tm_cur, csa->tm_beg) < csa->out_dly)
+#endif
+         goto skip;
+      if (csa->it_cnt == csa->it_dpy) goto skip;
+#if 0 /* 15/VII-2017 */
+      if (!spec && csa->it_cnt % csa->out_frq != 0) goto skip;
+#else
+      if (!spec &&
+         1000.0 * xdifftime(tm_cur, csa->tm_dpy) < csa->out_frq)
+         goto skip;
+#endif
+      /* display search progress depending on search phase */
+      switch (csa->phase)
+      {  case 1:
+            /* compute sum and number of (scaled) dual infeasibilities
+             * for original bounds */
+            sum = 0.0, nnn = 0;
+            for (j = 1; j <= n-m; j++)
+            {  k = head[m+j]; /* x[k] = xN[j] */
+               if (d[j] > 0.0)
+               {  /* xN[j] should have lower bound */
+                  if (l[k] == -DBL_MAX)
+                  {  sum += d[j];
+                     if (d[j] > +1e-7)
+                        nnn++;
+                  }
+               }
+               else if (d[j] < 0.0)
+               {  /* xN[j] should have upper bound */
+                  if (u[k] == +DBL_MAX)
+                  {  sum -= d[j];
+                     if (d[j] < -1e-7)
+                        nnn++;
+                  }
+               }
             }
-         }
+            /* on phase I variables have artificial bounds which are
+             * meaningless for original LP, so corresponding objective
+             * function value is also meaningless */
+#if 0 /* 27/III-2016 */
+            xprintf(" %6d: %23s inf = %11.3e (%d)",
+               csa->it_cnt, "", sum, nnn);
+#else
+            xprintf(" %6d: sum = %17.9e inf = %11.3e (%d)",
+               csa->it_cnt, lp->c[0] - spx_eval_obj(lp, beta),
+               sum, nnn);
+#endif
+            break;
+         case 2:
+            /* compute sum of (scaled) dual infeasibilities */
+            sum = 0.0, nnn = 0;
+            for (j = 1; j <= n-m; j++)
+            {  k = head[m+j]; /* x[k] = xN[j] */
+               if (d[j] > 0.0)
+               {  /* xN[j] should have its lower bound active */
+                  if (l[k] == -DBL_MAX || flag[j])
+                     sum += d[j];
+               }
+               else if (d[j] < 0.0)
+               {  /* xN[j] should have its upper bound active */
+                  if (l[k] != u[k] && !flag[j])
+                     sum -= d[j];
+               }
+            }
+            /* compute number of primal infeasibilities */
+            nnn = spy_chuzr_sel(lp, beta, csa->tol_bnd, csa->tol_bnd1,
+               NULL);
+            xprintf("#%6d: obj = %17.9e inf = %11.3e (%d)",
+#if SCALE_Z
+               csa->it_cnt,
+               (double)csa->dir * csa->fz * spx_eval_obj(lp, beta),
+#else
+               csa->it_cnt, (double)csa->dir * spx_eval_obj(lp, beta),
+#endif
+               sum, nnn);
+            break;
+         default:
+            xassert(csa != csa);
+      }
+      if (csa->inv_cnt)
+      {  /* number of basis factorizations performed */
+         xprintf(" %d", csa->inv_cnt);
+         csa->inv_cnt = 0;
+      }
+#if 1 /* 23/III-2016 */
+      if (csa->r_test == GLP_RT_FLIP)
+      {  /*xprintf("   %d,%d", csa->ns_cnt, csa->ls_cnt);*/
+         if (csa->ns_cnt + csa->ls_cnt)
+            xprintf(" %d%%",
+               (100 * csa->ls_cnt) / (csa->ns_cnt + csa->ls_cnt));
+         csa->ns_cnt = csa->ls_cnt = 0;
       }
-      else
-      {  /* solve the system F'*x = b */
-         for (i = n; i >= 1; i--)
-         {  k = pp_row[i];
-            xk = x[k];
-            if (xk != 0.0)
-            {  beg = fr_ptr[k];
-               end = beg + fr_len[k] - 1;
-               for (ptr = beg; ptr <= end; ptr++)
-                  x[sv_ind[ptr]] -= sv_val[ptr] * xk;
+#endif
+      xprintf("\n");
+      csa->it_dpy = csa->it_cnt;
+#if 1 /* 15/VII-2017 */
+      csa->tm_dpy = tm_cur;
+#endif
+skip: return;
+}
+
+#if 1 /* 31/III-2016 */
+static
+void spy_update_r(SPXLP *lp, int p, int q, const double beta[/*1+m*/],
+      const FVS *tcol, double tol, double tol1, FVS *r)
+{     /* update vector r of primal infeasibilities */
+      /* it is assumed that xB[p] leaves the basis, xN[q] enters the
+       * basis, and beta corresponds to the adjacent basis (i.e. this
+       * routine should be called after spx_update_beta) */
+      int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      int *tcol_ind = tcol->ind;
+      int *ind = r->ind;
+      double *vec = r->vec;
+      int i, k, t, nnz;
+      double lk, uk, ri, eps;
+      xassert(1 <= p && p <= m);
+      xassert(1 <= q && q <= n-m);
+      nnz = r->nnz;
+      for (t = tcol->nnz; t >= 1; t--)
+      {  i = tcol_ind[t];
+         /* xB[i] changes in the adjacent basis to beta[i], so only
+          * r[i] should be updated */
+         if (i == p)
+            k = head[m+q]; /* x[k] = new xB[p] = old xN[q] */
+         else
+            k = head[i];   /* x[k] = new xB[i] = old xB[i] */
+         lk = l[k], uk = u[k];
+         /* determine new value of r[i]; see spy_eval_r */
+         ri = 0.0;
+         if (beta[i] < lk)
+         {  /* determine absolute tolerance eps1[i] */
+            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
+            if (beta[i] < lk - eps)
+            {  /* lower bound is violated */
+               ri = lk - beta[i];
             }
          }
+         else if (beta[i] > uk)
+         {  /* determine absolute tolerance eps2[i] */
+            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
+            if (beta[i] > uk + eps)
+            {  /* upper bound is violated */
+               ri = uk - beta[i];
+            }
+         }
+         if (ri == 0.0)
+         {  if (vec[i] != 0.0)
+               vec[i] = DBL_MIN; /* will be removed */
+         }
+         else
+         {  if (vec[i] == 0.0)
+               ind[++nnz] = i;
+            vec[i] = ri;
+         }
+
       }
+      r->nnz = nnz;
+      /* remove zero elements */
+      fvs_adjust_vec(r, DBL_MIN + DBL_MIN);
       return;
 }
+#endif
 
 /***********************************************************************
-*  NAME
+*  spy_dual - driver to the dual simplex method
 *
-*  luf_v_solve - solve system V*x = b or V'*x = b
+*  This routine is a driver to the two-phase dual simplex method.
 *
-*  SYNOPSIS
+*  On exit this routine returns one of the following codes:
 *
-*  #include "glpluf.h"
-*  void luf_v_solve(LUF *luf, int tr, double x[]);
+*  0  LP instance has been successfully solved.
 *
-*  DESCRIPTION
-*
-*  The routine luf_v_solve solves either the system V*x = b (if the
-*  flag tr is zero) or the system V'*x = b (if the flag tr is non-zero),
-*  where the matrix V is a component of LU-factorization specified by
-*  the parameter luf, V' is a matrix transposed to V.
-*
-*  On entry the array x should contain elements of the right-hand side
-*  vector b in locations x[1], ..., x[n], where n is the order of the
-*  matrix V. On exit this array will contain elements of the solution
-*  vector x in the same locations. */
-
-void luf_v_solve(LUF *luf, int tr, double x[])
-{     int n = luf->n;
-      int *vr_ptr = luf->vr_ptr;
-      int *vr_len = luf->vr_len;
-      double *vr_piv = luf->vr_piv;
-      int *vc_ptr = luf->vc_ptr;
-      int *vc_len = luf->vc_len;
-      int *pp_row = luf->pp_row;
-      int *qq_col = luf->qq_col;
-      int *sv_ind = luf->sv_ind;
-      double *sv_val = luf->sv_val;
-      double *b = luf->work;
-      int i, j, k, beg, end, ptr;
-      double temp;
-      if (!luf->valid)
-         xfault("luf_v_solve: LU-factorization is not valid\n");
-      for (k = 1; k <= n; k++) b[k] = x[k], x[k] = 0.0;
-      if (!tr)
-      {  /* solve the system V*x = b */
-         for (k = n; k >= 1; k--)
-         {  i = pp_row[k], j = qq_col[k];
-            temp = b[i];
-            if (temp != 0.0)
-            {  x[j] = (temp /= vr_piv[i]);
-               beg = vc_ptr[j];
-               end = beg + vc_len[j] - 1;
-               for (ptr = beg; ptr <= end; ptr++)
-                  b[sv_ind[ptr]] -= sv_val[ptr] * temp;
+*  GLP_EOBJLL
+*     Objective lower limit has been reached (maximization).
+*
+*  GLP_EOBJUL
+*     Objective upper limit has been reached (minimization).
+*
+*  GLP_EITLIM
+*     Iteration limit has been exhausted.
+*
+*  GLP_ETMLIM
+*     Time limit has been exhausted.
+*
+*  GLP_EFAIL
+*     The solver failed to solve LP instance. */
+
+static int dual_simplex(struct csa *csa)
+{     /* dual simplex method main logic routine */
+      SPXLP *lp = csa->lp;
+      int m = lp->m;
+      int n = lp->n;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      SPXNT *nt = csa->nt;
+      double *beta = csa->beta;
+      double *d = csa->d;
+      SPYSE *se = csa->se;
+#if 0 /* 30/III-2016 */
+      int *list = csa->list;
+#endif
+#if 0 /* 31/III-2016 */
+      double *trow = csa->trow;
+      double *tcol = csa->tcol;
+#endif
+      double *pi = csa->work;
+      int msg_lev = csa->msg_lev;
+      double tol_bnd = csa->tol_bnd;
+      double tol_bnd1 = csa->tol_bnd1;
+      double tol_dj = csa->tol_dj;
+      double tol_dj1 = csa->tol_dj1;
+      int j, k, p_flag, refct, ret;
+      int perturb = -1;
+      /* -1 = perturbation is not used, but enabled
+       *  0 = perturbation is not used and disabled
+       * +1 = perturbation is being used */
+#if 1 /* 27/III-2016 */
+      int instab = 0; /* instability count */
+#endif
+#ifdef TIMING
+      double t_total  = timer(); /* total time */
+      double t_fact   = 0.0;     /* computing factorization */
+      double t_rtest  = 0.0;     /* performing ratio test */
+      double t_pivcol = 0.0;     /* computing pivot column */
+      double t_upd1   = 0.0;     /* updating primal values */
+      double t_upd2   = 0.0;     /* updating dual values */
+      double t_upd3   = 0.0;     /* updating se weights */
+      double t_upd4   = 0.0;     /* updating matrix N */
+      double t_upd5   = 0.0;     /* updating factorization */
+      double t_start;
+#endif
+      check_flags(csa);
+loop: /* main loop starts here */
+      /* compute factorization of the basis matrix */
+      if (!lp->valid)
+      {  double cond;
+#ifdef TIMING
+         t_start = timer();
+#endif
+         ret = spx_factorize(lp);
+#ifdef TIMING
+         t_fact += timer() - t_start;
+#endif
+         csa->inv_cnt++;
+         if (ret != 0)
+         {  if (msg_lev >= GLP_MSG_ERR)
+               xprintf("Error: unable to factorize the basis matrix (%d"
+                  ")\n", ret);
+            csa->p_stat = csa->d_stat = GLP_UNDEF;
+            ret = GLP_EFAIL;
+            goto fini;
+         }
+         /* check condition of the basis matrix */
+         cond = bfd_condest(lp->bfd);
+         if (cond > 1.0 / DBL_EPSILON)
+         {  if (msg_lev >= GLP_MSG_ERR)
+               xprintf("Error: basis matrix is singular to working prec"
+                  "ision (cond = %.3g)\n", cond);
+            csa->p_stat = csa->d_stat = GLP_UNDEF;
+            ret = GLP_EFAIL;
+            goto fini;
+         }
+         if (cond > 0.001 / DBL_EPSILON)
+         {  if (msg_lev >= GLP_MSG_ERR)
+               xprintf("Warning: basis matrix is ill-conditioned (cond "
+                  "= %.3g)\n", cond);
+         }
+         /* invalidate basic solution components */
+         csa->beta_st = csa->d_st = 0;
+      }
+      /* compute reduced costs of non-basic variables d = (d[j]) */
+      if (!csa->d_st)
+      {  spx_eval_pi(lp, pi);
+         for (j = 1; j <= n-m; j++)
+            d[j] = spx_eval_dj(lp, pi, j);
+         csa->d_st = 1; /* just computed */
+         /* determine the search phase, if not determined yet (this is
+          * performed only once at the beginning of the search for the
+          * original bounds) */
+         if (!csa->phase)
+         {  j = check_feas(csa, 0.97 * tol_dj, 0.97 * tol_dj1, 1);
+            if (j > 0)
+            {  /* initial basic solution is dual infeasible and cannot
+                * be recovered */
+               /* start to search for dual feasible solution */
+               set_art_bounds(csa);
+               csa->phase = 1;
+            }
+            else
+            {  /* initial basic solution is either dual feasible or its
+                * dual feasibility has been recovered */
+               /* start to search for optimal solution */
+               csa->phase = 2;
+            }
+         }
+         /* make sure that current basic solution is dual feasible */
+#if 1 /* 11/VII-2017 */
+         if (perturb <= 0)
+         {  if (check_feas(csa, tol_dj, tol_dj1, 0))
+            {  /* dual feasibility is broken due to excessive round-off
+                * errors */
+               if (perturb < 0)
+               {  if (msg_lev >= GLP_MSG_ALL)
+                     xprintf("Perturbing LP to avoid instability [%d].."
+                        ".\n", csa->it_cnt);
+                  perturb = 1;
+                  goto loop;
+               }
+               if (msg_lev >= GLP_MSG_ERR)
+                  xprintf("Warning: numerical instability (dual simplex"
+                     ", phase %s)\n", csa->phase == 1 ? "I" : "II");
+               instab++;
+               if (csa->dualp && instab >= 10)
+               {  /* do not continue the search; report failure */
+                  if (msg_lev >= GLP_MSG_ERR)
+                     xprintf("Warning: dual simplex failed due to exces"
+                        "sive numerical instability\n");
+                  csa->p_stat = csa->d_stat = GLP_UNDEF;
+                  ret = -1; /* special case of GLP_EFAIL */
+                  goto fini;
+               }
+               /* try to recover dual feasibility */
+               j = check_feas(csa, 0.97 * tol_dj, 0.97 * tol_dj1, 1);
+               if (j > 0)
+               {  /* dual feasibility cannot be recovered (this may
+                   * happen only on phase II) */
+                  xassert(csa->phase == 2);
+                  /* restart to search for dual feasible solution */
+                  set_art_bounds(csa);
+                  csa->phase = 1;
+               }
+            }
+         }
+         else
+         {  /* FIXME */
+            play_coef(csa, 1);
+         }
+      }
+#endif
+      /* at this point the search phase is determined */
+      xassert(csa->phase == 1 || csa->phase == 2);
+      /* compute values of basic variables beta = (beta[i]) */
+      if (!csa->beta_st)
+      {  spx_eval_beta(lp, beta);
+#if 1 /* 31/III-2016 */
+         /* also compute vector r of primal infeasibilities */
+         switch (csa->phase)
+         {  case 1:
+               spy_eval_r(lp, beta, 1e-8, 0.0, &csa->r);
+               break;
+            case 2:
+               spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
+               break;
+            default:
+               xassert(csa != csa);
+         }
+#endif
+         csa->beta_st = 1; /* just computed */
+      }
+      /* reset the dual reference space, if necessary */
+      if (se != NULL && !se->valid)
+         spy_reset_refsp(lp, se), refct = 1000;
+      /* at this point the basis factorization and all basic solution
+       * components are valid */
+      xassert(lp->valid && csa->beta_st && csa->d_st);
+#ifdef GLP_DEBUG
+      check_flags(csa);
+#endif
+#if CHECK_ACCURACY
+      /* check accuracy of current basic solution components (only for
+       * debugging) */
+      check_accuracy(csa);
+#endif
+      /* check if the objective limit has been reached */
+      if (csa->phase == 2 && csa->obj_lim != DBL_MAX
+         && spx_eval_obj(lp, beta) >= csa->obj_lim)
+      {
+#if 1 /* 26/V-2017 by mao */
+         if (perturb > 0)
+         {  /* remove perturbation */
+            /* [Should note that perturbing of objective coefficients
+             * implemented in play_coef is equivalent to *relaxing* of
+             * (zero) bounds of dual variables, so the perturbed
+             * objective is always better (*greater*) that the original
+             * one at the same basic point.] */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+#endif
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         display(csa, 1);
+         if (msg_lev >= GLP_MSG_ALL)
+            xprintf("OBJECTIVE %s LIMIT REACHED; SEARCH TERMINATED\n",
+               csa->dir > 0 ? "UPPER" : "LOWER");
+#if 0 /* 30/III-2016 */
+         csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
+         csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
+#else
+         spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
+         csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
+#endif
+         csa->d_stat = GLP_FEAS;
+         ret = (csa->dir > 0 ? GLP_EOBJUL : GLP_EOBJLL);
+         goto fini;
+      }
+      /* check if the iteration limit has been exhausted */
+      if (csa->it_cnt - csa->it_beg >= csa->it_lim)
+      {  if (perturb > 0)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         display(csa, 1);
+         if (msg_lev >= GLP_MSG_ALL)
+            xprintf("ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\n");
+         if (csa->phase == 1)
+         {  set_orig_bounds(csa);
+            check_flags(csa);
+            spx_eval_beta(lp, beta);
+         }
+#if 0 /* 30/III-2016 */
+         csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
+         csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
+#else
+         spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
+         csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
+#endif
+         csa->d_stat = (csa->phase == 1 ? GLP_INFEAS : GLP_FEAS);
+         ret = GLP_EITLIM;
+         goto fini;
+      }
+      /* check if the time limit has been exhausted */
+      if (1000.0 * xdifftime(xtime(), csa->tm_beg) >= csa->tm_lim)
+      {  if (perturb > 0)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         display(csa, 1);
+         if (msg_lev >= GLP_MSG_ALL)
+            xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
+         if (csa->phase == 1)
+         {  set_orig_bounds(csa);
+            check_flags(csa);
+            spx_eval_beta(lp, beta);
+         }
+#if 0 /* 30/III-2016 */
+         csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
+         csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
+#else
+         spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
+         csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
+#endif
+         csa->d_stat = (csa->phase == 1 ? GLP_INFEAS : GLP_FEAS);
+         ret = GLP_ETMLIM;
+         goto fini;
+      }
+      /* display the search progress */
+      display(csa, 0);
+      /* select eligible basic variables */
+#if 0 /* 31/III-2016; not needed because r is valid */
+      switch (csa->phase)
+      {  case 1:
+#if 0 /* 30/III-2016 */
+            csa->num = spy_chuzr_sel(lp, beta, 1e-8, 0.0, list);
+#else
+            spy_eval_r(lp, beta, 1e-8, 0.0, &csa->r);
+#endif
+            break;
+         case 2:
+#if 0 /* 30/III-2016 */
+            csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1, list);
+#else
+            spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
+#endif
+            break;
+         default:
+            xassert(csa != csa);
+      }
+#endif
+      /* check for optimality */
+#if 0 /* 30/III-2016 */
+      if (csa->num == 0)
+#else
+      if (csa->r.nnz == 0)
+#endif
+      {  if (perturb > 0 && csa->phase == 2)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         /* current basis is optimal */
+         display(csa, 1);
+         switch (csa->phase)
+         {  case 1:
+               /* check for dual feasibility */
+               set_orig_bounds(csa);
+               check_flags(csa);
+               if (check_feas(csa, tol_dj, tol_dj1, 0) == 0)
+               {  /* dual feasible solution found; switch to phase II */
+                  csa->phase = 2;
+                  xassert(!csa->beta_st);
+                  goto loop;
+               }
+#if 1 /* 26/V-2017 by cmatraki */
+               if (perturb > 0)
+               {  /* remove perturbation */
+                  remove_perturb(csa);
+                  perturb = 0;
+                  goto loop;
+               }
+#endif
+               /* no dual feasible solution exists */
+               if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("LP HAS NO DUAL FEASIBLE SOLUTION\n");
+               spx_eval_beta(lp, beta);
+#if 0 /* 30/III-2016 */
+               csa->num = spy_chuzr_sel(lp, beta, tol_bnd, tol_bnd1,
+                  list);
+               csa->p_stat = (csa->num == 0 ? GLP_FEAS : GLP_INFEAS);
+#else
+               spy_eval_r(lp, beta, tol_bnd, tol_bnd1, &csa->r);
+               csa->p_stat = (csa->r.nnz == 0 ? GLP_FEAS : GLP_INFEAS);
+#endif
+               csa->d_stat = GLP_NOFEAS;
+               ret = 0;
+               goto fini;
+            case 2:
+               /* optimal solution found */
+               if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("OPTIMAL LP SOLUTION FOUND\n");
+               csa->p_stat = csa->d_stat = GLP_FEAS;
+               ret = 0;
+               goto fini;
+            default:
+               xassert(csa != csa);
+         }
+      }
+      /* choose xB[p] and xN[q] */
+#if 0 /* 23/III-2016 */
+      choose_pivot(csa);
+#else
+#ifdef TIMING
+      t_start = timer();
+#endif
+#if 1 /* 31/III-2016 */
+      ret = choose_pivot(csa);
+#endif
+#ifdef TIMING
+      t_rtest += timer() - t_start;
+#endif
+      if (ret < 0)
+      {  lp->valid = 0;
+         goto loop;
+      }
+      if (ret == 0)
+         csa->ns_cnt++;
+      else
+         csa->ls_cnt++;
+#endif
+      /* check for dual unboundedness */
+      if (csa->q == 0)
+      {  if (perturb > 0)
+         {  /* remove perturbation */
+            remove_perturb(csa);
+            perturb = 0;
+         }
+         if (csa->beta_st != 1)
+            csa->beta_st = 0;
+         if (csa->d_st != 1)
+            csa->d_st = 0;
+         if (!(csa->beta_st && csa->d_st))
+            goto loop;
+         display(csa, 1);
+         switch (csa->phase)
+         {  case 1:
+               /* this should never happen */
+               if (msg_lev >= GLP_MSG_ERR)
+                  xprintf("Error: dual simplex failed\n");
+               csa->p_stat = csa->d_stat = GLP_UNDEF;
+               ret = GLP_EFAIL;
+               goto fini;
+            case 2:
+               /* dual unboundedness detected */
+               if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("LP HAS NO PRIMAL FEASIBLE SOLUTION\n");
+               csa->p_stat = GLP_NOFEAS;
+               csa->d_stat = GLP_FEAS;
+               ret = 0;
+               goto fini;
+            default:
+               xassert(csa != csa);
+         }
+      }
+      /* compute q-th column of the simplex table */
+#ifdef TIMING
+      t_start = timer();
+#endif
+#if 0 /* 31/III-2016 */
+      spx_eval_tcol(lp, csa->q, tcol);
+#else
+      spx_eval_tcol(lp, csa->q, csa->tcol.vec);
+      fvs_gather_vec(&csa->tcol, DBL_EPSILON);
+#endif
+#ifdef TIMING
+      t_pivcol += timer() - t_start;
+#endif
+      /* FIXME: tcol[p] and trow[q] should be close to each other */
+#if 0 /* 26/V-2017 by cmatraki */
+      xassert(csa->tcol.vec[csa->p] != 0.0);
+#else
+      if (csa->tcol.vec[csa->p] == 0.0)
+      {  if (msg_lev >= GLP_MSG_ERR)
+            xprintf("Error: tcol[p] = 0.0\n");
+         csa->p_stat = csa->d_stat = GLP_UNDEF;
+         ret = GLP_EFAIL;
+         goto fini;
+      }
+#endif
+      /* update values of basic variables for adjacent basis */
+      k = head[csa->p]; /* x[k] = xB[p] */
+      p_flag = (l[k] != u[k] && beta[csa->p] > u[k]);
+#if 0 /* 16/III-2016 */
+      spx_update_beta(lp, beta, csa->p, p_flag, csa->q, tcol);
+      csa->beta_st = 2;
+#else
+      /* primal solution may be invalidated due to long step */
+#ifdef TIMING
+      t_start = timer();
+#endif
+      if (csa->beta_st)
+#if 0 /* 30/III-2016 */
+      {  spx_update_beta(lp, beta, csa->p, p_flag, csa->q, tcol);
+#else
+      {  spx_update_beta_s(lp, beta, csa->p, p_flag, csa->q,
+            &csa->tcol);
+         /* also update vector r of primal infeasibilities */
+         /*fvs_check_vec(&csa->r);*/
+         switch (csa->phase)
+         {  case 1:
+               spy_update_r(lp, csa->p, csa->q, beta, &csa->tcol,
+                  1e-8, 0.0, &csa->r);
+               break;
+            case 2:
+               spy_update_r(lp, csa->p, csa->q, beta, &csa->tcol,
+                  tol_bnd, tol_bnd1, &csa->r);
+               break;
+            default:
+               xassert(csa != csa);
+         }
+         /*fvs_check_vec(&csa->r);*/
+#endif
+         csa->beta_st = 2;
+      }
+#ifdef TIMING
+      t_upd1 += timer() - t_start;
+#endif
+#endif
+#if 1 /* 11/VII-2017 */
+      /* check for stalling */
+      {  int k;
+         xassert(1 <= csa->p && csa->p <= m);
+         xassert(1 <= csa->q && csa->q <= n-m);
+         /* FIXME: recompute d[q]; see spx_update_d */
+         k = head[m+csa->q]; /* x[k] = xN[q] */
+         if (!(lp->l[k] == -DBL_MAX && lp->u[k] == +DBL_MAX))
+         {  if (fabs(d[csa->q]) >= 1e-6)
+            {  csa->degen = 0;
+               goto skip1;
+            }
+            /* degenerate iteration has been detected */
+            csa->degen++;
+            if (perturb < 0 && csa->degen >= 200)
+            {  if (msg_lev >= GLP_MSG_ALL)
+                  xprintf("Perturbing LP to avoid stalling [%d]...\n",
+                     csa->it_cnt);
+               perturb = 1;
             }
+skip1:      ;
          }
       }
+#endif
+      /* update reduced costs of non-basic variables for adjacent
+       * basis */
+#if 1 /* 28/III-2016 */
+      xassert(csa->d_st);
+#endif
+#ifdef TIMING
+      t_start = timer();
+#endif
+#if 0 /* 30/III-2016 */
+      if (spx_update_d(lp, d, csa->p, csa->q, trow, tcol) <= 1e-9)
+#else
+      if (spx_update_d_s(lp, d, csa->p, csa->q, &csa->trow, &csa->tcol)
+         <= 1e-9)
+#endif
+      {  /* successful updating */
+         csa->d_st = 2;
+      }
       else
-      {  /* solve the system V'*x = b */
-         for (k = 1; k <= n; k++)
-         {  i = pp_row[k], j = qq_col[k];
-            temp = b[j];
-            if (temp != 0.0)
-            {  x[i] = (temp /= vr_piv[i]);
-               beg = vr_ptr[i];
-               end = beg + vr_len[i] - 1;
-               for (ptr = beg; ptr <= end; ptr++)
-                  b[sv_ind[ptr]] -= sv_val[ptr] * temp;
+      {  /* new reduced costs are inaccurate */
+         csa->d_st = 0;
+      }
+#ifdef TIMING
+      t_upd2 += timer() - t_start;
+#endif
+      /* update steepest edge weights for adjacent basis, if used */
+#ifdef TIMING
+      t_start = timer();
+#endif
+      if (se != NULL)
+      {  if (refct > 0)
+#if 0 /* 30/III-2016 */
+         {  if (spy_update_gamma(lp, se, csa->p, csa->q, trow, tcol)
+               <= 1e-3)
+#else
+         {  if (spy_update_gamma_s(lp, se, csa->p, csa->q, &csa->trow,
+               &csa->tcol) <= 1e-3)
+#endif
+            {  /* successful updating */
+               refct--;
+            }
+            else
+            {  /* new weights are inaccurate; reset reference space */
+               se->valid = 0;
             }
          }
+         else
+         {  /* too many updates; reset reference space */
+            se->valid = 0;
+         }
       }
-      return;
+#ifdef TIMING
+      t_upd3 += timer() - t_start;
+#endif
+#ifdef TIMING
+      t_start = timer();
+#endif
+      /* update matrix N for adjacent basis, if used */
+      if (nt != NULL)
+         spx_update_nt(lp, nt, csa->p, csa->q);
+#ifdef TIMING
+      t_upd4 += timer() - t_start;
+#endif
+      /* change current basis header to adjacent one */
+      spx_change_basis(lp, csa->p, p_flag, csa->q);
+      /* and update factorization of the basis matrix */
+#ifdef TIMING
+      t_start = timer();
+#endif
+#if 0 /* 16/III-2016 */
+      if (csa->p > 0)
+#endif
+         spx_update_invb(lp, csa->p, head[csa->p]);
+#ifdef TIMING
+      t_upd5 += timer() - t_start;
+#endif
+      if (perturb > 0 && csa->d_st)
+         play_coef(csa, 0);
+      /* dual simplex iteration complete */
+      csa->it_cnt++;
+      goto loop;
+fini:
+#ifdef TIMING
+      t_total = timer() - t_total;
+      xprintf("Total time      = %10.3f\n", t_total);
+      xprintf("Factorization   = %10.3f\n", t_fact);
+      xprintf("Ratio test      = %10.3f\n", t_rtest);
+      xprintf("Pivot column    = %10.3f\n", t_pivcol);
+      xprintf("Updating beta   = %10.3f\n", t_upd1);
+      xprintf("Updating d      = %10.3f\n", t_upd2);
+      xprintf("Updating gamma  = %10.3f\n", t_upd3);
+      xprintf("Updating N      = %10.3f\n", t_upd4);
+      xprintf("Updating inv(B) = %10.3f\n", t_upd5);
+#endif
+      return ret;
 }
 
-/***********************************************************************
-*  NAME
-*
-*  luf_a_solve - solve system A*x = b or A'*x = b
-*
-*  SYNOPSIS
-*
-*  #include "glpluf.h"
-*  void luf_a_solve(LUF *luf, int tr, double x[]);
-*
-*  DESCRIPTION
-*
-*  The routine luf_a_solve solves either the system A*x = b (if the
-*  flag tr is zero) or the system A'*x = b (if the flag tr is non-zero),
-*  where the parameter luf specifies LU-factorization of the matrix A,
-*  A' is a matrix transposed to A.
-*
-*  On entry the array x should contain elements of the right-hand side
-*  vector b in locations x[1], ..., x[n], where n is the order of the
-*  matrix A. On exit this array will contain elements of the solution
-*  vector x in the same locations. */
-
-void luf_a_solve(LUF *luf, int tr, double x[])
-{     if (!luf->valid)
-         xfault("luf_a_solve: LU-factorization is not valid\n");
-      if (!tr)
-      {  /* A = F*V, therefore inv(A) = inv(V)*inv(F) */
-         luf_f_solve(luf, 0, x);
-         luf_v_solve(luf, 0, x);
+int spy_dual(glp_prob *P, const glp_smcp *parm)
+{     /* driver to the dual simplex method */
+      struct csa csa_, *csa = &csa_;
+      SPXLP lp;
+      SPXAT at;
+      SPXNT nt;
+      SPYSE se;
+      int ret, *map, *daeh;
+#if SCALE_Z
+      int i, j, k;
+#endif
+      /* build working LP and its initial basis */
+      memset(csa, 0, sizeof(struct csa));
+      csa->lp = &lp;
+      spx_init_lp(csa->lp, P, parm->excl);
+      spx_alloc_lp(csa->lp);
+      map = talloc(1+P->m+P->n, int);
+      spx_build_lp(csa->lp, P, parm->excl, parm->shift, map);
+      spx_build_basis(csa->lp, P, map);
+      switch (P->dir)
+      {  case GLP_MIN:
+            csa->dir = +1;
+            break;
+         case GLP_MAX:
+            csa->dir = -1;
+            break;
+         default:
+            xassert(P != P);
+      }
+#if SCALE_Z
+      csa->fz = 0.0;
+      for (k = 1; k <= csa->lp->n; k++)
+      {  double t = fabs(csa->lp->c[k]);
+         if (csa->fz < t)
+            csa->fz = t;
       }
+      if (csa->fz <= 1000.0)
+         csa->fz = 1.0;
       else
-      {  /* A' = V'*F', therefore inv(A') = inv(F')*inv(V') */
-         luf_v_solve(luf, 1, x);
-         luf_f_solve(luf, 1, x);
+         csa->fz /= 1000.0;
+      /*xprintf("csa->fz = %g\n", csa->fz);*/
+      for (k = 0; k <= csa->lp->n; k++)
+         csa->lp->c[k] /= csa->fz;
+#endif
+      csa->orig_b = talloc(1+csa->lp->m, double);
+      memcpy(csa->orig_b, csa->lp->b, (1+csa->lp->m) * sizeof(double));
+      csa->orig_c = talloc(1+csa->lp->n, double);
+      memcpy(csa->orig_c, csa->lp->c, (1+csa->lp->n) * sizeof(double));
+      csa->orig_l = talloc(1+csa->lp->n, double);
+      memcpy(csa->orig_l, csa->lp->l, (1+csa->lp->n) * sizeof(double));
+      csa->orig_u = talloc(1+csa->lp->n, double);
+      memcpy(csa->orig_u, csa->lp->u, (1+csa->lp->n) * sizeof(double));
+      switch (parm->aorn)
+      {  case GLP_USE_AT:
+            /* build matrix A in row-wise format */
+            csa->at = &at;
+            csa->nt = NULL;
+            spx_alloc_at(csa->lp, csa->at);
+            spx_build_at(csa->lp, csa->at);
+            break;
+         case GLP_USE_NT:
+            /* build matrix N in row-wise format for initial basis */
+            csa->at = NULL;
+            csa->nt = &nt;
+            spx_alloc_nt(csa->lp, csa->nt);
+            spx_init_nt(csa->lp, csa->nt);
+            spx_build_nt(csa->lp, csa->nt);
+            break;
+         default:
+            xassert(parm != parm);
+      }
+      /* allocate and initialize working components */
+      csa->phase = 0;
+      csa->beta = talloc(1+csa->lp->m, double);
+      csa->beta_st = 0;
+      csa->d = talloc(1+csa->lp->n-csa->lp->m, double);
+      csa->d_st = 0;
+      switch (parm->pricing)
+      {  case GLP_PT_STD:
+            csa->se = NULL;
+            break;
+         case GLP_PT_PSE:
+            csa->se = &se;
+            spy_alloc_se(csa->lp, csa->se);
+            break;
+         default:
+            xassert(parm != parm);
+      }
+#if 0 /* 30/III-2016 */
+      csa->list = talloc(1+csa->lp->m, int);
+      csa->trow = talloc(1+csa->lp->n-csa->lp->m, double);
+      csa->tcol = talloc(1+csa->lp->m, double);
+#else
+      fvs_alloc_vec(&csa->r, csa->lp->m);
+      fvs_alloc_vec(&csa->trow, csa->lp->n-csa->lp->m);
+      fvs_alloc_vec(&csa->tcol, csa->lp->m);
+#endif
+#if 1 /* 16/III-2016 */
+      csa->bp = NULL;
+#endif
+      csa->work = talloc(1+csa->lp->m, double);
+      csa->work1 = talloc(1+csa->lp->n-csa->lp->m, double);
+#if 0 /* 11/VI-2017 */
+#if 1 /* 31/III-2016 */
+      fvs_alloc_vec(&csa->wrow, csa->lp->n-csa->lp->m);
+      fvs_alloc_vec(&csa->wcol, csa->lp->m);
+#endif
+#endif
+      /* initialize control parameters */
+      csa->msg_lev = parm->msg_lev;
+      csa->dualp = (parm->meth == GLP_DUALP);
+#if 0 /* 16/III-2016 */
+      switch (parm->r_test)
+      {  case GLP_RT_STD:
+            csa->harris = 0;
+            break;
+         case GLP_RT_HAR:
+            csa->harris = 1;
+            break;
+         default:
+            xassert(parm != parm);
+      }
+#else
+      switch (parm->r_test)
+      {  case GLP_RT_STD:
+         case GLP_RT_HAR:
+            break;
+         case GLP_RT_FLIP:
+            csa->bp = talloc(1+csa->lp->n-csa->lp->m, SPYBP);
+            break;
+         default:
+            xassert(parm != parm);
       }
-      return;
-}
-
-/***********************************************************************
-*  NAME
-*
-*  luf_delete_it - delete LU-factorization
-*
-*  SYNOPSIS
-*
-*  #include "glpluf.h"
-*  void luf_delete_it(LUF *luf);
-*
-*  DESCRIPTION
-*
-*  The routine luf_delete deletes LU-factorization specified by the
-*  parameter luf and frees all the memory allocated to this program
-*  object. */
-
-void luf_delete_it(LUF *luf)
-{     if (luf->fr_ptr != NULL) xfree(luf->fr_ptr);
-      if (luf->fr_len != NULL) xfree(luf->fr_len);
-      if (luf->fc_ptr != NULL) xfree(luf->fc_ptr);
-      if (luf->fc_len != NULL) xfree(luf->fc_len);
-      if (luf->vr_ptr != NULL) xfree(luf->vr_ptr);
-      if (luf->vr_len != NULL) xfree(luf->vr_len);
-      if (luf->vr_cap != NULL) xfree(luf->vr_cap);
-      if (luf->vr_piv != NULL) xfree(luf->vr_piv);
-      if (luf->vc_ptr != NULL) xfree(luf->vc_ptr);
-      if (luf->vc_len != NULL) xfree(luf->vc_len);
-      if (luf->vc_cap != NULL) xfree(luf->vc_cap);
-      if (luf->pp_row != NULL) xfree(luf->pp_row);
-      if (luf->pp_col != NULL) xfree(luf->pp_col);
-      if (luf->qq_row != NULL) xfree(luf->qq_row);
-      if (luf->qq_col != NULL) xfree(luf->qq_col);
-      if (luf->sv_ind != NULL) xfree(luf->sv_ind);
-      if (luf->sv_val != NULL) xfree(luf->sv_val);
-      if (luf->sv_prev != NULL) xfree(luf->sv_prev);
-      if (luf->sv_next != NULL) xfree(luf->sv_next);
-      if (luf->vr_max != NULL) xfree(luf->vr_max);
-      if (luf->rs_head != NULL) xfree(luf->rs_head);
-      if (luf->rs_prev != NULL) xfree(luf->rs_prev);
-      if (luf->rs_next != NULL) xfree(luf->rs_next);
-      if (luf->cs_head != NULL) xfree(luf->cs_head);
-      if (luf->cs_prev != NULL) xfree(luf->cs_prev);
-      if (luf->cs_next != NULL) xfree(luf->cs_next);
-      if (luf->flag != NULL) xfree(luf->flag);
-      if (luf->work != NULL) xfree(luf->work);
-      xfree(luf);
-      return;
+      csa->r_test = parm->r_test;
+#endif
+      csa->tol_bnd = parm->tol_bnd;
+      csa->tol_bnd1 = .001 * parm->tol_bnd;
+      csa->tol_dj = parm->tol_dj;
+      csa->tol_dj1 = .001 * parm->tol_dj;
+#if 0
+      csa->tol_dj1 = 1e-9 * parm->tol_dj;
+#endif
+      csa->tol_piv = parm->tol_piv;
+      switch (P->dir)
+      {  case GLP_MIN:
+            csa->obj_lim = + parm->obj_ul;
+            break;
+         case GLP_MAX:
+            csa->obj_lim = - parm->obj_ll;
+            break;
+         default:
+            xassert(parm != parm);
+      }
+#if SCALE_Z
+      if (csa->obj_lim != DBL_MAX)
+         csa->obj_lim /= csa->fz;
+#endif
+      csa->it_lim = parm->it_lim;
+      csa->tm_lim = parm->tm_lim;
+      csa->out_frq = parm->out_frq;
+      csa->out_dly = parm->out_dly;
+      /* initialize working parameters */
+      csa->tm_beg = xtime();
+      csa->it_beg = csa->it_cnt = P->it_cnt;
+      csa->it_dpy = -1;
+#if 1 /* 15/VII-2017 */
+      csa->tm_dpy = 0.0;
+#endif
+      csa->inv_cnt = 0;
+#if 1 /* 11/VII-2017 */
+      csa->degen = 0;
+#endif
+#if 1 /* 23/III-2016 */
+      csa->ns_cnt = csa->ls_cnt = 0;
+#endif
+      /* try to solve working LP */
+      ret = dual_simplex(csa);
+      /* return basis factorization back to problem object */
+      P->valid = csa->lp->valid;
+      P->bfd = csa->lp->bfd;
+      /* set solution status */
+      P->pbs_stat = csa->p_stat;
+      P->dbs_stat = csa->d_stat;
+      /* if the solver failed, do not store basis header and basic
+       * solution components to problem object */
+      if (ret == GLP_EFAIL)
+         goto skip;
+      /* convert working LP basis to original LP basis and store it to
+       * problem object */
+      daeh = talloc(1+csa->lp->n, int);
+      spx_store_basis(csa->lp, P, map, daeh);
+      /* compute simplex multipliers for final basic solution found by
+       * the solver */
+      spx_eval_pi(csa->lp, csa->work);
+      /* convert working LP solution to original LP solution and store
+       * it to problem object */
+#if SCALE_Z
+      for (i = 1; i <= csa->lp->m; i++)
+         csa->work[i] *= csa->fz;
+      for (j = 1; j <= csa->lp->n-csa->lp->m; j++)
+         csa->d[j] *= csa->fz;
+#endif
+      spx_store_sol(csa->lp, P, parm->shift, map, daeh, csa->beta,
+         csa->work, csa->d);
+      tfree(daeh);
+      /* save simplex iteration count */
+      P->it_cnt = csa->it_cnt;
+      /* report auxiliary/structural variable causing unboundedness */
+      P->some = 0;
+      if (csa->p_stat == GLP_NOFEAS && csa->d_stat == GLP_FEAS)
+      {  int k, kk;
+         /* xB[p] = x[k] causes dual unboundedness */
+         xassert(1 <= csa->p && csa->p <= csa->lp->m);
+         k = csa->lp->head[csa->p];
+         xassert(1 <= k && k <= csa->lp->n);
+         /* convert to number of original variable */
+         for (kk = 1; kk <= P->m + P->n; kk++)
+         {  if (abs(map[kk]) == k)
+            {  P->some = kk;
+               break;
+            }
+         }
+         xassert(P->some != 0);
+      }
+skip: /* deallocate working objects and arrays */
+      spx_free_lp(csa->lp);
+      tfree(map);
+      tfree(csa->orig_b);
+      tfree(csa->orig_c);
+      tfree(csa->orig_l);
+      tfree(csa->orig_u);
+      if (csa->at != NULL)
+         spx_free_at(csa->lp, csa->at);
+      if (csa->nt != NULL)
+         spx_free_nt(csa->lp, csa->nt);
+      tfree(csa->beta);
+      tfree(csa->d);
+      if (csa->se != NULL)
+         spy_free_se(csa->lp, csa->se);
+#if 0 /* 30/III-2016 */
+      tfree(csa->list);
+      tfree(csa->trow);
+#else
+      fvs_free_vec(&csa->r);
+      fvs_free_vec(&csa->trow);
+#endif
+#if 1 /* 16/III-2016 */
+      if (csa->bp != NULL)
+         tfree(csa->bp);
+#endif
+#if 0 /* 29/III-2016 */
+      tfree(csa->tcol);
+#else
+      fvs_free_vec(&csa->tcol);
+#endif
+      tfree(csa->work);
+      tfree(csa->work1);
+#if 0 /* 11/VI-2017 */
+#if 1 /* 31/III-2016 */
+      fvs_free_vec(&csa->wrow);
+      fvs_free_vec(&csa->wcol);
+#endif
+#endif
+      /* return to calling program */
+      return ret >= 0 ? ret : GLP_EFAIL;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplux.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/lux.c`

 * *Files 22% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glplux.c */
+/* lux.c (LU-factorization, rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,36 +15,38 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glplux.h"
+#include "env.h"
+#include "lux.h"
+
 #define xfault xerror
 #define dmp_create_poolx(size) dmp_create_pool()
 
-/*----------------------------------------------------------------------
-// lux_create - create LU-factorization.
-//
-// SYNOPSIS
-//
-// #include "glplux.h"
-// LUX *lux_create(int n);
-//
-// DESCRIPTION
-//
-// The routine lux_create creates LU-factorization data structure for
-// a matrix of the order n. Initially the factorization corresponds to
-// the unity matrix (F = V = P = Q = I, so A = I).
-//
-// RETURNS
-//
-// The routine returns a pointer to the created LU-factorization data
-// structure, which represents the unity matrix of the order n. */
+/***********************************************************************
+*  lux_create - create LU-factorization
+*
+*  SYNOPSIS
+*
+*  #include "lux.h"
+*  LUX *lux_create(int n);
+*
+*  DESCRIPTION
+*
+*  The routine lux_create creates LU-factorization data structure for
+*  a matrix of the order n. Initially the factorization corresponds to
+*  the unity matrix (F = V = P = Q = I, so A = I).
+*
+*  RETURNS
+*
+*  The routine returns a pointer to the created LU-factorization data
+*  structure, which represents the unity matrix of the order n. */
 
 LUX *lux_create(int n)
 {     LUX *lux;
       int k;
       if (n < 1)
          xfault("lux_create: n = %d; invalid parameter\n", n);
       lux = xmalloc(sizeof(LUX));
@@ -70,21 +69,21 @@
          lux->P_row[k] = lux->P_col[k] = k;
          lux->Q_row[k] = lux->Q_col[k] = k;
       }
       lux->rank = n;
       return lux;
 }
 
-/*----------------------------------------------------------------------
-// initialize - initialize LU-factorization data structures.
-//
-// This routine initializes data structures for subsequent computing
-// the LU-factorization of a given matrix A, which is specified by the
-// formal routine col. On exit V = A and F = P = Q = I, where I is the
-// unity matrix. */
+/***********************************************************************
+*  initialize - initialize LU-factorization data structures
+*
+*  This routine initializes data structures for subsequent computing
+*  the LU-factorization of a given matrix A, which is specified by the
+*  formal routine col. On exit V = A and F = P = Q = I, where I is the
+*  unity matrix. */
 
 static void initialize(LUX *lux, int (*col)(void *info, int j,
       int ind[], mpq_t val[]), void *info, LUXWKA *wka)
 {     int n = lux->n;
       DMP *pool = lux->pool;
       LUXELM **F_row = lux->F_row;
       LUXELM **F_col = lux->F_col;
@@ -202,64 +201,64 @@
          C_next[j] = C_head[len];
          if (C_next[j] != 0) C_prev[C_next[j]] = j;
          C_head[len] = j;
       }
       return;
 }
 
-/*----------------------------------------------------------------------
-// find_pivot - choose a pivot element.
-//
-// This routine chooses a pivot element v[p,q] in the active submatrix
-// of matrix U = P*V*Q.
-//
-// It is assumed that on entry the matrix U has the following partially
-// triangularized form:
-//
-//       1       k         n
-//    1  x x x x x x x x x x
-//       . x x x x x x x x x
-//       . . x x x x x x x x
-//       . . . x x x x x x x
-//    k  . . . . * * * * * *
-//       . . . . * * * * * *
-//       . . . . * * * * * *
-//       . . . . * * * * * *
-//       . . . . * * * * * *
-//    n  . . . . * * * * * *
-//
-// where rows and columns k, k+1, ..., n belong to the active submatrix
-// (elements of the active submatrix are marked by '*').
-//
-// Since the matrix U = P*V*Q is not stored, the routine works with the
-// matrix V. It is assumed that the row-wise representation corresponds
-// to the matrix V, but the column-wise representation corresponds to
-// the active submatrix of the matrix V, i.e. elements of the matrix V,
-// which does not belong to the active submatrix, are missing from the
-// column linked lists. It is also assumed that each active row of the
-// matrix V is in the set R[len], where len is number of non-zeros in
-// the row, and each active column of the matrix V is in the set C[len],
-// where len is number of non-zeros in the column (in the latter case
-// only elements of the active submatrix are counted; such elements are
-// marked by '*' on the figure above).
-//
-// Due to exact arithmetic any non-zero element of the active submatrix
-// can be chosen as a pivot. However, to keep sparsity of the matrix V
-// the routine uses Markowitz strategy, trying to choose such element
-// v[p,q], which has smallest Markowitz cost (nr[p]-1) * (nc[q]-1),
-// where nr[p] and nc[q] are the number of non-zero elements, resp., in
-// p-th row and in q-th column of the active submatrix.
-//
-// In order to reduce the search, i.e. not to walk through all elements
-// of the active submatrix, the routine exploits a technique proposed by
-// I.Duff. This technique is based on using the sets R[len] and C[len]
-// of active rows and columns.
-//
-// On exit the routine returns a pointer to a pivot v[p,q] chosen, or
-// NULL, if the active submatrix is empty. */
+/***********************************************************************
+*  find_pivot - choose a pivot element
+*
+*  This routine chooses a pivot element v[p,q] in the active submatrix
+*  of matrix U = P*V*Q.
+*
+*  It is assumed that on entry the matrix U has the following partially
+*  triangularized form:
+*
+*        1       k         n
+*     1  x x x x x x x x x x
+*        . x x x x x x x x x
+*        . . x x x x x x x x
+*        . . . x x x x x x x
+*     k  . . . . * * * * * *
+*        . . . . * * * * * *
+*        . . . . * * * * * *
+*        . . . . * * * * * *
+*        . . . . * * * * * *
+*     n  . . . . * * * * * *
+*
+*  where rows and columns k, k+1, ..., n belong to the active submatrix
+*  (elements of the active submatrix are marked by '*').
+*
+*  Since the matrix U = P*V*Q is not stored, the routine works with the
+*  matrix V. It is assumed that the row-wise representation corresponds
+*  to the matrix V, but the column-wise representation corresponds to
+*  the active submatrix of the matrix V, i.e. elements of the matrix V,
+*  which does not belong to the active submatrix, are missing from the
+*  column linked lists. It is also assumed that each active row of the
+*  matrix V is in the set R[len], where len is number of non-zeros in
+*  the row, and each active column of the matrix V is in the set C[len],
+*  where len is number of non-zeros in the column (in the latter case
+*  only elements of the active submatrix are counted; such elements are
+*  marked by '*' on the figure above).
+*
+*  Due to exact arithmetic any non-zero element of the active submatrix
+*  can be chosen as a pivot. However, to keep sparsity of the matrix V
+*  the routine uses Markowitz strategy, trying to choose such element
+*  v[p,q], which has smallest Markowitz cost (nr[p]-1) * (nc[q]-1),
+*  where nr[p] and nc[q] are the number of non-zero elements, resp., in
+*  p-th row and in q-th column of the active submatrix.
+*
+*  In order to reduce the search, i.e. not to walk through all elements
+*  of the active submatrix, the routine exploits a technique proposed by
+*  I.Duff. This technique is based on using the sets R[len] and C[len]
+*  of active rows and columns.
+*
+*  On exit the routine returns a pointer to a pivot v[p,q] chosen, or
+*  NULL, if the active submatrix is empty. */
 
 static LUXELM *find_pivot(LUX *lux, LUXWKA *wka)
 {     int n = lux->n;
       LUXELM **V_row = lux->V_row;
       LUXELM **V_col = lux->V_col;
       int *R_len = wka->R_len;
       int *R_head = wka->R_head;
@@ -352,71 +351,71 @@
             if (ncand == piv_lim) goto done;
          }
       }
 done: /* bring the pivot v[p,q] to the factorizing routine */
       return piv;
 }
 
-/*----------------------------------------------------------------------
-// eliminate - perform gaussian elimination.
-//
-// This routine performs elementary gaussian transformations in order
-// to eliminate subdiagonal elements in the k-th column of the matrix
-// U = P*V*Q using the pivot element u[k,k], where k is the number of
-// the current elimination step.
-//
-// The parameter piv specifies the pivot element v[p,q] = u[k,k].
-//
-// Each time when the routine applies the elementary transformation to
-// a non-pivot row of the matrix V, it stores the corresponding element
-// to the matrix F in order to keep the main equality A = F*V.
-//
-// The routine assumes that on entry the matrices L = P*F*inv(P) and
-// U = P*V*Q are the following:
-//
-//       1       k                  1       k         n
-//    1  1 . . . . . . . . .     1  x x x x x x x x x x
-//       x 1 . . . . . . . .        . x x x x x x x x x
-//       x x 1 . . . . . . .        . . x x x x x x x x
-//       x x x 1 . . . . . .        . . . x x x x x x x
-//    k  x x x x 1 . . . . .     k  . . . . * * * * * *
-//       x x x x _ 1 . . . .        . . . . # * * * * *
-//       x x x x _ . 1 . . .        . . . . # * * * * *
-//       x x x x _ . . 1 . .        . . . . # * * * * *
-//       x x x x _ . . . 1 .        . . . . # * * * * *
-//    n  x x x x _ . . . . 1     n  . . . . # * * * * *
-//
-//            matrix L                   matrix U
-//
-// where rows and columns of the matrix U with numbers k, k+1, ..., n
-// form the active submatrix (eliminated elements are marked by '#' and
-// other elements of the active submatrix are marked by '*'). Note that
-// each eliminated non-zero element u[i,k] of the matrix U gives the
-// corresponding element l[i,k] of the matrix L (marked by '_').
-//
-// Actually all operations are performed on the matrix V. Should note
-// that the row-wise representation corresponds to the matrix V, but the
-// column-wise representation corresponds to the active submatrix of the
-// matrix V, i.e. elements of the matrix V, which doesn't belong to the
-// active submatrix, are missing from the column linked lists.
-//
-// Let u[k,k] = v[p,q] be the pivot. In order to eliminate subdiagonal
-// elements u[i',k] = v[i,q], i' = k+1, k+2, ..., n, the routine applies
-// the following elementary gaussian transformations:
-//
-//    (i-th row of V) := (i-th row of V) - f[i,p] * (p-th row of V),
-//
-// where f[i,p] = v[i,q] / v[p,q] is a gaussian multiplier.
-//
-// Additionally, in order to keep the main equality A = F*V, each time
-// when the routine applies the transformation to i-th row of the matrix
-// V, it also adds f[i,p] as a new element to the matrix F.
-//
-// IMPORTANT: On entry the working arrays flag and work should contain
-// zeros. This status is provided by the routine on exit. */
+/***********************************************************************
+*  eliminate - perform gaussian elimination
+*
+*  This routine performs elementary gaussian transformations in order
+*  to eliminate subdiagonal elements in the k-th column of the matrix
+*  U = P*V*Q using the pivot element u[k,k], where k is the number of
+*  the current elimination step.
+*
+*  The parameter piv specifies the pivot element v[p,q] = u[k,k].
+*
+*  Each time when the routine applies the elementary transformation to
+*  a non-pivot row of the matrix V, it stores the corresponding element
+*  to the matrix F in order to keep the main equality A = F*V.
+*
+*  The routine assumes that on entry the matrices L = P*F*inv(P) and
+*  U = P*V*Q are the following:
+*
+*        1       k                  1       k         n
+*     1  1 . . . . . . . . .     1  x x x x x x x x x x
+*        x 1 . . . . . . . .        . x x x x x x x x x
+*        x x 1 . . . . . . .        . . x x x x x x x x
+*        x x x 1 . . . . . .        . . . x x x x x x x
+*     k  x x x x 1 . . . . .     k  . . . . * * * * * *
+*        x x x x _ 1 . . . .        . . . . # * * * * *
+*        x x x x _ . 1 . . .        . . . . # * * * * *
+*        x x x x _ . . 1 . .        . . . . # * * * * *
+*        x x x x _ . . . 1 .        . . . . # * * * * *
+*     n  x x x x _ . . . . 1     n  . . . . # * * * * *
+*
+*             matrix L                   matrix U
+*
+*  where rows and columns of the matrix U with numbers k, k+1, ..., n
+*  form the active submatrix (eliminated elements are marked by '#' and
+*  other elements of the active submatrix are marked by '*'). Note that
+*  each eliminated non-zero element u[i,k] of the matrix U gives the
+*  corresponding element l[i,k] of the matrix L (marked by '_').
+*
+*  Actually all operations are performed on the matrix V. Should note
+*  that the row-wise representation corresponds to the matrix V, but the
+*  column-wise representation corresponds to the active submatrix of the
+*  matrix V, i.e. elements of the matrix V, which doesn't belong to the
+*  active submatrix, are missing from the column linked lists.
+*
+*  Let u[k,k] = v[p,q] be the pivot. In order to eliminate subdiagonal
+*  elements u[i',k] = v[i,q], i' = k+1, k+2, ..., n, the routine applies
+*  the following elementary gaussian transformations:
+*
+*     (i-th row of V) := (i-th row of V) - f[i,p] * (p-th row of V),
+*
+*  where f[i,p] = v[i,q] / v[p,q] is a gaussian multiplier.
+*
+*  Additionally, in order to keep the main equality A = F*V, each time
+*  when the routine applies the transformation to i-th row of the matrix
+*  V, it also adds f[i,p] as a new element to the matrix F.
+*
+*  IMPORTANT: On entry the working arrays flag and work should contain
+*  zeros. This status is provided by the routine on exit. */
 
 static void eliminate(LUX *lux, LUXWKA *wka, LUXELM *piv, int flag[],
       mpq_t work[])
 {     DMP *pool = lux->pool;
       LUXELM **F_row = lux->F_row;
       LUXELM **F_col = lux->F_col;
       mpq_t *V_piv = lux->V_piv;
@@ -656,86 +655,86 @@
          C_head[C_len[j]] = j;
       }
       mpq_clear(temp);
       /* return to the factorizing routine */
       return;
 }
 
-/*----------------------------------------------------------------------
-// lux_decomp - compute LU-factorization.
-//
-// SYNOPSIS
-//
-// #include "glplux.h"
-// int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],
-//    mpq_t val[]), void *info);
-//
-// DESCRIPTION
-//
-// The routine lux_decomp computes LU-factorization of a given square
-// matrix A.
-//
-// The parameter lux specifies LU-factorization data structure built by
-// means of the routine lux_create.
-//
-// The formal routine col specifies the original matrix A. In order to
-// obtain j-th column of the matrix A the routine lux_decomp calls the
-// routine col with the parameter j (1 <= j <= n, where n is the order
-// of A). In response the routine col should store row indices and
-// numerical values of non-zero elements of j-th column of A to the
-// locations ind[1], ..., ind[len] and val[1], ..., val[len], resp.,
-// where len is the number of non-zeros in j-th column, which should be
-// returned on exit. Neiter zero nor duplicate elements are allowed.
-//
-// The parameter info is a transit pointer passed to the formal routine
-// col; it can be used for various purposes.
-//
-// RETURNS
-//
-// The routine lux_decomp returns the singularity flag. Zero flag means
-// that the original matrix A is non-singular while non-zero flag means
-// that A is (exactly!) singular.
-//
-// Note that LU-factorization is valid in both cases, however, in case
-// of singularity some rows of the matrix V (including pivot elements)
-// will be empty.
-//
-// REPAIRING SINGULAR MATRIX
-//
-// If the routine lux_decomp returns non-zero flag, it provides all
-// necessary information that can be used for "repairing" the matrix A,
-// where "repairing" means replacing linearly dependent columns of the
-// matrix A by appropriate columns of the unity matrix. This feature is
-// needed when the routine lux_decomp is used for reinverting the basis
-// matrix within the simplex method procedure.
-//
-// On exit linearly dependent columns of the matrix U have the numbers
-// rank+1, rank+2, ..., n, where rank is the exact rank of the matrix A
-// stored by the routine to the member lux->rank. The correspondence
-// between columns of A and U is the same as between columns of V and U.
-// Thus, linearly dependent columns of the matrix A have the numbers
-// Q_col[rank+1], Q_col[rank+2], ..., Q_col[n], where Q_col is an array
-// representing the permutation matrix Q in column-like format. It is
-// understood that each j-th linearly dependent column of the matrix U
-// should be replaced by the unity vector, where all elements are zero
-// except the unity diagonal element u[j,j]. On the other hand j-th row
-// of the matrix U corresponds to the row of the matrix V (and therefore
-// of the matrix A) with the number P_row[j], where P_row is an array
-// representing the permutation matrix P in row-like format. Thus, each
-// j-th linearly dependent column of the matrix U should be replaced by
-// a column of the unity matrix with the number P_row[j].
-//
-// The code that repairs the matrix A may look like follows:
-//
-//    for (j = rank+1; j <= n; j++)
-//    {  replace column Q_col[j] of the matrix A by column P_row[j] of
-//       the unity matrix;
-//    }
-//
-// where rank, P_row, and Q_col are members of the structure LUX. */
+/***********************************************************************
+*  lux_decomp - compute LU-factorization
+*
+*  SYNOPSIS
+*
+*  #include "lux.h"
+*  int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],
+*     mpq_t val[]), void *info);
+*
+*  DESCRIPTION
+*
+*  The routine lux_decomp computes LU-factorization of a given square
+*  matrix A.
+*
+*  The parameter lux specifies LU-factorization data structure built by
+*  means of the routine lux_create.
+*
+*  The formal routine col specifies the original matrix A. In order to
+*  obtain j-th column of the matrix A the routine lux_decomp calls the
+*  routine col with the parameter j (1 <= j <= n, where n is the order
+*  of A). In response the routine col should store row indices and
+*  numerical values of non-zero elements of j-th column of A to the
+*  locations ind[1], ..., ind[len] and val[1], ..., val[len], resp.,
+*  where len is the number of non-zeros in j-th column, which should be
+*  returned on exit. Neiter zero nor duplicate elements are allowed.
+*
+*  The parameter info is a transit pointer passed to the formal routine
+*  col; it can be used for various purposes.
+*
+*  RETURNS
+*
+*  The routine lux_decomp returns the singularity flag. Zero flag means
+*  that the original matrix A is non-singular while non-zero flag means
+*  that A is (exactly!) singular.
+*
+*  Note that LU-factorization is valid in both cases, however, in case
+*  of singularity some rows of the matrix V (including pivot elements)
+*  will be empty.
+*
+*  REPAIRING SINGULAR MATRIX
+*
+*  If the routine lux_decomp returns non-zero flag, it provides all
+*  necessary information that can be used for "repairing" the matrix A,
+*  where "repairing" means replacing linearly dependent columns of the
+*  matrix A by appropriate columns of the unity matrix. This feature is
+*  needed when the routine lux_decomp is used for reinverting the basis
+*  matrix within the simplex method procedure.
+*
+*  On exit linearly dependent columns of the matrix U have the numbers
+*  rank+1, rank+2, ..., n, where rank is the exact rank of the matrix A
+*  stored by the routine to the member lux->rank. The correspondence
+*  between columns of A and U is the same as between columns of V and U.
+*  Thus, linearly dependent columns of the matrix A have the numbers
+*  Q_col[rank+1], Q_col[rank+2], ..., Q_col[n], where Q_col is an array
+*  representing the permutation matrix Q in column-like format. It is
+*  understood that each j-th linearly dependent column of the matrix U
+*  should be replaced by the unity vector, where all elements are zero
+*  except the unity diagonal element u[j,j]. On the other hand j-th row
+*  of the matrix U corresponds to the row of the matrix V (and therefore
+*  of the matrix A) with the number P_row[j], where P_row is an array
+*  representing the permutation matrix P in row-like format. Thus, each
+*  j-th linearly dependent column of the matrix U should be replaced by
+*  a column of the unity matrix with the number P_row[j].
+*
+*  The code that repairs the matrix A may look like follows:
+*
+*     for (j = rank+1; j <= n; j++)
+*     {  replace column Q_col[j] of the matrix A by column P_row[j] of
+*        the unity matrix;
+*     }
+*
+*  where rank, P_row, and Q_col are members of the structure LUX. */
 
 int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],
       mpq_t val[]), void *info)
 {     int n = lux->n;
       LUXELM **V_row = lux->V_row;
       LUXELM **V_col = lux->V_col;
       int *P_row = lux->P_row;
@@ -821,33 +820,33 @@
       xfree(wka->C_prev);
       xfree(wka->C_next);
       xfree(wka);
       /* return to the calling program */
       return (lux->rank < n);
 }
 
-/*----------------------------------------------------------------------
-// lux_f_solve - solve system F*x = b or F'*x = b.
-//
-// SYNOPSIS
-//
-// #include "glplux.h"
-// void lux_f_solve(LUX *lux, int tr, mpq_t x[]);
-//
-// DESCRIPTION
-//
-// The routine lux_f_solve solves either the system F*x = b (if the
-// flag tr is zero) or the system F'*x = b (if the flag tr is non-zero),
-// where the matrix F is a component of LU-factorization specified by
-// the parameter lux, F' is a matrix transposed to F.
-//
-// On entry the array x should contain elements of the right-hand side
-// vector b in locations x[1], ..., x[n], where n is the order of the
-// matrix F. On exit this array will contain elements of the solution
-// vector x in the same locations. */
+/***********************************************************************
+*  lux_f_solve - solve system F*x = b or F'*x = b
+*
+*  SYNOPSIS
+*
+*  #include "lux.h"
+*  void lux_f_solve(LUX *lux, int tr, mpq_t x[]);
+*
+*  DESCRIPTION
+*
+*  The routine lux_f_solve solves either the system F*x = b (if the
+*  flag tr is zero) or the system F'*x = b (if the flag tr is non-zero),
+*  where the matrix F is a component of LU-factorization specified by
+*  the parameter lux, F' is a matrix transposed to F.
+*
+*  On entry the array x should contain elements of the right-hand side
+*  vector b in locations x[1], ..., x[n], where n is the order of the
+*  matrix F. On exit this array will contain elements of the solution
+*  vector x in the same locations. */
 
 void lux_f_solve(LUX *lux, int tr, mpq_t x[])
 {     int n = lux->n;
       LUXELM **F_row = lux->F_row;
       LUXELM **F_col = lux->F_col;
       int *P_row = lux->P_row;
       LUXELM *fik, *fkj;
@@ -878,33 +877,33 @@
             }
          }
       }
       mpq_clear(temp);
       return;
 }
 
-/*----------------------------------------------------------------------
-// lux_v_solve - solve system V*x = b or V'*x = b.
-//
-// SYNOPSIS
-//
-// #include "glplux.h"
-// void lux_v_solve(LUX *lux, int tr, double x[]);
-//
-// DESCRIPTION
-//
-// The routine lux_v_solve solves either the system V*x = b (if the
-// flag tr is zero) or the system V'*x = b (if the flag tr is non-zero),
-// where the matrix V is a component of LU-factorization specified by
-// the parameter lux, V' is a matrix transposed to V.
-//
-// On entry the array x should contain elements of the right-hand side
-// vector b in locations x[1], ..., x[n], where n is the order of the
-// matrix V. On exit this array will contain elements of the solution
-// vector x in the same locations. */
+/***********************************************************************
+*  lux_v_solve - solve system V*x = b or V'*x = b
+*
+*  SYNOPSIS
+*
+*  #include "lux.h"
+*  void lux_v_solve(LUX *lux, int tr, double x[]);
+*
+*  DESCRIPTION
+*
+*  The routine lux_v_solve solves either the system V*x = b (if the
+*  flag tr is zero) or the system V'*x = b (if the flag tr is non-zero),
+*  where the matrix V is a component of LU-factorization specified by
+*  the parameter lux, V' is a matrix transposed to V.
+*
+*  On entry the array x should contain elements of the right-hand side
+*  vector b in locations x[1], ..., x[n], where n is the order of the
+*  matrix V. On exit this array will contain elements of the solution
+*  vector x in the same locations. */
 
 void lux_v_solve(LUX *lux, int tr, mpq_t x[])
 {     int n = lux->n;
       mpq_t *V_piv = lux->V_piv;
       LUXELM **V_row = lux->V_row;
       LUXELM **V_col = lux->V_col;
       int *P_row = lux->P_row;
@@ -946,33 +945,33 @@
       }
       for (k = 1; k <= n; k++) mpq_clear(b[k]);
       mpq_clear(temp);
       xfree(b);
       return;
 }
 
-/*----------------------------------------------------------------------
-// lux_solve - solve system A*x = b or A'*x = b.
-//
-// SYNOPSIS
-//
-// #include "glplux.h"
-// void lux_solve(LUX *lux, int tr, mpq_t x[]);
-//
-// DESCRIPTION
-//
-// The routine lux_solve solves either the system A*x = b (if the flag
-// tr is zero) or the system A'*x = b (if the flag tr is non-zero),
-// where the parameter lux specifies LU-factorization of the matrix A,
-// A' is a matrix transposed to A.
-//
-// On entry the array x should contain elements of the right-hand side
-// vector b in locations x[1], ..., x[n], where n is the order of the
-// matrix A. On exit this array will contain elements of the solution
-// vector x in the same locations. */
+/***********************************************************************
+*  lux_solve - solve system A*x = b or A'*x = b
+*
+*  SYNOPSIS
+*
+*  #include "lux.h"
+*  void lux_solve(LUX *lux, int tr, mpq_t x[]);
+*
+*  DESCRIPTION
+*
+*  The routine lux_solve solves either the system A*x = b (if the flag
+*  tr is zero) or the system A'*x = b (if the flag tr is non-zero),
+*  where the parameter lux specifies LU-factorization of the matrix A,
+*  A' is a matrix transposed to A.
+*
+*  On entry the array x should contain elements of the right-hand side
+*  vector b in locations x[1], ..., x[n], where n is the order of the
+*  matrix A. On exit this array will contain elements of the solution
+*  vector x in the same locations. */
 
 void lux_solve(LUX *lux, int tr, mpq_t x[])
 {     if (lux->rank < lux->n)
          xfault("lux_solve: LU-factorization has incomplete rank\n");
       if (!tr)
       {  /* A = F*V, therefore inv(A) = inv(V)*inv(F) */
          lux_f_solve(lux, 0, x);
@@ -982,27 +981,27 @@
       {  /* A' = V'*F', therefore inv(A') = inv(F')*inv(V') */
          lux_v_solve(lux, 1, x);
          lux_f_solve(lux, 1, x);
       }
       return;
 }
 
-/*----------------------------------------------------------------------
-// lux_delete - delete LU-factorization.
-//
-// SYNOPSIS
-//
-// #include "glplux.h"
-// void lux_delete(LUX *lux);
-//
-// DESCRIPTION
-//
-// The routine lux_delete deletes LU-factorization data structure,
-// which the parameter lux points to, freeing all the memory allocated
-// to this object. */
+/***********************************************************************
+*  lux_delete - delete LU-factorization
+*
+*  SYNOPSIS
+*
+*  #include "lux.h"
+*  void lux_delete(LUX *lux);
+*
+*  DESCRIPTION
+*
+*  The routine lux_delete deletes LU-factorization data structure,
+*  which the parameter lux points to, freeing all the memory allocated
+*  to this object. */
 
 void lux_delete(LUX *lux)
 {     int n = lux->n;
       LUXELM *fij, *vij;
       int i;
       for (i = 1; i <= n; i++)
       {  for (fij = lux->F_row[i]; fij != NULL; fij = fij->r_next)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glplux.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/lux.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glplux.h (LU-factorization, bignum arithmetic) */
+/* lux.h (LU-factorization, rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,65 +15,65 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPLUX_H
-#define GLPLUX_H
+#ifndef LUX_H
+#define LUX_H
 
-#include "glpdmp.h"
-#include "glpgmp.h"
+#include "dmp.h"
+#include "mygmp.h"
 
-/*----------------------------------------------------------------------
-// The structure LUX defines LU-factorization of a square matrix A,
-// which is the following quartet:
-//
-//    [A] = (F, V, P, Q),                                            (1)
-//
-// where F and V are such matrices that
-//
-//    A = F * V,                                                     (2)
-//
-// and P and Q are such permutation matrices that the matrix
-//
-//    L = P * F * inv(P)                                             (3)
-//
-// is lower triangular with unity diagonal, and the matrix
-//
-//    U = P * V * Q                                                  (4)
-//
-// is upper triangular. All the matrices have the order n.
-//
-// The matrices F and V are stored in row/column-wise sparse format as
-// row and column linked lists of non-zero elements. Unity elements on
-// the main diagonal of the matrix F are not stored. Pivot elements of
-// the matrix V (that correspond to diagonal elements of the matrix U)
-// are also missing from the row and column lists and stored separately
-// in an ordinary array.
-//
-// The permutation matrices P and Q are stored as ordinary arrays using
-// both row- and column-like formats.
-//
-// The matrices L and U being completely defined by the matrices F, V,
-// P, and Q are not stored explicitly.
-//
-// It is easy to show that the factorization (1)-(3) is some version of
-// LU-factorization. Indeed, from (3) and (4) it follows that:
-//
-//    F = inv(P) * L * P,
-//
-//    V = inv(P) * U * inv(Q),
-//
-// and substitution into (2) gives:
-//
-//    A = F * V = inv(P) * L * U * inv(Q).
-//
-// For more details see the program documentation. */
+/***********************************************************************
+*  The structure LUX defines LU-factorization of a square matrix A,
+*  which is the following quartet:
+*
+*     [A] = (F, V, P, Q),                                            (1)
+*
+*  where F and V are such matrices that
+*
+*     A = F * V,                                                     (2)
+*
+*  and P and Q are such permutation matrices that the matrix
+*
+*     L = P * F * inv(P)                                             (3)
+*
+*  is lower triangular with unity diagonal, and the matrix
+*
+*     U = P * V * Q                                                  (4)
+*
+*  is upper triangular. All the matrices have the order n.
+*
+*  The matrices F and V are stored in row/column-wise sparse format as
+*  row and column linked lists of non-zero elements. Unity elements on
+*  the main diagonal of the matrix F are not stored. Pivot elements of
+*  the matrix V (that correspond to diagonal elements of the matrix U)
+*  are also missing from the row and column lists and stored separately
+*  in an ordinary array.
+*
+*  The permutation matrices P and Q are stored as ordinary arrays using
+*  both row- and column-like formats.
+*
+*  The matrices L and U being completely defined by the matrices F, V,
+*  P, and Q are not stored explicitly.
+*
+*  It is easy to show that the factorization (1)-(3) is some version of
+*  LU-factorization. Indeed, from (3) and (4) it follows that:
+*
+*     F = inv(P) * L * P,
+*
+*     V = inv(P) * U * inv(Q),
+*
+*  and substitution into (2) gives:
+*
+*     A = F * V = inv(P) * L * U * inv(Q).
+*
+*  For more details see the program documentation. */
 
 typedef struct LUX LUX;
 typedef struct LUXELM LUXELM;
 typedef struct LUXWKA LUXWKA;
 
 struct LUX
 {     /* LU-factorization of a square matrix */
@@ -186,36 +183,35 @@
          which is active and has the same length as j-th column */
       int *C_next; /* int C_next[1+n]; */
       /* C_next[0] is not used;
          C_next[j], 1 <= j <= n, is the number of a next column, which
          is active and has the same length as j-th column */
 };
 
-#define lux_create            _glp_lux_create
-#define lux_decomp            _glp_lux_decomp
-#define lux_f_solve           _glp_lux_f_solve
-#define lux_v_solve           _glp_lux_v_solve
-#define lux_solve             _glp_lux_solve
-#define lux_delete            _glp_lux_delete
-
+#define lux_create _glp_lux_create
 LUX *lux_create(int n);
 /* create LU-factorization */
 
+#define lux_decomp _glp_lux_decomp
 int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],
       mpq_t val[]), void *info);
 /* compute LU-factorization */
 
+#define lux_f_solve _glp_lux_f_solve
 void lux_f_solve(LUX *lux, int tr, mpq_t x[]);
 /* solve system F*x = b or F'*x = b */
 
+#define lux_v_solve _glp_lux_v_solve
 void lux_v_solve(LUX *lux, int tr, mpq_t x[]);
 /* solve system V*x = b or V'*x = b */
 
+#define lux_solve _glp_lux_solve
 void lux_solve(LUX *lux, int tr, mpq_t x[]);
 /* solve system A*x = b or A'*x = b */
 
+#define lux_delete _glp_lux_delete
 void lux_delete(LUX *lux);
 /* delete LU-factorization */
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmat.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpmat.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpmat.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,24 +15,19 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#endif
-
-#include "glpenv.h"
+#include "env.h"
 #include "glpmat.h"
-#include "glpqmd.h"
-#include "amd/amd.h"
-#include "colamd/colamd.h"
+#include "qmd.h"
+#include "amd.h"
+#include "colamd.h"
 
 /*----------------------------------------------------------------------
 -- check_fvs - check sparse vector in full-vector storage format.
 --
 -- SYNOPSIS
 --
 -- #include "glpmat.h"
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmat.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpmat.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 /* glpmat.h (linear algebra routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -23,121 +20,121 @@
 ***********************************************************************/
 
 #ifndef GLPMAT_H
 #define GLPMAT_H
 
 /***********************************************************************
 *  FULL-VECTOR STORAGE
-* 
+*
 *  For a sparse vector x having n elements, ne of which are non-zero,
 *  the full-vector storage format uses two arrays x_ind and x_vec, which
 *  are set up as follows:
-* 
+*
 *  x_ind is an integer array of length [1+ne]. Location x_ind[0] is
 *  not used, and locations x_ind[1], ..., x_ind[ne] contain indices of
 *  non-zero elements in vector x.
-* 
+*
 *  x_vec is a floating-point array of length [1+n]. Location x_vec[0]
 *  is not used, and locations x_vec[1], ..., x_vec[n] contain numeric
 *  values of ALL elements in vector x, including its zero elements.
-* 
+*
 *  Let, for example, the following sparse vector x be given:
-* 
+*
 *     (0, 1, 0, 0, 2, 3, 0, 4)
-* 
+*
 *  Then the arrays are:
-* 
+*
 *     x_ind = { X; 2, 5, 6, 8 }
-* 
+*
 *     x_vec = { X; 0, 1, 0, 0, 2, 3, 0, 4 }
-* 
+*
 *  COMPRESSED-VECTOR STORAGE
-* 
+*
 *  For a sparse vector x having n elements, ne of which are non-zero,
 *  the compressed-vector storage format uses two arrays x_ind and x_vec,
 *  which are set up as follows:
-* 
+*
 *  x_ind is an integer array of length [1+ne]. Location x_ind[0] is
 *  not used, and locations x_ind[1], ..., x_ind[ne] contain indices of
 *  non-zero elements in vector x.
-* 
+*
 *  x_vec is a floating-point array of length [1+ne]. Location x_vec[0]
 *  is not used, and locations x_vec[1], ..., x_vec[ne] contain numeric
 *  values of corresponding non-zero elements in vector x.
-* 
+*
 *  Let, for example, the following sparse vector x be given:
-* 
+*
 *     (0, 1, 0, 0, 2, 3, 0, 4)
-* 
+*
 *  Then the arrays are:
 *
 *     x_ind = { X; 2, 5, 6, 8 }
-* 
+*
 *     x_vec = { X; 1, 2, 3, 4 }
-* 
+*
 *  STORAGE-BY-ROWS
-* 
+*
 *  For a sparse matrix A, which has m rows, n columns, and ne non-zero
 *  elements the storage-by-rows format uses three arrays A_ptr, A_ind,
 *  and A_val, which are set up as follows:
-* 
+*
 *  A_ptr is an integer array of length [1+m+1] also called "row pointer
 *  array". It contains the relative starting positions of each row of A
 *  in the arrays A_ind and A_val, i.e. element A_ptr[i], 1 <= i <= m,
 *  indicates where row i begins in the arrays A_ind and A_val. If all
 *  elements in row i are zero, then A_ptr[i] = A_ptr[i+1]. Location
 *  A_ptr[0] is not used, location A_ptr[1] must contain 1, and location
 *  A_ptr[m+1] must contain ne+1 that indicates the position after the
 *  last element in the arrays A_ind and A_val.
-* 
+*
 *  A_ind is an integer array of length [1+ne]. Location A_ind[0] is not
 *  used, and locations A_ind[1], ..., A_ind[ne] contain column indices
 *  of (non-zero) elements in matrix A.
 *
 *  A_val is a floating-point array of length [1+ne]. Location A_val[0]
 *  is not used, and locations A_val[1], ..., A_val[ne] contain numeric
 *  values of non-zero elements in matrix A.
-* 
+*
 *  Non-zero elements of matrix A are stored contiguously, and the rows
 *  of matrix A are stored consecutively from 1 to m in the arrays A_ind
 *  and A_val. The elements in each row of A may be stored in any order
 *  in A_ind and A_val. Note that elements with duplicate column indices
 *  are not allowed.
-* 
+*
 *  Let, for example, the following sparse matrix A be given:
-* 
+*
 *     | 11  . 13  .  .  . |
 *     | 21 22  . 24  .  . |
 *     |  . 32 33  .  .  . |
 *     |  .  . 43 44  . 46 |
 *     |  .  .  .  .  .  . |
 *     | 61 62  .  .  . 66 |
-* 
+*
 *  Then the arrays are:
-* 
+*
 *     A_ptr = { X; 1, 3, 6, 8, 11, 11; 14 }
 *
 *     A_ind = { X;  1,  3;  4,  2,  1;  2,  3;  4,  3,  6;  1,  2,  6 }
-* 
+*
 *     A_val = { X; 11, 13; 24, 22, 21; 32, 33; 44, 43, 46; 61, 62, 66 }
-* 
+*
 *  PERMUTATION MATRICES
-* 
+*
 *  Let P be a permutation matrix of the order n. It is represented as
 *  an integer array P_per of length [1+n+n] as follows: if p[i,j] = 1,
 *  then P_per[i] = j and P_per[n+j] = i. Location P_per[0] is not used.
-* 
+*
 *  Let A' = P*A. If i-th row of A corresponds to i'-th row of A', then
 *  P_per[i'] = i and P_per[n+i] = i'.
-* 
+*
 *  References:
-* 
+*
 *  1. Gustavson F.G. Some basic techniques for solving sparse systems of
 *     linear equations. In Rose and Willoughby (1972), pp. 41-52.
-* 
+*
 *  2. Basic Linear Algebra Subprograms Technical (BLAST) Forum Standard.
 *     University of Tennessee (2001). */
 
 #define check_fvs _glp_mat_check_fvs
 int check_fvs(int n, int nnz, int ind[], double vec[]);
 /* check sparse vector in full-vector storage format */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpmpl.h (GNU MathProg translator) */
+/* mpl.h (GNU MathProg translator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,21 +15,28 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPMPL_H
-#define GLPMPL_H
+#ifndef MPL_H
+#define MPL_H
 
-#include "glpavl.h"
-#include "glprng.h"
+#include "avl.h"
+#include "dmp.h"
+#include "env.h"
+#include "misc.h"
+#include "rng.h"
 
+#if 0 /* 22/I-2013 */
 typedef struct MPL MPL;
+#else
+typedef struct glp_tran MPL;
+#endif
 typedef char STRING;
 typedef struct SYMBOL SYMBOL;
 typedef struct TUPLE TUPLE;
 typedef struct ARRAY ELEMSET;
 typedef struct ELEMVAR ELEMVAR;
 typedef struct FORMULA FORMULA;
 typedef struct ELEMCON ELEMCON;
@@ -111,15 +115,19 @@
 
 #define CONTEXT_SIZE 60
 /* size of the context queue, in characters */
 
 #define OUTBUF_SIZE 1024
 /* size of the output buffer, in characters */
 
+#if 0 /* 22/I-2013 */
 struct MPL
+#else
+struct glp_tran
+#endif
 {     /* translator database */
       /*--------------------------------------------------------------*/
       /* scanning segment */
       int line;
       /* number of the current text line */
       int c;
       /* the current character or EOF */
@@ -282,31 +290,31 @@
          to i-th row of the problem, 1 <= i <= m */
       ELEMVAR **col; /* ELEMVAR *col[1+n]; */
       /* col[0] is not used;
          col[j] is elemental variable, which corresponds to j-th column
          of the problem, 1 <= j <= n */
       /*--------------------------------------------------------------*/
       /* input/output segment */
-      XFILE *in_fp;
+      glp_file *in_fp;
       /* stream assigned to the input text file */
       char *in_file;
       /* name of the input text file */
-      XFILE *out_fp;
+      glp_file *out_fp;
       /* stream assigned to the output text file used to write all data
          produced by display and printf statements; NULL means the data
          should be sent to stdout via the routine xprintf */
       char *out_file;
       /* name of the output text file */
 #if 0 /* 08/XI-2009 */
       char *out_buf; /* char out_buf[OUTBUF_SIZE] */
       /* buffer to accumulate output data */
       int out_cnt;
       /* count of data bytes stored in the output buffer */
 #endif
-      XFILE *prt_fp;
+      glp_file *prt_fp;
       /* stream assigned to the print text file; may be NULL */
       char *prt_file;
       /* name of the output print file */
       /*--------------------------------------------------------------*/
       /* solver interface segment */
       jmp_buf jump;
       /* jump address for non-local go to in case of error */
@@ -822,14 +830,18 @@
 double fp_sin(MPL *mpl, double x);
 /* floating-point trigonometric sine */
 
 #define fp_cos _glp_mpl_fp_cos
 double fp_cos(MPL *mpl, double x);
 /* floating-point trigonometric cosine */
 
+#define fp_tan _glp_mpl_fp_tan
+double fp_tan(MPL *mpl, double x);
+/* floating-point trigonometric tangent */
+
 #define fp_atan _glp_mpl_fp_atan
 double fp_atan(MPL *mpl, double x);
 /* floating-point trigonometric arctangent */
 
 #define fp_atan2 _glp_mpl_fp_atan2
 double fp_atan2(MPL *mpl, double y, double x);
 /* floating-point trigonometric arctangent */
@@ -2102,70 +2114,71 @@
 #define O_FLOOR         326   /* round downward ("floor of x") */
 #define O_EXP           327   /* base-e exponential */
 #define O_LOG           328   /* natural logarithm */
 #define O_LOG10         329   /* common (decimal) logarithm */
 #define O_SQRT          330   /* square root */
 #define O_SIN           331   /* trigonometric sine */
 #define O_COS           332   /* trigonometric cosine */
-#define O_ATAN          333   /* trigonometric arctangent */
-#define O_ROUND         334   /* round to nearest integer */
-#define O_TRUNC         335   /* truncate to nearest integer */
-#define O_CARD          336   /* cardinality of set */
-#define O_LENGTH        337   /* length of symbolic value */
+#define O_TAN           333   /* trigonometric tangent */
+#define O_ATAN          334   /* trigonometric arctangent */
+#define O_ROUND         335   /* round to nearest integer */
+#define O_TRUNC         336   /* truncate to nearest integer */
+#define O_CARD          337   /* cardinality of set */
+#define O_LENGTH        338   /* length of symbolic value */
                               /* binary operations -------------------*/
-#define O_ADD           338   /* addition */
-#define O_SUB           339   /* subtraction */
-#define O_LESS          340   /* non-negative subtraction */
-#define O_MUL           341   /* multiplication */
-#define O_DIV           342   /* division */
-#define O_IDIV          343   /* quotient of exact division */
-#define O_MOD           344   /* remainder of exact division */
-#define O_POWER         345   /* exponentiation (raise to power) */
-#define O_ATAN2         346   /* trigonometric arctangent */
-#define O_ROUND2        347   /* round to n fractional digits */
-#define O_TRUNC2        348   /* truncate to n fractional digits */
-#define O_UNIFORM       349   /* pseudo-random in [a, b) */
-#define O_NORMAL        350   /* gaussian random, given mu and sigma */
-#define O_CONCAT        351   /* concatenation */
-#define O_LT            352   /* comparison on 'less than' */
-#define O_LE            353   /* comparison on 'not greater than' */
-#define O_EQ            354   /* comparison on 'equal to' */
-#define O_GE            355   /* comparison on 'not less than' */
-#define O_GT            356   /* comparison on 'greater than' */
-#define O_NE            357   /* comparison on 'not equal to' */
-#define O_AND           358   /* conjunction (logical "and") */
-#define O_OR            359   /* disjunction (logical "or") */
-#define O_UNION         360   /* union */
-#define O_DIFF          361   /* difference */
-#define O_SYMDIFF       362   /* symmetric difference */
-#define O_INTER         363   /* intersection */
-#define O_CROSS         364   /* cross (Cartesian) product */
-#define O_IN            365   /* test on 'x in Y' */
-#define O_NOTIN         366   /* test on 'x not in Y' */
-#define O_WITHIN        367   /* test on 'X within Y' */
-#define O_NOTWITHIN     368   /* test on 'X not within Y' */
-#define O_SUBSTR        369   /* substring */
-#define O_STR2TIME      370   /* convert string to time */
-#define O_TIME2STR      371   /* convert time to string */
+#define O_ADD           339   /* addition */
+#define O_SUB           340   /* subtraction */
+#define O_LESS          341   /* non-negative subtraction */
+#define O_MUL           342   /* multiplication */
+#define O_DIV           343   /* division */
+#define O_IDIV          344   /* quotient of exact division */
+#define O_MOD           345   /* remainder of exact division */
+#define O_POWER         346   /* exponentiation (raise to power) */
+#define O_ATAN2         347   /* trigonometric arctangent */
+#define O_ROUND2        348   /* round to n fractional digits */
+#define O_TRUNC2        349   /* truncate to n fractional digits */
+#define O_UNIFORM       350   /* pseudo-random in [a, b) */
+#define O_NORMAL        351   /* gaussian random, given mu and sigma */
+#define O_CONCAT        352   /* concatenation */
+#define O_LT            353   /* comparison on 'less than' */
+#define O_LE            354   /* comparison on 'not greater than' */
+#define O_EQ            355   /* comparison on 'equal to' */
+#define O_GE            356   /* comparison on 'not less than' */
+#define O_GT            357   /* comparison on 'greater than' */
+#define O_NE            358   /* comparison on 'not equal to' */
+#define O_AND           359   /* conjunction (logical "and") */
+#define O_OR            360   /* disjunction (logical "or") */
+#define O_UNION         361   /* union */
+#define O_DIFF          362   /* difference */
+#define O_SYMDIFF       363   /* symmetric difference */
+#define O_INTER         364   /* intersection */
+#define O_CROSS         365   /* cross (Cartesian) product */
+#define O_IN            366   /* test on 'x in Y' */
+#define O_NOTIN         367   /* test on 'x not in Y' */
+#define O_WITHIN        368   /* test on 'X within Y' */
+#define O_NOTWITHIN     369   /* test on 'X not within Y' */
+#define O_SUBSTR        370   /* substring */
+#define O_STR2TIME      371   /* convert string to time */
+#define O_TIME2STR      372   /* convert time to string */
                               /* ternary operations ------------------*/
-#define O_DOTS          372   /* build "arithmetic" set */
-#define O_FORK          373   /* if-then-else */
-#define O_SUBSTR3       374   /* substring */
+#define O_DOTS          373   /* build "arithmetic" set */
+#define O_FORK          374   /* if-then-else */
+#define O_SUBSTR3       375   /* substring */
                               /* n-ary operations --------------------*/
-#define O_MIN           375   /* minimal value (n-ary) */
-#define O_MAX           376   /* maximal value (n-ary) */
+#define O_MIN           376   /* minimal value (n-ary) */
+#define O_MAX           377   /* maximal value (n-ary) */
                               /* iterated operations -----------------*/
-#define O_SUM           377   /* summation */
-#define O_PROD          378   /* multiplication */
-#define O_MINIMUM       379   /* minimum */
-#define O_MAXIMUM       380   /* maximum */
-#define O_FORALL        381   /* conjunction (A-quantification) */
-#define O_EXISTS        382   /* disjunction (E-quantification) */
-#define O_SETOF         383   /* compute elemental set */
-#define O_BUILD         384   /* build elemental set */
+#define O_SUM           378   /* summation */
+#define O_PROD          379   /* multiplication */
+#define O_MINIMUM       380   /* minimum */
+#define O_MAXIMUM       381   /* maximum */
+#define O_FORALL        382   /* conjunction (A-quantification) */
+#define O_EXISTS        383   /* disjunction (E-quantification) */
+#define O_SETOF         384   /* compute elemental set */
+#define O_BUILD         385   /* build elemental set */
       OPERANDS arg;
       /* operands that participate in the operation */
       int type;
       /* type of the resultant value:
          A_NUMERIC  - numeric
          A_SYMBOLIC - symbolic
          A_LOGICAL  - logical
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl1.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpmpl01.c */
+/* mpl1.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,22 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
+#include "mpl.h"
 
-#define _GLPSTD_STDIO
-#include "glpmpl.h"
 #define dmp_get_atomv dmp_get_atom
 
 /**********************************************************************/
 /* * *                  PROCESSING MODEL SECTION                  * * */
 /**********************************************************************/
 
 /*----------------------------------------------------------------------
@@ -604,14 +595,15 @@
          case O_FLOOR:
          case O_EXP:
          case O_LOG:
          case O_LOG10:
          case O_SQRT:
          case O_SIN:
          case O_COS:
+         case O_TAN:
          case O_ATAN:
          case O_ROUND:
          case O_TRUNC:
          case O_CARD:
          case O_LENGTH:
             /* unary operation */
             xassert(arg->arg.x != NULL);
@@ -1150,14 +1142,15 @@
 -- <primary expression> ::= log ( <arg> )
 -- <primary expression> ::= log10 ( <arg> )
 -- <primary expression> ::= max ( <arg list> )
 -- <primary expression> ::= min ( <arg list> )
 -- <primary expression> ::= sqrt ( <arg> )
 -- <primary expression> ::= sin ( <arg> )
 -- <primary expression> ::= cos ( <arg> )
+-- <primary expression> ::= tan ( <arg> )
 -- <primary expression> ::= atan ( <arg> )
 -- <primary expression> ::= atan2 ( <arg> , <arg> )
 -- <primary expression> ::= round ( <arg> )
 -- <primary expression> ::= round ( <arg> , <arg> )
 -- <primary expression> ::= trunc ( <arg> )
 -- <primary expression> ::= trunc ( <arg> , <arg> )
 -- <primary expression> ::= Irand224 ( )
@@ -1196,14 +1189,16 @@
          op = O_LOG10;
       else if (strcmp(mpl->image, "sqrt") == 0)
          op = O_SQRT;
       else if (strcmp(mpl->image, "sin") == 0)
          op = O_SIN;
       else if (strcmp(mpl->image, "cos") == 0)
          op = O_COS;
+      else if (strcmp(mpl->image, "tan") == 0)
+         op = O_TAN;
       else if (strcmp(mpl->image, "atan") == 0)
          op = O_ATAN;
       else if (strcmp(mpl->image, "min") == 0)
          op = O_MIN;
       else if (strcmp(mpl->image, "max") == 0)
          op = O_MAX;
       else if (strcmp(mpl->image, "round") == 0)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl2.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpmpl02.c */
+/* mpl2.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,17 +15,15 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#define _GLPSTD_STDIO
-#include "glpenv.h"
-#include "glpmpl.h"
+#include "mpl.h"
 
 /**********************************************************************/
 /* * *                  PROCESSING DATA SECTION                   * * */
 /**********************************************************************/
 
 /*----------------------------------------------------------------------
 -- create_slice - create slice.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl3.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpmpl03.c */
+/* mpl3.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,24 +15,15 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#define _GLPSTD_ERRNO
-#define _GLPSTD_STDIO
-#include "glpenv.h"
-#include "glpmpl.h"
+#include "mpl.h"
 
 /**********************************************************************/
 /* * *                   FLOATING-POINT NUMBERS                   * * */
 /**********************************************************************/
 
 /*----------------------------------------------------------------------
 -- fp_add - floating-point addition.
@@ -233,14 +221,25 @@
 double fp_cos(MPL *mpl, double x)
 {     if (!(-1e6 <= x && x <= +1e6))
          error(mpl, "cos(%.*g); argument too large", DBL_DIG, x);
       return cos(x);
 }
 
 /*----------------------------------------------------------------------
+-- fp_tan - floating-point trigonometric tangent.
+--
+-- This routine computes the trigonometric tangent tan(x). */
+
+double fp_tan(MPL *mpl, double x)
+{     if (!(-1e6 <= x && x <= +1e6))
+         error(mpl, "tan(%.*g); argument too large", DBL_DIG, x);
+      return tan(x);
+}
+
+/*----------------------------------------------------------------------
 -- fp_atan - floating-point trigonometric arctangent.
 --
 -- This routine computes the trigonometric arctangent atan(x). */
 
 double fp_atan(MPL *mpl, double x)
 {     xassert(mpl == mpl);
       return atan(x);
@@ -3684,14 +3683,18 @@
             /* trigonometric sine */
             value = fp_sin(mpl, eval_numeric(mpl, code->arg.arg.x));
             break;
          case O_COS:
             /* trigonometric cosine */
             value = fp_cos(mpl, eval_numeric(mpl, code->arg.arg.x));
             break;
+         case O_TAN:
+            /* trigonometric tangent */
+            value = fp_tan(mpl, eval_numeric(mpl, code->arg.arg.x));
+            break;
          case O_ATAN:
             /* trigonometric arctangent (one argument) */
             value = fp_atan(mpl, eval_numeric(mpl, code->arg.arg.x));
             break;
          case O_ATAN2:
             /* trigonometric arctangent (two arguments) */
             value = fp_atan2(mpl,
@@ -4879,14 +4882,15 @@
          case O_FLOOR:
          case O_EXP:
          case O_LOG:
          case O_LOG10:
          case O_SQRT:
          case O_SIN:
          case O_COS:
+         case O_TAN:
          case O_ATAN:
          case O_ROUND:
          case O_TRUNC:
          case O_CARD:
          case O_LENGTH:
             /* unary operation */
             clean_code(mpl, code->arg.arg.x);
@@ -5732,15 +5736,22 @@
 -- This routine executes specified printf statement. */
 
 #if 1 /* 14/VII-2006 */
 static void print_char(MPL *mpl, int c)
 {     if (mpl->prt_fp == NULL)
          write_char(mpl, c);
       else
+#if 0 /* 04/VIII-2013 */
          xfputc(c, mpl->prt_fp);
+#else
+      {  unsigned char buf[1];
+         buf[0] = (unsigned char)c;
+         glp_write(mpl->prt_fp, buf, 1);
+      }
+#endif
       return;
 }
 
 static void print_text(MPL *mpl, char *fmt, ...)
 {     va_list arg;
       char buf[OUTBUF_SIZE], *c;
       va_start(arg, fmt);
@@ -5887,15 +5898,15 @@
       return;
 }
 #else
 void execute_printf(MPL *mpl, PRINTF *prt)
 {     if (prt->fname == NULL)
       {  /* switch to the standard output */
          if (mpl->prt_fp != NULL)
-         {  xfclose(mpl->prt_fp), mpl->prt_fp = NULL;
+         {  glp_close(mpl->prt_fp), mpl->prt_fp = NULL;
             xfree(mpl->prt_file), mpl->prt_file = NULL;
          }
       }
       else
       {  /* evaluate file name string */
          SYMBOL *sym;
          char fname[MAX_LENGTH+1];
@@ -5904,33 +5915,36 @@
             sprintf(fname, "%.*g", DBL_DIG, sym->num);
          else
             fetch_string(mpl, sym->str, fname);
          delete_symbol(mpl, sym);
          /* close the current print file, if necessary */
          if (mpl->prt_fp != NULL &&
             (!prt->app || strcmp(mpl->prt_file, fname) != 0))
-         {  xfclose(mpl->prt_fp), mpl->prt_fp = NULL;
+         {  glp_close(mpl->prt_fp), mpl->prt_fp = NULL;
             xfree(mpl->prt_file), mpl->prt_file = NULL;
          }
          /* open the specified print file, if necessary */
          if (mpl->prt_fp == NULL)
-         {  mpl->prt_fp = xfopen(fname, prt->app ? "a" : "w");
+         {  mpl->prt_fp = glp_open(fname, prt->app ? "a" : "w");
             if (mpl->prt_fp == NULL)
-               error(mpl, "unable to open `%s' for writing - %s",
-                  fname, xerrmsg());
+               error(mpl, "unable to open '%s' for writing - %s",
+                  fname, get_err_msg());
             mpl->prt_file = xmalloc(strlen(fname)+1);
             strcpy(mpl->prt_file, fname);
          }
       }
       loop_within_domain(mpl, prt->domain, prt, printf_func);
       if (mpl->prt_fp != NULL)
-      {  xfflush(mpl->prt_fp);
-         if (xferror(mpl->prt_fp))
-            error(mpl, "writing error to `%s' - %s", mpl->prt_file,
-               xerrmsg());
+      {
+#if 0 /* FIXME */
+         xfflush(mpl->prt_fp);
+#endif
+         if (glp_ioerr(mpl->prt_fp))
+            error(mpl, "writing error to '%s' - %s", mpl->prt_file,
+               get_err_msg());
       }
       return;
 }
 #endif
 
 /*----------------------------------------------------------------------
 -- clean_printf - clean printf statement.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl04.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl4.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpmpl04.c */
+/* mpl4.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2016 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,23 +15,18 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
+#include "mpl.h"
 
-#define _GLPSTD_ERRNO
-#define _GLPSTD_STDIO
-#include "glpmpl.h"
 #define xfault xerror
+#define xfprintf glp_format
 #define dmp_create_poolx(size) dmp_create_pool()
 
 /**********************************************************************/
 /* * *              GENERATING AND POSTSOLVING MODEL              * * */
 /**********************************************************************/
 
 /*----------------------------------------------------------------------
@@ -235,38 +227,38 @@
 --       the generation phase. */
 
 void clean_model(MPL *mpl)
 {     STATEMENT *stmt;
       for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)
          clean_statement(mpl, stmt);
       /* check that all atoms have been returned to their pools */
-      if (dmp_in_use(mpl->strings).lo != 0)
+      if (dmp_in_use(mpl->strings) != 0)
          error(mpl, "internal logic error: %d string segment(s) were lo"
-            "st", dmp_in_use(mpl->strings).lo);
-      if (dmp_in_use(mpl->symbols).lo != 0)
+            "st", dmp_in_use(mpl->strings));
+      if (dmp_in_use(mpl->symbols) != 0)
          error(mpl, "internal logic error: %d symbol(s) were lost",
-            dmp_in_use(mpl->symbols).lo);
-      if (dmp_in_use(mpl->tuples).lo != 0)
+            dmp_in_use(mpl->symbols));
+      if (dmp_in_use(mpl->tuples) != 0)
          error(mpl, "internal logic error: %d n-tuple component(s) were"
-            " lost", dmp_in_use(mpl->tuples).lo);
-      if (dmp_in_use(mpl->arrays).lo != 0)
+            " lost", dmp_in_use(mpl->tuples));
+      if (dmp_in_use(mpl->arrays) != 0)
          error(mpl, "internal logic error: %d array(s) were lost",
-            dmp_in_use(mpl->arrays).lo);
-      if (dmp_in_use(mpl->members).lo != 0)
+            dmp_in_use(mpl->arrays));
+      if (dmp_in_use(mpl->members) != 0)
          error(mpl, "internal logic error: %d array member(s) were lost"
-            , dmp_in_use(mpl->members).lo);
-      if (dmp_in_use(mpl->elemvars).lo != 0)
+            , dmp_in_use(mpl->members));
+      if (dmp_in_use(mpl->elemvars) != 0)
          error(mpl, "internal logic error: %d elemental variable(s) wer"
-            "e lost", dmp_in_use(mpl->elemvars).lo);
-      if (dmp_in_use(mpl->formulae).lo != 0)
+            "e lost", dmp_in_use(mpl->elemvars));
+      if (dmp_in_use(mpl->formulae) != 0)
          error(mpl, "internal logic error: %d linear term(s) were lost",
-            dmp_in_use(mpl->formulae).lo);
-      if (dmp_in_use(mpl->elemcons).lo != 0)
+            dmp_in_use(mpl->formulae));
+      if (dmp_in_use(mpl->elemcons) != 0)
          error(mpl, "internal logic error: %d elemental constraint(s) w"
-            "ere lost", dmp_in_use(mpl->elemcons).lo);
+            "ere lost", dmp_in_use(mpl->elemcons));
       return;
 }
 
 /**********************************************************************/
 /* * *                        INPUT/OUTPUT                        * * */
 /**********************************************************************/
 
@@ -291,17 +283,17 @@
       mpl->f_token = 0;
       mpl->f_imlen = 0;
       mpl->f_image[0] = '\0';
       mpl->f_value = 0.0;
       memset(mpl->context, ' ', CONTEXT_SIZE);
       mpl->c_ptr = 0;
       xassert(mpl->in_fp == NULL);
-      mpl->in_fp = xfopen(file, "r");
+      mpl->in_fp = glp_open(file, "r");
       if (mpl->in_fp == NULL)
-         error(mpl, "unable to open %s - %s", file, xerrmsg());
+         error(mpl, "unable to open %s - %s", file, get_err_msg());
       mpl->in_file = file;
       /* scan the very first character */
       get_char(mpl);
       /* scan the very first token */
       get_token(mpl);
       return;
 }
@@ -311,69 +303,69 @@
 --
 -- This routine returns a next ASCII character read from the input text
 -- file. If the end of file has been reached, EOF is returned. */
 
 int read_char(MPL *mpl)
 {     int c;
       xassert(mpl->in_fp != NULL);
-      c = xfgetc(mpl->in_fp);
+      c = glp_getc(mpl->in_fp);
       if (c < 0)
-      {  if (xferror(mpl->in_fp))
+      {  if (glp_ioerr(mpl->in_fp))
             error(mpl, "read error on %s - %s", mpl->in_file,
-               xerrmsg());
+               get_err_msg());
          c = EOF;
       }
       return c;
 }
 
 /*----------------------------------------------------------------------
 -- close_input - close input text file.
 --
 -- This routine closes the input text file. */
 
 void close_input(MPL *mpl)
 {     xassert(mpl->in_fp != NULL);
-      xfclose(mpl->in_fp);
+      glp_close(mpl->in_fp);
       mpl->in_fp = NULL;
       mpl->in_file = NULL;
       return;
 }
 
 /*----------------------------------------------------------------------
 -- open_output - open output text file.
 --
 -- This routine opens the output text file for writing data produced by
 -- display and printf statements. */
 
 void open_output(MPL *mpl, char *file)
 {     xassert(mpl->out_fp == NULL);
-      /* if (file == NULL) */
-      /* {  file = "<stdout>"; */
-      /*    mpl->out_fp = (void *)stdout; */
-      /* } */
-      /* else */
-      {  mpl->out_fp = xfopen(file, "w");
+      if (file == NULL)
+      {  file = "<stdout>";
+         mpl->out_fp = (void *)stdout;
+      }
+      else
+      {  mpl->out_fp = glp_open(file, "w");
          if (mpl->out_fp == NULL)
-            error(mpl, "unable to create %s - %s", file, xerrmsg());
+            error(mpl, "unable to create %s - %s", file, get_err_msg());
       }
       mpl->out_file = xmalloc(strlen(file)+1);
       strcpy(mpl->out_file, file);
       return;
 }
 
 /*----------------------------------------------------------------------
 -- write_char - write next character to output text file.
 --
 -- This routine writes an ASCII character to the output text file. */
 
 void write_char(MPL *mpl, int c)
 {     xassert(mpl->out_fp != NULL);
-      /* if (mpl->out_fp == (void *)stdout) */
-      /*    xprintf("%c", c); */
-      /* else */
+      if (mpl->out_fp == (void *)stdout)
+         xprintf("%c", c);
+      else
          xfprintf(mpl->out_fp, "%c", c);
       return;
 }
 
 /*----------------------------------------------------------------------
 -- write_text - format and write text to output text file.
 --
@@ -394,19 +386,22 @@
 /*----------------------------------------------------------------------
 -- flush_output - finalize writing data to output text file.
 --
 -- This routine finalizes writing data to the output text file. */
 
 void flush_output(MPL *mpl)
 {     xassert(mpl->out_fp != NULL);
-      /* if (mpl->out_fp != (void *)stdout) */
-      {  xfflush(mpl->out_fp);
-         if (xferror(mpl->out_fp))
+      if (mpl->out_fp != (void *)stdout)
+      {
+#if 0 /* FIXME */
+         xfflush(mpl->out_fp);
+#endif
+         if (glp_ioerr(mpl->out_fp))
             error(mpl, "write error on %s - %s", mpl->out_file,
-               xerrmsg());
+               get_err_msg());
       }
       return;
 }
 
 /**********************************************************************/
 /* * *                      SOLVER INTERFACE                      * * */
 /**********************************************************************/
@@ -1410,19 +1405,19 @@
       dmp_delete_pool(mpl->formulae);
       dmp_delete_pool(mpl->elemcons);
       xfree(mpl->sym_buf);
       xfree(mpl->tup_buf);
       rng_delete_rand(mpl->rand);
       if (mpl->row != NULL) xfree(mpl->row);
       if (mpl->col != NULL) xfree(mpl->col);
-      if (mpl->in_fp != NULL) xfclose(mpl->in_fp);
-      if (mpl->out_fp != NULL /* && mpl->out_fp != (void *)stdout */)
-         xfclose(mpl->out_fp);
+      if (mpl->in_fp != NULL) glp_close(mpl->in_fp);
+      if (mpl->out_fp != NULL && mpl->out_fp != (void *)stdout)
+         glp_close(mpl->out_fp);
       if (mpl->out_file != NULL) xfree(mpl->out_file);
-      if (mpl->prt_fp != NULL) xfclose(mpl->prt_fp);
+      if (mpl->prt_fp != NULL) glp_close(mpl->prt_fp);
       if (mpl->prt_file != NULL) xfree(mpl->prt_file);
       if (mpl->mod_file != NULL) xfree(mpl->mod_file);
       xfree(mpl->mpl_buf);
       xfree(mpl);
       return;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmpl06.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mpl6.c`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpmpl06.c */
+/* mpl6.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,24 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#pragma clang diagnostic ignored "-Wself-assign"
-#endif
-
-#define _GLPSTD_ERRNO
-#define _GLPSTD_STDIO
-#include "glpmpl.h"
-#include "glpsql.h"
+#include "mpl.h"
+#include "mplsql.h"
 
 /**********************************************************************/
 
 #define CSV_FIELD_MAX 50
 /* maximal number of fields in record */
 
 #define CSV_FDLEN_MAX 100
@@ -83,15 +72,19 @@
 {     /* read character from csv data file */
       int c;
       xassert(csv->c != EOF);
       if (csv->c == '\n') csv->count++;
 loop: c = fgetc(csv->fp);
       if (ferror(csv->fp))
       {  xprintf("%s:%d: read error - %s\n", csv->fname, csv->count,
+#if 0 /* 29/I-2017 */
             strerror(errno));
+#else
+            xstrerr(errno));
+#endif
          longjmp(csv->jump, 0);
       }
       if (feof(csv->fp))
       {  if (csv->c == '\n')
          {  csv->count--;
             c = EOF;
          }
@@ -242,15 +235,19 @@
       strcpy(csv->fname, mpl_tab_get_arg(dca, 2));
       if (mode == 'R')
       {  /* open the file for reading */
          int k;
          csv->fp = fopen(csv->fname, "r");
          if (csv->fp == NULL)
          {  xprintf("csv_driver: unable to open %s - %s\n",
+#if 0 /* 29/I-2017 */
                csv->fname, strerror(errno));
+#else
+               csv->fname, xstrerr(errno));
+#endif
             longjmp(csv->jump, 0);
          }
 #if 1 /* 01/VI-2010 */
          csv->nskip = 0;
 #endif
          /* skip fake new-line */
          read_field(csv);
@@ -286,15 +283,19 @@
       }
       else if (mode == 'W')
       {  /* open the file for writing */
          int k, nf;
          csv->fp = fopen(csv->fname, "w");
          if (csv->fp == NULL)
          {  xprintf("csv_driver: unable to create %s - %s\n",
+#if 0 /* 29/I-2017 */
                csv->fname, strerror(errno));
+#else
+               csv->fname, xstrerr(errno));
+#endif
             longjmp(csv->jump, 0);
          }
          /* write field names */
          nf = mpl_tab_num_flds(dca);
          for (k = 1; k <= nf; k++)
             fprintf(csv->fp, "%s%c", mpl_tab_get_name(dca, k),
                k < nf ? ',' : '\n');
@@ -398,29 +399,37 @@
                xassert(dca != dca);
          }
          fputc(k < nf ? ',' : '\n', csv->fp);
       }
       csv->count++;
       if (ferror(csv->fp))
       {  xprintf("%s:%d: write error - %s\n", csv->fname, csv->count,
+#if 0 /* 29/I-2017 */
             strerror(errno));
+#else
+            xstrerr(errno));
+#endif
          ret = 1;
       }
       return ret;
 }
 
 static int csv_close_file(TABDCA *dca, struct csv *csv)
 {     /* close csv data file */
       int ret = 0;
       xassert(dca == dca);
       if (csv->mode == 'W')
       {  fflush(csv->fp);
          if (ferror(csv->fp))
          {  xprintf("%s:%d: write error - %s\n", csv->fname,
+#if 0 /* 29/I-2017 */
                csv->count, strerror(errno));
+#else
+               csv->count, xstrerr(errno));
+#endif
             ret = 1;
          }
       }
       xfree(csv->fname);
       fclose(csv->fp);
       xfree(csv);
       return ret;
@@ -464,15 +473,19 @@
 
 static int read_byte(struct dbf *dbf)
 {     /* read byte from xBASE data file */
       int b;
       b = fgetc(dbf->fp);
       if (ferror(dbf->fp))
       {  xprintf("%s:0x%X: read error - %s\n", dbf->fname,
+#if 0 /* 29/I-2017 */
             dbf->offset, strerror(errno));
+#else
+            dbf->offset, xstrerr(errno));
+#endif
          longjmp(dbf->jump, 0);
       }
       if (feof(dbf->fp))
       {  xprintf("%s:0x%X: unexpected end of file\n", dbf->fname,
             dbf->offset);
          longjmp(dbf->jump, 0);
       }
@@ -711,30 +724,38 @@
       dbf->fname = xmalloc(strlen(mpl_tab_get_arg(dca, 2))+1);
       strcpy(dbf->fname, mpl_tab_get_arg(dca, 2));
       if (mode == 'R')
       {  /* open the file for reading */
          dbf->fp = fopen(dbf->fname, "rb");
          if (dbf->fp == NULL)
          {  xprintf("xBASE driver: unable to open %s - %s\n",
+#if 0 /* 29/I-2017 */
                dbf->fname, strerror(errno));
+#else
+               dbf->fname, xstrerr(errno));
+#endif
             longjmp(dbf->jump, 0);
          }
          read_header(dca, dbf);
       }
       else if (mode == 'W')
       {  /* open the file for writing */
          if (mpl_tab_num_args(dca) < 3)
          {  xprintf("xBASE driver: file format not specified\n");
             longjmp(dbf->jump, 0);
          }
          parse_third_arg(dca, dbf);
          dbf->fp = fopen(dbf->fname, "wb");
          if (dbf->fp == NULL)
          {  xprintf("xBASE driver: unable to create %s - %s\n",
+#if 0 /* 29/I-2017 */
                dbf->fname, strerror(errno));
+#else
+               dbf->fname, xstrerr(errno));
+#endif
             longjmp(dbf->jump, 0);
          }
          write_header(dca, dbf);
       }
       else
          xassert(mode != mode);
       /* the file has been open */
@@ -866,25 +887,33 @@
          }
          /* end-of-file flag */
          write_byte(dbf, 0x1A);
          /* number of records */
          dbf->offset = 4;
          if (fseek(dbf->fp, dbf->offset, SEEK_SET))
          {  xprintf("%s:0x%X: seek error - %s\n", dbf->fname,
+#if 0 /* 29/I-2017 */
                dbf->offset, strerror(errno));
+#else
+               dbf->offset, xstrerr(errno));
+#endif
             longjmp(dbf->jump, 0);
          }
          write_byte(dbf, dbf->count);
          write_byte(dbf, dbf->count >> 8);
          write_byte(dbf, dbf->count >> 16);
          write_byte(dbf, dbf->count >> 24);
          fflush(dbf->fp);
          if (ferror(dbf->fp))
          {  xprintf("%s:0x%X: write error - %s\n", dbf->fname,
+#if 0 /* 29/I-2017 */
                dbf->offset, strerror(errno));
+#else
+               dbf->offset, xstrerr(errno));
+#endif
             longjmp(dbf->jump, 0);
          }
 skip:    ;
       }
       xfree(dbf->fname);
       fclose(dbf->fp);
       xfree(dbf);
@@ -917,15 +946,15 @@
          dca->link = db_iodbc_open(dca, mode);
       }
       else if (strcmp(dca->arg[1], "MySQL") == 0)
       {  dca->id = TAB_MYSQL;
          dca->link = db_mysql_open(dca, mode);
       }
       else
-         xprintf("Invalid table driver `%s'\n", dca->arg[1]);
+         xprintf("Invalid table driver '%s'\n", dca->arg[1]);
       if (dca->link == NULL)
          error(mpl, "error on opening table %s",
             mpl->stmt->u.tab->name);
       return;
 }
 
 int mpl_tab_drv_read(MPL *mpl)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpmps.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp6.c`

 * *Files 27% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpmps.c (MPS format routines) */
+/* npp6.c (translate feasibility problem to CNF-SAT) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2011-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,1390 +15,1484 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wself-assign"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#include "glpapi.h"
+#include "env.h"
+#include "npp.h"
 
 /***********************************************************************
-*  NAME
-*
-*  glp_init_mpscp - initialize MPS format control parameters
-*
-*  SYNOPSIS
-*
-*  void glp_init_mpscp(glp_mpscp *parm);
+*  npp_sat_free_row - process free (unbounded) row
 *
-*  DESCRIPTION
+*  This routine processes row p, which is free (i.e. has no finite
+*  bounds):
 *
-*  The routine glp_init_mpscp initializes control parameters, which are
-*  used by the MPS input/output routines glp_read_mps and glp_write_mps,
-*  with default values.
+*     -inf < sum a[p,j] x[j] < +inf.                                 (1)
 *
-*  Default values of the control parameters are stored in the glp_mpscp
-*  structure, which the parameter parm points to. */
+*  The constraint (1) cannot be active and therefore it is redundant,
+*  so the routine simply removes it from the original problem. */
 
-void glp_init_mpscp(glp_mpscp *parm)
-{     parm->blank = '\0';
-      parm->obj_name = NULL;
-      parm->tol_mps = 1e-12;
-      return;
-}
-
-static void check_parm(const char *func, const glp_mpscp *parm)
-{     /* check control parameters */
-      if (!(0x00 <= parm->blank && parm->blank <= 0xFF) ||
-          !(parm->blank == '\0' || isprint(parm->blank)))
-         xerror("%s: blank = 0x%02X; invalid parameter\n",
-            func, parm->blank);
-      if (!(parm->obj_name == NULL || strlen(parm->obj_name) <= 255))
-         xerror("%s: obj_name = \"%.12s...\"; parameter too long\n",
-            func, parm->obj_name);
-      if (!(0.0 <= parm->tol_mps && parm->tol_mps < 1.0))
-         xerror("%s: tol_mps = %g; invalid parameter\n",
-            func, parm->tol_mps);
+void npp_sat_free_row(NPP *npp, NPPROW *p)
+{     /* the row should be free */
+      xassert(p->lb == -DBL_MAX && p->ub == +DBL_MAX);
+      /* remove the row from the problem */
+      npp_del_row(npp, p);
       return;
 }
 
 /***********************************************************************
-*  NAME
+*  npp_sat_fixed_col - process fixed column
 *
-*  glp_read_mps - read problem data in MPS format
+*  This routine processes column q, which is fixed:
 *
-*  SYNOPSIS
+*     x[q] = s[q],                                                   (1)
 *
-*  int glp_read_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
-*     const char *fname);
+*  where s[q] is a fixed column value.
 *
-*  DESCRIPTION
+*  The routine substitutes fixed value s[q] into constraint rows and
+*  then removes column x[q] from the original problem.
 *
-*  The routine glp_read_mps reads problem data in MPS format from a
-*  text file.
+*  Substitution of x[q] = s[q] into row i gives:
 *
-*  The parameter fmt specifies the version of MPS format:
+*     L[i] <= sum a[i,j] x[j] <= U[i]   ==>
+*              j
 *
-*  GLP_MPS_DECK - fixed (ancient) MPS format;
-*  GLP_MPS_FILE - free (modern) MPS format.
+*     L[i] <= sum a[i,j] x[j] + a[i,q] x[q] <= U[i]   ==>
+*            j!=q
 *
-*  The parameter parm is a pointer to the structure glp_mpscp, which
-*  specifies control parameters used by the routine. If parm is NULL,
-*  the routine uses default settings.
+*     L[i] <= sum a[i,j] x[j] + a[i,q] s[q] <= U[i]   ==>
+*            j!=q
 *
-*  The character string fname specifies a name of the text file to be
-*  read.
+*     L~[i] <= sum a[i,j] x[j] <= U~[i],
+*             j!=q
 *
-*  Note that before reading data the current content of the problem
-*  object is completely erased with the routine glp_erase_prob.
+*  where
 *
-*  RETURNS
+*     L~[i] = L[i] - a[i,q] s[q],                                    (2)
+*
+*     U~[i] = U[i] - a[i,q] s[q]                                     (3)
 *
-*  If the operation was successful, the routine glp_read_mps returns
-*  zero. Otherwise, it prints an error message and returns non-zero. */
+*  are, respectively, lower and upper bound of row i in the transformed
+*  problem.
+*
+*  On recovering solution x[q] is assigned the value of s[q]. */
 
-struct csa
-{     /* common storage area */
-      glp_prob *P;
-      /* pointer to problem object */
-      int deck;
-      /* MPS format (0 - free, 1 - fixed) */
-      const glp_mpscp *parm;
-      /* pointer to control parameters */
-      const char *fname;
-      /* name of input MPS file */
-      XFILE *fp;
-      /* stream assigned to input MPS file */
-      jmp_buf jump;
-      /* label for go to in case of error */
-      int recno;
-      /* current record (card) number */
-      int recpos;
-      /* current record (card) position */
-      int c;
-      /* current character */
-      int fldno;
-      /* current field number */
-      char field[255+1];
-      /* current field content */
-      int w80;
-      /* warning 'record must not be longer than 80 chars' issued */
-      int wef;
-      /* warning 'extra fields detected beyond field 6' issued */
-      int obj_row;
-      /* objective row number */
-      void *work1, *work2, *work3;
-      /* working arrays */
+struct sat_fixed_col
+{     /* fixed column */
+      int q;
+      /* column reference number for variable x[q] */
+      int s;
+      /* value, at which x[q] is fixed */
 };
 
-static void error(struct csa *csa, const char *fmt, ...)
-{     /* print error message and terminate processing */
-      va_list arg;
-      xprintf("%s:%d: ", csa->fname, csa->recno);
-      va_start(arg, fmt);
-      xvprintf(fmt, arg);
-      va_end(arg);
-      longjmp(csa->jump, 1);
-      /* no return */
-}
-
-static void warning(struct csa *csa, const char *fmt, ...)
-{     /* print warning message and continue processing */
-      va_list arg;
-      xprintf("%s:%d: warning: ", csa->fname, csa->recno);
-      va_start(arg, fmt);
-      xvprintf(fmt, arg);
-      va_end(arg);
-      return;
+static int rcv_sat_fixed_col(NPP *, void *);
+
+int npp_sat_fixed_col(NPP *npp, NPPCOL *q)
+{     struct sat_fixed_col *info;
+      NPPROW *i;
+      NPPAIJ *aij;
+      int temp;
+      /* the column should be fixed */
+      xassert(q->lb == q->ub);
+      /* create transformation stack entry */
+      info = npp_push_tse(npp,
+         rcv_sat_fixed_col, sizeof(struct sat_fixed_col));
+      info->q = q->j;
+      info->s = (int)q->lb;
+      xassert((double)info->s == q->lb);
+      /* substitute x[q] = s[q] into constraint rows */
+      if (info->s == 0)
+         goto skip;
+      for (aij = q->ptr; aij != NULL; aij = aij->c_next)
+      {  i = aij->row;
+         if (i->lb != -DBL_MAX)
+         {  i->lb -= aij->val * (double)info->s;
+            temp = (int)i->lb;
+            if ((double)temp != i->lb)
+               return 1; /* integer arithmetic error */
+         }
+         if (i->ub != +DBL_MAX)
+         {  i->ub -= aij->val * (double)info->s;
+            temp = (int)i->ub;
+            if ((double)temp != i->ub)
+               return 2; /* integer arithmetic error */
+         }
+      }
+skip: /* remove the column from the problem */
+      npp_del_col(npp, q);
+      return 0;
+}
+
+static int rcv_sat_fixed_col(NPP *npp, void *info_)
+{     struct sat_fixed_col *info = info_;
+      npp->c_value[info->q] = (double)info->s;
+      return 0;
 }
 
-static void read_char(struct csa *csa)
-{     /* read next character */
-      int c;
-      if (csa->c == '\n')
-         csa->recno++, csa->recpos = 0;
-      csa->recpos++;
-read: c = xfgetc(csa->fp);
-      if (c < 0)
-      {  if (xferror(csa->fp))
-            error(csa, "read error - %s\n", xerrmsg());
-         else if (csa->c == '\n')
-            error(csa, "unexpected end of file\n");
-         else
-         {  warning(csa, "missing final end of line\n");
-            c = '\n';
-         }
+/***********************************************************************
+*  npp_sat_is_bin_comb - test if row is binary combination
+*
+*  This routine tests if the specified row is a binary combination,
+*  i.e. all its constraint coefficients are +1 and -1 and all variables
+*  are binary. If the test was passed, the routine returns non-zero,
+*  otherwise zero. */
+
+int npp_sat_is_bin_comb(NPP *npp, NPPROW *row)
+{     NPPCOL *col;
+      NPPAIJ *aij;
+      xassert(npp == npp);
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+      {  if (!(aij->val == +1.0 || aij->val == -1.0))
+            return 0; /* non-unity coefficient */
+         col = aij->col;
+         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))
+            return 0; /* non-binary column */
       }
-      else if (c == '\n')
-         ;
-      else if (csa->c == '\r')
-      {  c = '\r';
-         goto badc;
-      }
-      else if (csa->deck && c == '\r')
-      {  csa->c = '\r';
-         goto read;
-      }
-      else if (c == ' ')
-         ;
-      else if (isspace(c))
-      {  if (csa->deck)
-badc:       error(csa, "in fixed MPS format white-space character 0x%02"
-               "X is not allowed\n", c);
-         c = ' ';
-      }
-      else if (iscntrl(c))
-         error(csa, "invalid control character 0x%02X\n", c);
-      if (csa->deck && csa->recpos == 81 && c != '\n' && csa->w80 < 1)
-      {  warning(csa, "in fixed MPS format record must not be longer th"
-            "an 80 characters\n");
-         csa->w80++;
+      return 1; /* test was passed */
+}
+
+/***********************************************************************
+*  npp_sat_num_pos_coef - determine number of positive coefficients
+*
+*  This routine returns the number of positive coefficients in the
+*  specified row. */
+
+int npp_sat_num_pos_coef(NPP *npp, NPPROW *row)
+{     NPPAIJ *aij;
+      int num = 0;
+      xassert(npp == npp);
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+      {  if (aij->val > 0.0)
+            num++;
       }
-      csa->c = c;
-      return;
+      return num;
 }
 
-static int indicator(struct csa *csa, int name)
-{     /* skip comment records and read possible indicator record */
-      int ret;
-      /* reset current field number */
-      csa->fldno = 0;
-loop: /* read the very first character of the next record */
-      xassert(csa->c == '\n');
-      read_char(csa);
-      if (csa->c == ' ' || csa->c == '\n')
-      {  /* data record */
-         ret = 0;
-      }
-      else if (csa->c == '*')
-      {  /* comment record */
-         while (csa->c != '\n')
-            read_char(csa);
-         goto loop;
+/***********************************************************************
+*  npp_sat_num_neg_coef - determine number of negative coefficients
+*
+*  This routine returns the number of negative coefficients in the
+*  specified row. */
+
+int npp_sat_num_neg_coef(NPP *npp, NPPROW *row)
+{     NPPAIJ *aij;
+      int num = 0;
+      xassert(npp == npp);
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+      {  if (aij->val < 0.0)
+            num++;
       }
-      else
-      {  /* indicator record */
-         int len = 0;
-         while (csa->c != ' ' && csa->c != '\n' && len < 12)
-         {  csa->field[len++] = (char)csa->c;
-            read_char(csa);
-         }
-         csa->field[len] = '\0';
-         if (!(strcmp(csa->field, "NAME")    == 0 ||
-               strcmp(csa->field, "ROWS")    == 0 ||
-               strcmp(csa->field, "COLUMNS") == 0 ||
-               strcmp(csa->field, "RHS")     == 0 ||
-               strcmp(csa->field, "RANGES")  == 0 ||
-               strcmp(csa->field, "BOUNDS")  == 0 ||
-               strcmp(csa->field, "ENDATA")  == 0))
-            error(csa, "invalid indicator record\n");
-         if (!name)
-         {  while (csa->c != '\n')
-               read_char(csa);
+      return num;
+}
+
+/***********************************************************************
+*  npp_sat_is_cover_ineq - test if row is covering inequality
+*
+*  The canonical form of a covering inequality is the following:
+*
+*     sum x[j] >= 1,                                                 (1)
+*   j in J
+*
+*  where all x[j] are binary variables.
+*
+*  In general case a covering inequality may have one of the following
+*  two forms:
+*
+*     sum  x[j] -  sum  x[j] >= 1 - |J-|,                            (2)
+*   j in J+      j in J-
+*
+*
+*     sum  x[j] -  sum  x[j] <= |J+| - 1.                            (3)
+*   j in J+      j in J-
+*
+*  Obviously, the inequality (2) can be transformed to the form (1) by
+*  substitution x[j] = 1 - x'[j] for all j in J-, where x'[j] is the
+*  negation of variable x[j]. And the inequality (3) can be transformed
+*  to (2) by multiplying both left- and right-hand sides by -1.
+*
+*  This routine returns one of the following codes:
+*
+*  0, if the specified row is not a covering inequality;
+*
+*  1, if the specified row has the form (2);
+*
+*  2, if the specified row has the form (3). */
+
+int npp_sat_is_cover_ineq(NPP *npp, NPPROW *row)
+{     xassert(npp == npp);
+      if (row->lb != -DBL_MAX && row->ub == +DBL_MAX)
+      {  /* row is inequality of '>=' type */
+         if (npp_sat_is_bin_comb(npp, row))
+         {  /* row is a binary combination */
+            if (row->lb == 1.0 - npp_sat_num_neg_coef(npp, row))
+            {  /* row has the form (2) */
+               return 1;
+            }
          }
-         ret = 1;
       }
-      return ret;
+      else if (row->lb == -DBL_MAX && row->ub != +DBL_MAX)
+      {  /* row is inequality of '<=' type */
+         if (npp_sat_is_bin_comb(npp, row))
+         {  /* row is a binary combination */
+            if (row->ub == npp_sat_num_pos_coef(npp, row) - 1.0)
+            {  /* row has the form (3) */
+               return 2;
+            }
+         }
+      }
+      /* row is not a covering inequality */
+      return 0;
 }
 
-static void read_field(struct csa *csa)
-{     /* read next field of the current data record */
-      csa->fldno++;
-      if (csa->deck)
-      {  /* fixed MPS format */
-         int beg, end, pos;
-         /* determine predefined field positions */
-         if (csa->fldno == 1)
-            beg = 2, end = 3;
-         else if (csa->fldno == 2)
-            beg = 5, end = 12;
-         else if (csa->fldno == 3)
-            beg = 15, end = 22;
-         else if (csa->fldno == 4)
-            beg = 25, end = 36;
-         else if (csa->fldno == 5)
-            beg = 40, end = 47;
-         else if (csa->fldno == 6)
-            beg = 50, end = 61;
-         else
-            xassert(csa != csa);
-         /* skip blanks preceding the current field */
-         if (csa->c != '\n')
-         {  pos = csa->recpos;
-            while (csa->recpos < beg)
-            {  if (csa->c == ' ')
-                  ;
-               else if (csa->c == '\n')
-                  break;
-               else
-                  error(csa, "in fixed MPS format positions %d-%d must "
-                     "be blank\n", pos, beg-1);
-               read_char(csa);
-            }
-         }
-         /* skip possible comment beginning in the field 3 or 5 */
-         if ((csa->fldno == 3 || csa->fldno == 5) && csa->c == '$')
-         {  while (csa->c != '\n')
-               read_char(csa);
-         }
-         /* read the current field */
-         for (pos = beg; pos <= end; pos++)
-         {  if (csa->c == '\n') break;
-            csa->field[pos-beg] = (char)csa->c;
-            read_char(csa);
-         }
-         csa->field[pos-beg] = '\0';
-         strtrim(csa->field);
-         /* skip blanks following the last field */
-         if (csa->fldno == 6 && csa->c != '\n')
-         {  while (csa->recpos <= 72)
-            {  if (csa->c == ' ')
-                  ;
-               else if (csa->c == '\n')
-                  break;
-               else
-                  error(csa, "in fixed MPS format positions 62-72 must "
-                     "be blank\n");
-               read_char(csa);
+/***********************************************************************
+*  npp_sat_is_pack_ineq - test if row is packing inequality
+*
+*  The canonical form of a packing inequality is the following:
+*
+*     sum x[j] <= 1,                                                 (1)
+*   j in J
+*
+*  where all x[j] are binary variables.
+*
+*  In general case a packing inequality may have one of the following
+*  two forms:
+*
+*     sum  x[j] -  sum  x[j] <= 1 - |J-|,                            (2)
+*   j in J+      j in J-
+*
+*
+*     sum  x[j] -  sum  x[j] >= |J+| - 1.                            (3)
+*   j in J+      j in J-
+*
+*  Obviously, the inequality (2) can be transformed to the form (1) by
+*  substitution x[j] = 1 - x'[j] for all j in J-, where x'[j] is the
+*  negation of variable x[j]. And the inequality (3) can be transformed
+*  to (2) by multiplying both left- and right-hand sides by -1.
+*
+*  This routine returns one of the following codes:
+*
+*  0, if the specified row is not a packing inequality;
+*
+*  1, if the specified row has the form (2);
+*
+*  2, if the specified row has the form (3). */
+
+int npp_sat_is_pack_ineq(NPP *npp, NPPROW *row)
+{     xassert(npp == npp);
+      if (row->lb == -DBL_MAX && row->ub != +DBL_MAX)
+      {  /* row is inequality of '<=' type */
+         if (npp_sat_is_bin_comb(npp, row))
+         {  /* row is a binary combination */
+            if (row->ub == 1.0 - npp_sat_num_neg_coef(npp, row))
+            {  /* row has the form (2) */
+               return 1;
             }
-            while (csa->c != '\n')
-               read_char(csa);
          }
       }
-      else
-      {  /* free MPS format */
-         int len;
-         /* skip blanks preceding the current field */
-         while (csa->c == ' ')
-            read_char(csa);
-         /* skip possible comment */
-         if (csa->c == '$')
-         {  while (csa->c != '\n')
-               read_char(csa);
-         }
-         /* read the current field */
-         len = 0;
-         while (!(csa->c == ' ' || csa->c == '\n'))
-         {  if (len == 255)
-               error(csa, "length of field %d exceeds 255 characters\n",
-                  csa->fldno++);
-            csa->field[len++] = (char)csa->c;
-            read_char(csa);
-         }
-         csa->field[len] = '\0';
-         /* skip anything following the last field (any extra fields
-            are considered to be comments) */
-         if (csa->fldno == 6)
-         {  while (csa->c == ' ')
-               read_char(csa);
-            if (csa->c != '$' && csa->c != '\n' && csa->wef < 1)
-            {  warning(csa, "some extra field(s) detected beyond field "
-                  "6; field(s) ignored\n");
-               csa->wef++;
+      else if (row->lb != -DBL_MAX && row->ub == +DBL_MAX)
+      {  /* row is inequality of '>=' type */
+         if (npp_sat_is_bin_comb(npp, row))
+         {  /* row is a binary combination */
+            if (row->lb == npp_sat_num_pos_coef(npp, row) - 1.0)
+            {  /* row has the form (3) */
+               return 2;
             }
-            while (csa->c != '\n')
-               read_char(csa);
          }
       }
-      return;
+      /* row is not a packing inequality */
+      return 0;
 }
 
-static void patch_name(struct csa *csa, char *name)
-{     /* process embedded blanks in symbolic name */
-      int blank = csa->parm->blank;
-      if (blank == '\0')
-      {  /* remove emedded blanks */
-         strspx(name);
-      }
-      else
-      {  /* replace embedded blanks by specified character */
-         for (; *name != '\0'; name++)
-            if (*name == ' ') *name = (char)blank;
+/***********************************************************************
+*  npp_sat_is_partn_eq - test if row is partitioning equality
+*
+*  The canonical form of a partitioning equality is the following:
+*
+*     sum x[j] = 1,                                                  (1)
+*   j in J
+*
+*  where all x[j] are binary variables.
+*
+*  In general case a partitioning equality may have one of the following
+*  two forms:
+*
+*     sum  x[j] -  sum  x[j] = 1 - |J-|,                             (2)
+*   j in J+      j in J-
+*
+*
+*     sum  x[j] -  sum  x[j] = |J+| - 1.                             (3)
+*   j in J+      j in J-
+*
+*  Obviously, the equality (2) can be transformed to the form (1) by
+*  substitution x[j] = 1 - x'[j] for all j in J-, where x'[j] is the
+*  negation of variable x[j]. And the equality (3) can be transformed
+*  to (2) by multiplying both left- and right-hand sides by -1.
+*
+*  This routine returns one of the following codes:
+*
+*  0, if the specified row is not a partitioning equality;
+*
+*  1, if the specified row has the form (2);
+*
+*  2, if the specified row has the form (3). */
+
+int npp_sat_is_partn_eq(NPP *npp, NPPROW *row)
+{     xassert(npp == npp);
+      if (row->lb == row->ub)
+      {  /* row is equality constraint */
+         if (npp_sat_is_bin_comb(npp, row))
+         {  /* row is a binary combination */
+            if (row->lb == 1.0 - npp_sat_num_neg_coef(npp, row))
+            {  /* row has the form (2) */
+               return 1;
+            }
+            if (row->ub == npp_sat_num_pos_coef(npp, row) - 1.0)
+            {  /* row has the form (3) */
+               return 2;
+            }
+         }
       }
-      return;
+      /* row is not a partitioning equality */
+      return 0;
 }
 
-static double read_number(struct csa *csa)
-{     /* read next field and convert it to floating-point number */
-      double x;
-      char *s;
-      /* read next field */
-      read_field(csa);
-      xassert(csa->fldno == 4 || csa->fldno == 6);
-      if (csa->field[0] == '\0')
-         error(csa, "missing numeric value in field %d\n", csa->fldno);
-      /* skip initial spaces of the field */
-      for (s = csa->field; *s == ' '; s++);
-      /* perform conversion */
-      if (str2num(s, &x) != 0)
-         error(csa, "cannot convert `%s' to floating-point number\n",
-            s);
-      return x;
-}
-
-static void skip_field(struct csa *csa)
-{     /* read and skip next field (assumed to be blank) */
-      read_field(csa);
-      if (csa->field[0] != '\0')
-         error(csa, "field %d must be blank\n", csa->fldno);
-      return;
+/***********************************************************************
+*  npp_sat_reverse_row - multiply both sides of row by -1
+*
+*  This routines multiplies by -1 both left- and right-hand sides of
+*  the specified row:
+*
+*     L <= sum x[j] <= U,
+*
+*  that results in the following row:
+*
+*     -U <= sum (-x[j]) <= -L.
+*
+*  If no integer overflow occured, the routine returns zero, otherwise
+*  non-zero. */
+
+int npp_sat_reverse_row(NPP *npp, NPPROW *row)
+{     NPPAIJ *aij;
+      int temp, ret = 0;
+      double old_lb, old_ub;
+      xassert(npp == npp);
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+      {  aij->val = -aij->val;
+         temp = (int)aij->val;
+         if ((double)temp != aij->val)
+            ret = 1;
+      }
+      old_lb = row->lb, old_ub = row->ub;
+      if (old_ub == +DBL_MAX)
+         row->lb = -DBL_MAX;
+      else
+      {  row->lb = -old_ub;
+         temp = (int)row->lb;
+         if ((double)temp != row->lb)
+            ret = 2;
+      }
+      if (old_lb == -DBL_MAX)
+         row->ub = +DBL_MAX;
+      else
+      {  row->ub = -old_lb;
+         temp = (int)row->ub;
+         if ((double)temp != row->ub)
+            ret = 3;
+      }
+      return ret;
 }
 
-static void read_name(struct csa *csa)
-{     /* read NAME indicator record */
-      if (!(indicator(csa, 1) && strcmp(csa->field, "NAME") == 0))
-         error(csa, "missing NAME indicator record\n");
-      /* this indicator record looks like a data record; simulate that
-         fields 1 and 2 were read */
-      csa->fldno = 2;
-      /* field 3: model name */
-      read_field(csa), patch_name(csa, csa->field);
-      if (csa->field[0] == '\0')
-         warning(csa, "missing model name in field 3\n");
-      else
-         glp_set_prob_name(csa->P, csa->field);
-      /* skip anything following field 3 */
-      while (csa->c != '\n')
-         read_char(csa);
-      return;
+/***********************************************************************
+*  npp_sat_split_pack - split packing inequality
+*
+*  Let there be given a packing inequality in canonical form:
+*
+*     sum  t[j] <= 1,                                                (1)
+*   j in J
+*
+*  where t[j] = x[j] or t[j] = 1 - x[j], x[j] is a binary variable.
+*  And let J = J1 U J2 is a partition of the set of literals. Then the
+*  inequality (1) is obviously equivalent to the following two packing
+*  inequalities:
+*
+*     sum  t[j] <= y       <-->   sum  t[j] + (1 - y) <= 1,          (2)
+*   j in J1                     j in J1
+*
+*     sum  t[j] <= 1 - y   <-->   sum  t[j] + y       <= 1,          (3)
+*   j in J2                     j in J2
+*
+*  where y is a new binary variable added to the transformed problem.
+*
+*  Assuming that the specified row is a packing inequality (1), this
+*  routine constructs the set J1 by including there first nlit literals
+*  (terms) from the specified row, and the set J2 = J \ J1. Then the
+*  routine creates a new row, which corresponds to inequality (2), and
+*  replaces the specified row with inequality (3). */
+
+NPPROW *npp_sat_split_pack(NPP *npp, NPPROW *row, int nlit)
+{     NPPROW *rrr;
+      NPPCOL *col;
+      NPPAIJ *aij;
+      int k;
+      /* original row should be packing inequality (1) */
+      xassert(npp_sat_is_pack_ineq(npp, row) == 1);
+      /* and nlit should be less than the number of literals (terms)
+         in the original row */
+      xassert(0 < nlit && nlit < npp_row_nnz(npp, row));
+      /* create new row corresponding to inequality (2) */
+      rrr = npp_add_row(npp);
+      rrr->lb = -DBL_MAX, rrr->ub = 1.0;
+      /* move first nlit literals (terms) from the original row to the
+         new row; the original row becomes inequality (3) */
+      for (k = 1; k <= nlit; k++)
+      {  aij = row->ptr;
+         xassert(aij != NULL);
+         /* add literal to the new row */
+         npp_add_aij(npp, rrr, aij->col, aij->val);
+         /* correct rhs */
+         if (aij->val < 0.0)
+            rrr->ub -= 1.0, row->ub += 1.0;
+         /* remove literal from the original row */
+         npp_del_aij(npp, aij);
+      }
+      /* create new binary variable y */
+      col = npp_add_col(npp);
+      col->is_int = 1, col->lb = 0.0, col->ub = 1.0;
+      /* include literal (1 - y) in the new row */
+      npp_add_aij(npp, rrr, col, -1.0);
+      rrr->ub -= 1.0;
+      /* include literal y in the original row */
+      npp_add_aij(npp, row, col, +1.0);
+      return rrr;
 }
 
-static void read_rows(struct csa *csa)
-{     /* read ROWS section */
-      int i, type;
-loop: if (indicator(csa, 0)) goto done;
-      /* field 1: row type */
-      read_field(csa), strspx(csa->field);
-      if (strcmp(csa->field, "N") == 0)
-         type = GLP_FR;
-      else if (strcmp(csa->field, "G") == 0)
-         type = GLP_LO;
-      else if (strcmp(csa->field, "L") == 0)
-         type = GLP_UP;
-      else if (strcmp(csa->field, "E") == 0)
-         type = GLP_FX;
-      else if (csa->field[0] == '\0')
-         error(csa, "missing row type in field 1\n");
-      else
-         error(csa, "invalid row type in field 1\n");
-      /* field 2: row name */
-      read_field(csa), patch_name(csa, csa->field);
-      if (csa->field[0] == '\0')
-         error(csa, "missing row name in field 2\n");
-      if (glp_find_row(csa->P, csa->field) != 0)
-         error(csa, "row `%s' multiply specified\n", csa->field);
-      i = glp_add_rows(csa->P, 1);
-      glp_set_row_name(csa->P, i, csa->field);
-      glp_set_row_bnds(csa->P, i, type, 0.0, 0.0);
-      /* fields 3, 4, 5, and 6 must be blank */
-      skip_field(csa);
-      skip_field(csa);
-      skip_field(csa);
-      skip_field(csa);
-      goto loop;
-done: return;
-}
-
-static void read_columns(struct csa *csa)
-{     /* read COLUMNS section */
-      int i, j, f, len, kind = GLP_CV, *ind;
-      double aij, *val;
-      char name[255+1], *flag;
-      /* allocate working arrays */
-      csa->work1 = ind = xcalloc(1+csa->P->m, sizeof(int));
-      csa->work2 = val = xcalloc(1+csa->P->m, sizeof(double));
-      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));
-      memset(&flag[1], 0, csa->P->m);
-      /* no current column exists */
-      j = 0, len = 0;
-loop: if (indicator(csa, 0)) goto done;
-      /* field 1 must be blank */
-      if (csa->deck)
-      {  read_field(csa);
-         if (csa->field[0] != '\0')
-            error(csa, "field 1 must be blank\n");
-      }
-      else
-         csa->fldno++;
-      /* field 2: column or kind name */
-      read_field(csa), patch_name(csa, csa->field);
-      strcpy(name, csa->field);
-      /* field 3: row name or keyword 'MARKER' */
-      read_field(csa), patch_name(csa, csa->field);
-      if (strcmp(csa->field, "'MARKER'") == 0)
-      {  /* process kind data record */
-         /* field 4 must be blank */
-         if (csa->deck)
-         {  read_field(csa);
-            if (csa->field[0] != '\0')
-               error(csa, "field 4 must be blank\n");
+/***********************************************************************
+*  npp_sat_encode_pack - encode packing inequality
+*
+*  Given a packing inequality in canonical form:
+*
+*     sum  t[j] <= 1,                                                (1)
+*   j in J
+*
+*  where t[j] = x[j] or t[j] = 1 - x[j], x[j] is a binary variable,
+*  this routine translates it to CNF by replacing it with the following
+*  equivalent set of edge packing inequalities:
+*
+*     t[j] + t[k] <= 1   for all j, k in J, j != k.                  (2)
+*
+*  Then the routine transforms each edge packing inequality (2) to
+*  corresponding covering inequality (that encodes two-literal clause)
+*  by multiplying both its part by -1:
+*
+*     - t[j] - t[k] >= -1   <-->   (1 - t[j]) + (1 - t[k]) >= 1.     (3)
+*
+*  On exit the routine removes the original row from the problem. */
+
+void npp_sat_encode_pack(NPP *npp, NPPROW *row)
+{     NPPROW *rrr;
+      NPPAIJ *aij, *aik;
+      /* original row should be packing inequality (1) */
+      xassert(npp_sat_is_pack_ineq(npp, row) == 1);
+      /* create equivalent system of covering inequalities (3) */
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+      {  /* due to symmetry only one of inequalities t[j] + t[k] <= 1
+            and t[k] <= t[j] <= 1 can be considered */
+         for (aik = aij->r_next; aik != NULL; aik = aik->r_next)
+         {  /* create edge packing inequality (2) */
+            rrr = npp_add_row(npp);
+            rrr->lb = -DBL_MAX, rrr->ub = 1.0;
+            npp_add_aij(npp, rrr, aij->col, aij->val);
+            if (aij->val < 0.0)
+               rrr->ub -= 1.0;
+            npp_add_aij(npp, rrr, aik->col, aik->val);
+            if (aik->val < 0.0)
+               rrr->ub -= 1.0;
+            /* and transform it to covering inequality (3) */
+            npp_sat_reverse_row(npp, rrr);
+            xassert(npp_sat_is_cover_ineq(npp, rrr) == 1);
          }
-         else
-            csa->fldno++;
-         /* field 5: keyword 'INTORG' or 'INTEND' */
-         read_field(csa), patch_name(csa, csa->field);
-         if (strcmp(csa->field, "'INTORG'") == 0)
-            kind = GLP_IV;
-         else if (strcmp(csa->field, "'INTEND'") == 0)
-            kind = GLP_CV;
-         else if (csa->field[0] == '\0')
-            error(csa, "missing keyword in field 5\n");
-         else
-            error(csa, "invalid keyword in field 5\n");
-         /* field 6 must be blank */
-         skip_field(csa);
-         goto loop;
-      }
-      /* process column name specified in field 2 */
-      if (name[0] == '\0')
-      {  /* the same column as in previous data record */
-         if (j == 0)
-            error(csa, "missing column name in field 2\n");
-      }
-      else if (j != 0 && strcmp(name, csa->P->col[j]->name) == 0)
-      {  /* the same column as in previous data record */
-         xassert(j != 0);
       }
-      else
-      {  /* store the current column */
-         if (j != 0)
-         {  glp_set_mat_col(csa->P, j, len, ind, val);
-            while (len > 0) flag[ind[len--]] = 0;
-         }
-         /* create new column */
-         if (glp_find_col(csa->P, name) != 0)
-            error(csa, "column `%s' multiply specified\n", name);
-         j = glp_add_cols(csa->P, 1);
-         glp_set_col_name(csa->P, j, name);
-         glp_set_col_kind(csa->P, j, kind);
-         if (kind == GLP_CV)
-            glp_set_col_bnds(csa->P, j, GLP_LO, 0.0, 0.0);
-         else if (kind == GLP_IV)
-            glp_set_col_bnds(csa->P, j, GLP_DB, 0.0, 1.0);
-         else
-            xassert(kind != kind);
-      }
-      /* process fields 3-4 and 5-6 */
-      for (f = 3; f <= 5; f += 2)
-      {  /* field 3 or 5: row name */
-         if (f == 3)
-         {  if (csa->field[0] == '\0')
-               error(csa, "missing row name in field 3\n");
-         }
-         else
-         {  read_field(csa), patch_name(csa, csa->field);
-            if (csa->field[0] == '\0')
-            {  /* if field 5 is blank, field 6 also must be blank */
-               skip_field(csa);
-               continue;
-            }
-         }
-         i = glp_find_row(csa->P, csa->field);
-         if (i == 0)
-            error(csa, "row `%s' not found\n", csa->field);
-         if (flag[i])
-            error(csa, "duplicate coefficient in row `%s'\n",
-               csa->field);
-         /* field 4 or 6: coefficient value */
-         aij = read_number(csa);
-         if (fabs(aij) < csa->parm->tol_mps) aij = 0.0;
-         len++, ind[len] = i, val[len] = aij, flag[i] = 1;
-      }
-      goto loop;
-done: /* store the last column */
-      if (j != 0)
-         glp_set_mat_col(csa->P, j, len, ind, val);
-      /* free working arrays */
-      xfree(ind);
-      xfree(val);
-      xfree(flag);
-      csa->work1 = csa->work2 = csa->work3 = NULL;
+      /* remove the original row from the problem */
+      npp_del_row(npp, row);
       return;
 }
 
-static void read_rhs(struct csa *csa)
-{     /* read RHS section */
-      int i, f, v, type;
-      double rhs;
-      char name[255+1], *flag;
-      /* allocate working array */
-      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));
-      memset(&flag[1], 0, csa->P->m);
-      /* no current RHS vector exists */
-      v = 0;
-loop: if (indicator(csa, 0)) goto done;
-      /* field 1 must be blank */
-      if (csa->deck)
-      {  read_field(csa);
-         if (csa->field[0] != '\0')
-            error(csa, "field 1 must be blank\n");
-      }
-      else
-         csa->fldno++;
-      /* field 2: RHS vector name */
-      read_field(csa), patch_name(csa, csa->field);
-      if (csa->field[0] == '\0')
-      {  /* the same RHS vector as in previous data record */
-         if (v == 0)
-         {  warning(csa, "missing RHS vector name in field 2\n");
-            goto blnk;
+/***********************************************************************
+*  npp_sat_encode_sum2 - encode 2-bit summation
+*
+*  Given a set containing two literals x and y this routine encodes
+*  the equality
+*
+*     x + y = s + 2 * c,                                             (1)
+*
+*  where
+*
+*     s = (x + y) % 2                                                (2)
+*
+*  is a binary variable modeling the low sum bit, and
+*
+*     c = (x + y) / 2                                                (3)
+*
+*  is a binary variable modeling the high (carry) sum bit. */
+
+void npp_sat_encode_sum2(NPP *npp, NPPLSE *set, NPPSED *sed)
+{     NPPROW *row;
+      int x, y, s, c;
+      /* the set should contain exactly two literals */
+      xassert(set != NULL);
+      xassert(set->next != NULL);
+      xassert(set->next->next == NULL);
+      sed->x = set->lit;
+      xassert(sed->x.neg == 0 || sed->x.neg == 1);
+      sed->y = set->next->lit;
+      xassert(sed->y.neg == 0 || sed->y.neg == 1);
+      sed->z.col = NULL, sed->z.neg = 0;
+      /* perform encoding s = (x + y) % 2 */
+      sed->s = npp_add_col(npp);
+      sed->s->is_int = 1, sed->s->lb = 0.0, sed->s->ub = 1.0;
+      for (x = 0; x <= 1; x++)
+      {  for (y = 0; y <= 1; y++)
+         {  for (s = 0; s <= 1; s++)
+            {  if ((x + y) % 2 != s)
+               {  /* generate CNF clause to disable infeasible
+                     combination */
+                  row = npp_add_row(npp);
+                  row->lb = 1.0, row->ub = +DBL_MAX;
+                  if (x == sed->x.neg)
+                     npp_add_aij(npp, row, sed->x.col, +1.0);
+                  else
+                  {  npp_add_aij(npp, row, sed->x.col, -1.0);
+                     row->lb -= 1.0;
+                  }
+                  if (y == sed->y.neg)
+                     npp_add_aij(npp, row, sed->y.col, +1.0);
+                  else
+                  {  npp_add_aij(npp, row, sed->y.col, -1.0);
+                     row->lb -= 1.0;
+                  }
+                  if (s == 0)
+                     npp_add_aij(npp, row, sed->s, +1.0);
+                  else
+                  {  npp_add_aij(npp, row, sed->s, -1.0);
+                     row->lb -= 1.0;
+                  }
+               }
+            }
          }
       }
-      else if (v != 0 && strcmp(csa->field, name) == 0)
-      {  /* the same RHS vector as in previous data record */
-         xassert(v != 0);
-      }
-      else
-blnk: {  /* new RHS vector */
-         if (v != 0)
-            error(csa, "multiple RHS vectors not supported\n");
-         v++;
-         strcpy(name, csa->field);
-      }
-      /* process fields 3-4 and 5-6 */
-      for (f = 3; f <= 5; f += 2)
-      {  /* field 3 or 5: row name */
-         read_field(csa), patch_name(csa, csa->field);
-         if (csa->field[0] == '\0')
-         {  if (f == 3)
-               error(csa, "missing row name in field 3\n");
-            else
-            {  /* if field 5 is blank, field 6 also must be blank */
-               skip_field(csa);
-               continue;
-            }
-         }
-         i = glp_find_row(csa->P, csa->field);
-         if (i == 0)
-            error(csa, "row `%s' not found\n", csa->field);
-         if (flag[i])
-            error(csa, "duplicate right-hand side for row `%s'\n",
-               csa->field);
-         /* field 4 or 6: right-hand side value */
-         rhs = read_number(csa);
-         if (fabs(rhs) < csa->parm->tol_mps) rhs = 0.0;
-         type = csa->P->row[i]->type;
-         if (type == GLP_FR)
-         {  if (i == csa->obj_row)
-               glp_set_obj_coef(csa->P, 0, rhs);
-            else if (rhs != 0.0)
-               warning(csa, "non-zero right-hand side for free row `%s'"
-                  " ignored\n", csa->P->row[i]->name);
+      /* perform encoding c = (x + y) / 2 */
+      sed->c = npp_add_col(npp);
+      sed->c->is_int = 1, sed->c->lb = 0.0, sed->c->ub = 1.0;
+      for (x = 0; x <= 1; x++)
+      {  for (y = 0; y <= 1; y++)
+         {  for (c = 0; c <= 1; c++)
+            {  if ((x + y) / 2 != c)
+               {  /* generate CNF clause to disable infeasible
+                     combination */
+                  row = npp_add_row(npp);
+                  row->lb = 1.0, row->ub = +DBL_MAX;
+                  if (x == sed->x.neg)
+                     npp_add_aij(npp, row, sed->x.col, +1.0);
+                  else
+                  {  npp_add_aij(npp, row, sed->x.col, -1.0);
+                     row->lb -= 1.0;
+                  }
+                  if (y == sed->y.neg)
+                     npp_add_aij(npp, row, sed->y.col, +1.0);
+                  else
+                  {  npp_add_aij(npp, row, sed->y.col, -1.0);
+                     row->lb -= 1.0;
+                  }
+                  if (c == 0)
+                     npp_add_aij(npp, row, sed->c, +1.0);
+                  else
+                  {  npp_add_aij(npp, row, sed->c, -1.0);
+                     row->lb -= 1.0;
+                  }
+               }
+            }
          }
-         else
-            glp_set_row_bnds(csa->P, i, type, rhs, rhs);
-         flag[i] = 1;
       }
-      goto loop;
-done: /* free working array */
-      xfree(flag);
-      csa->work3 = NULL;
       return;
 }
 
-static void read_ranges(struct csa *csa)
-{     /* read RANGES section */
-      int i, f, v, type;
-      double rhs, rng;
-      char name[255+1], *flag;
-      /* allocate working array */
-      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));
-      memset(&flag[1], 0, csa->P->m);
-      /* no current RANGES vector exists */
-      v = 0;
-loop: if (indicator(csa, 0)) goto done;
-      /* field 1 must be blank */
-      if (csa->deck)
-      {  read_field(csa);
-         if (csa->field[0] != '\0')
-            error(csa, "field 1 must be blank\n");
-      }
-      else
-         csa->fldno++;
-      /* field 2: RANGES vector name */
-      read_field(csa), patch_name(csa, csa->field);
-      if (csa->field[0] == '\0')
-      {  /* the same RANGES vector as in previous data record */
-         if (v == 0)
-         {  warning(csa, "missing RANGES vector name in field 2\n");
-            goto blnk;
+/***********************************************************************
+*  npp_sat_encode_sum3 - encode 3-bit summation
+*
+*  Given a set containing at least three literals this routine chooses
+*  some literals x, y, z from that set and encodes the equality
+*
+*     x + y + z = s + 2 * c,                                         (1)
+*
+*  where
+*
+*     s = (x + y + z) % 2                                            (2)
+*
+*  is a binary variable modeling the low sum bit, and
+*
+*     c = (x + y + z) / 2                                            (3)
+*
+*  is a binary variable modeling the high (carry) sum bit. */
+
+void npp_sat_encode_sum3(NPP *npp, NPPLSE *set, NPPSED *sed)
+{     NPPROW *row;
+      int x, y, z, s, c;
+      /* the set should contain at least three literals */
+      xassert(set != NULL);
+      xassert(set->next != NULL);
+      xassert(set->next->next != NULL);
+      sed->x = set->lit;
+      xassert(sed->x.neg == 0 || sed->x.neg == 1);
+      sed->y = set->next->lit;
+      xassert(sed->y.neg == 0 || sed->y.neg == 1);
+      sed->z = set->next->next->lit;
+      xassert(sed->z.neg == 0 || sed->z.neg == 1);
+      /* perform encoding s = (x + y + z) % 2 */
+      sed->s = npp_add_col(npp);
+      sed->s->is_int = 1, sed->s->lb = 0.0, sed->s->ub = 1.0;
+      for (x = 0; x <= 1; x++)
+      {  for (y = 0; y <= 1; y++)
+         {  for (z = 0; z <= 1; z++)
+            {  for (s = 0; s <= 1; s++)
+               {  if ((x + y + z) % 2 != s)
+                  {  /* generate CNF clause to disable infeasible
+                        combination */
+                     row = npp_add_row(npp);
+                     row->lb = 1.0, row->ub = +DBL_MAX;
+                     if (x == sed->x.neg)
+                        npp_add_aij(npp, row, sed->x.col, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->x.col, -1.0);
+                        row->lb -= 1.0;
+                     }
+                     if (y == sed->y.neg)
+                        npp_add_aij(npp, row, sed->y.col, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->y.col, -1.0);
+                        row->lb -= 1.0;
+                     }
+                     if (z == sed->z.neg)
+                        npp_add_aij(npp, row, sed->z.col, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->z.col, -1.0);
+                        row->lb -= 1.0;
+                     }
+                     if (s == 0)
+                        npp_add_aij(npp, row, sed->s, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->s, -1.0);
+                        row->lb -= 1.0;
+                     }
+                  }
+               }
+            }
          }
       }
-      else if (v != 0 && strcmp(csa->field, name) == 0)
-      {  /* the same RANGES vector as in previous data record */
-         xassert(v != 0);
-      }
-      else
-blnk: {  /* new RANGES vector */
-         if (v != 0)
-            error(csa, "multiple RANGES vectors not supported\n");
-         v++;
-         strcpy(name, csa->field);
-      }
-      /* process fields 3-4 and 5-6 */
-      for (f = 3; f <= 5; f += 2)
-      {  /* field 3 or 5: row name */
-         read_field(csa), patch_name(csa, csa->field);
-         if (csa->field[0] == '\0')
-         {  if (f == 3)
-               error(csa, "missing row name in field 3\n");
-            else
-            {  /* if field 5 is blank, field 6 also must be blank */
-               skip_field(csa);
-               continue;
-            }
-         }
-         i = glp_find_row(csa->P, csa->field);
-         if (i == 0)
-            error(csa, "row `%s' not found\n", csa->field);
-         if (flag[i])
-            error(csa, "duplicate range for row `%s'\n", csa->field);
-         /* field 4 or 6: range value */
-         rng = read_number(csa);
-         if (fabs(rng) < csa->parm->tol_mps) rng = 0.0;
-         type = csa->P->row[i]->type;
-         if (type == GLP_FR)
-            warning(csa, "range for free row `%s' ignored\n",
-               csa->P->row[i]->name);
-         else if (type == GLP_LO)
-         {  rhs = csa->P->row[i]->lb;
-            glp_set_row_bnds(csa->P, i, rhs == 0.0 ? GLP_FX : GLP_DB,
-               rhs, rhs + fabs(rng));
-         }
-         else if (type == GLP_UP)
-         {  rhs = csa->P->row[i]->ub;
-            glp_set_row_bnds(csa->P, i, rhs == 0.0 ? GLP_FX : GLP_DB,
-               rhs - fabs(rng), rhs);
-         }
-         else if (type == GLP_FX)
-         {  rhs = csa->P->row[i]->lb;
-            if (rng > 0.0)
-               glp_set_row_bnds(csa->P, i, GLP_DB, rhs, rhs + rng);
-            else if (rng < 0.0)
-               glp_set_row_bnds(csa->P, i, GLP_DB, rhs + rng, rhs);
+      /* perform encoding c = (x + y + z) / 2 */
+      sed->c = npp_add_col(npp);
+      sed->c->is_int = 1, sed->c->lb = 0.0, sed->c->ub = 1.0;
+      for (x = 0; x <= 1; x++)
+      {  for (y = 0; y <= 1; y++)
+         {  for (z = 0; z <= 1; z++)
+            {  for (c = 0; c <= 1; c++)
+               {  if ((x + y + z) / 2 != c)
+                  {  /* generate CNF clause to disable infeasible
+                        combination */
+                     row = npp_add_row(npp);
+                     row->lb = 1.0, row->ub = +DBL_MAX;
+                     if (x == sed->x.neg)
+                        npp_add_aij(npp, row, sed->x.col, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->x.col, -1.0);
+                        row->lb -= 1.0;
+                     }
+                     if (y == sed->y.neg)
+                        npp_add_aij(npp, row, sed->y.col, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->y.col, -1.0);
+                        row->lb -= 1.0;
+                     }
+                     if (z == sed->z.neg)
+                        npp_add_aij(npp, row, sed->z.col, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->z.col, -1.0);
+                        row->lb -= 1.0;
+                     }
+                     if (c == 0)
+                        npp_add_aij(npp, row, sed->c, +1.0);
+                     else
+                     {  npp_add_aij(npp, row, sed->c, -1.0);
+                        row->lb -= 1.0;
+                     }
+                  }
+               }
+            }
          }
-         else
-            xassert(type != type);
-         flag[i] = 1;
       }
-      goto loop;
-done: /* free working array */
-      xfree(flag);
-      csa->work3 = NULL;
       return;
 }
 
-static void read_bounds(struct csa *csa)
-{     /* read BOUNDS section */
-      GLPCOL *col;
-      int j, v, mask, data;
-      double bnd, lb, ub;
-      char type[2+1], name[255+1], *flag;
-      /* allocate working array */
-      csa->work3 = flag = xcalloc(1+csa->P->n, sizeof(char));
-      memset(&flag[1], 0, csa->P->n);
-      /* no current BOUNDS vector exists */
-      v = 0;
-loop: if (indicator(csa, 0)) goto done;
-      /* field 1: bound type */
-      read_field(csa);
-      if (strcmp(csa->field, "LO") == 0)
-         mask = 0x01, data = 1;
-      else if (strcmp(csa->field, "UP") == 0)
-         mask = 0x10, data = 1;
-      else if (strcmp(csa->field, "FX") == 0)
-         mask = 0x11, data = 1;
-      else if (strcmp(csa->field, "FR") == 0)
-         mask = 0x11, data = 0;
-      else if (strcmp(csa->field, "MI") == 0)
-         mask = 0x01, data = 0;
-      else if (strcmp(csa->field, "PL") == 0)
-         mask = 0x10, data = 0;
-      else if (strcmp(csa->field, "LI") == 0)
-         mask = 0x01, data = 1;
-      else if (strcmp(csa->field, "UI") == 0)
-         mask = 0x10, data = 1;
-      else if (strcmp(csa->field, "BV") == 0)
-         mask = 0x11, data = 0;
-      else if (csa->field[0] == '\0')
-         error(csa, "missing bound type in field 1\n");
-      else
-         error(csa, "invalid bound type in field 1\n");
-      strcpy(type, csa->field);
-      /* field 2: BOUNDS vector name */
-      read_field(csa), patch_name(csa, csa->field);
-      if (csa->field[0] == '\0')
-      {  /* the same BOUNDS vector as in previous data record */
-         if (v == 0)
-         {  warning(csa, "missing BOUNDS vector name in field 2\n");
-            goto blnk;
+/***********************************************************************
+*  npp_sat_encode_sum_ax - encode linear combination of 0-1 variables
+*
+*  PURPOSE
+*
+*  Given a linear combination of binary variables:
+*
+*     sum a[j] x[j],                                                 (1)
+*      j
+*
+*  which is the linear form of the specified row, this routine encodes
+*  (i.e. translates to CNF) the following equality:
+*
+*                        n
+*     sum |a[j]| t[j] = sum 2**(k-1) * y[k],                         (2)
+*      j                k=1
+*
+*  where t[j] = x[j] (if a[j] > 0) or t[j] = 1 - x[j] (if a[j] < 0),
+*  and y[k] is either t[j] or a new literal created by the routine or
+*  a constant zero. Note that the sum in the right-hand side of (2) can
+*  be thought as a n-bit representation of the sum in the left-hand
+*  side, which is a non-negative integer number.
+*
+*  ALGORITHM
+*
+*  First, the number of bits, n, sufficient to represent any value in
+*  the left-hand side of (2) is determined. Obviously, n is the number
+*  of bits sufficient to represent the sum (sum |a[j]|).
+*
+*  Let
+*
+*               n
+*     |a[j]| = sum 2**(k-1) b[j,k],                                  (3)
+*              k=1
+*
+*  where b[j,k] is k-th bit in a n-bit representation of |a[j]|. Then
+*
+*                          m            n
+*     sum |a[j]| * t[j] = sum 2**(k-1) sum b[j,k] * t[j].            (4)
+*      j                  k=1          j=1
+*
+*  Introducing the set
+*
+*     J[k] = { j : b[j,k] = 1 }                                      (5)
+*
+*  allows rewriting (4) as follows:
+*
+*                          n
+*     sum |a[j]| * t[j] = sum 2**(k-1)  sum    t[j].                 (6)
+*      j                  k=1         j in J[k]
+*
+*  Thus, our goal is to provide |J[k]| <= 1 for all k, in which case
+*  we will have the representation (1).
+*
+*  Let |J[k]| = 2, i.e. J[k] has exactly two literals u and v. In this
+*  case we can apply the following transformation:
+*
+*     u + v = s + 2 * c,                                             (7)
+*
+*  where s and c are, respectively, low (sum) and high (carry) bits of
+*  the sum of two bits. This allows to replace two literals u and v in
+*  J[k] by one literal s, and carry out literal c to J[k+1].
+*
+*  If |J[k]| >= 3, i.e. J[k] has at least three literals u, v, and w,
+*  we can apply the following transformation:
+*
+*     u + v + w = s + 2 * c.                                         (8)
+*
+*  Again, literal s replaces literals u, v, and w in J[k], and literal
+*  c goes into J[k+1].
+*
+*  On exit the routine stores each literal from J[k] in element y[k],
+*  1 <= k <= n. If J[k] is empty, y[k] is set to constant false.
+*
+*  RETURNS
+*
+*  The routine returns n, the number of literals in the right-hand side
+*  of (2), 0 <= n <= NBIT_MAX. If the sum (sum |a[j]|) is too large, so
+*  more than NBIT_MAX (= 31) literals are needed to encode the original
+*  linear combination, the routine returns a negative value. */
+
+#define NBIT_MAX 31
+/* maximal number of literals in the right hand-side of (2) */
+
+static NPPLSE *remove_lse(NPP *npp, NPPLSE *set, NPPCOL *col)
+{     /* remove specified literal from specified literal set */
+      NPPLSE *lse, *prev = NULL;
+      for (lse = set; lse != NULL; prev = lse, lse = lse->next)
+         if (lse->lit.col == col) break;
+      xassert(lse != NULL);
+      if (prev == NULL)
+         set = lse->next;
+      else
+         prev->next = lse->next;
+      dmp_free_atom(npp->pool, lse, sizeof(NPPLSE));
+      return set;
+}
+
+int npp_sat_encode_sum_ax(NPP *npp, NPPROW *row, NPPLIT y[])
+{     NPPAIJ *aij;
+      NPPLSE *set[1+NBIT_MAX], *lse;
+      NPPSED sed;
+      int k, n, temp;
+      double sum;
+      /* compute the sum (sum |a[j]|) */
+      sum = 0.0;
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+         sum += fabs(aij->val);
+      /* determine n, the number of bits in the sum */
+      temp = (int)sum;
+      if ((double)temp != sum)
+         return -1; /* integer arithmetic error */
+      for (n = 0; temp > 0; n++, temp >>= 1);
+      xassert(0 <= n && n <= NBIT_MAX);
+      /* build initial sets J[k], 1 <= k <= n; see (5) */
+      /* set[k] is a pointer to the list of literals in J[k] */
+      for (k = 1; k <= n; k++)
+         set[k] = NULL;
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+      {  temp = (int)fabs(aij->val);
+         xassert((int)temp == fabs(aij->val));
+         for (k = 1; temp > 0; k++, temp >>= 1)
+         {  if (temp & 1)
+            {  xassert(k <= n);
+               lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));
+               lse->lit.col = aij->col;
+               lse->lit.neg = (aij->val > 0.0 ? 0 : 1);
+               lse->next = set[k];
+               set[k] = lse;
+            }
          }
       }
-      else if (v != 0 && strcmp(csa->field, name) == 0)
-      {  /* the same BOUNDS vector as in previous data record */
-         xassert(v != 0);
-      }
-      else
-blnk: {  /* new BOUNDS vector */
-         if (v != 0)
-            error(csa, "multiple BOUNDS vectors not supported\n");
-         v++;
-         strcpy(name, csa->field);
-      }
-      /* field 3: column name */
-      read_field(csa), patch_name(csa, csa->field);
-      if (csa->field[0] == '\0')
-         error(csa, "missing column name in field 3\n");
-      j = glp_find_col(csa->P, csa->field);
-      if (j == 0)
-         error(csa, "column `%s' not found\n", csa->field);
-      if ((flag[j] & mask) == 0x01)
-         error(csa, "duplicate lower bound for column `%s'\n",
-            csa->field);
-      if ((flag[j] & mask) == 0x10)
-         error(csa, "duplicate upper bound for column `%s'\n",
-            csa->field);
-      xassert((flag[j] & mask) == 0x00);
-      /* field 4: bound value */
-      if (data)
-      {  bnd = read_number(csa);
-         if (fabs(bnd) < csa->parm->tol_mps) bnd = 0.0;
-      }
-      else
-         read_field(csa), bnd = 0.0;
-      /* get current column bounds */
-      col = csa->P->col[j];
-      if (col->type == GLP_FR)
-         lb = -DBL_MAX, ub = +DBL_MAX;
-      else if (col->type == GLP_LO)
-         lb = col->lb, ub = +DBL_MAX;
-      else if (col->type == GLP_UP)
-         lb = -DBL_MAX, ub = col->ub;
-      else if (col->type == GLP_DB)
-         lb = col->lb, ub = col->ub;
-      else if (col->type == GLP_FX)
-         lb = ub = col->lb;
-      else
-         xassert(col != col);
-      /* change column bounds */
-      if (strcmp(type, "LO") == 0)
-         lb = bnd;
-      else if (strcmp(type, "UP") == 0)
-         ub = bnd;
-      else if (strcmp(type, "FX") == 0)
-         lb = ub = bnd;
-      else if (strcmp(type, "FR") == 0)
-         lb = -DBL_MAX, ub = +DBL_MAX;
-      else if (strcmp(type, "MI") == 0)
-         lb = -DBL_MAX;
-      else if (strcmp(type, "PL") == 0)
-         ub = +DBL_MAX;
-      else if (strcmp(type, "LI") == 0)
-      {  glp_set_col_kind(csa->P, j, GLP_IV);
-         lb = ceil(bnd);
-      }
-      else if (strcmp(type, "UI") == 0)
-      {  glp_set_col_kind(csa->P, j, GLP_IV);
-         ub = floor(bnd);
-      }
-      else if (strcmp(type, "BV") == 0)
-      {  glp_set_col_kind(csa->P, j, GLP_IV);
-         lb = 0.0, ub = 1.0;
+      /* main transformation loop */
+      for (k = 1; k <= n; k++)
+      {  /* reduce J[k] and set y[k] */
+         for (;;)
+         {  if (set[k] == NULL)
+            {  /* J[k] is empty */
+               /* set y[k] to constant false */
+               y[k].col = NULL, y[k].neg = 0;
+               break;
+            }
+            if (set[k]->next == NULL)
+            {  /* J[k] contains one literal */
+               /* set y[k] to that literal */
+               y[k] = set[k]->lit;
+               dmp_free_atom(npp->pool, set[k], sizeof(NPPLSE));
+               break;
+            }
+            if (set[k]->next->next == NULL)
+            {  /* J[k] contains two literals */
+               /* apply transformation (7) */
+               npp_sat_encode_sum2(npp, set[k], &sed);
+            }
+            else
+            {  /* J[k] contains at least three literals */
+               /* apply transformation (8) */
+               npp_sat_encode_sum3(npp, set[k], &sed);
+               /* remove third literal from set[k] */
+               set[k] = remove_lse(npp, set[k], sed.z.col);
+            }
+            /* remove second literal from set[k] */
+            set[k] = remove_lse(npp, set[k], sed.y.col);
+            /* remove first literal from set[k] */
+            set[k] = remove_lse(npp, set[k], sed.x.col);
+            /* include new literal s to set[k] */
+            lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));
+            lse->lit.col = sed.s, lse->lit.neg = 0;
+            lse->next = set[k];
+            set[k] = lse;
+            /* include new literal c to set[k+1] */
+            xassert(k < n); /* FIXME: can "overflow" happen? */
+            lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));
+            lse->lit.col = sed.c, lse->lit.neg = 0;
+            lse->next = set[k+1];
+            set[k+1] = lse;
+         }
       }
-      else
-         xassert(type != type);
-      /* set new column bounds */
-      if (lb == -DBL_MAX && ub == +DBL_MAX)
-         glp_set_col_bnds(csa->P, j, GLP_FR, lb, ub);
-      else if (ub == +DBL_MAX)
-         glp_set_col_bnds(csa->P, j, GLP_LO, lb, ub);
-      else if (lb == -DBL_MAX)
-         glp_set_col_bnds(csa->P, j, GLP_UP, lb, ub);
-      else if (lb != ub)
-         glp_set_col_bnds(csa->P, j, GLP_DB, lb, ub);
-      else
-         glp_set_col_bnds(csa->P, j, GLP_FX, lb, ub);
-      flag[j] |= (char)mask;
-      /* fields 5 and 6 must be blank */
-      skip_field(csa);
-      skip_field(csa);
-      goto loop;
-done: /* free working array */
-      xfree(flag);
-      csa->work3 = NULL;
-      return;
+      return n;
 }
 
-int glp_read_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
-      const char *fname)
-{     /* read problem data in MPS format */
-      glp_mpscp _parm;
-      struct csa _csa, *csa = &_csa;
-      int ret;
-      xprintf("Reading problem data from `%s'...\n", fname);
-      if (!(fmt == GLP_MPS_DECK || fmt == GLP_MPS_FILE))
-         xerror("glp_read_mps: fmt = %d; invalid parameter\n", fmt);
-      if (parm == NULL)
-         glp_init_mpscp(&_parm), parm = &_parm;
-      /* check control parameters */
-      check_parm("glp_read_mps", parm);
-      /* initialize common storage area */
-      csa->P = P;
-      csa->deck = (fmt == GLP_MPS_DECK);
-      csa->parm = parm;
-      csa->fname = fname;
-      csa->fp = NULL;
-      if (setjmp(csa->jump))
-      {  ret = 1;
-         goto done;
-      }
-      csa->recno = csa->recpos = 0;
-      csa->c = '\n';
-      csa->fldno = 0;
-      csa->field[0] = '\0';
-      csa->w80 = csa->wef = 0;
-      csa->obj_row = 0;
-      csa->work1 = csa->work2 = csa->work3 = NULL;
-      /* erase problem object */
-      glp_erase_prob(P);
-      glp_create_index(P);
-      /* open input MPS file */
-      csa->fp = xfopen(fname, "r");
-      if (csa->fp == NULL)
-      {  xprintf("Unable to open `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      /* read NAME indicator record */
-      read_name(csa);
-      if (P->name != NULL)
-         xprintf("Problem: %s\n", P->name);
-      /* read ROWS section */
-      if (!(indicator(csa, 0) && strcmp(csa->field, "ROWS") == 0))
-         error(csa, "missing ROWS indicator record\n");
-      read_rows(csa);
-      /* determine objective row */
-      if (parm->obj_name == NULL || parm->obj_name[0] == '\0')
-      {  /* use the first row of N type */
-         int i;
-         for (i = 1; i <= P->m; i++)
-         {  if (P->row[i]->type == GLP_FR)
-            {  csa->obj_row = i;
-               break;
+/***********************************************************************
+*  npp_sat_normalize_clause - normalize clause
+*
+*  This routine normalizes the specified clause, which is a disjunction
+*  of literals, by replacing multiple literals, which refer to the same
+*  binary variable, with a single literal.
+*
+*  On exit the routine returns the number of literals in the resulting
+*  clause. However, if the specified clause includes both a literal and
+*  its negation, the routine returns a negative value meaning that the
+*  clause is equivalent to the value true. */
+
+int npp_sat_normalize_clause(NPP *npp, int size, NPPLIT lit[])
+{     int j, k, new_size;
+      xassert(npp == npp);
+      xassert(size >= 0);
+      new_size = 0;
+      for (k = 1; k <= size; k++)
+      {  for (j = 1; j <= new_size; j++)
+         {  if (lit[k].col == lit[j].col)
+            {  /* lit[k] refers to the same variable as lit[j], which
+                  is already included in the resulting clause */
+               if (lit[k].neg == lit[j].neg)
+               {  /* ignore lit[k] due to the idempotent law */
+                  goto skip;
+               }
+               else
+               {  /* lit[k] is NOT lit[j]; the clause is equivalent to
+                     the value true */
+                  return -1;
+               }
             }
          }
-         if (csa->obj_row == 0)
-            warning(csa, "unable to determine objective row\n");
+         /* include lit[k] in the resulting clause */
+         lit[++new_size] = lit[k];
+skip:    ;
       }
-      else
-      {  /* use a row with specified name */
-         int i;
-         for (i = 1; i <= P->m; i++)
-         {  xassert(P->row[i]->name != NULL);
-            if (strcmp(parm->obj_name, P->row[i]->name) == 0)
-            {  csa->obj_row = i;
-               break;
-            }
+      return new_size;
+}
+
+/***********************************************************************
+*  npp_sat_encode_clause - translate clause to cover inequality
+*
+*  Given a clause
+*
+*     OR  t[j],                                                      (1)
+*   j in J
+*
+*  where t[j] is a literal, i.e. t[j] = x[j] or t[j] = NOT x[j], this
+*  routine translates it to the following equivalent cover inequality,
+*  which is added to the transformed problem:
+*
+*     sum t[j] >= 1,                                                 (2)
+*   j in J
+*
+*  where t[j] = x[j] or t[j] = 1 - x[j].
+*
+*  If necessary, the clause should be normalized before a call to this
+*  routine. */
+
+NPPROW *npp_sat_encode_clause(NPP *npp, int size, NPPLIT lit[])
+{     NPPROW *row;
+      int k;
+      xassert(size >= 1);
+      row = npp_add_row(npp);
+      row->lb = 1.0, row->ub = +DBL_MAX;
+      for (k = 1; k <= size; k++)
+      {  xassert(lit[k].col != NULL);
+         if (lit[k].neg == 0)
+            npp_add_aij(npp, row, lit[k].col, +1.0);
+         else if (lit[k].neg == 1)
+         {  npp_add_aij(npp, row, lit[k].col, -1.0);
+            row->lb -= 1.0;
          }
-         if (csa->obj_row == 0)
-            error(csa, "objective row `%s' not found\n",
-               parm->obj_name);
-      }
-      if (csa->obj_row != 0)
-      {  glp_set_obj_name(P, P->row[csa->obj_row]->name);
-         xprintf("Objective: %s\n", P->obj);
-      }
-      /* read COLUMNS section */
-      if (strcmp(csa->field, "COLUMNS") != 0)
-         error(csa, "missing COLUMNS indicator record\n");
-      read_columns(csa);
-      /* set objective coefficients */
-      if (csa->obj_row != 0)
-      {  GLPAIJ *aij;
-         for (aij = P->row[csa->obj_row]->ptr; aij != NULL; aij =
-            aij->r_next) glp_set_obj_coef(P, aij->col->j, aij->val);
-      }
-      /* read optional RHS section */
-      if (strcmp(csa->field, "RHS") == 0)
-         read_rhs(csa);
-      /* read optional RANGES section */
-      if (strcmp(csa->field, "RANGES") == 0)
-         read_ranges(csa);
-      /* read optional BOUNDS section */
-      if (strcmp(csa->field, "BOUNDS") == 0)
-         read_bounds(csa);
-      /* read ENDATA indicator record */
-      if (strcmp(csa->field, "ENDATA") != 0)
-         error(csa, "invalid use of %s indicator record\n",
-            csa->field);
-      /* print some statistics */
-      xprintf("%d row%s, %d column%s, %d non-zero%s\n",
-         P->m, P->m == 1 ? "" : "s", P->n, P->n == 1 ? "" : "s",
-         P->nnz, P->nnz == 1 ? "" : "s");
-      if (glp_get_num_int(P) > 0)
-      {  int ni = glp_get_num_int(P);
-         int nb = glp_get_num_bin(P);
-         if (ni == 1)
-         {  if (nb == 0)
-               xprintf("One variable is integer\n");
-            else
-               xprintf("One variable is binary\n");
+         else
+            xassert(lit != lit);
+      }
+      return row;
+}
+
+/***********************************************************************
+*  npp_sat_encode_geq - encode "not less than" constraint
+*
+*  PURPOSE
+*
+*  This routine translates to CNF the following constraint:
+*
+*      n
+*     sum 2**(k-1) * y[k] >= b,                                      (1)
+*     k=1
+*
+*  where y[k] is either a literal (i.e. y[k] = x[k] or y[k] = 1 - x[k])
+*  or constant false (zero), b is a given lower bound.
+*
+*  ALGORITHM
+*
+*  If b < 0, the constraint is redundant, so assume that b >= 0. Let
+*
+*          n
+*     b = sum 2**(k-1) b[k],                                         (2)
+*         k=1
+*
+*  where b[k] is k-th binary digit of b. (Note that if b >= 2**n and
+*  therefore cannot be represented in the form (2), the constraint (1)
+*  is infeasible.) In this case the condition (1) is equivalent to the
+*  following condition:
+*
+*     y[n] y[n-1] ... y[2] y[1] >= b[n] b[n-1] ... b[2] b[1],        (3)
+*
+*  where ">=" is understood lexicographically.
+*
+*  Algorithmically the condition (3) can be tested as follows:
+*
+*     for (k = n; k >= 1; k--)
+*     {  if (y[k] < b[k])
+*           y is less than b;
+*        if (y[k] > b[k])
+*           y is greater than b;
+*     }
+*     y is equal to b;
+*
+*  Thus, y is less than b iff there exists k, 1 <= k <= n, for which
+*  the following condition is satisfied:
+*
+*     y[n] = b[n] AND ... AND y[k+1] = b[k+1] AND y[k] < b[k].       (4)
+*
+*  Negating the condition (4) we have that y is not less than b iff for
+*  all k, 1 <= k <= n, the following condition is satisfied:
+*
+*     y[n] != b[n] OR ... OR y[k+1] != b[k+1] OR y[k] >= b[k].       (5)
+*
+*  Note that if b[k] = 0, the literal y[k] >= b[k] is always true, in
+*  which case the entire clause (5) is true and can be omitted.
+*
+*  RETURNS
+*
+*  Normally the routine returns zero. However, if the constraint (1) is
+*  infeasible, the routine returns non-zero. */
+
+int npp_sat_encode_geq(NPP *npp, int n, NPPLIT y[], int rhs)
+{     NPPLIT lit[1+NBIT_MAX];
+      int j, k, size, temp, b[1+NBIT_MAX];
+      xassert(0 <= n && n <= NBIT_MAX);
+      /* if the constraint (1) is redundant, do nothing */
+      if (rhs < 0)
+         return 0;
+      /* determine binary digits of b according to (2) */
+      for (k = 1, temp = rhs; k <= n; k++, temp >>= 1)
+         b[k] = temp & 1;
+      if (temp != 0)
+      {  /* b >= 2**n; the constraint (1) is infeasible */
+         return 1;
+      }
+      /* main transformation loop */
+      for (k = 1; k <= n; k++)
+      {  /* build the clause (5) for current k */
+         size = 0; /* clause size = number of literals */
+         /* add literal y[k] >= b[k] */
+         if (b[k] == 0)
+         {  /* b[k] = 0 -> the literal is true */
+            goto skip;
+         }
+         else if (y[k].col == NULL)
+         {  /* y[k] = 0, b[k] = 1 -> the literal is false */
+            xassert(y[k].neg == 0);
          }
          else
-         {  xprintf("%d integer variables, ", ni);
-            if (nb == 0)
-               xprintf("none");
-            else if (nb == 1)
-               xprintf("one");
-            else if (nb == ni)
-               xprintf("all");
+         {  /* add literal y[k] = 1 */
+            lit[++size] = y[k];
+         }
+         for (j = k+1; j <= n; j++)
+         {  /* add literal y[j] != b[j] */
+            if (y[j].col == NULL)
+            {  xassert(y[j].neg == 0);
+               if (b[j] == 0)
+               {  /* y[j] = 0, b[j] = 0 -> the literal is false */
+                  continue;
+               }
+               else
+               {  /* y[j] = 0, b[j] = 1 -> the literal is true */
+                  goto skip;
+               }
+            }
             else
-               xprintf("%d", nb);
-            xprintf(" of which %s binary\n", nb == 1 ? "is" : "are");
+            {  lit[++size] = y[j];
+               if (b[j] != 0)
+                  lit[size].neg = 1 - lit[size].neg;
+            }
          }
+         /* normalize the clause */
+         size = npp_sat_normalize_clause(npp, size, lit);
+         if (size < 0)
+         {  /* the clause is equivalent to the value true */
+            goto skip;
+         }
+         if (size == 0)
+         {  /* the clause is equivalent to the value false; this means
+               that the constraint (1) is infeasible */
+            return 2;
+         }
+         /* translate the clause to corresponding cover inequality */
+         npp_sat_encode_clause(npp, size, lit);
+skip:    ;
       }
-      xprintf("%d records were read\n", csa->recno);
-      /* problem data has been successfully read */
-      glp_delete_index(P);
-      glp_sort_matrix(P);
-      ret = 0;
-done: if (csa->fp != NULL) xfclose(csa->fp);
-      if (csa->work1 != NULL) xfree(csa->work1);
-      if (csa->work2 != NULL) xfree(csa->work2);
-      if (csa->work3 != NULL) xfree(csa->work3);
-      if (ret != 0) glp_erase_prob(P);
-      return ret;
+      return 0;
 }
 
 /***********************************************************************
-*  NAME
+*  npp_sat_encode_leq - encode "not greater than" constraint
+*
+*  PURPOSE
+*
+*  This routine translates to CNF the following constraint:
+*
+*      n
+*     sum 2**(k-1) * y[k] <= b,                                      (1)
+*     k=1
+*
+*  where y[k] is either a literal (i.e. y[k] = x[k] or y[k] = 1 - x[k])
+*  or constant false (zero), b is a given upper bound.
+*
+*  ALGORITHM
+*
+*  If b < 0, the constraint is infeasible, so assume that b >= 0. Let
+*
+*          n
+*     b = sum 2**(k-1) b[k],                                         (2)
+*         k=1
 *
-*  glp_write_mps - write problem data in MPS format
+*  where b[k] is k-th binary digit of b. (Note that if b >= 2**n and
+*  therefore cannot be represented in the form (2), the constraint (1)
+*  is redundant.) In this case the condition (1) is equivalent to the
+*  following condition:
 *
-*  SYNOPSIS
+*     y[n] y[n-1] ... y[2] y[1] <= b[n] b[n-1] ... b[2] b[1],        (3)
 *
-*  int glp_write_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
-*     const char *fname);
+*  where "<=" is understood lexicographically.
 *
-*  DESCRIPTION
+*  Algorithmically the condition (3) can be tested as follows:
 *
-*  The routine glp_write_mps writes problem data in MPS format to a
-*  text file.
+*     for (k = n; k >= 1; k--)
+*     {  if (y[k] < b[k])
+*           y is less than b;
+*        if (y[k] > b[k])
+*           y is greater than b;
+*     }
+*     y is equal to b;
 *
-*  The parameter fmt specifies the version of MPS format:
+*  Thus, y is greater than b iff there exists k, 1 <= k <= n, for which
+*  the following condition is satisfied:
 *
-*  GLP_MPS_DECK - fixed (ancient) MPS format;
-*  GLP_MPS_FILE - free (modern) MPS format.
+*     y[n] = b[n] AND ... AND y[k+1] = b[k+1] AND y[k] > b[k].       (4)
 *
-*  The parameter parm is a pointer to the structure glp_mpscp, which
-*  specifies control parameters used by the routine. If parm is NULL,
-*  the routine uses default settings.
+*  Negating the condition (4) we have that y is not greater than b iff
+*  for all k, 1 <= k <= n, the following condition is satisfied:
 *
-*  The character string fname specifies a name of the text file to be
-*  written.
+*     y[n] != b[n] OR ... OR y[k+1] != b[k+1] OR y[k] <= b[k].       (5)
+*
+*  Note that if b[k] = 1, the literal y[k] <= b[k] is always true, in
+*  which case the entire clause (5) is true and can be omitted.
 *
 *  RETURNS
 *
-*  If the operation was successful, the routine glp_read_mps returns
-*  zero. Otherwise, it prints an error message and returns non-zero. */
-
-#define csa csa1
+*  Normally the routine returns zero. However, if the constraint (1) is
+*  infeasible, the routine returns non-zero. */
 
-struct csa
-{     /* common storage area */
-      glp_prob *P;
-      /* pointer to problem object */
-      int deck;
-      /* MPS format (0 - free, 1 - fixed) */
-      const glp_mpscp *parm;
-      /* pointer to control parameters */
-      char field[255+1];
-      /* field buffer */
-};
-
-static char *mps_name(struct csa *csa)
-{     /* make problem name */
-      char *f;
-      if (csa->P->name == NULL)
-         csa->field[0] = '\0';
-      else if (csa->deck)
-      {  strncpy(csa->field, csa->P->name, 8);
-         csa->field[8] = '\0';
+int npp_sat_encode_leq(NPP *npp, int n, NPPLIT y[], int rhs)
+{     NPPLIT lit[1+NBIT_MAX];
+      int j, k, size, temp, b[1+NBIT_MAX];
+      xassert(0 <= n && n <= NBIT_MAX);
+      /* check if the constraint (1) is infeasible */
+      if (rhs < 0)
+         return 1;
+      /* determine binary digits of b according to (2) */
+      for (k = 1, temp = rhs; k <= n; k++, temp >>= 1)
+         b[k] = temp & 1;
+      if (temp != 0)
+      {  /* b >= 2**n; the constraint (1) is redundant */
+         return 0;
+      }
+      /* main transformation loop */
+      for (k = 1; k <= n; k++)
+      {  /* build the clause (5) for current k */
+         size = 0; /* clause size = number of literals */
+         /* add literal y[k] <= b[k] */
+         if (b[k] == 1)
+         {  /* b[k] = 1 -> the literal is true */
+            goto skip;
+         }
+         else if (y[k].col == NULL)
+         {  /* y[k] = 0, b[k] = 0 -> the literal is true */
+            xassert(y[k].neg == 0);
+            goto skip;
+         }
+         else
+         {  /* add literal y[k] = 0 */
+            lit[++size] = y[k];
+            lit[size].neg = 1 - lit[size].neg;
+         }
+         for (j = k+1; j <= n; j++)
+         {  /* add literal y[j] != b[j] */
+            if (y[j].col == NULL)
+            {  xassert(y[j].neg == 0);
+               if (b[j] == 0)
+               {  /* y[j] = 0, b[j] = 0 -> the literal is false */
+                  continue;
+               }
+               else
+               {  /* y[j] = 0, b[j] = 1 -> the literal is true */
+                  goto skip;
+               }
+            }
+            else
+            {  lit[++size] = y[j];
+               if (b[j] != 0)
+                  lit[size].neg = 1 - lit[size].neg;
+            }
+         }
+         /* normalize the clause */
+         size = npp_sat_normalize_clause(npp, size, lit);
+         if (size < 0)
+         {  /* the clause is equivalent to the value true */
+            goto skip;
+         }
+         if (size == 0)
+         {  /* the clause is equivalent to the value false; this means
+               that the constraint (1) is infeasible */
+            return 2;
+         }
+         /* translate the clause to corresponding cover inequality */
+         npp_sat_encode_clause(npp, size, lit);
+skip:    ;
       }
-      else
-         strcpy(csa->field, csa->P->name);
-      for (f = csa->field; *f != '\0'; f++)
-         if (*f == ' ') *f = '_';
-      return csa->field;
+      return 0;
 }
 
-static char *row_name(struct csa *csa, int i)
-{     /* make i-th row name */
-      char *f;
-      xassert(0 <= i && i <= csa->P->m);
-      if (i == 0 || csa->P->row[i]->name == NULL ||
-          csa->deck && strlen(csa->P->row[i]->name) > 8)
-         sprintf(csa->field, "R%07d", i);
-      else
-      {  strcpy(csa->field, csa->P->row[i]->name);
-         for (f = csa->field; *f != '\0'; f++)
-            if (*f == ' ') *f = '_';
-      }
-      return csa->field;
+/***********************************************************************
+*  npp_sat_encode_row - encode constraint (row) of general type
+*
+*  PURPOSE
+*
+*  This routine translates to CNF the following constraint (row):
+*
+*     L <= sum a[j] x[j] <= U,                                       (1)
+*           j
+*
+*  where all x[j] are binary variables.
+*
+*  ALGORITHM
+*
+*  First, the routine performs substitution x[j] = t[j] for j in J+
+*  and x[j] = 1 - t[j] for j in J-, where J+ = { j : a[j] > 0 } and
+*  J- = { j : a[j] < 0 }. This gives:
+*
+*     L <=  sum  a[j] t[j] +   sum  a[j] (1 - t[j]) <= U  ==>
+*         j in J+            j in J-
+*
+*     L' <= sum |a[j]| t[j] <= U',                                   (2)
+*            j
+*
+*  where
+*
+*     L' = L -   sum  a[j],   U' = U -   sum  a[j].                  (3)
+*              j in J-                 j in J-
+*
+*  (Actually only new bounds L' and U' are computed.)
+*
+*  Then the routine translates to CNF the following equality:
+*
+*                        n
+*     sum |a[j]| t[j] = sum 2**(k-1) * y[k],                         (4)
+*      j                k=1
+*
+*  where y[k] is either some t[j] or a new literal or a constant zero
+*  (see the routine npp_sat_encode_sum_ax).
+*
+*  Finally, the routine translates to CNF the following conditions:
+*
+*      n
+*     sum 2**(k-1) * y[k] >= L'                                      (5)
+*     k=1
+*
+*  and
+*
+*      n
+*     sum 2**(k-1) * y[k] <= U'                                      (6)
+*     k=1
+*
+*  (see the routines npp_sat_encode_geq and npp_sat_encode_leq).
+*
+*  All resulting clauses are encoded as cover inequalities and included
+*  into the transformed problem.
+*
+*  Note that on exit the routine removes the specified constraint (row)
+*  from the original problem.
+*
+*  RETURNS
+*
+*  The routine returns one of the following codes:
+*
+*  0 - translation was successful;
+*  1 - constraint (1) was found infeasible;
+*  2 - integer arithmetic error occured. */
+
+int npp_sat_encode_row(NPP *npp, NPPROW *row)
+{     NPPAIJ *aij;
+      NPPLIT y[1+NBIT_MAX];
+      int n, rhs;
+      double lb, ub;
+      /* the row should not be free */
+      xassert(!(row->lb == -DBL_MAX && row->ub == +DBL_MAX));
+      /* compute new bounds L' and U' (3) */
+      lb = row->lb;
+      ub = row->ub;
+      for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+      {  if (aij->val < 0.0)
+         {  if (lb != -DBL_MAX)
+               lb -= aij->val;
+            if (ub != -DBL_MAX)
+               ub -= aij->val;
+         }
+      }
+      /* encode the equality (4) */
+      n = npp_sat_encode_sum_ax(npp, row, y);
+      if (n < 0)
+         return 2; /* integer arithmetic error */
+      /* encode the condition (5) */
+      if (lb != -DBL_MAX)
+      {  rhs = (int)lb;
+         if ((double)rhs != lb)
+            return 2; /* integer arithmetic error */
+         if (npp_sat_encode_geq(npp, n, y, rhs) != 0)
+            return 1; /* original constraint is infeasible */
+      }
+      /* encode the condition (6) */
+      if (ub != +DBL_MAX)
+      {  rhs = (int)ub;
+         if ((double)rhs != ub)
+            return 2; /* integer arithmetic error */
+         if (npp_sat_encode_leq(npp, n, y, rhs) != 0)
+            return 1; /* original constraint is infeasible */
+      }
+      /* remove the specified row from the problem */
+      npp_del_row(npp, row);
+      return 0;
 }
 
-static char *col_name(struct csa *csa, int j)
-{     /* make j-th column name */
-      char *f;
-      xassert(1 <= j && j <= csa->P->n);
-      if (csa->P->col[j]->name == NULL ||
-          csa->deck && strlen(csa->P->col[j]->name) > 8)
-         sprintf(csa->field, "C%07d", j);
-      else
-      {  strcpy(csa->field, csa->P->col[j]->name);
-         for (f = csa->field; *f != '\0'; f++)
-            if (*f == ' ') *f = '_';
-      }
-      return csa->field;
-}
+/***********************************************************************
+*  npp_sat_encode_prob - encode 0-1 feasibility problem
+*
+*  This routine translates the specified 0-1 feasibility problem to an
+*  equivalent SAT-CNF problem.
+*
+*  N.B. Currently this is a very crude implementation.
+*
+*  RETURNS
+*
+*  0           success;
+*
+*  GLP_ENOPFS  primal/integer infeasibility detected;
+*
+*  GLP_ERANGE  integer overflow occured. */
 
-static char *mps_numb(struct csa *csa, double val)
-{     /* format floating-point number */
-      int dig;
-      char *exp;
-      for (dig = 12; dig >= 6; dig--)
-      {  if (val != 0.0 && fabs(val) < 0.002)
-            sprintf(csa->field, "%.*E", dig-1, val);
-         else
-            sprintf(csa->field, "%.*G", dig, val);
-         exp = strchr(csa->field, 'E');
-         if (exp != NULL)
-            sprintf(exp+1, "%d", atoi(exp+1));
-         if (strlen(csa->field) <= 12) break;
-      }
-      xassert(strlen(csa->field) <= 12);
-      return csa->field;
-}
-
-int glp_write_mps(glp_prob *P, int fmt, const glp_mpscp *parm,
-      const char *fname)
-{     /* write problem data in MPS format */
-      glp_mpscp _parm;
-      struct csa _csa, *csa = &_csa;
-      XFILE *fp;
-      int out_obj, one_col = 0, empty = 0;
-      int i, j, recno, marker, count, gap, ret;
-      xprintf("Writing problem data to `%s'...\n", fname);
-      if (!(fmt == GLP_MPS_DECK || fmt == GLP_MPS_FILE))
-         xerror("glp_write_mps: fmt = %d; invalid parameter\n", fmt);
-      if (parm == NULL)
-         glp_init_mpscp(&_parm), parm = &_parm;
-      /* check control parameters */
-      check_parm("glp_write_mps", parm);
-      /* initialize common storage area */
-      csa->P = P;
-      csa->deck = (fmt == GLP_MPS_DECK);
-      csa->parm = parm;
-      /* create output MPS file */
-      fp = xfopen(fname, "w"), recno = 0;
-      if (fp == NULL)
-      {  xprintf("Unable to create `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
-      }
-      /* write comment records */
-      xfprintf(fp, "* %-*s%s\n", P->name == NULL ? 1 : 12, "Problem:",
-         P->name == NULL ? "" : P->name), recno++;
-      xfprintf(fp, "* %-12s%s\n", "Class:", glp_get_num_int(P) == 0 ?
-         "LP" : "MIP"), recno++;
-      xfprintf(fp, "* %-12s%d\n", "Rows:", P->m), recno++;
-      if (glp_get_num_int(P) == 0)
-         xfprintf(fp, "* %-12s%d\n", "Columns:", P->n), recno++;
-      else
-         xfprintf(fp, "* %-12s%d (%d integer, %d binary)\n",
-            "Columns:", P->n, glp_get_num_int(P), glp_get_num_bin(P)),
-            recno++;
-      xfprintf(fp, "* %-12s%d\n", "Non-zeros:", P->nnz), recno++;
-      xfprintf(fp, "* %-12s%s\n", "Format:", csa->deck ? "Fixed MPS" :
-         "Free MPS"), recno++;
-      xfprintf(fp, "*\n", recno++);
-      /* write NAME indicator record */
-      xfprintf(fp, "NAME%*s%s\n",
-         P->name == NULL ? 0 : csa->deck ? 10 : 1, "", mps_name(csa)),
-         recno++;
-#if 1
-      /* determine whether to write the objective row */
-      out_obj = 1;
-      for (i = 1; i <= P->m; i++)
-      {  if (P->row[i]->type == GLP_FR)
-         {  out_obj = 0;
-            break;
-         }
-      }
-#endif
-      /* write ROWS section */
-      xfprintf(fp, "ROWS\n"), recno++;
-      for (i = (out_obj ? 0 : 1); i <= P->m; i++)
-      {  int type;
-         type = (i == 0 ? GLP_FR : P->row[i]->type);
-         if (type == GLP_FR)
-            type = 'N';
-         else if (type == GLP_LO)
-            type = 'G';
-         else if (type == GLP_UP)
-            type = 'L';
-         else if (type == GLP_DB || type == GLP_FX)
-            type = 'E';
-         else
-            xassert(type != type);
-         xfprintf(fp, " %c%*s%s\n", type, csa->deck ? 2 : 1, "",
-            row_name(csa, i)), recno++;
-      }
-      /* write COLUMNS section */
-      xfprintf(fp, "COLUMNS\n"), recno++;
-      marker = 0;
-      for (j = 1; j <= P->n; j++)
-      {  GLPAIJ cj, *aij;
-         int kind;
-         kind = P->col[j]->kind;
-         if (kind == GLP_CV)
-         {  if (marker % 2 == 1)
-            {  /* close current integer block */
-               marker++;
-               xfprintf(fp, "%*sM%07d%*s'MARKER'%*s'INTEND'\n",
-                  csa->deck ? 4 : 1, "", marker, csa->deck ? 2 : 1, "",
-                  csa->deck ? 17 : 1, ""), recno++;
-            }
-         }
-         else if (kind == GLP_IV)
-         {  if (marker % 2 == 0)
-            {  /* open new integer block */
-               marker++;
-               xfprintf(fp, "%*sM%07d%*s'MARKER'%*s'INTORG'\n",
-                  csa->deck ? 4 : 1, "", marker, csa->deck ? 2 : 1, "",
-                  csa->deck ? 17 : 1, ""), recno++;
+int npp_sat_encode_prob(NPP *npp)
+{     NPPROW *row, *next_row, *prev_row;
+      NPPCOL *col, *next_col;
+      int cover = 0, pack = 0, partn = 0, ret;
+      /* process and remove free rows */
+      for (row = npp->r_head; row != NULL; row = next_row)
+      {  next_row = row->next;
+         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)
+            npp_sat_free_row(npp, row);
+      }
+      /* process and remove fixed columns */
+      for (col = npp->c_head; col != NULL; col = next_col)
+      {  next_col = col->next;
+         if (col->lb == col->ub)
+            xassert(npp_sat_fixed_col(npp, col) == 0);
+      }
+      /* only binary variables should remain */
+      for (col = npp->c_head; col != NULL; col = col->next)
+         xassert(col->is_int && col->lb == 0.0 && col->ub == 1.0);
+      /* new rows may be added to the end of the row list, so we walk
+         from the end to beginning of the list */
+      for (row = npp->r_tail; row != NULL; row = prev_row)
+      {  prev_row = row->prev;
+         /* process special cases */
+         ret = npp_sat_is_cover_ineq(npp, row);
+         if (ret != 0)
+         {  /* row is covering inequality */
+            cover++;
+            /* since it already encodes a clause, just transform it to
+               canonical form */
+            if (ret == 2)
+            {  xassert(npp_sat_reverse_row(npp, row) == 0);
+               ret = npp_sat_is_cover_ineq(npp, row);
             }
+            xassert(ret == 1);
+            continue;
          }
-         else
-            xassert(kind != kind);
-         if (out_obj && P->col[j]->coef != 0.0)
-         {  /* make fake objective coefficient */
-            aij = &cj;
-            aij->row = NULL;
-            aij->val = P->col[j]->coef;
-            aij->c_next = P->col[j]->ptr;
-         }
-         else
-            aij = P->col[j]->ptr;
-#if 1 /* FIXME */
-         if (aij == NULL)
-         {  /* empty column */
-            empty++;
-            xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
-               csa->deck ? 8 : 1, col_name(csa, j));
-            /* we need a row */
-            xassert(P->m > 0);
-            xfprintf(fp, "%*s%-*s",
-               csa->deck ? 2 : 1, "", csa->deck ? 8 : 1,
-               row_name(csa, 1));
-            xfprintf(fp, "%*s0%*s$ empty column\n",
-               csa->deck ? 13 : 1, "", csa->deck ? 3 : 1, ""), recno++;
-         }
-#endif
-         count = 0;
-         for (aij = aij; aij != NULL; aij = aij->c_next)
-         {  if (one_col || count % 2 == 0)
-               xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
-                  csa->deck ? 8 : 1, col_name(csa, j));
-            gap = (one_col || count % 2 == 0 ? 2 : 3);
-            xfprintf(fp, "%*s%-*s",
-               csa->deck ? gap : 1, "", csa->deck ? 8 : 1,
-               row_name(csa, aij->row == NULL ? 0 : aij->row->i));
-            xfprintf(fp, "%*s%*s",
-               csa->deck ? 2 : 1, "", csa->deck ? 12 : 1,
-               mps_numb(csa, aij->val)), count++;
-            if (one_col || count % 2 == 0)
-               xfprintf(fp, "\n"), recno++;
-         }
-         if (!(one_col || count % 2 == 0))
-            xfprintf(fp, "\n"), recno++;
-      }
-      if (marker % 2 == 1)
-      {  /* close last integer block */
-         marker++;
-         xfprintf(fp, "%*sM%07d%*s'MARKER'%*s'INTEND'\n",
-            csa->deck ? 4 : 1, "", marker, csa->deck ? 2 : 1, "",
-            csa->deck ? 17 : 1, ""), recno++;
-      }
-#if 1
-      if (empty > 0)
-         xprintf("Warning: problem has %d empty column(s)\n", empty);
-#endif
-      /* write RHS section */
-      xfprintf(fp, "RHS\n"), recno++;
-      count = 0;
-      for (i = (out_obj ? 0 : 1); i <= P->m; i++)
-      {  int type;
-         double rhs;
-         if (i == 0)
-            rhs = P->c0;
-         else
-         {  type = P->row[i]->type;
-            if (type == GLP_FR)
-               rhs = 0.0;
-            else if (type == GLP_LO)
-               rhs = P->row[i]->lb;
-            else if (type == GLP_UP)
-               rhs = P->row[i]->ub;
-            else if (type == GLP_DB || type == GLP_FX)
-               rhs = P->row[i]->lb;
-            else
-               xassert(type != type);
-         }
-         if (rhs != 0.0)
-         {  if (one_col || count % 2 == 0)
-               xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
-                  csa->deck ? 8 : 1, "RHS1");
-            gap = (one_col || count % 2 == 0 ? 2 : 3);
-            xfprintf(fp, "%*s%-*s",
-               csa->deck ? gap : 1, "", csa->deck ? 8 : 1,
-               row_name(csa, i));
-            xfprintf(fp, "%*s%*s",
-               csa->deck ? 2 : 1, "", csa->deck ? 12 : 1,
-               mps_numb(csa, rhs)), count++;
-            if (one_col || count % 2 == 0)
-               xfprintf(fp, "\n"), recno++;
-         }
-      }
-      if (!(one_col || count % 2 == 0))
-         xfprintf(fp, "\n"), recno++;
-      /* write RANGES section */
-      for (i = P->m; i >= 1; i--)
-         if (P->row[i]->type == GLP_DB) break;
-      if (i == 0) goto bnds;
-      xfprintf(fp, "RANGES\n"), recno++;
-      count = 0;
-      for (i = 1; i <= P->m; i++)
-      {  if (P->row[i]->type == GLP_DB)
-         {  if (one_col || count % 2 == 0)
-               xfprintf(fp, "%*s%-*s", csa->deck ? 4 : 1, "",
-                  csa->deck ? 8 : 1, "RNG1");
-            gap = (one_col || count % 2 == 0 ? 2 : 3);
-            xfprintf(fp, "%*s%-*s",
-               csa->deck ? gap : 1, "", csa->deck ? 8 : 1,
-               row_name(csa, i));
-            xfprintf(fp, "%*s%*s",
-               csa->deck ? 2 : 1, "", csa->deck ? 12 : 1,
-               mps_numb(csa, P->row[i]->ub - P->row[i]->lb)), count++;
-            if (one_col || count % 2 == 0)
-               xfprintf(fp, "\n"), recno++;
-         }
-      }
-      if (!(one_col || count % 2 == 0))
-         xfprintf(fp, "\n"), recno++;
-bnds: /* write BOUNDS section */
-      for (j = P->n; j >= 1; j--)
-         if (!(P->col[j]->type == GLP_LO && P->col[j]->lb == 0.0))
-            break;
-      if (j == 0) goto endt;
-      xfprintf(fp, "BOUNDS\n"), recno++;
-      for (j = 1; j <= P->n; j++)
-      {  int type, data[2];
-         double bnd[2];
-         char *spec[2];
-         spec[0] = spec[1] = NULL;
-         type = P->col[j]->type;
-         if (type == GLP_FR)
-            spec[0] = "FR", data[0] = 0;
-         else if (type == GLP_LO)
-         {  if (P->col[j]->lb != 0.0)
-               spec[0] = "LO", data[0] = 1, bnd[0] = P->col[j]->lb;
-            if (P->col[j]->kind == GLP_IV)
-               spec[1] = "PL", data[1] = 0;
-         }
-         else if (type == GLP_UP)
-         {  spec[0] = "MI", data[0] = 0;
-            spec[1] = "UP", data[1] = 1, bnd[1] = P->col[j]->ub;
-         }
-         else if (type == GLP_DB)
-         {  if (P->col[j]->lb != 0.0)
-               spec[0] = "LO", data[0] = 1, bnd[0] = P->col[j]->lb;
-            spec[1] = "UP", data[1] = 1, bnd[1] = P->col[j]->ub;
-         }
-         else if (type == GLP_FX)
-            spec[0] = "FX", data[0] = 1, bnd[0] = P->col[j]->lb;
-         else
-            xassert(type != type);
-         for (i = 0; i <= 1; i++)
-         {  if (spec[i] != NULL)
-            {  xfprintf(fp, " %s %-*s%*s%-*s", spec[i],
-                  csa->deck ? 8 : 1, "BND1", csa->deck ? 2 : 1, "",
-                  csa->deck ? 8 : 1, col_name(csa, j));
-               if (data[i])
-                  xfprintf(fp, "%*s%*s", csa->deck ? 2 : 1, "",
-                     csa->deck ? 12 : 1, mps_numb(csa, bnd[i]));
-               xfprintf(fp, "\n"), recno++;
+         ret = npp_sat_is_partn_eq(npp, row);
+         if (ret != 0)
+         {  /* row is partitioning equality */
+            NPPROW *cov;
+            NPPAIJ *aij;
+            partn++;
+            /* transform it to canonical form */
+            if (ret == 2)
+            {  xassert(npp_sat_reverse_row(npp, row) == 0);
+               ret = npp_sat_is_partn_eq(npp, row);
             }
-         }
-      }
-endt: /* write ENDATA indicator record */
-      xfprintf(fp, "ENDATA\n"), recno++;
-      xfflush(fp);
-      if (xferror(fp))
-      {  xprintf("Write error on `%s' - %s\n", fname, xerrmsg());
-         ret = 1;
-         goto done;
+            xassert(ret == 1);
+            /* and split it into covering and packing inequalities,
+               both in canonical forms */
+            cov = npp_add_row(npp);
+            cov->lb = row->lb, cov->ub = +DBL_MAX;
+            for (aij = row->ptr; aij != NULL; aij = aij->r_next)
+               npp_add_aij(npp, cov, aij->col, aij->val);
+            xassert(npp_sat_is_cover_ineq(npp, cov) == 1);
+            /* the cover inequality already encodes a clause and do
+               not need any further processing */
+            row->lb = -DBL_MAX;
+            xassert(npp_sat_is_pack_ineq(npp, row) == 1);
+            /* the packing inequality will be processed below */
+            pack--;
+         }
+         ret = npp_sat_is_pack_ineq(npp, row);
+         if (ret != 0)
+         {  /* row is packing inequality */
+            NPPROW *rrr;
+            int nlit, desired_nlit = 4;
+            pack++;
+            /* transform it to canonical form */
+            if (ret == 2)
+            {  xassert(npp_sat_reverse_row(npp, row) == 0);
+               ret = npp_sat_is_pack_ineq(npp, row);
+            }
+            xassert(ret == 1);
+            /* process the packing inequality */
+            for (;;)
+            {  /* determine the number of literals in the remaining
+                  inequality */
+               nlit = npp_row_nnz(npp, row);
+               if (nlit <= desired_nlit)
+                  break;
+               /* split the current inequality into one having not more
+                  than desired_nlit literals and remaining one */
+               rrr = npp_sat_split_pack(npp, row, desired_nlit-1);
+               /* translate the former inequality to CNF and remove it
+                  from the original problem */
+               npp_sat_encode_pack(npp, rrr);
+            }
+            /* translate the remaining inequality to CNF and remove it
+               from the original problem */
+            npp_sat_encode_pack(npp, row);
+            continue;
+         }
+         /* translate row of general type to CNF and remove it from the
+            original problem */
+         ret = npp_sat_encode_row(npp, row);
+         if (ret == 0)
+            ;
+         else if (ret == 1)
+            ret = GLP_ENOPFS;
+         else if (ret == 2)
+            ret = GLP_ERANGE;
+         else
+            xassert(ret != ret);
+         if (ret != 0)
+            goto done;
       }
-      /* problem data has been successfully written */
-      xprintf("%d records were written\n", recno);
       ret = 0;
-done: if (fp != NULL) xfclose(fp);
-      return ret;
+      if (cover != 0)
+         xprintf("%d covering inequalities\n", cover);
+      if (pack != 0)
+         xprintf("%d packing inequalities\n", pack);
+      if (partn != 0)
+         xprintf("%d partitioning equalities\n", partn);
+done: return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/ks.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnet.h (graph and network algorithms) */
+/* ks.h (0-1 knapsack problem) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2017-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,43 +15,28 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPNET_H
-#define GLPNET_H
+#ifndef KS_H
+#define KS_H
 
-#define mc21a _glp_mc21a
-int mc21a(int n, const int icn[], const int ip[], const int lenr[],
-      int iperm[], int pr[], int arp[], int cv[], int out[]);
-/* permutations for zero-free diagonal */
-
-#define mc13d _glp_mc13d
-int mc13d(int n, const int icn[], const int ip[], const int lenr[],
-      int ior[], int ib[], int lowl[], int numb[], int prev[]);
-/* permutations to block triangular form */
-
-#define okalg _glp_okalg
-int okalg(int nv, int na, const int tail[], const int head[],
-      const int low[], const int cap[], const int cost[], int x[],
-      int pi[]);
-/* out-of-kilter algorithm */
-
-#define ffalg _glp_ffalg
-void ffalg(int nv, int na, const int tail[], const int head[],
-      int s, int t, const int cap[], int x[], char cut[]);
-/* Ford-Fulkerson algorithm */
-
-#define wclique _glp_wclique
-int wclique(int n, const int w[], const unsigned char a[], int ind[]);
-/* find maximum weight clique with Ostergard's algorithm */
-
-#define kellerman _glp_kellerman
-int kellerman(int n, int (*func)(void *info, int i, int ind[]),
-      void *info, void /* glp_graph */ *H);
-/* cover edges by cliques with Kellerman's heuristic */
+#define ks_enum _glp_ks_enum
+int ks_enum(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],
+      char x[/*1+n*/]);
+/* solve 0-1 knapsack problem by complete enumeration */
+
+#define ks_mt1 _glp_ks_mt1
+int ks_mt1(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],
+      char x[/*1+n*/]);
+/* solve 0-1 knapsack problem with Martello & Toth algorithm */
+
+#define ks_greedy _glp_ks_greedy
+int ks_greedy(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],
+      char x[/*1+n*/]);
+/* solve 0-1 knapsack problem with greedy heuristic */
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mc21a.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* glpnet01.c (permutations for zero-free diagonal) */
+/* mc21a.c (permutations for zero-free diagonal) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
 *
 *  This code is the result of translation of the Fortran subroutines
 *  MC21A and MC21B associated with the following paper:
 *
@@ -24,24 +24,24 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpnet.h"
+#include "mc21a.h"
 
 /***********************************************************************
 *  NAME
 *
 *  mc21a - permutations for zero-free diagonal
 *
 *  SYNOPSIS
 *
-*  #include "glpnet.h"
+*  #include "mc21a.h"
 *  int mc21a(int n, const int icn[], const int ip[], const int lenr[],
 *     int iperm[], int pr[], int arp[], int cv[], int out[]);
 *
 *  DESCRIPTION
 *
 *  Given the pattern of nonzeros of a sparse matrix, the routine mc21a
 *  attempts to find a permutation of its rows that makes the matrix have
@@ -99,15 +99,15 @@
       for (i = 1; i <= n; i++)
       {  arp[i] = lenr[i] - 1;
          cv[i] = iperm[i] = 0;
       }
       numnz = 0;
       /* Main loop. */
       /* Each pass round this loop either results in a new assignment
-         or gives a row with no assignment. */
+       * or gives a row with no assignment. */
       for (jord = 1; jord <= n; jord++)
       {  j = jord;
          pr[j] = -1;
          for (k = 1; k <= jord; k++)
          {  /* Look for a cheap assignment. */
             in1 = arp[j];
             if (in1 >= 0)
@@ -129,15 +129,15 @@
                {  in2 = ip[j] + lenr[j] - 1;
                   in1 = in2 - in1;
                   /* Forward scan. */
                   for (ii = in1; ii <= in2; ii++)
                   {  i = icn[ii];
                      if (cv[i] != jord)
                      {  /* Column i has not yet been accessed during
-                           this pass. */
+                         * this pass. */
                         j1 = j;
                         j = iperm[i];
                         cv[i] = jord;
                         pr[j] = j1;
                         out[j1] = in2 - ii - 1;
                         goto L100;
                      }
@@ -159,15 +159,15 @@
             ii = ip[j] + lenr[j] - out[j] - 2;
             i = icn[ii];
             iperm[i] = j;
          }
 L130:    ;
       }
       /* If matrix is structurally singular, we now complete the
-         permutation iperm. */
+       * permutation iperm. */
       if (numnz < n)
       {  for (i = 1; i <= n; i++)
             arp[i] = 0;
          k = 0;
          for (i = 1; i <= n; i++)
          {  if (iperm[i] == 0)
                out[++k] = i;
@@ -181,55 +181,55 @@
          }
       }
       return numnz;
 }
 
 /**********************************************************************/
 
-#if 0
-#include "glplib.h"
+#ifdef GLP_TEST
+#include "env.h"
 
 int sing;
 
 void ranmat(int m, int n, int icn[], int iptr[], int nnnp1, int *knum,
       int iw[]);
 
 void fa01bs(int max, int *nrand);
 
 int main(void)
 {     /* test program for the routine mc21a */
       /* these runs on random matrices cause all possible statements in
-         mc21a to be executed */
+       * mc21a to be executed */
       int i, iold, j, j1, j2, jj, knum, l, licn, n, nov4, num, numnz;
       int ip[1+21], icn[1+1000], iperm[1+20], lenr[1+20], iw1[1+80];
       licn = 1000;
       /* run on random matrices of orders 1 through 20 */
       for (n = 1; n <= 20; n++)
       {  nov4 = n / 4;
          if (nov4 < 1) nov4 = 1;
 L10:     fa01bs(nov4, &l);
          knum = l * n;
          /* knum is requested number of non-zeros in random matrix */
          if (knum > licn) goto L10;
          /* if sing is false, matrix is guaranteed structurally
-            non-singular */
+          * non-singular */
          sing = ((n / 2) * 2 == n);
          /* call to subroutine to generate random matrix */
          ranmat(n, n, icn, ip, n+1, &knum, iw1);
          /* knum is now actual number of non-zeros in random matrix */
          if (knum > licn) goto L10;
          xprintf("n = %2d; nz = %4d; sing = %d\n", n, knum, sing);
          /* set up array of row lengths */
          for (i = 1; i <= n; i++)
             lenr[i] = ip[i+1] - ip[i];
          /* call to mc21a */
          numnz = mc21a(n, icn, ip, lenr, iperm, &iw1[0], &iw1[n],
             &iw1[n+n], &iw1[n+n+n]);
          /* testing to see if there are numnz non-zeros on the diagonal
-            of the permuted matrix. */
+          * of the permuted matrix. */
          num = 0;
          for (i = 1; i <= n; i++)
          {  iold = iperm[i];
             j1 = ip[iold];
             j2 = j1 + lenr[iold] - 1;
             if (j2 < j1) continue;
             for (jj = j1; jj <= j2; jj++)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/mc13d.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* glpnet02.c (permutations to block triangular form) */
+/* mc13d.c (permutations to block triangular form) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
 *
 *  This code is the result of translation of the Fortran subroutines
 *  MC13D and MC13E associated with the following paper:
 *
@@ -24,24 +24,24 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpnet.h"
+#include "mc13d.h"
 
 /***********************************************************************
 *  NAME
 *
 *  mc13d - permutations to block triangular form
 *
 *  SYNOPSIS
 *
-*  #include "glpnet.h"
+*  #include "mc13d.h"
 *  int mc13d(int n, const int icn[], const int ip[], const int lenr[],
 *     int ior[], int ib[], int lowl[], int numb[], int prev[]);
 *
 *  DESCRIPTION
 *
 *  Given the column numbers of the nonzeros in each row of the sparse
 *  matrix, the routine mc13d finds a symmetric permutation that makes
@@ -102,44 +102,44 @@
 
 int mc13d(int n, const int icn[], const int ip[], const int lenr[],
       int ior[], int ib[], int lowl[], int numb[], int prev[])
 {     int *arp = ior;
       int dummy, i, i1, i2, icnt, ii, isn, ist, ist1, iv, iw, j, lcnt,
          nnm1, num, stp;
       /* icnt is the number of nodes whose positions in final ordering
-         have been found. */
+       * have been found. */
       icnt = 0;
       /* num is the number of blocks that have been found. */
       num = 0;
       nnm1 = n + n - 1;
       /* Initialization of arrays. */
       for (j = 1; j <= n; j++)
       {  numb[j] = 0;
          arp[j] = lenr[j] - 1;
       }
       for (isn = 1; isn <= n; isn++)
       {  /* Look for a starting node. */
          if (numb[isn] != 0) continue;
          iv = isn;
          /* ist is the number of nodes on the stack ... it is the stack
-            pointer. */
+          * pointer. */
          ist = 1;
          /* Put node iv at beginning of stack. */
          lowl[iv] = numb[iv] = 1;
          ib[n] = iv;
          /* The body of this loop puts a new node on the stack or
-            backtracks. */
+          * backtracks. */
          for (dummy = 1; dummy <= nnm1; dummy++)
          {  i1 = arp[iv];
             /* Have all edges leaving node iv been searched? */
             if (i1 >= 0)
             {  i2 = ip[iv] + lenr[iv] - 1;
                i1 = i2 - i1;
                /* Look at edges leaving node iv until one enters a new
-                  node or all edges are exhausted. */
+                * node or all edges are exhausted. */
                for (ii = i1; ii <= i2; ii++)
                {  iw = icn[ii];
                   /* Has node iw been on stack already? */
                   if (numb[iw] == 0) goto L70;
                   /* Update value of lowl[iv] if necessary. */
                   if (lowl[iw] < lowl[iv]) lowl[iv] = lowl[iw];
                }
@@ -149,15 +149,15 @@
             /* Is node iv the root of a block? */
             if (lowl[iv] < numb[iv]) goto L60;
             /* Order nodes in a block. */
             num++;
             ist1 = n + 1 - ist;
             lcnt = icnt + 1;
             /* Peel block off the top of the stack starting at the top
-               and working down to the root of the block. */
+             * and working down to the root of the block. */
             for (stp = ist1; stp <= n; stp++)
             {  iw = ib[stp];
                lowl[iw] = n + 1;
                numb[iw] = ++icnt;
                if (iw == iv) break;
             }
             ist = n - stp;
@@ -185,16 +185,16 @@
       for (i = 1; i <= n; i++)
          arp[numb[i]] = i;
       return num;
 }
 
 /**********************************************************************/
 
-#if 0
-#include "glplib.h"
+#ifdef GLP_TEST
+#include "env.h"
 
 void test(int n, int ipp);
 
 int main(void)
 {     /* test program for routine mc13d */
       test( 1,   0);
       test( 2,   1);
@@ -225,25 +225,25 @@
       for (j = 1; j <= n; j++)
       {  for (i = 1; i <= n; i++)
             a[i][j] = 0;
          a[j][j] = 1;
       }
       for (k9 = 1; k9 <= ipp; k9++)
       {  /* these statements should be replaced by calls to your
-            favorite random number generator to place two pseudo-random
-            numbers between 1 and n in the variables i and j */
+          * favorite random number generator to place two pseudo-random
+          * numbers between 1 and n in the variables i and j */
          for (;;)
          {  fa01bs(n, &i);
             fa01bs(n, &j);
             if (!a[i][j]) break;
          }
          a[i][j] = 1;
       }
       /* setup converts matrix a[i,j] to required sparsity-oriented
-         storage format */
+       * storage format */
       setup(n, a, ip, icn, lenr);
       num = mc13d(n, icn, ip, lenr, ior, ib, &iw[0], &iw[n], &iw[n+n]);
       /* output reordered matrix with blocking to improve clarity */
       xprintf("\nThe reordered matrix which has %d block%s is of the fo"
          "rm\n", num, num == 1 ? "" : "s");
       ib[num+1] = n + 1;
       index = 100;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/luf.c`

 * *Files 24% similar despite different names*

```diff
@@ -1,17 +1,13 @@
-/* glpnet03.c (Klingman's network problem generator) */
+/* luf.c (sparse LU-factorization) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  This code is the result of translation of the Fortran program NETGEN
-*  developed by Dr. Darwin Klingman, which is publically available from
-*  NETLIB at <http://www.netlib.org/lp/generators>.
-*
-*  The translation was made by Andrew Makhorin <mao@gnu.org>.
+*  Copyright (C) 2012-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -19,758 +15,697 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
+#include "env.h"
+#include "luf.h"
 
 /***********************************************************************
-*  NAME
-*
-*  glp_netgen - Klingman's network problem generator
+*  luf_store_v_cols - store matrix V = A in column-wise format
 *
-*  SYNOPSIS
+*  This routine stores matrix V = A in column-wise format, where A is
+*  the original matrix to be factorized.
 *
-*  int glp_netgen(glp_graph *G, int v_rhs, int a_cap, int a_cost,
-*     const int parm[1+15]);
-*
-*  DESCRIPTION
-*
-*  The routine glp_netgen is a network problem generator developed by
-*  Dr. Darwin Klingman. It can create capacitated and uncapacitated
-*  minimum cost flow (or transshipment), transportation, and assignment
-*  problems.
+*  On exit the routine returns the number of non-zeros in matrix V. */
+
+int luf_store_v_cols(LUF *luf, int (*col)(void *info, int j, int ind[],
+      double val[]), void *info, int ind[], double val[])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int vc_ref = luf->vc_ref;
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      int *vc_len = &sva->len[vc_ref-1];
+      int *vc_cap = &sva->cap[vc_ref-1];
+      int j, len, ptr, nnz;
+      nnz = 0;
+      for (j = 1; j <= n; j++)
+      {  /* get j-th column */
+         len = col(info, j, ind, val);
+         xassert(0 <= len && len <= n);
+         /* enlarge j-th column capacity */
+         if (vc_cap[j] < len)
+         {  if (sva->r_ptr - sva->m_ptr < len)
+            {  sva_more_space(sva, len);
+               sv_ind = sva->ind;
+               sv_val = sva->val;
+            }
+            sva_enlarge_cap(sva, vc_ref-1+j, len, 0);
+         }
+         /* store j-th column */
+         ptr = vc_ptr[j];
+         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
+         memcpy(&sv_val[ptr], &val[1], len * sizeof(double));
+         vc_len[j] = len;
+         nnz += len;
+      }
+      return nnz;
+}
+
+/***********************************************************************
+*  luf_check_all - check LU-factorization before k-th elimination step
 *
-*  The parameter G specifies the graph object, to which the generated
-*  problem data have to be stored. Note that on entry the graph object
-*  is erased with the routine glp_erase_graph.
+*  This routine checks that before performing k-th elimination step,
+*  1 <= k <= n+1, all components of the LU-factorization are correct.
 *
-*  The parameter v_rhs specifies an offset of the field of type double
-*  in the vertex data block, to which the routine stores the supply or
-*  demand value. If v_rhs < 0, the value is not stored.
+*  In case of k = n+1, i.e. after last elimination step, it is assumed
+*  that rows of F and columns of V are *not* built yet.
 *
-*  The parameter a_cap specifies an offset of the field of type double
-*  in the arc data block, to which the routine stores the arc capacity.
-*  If a_cap < 0, the capacity is not stored.
+*  NOTE: For testing/debugging only. */
+
+void luf_check_all(LUF *luf, int k)
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int fr_ref = luf->fr_ref;
+      int *fr_len = &sva->len[fr_ref-1];
+      int fc_ref = luf->fc_ref;
+      int *fc_ptr = &sva->ptr[fc_ref-1];
+      int *fc_len = &sva->len[fc_ref-1];
+      int vr_ref = luf->vr_ref;
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      int *vr_len = &sva->len[vr_ref-1];
+      int vc_ref = luf->vc_ref;
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      int *vc_len = &sva->len[vc_ref-1];
+      int *pp_ind = luf->pp_ind;
+      int *pp_inv = luf->pp_inv;
+      int *qq_ind = luf->qq_ind;
+      int *qq_inv = luf->qq_inv;
+      int i, ii, i_ptr, i_end, j, jj, j_ptr, j_end;
+      xassert(n > 0);
+      xassert(1 <= k && k <= n+1);
+      /* check permutation matrix P */
+      for (i = 1; i <= n; i++)
+      {  ii = pp_ind[i];
+         xassert(1 <= ii && ii <= n);
+         xassert(pp_inv[ii] == i);
+      }
+      /* check permutation matrix Q */
+      for (j = 1; j <= n; j++)
+      {  jj = qq_inv[j];
+         xassert(1 <= jj && jj <= n);
+         xassert(qq_ind[jj] == j);
+      }
+      /* check row-wise representation of matrix F */
+      for (i = 1; i <= n; i++)
+         xassert(fr_len[i] == 0);
+      /* check column-wise representation of matrix F */
+      for (j = 1; j <= n; j++)
+      {  /* j-th column of F = jj-th column of L */
+         jj = pp_ind[j];
+         if (jj < k)
+         {  j_ptr = fc_ptr[j];
+            j_end = j_ptr + fc_len[j];
+            for (; j_ptr < j_end; j_ptr++)
+            {  i = sv_ind[j_ptr];
+               xassert(1 <= i && i <= n);
+               ii = pp_ind[i]; /* f[i,j] = l[ii,jj] */
+               xassert(ii > jj);
+               xassert(sv_val[j_ptr] != 0.0);
+            }
+         }
+         else /* jj >= k */
+            xassert(fc_len[j] == 0);
+      }
+      /* check row-wise representation of matrix V */
+      for (i = 1; i <= n; i++)
+      {  /* i-th row of V = ii-th row of U */
+         ii = pp_ind[i];
+         i_ptr = vr_ptr[i];
+         i_end = i_ptr + vr_len[i];
+         for (; i_ptr < i_end; i_ptr++)
+         {  j = sv_ind[i_ptr];
+            xassert(1 <= j && j <= n);
+            jj = qq_inv[j]; /* v[i,j] = u[ii,jj] */
+            if (ii < k)
+               xassert(jj > ii);
+            else /* ii >= k */
+            {  xassert(jj >= k);
+               /* find v[i,j] in j-th column */
+               j_ptr = vc_ptr[j];
+               j_end = j_ptr + vc_len[j];
+               for (; sv_ind[j_ptr] != i; j_ptr++)
+                  /* nop */;
+               xassert(j_ptr < j_end);
+            }
+            xassert(sv_val[i_ptr] != 0.0);
+         }
+      }
+      /* check column-wise representation of matrix V */
+      for (j = 1; j <= n; j++)
+      {  /* j-th column of V = jj-th column of U */
+         jj = qq_inv[j];
+         if (jj < k)
+            xassert(vc_len[j] == 0);
+         else /* jj >= k */
+         {  j_ptr = vc_ptr[j];
+            j_end = j_ptr + vc_len[j];
+            for (; j_ptr < j_end; j_ptr++)
+            {  i = sv_ind[j_ptr];
+               ii = pp_ind[i]; /* v[i,j] = u[ii,jj] */
+               xassert(ii >= k);
+               /* find v[i,j] in i-th row */
+               i_ptr = vr_ptr[i];
+               i_end = i_ptr + vr_len[i];
+               for (; sv_ind[i_ptr] != j; i_ptr++)
+                  /* nop */;
+               xassert(i_ptr < i_end);
+            }
+         }
+      }
+      return;
+}
+
+/***********************************************************************
+*  luf_build_v_rows - build matrix V in row-wise format
 *
-*  The parameter a_cost specifies an offset of the field of type double
-*  in the arc data block, to which the routine stores the per-unit cost
-*  if the arc flow. If a_cost < 0, the cost is not stored.
+*  This routine builds the row-wise representation of matrix V in the
+*  left part of SVA using its column-wise representation.
 *
-*  The array parm contains description of the network to be generated:
+*  NOTE: On entry to the routine all rows of matrix V should have zero
+*        capacity.
 *
-*  parm[0]           not used
-*  parm[1]  (iseed)  8-digit positive random number seed
-*  parm[2]  (nprob)  8-digit problem id number
-*  parm[3]  (nodes)  total number of nodes
-*  parm[4]  (nsorc)  total number of source nodes (including
-*                    transshipment nodes)
-*  parm[5]  (nsink)  total number of sink nodes (including
-*                    transshipment nodes)
-*  parm[6]  (iarcs)  number of arcs
-*  parm[7]  (mincst) minimum cost for arcs
-*  parm[8]  (maxcst) maximum cost for arcs
-*  parm[9]  (itsup)  total supply
-*  parm[10] (ntsorc) number of transshipment source nodes
-*  parm[11] (ntsink) number of transshipment sink nodes
-*  parm[12] (iphic)  percentage of skeleton arcs to be given
-*                    the maximum cost
-*  parm[13] (ipcap)  percentage of arcs to be capacitated
-*  parm[14] (mincap) minimum upper bound for capacitated arcs
-*  parm[15] (maxcap) maximum upper bound for capacitated arcs
+*  The working array len should have at least 1+n elements (len[0] is
+*  not used). */
+
+void luf_build_v_rows(LUF *luf, int len[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int vr_ref = luf->vr_ref;
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      int *vr_len = &sva->len[vr_ref-1];
+      int vc_ref = luf->vc_ref;
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      int *vc_len = &sva->len[vc_ref-1];
+      int i, j, end, nnz, ptr, ptr1;
+      /* calculate the number of non-zeros in each row of matrix V and
+       * the total number of non-zeros */
+      nnz = 0;
+      for (i = 1; i <= n; i++)
+         len[i] = 0;
+      for (j = 1; j <= n; j++)
+      {  nnz += vc_len[j];
+         for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)
+            len[sv_ind[ptr]]++;
+      }
+      /* we need at least nnz free locations in SVA */
+      if (sva->r_ptr - sva->m_ptr < nnz)
+      {  sva_more_space(sva, nnz);
+         sv_ind = sva->ind;
+         sv_val = sva->val;
+      }
+      /* reserve locations for rows of matrix V */
+      for (i = 1; i <= n; i++)
+      {  if (len[i] > 0)
+            sva_enlarge_cap(sva, vr_ref-1+i, len[i], 0);
+         vr_len[i] = len[i];
+      }
+      /* walk thru column of matrix V and build its rows */
+      for (j = 1; j <= n; j++)
+      {  for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)
+         {  i = sv_ind[ptr];
+            sv_ind[ptr1 = vr_ptr[i] + (--len[i])] = j;
+            sv_val[ptr1] = sv_val[ptr];
+         }
+      }
+      return;
+}
+
+/***********************************************************************
+*  luf_build_f_rows - build matrix F in row-wise format
 *
-*  The routine generates a transportation problem if:
+*  This routine builds the row-wise representation of matrix F in the
+*  right part of SVA using its column-wise representation.
 *
-*     nsorc + nsink = nodes, ntsorc = 0, and ntsink = 0.
+*  NOTE: On entry to the routine all rows of matrix F should have zero
+*        capacity.
 *
-*  The routine generates an assignment problem if the requirements for
-*  a transportation problem are met and:
+*  The working array len should have at least 1+n elements (len[0] is
+*  not used). */
+
+void luf_build_f_rows(LUF *luf, int len[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int fr_ref = luf->fr_ref;
+      int *fr_ptr = &sva->ptr[fr_ref-1];
+      int *fr_len = &sva->len[fr_ref-1];
+      int fc_ref = luf->fc_ref;
+      int *fc_ptr = &sva->ptr[fc_ref-1];
+      int *fc_len = &sva->len[fc_ref-1];
+      int i, j, end, nnz, ptr, ptr1;
+      /* calculate the number of non-zeros in each row of matrix F and
+       * the total number of non-zeros (except diagonal elements) */
+      nnz = 0;
+      for (i = 1; i <= n; i++)
+         len[i] = 0;
+      for (j = 1; j <= n; j++)
+      {  nnz += fc_len[j];
+         for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)
+            len[sv_ind[ptr]]++;
+      }
+      /* we need at least nnz free locations in SVA */
+      if (sva->r_ptr - sva->m_ptr < nnz)
+      {  sva_more_space(sva, nnz);
+         sv_ind = sva->ind;
+         sv_val = sva->val;
+      }
+      /* reserve locations for rows of matrix F */
+      for (i = 1; i <= n; i++)
+      {  if (len[i] > 0)
+            sva_reserve_cap(sva, fr_ref-1+i, len[i]);
+         fr_len[i] = len[i];
+      }
+      /* walk through columns of matrix F and build its rows */
+      for (j = 1; j <= n; j++)
+      {  for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)
+         {  i = sv_ind[ptr];
+            sv_ind[ptr1 = fr_ptr[i] + (--len[i])] = j;
+            sv_val[ptr1] = sv_val[ptr];
+         }
+      }
+      return;
+}
+
+/***********************************************************************
+*  luf_build_v_cols - build matrix V in column-wise format
 *
-*     nsorc = nsink and itsup = nsorc.
+*  This routine builds the column-wise representation of matrix V in
+*  the left (if the flag updat is set) or right (if the flag updat is
+*  clear) part of SVA using its row-wise representation.
+*
+*  NOTE: On entry to the routine all columns of matrix V should have
+*        zero capacity.
+*
+*  The working array len should have at least 1+n elements (len[0] is
+*  not used). */
+
+void luf_build_v_cols(LUF *luf, int updat, int len[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int vr_ref = luf->vr_ref;
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      int *vr_len = &sva->len[vr_ref-1];
+      int vc_ref = luf->vc_ref;
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      int *vc_len = &sva->len[vc_ref-1];
+      int i, j, end, nnz, ptr, ptr1;
+      /* calculate the number of non-zeros in each column of matrix V
+       * and the total number of non-zeros (except pivot elements) */
+      nnz = 0;
+      for (j = 1; j <= n; j++)
+         len[j] = 0;
+      for (i = 1; i <= n; i++)
+      {  nnz += vr_len[i];
+         for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
+            len[sv_ind[ptr]]++;
+      }
+      /* we need at least nnz free locations in SVA */
+      if (sva->r_ptr - sva->m_ptr < nnz)
+      {  sva_more_space(sva, nnz);
+         sv_ind = sva->ind;
+         sv_val = sva->val;
+      }
+      /* reserve locations for columns of matrix V */
+      for (j = 1; j <= n; j++)
+      {  if (len[j] > 0)
+         {  if (updat)
+               sva_enlarge_cap(sva, vc_ref-1+j, len[j], 0);
+            else
+               sva_reserve_cap(sva, vc_ref-1+j, len[j]);
+         }
+         vc_len[j] = len[j];
+      }
+      /* walk through rows of matrix V and build its columns */
+      for (i = 1; i <= n; i++)
+      {  for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
+         {  j = sv_ind[ptr];
+            sv_ind[ptr1 = vc_ptr[j] + (--len[j])] = i;
+            sv_val[ptr1] = sv_val[ptr];
+         }
+      }
+      return;
+}
+
+/***********************************************************************
+*  luf_check_f_rc - check rows and columns of matrix F
 *
-*  RETURNS
+*  This routine checks that the row- and column-wise representations
+*  of matrix F are identical.
 *
-*  If the instance was successfully generated, the routine glp_netgen
-*  returns zero; otherwise, if specified parameters are inconsistent,
-*  the routine returns a non-zero error code.
+*  NOTE: For testing/debugging only. */
+
+void luf_check_f_rc(LUF *luf)
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int fr_ref = luf->fr_ref;
+      int *fr_ptr = &sva->ptr[fr_ref-1];
+      int *fr_len = &sva->len[fr_ref-1];
+      int fc_ref = luf->fc_ref;
+      int *fc_ptr = &sva->ptr[fc_ref-1];
+      int *fc_len = &sva->len[fc_ref-1];
+      int i, i_end, i_ptr, j, j_end, j_ptr;
+      /* walk thru rows of matrix F */
+      for (i = 1; i <= n; i++)
+      {  for (i_end = (i_ptr = fr_ptr[i]) + fr_len[i];
+            i_ptr < i_end; i_ptr++)
+         {  j = sv_ind[i_ptr];
+            /* find element f[i,j] in j-th column of matrix F */
+            for (j_end = (j_ptr = fc_ptr[j]) + fc_len[j];
+               sv_ind[j_ptr] != i; j_ptr++)
+               /* nop */;
+            xassert(j_ptr < j_end);
+            xassert(sv_val[i_ptr] == sv_val[j_ptr]);
+            /* mark element f[i,j] */
+            sv_ind[j_ptr] = -i;
+         }
+      }
+      /* walk thru column of matix F and check that all elements has
+         been marked */
+      for (j = 1; j <= n; j++)
+      {  for (j_end = (j_ptr = fc_ptr[j]) + fc_len[j];
+            j_ptr < j_end; j_ptr++)
+         {  xassert((i = sv_ind[j_ptr]) < 0);
+            /* unmark element f[i,j] */
+            sv_ind[j_ptr] = -i;
+         }
+      }
+      return;
+}
+
+/***********************************************************************
+*  luf_check_v_rc - check rows and columns of matrix V
 *
-*  REFERENCES
+*  This routine checks that the row- and column-wise representations
+*  of matrix V are identical.
 *
-*  D.Klingman, A.Napier, and J.Stutz. NETGEN: A program for generating
-*  large scale capacitated assignment, transportation, and minimum cost
-*  flow networks. Management Science 20 (1974), 814-20. */
-
-struct csa
-{     /* common storage area */
-      glp_graph *G;
-      int v_rhs, a_cap, a_cost;
-      int nodes, iarcs, mincst, maxcst, itsup, nsorc, nsink, nonsor,
-         nfsink, narcs, nsort, nftsor, ipcap, mincap, maxcap, ktl,
-         nodlft, *ipred, *ihead, *itail, *iflag, *isup, *lsinks, mult,
-         modul, i15, i16, jran;
-};
-
-#define G      (csa->G)
-#define v_rhs  (csa->v_rhs)
-#define a_cap  (csa->a_cap)
-#define a_cost (csa->a_cost)
-#define nodes  (csa->nodes)
-#define iarcs  (csa->iarcs)
-#define mincst (csa->mincst)
-#define maxcst (csa->maxcst)
-#define itsup  (csa->itsup)
-#define nsorc  (csa->nsorc)
-#define nsink  (csa->nsink)
-#define nonsor (csa->nonsor)
-#define nfsink (csa->nfsink)
-#define narcs  (csa->narcs)
-#define nsort  (csa->nsort)
-#define nftsor (csa->nftsor)
-#define ipcap  (csa->ipcap)
-#define mincap (csa->mincap)
-#define maxcap (csa->maxcap)
-#define ktl    (csa->ktl)
-#define nodlft (csa->nodlft)
-#if 0
-/* spent a day to find out this bug */
-#define ist    (csa->ist)
-#else
-#define ist    (ipred[0])
-#endif
-#define ipred  (csa->ipred)
-#define ihead  (csa->ihead)
-#define itail  (csa->itail)
-#define iflag  (csa->iflag)
-#define isup   (csa->isup)
-#define lsinks (csa->lsinks)
-#define mult   (csa->mult)
-#define modul  (csa->modul)
-#define i15    (csa->i15)
-#define i16    (csa->i16)
-#define jran   (csa->jran)
-
-static void cresup(struct csa *csa);
-static void chain(struct csa *csa, int lpick, int lsorc);
-static void chnarc(struct csa *csa, int lsorc);
-static void sort(struct csa *csa);
-static void pickj(struct csa *csa, int it);
-static void assign(struct csa *csa);
-static void setran(struct csa *csa, int iseed);
-static int iran(struct csa *csa, int ilow, int ihigh);
-
-int glp_netgen(glp_graph *G_, int _v_rhs, int _a_cap, int _a_cost,
-      const int parm[1+15])
-{     struct csa _csa, *csa = &_csa;
-      int iseed, nprob, ntsorc, ntsink, iphic, i, nskel, nltr, ltsink,
-         ntrans, npsink, nftr, npsorc, ntravl, ntrrem, lsorc, lpick,
-         nsksr, nsrchn, j, item, l, ks, k, ksp, li, n, ii, it, ih, icap,
-         jcap, icost, jcost, ret;
-      G = G_;
-      v_rhs = _v_rhs;
-      a_cap = _a_cap;
-      a_cost = _a_cost;
-      if (G != NULL)
-      {  if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))
-            xerror("glp_netgen: v_rhs = %d; invalid offset\n", v_rhs);
-         if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))
-            xerror("glp_netgen: a_cap = %d; invalid offset\n", a_cap);
-         if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))
-            xerror("glp_netgen: a_cost = %d; invalid offset\n", a_cost);
-      }
-      /* Input the user's random number seed and fix it if
-         non-positive. */
-      iseed = parm[1];
-      nprob = parm[2];
-      if (iseed <= 0) iseed = 13502460;
-      setran(csa, iseed);
-      /* Input the user's problem characteristics. */
-      nodes = parm[3];
-      nsorc = parm[4];
-      nsink = parm[5];
-      iarcs = parm[6];
-      mincst = parm[7];
-      maxcst = parm[8];
-      itsup = parm[9];
-      ntsorc = parm[10];
-      ntsink = parm[11];
-      iphic = parm[12];
-      ipcap = parm[13];
-      mincap = parm[14];
-      maxcap = parm[15];
-      /* Check the size of the problem. */
-      if (!(10 <= nodes && nodes <= 100000))
-      {  ret = 1;
-         goto done;
-      }
-      /* Check user supplied parameters for consistency. */
-      if (!(nsorc >= 0 && nsink >= 0 && nsorc + nsink <= nodes))
-      {  ret = 2;
-         goto done;
-      }
-      if (iarcs < 0)
-      {  ret = 3;
-         goto done;
-      }
-      if (mincst > maxcst)
-      {  ret = 4;
-         goto done;
-      }
-      if (itsup < 0)
-      {  ret = 5;
-         goto done;
-      }
-      if (!(0 <= ntsorc && ntsorc <= nsorc))
-      {  ret = 6;
-         goto done;
-      }
-      if (!(0 <= ntsink && ntsink <= nsink))
-      {  ret = 7;
-         goto done;
-      }
-      if (!(0 <= iphic && iphic <= 100))
-      {  ret = 8;
-         goto done;
-      }
-      if (!(0 <= ipcap && ipcap <= 100))
-      {  ret = 9;
-         goto done;
-      }
-      if (mincap > maxcap)
-      {  ret = 10;
-         goto done;
-      }
-      /* Initailize the graph object. */
-      if (G != NULL)
-      {  glp_erase_graph(G, G->v_size, G->a_size);
-         glp_add_vertices(G, nodes);
-         if (v_rhs >= 0)
-         {  double zero = 0.0;
-            for (i = 1; i <= nodes; i++)
-            {  glp_vertex *v = G->v[i];
-               memcpy((char *)v->data + v_rhs, &zero, sizeof(double));
-            }
+*  NOTE: For testing/debugging only. */
+
+void luf_check_v_rc(LUF *luf)
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int vr_ref = luf->vr_ref;
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      int *vr_len = &sva->len[vr_ref-1];
+      int vc_ref = luf->vc_ref;
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      int *vc_len = &sva->len[vc_ref-1];
+      int i, i_end, i_ptr, j, j_end, j_ptr;
+      /* walk thru rows of matrix V */
+      for (i = 1; i <= n; i++)
+      {  for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
+            i_ptr < i_end; i_ptr++)
+         {  j = sv_ind[i_ptr];
+            /* find element v[i,j] in j-th column of matrix V */
+            for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
+               sv_ind[j_ptr] != i; j_ptr++)
+               /* nop */;
+            xassert(j_ptr < j_end);
+            xassert(sv_val[i_ptr] == sv_val[j_ptr]);
+            /* mark element v[i,j] */
+            sv_ind[j_ptr] = -i;
+         }
+      }
+      /* walk thru column of matix V and check that all elements has
+         been marked */
+      for (j = 1; j <= n; j++)
+      {  for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
+            j_ptr < j_end; j_ptr++)
+         {  xassert((i = sv_ind[j_ptr]) < 0);
+            /* unmark element v[i,j] */
+            sv_ind[j_ptr] = -i;
          }
       }
-      /* Allocate working arrays. */
-      ipred = xcalloc(1+nodes, sizeof(int));
-      ihead = xcalloc(1+nodes, sizeof(int));
-      itail = xcalloc(1+nodes, sizeof(int));
-      iflag = xcalloc(1+nodes, sizeof(int));
-      isup = xcalloc(1+nodes, sizeof(int));
-      lsinks = xcalloc(1+nodes, sizeof(int));
-      /* Print the problem documentation records. */
-      if (G == NULL)
-      {  xprintf("BEGIN\n");
-         xprintf("NETGEN PROBLEM%8d%10s%10d NODES AND%10d ARCS\n",
-            nprob, "", nodes, iarcs);
-         xprintf("USER:%11d%11d%11d%11d%11d%11d\nDATA:%11d%11d%11d%11d%"
-            "11d%11d\n", iseed, nsorc, nsink, mincst,
-            maxcst, itsup, ntsorc, ntsink, iphic, ipcap,
-            mincap, maxcap);
-      }
-      else
-         glp_set_graph_name(G, "NETGEN");
-      /* Set various constants used in the program. */
-      narcs = 0;
-      nskel = 0;
-      nltr = nodes - nsink;
-      ltsink = nltr + ntsink;
-      ntrans = nltr - nsorc;
-      nfsink = nltr + 1;
-      nonsor = nodes - nsorc + ntsorc;
-      npsink = nsink - ntsink;
-      nodlft = nodes - nsink + ntsink;
-      nftr = nsorc + 1;
-      nftsor = nsorc - ntsorc + 1;
-      npsorc = nsorc - ntsorc;
-      /* Randomly distribute the supply among the source nodes. */
-      if (npsorc + npsink == nodes && npsorc == npsink &&
-          itsup == nsorc)
-      {  assign(csa);
-         nskel = nsorc;
-         goto L390;
-      }
-      cresup(csa);
-      /* Print the supply records. */
-      if (G == NULL)
-      {  xprintf("SUPPLY\n");
-         for (i = 1; i <= nsorc; i++)
-            xprintf("%6s%6d%18s%10d\n", "", i, "", isup[i]);
-         xprintf("ARCS\n");
-      }
-      else
-      {  if (v_rhs >= 0)
-         {  for (i = 1; i <= nsorc; i++)
-            {  double temp = (double)isup[i];
-               glp_vertex *v = G->v[i];
-               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));
-            }
+      return;
+}
+
+/***********************************************************************
+*  luf_f_solve - solve system F * x = b
+*
+*  This routine solves the system F * x = b, where the matrix F is the
+*  left factor of the sparse LU-factorization.
+*
+*  On entry the array x should contain elements of the right-hand side
+*  vector b in locations x[1], ..., x[n], where n is the order of the
+*  matrix F. On exit this array will contain elements of the solution
+*  vector x in the same locations. */
+
+void luf_f_solve(LUF *luf, double x[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int fc_ref = luf->fc_ref;
+      int *fc_ptr = &sva->ptr[fc_ref-1];
+      int *fc_len = &sva->len[fc_ref-1];
+      int *pp_inv = luf->pp_inv;
+      int j, k, ptr, end;
+      double x_j;
+      for (k = 1; k <= n; k++)
+      {  /* k-th column of L = j-th column of F */
+         j = pp_inv[k];
+         /* x[j] is already computed */
+         /* walk thru j-th column of matrix F and substitute x[j] into
+          * other equations */
+         if ((x_j = x[j]) != 0.0)
+         {  for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)
+               x[sv_ind[ptr]] -= sv_val[ptr] * x_j;
          }
       }
-      /* Make the sources point to themselves in ipred array. */
-      for (i = 1; i <= nsorc; i++)
-         ipred[i] = i;
-      if (ntrans == 0) goto L170;
-      /* Chain the transshipment nodes together in the ipred array. */
-      ist = nftr;
-      ipred[nltr] = 0;
-      for (i = nftr; i < nltr; i++)
-         ipred[i] = i+1;
-      /* Form even length chains for 60 percent of the transshipments.*/
-      ntravl = 6 * ntrans / 10;
-      ntrrem = ntrans - ntravl;
-L140: lsorc = 1;
-      while (ntravl != 0)
-      {  lpick = iran(csa, 1, ntravl + ntrrem);
-         ntravl--;
-         chain(csa, lpick, lsorc);
-         if (lsorc == nsorc) goto L140;
-         lsorc++;
-      }
-      /* Add the remaining transshipments to the chains. */
-      while (ntrrem != 0)
-      {
-         lpick = iran(csa, 1, ntrrem);
-         ntrrem--;
-         lsorc = iran(csa, 1, nsorc);
-         chain(csa, lpick, lsorc);
-      }
-L170: /* Set all demands equal to zero. */
-      for (i = nfsink; i <= nodes; i++)
-         ipred[i] = 0;
-      /* The following loop takes one chain at a time (through the use
-         of logic contained in the loop and calls to other routines) and
-         creates the remaining network arcs. */
-      for (lsorc = 1; lsorc <= nsorc; lsorc++)
-      {  chnarc(csa, lsorc);
-         for (i = nfsink; i <= nodes; i++)
-            iflag[i] = 0;
-         /* Choose the number of sinks to be hooked up to the current
-            chain. */
-         if (ntrans != 0)
-            nsksr = (nsort * 2 * nsink) / ntrans;
-         else
-            nsksr = nsink / nsorc + 1;
-         if (nsksr < 2) nsksr = 2;
-         if (nsksr > nsink) nsksr = nsink;
-         nsrchn = nsort;
-         /* Randomly pick nsksr sinks and put their names in lsinks. */
-         ktl = nsink;
-         for (j = 1; j <= nsksr; j++)
-         {  item = iran(csa, 1, ktl);
-            ktl--;
-            for (l = nfsink; l <= nodes; l++)
-            {  if (iflag[l] != 1)
-               {  item--;
-                  if (item == 0) goto L230;
-               }
-            }
-            break;
-L230:       lsinks[j] = l;
-            iflag[l] = 1;
-         }
-         /* If last source chain, add all sinks with zero demand to
-            lsinks list. */
-         if (lsorc == nsorc)
-         {  for (j = nfsink; j <= nodes; j++)
-            {  if (ipred[j] == 0 && iflag[j] != 1)
-               {  nsksr++;
-                  lsinks[nsksr] = j;
-                  iflag[j] = 1;
-               }
-            }
-         }
-         /* Create demands for group of sinks in lsinks. */
-         ks = isup[lsorc] / nsksr;
-         k = ipred[lsorc];
-         for (i = 1; i <= nsksr; i++)
-         {  nsort++;
-            ksp = iran(csa, 1, ks);
-            j = iran(csa, 1, nsksr);
-            itail[nsort] = k;
-            li = lsinks[i];
-            ihead[nsort] = li;
-            ipred[li] += ksp;
-            li = lsinks[j];
-            ipred[li] += ks - ksp;
-            n = iran(csa, 1, nsrchn);
-            k = lsorc;
-            for (ii = 1; ii <= n; ii++)
-               k = ipred[k];
-         }
-         li = lsinks[1];
-         ipred[li] += isup[lsorc] - ks * nsksr;
-         nskel += nsort;
-         /* Sort the arcs in the chain from source lsorc using itail as
-            sort key. */
-         sort(csa);
-         /* Print this part of skeleton and create the arcs for these
-            nodes. */
-         i = 1;
-         itail[nsort+1] = 0;
-L300:    for (j = nftsor; j <= nodes; j++)
-            iflag[j] = 0;
-         ktl = nonsor - 1;
-         it = itail[i];
-         iflag[it] = 1;
-L320:    ih = ihead[i];
-         iflag[ih] = 1;
-         narcs++;
-         ktl--;
-         /* Determine if this skeleton arc should be capacitated. */
-         icap = itsup;
-         jcap = iran(csa, 1, 100);
-         if (jcap <= ipcap)
-         {  icap = isup[lsorc];
-            if (mincap > icap) icap = mincap;
-         }
-         /* Determine if this skeleton arc should have the maximum
-            cost. */
-         icost = maxcst;
-         jcost = iran(csa, 1, 100);
-         if (jcost > iphic)
-            icost = iran(csa, mincst, maxcst);
-         if (G == NULL)
-            xprintf("%6s%6d%6d%2s%10d%10d\n", "", it, ih, "", icost,
-               icap);
-         else
-         {  glp_arc *a = glp_add_arc(G, it, ih);
-            if (a_cap >= 0)
-            {  double temp = (double)icap;
-               memcpy((char *)a->data + a_cap, &temp, sizeof(double));
-            }
-            if (a_cost >= 0)
-            {  double temp = (double)icost;
-               memcpy((char *)a->data + a_cost, &temp, sizeof(double));
-            }
-         }
-         i++;
-         if (itail[i] == it) goto L320;
-         pickj(csa, it);
-         if (i <= nsort) goto L300;
-      }
-      /* Create arcs from the transshipment sinks. */
-      if (ntsink != 0)
-      {  for (i = nfsink; i <= ltsink; i++)
-         {  for (j = nftsor; j <= nodes; j++)
-               iflag[j] = 0;
-            ktl = nonsor - 1;
-            iflag[i] = 1;
-            pickj(csa, i);
-         }
-      }
-L390: /* Print the demand records and end record. */
-      if (G == NULL)
-      {  xprintf("DEMAND\n");
-         for (i = nfsink; i <= nodes; i++)
-            xprintf("%6s%6d%18s%10d\n", "", i, "", ipred[i]);
-         xprintf("END\n");
-      }
-      else
-      {  if (v_rhs >= 0)
-         {  for (i = nfsink; i <= nodes; i++)
-            {  double temp = - (double)ipred[i];
-               glp_vertex *v = G->v[i];
-               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));
-            }
+      return;
+}
+
+/***********************************************************************
+*  luf_ft_solve - solve system F' * x = b
+*
+*  This routine solves the system F' * x = b, where F' is a matrix
+*  transposed to the matrix F, which is the left factor of the sparse
+*  LU-factorization.
+*
+*  On entry the array x should contain elements of the right-hand side
+*  vector b in locations x[1], ..., x[n], where n is the order of the
+*  matrix F. On exit this array will contain elements of the solution
+*  vector x in the same locations. */
+
+void luf_ft_solve(LUF *luf, double x[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int fr_ref = luf->fr_ref;
+      int *fr_ptr = &sva->ptr[fr_ref-1];
+      int *fr_len = &sva->len[fr_ref-1];
+      int *pp_inv = luf->pp_inv;
+      int i, k, ptr, end;
+      double x_i;
+      for (k = n; k >= 1; k--)
+      {  /* k-th column of L' = i-th row of F */
+         i = pp_inv[k];
+         /* x[i] is already computed */
+         /* walk thru i-th row of matrix F and substitute x[i] into
+          * other equations */
+         if ((x_i = x[i]) != 0.0)
+         {  for (end = (ptr = fr_ptr[i]) + fr_len[i]; ptr < end; ptr++)
+               x[sv_ind[ptr]] -= sv_val[ptr] * x_i;
          }
       }
-      /* Free working arrays. */
-      xfree(ipred);
-      xfree(ihead);
-      xfree(itail);
-      xfree(iflag);
-      xfree(isup);
-      xfree(lsinks);
-      /* The instance has been successfully generated. */
-      ret = 0;
-done: return ret;
-}
-
-/***********************************************************************
-*  The routine cresup randomly distributes the total supply among the
-*  source nodes. */
-
-static void cresup(struct csa *csa)
-{     int i, j, ks, ksp;
-      xassert(itsup > nsorc);
-      ks = itsup / nsorc;
-      for (i = 1; i <= nsorc; i++)
-         isup[i] = 0;
-      for (i = 1; i <= nsorc; i++)
-      {  ksp = iran(csa, 1, ks);
-         j = iran(csa, 1, nsorc);
-         isup[i] += ksp;
-         isup[j] += ks - ksp;
-      }
-      j = iran(csa, 1, nsorc);
-      isup[j] += itsup - ks * nsorc;
-      return;
-}
-
-/***********************************************************************
-*  The routine chain adds node lpick to the end of the chain with source
-*  node lsorc. */
-
-static void chain(struct csa *csa, int lpick, int lsorc)
-{     int i, j, k, l, m;
-      k = 0;
-      m = ist;
-      for (i = 1; i <= lpick; i++)
-      {  l = k;
-         k = m;
-         m = ipred[k];
-      }
-      ipred[l] = m;
-      j = ipred[lsorc];
-      ipred[k] = j;
-      ipred[lsorc] = k;
-      return;
-}
-
-/***********************************************************************
-*  The routine chnarc puts the arcs in the chain from source lsorc into
-*  the ihead and itail arrays for sorting. */
-
-static void chnarc(struct csa *csa, int lsorc)
-{     int ito, ifrom;
-      nsort = 0;
-      ito = ipred[lsorc];
-L10:  if (ito == lsorc) return;
-      nsort++;
-      ifrom = ipred[ito];
-      ihead[nsort] = ito;
-      itail[nsort] = ifrom;
-      ito = ifrom;
-      goto L10;
-}
-
-/***********************************************************************
-*  The routine sort sorts the nsort arcs in the ihead and itail arrays.
-*  ihead is used as the sort key (i.e. forward star sort order). */
-
-static void sort(struct csa *csa)
-{     int i, j, k, l, m, n, it;
-      n = nsort;
-      m = n;
-L10:  m /= 2;
-      if (m == 0) return;
-      k = n - m;
-      j = 1;
-L20:  i = j;
-L30:  l = i + m;
-      if (itail[i] <= itail[l]) goto L40;
-      it = itail[i];
-      itail[i] = itail[l];
-      itail[l] = it;
-      it = ihead[i];
-      ihead[i] = ihead[l];
-      ihead[l] = it;
-      i -= m;
-      if (i >= 1) goto L30;
-L40:  j++;
-      if (j <= k) goto L20;
-      goto L10;
-}
-
-/***********************************************************************
-*  The routine pickj creates a random number of arcs out of node 'it'.
-*  Various parameters are dynamically adjusted in an attempt to ensure
-*  that the generated network has the correct number of arcs. */
-
-static void pickj(struct csa *csa, int it)
-{     int j, k, l, nn, nupbnd, icap, jcap, icost;
-      if ((nodlft - 1) * 2 > iarcs - narcs - 1)
-      {  nodlft--;
-         return;
-      }
-      if ((iarcs - narcs + nonsor - ktl - 1) / nodlft - nonsor + 1 >= 0)
-         k = nonsor;
-      else
-      {  nupbnd = (iarcs - narcs - nodlft) / nodlft * 2;
-L40:     k = iran(csa, 1, nupbnd);
-         if (nodlft == 1) k = iarcs - narcs;
-         if ((nodlft - 1) * (nonsor - 1) < iarcs - narcs - k) goto L40;
-      }
-      nodlft--;
-      for (j = 1; j <= k; j++)
-      {  nn = iran(csa, 1, ktl);
-         ktl--;
-         for (l = nftsor; l <= nodes; l++)
-         {  if (iflag[l] != 1)
-            {  nn--;
-               if (nn == 0) goto L70;
-            }
-         }
-         return;
-L70:     iflag[l] = 1;
-         icap = itsup;
-         jcap = iran(csa, 1, 100);
-         if (jcap <= ipcap)
-            icap = iran(csa, mincap, maxcap);
-         icost = iran(csa, mincst, maxcst);
-         if (G == NULL)
-            xprintf("%6s%6d%6d%2s%10d%10d\n", "", it, l, "", icost,
-               icap);
-         else
-         {  glp_arc *a = glp_add_arc(G, it, l);
-            if (a_cap >= 0)
-            {  double temp = (double)icap;
-               memcpy((char *)a->data + a_cap, &temp, sizeof(double));
-            }
-            if (a_cost >= 0)
-            {  double temp = (double)icost;
-               memcpy((char *)a->data + a_cost, &temp, sizeof(double));
-            }
+      return;
+}
+
+/***********************************************************************
+*  luf_v_solve - solve system V * x = b
+*
+*  This routine solves the system V * x = b, where the matrix V is the
+*  right factor of the sparse LU-factorization.
+*
+*  On entry the array b should contain elements of the right-hand side
+*  vector b in locations b[1], ..., b[n], where n is the order of the
+*  matrix V. On exit the array x will contain elements of the solution
+*  vector x in locations x[1], ..., x[n]. Note that the array b will be
+*  clobbered on exit. */
+
+void luf_v_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      double *vr_piv = luf->vr_piv;
+      int vc_ref = luf->vc_ref;
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      int *vc_len = &sva->len[vc_ref-1];
+      int *pp_inv = luf->pp_inv;
+      int *qq_ind = luf->qq_ind;
+      int i, j, k, ptr, end;
+      double x_j;
+      for (k = n; k >= 1; k--)
+      {  /* k-th row of U = i-th row of V */
+         /* k-th column of U = j-th column of V */
+         i = pp_inv[k];
+         j = qq_ind[k];
+         /* compute x[j] = b[i] / u[k,k], where u[k,k] = v[i,j];
+          * walk through j-th column of matrix V and substitute x[j]
+          * into other equations */
+         if ((x_j = x[j] = b[i] / vr_piv[i]) != 0.0)
+         {  for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)
+               b[sv_ind[ptr]] -= sv_val[ptr] * x_j;
          }
-         narcs++;
       }
       return;
 }
 
 /***********************************************************************
-*  The routine assign generate assignment problems. It defines the unit
-*  supplies, builds a skeleton, then calls pickj to create the arcs. */
-
-static void assign(struct csa *csa)
-{     int i, it, nn, l, ll, icost;
-      if (G == NULL)
-         xprintf("SUPPLY\n");
-      for (i = 1; i <= nsorc; i++)
-      {  isup[i] = 1;
-         iflag[i] = 0;
-         if (G == NULL)
-            xprintf("%6s%6d%18s%10d\n", "", i, "", isup[i]);
-         else
-         {  if (v_rhs >= 0)
-            {  double temp = (double)isup[i];
-               glp_vertex *v = G->v[i];
-               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));
-            }
+*  luf_vt_solve - solve system V' * x = b
+*
+*  This routine solves the system V' * x = b, where V' is a matrix
+*  transposed to the matrix V, which is the right factor of the sparse
+*  LU-factorization.
+*
+*  On entry the array b should contain elements of the right-hand side
+*  vector b in locations b[1], ..., b[n], where n is the order of the
+*  matrix V. On exit the array x will contain elements of the solution
+*  vector x in locations x[1], ..., x[n]. Note that the array b will be
+*  clobbered on exit. */
+
+void luf_vt_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      double *vr_piv = luf->vr_piv;
+      int vr_ref = luf->vr_ref;
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      int *vr_len = &sva->len[vr_ref-1];
+      int *pp_inv = luf->pp_inv;
+      int *qq_ind = luf->qq_ind;
+      int i, j, k, ptr, end;
+      double x_i;
+      for (k = 1; k <= n; k++)
+      {  /* k-th row of U' = j-th column of V */
+         /* k-th column of U' = i-th row of V */
+         i = pp_inv[k];
+         j = qq_ind[k];
+         /* compute x[i] = b[j] / u'[k,k], where u'[k,k] = v[i,j];
+          * walk through i-th row of matrix V and substitute x[i] into
+          * other equations */
+         if ((x_i = x[i] = b[j] / vr_piv[i]) != 0.0)
+         {  for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
+               b[sv_ind[ptr]] -= sv_val[ptr] * x_i;
          }
       }
-      if (G == NULL)
-         xprintf("ARCS\n");
-      for (i = nfsink; i <= nodes; i++)
-         ipred[i] = 1;
-      for (it = 1; it <= nsorc; it++)
-      {  for (i = nfsink; i <= nodes; i++)
-            iflag[i] = 0;
-         ktl = nsink - 1;
-         nn = iran(csa, 1, nsink - it + 1);
-         for (l = 1; l <= nsorc; l++)
-         {  if (iflag[l] != 1)
-            {  nn--;
-               if (nn == 0) break;
-            }
-         }
-         narcs++;
-         ll = nsorc + l;
-         icost = iran(csa, mincst, maxcst);
-         if (G == NULL)
-            xprintf("%6s%6d%6d%2s%10d%10d\n", "", it, ll, "", icost,
-               isup[1]);
-         else
-         {  glp_arc *a = glp_add_arc(G, it, ll);
-            if (a_cap >= 0)
-            {  double temp = (double)isup[1];
-               memcpy((char *)a->data + a_cap, &temp, sizeof(double));
-            }
-            if (a_cost >= 0)
-            {  double temp = (double)icost;
-               memcpy((char *)a->data + a_cost, &temp, sizeof(double));
-            }
-         }
-         iflag[l] = 1;
-         iflag[ll] = 1;
-         pickj(csa, it);
+      return;
+}
+
+/***********************************************************************
+*  luf_vt_solve1 - solve system V' * y = e' to cause growth in y
+*
+*  This routine is a special version of luf_vt_solve. It solves the
+*  system V'* y = e' = e + delta e, where V' is a matrix transposed to
+*  the matrix V, e is the specified right-hand side vector, and delta e
+*  is a vector of +1 and -1 chosen to cause growth in the solution
+*  vector y.
+*
+*  On entry the array e should contain elements of the right-hand side
+*  vector e in locations e[1], ..., e[n], where n is the order of the
+*  matrix V. On exit the array y will contain elements of the solution
+*  vector y in locations y[1], ..., y[n]. Note that the array e will be
+*  clobbered on exit. */
+
+void luf_vt_solve1(LUF *luf, double e[/*1+n*/], double y[/*1+n*/])
+{     int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      double *vr_piv = luf->vr_piv;
+      int vr_ref = luf->vr_ref;
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      int *vr_len = &sva->len[vr_ref-1];
+      int *pp_inv = luf->pp_inv;
+      int *qq_ind = luf->qq_ind;
+      int i, j, k, ptr, end;
+      double e_j, y_i;
+      for (k = 1; k <= n; k++)
+      {  /* k-th row of U' = j-th column of V */
+         /* k-th column of U' = i-th row of V */
+         i = pp_inv[k];
+         j = qq_ind[k];
+         /* determine e'[j] = e[j] + delta e[j] */
+         e_j = (e[j] >= 0.0 ? e[j] + 1.0 : e[j] - 1.0);
+         /* compute y[i] = e'[j] / u'[k,k], where u'[k,k] = v[i,j] */
+         y_i = y[i] = e_j / vr_piv[i];
+         /* walk through i-th row of matrix V and substitute y[i] into
+          * other equations */
+         for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)
+            e[sv_ind[ptr]] -= sv_val[ptr] * y_i;
       }
       return;
 }
 
 /***********************************************************************
-*  Portable congruential (uniform) random number generator:
-*
-*     next_value = ((7**5) * previous_value) modulo ((2**31)-1)
-*
-*  This generator consists of three routines:
-*
-*  (1) setran - initializes constants and seed
-*  (2) iran   - generates an integer random number
-*  (3) rran   - generates a real random number
-*
-*  The generator requires a machine with at least 32 bits of precision.
-*  The seed (iseed) must be in the range [1,(2**31)-1]. */
-
-static void setran(struct csa *csa, int iseed)
-{     xassert(iseed >= 1);
-      mult = 16807;
-      modul = 2147483647;
-      i15 = 1 << 15;
-      i16 = 1 << 16;
-      jran = iseed;
-      return;
-}
-
-/***********************************************************************
-*  The routine iran generates an integer random number between ilow and
-*  ihigh. If ilow > ihigh then iran returns ihigh. */
-
-static int iran(struct csa *csa, int ilow, int ihigh)
-{     int ixhi, ixlo, ixalo, leftlo, ixahi, ifulhi, irtlo, iover,
-         irthi, j;
-      ixhi = jran / i16;
-      ixlo = jran - ixhi * i16;
-      ixalo = ixlo * mult;
-      leftlo = ixalo / i16;
-      ixahi = ixhi * mult;
-      ifulhi = ixahi + leftlo;
-      irtlo = ixalo - leftlo * i16;
-      iover = ifulhi / i15;
-      irthi = ifulhi - iover * i15;
-      jran = ((irtlo - modul) + irthi * i16) + iover;
-      if (jran < 0) jran += modul;
-      j = ihigh - ilow + 1;
-      if (j > 0)
-         return jran % j + ilow;
-      else
-         return ihigh;
-}
-
-/**********************************************************************/
-
-#if 0
-static int scan(char card[80+1], int pos, int len)
-{     char buf[10+1];
-      memcpy(buf, &card[pos-1], len);
-      buf[len] = '\0';
-      return atoi(buf);
-}
-
-int main(void)
-{     int parm[1+15];
-      char card[80+1];
-      xassert(fgets(card, sizeof(card), stdin) == card);
-      parm[1] = scan(card, 1, 8);
-      parm[2] = scan(card, 9, 8);
-      xassert(fgets(card, sizeof(card), stdin) == card);
-      parm[3] = scan(card, 1, 5);
-      parm[4] = scan(card, 6, 5);
-      parm[5] = scan(card, 11, 5);
-      parm[6] = scan(card, 16, 5);
-      parm[7] = scan(card, 21, 5);
-      parm[8] = scan(card, 26, 5);
-      parm[9] = scan(card, 31, 10);
-      parm[10] = scan(card, 41, 5);
-      parm[11] = scan(card, 46, 5);
-      parm[12] = scan(card, 51, 5);
-      parm[13] = scan(card, 56, 5);
-      parm[14] = scan(card, 61, 10);
-      parm[15] = scan(card, 71, 10);
-      glp_netgen(NULL, 0, 0, 0, parm);
-      return 0;
+*  luf_estimate_norm - estimate 1-norm of inv(A)
+*
+*  This routine estimates 1-norm of inv(A) by one step of inverse
+*  iteration for the small singular vector as described in [1]. This
+*  involves solving two systems of equations:
+*
+*     A'* y = e,
+*
+*     A * z = y,
+*
+*  where A' is a matrix transposed to A, and e is a vector of +1 and -1
+*  chosen to cause growth in y. Then
+*
+*     estimate 1-norm of inv(A) = (1-norm of z) / (1-norm of y)
+*
+*  REFERENCES
+*
+*  1. G.E.Forsythe, M.A.Malcolm, C.B.Moler. Computer Methods for
+*     Mathematical Computations. Prentice-Hall, Englewood Cliffs, N.J.,
+*     pp. 30-62 (subroutines DECOMP and SOLVE). */
+
+double luf_estimate_norm(LUF *luf, double w1[/*1+n*/], double
+      w2[/*1+n*/])
+{     int n = luf->n;
+      double *e = w1;
+      double *y = w2;
+      double *z = w1;
+      int i;
+      double y_norm, z_norm;
+      /* y = inv(A') * e = inv(F') * inv(V') * e */
+      /* compute y' = inv(V') * e to cause growth in y' */
+      for (i = 1; i <= n; i++)
+         e[i] = 0.0;
+      luf_vt_solve1(luf, e, y);
+      /* compute y = inv(F') * y' */
+      luf_ft_solve(luf, y);
+      /* compute 1-norm of y = sum |y[i]| */
+      y_norm = 0.0;
+      for (i = 1; i <= n; i++)
+         y_norm += (y[i] >= 0.0 ? +y[i] : -y[i]);
+      /* z = inv(A) * y = inv(V) * inv(F) * y */
+      /* compute z' = inv(F) * y */
+      luf_f_solve(luf, y);
+      /* compute z = inv(V) * z' */
+      luf_v_solve(luf, y, z);
+      /* compute 1-norm of z = sum |z[i]| */
+      z_norm = 0.0;
+      for (i = 1; i <= n; i++)
+         z_norm += (z[i] >= 0.0 ? +z[i] : -z[i]);
+      /* estimate 1-norm of inv(A) = (1-norm of z) / (1-norm of y) */
+      return z_norm / y_norm;
 }
-#endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet06.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/okalg.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnet06.c (out-of-kilter algorithm) */
+/* okalg.c (out-of-kilter algorithm) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,29 +15,25 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#endif
-
-#include "glpenv.h"
-#include "glpnet.h"
+#include "env.h"
+#include "okalg.h"
 
 /***********************************************************************
 *  NAME
 *
 *  okalg - out-of-kilter algorithm
 *
 *  SYNOPSIS
 *
-*  #include "glpnet.h"
+*  #include "okalg.h"
 *  int okalg(int nv, int na, const int tail[], const int head[],
 *     const int low[], const int cap[], const int cost[], int x[],
 *     int pi[]);
 *
 *  DESCRIPTION
 *
 *  The routine okalg implements the out-of-kilter algorithm to find a
@@ -137,15 +130,15 @@
       for (a = 1; a <= na; a++)
       {  arc[--ptr[tail[a]]] = a;
          arc[--ptr[head[a]]] = a;
       }
       xassert(ptr[1] == 1);
       xassert(ptr[nv+1] == na+na+1);
       /* now the indices of arcs incident to node i are stored in
-         locations arc[ptr[i]], arc[ptr[i]+1], ..., arc[ptr[i+1]-1] */
+       * locations arc[ptr[i]], arc[ptr[i]+1], ..., arc[ptr[i+1]-1] */
       /* initialize arc flows and node potentials */
       for (a = 1; a <= na; a++)
          x[a] = 0;
       for (i = 1; i <= nv; i++)
          pi[i] = 0;
 loop: /* main loop starts here */
       /* find out-of-kilter arc */
@@ -153,23 +146,23 @@
       for (a = 1; a <= na; a++)
       {  i = tail[a], j = head[a];
          if (overflow(cost[a], pi[i] - pi[j]))
          {  ret = 2;
             goto done;
          }
          lambda = cost[a] + (pi[i] - pi[j]);
-         if (x[a] < low[a] || lambda < 0 && x[a] < cap[a])
+         if (x[a] < low[a] || (lambda < 0 && x[a] < cap[a]))
          {  /* arc a = i->j is out of kilter, and we need to increase
-               the flow through this arc */
+             * the flow through this arc */
             aok = a, s = j, t = i;
             break;
          }
-         if (x[a] > cap[a] || lambda > 0 && x[a] > low[a])
+         if (x[a] > cap[a] || (lambda > 0 && x[a] > low[a]))
          {  /* arc a = i->j is out of kilter, and we need to decrease
-               the flow through this arc */
+             * the flow through this arc */
             aok = a, s = i, t = j;
             break;
          }
       }
       if (aok == 0)
       {  /* all arcs are in kilter */
          /* check for feasibility */
@@ -199,29 +192,29 @@
                goto done;
             }
          }
          /* check for optimality */
          for (a = 1; a <= na; a++)
          {  i = tail[a], j = head[a];
             lambda = cost[a] + (pi[i] - pi[j]);
-            if (lambda > 0 && x[a] != low[a] ||
-                lambda < 0 && x[a] != cap[a])
+            if ((lambda > 0 && x[a] != low[a]) ||
+                (lambda < 0 && x[a] != cap[a]))
             {  ret = 3;
                goto done;
             }
          }
          /* current circulation is optimal */
          ret = 0;
          goto done;
       }
       /* now we need to find a cycle (t, a, s, ..., t), which allows
-         increasing the flow along it, where a is the out-of-kilter arc
-         just found */
+       * increasing the flow along it, where a is the out-of-kilter arc
+       * just found */
       /* link[i] = 0 means that node i is not labelled yet;
-         link[i] = a means that arc a immediately precedes node i */
+       * link[i] = a means that arc a immediately precedes node i */
       /* initially only node s is labelled */
       for (i = 1; i <= nv; i++)
          link[i] = 0;
       link[s] = aok, list[1] = s, pos1 = pos2 = 1;
       /* breadth first search */
       while (pos1 <= pos2)
       {  /* dequeue node i */
@@ -231,30 +224,30 @@
          {  a = arc[k];
             if (tail[a] == i)
             {  /* a = i->j is a forward arc from s to t */
                j = head[a];
                /* if node j has been labelled, skip the arc */
                if (link[j] != 0) continue;
                /* if the arc does not allow increasing the flow through
-                  it, skip the arc */
+                * it, skip the arc */
                if (x[a] >= cap[a]) continue;
                if (overflow(cost[a], pi[i] - pi[j]))
                {  ret = 2;
                   goto done;
                }
                lambda = cost[a] + (pi[i] - pi[j]);
                if (lambda > 0 && x[a] >= low[a]) continue;
             }
             else if (head[a] == i)
             {  /* a = i<-j is a backward arc from s to t */
                j = tail[a];
                /* if node j has been labelled, skip the arc */
                if (link[j] != 0) continue;
                /* if the arc does not allow decreasing the flow through
-                  it, skip the arc */
+                * it, skip the arc */
                if (x[a] <= low[a]) continue;
                if (overflow(cost[a], pi[j] - pi[i]))
                {  ret = 2;
                   goto done;
                }
                lambda = cost[a] + (pi[j] - pi[i]);
                if (lambda < 0 && x[a] <= cap[a]) continue;
@@ -265,15 +258,15 @@
             link[j] = a, list[++pos2] = j;
             /* check for breakthrough */
             if (j == t) goto brkt;
          }
       }
       /* NONBREAKTHROUGH */
       /* consider all arcs, whose one endpoint is labelled and other is
-         not, and determine maximal change of node potentials */
+       * not, and determine maximal change of node potentials */
       delta = 0;
       for (a = 1; a <= na; a++)
       {  i = tail[a], j = head[a];
          if (link[i] != 0 && link[j] == 0)
          {  /* a = i->j, where node i is labelled, node j is not */
             if (overflow(cost[a], pi[i] - pi[j]))
             {  ret = 2;
@@ -308,15 +301,15 @@
             }
             pi[i] += delta;
          }
       }
       goto loop;
 brkt: /* BREAKTHROUGH */
       /* walk through arcs of the cycle (t, a, s, ..., t) found in the
-         reverse order and determine maximal change of the flow */
+       * reverse order and determine maximal change of the flow */
       delta = 0;
       for (j = t;; j = i)
       {  /* arc a immediately precedes node j in the cycle */
          a = link[j];
          if (head[a] == j)
          {  /* a = i->j is a forward arc of the cycle */
             i = tail[a];
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet07.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/ffalg.c`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnet07.c (Ford-Fulkerson algorithm) */
+/* ffalg.c (Ford-Fulkerson algorithm) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,25 +15,25 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpenv.h"
-#include "glpnet.h"
+#include "env.h"
+#include "ffalg.h"
 
 /***********************************************************************
 *  NAME
 *
 *  ffalg - Ford-Fulkerson algorithm
 *
 *  SYNOPSIS
 *
-*  #include "glpnet.h"
+*  #include "ffalg.h"
 *  void ffalg(int nv, int na, const int tail[], const int head[],
 *     int s, int t, const int cap[], int x[], char cut[]);
 *
 *  DESCRIPTION
 *
 *  The routine ffalg implements the Ford-Fulkerson algorithm to find a
 *  maximal flow in the specified flow network.
@@ -112,22 +109,22 @@
       for (a = 1; a <= na; a++)
       {  arc[--ptr[tail[a]]] = a;
          arc[--ptr[head[a]]] = a;
       }
       xassert(ptr[1] == 1);
       xassert(ptr[nv+1] == na+na+1);
       /* now the indices of arcs incident to node i are stored in
-         locations arc[ptr[i]], arc[ptr[i]+1], ..., arc[ptr[i+1]-1] */
+       * locations arc[ptr[i]], arc[ptr[i]+1], ..., arc[ptr[i+1]-1] */
       /* initialize arc flows */
       for (a = 1; a <= na; a++)
          x[a] = 0;
 loop: /* main loop starts here */
       /* build augmenting tree rooted at s */
       /* link[i] = 0 means that node i is not labelled yet;
-         link[i] = a means that arc a immediately precedes node i */
+       * link[i] = a means that arc a immediately precedes node i */
       /* initially node s is labelled as the root */
       for (i = 1; i <= nv; i++)
          link[i] = 0;
       link[s] = -1, list[1] = s, pos1 = pos2 = 1;
       /* breadth first search */
       while (pos1 <= pos2)
       {  /* dequeue node i */
@@ -137,24 +134,24 @@
          {  a = arc[k];
             if (tail[a] == i)
             {  /* a = i->j is a forward arc from s to t */
                j = head[a];
                /* if node j has been labelled, skip the arc */
                if (link[j] != 0) continue;
                /* if the arc does not allow increasing the flow through
-                  it, skip the arc */
+                * it, skip the arc */
                if (x[a] == cap[a]) continue;
             }
             else if (head[a] == i)
             {  /* a = i<-j is a backward arc from s to t */
                j = tail[a];
                /* if node j has been labelled, skip the arc */
                if (link[j] != 0) continue;
                /* if the arc does not allow decreasing the flow through
-                  it, skip the arc */
+                * it, skip the arc */
                if (x[a] == 0) continue;
             }
             else
                xassert(a != a);
             /* label node j and enqueue it */
             link[j] = a, list[++pos2] = j;
             /* check for breakthrough */
@@ -167,15 +164,15 @@
       if (cut != NULL)
       {  for (i = 1; i <= nv; i++)
             cut[i] = (char)(link[i] != 0);
       }
       goto done;
 brkt: /* BREAKTHROUGH */
       /* walk through arcs of the augmenting path (s, ..., t) found in
-         the reverse order and determine maximal change of the flow */
+       * the reverse order and determine maximal change of the flow */
       delta = 0;
       for (j = t; j != s; j = i)
       {  /* arc a immediately precedes node j in the path */
          a = link[j];
          if (head[a] == j)
          {  /* a = i->j is a forward arc of the cycle */
             i = tail[a];
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet08.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/wclique.c`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* glpnet08.c */
+/* wclique.c (maximum weight clique, Ostergard's algorithm) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
 *
 *  Two subroutines sub() and wclique() below are intended to find a
 *  maximum weight clique in a given undirected graph. These subroutines
 *  are slightly modified version of the program WCLIQUE developed by
@@ -27,28 +27,25 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#endif
-
-#include "glpenv.h"
-#include "glpnet.h"
+#include "env.h"
+#include "wclique.h"
 
 /***********************************************************************
 *  NAME
 *
 *  wclique - find maximum weight clique with Ostergard's algorithm
 *
 *  SYNOPSIS
 *
+*  #include "wclique.h"
 *  int wclique(int n, const int w[], const unsigned char a[],
 *     int ind[]);
 *
 *  DESCRIPTION
 *
 *  The routine wclique finds a maximum weight clique in an undirected
 *  graph with Ostergard's algorithm.
@@ -101,15 +98,15 @@
 #define rec       (csa->rec)
 #define clique    (csa->clique)
 #define set       (csa->set)
 
 #if 0
 static int is_edge(struct csa *csa, int i, int j)
 {     /* if there is arc (i,j), the routine returns true; otherwise
-         false; 0 <= i, j < n */
+       * false; 0 <= i, j < n */
       int k;
       xassert(0 <= i && i < n);
       xassert(0 <= j && j < n);
       if (i == j) return 0;
       if (i < j) k = i, i = j, j = k;
       k = (i * (i - 1)) / 2 + j;
       return a[k / CHAR_BIT] &
@@ -164,22 +161,22 @@
          sub(csa, p1 - newtable - 1, newtable, level + 1, curr_weight,
             left_weight);
       }
 done: xfree(newtable);
       return;
 }
 
-int wclique(int _n, const int w[], const unsigned char _a[], int ind[])
-{     struct csa _csa, *csa = &_csa;
+int wclique(int n_, const int w[], const unsigned char a_[], int ind[])
+{     struct csa csa_, *csa = &csa_;
       int i, j, p, max_wt, max_nwt, wth, *used, *nwt, *pos;
-      glp_long timer;
-      n = _n;
+      double timer;
+      n = n_;
       xassert(n > 0);
       wt = &w[1];
-      a = _a;
+      a = a_;
       record = 0;
       rec_level = 0;
       rec = &ind[1];
       clique = xcalloc(n, sizeof(int));
       set = xcalloc(n, sizeof(int));
       used = xcalloc(n, sizeof(int));
       nwt = xcalloc(n, sizeof(int));
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnet09.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxnt.c`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnet09.c */
+/* spxnt.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2015 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,222 +15,287 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
+#include "env.h"
+#include "spxnt.h"
 
-#include "glpapi.h"
-#include "glpnet.h"
+/***********************************************************************
+*  spx_alloc_nt - allocate matrix N in sparse row-wise format
+*
+*  This routine allocates the memory for arrays needed to represent the
+*  matrix N composed of non-basic columns of the constraint matrix A. */
+
+void spx_alloc_nt(SPXLP *lp, SPXNT *nt)
+{     int m = lp->m;
+      int nnz = lp->nnz;
+      nt->ptr = talloc(1+m, int);
+      nt->len = talloc(1+m, int);
+      nt->ind = talloc(1+nnz, int);
+      nt->val = talloc(1+nnz, double);
+      return;
+}
 
 /***********************************************************************
-*  NAME
+*  spx_init_nt - initialize row pointers for matrix N
 *
-*  kellerman - cover edges by cliques with Kellerman's heuristic
+*  This routine initializes (sets up) row pointers for the matrix N
+*  using column-wise representation of the constraint matrix A.
 *
-*  SYNOPSIS
-*
-*  #include "glpnet.h"
-*  int kellerman(int n, int (*func)(void *info, int i, int ind[]),
-*     void *info, glp_graph *H);
-*
-*  DESCRIPTION
-*
-*  The routine kellerman implements Kellerman's heuristic algorithm
-*  to find a minimal set of cliques which cover all edges of specified
-*  graph G = (V, E).
-*
-*  The parameter n specifies the number of vertices |V|, n >= 0.
-*
-*  Formal routine func specifies the set of edges E in the following
-*  way. Running the routine kellerman calls the routine func and passes
-*  to it parameter i, which is the number of some vertex, 1 <= i <= n.
-*  In response the routine func should store numbers of all vertices
-*  adjacent to vertex i to locations ind[1], ind[2], ..., ind[len] and
-*  return the value of len, which is the number of adjacent vertices,
-*  0 <= len <= n. Self-loops are allowed, but ignored. Multiple edges
-*  are not allowed.
-*
-*  The parameter info is a transit pointer (magic cookie) passed to the
-*  formal routine func as its first parameter.
-*
-*  The result provided by the routine kellerman is the bipartite graph
-*  H = (V union C, F), which defines the covering found. (The program
-*  object of type glp_graph specified by the parameter H should be
-*  previously created with the routine glp_create_graph. On entry the
-*  routine kellerman erases the content of this object with the routine
-*  glp_erase_graph.) Vertices of first part V correspond to vertices of
-*  the graph G and have the same ordinal numbers 1, 2, ..., n. Vertices
-*  of second part C correspond to cliques and have ordinal numbers
-*  n+1, n+2, ..., n+k, where k is the total number of cliques in the
-*  edge covering found. Every edge f in F in the program object H is
-*  represented as arc f = (i->j), where i in V and j in C, which means
-*  that vertex i of the graph G is in clique C[j], 1 <= j <= k. (Thus,
-*  if two vertices of the graph G are in the same clique, these vertices
-*  are adjacent in G, and corresponding edge is covered by that clique.)
-*
-*  RETURNS
-*
-*  The routine Kellerman returns k, the total number of cliques in the
-*  edge covering found.
-*
-*  REFERENCE
-*
-*  For more details see: glpk/doc/notes/keller.pdf (in Russian). */
-
-struct set
-{     /* set of vertices */
-      int size;
-      /* size (cardinality) of the set, 0 <= card <= n */
-      int *list; /* int list[1+n]; */
-      /* the set contains vertices list[1,...,size] */
-      int *pos; /* int pos[1+n]; */
-      /* pos[i] > 0 means that vertex i is in the set and
-         list[pos[i]] = i; pos[i] = 0 means that vertex i is not in
-         the set */
-};
-
-int kellerman(int n, int (*func)(void *info, int i, int ind[]),
-      void *info, void /* glp_graph */ *H_)
-{     glp_graph *H = H_;
-      struct set W_, *W = &W_, V_, *V = &V_;
-      glp_arc *a;
-      int i, j, k, m, t, len, card, best;
-      xassert(n >= 0);
-      /* H := (V, 0; 0), where V is the set of vertices of graph G */
-      glp_erase_graph(H, H->v_size, H->a_size);
-      glp_add_vertices(H, n);
-      /* W := 0 */
-      W->size = 0;
-      W->list = xcalloc(1+n, sizeof(int));
-      W->pos = xcalloc(1+n, sizeof(int));
-      memset(&W->pos[1], 0, sizeof(int) * n);
-      /* V := 0 */
-      V->size = 0;
-      V->list = xcalloc(1+n, sizeof(int));
-      V->pos = xcalloc(1+n, sizeof(int));
-      memset(&V->pos[1], 0, sizeof(int) * n);
-      /* main loop */
-      for (i = 1; i <= n; i++)
-      {  /* W must be empty */
-         xassert(W->size == 0);
-         /* W := { j : i > j and (i,j) in E } */
-         len = func(info, i, W->list);
-         xassert(0 <= len && len <= n);
-         for (t = 1; t <= len; t++)
-         {  j = W->list[t];
-            xassert(1 <= j && j <= n);
-            if (j >= i) continue;
-            xassert(W->pos[j] == 0);
-            W->list[++W->size] = j, W->pos[j] = W->size;
-         }
-         /* on i-th iteration we need to cover edges (i,j) for all
-            j in W */
-         /* if W is empty, it is a special case */
-         if (W->size == 0)
-         {  /* set k := k + 1 and create new clique C[k] = { i } */
-            k = glp_add_vertices(H, 1) - n;
-            glp_add_arc(H, i, n + k);
-            continue;
-         }
-         /* try to include vertex i into existing cliques */
-         /* V must be empty */
-         xassert(V->size == 0);
-         /* k is the number of cliques found so far */
-         k = H->nv - n;
-         for (m = 1; m <= k; m++)
-         {  /* do while V != W; since here V is within W, we can use
-               equivalent condition: do while |V| < |W| */
-            if (V->size == W->size) break;
-            /* check if C[m] is within W */
-            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)
-            {  j = a->tail->i;
-               if (W->pos[j] == 0) break;
-            }
-            if (a != NULL) continue;
-            /* C[m] is within W, expand clique C[m] with vertex i */
-            /* C[m] := C[m] union {i} */
-            glp_add_arc(H, i, n + m);
-            /* V is a set of vertices whose incident edges are already
-               covered by existing cliques */
-            /* V := V union C[m] */
-            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)
-            {  j = a->tail->i;
-               if (V->pos[j] == 0)
-                  V->list[++V->size] = j, V->pos[j] = V->size;
-            }
-         }
-         /* remove from set W the vertices whose incident edges are
-            already covered by existing cliques */
-         /* W := W \ V, V := 0 */
-         for (t = 1; t <= V->size; t++)
-         {  j = V->list[t], V->pos[j] = 0;
-            if (W->pos[j] != 0)
-            {  /* remove vertex j from W */
-               if (W->pos[j] != W->size)
-               {  int jj = W->list[W->size];
-                  W->list[W->pos[j]] = jj;
-                  W->pos[jj] = W->pos[j];
-               }
-               W->size--, W->pos[j] = 0;
-            }
+*  This routine needs to be called only once. */
+
+void spx_init_nt(SPXLP *lp, SPXNT *nt)
+{     int m = lp->m;
+      int n = lp->n;
+      int nnz = lp->nnz;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      int *NT_ptr = nt->ptr;
+      int *NT_len = nt->len;
+      int i, k, ptr, end;
+      /* calculate NT_len[i] = maximal number of non-zeros in i-th row
+       * of N = number of non-zeros in i-th row of A */
+      memset(&NT_len[1], 0, m * sizeof(int));
+      for (k = 1; k <= n; k++)
+      {  ptr = A_ptr[k];
+         end = A_ptr[k+1];
+         for (; ptr < end; ptr++)
+            NT_len[A_ind[ptr]]++;
+      }
+      /* initialize row pointers NT_ptr[i], i = 1,...,n-m */
+      NT_ptr[1] = 1;
+      for (i = 2; i <= m; i++)
+         NT_ptr[i] = NT_ptr[i-1] + NT_len[i-1];
+      xassert(NT_ptr[m] + NT_len[m] == nnz+1);
+      return;
+}
+
+/***********************************************************************
+*  spx_nt_add_col - add column N[j] = A[k] to matrix N
+*
+*  This routine adds elements of column N[j] = A[k], 1 <= j <= n-m,
+*  1 <= k <= n, to the row-wise represntation of the matrix N. It is
+*  assumed (with no check) that elements of the specified column are
+*  missing in the row-wise represntation of N. */
+
+void spx_nt_add_col(SPXLP *lp, SPXNT *nt, int j, int k)
+{     int m = lp->m;
+      int n = lp->n;
+      int nnz = lp->nnz;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      double *A_val = lp->A_val;
+      int *NT_ptr = nt->ptr;
+      int *NT_len = nt->len;
+      int *NT_ind = nt->ind;
+      double *NT_val = nt->val;
+      int i, ptr, end, pos;
+      xassert(1 <= j && j <= n-m);
+      xassert(1 <= k && k <= n);
+      ptr = A_ptr[k];
+      end = A_ptr[k+1];
+      for (; ptr < end; ptr++)
+      {  i = A_ind[ptr];
+         /* add element N[i,j] = A[i,k] to i-th row of matrix N */
+         pos = NT_ptr[i] + (NT_len[i]++);
+         if (i < m)
+            xassert(pos < NT_ptr[i+1]);
+         else
+            xassert(pos <= nnz);
+         NT_ind[pos] = j;
+         NT_val[pos] = A_val[ptr];
+      }
+      return;
+}
+
+/***********************************************************************
+*  spx_build_nt - build matrix N for current basis
+*
+*  This routine builds the row-wise represntation of the matrix N
+*  for the current basis by adding columns of the constraint matrix A
+*  corresponding to non-basic variables. */
+
+void spx_build_nt(SPXLP *lp, SPXNT *nt)
+{     int m = lp->m;
+      int n = lp->n;
+      int *head = lp->head;
+      int *NT_len = nt->len;
+      int j, k;
+      /* N := 0 */
+      memset(&NT_len[1], 0, m * sizeof(int));
+      /* add non-basic columns N[j] = A[k] */
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         spx_nt_add_col(lp, nt, j, k);
+      }
+      return;
+}
+
+/***********************************************************************
+*  spx_nt_del_col - remove column N[j] = A[k] from matrix N
+*
+*  This routine removes elements of column N[j] = A[k], 1 <= j <= n-m,
+*  1 <= k <= n, from the row-wise representation of the matrix N. It is
+*  assumed (with no check) that elements of the specified column are
+*  present in the row-wise representation of N. */
+
+void spx_nt_del_col(SPXLP *lp, SPXNT *nt, int j, int k)
+{     int m = lp->m;
+      int n = lp->n;
+      int *A_ptr = lp->A_ptr;
+      int *A_ind = lp->A_ind;
+      int *NT_ptr = nt->ptr;
+      int *NT_len = nt->len;
+      int *NT_ind = nt->ind;
+      double *NT_val = nt->val;
+      int i, ptr, end, ptr1, end1;
+      xassert(1 <= j && j <= n-m);
+      xassert(1 <= k && k <= n);
+      ptr = A_ptr[k];
+      end = A_ptr[k+1];
+      for (; ptr < end; ptr++)
+      {  i = A_ind[ptr];
+         /* find element N[i,j] = A[i,k] in i-th row of matrix N */
+         ptr1 = NT_ptr[i];
+         end1 = ptr1 + NT_len[i];
+         for (; NT_ind[ptr1] != j; ptr1++)
+            /* nop */;
+         xassert(ptr1 < end1);
+         /* and remove it from i-th row element list */
+         NT_len[i]--;
+         NT_ind[ptr1] = NT_ind[end1-1];
+         NT_val[ptr1] = NT_val[end1-1];
+      }
+      return;
+}
+
+/***********************************************************************
+*  spx_update_nt - update matrix N for adjacent basis
+*
+*  This routine updates the row-wise represntation of matrix N for
+*  the adjacent basis, where column N[q], 1 <= q <= n-m, is replaced by
+*  column B[p], 1 <= p <= m, of the current basis matrix B. */
+
+void spx_update_nt(SPXLP *lp, SPXNT *nt, int p, int q)
+{     int m = lp->m;
+      int n = lp->n;
+      int *head = lp->head;
+      xassert(1 <= p && p <= m);
+      xassert(1 <= q && q <= n-m);
+      /* remove old column N[q] corresponding to variable xN[q] */
+      spx_nt_del_col(lp, nt, q, head[m+q]);
+      /* add new column N[q] corresponding to variable xB[p] */
+      spx_nt_add_col(lp, nt, q, head[p]);
+      return;
+}
+
+/***********************************************************************
+*  spx_nt_prod - compute product y := y + s * N'* x
+*
+*  This routine computes the product:
+*
+*     y := y + s * N'* x,
+*
+*  where N' is a matrix transposed to the mx(n-m)-matrix N composed
+*  from non-basic columns of the constraint matrix A, x is a m-vector,
+*  s is a scalar, y is (n-m)-vector.
+*
+*  If the flag ign is non-zero, the routine ignores the input content
+*  of the array y assuming that y = 0.
+*
+*  The routine uses the row-wise representation of the matrix N and
+*  computes the product as a linear combination:
+*
+*     y := y + s * (N'[1] * x[1] + ... + N'[m] * x[m]),
+*
+*  where N'[i] is i-th row of N, 1 <= i <= m. */
+
+void spx_nt_prod(SPXLP *lp, SPXNT *nt, double y[/*1+n-m*/], int ign,
+      double s, const double x[/*1+m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      int *NT_ptr = nt->ptr;
+      int *NT_len = nt->len;
+      int *NT_ind = nt->ind;
+      double *NT_val = nt->val;
+      int i, j, ptr, end;
+      double t;
+      if (ign)
+      {  /* y := 0 */
+         for (j = 1; j <= n-m; j++)
+            y[j] = 0.0;
+      }
+      for (i = 1; i <= m; i++)
+      {  if (x[i] != 0.0)
+         {  /* y := y + s * (i-th row of N) * x[i] */
+            t = s * x[i];
+            ptr = NT_ptr[i];
+            end = ptr + NT_len[i];
+            for (; ptr < end; ptr++)
+               y[NT_ind[ptr]] += NT_val[ptr] * t;
          }
-         V->size = 0;
-         /* now set W contains only vertices whose incident edges are
-            still not covered by existing cliques; create new cliques
-            to cover remaining edges until set W becomes empty */
-         while (W->size > 0)
-         {  /* find clique C[m], 1 <= m <= k, which shares maximal
-               number of vertices with W; to break ties choose clique
-               having smallest number m */
-            m = 0, best = -1;
-            k = H->nv - n;
-            for (t = 1; t <= k; t++)
-            {  /* compute cardinality of intersection of W and C[t] */
-               card = 0;
-               for (a = H->v[n + t]->in; a != NULL; a = a->h_next)
-               {  j = a->tail->i;
-                  if (W->pos[j] != 0) card++;
-               }
-               if (best < card)
-                  m = t, best = card;
-            }
-            xassert(m > 0);
-            /* set k := k + 1 and create new clique:
-               C[k] := (W intersect C[m]) union { i }, which covers all
-               edges incident to vertices from (W intersect C[m]) */
-            k = glp_add_vertices(H, 1) - n;
-            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)
-            {  j = a->tail->i;
-               if (W->pos[j] != 0)
-               {  /* vertex j is in both W and C[m]; include it in new
-                     clique C[k] */
-                  glp_add_arc(H, j, n + k);
-                  /* remove vertex j from W, since edge (i,j) will be
-                     covered by new clique C[k] */
-                  if (W->pos[j] != W->size)
-                  {  int jj = W->list[W->size];
-                     W->list[W->pos[j]] = jj;
-                     W->pos[jj] = W->pos[j];
-                  }
-                  W->size--, W->pos[j] = 0;
-               }
-            }
-            /* include vertex i to new clique C[k] to cover edges (i,j)
-               incident to all vertices j just removed from W */
-            glp_add_arc(H, i, n + k);
+      }
+      return;
+}
+
+#if 1 /* 31/III-2016 */
+void spx_nt_prod_s(SPXLP *lp, SPXNT *nt, FVS *y, int ign, double s,
+      const FVS *x, double eps)
+{     /* sparse version of spx_nt_prod */
+      int *NT_ptr = nt->ptr;
+      int *NT_len = nt->len;
+      int *NT_ind = nt->ind;
+      double *NT_val = nt->val;
+      int *x_ind = x->ind;
+      double *x_vec = x->vec;
+      int *y_ind = y->ind;
+      double *y_vec = y->vec;
+      int i, j, k, nnz, ptr, end;
+      double t;
+      xassert(x->n == lp->m);
+      xassert(y->n == lp->n-lp->m);
+      if (ign)
+      {  /* y := 0 */
+         fvs_clear_vec(y);
+      }
+      nnz = y->nnz;
+      for (k = x->nnz; k >= 1; k--)
+      {  i = x_ind[k];
+         /* y := y + s * (i-th row of N) * x[i] */
+         t = s * x_vec[i];
+         ptr = NT_ptr[i];
+         end = ptr + NT_len[i];
+         for (; ptr < end; ptr++)
+         {  j = NT_ind[ptr];
+            if (y_vec[j] == 0.0)
+               y_ind[++nnz] = j;
+            y_vec[j] += NT_val[ptr] * t;
+            /* don't forget about numeric cancellation */
+            if (y_vec[j] == 0.0)
+               y_vec[j] = DBL_MIN;
          }
       }
-      /* free working arrays */
-      xfree(W->list);
-      xfree(W->pos);
-      xfree(V->list);
-      xfree(V->pos);
-      /* return the number of cliques in the edge covering found */
-      return H->nv - n;
+      y->nnz = nnz;
+      fvs_adjust_vec(y, eps);
+      return;
+}
+#endif
+
+/***********************************************************************
+*  spx_free_nt - deallocate matrix N in sparse row-wise format
+*
+*  This routine deallocates the memory used for arrays of the program
+*  object nt. */
+
+void spx_free_nt(SPXLP *lp, SPXNT *nt)
+{     xassert(lp == lp);
+      tfree(nt->ptr);
+      tfree(nt->len);
+      tfree(nt->ind);
+      tfree(nt->val);
+      return;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp.h`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnpp.h (LP/MIP preprocessor) */
+/* npp.h (LP/MIP preprocessor) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,27 +15,35 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPNPP_H
-#define GLPNPP_H
+#ifndef NPP_H
+#define NPP_H
 
-#include "glpapi.h"
+#include "prob.h"
 
+#if 0 /* 20/XI-2017 */
 typedef struct NPP NPP;
+#else
+typedef struct glp_prep NPP;
+#endif
 typedef struct NPPROW NPPROW;
 typedef struct NPPCOL NPPCOL;
 typedef struct NPPAIJ NPPAIJ;
 typedef struct NPPTSE NPPTSE;
 typedef struct NPPLFE NPPLFE;
 
+#if 0 /* 20/XI-2017 */
 struct NPP
+#else
+struct glp_prep
+#endif
 {     /* LP/MIP preprocessor workspace */
       /*--------------------------------------------------------------*/
       /* original problem segment */
       int orig_dir;
       /* optimization direction flag:
          GLP_MIN - minimization
          GLP_MAX - maximization */
@@ -511,10 +516,128 @@
 int npp_simplex(NPP *npp, const glp_smcp *parm);
 /* process LP prior to applying primal/dual simplex method */
 
 #define npp_integer _glp_npp_integer
 int npp_integer(NPP *npp, const glp_iocp *parm);
 /* process MIP prior to applying branch-and-bound method */
 
+/**********************************************************************/
+
+#define npp_sat_free_row _glp_npp_sat_free_row
+void npp_sat_free_row(NPP *npp, NPPROW *p);
+/* process free (unbounded) row */
+
+#define npp_sat_fixed_col _glp_npp_sat_fixed_col
+int npp_sat_fixed_col(NPP *npp, NPPCOL *q);
+/* process fixed column */
+
+#define npp_sat_is_bin_comb _glp_npp_sat_is_bin_comb
+int npp_sat_is_bin_comb(NPP *npp, NPPROW *row);
+/* test if row is binary combination */
+
+#define npp_sat_num_pos_coef _glp_npp_sat_num_pos_coef
+int npp_sat_num_pos_coef(NPP *npp, NPPROW *row);
+/* determine number of positive coefficients */
+
+#define npp_sat_num_neg_coef _glp_npp_sat_num_neg_coef
+int npp_sat_num_neg_coef(NPP *npp, NPPROW *row);
+/* determine number of negative coefficients */
+
+#define npp_sat_is_cover_ineq _glp_npp_sat_is_cover_ineq
+int npp_sat_is_cover_ineq(NPP *npp, NPPROW *row);
+/* test if row is covering inequality */
+
+#define npp_sat_is_pack_ineq _glp_npp_sat_is_pack_ineq
+int npp_sat_is_pack_ineq(NPP *npp, NPPROW *row);
+/* test if row is packing inequality */
+
+#define npp_sat_is_partn_eq _glp_npp_sat_is_partn_eq
+int npp_sat_is_partn_eq(NPP *npp, NPPROW *row);
+/* test if row is partitioning equality */
+
+#define npp_sat_reverse_row _glp_npp_sat_reverse_row
+int npp_sat_reverse_row(NPP *npp, NPPROW *row);
+/* multiply both sides of row by -1 */
+
+#define npp_sat_split_pack _glp_npp_sat_split_pack
+NPPROW *npp_sat_split_pack(NPP *npp, NPPROW *row, int nnn);
+/* split packing inequality */
+
+#define npp_sat_encode_pack _glp_npp_sat_encode_pack
+void npp_sat_encode_pack(NPP *npp, NPPROW *row);
+/* encode packing inequality */
+
+typedef struct NPPLIT NPPLIT;
+typedef struct NPPLSE NPPLSE;
+typedef struct NPPSED NPPSED;
+
+struct NPPLIT
+{     /* literal (binary variable or its negation) */
+      NPPCOL *col;
+      /* pointer to binary variable; NULL means constant false */
+      int neg;
+      /* negation flag:
+         0 - literal is variable (or constant false)
+         1 - literal is negation of variable (or constant true) */
+};
+
+struct NPPLSE
+{     /* literal set element */
+      NPPLIT lit;
+      /* literal */
+      NPPLSE *next;
+      /* pointer to another element */
+};
+
+struct NPPSED
+{     /* summation encoding descriptor */
+      /* this struct describes the equality
+            x + y + z = s + 2 * c,
+         which was encoded as CNF and included into the transformed
+         problem; here x and y are literals, z is either a literal or
+         constant zero, s and c are binary variables modeling, resp.,
+         the low and high (carry) sum bits */
+      NPPLIT x, y, z;
+      /* literals; if z.col = NULL, z is constant zero */
+      NPPCOL *s, *c;
+      /* binary variables modeling the sum bits */
+};
+
+#define npp_sat_encode_sum2 _glp_npp_sat_encode_sum2
+void npp_sat_encode_sum2(NPP *npp, NPPLSE *set, NPPSED *sed);
+/* encode 2-bit summation */
+
+#define npp_sat_encode_sum3 _glp_npp_sat_encode_sum3
+void npp_sat_encode_sum3(NPP *npp, NPPLSE *set, NPPSED *sed);
+/* encode 3-bit summation */
+
+#define npp_sat_encode_sum_ax _glp_npp_sat_encode_sum_ax
+int npp_sat_encode_sum_ax(NPP *npp, NPPROW *row, NPPLIT y[]);
+/* encode linear combination of 0-1 variables */
+
+#define npp_sat_normalize_clause _glp_npp_sat_normalize_clause
+int npp_sat_normalize_clause(NPP *npp, int size, NPPLIT lit[]);
+/* normalize clause */
+
+#define npp_sat_encode_clause _glp_npp_sat_encode_clause
+NPPROW *npp_sat_encode_clause(NPP *npp, int size, NPPLIT lit[]);
+/* translate clause to cover inequality */
+
+#define npp_sat_encode_geq _glp_npp_sat_encode_geq
+int npp_sat_encode_geq(NPP *npp, int n, NPPLIT y[], int rhs);
+/* encode "not less than" constraint */
+
+#define npp_sat_encode_leq _glp_npp_sat_encode_leq
+int npp_sat_encode_leq(NPP *npp, int n, NPPLIT y[], int rhs);
+/* encode "not greater than" constraint */
+
+#define npp_sat_encode_row _glp_npp_sat_encode_row
+int npp_sat_encode_row(NPP *npp, NPPROW *row);
+/* encode constraint (row) of general type */
+
+#define npp_sat_encode_prob _glp_npp_sat_encode_prob
+int npp_sat_encode_prob(NPP *npp);
+/* encode 0-1 feasibility problem */
+
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp1.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnpp01.c */
+/* npp1.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wshorten-64-to-32"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#include "glpnpp.h"
+#include "env.h"
+#include "npp.h"
 
 NPP *npp_create_wksp(void)
 {     /* create LP/MIP preprocessor workspace */
       NPP *npp;
       npp = xmalloc(sizeof(NPP));
       npp->orig_dir = 0;
       npp->orig_m = npp->orig_n = npp->orig_nnz = 0;
@@ -585,17 +578,27 @@
       xassert(npp->orig_dir == prob->dir);
       if (npp->orig_dir == GLP_MIN)
          dir = +1.0;
       else if (npp->orig_dir == GLP_MAX)
          dir = -1.0;
       else
          xassert(npp != npp);
+#if 0 /* 11/VII-2013; due to call from ios_main */
       xassert(npp->m == prob->m);
+#else
+      if (npp->sol != GLP_MIP)
+         xassert(npp->m == prob->m);
+#endif
       xassert(npp->n == prob->n);
+#if 0 /* 11/VII-2013; due to call from ios_main */
       xassert(npp->nnz == prob->nnz);
+#else
+      if (npp->sol != GLP_MIP)
+         xassert(npp->nnz == prob->nnz);
+#endif
       /* copy solution status */
       if (npp->sol == GLP_SOL)
       {  npp->p_stat = prob->pbs_stat;
          npp->d_stat = prob->dbs_stat;
       }
       else if (npp->sol == GLP_IPT)
          npp->t_stat = prob->ipt_stat;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp2.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnpp02.c */
+/* npp2.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpnpp.h"
+#include "env.h"
+#include "npp.h"
 
 /***********************************************************************
 *  NAME
 *
 *  npp_free_row - process free (unbounded) row
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp03.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp3.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnpp03.c */
+/* npp3.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,19 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#endif
-
-#include "glpnpp.h"
+#include "env.h"
+#include "npp.h"
 
 /***********************************************************************
 *  NAME
 *
 *  npp_empty_row - process empty row
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp04.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp4.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnpp04.c */
+/* npp4.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wsometimes-uninitialized"
-#endif
-
-#include "glpnpp.h"
+#include "env.h"
+#include "npp.h"
 
 /***********************************************************************
 *  NAME
 *
 *  npp_binarize_prob - binarize MIP problem
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpnpp05.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/npp/npp5.c`

 * *Files 0% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpnpp05.c */
+/* npp5.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2009-2017 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpnpp.h"
+#include "env.h"
+#include "npp.h"
 
 /***********************************************************************
 *  NAME
 *
 *  npp_clean_prob - perform initial LP/MIP processing
 *
 *  SYNOPSIS
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpqmd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spychuzr.c`

 * *Files 25% similar despite different names*

```diff
@@ -1,23 +1,13 @@
-/* glpqmd.c (quotient minimum degree algorithm) */
+/* spychuzr.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  THIS CODE IS THE RESULT OF TRANSLATION OF THE FORTRAN SUBROUTINES
-*  GENQMD, QMDRCH, QMDQT, QMDUPD, AND QMDMRG FROM THE BOOK:
-*
-*  ALAN GEORGE, JOSEPH W-H LIU. COMPUTER SOLUTION OF LARGE SPARSE
-*  POSITIVE DEFINITE SYSTEMS. PRENTICE-HALL, 1981.
-*
-*  THE TRANSLATION HAS BEEN DONE WITH THE PERMISSION OF THE AUTHORS
-*  OF THE ORIGINAL FORTRAN SUBROUTINES: ALAN GEORGE AND JOSEPH LIU,
-*  UNIVERSITY OF WATERLOO, WATERLOO, ONTARIO, CANADA.
-*
-*  The translation was made by Andrew Makhorin <mao@gnu.org>.
+*  Copyright (C) 2015 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -25,560 +15,467 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpqmd.h"
+#include "env.h"
+#include "spychuzr.h"
 
 /***********************************************************************
-*  NAME
-*
-*  genqmd - GENeral Quotient Minimum Degree algorithm
-*
-*  SYNOPSIS
+*  spy_chuzr_sel - select eligible basic variables
 *
-*  #include "glpqmd.h"
-*  void genqmd(int *neqns, int xadj[], int adjncy[], int perm[],
-*     int invp[], int deg[], int marker[], int rchset[], int nbrhd[],
-*     int qsize[], int qlink[], int *nofsub);
+*  This routine selects eligible basic variables xB[i], whose value
+*  beta[i] violates corresponding lower lB[i] or upper uB[i] bound.
+*  Positive bound violation rp[i] = lb[i] - beta[i] > 0 is the reduced
+*  cost of non-basic dual variable lambda^+B[i] >= 0, so increasing it
+*  increases the dual objective. Similarly, negative bound violation
+*  rn[i] = ub[i] - beta[i] < 0 is the reduced cost of non-basic dual
+*  variable lambda^-B[i] <= 0, so decreasing it also increases the dual
+*  objective.
 *
-*  PURPOSE
+*  Current values of basic variables should be placed in the array
+*  locations beta[1], ..., beta[m].
 *
-*  This routine implements the minimum degree algorithm. It makes use
-*  of the implicit representation of the elimination graph by quotient
-*  graphs, and the notion of indistinguishable nodes.
+*  Basic variable xB[i] is considered eligible, if:
 *
-*  CAUTION
+*     beta[i] <= lB[i] - eps1[i], or
 *
-*  The adjancy vector adjncy will be destroyed.
+*     beta[i] >= uB[i] + eps2[i],
 *
-*  INPUT PARAMETERS
+*  for
 *
-*  neqns  - number of equations;
-*  (xadj, adjncy) -
-*           the adjancy structure.
+*     eps1[i] = tol + tol1 * |lB[i]|,
 *
-*  OUTPUT PARAMETERS
+*     eps2[i] = tol + tol2 * |uB[i]|,
 *
-*  perm   - the minimum degree ordering;
-*  invp   - the inverse of perm.
+*  where lB[i] and uB[i] are, resp., lower and upper bounds of xB[i],
+*  tol and tol1 are specified tolerances.
 *
-*  WORKING PARAMETERS
-*
-*  deg    - the degree vector. deg[i] is negative means node i has been
-*           numbered;
-*  marker - a marker vector, where marker[i] is negative means node i
-*           has been merged with another nodeand thus can be ignored;
-*  rchset - vector used for the reachable set;
-*  nbrhd  - vector used for neighborhood set;
-*  qsize  - vector used to store the size of indistinguishable
-*           supernodes;
-*  qlink  - vector used to store indistinguishable nodes, i, qlink[i],
-*           qlink[qlink[i]], ... are the members of the supernode
-*           represented by i.
-*
-*  PROGRAM SUBROUTINES
-*
-*  qmdrch, qmdqt, qmdupd.
-***********************************************************************/
+*  On exit the routine stores indices i of eligible basic variables
+*  xB[i] to the array locations list[1], ..., list[num] and returns the
+*  number of such variables 0 <= num <= m. (If the parameter list is
+*  specified as NULL, no indices are stored.) */
 
-void genqmd(int *_neqns, int xadj[], int adjncy[], int perm[],
-      int invp[], int deg[], int marker[], int rchset[], int nbrhd[],
-      int qsize[], int qlink[], int *_nofsub)
-{     int inode, ip, irch, j, mindeg, ndeg, nhdsze, node, np, num,
-         nump1, nxnode, rchsze, search, thresh;
-#     define neqns  (*_neqns)
-#     define nofsub (*_nofsub)
-      /* Initialize degree vector and other working variables. */
-      mindeg = neqns;
-      nofsub = 0;
-      for (node = 1; node <= neqns; node++)
-      {  perm[node] = node;
-         invp[node] = node;
-         marker[node] = 0;
-         qsize[node] = 1;
-         qlink[node] = 0;
-         ndeg = xadj[node+1] - xadj[node];
-         deg[node] = ndeg;
-         if (ndeg < mindeg) mindeg = ndeg;
-      }
+int spy_chuzr_sel(SPXLP *lp, const double beta[/*1+m*/], double tol,
+      double tol1, int list[/*1+m*/])
+{     int m = lp->m;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      int i, k, num;
+      double lk, uk, eps;
       num = 0;
-      /* Perform threshold search to get a node of min degree.
-         Variable search point to where search should start. */
-s200: search = 1;
-      thresh = mindeg;
-      mindeg = neqns;
-s300: nump1 = num + 1;
-      if (nump1 > search) search = nump1;
-      for (j = search; j <= neqns; j++)
-      {  node = perm[j];
-         if (marker[node] >= 0)
-         {  ndeg = deg[node];
-            if (ndeg <= thresh) goto s500;
-            if (ndeg < mindeg) mindeg = ndeg;
-         }
-      }
-      goto s200;
-      /* Node has minimum degree. Find its reachable sets by calling
-         qmdrch. */
-s500: search = j;
-      nofsub += deg[node];
-      marker[node] = 1;
-      qmdrch(&node, xadj, adjncy, deg, marker, &rchsze, rchset, &nhdsze,
-         nbrhd);
-      /* Eliminate all nodes indistinguishable from node. They are given
-         by node, qlink[node], ... . */
-      nxnode = node;
-s600: num++;
-      np = invp[nxnode];
-      ip = perm[num];
-      perm[np] = ip;
-      invp[ip] = np;
-      perm[num] = nxnode;
-      invp[nxnode] = num;
-      deg[nxnode] = -1;
-      nxnode = qlink[nxnode];
-      if (nxnode > 0) goto s600;
-      if (rchsze > 0)
-      {  /* Update the degrees of the nodes in the reachable set and
-            identify indistinguishable nodes. */
-         qmdupd(xadj, adjncy, &rchsze, rchset, deg, qsize, qlink,
-            marker, &rchset[rchsze+1], &nbrhd[nhdsze+1]);
-         /* Reset marker value of nodes in reach set. Update threshold
-            value for cyclic search. Also call qmdqt to form new
-            quotient graph. */
-         marker[node] = 0;
-         for (irch = 1; irch <= rchsze; irch++)
-         {  inode = rchset[irch];
-            if (marker[inode] >= 0)
-            {  marker[inode] = 0;
-               ndeg = deg[inode];
-               if (ndeg < mindeg) mindeg = ndeg;
-               if (ndeg <= thresh)
-               {  mindeg = thresh;
-                  thresh = ndeg;
-                  search = invp[inode];
-               }
+      /* walk thru list of basic variables */
+      for (i = 1; i <= m; i++)
+      {  k = head[i]; /* x[k] = xB[i] */
+         lk = l[k], uk = u[k];
+         /* check if xB[i] is eligible */
+         if (beta[i] < lk)
+         {  /* determine absolute tolerance eps1[i] */
+            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);
+            if (beta[i] < lk - eps)
+            {  /* lower bound is violated */
+               num++;
+               if (list != NULL)
+                  list[num] = i;
+            }
+         }
+         else if (beta[i] > uk)
+         {  /* determine absolute tolerance eps2[i] */
+            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);
+            if (beta[i] > uk + eps)
+            {  /* upper bound is violated */
+               num++;
+               if (list != NULL)
+                  list[num] = i;
             }
          }
-         if (nhdsze > 0)
-            qmdqt(&node, xadj, adjncy, marker, &rchsze, rchset, nbrhd);
       }
-      if (num < neqns) goto s300;
-      return;
-#     undef neqns
-#     undef nofsub
+      return num;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  qmdrch - Quotient MD ReaCHable set
-*
-*  SYNOPSIS
-*
-*  #include "glpqmd.h"
-*  void qmdrch(int *root, int xadj[], int adjncy[], int deg[],
-*     int marker[], int *rchsze, int rchset[], int *nhdsze,
-*     int nbrhd[]);
-*
-*  PURPOSE
+*  spy_chuzr_std - choose basic variable (dual Dantzig's rule)
 *
-*  This subroutine determines the reachable set of a node through a
-*  given subset. The adjancy structure is assumed to be stored in a
-*  quotient graph format.
-* 
-*  INPUT PARAMETERS
+*  This routine chooses most eligible basic variable xB[p] according
+*  to dual Dantzig's ("standard") rule:
 *
-*  root   - the given node not in the subset;
-*  (xadj, adjncy) -
-*           the adjancy structure pair;
-*  deg    - the degree vector. deg[i] < 0 means the node belongs to the
-*           given subset.
+*     r[p] =   max  |r[i]|,
+*            i in I
 *
-*  OUTPUT PARAMETERS
-*
-*  (rchsze, rchset) -
-*           the reachable set;
-*  (nhdsze, nbrhd) -
-*           the neighborhood set.
-*
-*  UPDATED PARAMETERS
+*            ( lB[i] - beta[i], if beta[i] < lB[i]
+*            (
+*     r[i] = { 0,               if lB[i] <= beta[i] <= uB[i]
+*            (
+*            ( uB[i] - beta[i], if beta[i] > uB[i]
+*
+*  where I <= {1, ..., m} is the set of indices of eligible basic
+*  variables, beta[i] is current value of xB[i], lB[i] and uB[i] are,
+*  resp., lower and upper bounds of xB[i], r[i] is bound violation.
+*
+*  Current values of basic variables should be placed in the array
+*  locations beta[1], ..., beta[m].
+*
+*  Indices of eligible basic variables i in I should be placed in the
+*  array locations list[1], ..., list[num], where num = |J| > 0 is the
+*  total number of such variables.
+*
+*  On exit the routine returns p, the index of the basic variable xB[p]
+*  chosen. */
+
+int spy_chuzr_std(SPXLP *lp, const double beta[/*1+m*/], int num,
+      const int list[])
+{     int m = lp->m;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      int i, k, p, t;
+      double abs_ri, abs_rp;
+      xassert(0 < num && num <= m);
+      p = 0, abs_rp = -1.0;
+      for (t = 1; t <= num; t++)
+      {  i = list[t];
+         k = head[i]; /* x[k] = xB[i] */
+         if (beta[i] < l[k])
+            abs_ri = l[k] - beta[i];
+         else if (beta[i] > u[k])
+            abs_ri = beta[i] - u[k];
+         else
+            xassert(t != t);
+         if (abs_rp < abs_ri)
+            p = i, abs_rp = abs_ri;
+      }
+      xassert(p != 0);
+      return p;
+}
+
+/***********************************************************************
+*  spy_alloc_se - allocate dual pricing data block
 *
-*  marker - the marker vector for reach and nbrhd sets. > 0 means the
-*           node is in reach set. < 0 means the node has been merged
-*           with others in the quotient or it is in nbrhd set.
-***********************************************************************/
+*  This routine allocates the memory for arrays used in the dual
+*  pricing data block. */
 
-void qmdrch(int *_root, int xadj[], int adjncy[], int deg[],
-      int marker[], int *_rchsze, int rchset[], int *_nhdsze,
-      int nbrhd[])
-{     int i, istop, istrt, j, jstop, jstrt, nabor, node;
-#     define root   (*_root)
-#     define rchsze (*_rchsze)
-#     define nhdsze (*_nhdsze)
-      /* Loop through the neighbors of root in the quotient graph. */
-      nhdsze = 0;
-      rchsze = 0;
-      istrt = xadj[root];
-      istop = xadj[root+1] - 1;
-      if (istop < istrt) return;
-      for (i = istrt; i <= istop; i++)
-      {  nabor = adjncy[i];
-         if (nabor == 0) return;
-         if (marker[nabor] == 0)
-         {  if (deg[nabor] >= 0)
-            {  /* Include nabor into the reachable set. */
-               rchsze++;
-               rchset[rchsze] = nabor;
-               marker[nabor] = 1;
-               goto s600;
-            }
-            /* nabor has been eliminated. Find nodes reachable from
-               it. */
-            marker[nabor] = -1;
-            nhdsze++;
-            nbrhd[nhdsze] = nabor;
-s300:       jstrt = xadj[nabor];
-            jstop = xadj[nabor+1] - 1;
-            for (j = jstrt; j <= jstop; j++)
-            {  node = adjncy[j];
-               nabor = - node;
-               if (node < 0) goto s300;
-               if (node == 0) goto s600;
-               if (marker[node] == 0)
-               {  rchsze++;
-                  rchset[rchsze] = node;
-                  marker[node] = 1;
-               }
-            }
-         }
-s600:    ;
-      }
+void spy_alloc_se(SPXLP *lp, SPYSE *se)
+{     int m = lp->m;
+      int n = lp->n;
+#if 1 /* 30/III-2016 */
+      int i;
+#endif
+      se->valid = 0;
+      se->refsp = talloc(1+n, char);
+      se->gamma = talloc(1+m, double);
+      se->work = talloc(1+m, double);
+#if 1 /* 30/III-2016 */
+      se->u.n = m;
+      se->u.nnz = 0;
+      se->u.ind = talloc(1+m, int);
+      se->u.vec = talloc(1+m, double);
+      for (i = 1; i <= m; i++)
+         se->u.vec[i] = 0.0;
+#endif
       return;
-#     undef root
-#     undef rchsze
-#     undef nhdsze
 }
 
 /***********************************************************************
-*  NAME
-*
-*  qmdqt - Quotient MD Quotient graph Transformation
-*
-*  SYNOPSIS
-*
-*  #include "glpqmd.h"
-*  void qmdqt(int *root, int xadj[], int adjncy[], int marker[],
-*     int *rchsze, int rchset[], int nbrhd[]);
-*
-*  PURPOSE
-*
-*  This subroutine performs the quotient graph transformation after a
-*  node has been eliminated.
-*
-*  INPUT PARAMETERS
+*  spy_reset_refsp - reset dual reference space
 *
-*  root   - the node just eliminated. It becomes the representative of
-*           the new supernode;
-*  (xadj, adjncy) -
-*           the adjancy structure;
-*  (rchsze, rchset) -
-*           the reachable set of root in the old quotient graph;
-*  nbrhd  - the neighborhood set which will be merged with root to form
-*           the new supernode;
-*  marker - the marker vector.
-*
-*  UPDATED PARAMETERS
-*
-*  adjncy - becomes the adjncy of the quotient graph.
-***********************************************************************/
-
-void qmdqt(int *_root, int xadj[], int adjncy[], int marker[],
-      int *_rchsze, int rchset[], int nbrhd[])
-{     int inhd, irch, j, jstop, jstrt, link, nabor, node;
-#     define root   (*_root)
-#     define rchsze (*_rchsze)
-      irch = 0;
-      inhd = 0;
-      node = root;
-s100: jstrt = xadj[node];
-      jstop = xadj[node+1] - 2;
-      if (jstop >= jstrt)
-      {  /* Place reach nodes into the adjacent list of node. */
-         for (j = jstrt; j <= jstop; j++)
-         {  irch++;
-            adjncy[j] = rchset[irch];
-            if (irch >= rchsze) goto s400;
-         }
-      }
-      /* Link to other space provided by the nbrhd set. */
-      link = adjncy[jstop+1];
-      node = - link;
-      if (link >= 0)
-      {  inhd++;
-         node = nbrhd[inhd];
-         adjncy[jstop+1] = - node;
-      }
-      goto s100;
-      /* All reachable nodes have been saved. End the adjacent list.
-         Add root to the neighborhood list of each node in the reach
-         set. */
-s400: adjncy[j+1] = 0;
-      for (irch = 1; irch <= rchsze; irch++)
-      {  node = rchset[irch];
-         if (marker[node] >= 0)
-         {  jstrt = xadj[node];
-            jstop = xadj[node+1] - 1;
-            for (j = jstrt; j <= jstop; j++)
-            {  nabor = adjncy[j];
-               if (marker[nabor] < 0)
-               {  adjncy[j] = root;
-                  goto s600;
-               }
-            }
-         }
-s600:    ;
+*  This routine resets (re-initializes) the dual reference space
+*  composing it from dual variables which are non-basic (corresponding
+*  to basic primal variables) in the current basis, and sets all
+*  weights gamma[i] to 1. */
+
+void spy_reset_refsp(SPXLP *lp, SPYSE *se)
+{     int m = lp->m;
+      int n = lp->n;
+      int *head = lp->head;
+      char *refsp = se->refsp;
+      double *gamma = se->gamma;
+      int i, k;
+      se->valid = 1;
+      memset(&refsp[1], 0, n * sizeof(char));
+      for (i = 1; i <= m; i++)
+      {  k = head[i]; /* x[k] = xB[i] */
+         refsp[k] = 1;
+         gamma[i] = 1.0;
       }
       return;
-#     undef root
-#     undef rchsze
 }
 
 /***********************************************************************
-*  NAME
-*
-*  qmdupd - Quotient MD UPDate
-*
-*  SYNOPSIS
+*  spy_eval_gamma_i - compute dual proj. steepest edge weight directly
 *
-*  #include "glpqmd.h"
-*  void qmdupd(int xadj[], int adjncy[], int *nlist, int list[],
-*     int deg[], int qsize[], int qlink[], int marker[], int rchset[],
-*     int nbrhd[]);
+*  This routine computes dual projected steepest edge weight gamma[i],
+*  1 <= i <= m, for the current basis directly with the formula:
 *
-*  PURPOSE
-*
-*  This routine performs degree update for a set of nodes in the minimum
-*  degree algorithm.
-*
-*  INPUT PARAMETERS
-*
-*  (xadj, adjncy) -
-*           the adjancy structure;
-*  (nlist, list) -
-*           the list of nodes whose degree has to be updated.
-*
-*  UPDATED PARAMETERS
-*
-*  deg    - the degree vector;
-*  qsize  - size of indistinguishable supernodes;
-*  qlink  - linked list for indistinguishable nodes;
-*  marker - used to mark those nodes in reach/nbrhd sets.
-*
-*  WORKING PARAMETERS
-*
-*  rchset - the reachable set;
-*  nbrhd  - the neighborhood set.
-*
-*  PROGRAM SUBROUTINES
-*
-*  qmdmrg.
-***********************************************************************/
-
-void qmdupd(int xadj[], int adjncy[], int *_nlist, int list[],
-      int deg[], int qsize[], int qlink[], int marker[], int rchset[],
-      int nbrhd[])
-{     int deg0, deg1, il, inhd, inode, irch, j, jstop, jstrt, mark,
-         nabor, nhdsze, node, rchsze;
-#     define nlist  (*_nlist)
-      /* Find all eliminated supernodes that are adjacent to some nodes
-         in the given list. Put them into (nhdsze, nbrhd). deg0 contains
-         the number of nodes in the list. */
-      if (nlist <= 0) return;
-      deg0 = 0;
-      nhdsze = 0;
-      for (il = 1; il <= nlist; il++)
-      {  node = list[il];
-         deg0 += qsize[node];
-         jstrt = xadj[node];
-         jstop = xadj[node+1] - 1;
-         for (j = jstrt; j <= jstop; j++)
-         {  nabor = adjncy[j];
-            if (marker[nabor] == 0 && deg[nabor] < 0)
-            {  marker[nabor] = -1;
-               nhdsze++;
-               nbrhd[nhdsze] = nabor;
-            }
+*                           n-m
+*     gamma[i] = delta[i] + sum eta[j] * T[i,j]**2,
+*                           j=1
+*
+*  where T[i,j] is element of the current simplex table, and
+*
+*                ( 1, if lambdaN[j] is in the reference space
+*     eta[j]   = {
+*                ( 0, otherwise
+*
+*                ( 1, if lambdaB[i] is in the reference space
+*     delta[i] = {
+*                ( 0, otherwise
+*
+*  Dual basic variable lambdaN[j] corresponds to primal non-basic
+*  variable xN[j], and dual non-basic variable lambdaB[j] corresponds
+*  to primal basic variable xB[i].
+*
+*  NOTE: For testing/debugging only. */
+
+double spy_eval_gamma_i(SPXLP *lp, SPYSE *se, int i)
+{     int m = lp->m;
+      int n = lp->n;
+      int *head = lp->head;
+      char *refsp = se->refsp;
+      double *rho = se->work;
+      int j, k;
+      double gamma_i, t_ij;
+      xassert(se->valid);
+      xassert(1 <= i && i <= m);
+      k = head[i]; /* x[k] = xB[i] */
+      gamma_i = (refsp[k] ? 1.0 : 0.0);
+      spx_eval_rho(lp, i, rho);
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         if (refsp[k])
+         {  t_ij = spx_eval_tij(lp, rho, j);
+            gamma_i += t_ij * t_ij;
          }
       }
-      /* Merge indistinguishable nodes in the list by calling the
-         subroutine qmdmrg. */
-      if (nhdsze > 0)
-         qmdmrg(xadj, adjncy, deg, qsize, qlink, marker, &deg0, &nhdsze,
-            nbrhd, rchset, &nbrhd[nhdsze+1]);
-      /* Find the new degrees of the nodes that have not been merged. */
-      for (il = 1; il <= nlist; il++)
-      {  node = list[il];
-         mark = marker[node];
-         if (mark == 0 || mark == 1)
-         {  marker[node] = 2;
-            qmdrch(&node, xadj, adjncy, deg, marker, &rchsze, rchset,
-               &nhdsze, nbrhd);
-            deg1 = deg0;
-            if (rchsze > 0)
-            {  for (irch = 1; irch <= rchsze; irch++)
-               {  inode = rchset[irch];
-                  deg1 += qsize[inode];
-                  marker[inode] = 0;
-               }
-            }
-            deg[node] = deg1 - 1;
-            if (nhdsze > 0)
-            {  for (inhd = 1; inhd <= nhdsze; inhd++)
-               {  inode = nbrhd[inhd];
-                  marker[inode] = 0;
-               }
-            }
-         }
-      }
-      return;
-#     undef nlist
+      return gamma_i;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  qmdmrg - Quotient MD MeRGe
-*
-*  SYNOPSIS
-*
-*  #include "qmdmrg.h"
-*  void qmdmrg(int xadj[], int adjncy[], int deg[], int qsize[],
-*     int qlink[], int marker[], int *deg0, int *nhdsze, int nbrhd[],
-*     int rchset[], int ovrlp[]);
-*
-*  PURPOSE
-*
-*  This routine merges indistinguishable nodes in the minimum degree
-*  ordering algorithm. It also computes the new degrees of these new
-*  supernodes.
-*
-*  INPUT PARAMETERS
+*  spy_chuzr_pse - choose basic variable (dual projected steepest edge)
 *
-*  (xadj, adjncy) -
-*           the adjancy structure;
-*  deg0   - the number of nodes in the given set;
-*  (nhdsze, nbrhd) -
-*           the set of eliminated supernodes adjacent to some nodes in
-*           the set.
+*  This routine chooses most eligible basic variable xB[p] according
+*  to the dual projected steepest edge method:
 *
-*  UPDATED PARAMETERS
+*      r[p]**2           r[i]**2
+*     -------- =   max  -------- ,
+*     gamma[p]   i in I gamma[i]
+*
+*            ( lB[i] - beta[i], if beta[i] < lB[i]
+*            (
+*     r[i] = { 0,               if lB[i] <= beta[i] <= uB[i]
+*            (
+*            ( uB[i] - beta[i], if beta[i] > uB[i]
+*
+*  where I <= {1, ..., m} is the set of indices of eligible basic
+*  variables, beta[i] is current value of xB[i], lB[i] and uB[i] are,
+*  resp., lower and upper bounds of xB[i], r[i] is bound violation.
+*
+*  Current values of basic variables should be placed in the array
+*  locations beta[1], ..., beta[m].
+*
+*  Indices of eligible basic variables i in I should be placed in the
+*  array locations list[1], ..., list[num], where num = |J| > 0 is the
+*  total number of such variables.
+*
+*  On exit the routine returns p, the index of the basic variable xB[p]
+*  chosen. */
+
+int spy_chuzr_pse(SPXLP *lp, SPYSE *se, const double beta[/*1+m*/],
+      int num, const int list[])
+{     int m = lp->m;
+      double *l = lp->l;
+      double *u = lp->u;
+      int *head = lp->head;
+      double *gamma = se->gamma;
+      int i, k, p, t;
+      double best, ri, temp;
+      xassert(0 < num && num <= m);
+      p = 0, best = -1.0;
+      for (t = 1; t <= num; t++)
+      {  i = list[t];
+         k = head[i]; /* x[k] = xB[i] */
+         if (beta[i] < l[k])
+            ri = l[k] - beta[i];
+         else if (beta[i] > u[k])
+            ri = u[k] - beta[i];
+         else
+            xassert(t != t);
+         /* FIXME */
+         if (gamma[i] < DBL_EPSILON)
+            temp = 0.0;
+         else
+            temp = (ri * ri) / gamma[i];
+         if (best < temp)
+            p = i, best = temp;
+      }
+      xassert(p != 0);
+      return p;
+}
+
+/***********************************************************************
+*  spy_update_gamma - update dual proj. steepest edge weights exactly
 *
-*  deg    - the degree vector;
-*  qsize  - size of indistinguishable nodes;
-*  qlink  - linked list for indistinguishable nodes;
-*  marker - the given set is given by those nodes with marker value set
-*           to 1. Those nodes with degree updated will have marker value
-*           set to 2.
+*  This routine updates the vector gamma = (gamma[i]) of dual projected
+*  steepest edge weights exactly, for the adjacent basis.
 *
-*  WORKING PARAMETERS
+*  On entry to the routine the content of the se object should be valid
+*  and should correspond to the current basis.
 *
-*  rchset - the reachable set;
-*  ovrlp  - temp vector to store the intersection of two reachable sets.
-***********************************************************************/
-
-void qmdmrg(int xadj[], int adjncy[], int deg[], int qsize[],
-      int qlink[], int marker[], int *_deg0, int *_nhdsze, int nbrhd[],
-      int rchset[], int ovrlp[])
-{     int deg1, head, inhd, iov, irch, j, jstop, jstrt, link, lnode,
-         mark, mrgsze, nabor, node, novrlp, rchsze, root;
-#     define deg0   (*_deg0)
-#     define nhdsze (*_nhdsze)
-      /* Initialization. */
-      if (nhdsze <= 0) return;
-      for (inhd = 1; inhd <= nhdsze; inhd++)
-      {  root = nbrhd[inhd];
-         marker[root] = 0;
+*  The parameter 1 <= p <= m specifies basic variable xB[p] which
+*  becomes non-basic variable xN[q] in the adjacent basis.
+*
+*  The parameter 1 <= q <= n-m specified non-basic variable xN[q] which
+*  becomes basic variable xB[p] in the adjacent basis.
+*
+*  It is assumed that the array trow contains elements of p-th (pivot)
+*  row T'[p] of the simplex table in locations trow[1], ..., trow[n-m].
+*  It is also assumed that the array tcol contains elements of q-th
+*  (pivot) column T[q] of the simple table in locations tcol[1], ...,
+*  tcol[m]. (These row and column should be computed for the current
+*  basis.)
+*
+*  For details about the formulae used see the program documentation.
+*
+*  The routine also computes the relative error:
+*
+*     e = |gamma[p] - gamma'[p]| / (1 + |gamma[p]|),
+*
+*  where gamma'[p] is the weight for lambdaB[p] (which is dual
+*  non-basic variable corresponding to xB[p]) on entry to the routine,
+*  and returns e on exit. (If e happens to be large enough, the calling
+*  program may reset the reference space, since other weights also may
+*  be inaccurate.) */
+
+double spy_update_gamma(SPXLP *lp, SPYSE *se, int p, int q,
+      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])
+{     int m = lp->m;
+      int n = lp->n;
+      int *head = lp->head;
+      char *refsp = se->refsp;
+      double *gamma = se->gamma;
+      double *u = se->work;
+      int i, j, k, ptr, end;
+      double gamma_p, delta_p, e, r, t1, t2;
+      xassert(se->valid);
+      xassert(1 <= p && p <= m);
+      xassert(1 <= q && q <= n-m);
+      /* compute gamma[p] in current basis more accurately; also
+       * compute auxiliary vector u */
+      k = head[p]; /* x[k] = xB[p] */
+      gamma_p = delta_p = (refsp[k] ? 1.0 : 0.0);
+      for (i = 1; i <= m; i++)
+         u[i] = 0.0;
+      for (j = 1; j <= n-m; j++)
+      {  k = head[m+j]; /* x[k] = xN[j] */
+         if (refsp[k] && trow[j] != 0.0)
+         {  gamma_p += trow[j] * trow[j];
+            /* u := u + T[p,j] * N[j], where N[j] = A[k] is constraint
+             * matrix column corresponding to xN[j] */
+            ptr = lp->A_ptr[k];
+            end = lp->A_ptr[k+1];
+            for (; ptr < end; ptr++)
+               u[lp->A_ind[ptr]] += trow[j] * lp->A_val[ptr];
+         }
+      }
+      bfd_ftran(lp->bfd, u);
+      /* compute relative error in gamma[p] */
+      e = fabs(gamma_p - gamma[p]) / (1.0 + gamma_p);
+      /* compute new gamma[p] */
+      gamma[p] = gamma_p / (tcol[p] * tcol[p]);
+      /* compute new gamma[i] for all i != p */
+      for (i = 1; i <= m; i++)
+      {  if (i == p)
+            continue;
+         /* compute r[i] = T[i,q] / T[p,q] */
+         r = tcol[i] / tcol[p];
+         /* compute new gamma[i] */
+         t1 = gamma[i] + r * (r * gamma_p + u[i] + u[i]);
+         k = head[i]; /* x[k] = xB[i] */
+         t2 = (refsp[k] ? 1.0 : 0.0) + delta_p * r * r;
+         gamma[i] = (t1 >= t2 ? t1 : t2);
       }
-      /* Loop through each eliminated supernode in the set
-         (nhdsze, nbrhd). */
-      for (inhd = 1; inhd <= nhdsze; inhd++)
-      {  root = nbrhd[inhd];
-         marker[root] = -1;
-         rchsze = 0;
-         novrlp = 0;
-         deg1 = 0;
-s200:    jstrt = xadj[root];
-         jstop = xadj[root+1] - 1;
-         /* Determine the reachable set and its intersection with the
-            input reachable set. */
-         for (j = jstrt; j <= jstop; j++)
-         {  nabor = adjncy[j];
-            root = - nabor;
-            if (nabor < 0) goto s200;
-            if (nabor == 0) break;
-            mark = marker[nabor];
-            if (mark == 0)
-            {  rchsze++;
-               rchset[rchsze] = nabor;
-               deg1 += qsize[nabor];
-               marker[nabor] = 1;
-            }
-            else if (mark == 1)
-            {  novrlp++;
-               ovrlp[novrlp] = nabor;
-               marker[nabor] = 2;
-            }
-         }
-         /* From the overlapped set, determine the nodes that can be
-            merged together. */
-         head = 0;
-         mrgsze = 0;
-         for (iov = 1; iov <= novrlp; iov++)
-         {  node = ovrlp[iov];
-            jstrt = xadj[node];
-            jstop = xadj[node+1] - 1;
-            for (j = jstrt; j <= jstop; j++)
-            {  nabor = adjncy[j];
-               if (marker[nabor] == 0)
-               {  marker[node] = 1;
-                  goto s1100;
-               }
-            }
-            /* Node belongs to the new merged supernode. Update the
-               vectors qlink and qsize. */
-            mrgsze += qsize[node];
-            marker[node] = -1;
-            lnode = node;
-s900:       link = qlink[lnode];
-            if (link > 0)
-            {  lnode = link;
-               goto s900;
-            }
-            qlink[lnode] = head;
-            head = node;
-s1100:      ;
-         }
-         if (head > 0)
-         {  qsize[head] = mrgsze;
-            deg[head] = deg0 + deg1 - 1;
-            marker[head] = 2;
-         }
-         /* Reset marker values. */
-         root = nbrhd[inhd];
-         marker[root] = 0;
-         if (rchsze > 0)
-         {  for (irch = 1; irch <= rchsze; irch++)
-            {  node = rchset[irch];
-               marker[node] = 0;
-            }
-         }
+      return e;
+}
+
+#if 1 /* 30/III-2016 */
+double spy_update_gamma_s(SPXLP *lp, SPYSE *se, int p, int q,
+      const FVS *trow, const FVS *tcol)
+{     /* sparse version of spy_update_gamma */
+      int m = lp->m;
+      int n = lp->n;
+      int *head = lp->head;
+      char *refsp = se->refsp;
+      double *gamma = se->gamma;
+      double *u = se->work;
+      int trow_nnz = trow->nnz;
+      int *trow_ind = trow->ind;
+      double *trow_vec = trow->vec;
+      int tcol_nnz = tcol->nnz;
+      int *tcol_ind = tcol->ind;
+      double *tcol_vec = tcol->vec;
+      int i, j, k, t, ptr, end;
+      double gamma_p, delta_p, e, r, t1, t2;
+      xassert(se->valid);
+      xassert(1 <= p && p <= m);
+      xassert(1 <= q && q <= n-m);
+      /* compute gamma[p] in current basis more accurately; also
+       * compute auxiliary vector u */
+      k = head[p]; /* x[k] = xB[p] */
+      gamma_p = delta_p = (refsp[k] ? 1.0 : 0.0);
+      for (i = 1; i <= m; i++)
+         u[i] = 0.0;
+      for (t = 1; t <= trow_nnz; t++)
+      {  j = trow_ind[t];
+         k = head[m+j]; /* x[k] = xN[j] */
+         if (refsp[k])
+         {  gamma_p += trow_vec[j] * trow_vec[j];
+            /* u := u + T[p,j] * N[j], where N[j] = A[k] is constraint
+             * matrix column corresponding to xN[j] */
+            ptr = lp->A_ptr[k];
+            end = lp->A_ptr[k+1];
+            for (; ptr < end; ptr++)
+               u[lp->A_ind[ptr]] += trow_vec[j] * lp->A_val[ptr];
+         }
+      }
+      bfd_ftran(lp->bfd, u);
+      /* compute relative error in gamma[p] */
+      e = fabs(gamma_p - gamma[p]) / (1.0 + gamma_p);
+      /* compute new gamma[p] */
+      gamma[p] = gamma_p / (tcol_vec[p] * tcol_vec[p]);
+      /* compute new gamma[i] for all i != p */
+      for (t = 1; t <= tcol_nnz; t++)
+      {  i = tcol_ind[t];
+         if (i == p)
+            continue;
+         /* compute r[i] = T[i,q] / T[p,q] */
+         r = tcol_vec[i] / tcol_vec[p];
+         /* compute new gamma[i] */
+         t1 = gamma[i] + r * (r * gamma_p + u[i] + u[i]);
+         k = head[i]; /* x[k] = xB[i] */
+         t2 = (refsp[k] ? 1.0 : 0.0) + delta_p * r * r;
+         gamma[i] = (t1 >= t2 ? t1 : t2);
       }
+      return e;
+}
+#endif
+
+/***********************************************************************
+*  spy_free_se - deallocate dual pricing data block
+*
+*  This routine deallocates the memory used for arrays in the dual
+*  pricing data block. */
+
+void spy_free_se(SPXLP *lp, SPYSE *se)
+{     xassert(lp == lp);
+      tfree(se->refsp);
+      tfree(se->gamma);
+      tfree(se->work);
+#if 1 /* 30/III-2016 */
+      tfree(se->u.ind);
+      tfree(se->u.vec);
+#endif
       return;
-#     undef deg0
-#     undef nhdsze
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpqmd.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/qmd.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpqmd.h (quotient minimum degree algorithm) */
+/* qmd.h (quotient minimum degree algorithm) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2001 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,41 +15,41 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPQMD_H
-#define GLPQMD_H
+#ifndef QMD_H
+#define QMD_H
 
-#define genqmd _glp_qmd_genqmd
+#define genqmd _glp_genqmd
 void genqmd(int *neqns, int xadj[], int adjncy[], int perm[],
       int invp[], int deg[], int marker[], int rchset[], int nbrhd[],
       int qsize[], int qlink[], int *nofsub);
 /* GENeral Quotient Minimum Degree algorithm */
 
-#define qmdrch _glp_qmd_qmdrch
+#define qmdrch _glp_qmdrch
 void qmdrch(int *root, int xadj[], int adjncy[], int deg[],
       int marker[], int *rchsze, int rchset[], int *nhdsze,
       int nbrhd[]);
 /* Quotient MD ReaCHable set */
 
-#define qmdqt _glp_qmd_qmdqt
+#define qmdqt _glp_qmdqt
 void qmdqt(int *root, int xadj[], int adjncy[], int marker[],
       int *rchsze, int rchset[], int nbrhd[]);
 /* Quotient MD Quotient graph Transformation */
 
-#define qmdupd _glp_qmd_qmdupd
+#define qmdupd _glp_qmdupd
 void qmdupd(int xadj[], int adjncy[], int *nlist, int list[],
       int deg[], int qsize[], int qlink[], int marker[], int rchset[],
       int nbrhd[]);
 /* Quotient MD UPDate */
 
-#define qmdmrg _glp_qmd_qmdmrg
+#define qmdmrg _glp_qmdmrg
 void qmdmrg(int xadj[], int adjncy[], int deg[], int qsize[],
       int qlink[], int marker[], int *deg0, int *nhdsze, int nbrhd[],
       int rchset[], int ovrlp[]);
 /* Quotient MD MeRGe */
 
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprgr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rgr.c`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glprgr.c */
+/* rgr.c (raster graphics) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2004-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,28 +15,25 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#define _GLPSTD_ERRNO
-#define _GLPSTD_STDIO
-#include "glpenv.h"
-#include "glprgr.h"
-#define xfault xerror
+#include "env.h"
+#include "rgr.h"
 
 /***********************************************************************
 *  NAME
 *
 *  rgr_write_bmp16 - write 16-color raster image in BMP file format
 *
 *  SYNOPSIS
 *
-*  #include "glprgr.h"
+*  #include "rgr.h"
 *  int rgr_write_bmp16(const char *fname, int m, int n, const char
 *     map[]);
 *
 *  DESCRIPTION
 *
 *  The routine rgr_write_bmp16 writes 16-color raster image in
 *  uncompressed BMP file format (Windows bitmap) to a binary file whose
@@ -91,21 +85,25 @@
       return;
 }
 
 int rgr_write_bmp16(const char *fname, int m, int n, const char map[])
 {     FILE *fp;
       int offset, bmsize, i, j, b, ret = 0;
       if (!(1 <= m && m <= 32767))
-         xfault("rgr_write_bmp16: m = %d; invalid height\n", m);
+         xerror("rgr_write_bmp16: m = %d; invalid height\n", m);
       if (!(1 <= n && n <= 32767))
-         xfault("rgr_write_bmp16: n = %d; invalid width\n", n);
+         xerror("rgr_write_bmp16: n = %d; invalid width\n", n);
       fp = fopen(fname, "wb");
       if (fp == NULL)
-      {  xprintf("rgr_write_bmp16: unable to create `%s' - %s\n",
+      {  xprintf("rgr_write_bmp16: unable to create '%s' - %s\n",
+#if 0 /* 29/I-2017 */
             fname, strerror(errno));
+#else
+            fname, xstrerr(errno));
+#endif
          ret = 1;
          goto fini;
       }
       offset = 14 + 40 + 16 * 4;
       bmsize = (4 * n + 31) / 32;
       /* struct BMPFILEHEADER (14 bytes) */
       /* UINT bfType */          put_byte(fp, 'B'), put_byte(fp, 'M');
@@ -150,16 +148,20 @@
          {  b <<= 4;
             b |= (j < n ? map[i * n + j] & 15 : 0);
             if (j & 1) put_byte(fp, b);
          }
       }
       fflush(fp);
       if (ferror(fp))
-      {  xprintf("rgr_write_bmp16: write error on `%s' - %s\n",
+      {  xprintf("rgr_write_bmp16: write error on '%s' - %s\n",
+#if 0 /* 29/I-2017 */
             fname, strerror(errno));
+#else
+            fname, xstrerr(errno));
+#endif
          ret = 1;
       }
 fini: if (fp != NULL) fclose(fp);
       return ret;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprgr.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rgr.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glprgr.h (raster graphics) */
+/* rgr.h (raster graphics) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2004-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,16 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPRGR_H
-#define GLPRGR_H
+#ifndef RGR_H
+#define RGR_H
 
 #define rgr_write_bmp16 _glp_rgr_write_bmp16
 int rgr_write_bmp16(const char *fname, int m, int n, const char map[]);
 /* write 16-color raster image in BMP file format */
 
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprng.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rng.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glprng.h (pseudo-random number generator) */
+/* rng.h (pseudo-random number generator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,16 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPRNG_H
-#define GLPRNG_H
+#ifndef RNG_H
+#define RNG_H
 
 typedef struct RNG RNG;
 
 struct RNG
 {     /* Knuth's portable pseudo-random number generator */
       int A[56];
       /* pseudo-random values */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprng01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rng.c`

 * *Files 6% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* glprng01.c */
+/* rng.c (pseudo-random number generator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
 *
 *  This code is a modified version of the module GB_FLIP, a portable
 *  pseudo-random number generator. The original version of GB_FLIP is
 *  a part of The Stanford GraphBase developed by Donald E. Knuth (see
@@ -23,20 +23,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wsign-conversion"
-#endif
-
-#include "glpenv.h"
-#include "glprng.h"
+#include "env.h"
+#include "rng.h"
 
 #if 0
 int A[56] = { -1 };
 #else
 #define A (rand->A)
 #endif
 /* pseudo-random values */
@@ -49,15 +45,15 @@
 /* the next A value to be exported */
 
 #define mod_diff(x, y) (((x) - (y)) & 0x7FFFFFFF)
 /* difference modulo 2^31 */
 
 static int flip_cycle(RNG *rand)
 {     /* this is an auxiliary routine to do 55 more steps of the basic
-         recurrence, at high speed, and to reset fptr */
+       * recurrence, at high speed, and to reset fptr */
       int *ii, *jj;
       for (ii = &A[1], jj = &A[32]; jj <= &A[55]; ii++, jj++)
          *ii = mod_diff(*ii, *jj);
       for (jj = &A[1]; ii <= &A[55]; ii++, jj++)
          *ii = mod_diff(*ii, *jj);
       fptr = &A[54];
       return A[55];
@@ -66,45 +62,45 @@
 /***********************************************************************
 *  NAME
 *
 *  rng_create_rand - create pseudo-random number generator
 *
 *  SYNOPSIS
 *
-*  #include "glprng.h"
+*  #include "rng.h"
 *  RNG *rng_create_rand(void);
 *
 *  DESCRIPTION
 *
 *  The routine rng_create_rand creates and initializes a pseudo-random
 *  number generator.
 *
 *  RETURNS
 *
 *  The routine returns a pointer to the generator created. */
 
 RNG *rng_create_rand(void)
 {     RNG *rand;
       int i;
-      rand = xmalloc(sizeof(RNG));
+      rand = talloc(1, RNG);
       A[0] = -1;
       for (i = 1; i <= 55; i++) A[i] = 0;
       fptr = A;
       rng_init_rand(rand, 1);
       return rand;
 }
 
 /***********************************************************************
 *  NAME
 *
 *  rng_init_rand - initialize pseudo-random number generator
 *
 *  SYNOPSIS
 *
-*  #include "glprng.h"
+*  #include "rng.h"
 *  void rng_init_rand(RNG *rand, int seed);
 *
 *  DESCRIPTION
 *
 *  The routine rng_init_rand initializes the pseudo-random number
 *  generator. The parameter seed may be any integer number. Note that
 *  on creating the generator this routine is called with the parameter
@@ -136,15 +132,15 @@
 /***********************************************************************
 *  NAME
 *
 *  rng_next_rand - obtain pseudo-random integer in the range [0, 2^31-1]
 *
 *  SYNOPSIS
 *
-*  #include "glprng.h"
+*  #include "rng.h"
 *  int rng_next_rand(RNG *rand);
 *
 *  RETURNS
 *
 *  The routine rng_next_rand returns a next pseudo-random integer which
 *  is uniformly distributed between 0 and 2^31-1, inclusive. The period
 *  length of the generated numbers is 2^85 - 2^30. The low order bits of
@@ -158,15 +154,15 @@
 /***********************************************************************
 *  NAME
 *
 *  rng_unif_rand - obtain pseudo-random integer in the range [0, m-1]
 *
 *  SYNOPSIS
 *
-*  #include "glprng.h"
+*  #include "rng.h"
 *  int rng_unif_rand(RNG *rand, int m);
 *
 *  RETURNS
 *
 *  The routine rng_unif_rand returns a next pseudo-random integer which
 *  is uniformly distributed between 0 and m-1, inclusive, where m is any
 *  positive integer less than 2^31. */
@@ -184,32 +180,32 @@
 /***********************************************************************
 *  NAME
 *
 *  rng_delete_rand - delete pseudo-random number generator
 *
 *  SYNOPSIS
 *
-*  #include "glprng.h"
+*  #include "rng.h"
 *  void rng_delete_rand(RNG *rand);
 *
 *  DESCRIPTION
 *
 *  The routine rng_delete_rand frees all the memory allocated to the
 *  specified pseudo-random number generator. */
 
 void rng_delete_rand(RNG *rand)
-{     xfree(rand);
+{     tfree(rand);
       return;
 }
 
 /**********************************************************************/
 
-#if 0
+#ifdef GLP_TEST
 /* To be sure that this modified version produces the same results as
-   the original version, run this validation program. */
+ * the original version, run this validation program. */
 
 int main(void)
 {     RNG *rand;
       int j;
       rand = rng_create_rand();
       rng_init_rand(rand, -314159);
       if (rng_next_rand(rand) != 119318998)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glprng02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/rng1.c`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glprng02.c */
+/* rng1.c (pseudo-random number generator) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,26 +15,25 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpenv.h"
-#include "glprng.h"
-#define xfault xerror
+#include "env.h"
+#include "rng.h"
 
 /***********************************************************************
 *  NAME
 *
 *  rng_unif_01 - obtain pseudo-random number in the range [0, 1]
 *
 *  SYNOPSIS
 *
-*  #include "glprng.h"
+*  #include "rng.h"
 *  double rng_unif_01(RNG *rand);
 *
 *  RETURNS
 *
 *  The routine rng_unif_01 returns a next pseudo-random number which is
 *  uniformly distributed in the range [0, 1]. */
 
@@ -51,26 +47,25 @@
 /***********************************************************************
 *  NAME
 *
 *  rng_uniform - obtain pseudo-random number in the range [a, b]
 *
 *  SYNOPSIS
 *
-*  #include "glprng.h"
+*  #include "rng.h"
 *  double rng_uniform(RNG *rand, double a, double b);
 *
 *  RETURNS
 *
 *  The routine rng_uniform returns a next pseudo-random number which is
 *  uniformly distributed in the range [a, b]. */
 
 double rng_uniform(RNG *rand, double a, double b)
 {     double x;
-      if (a >= b)
-         xfault("rng_uniform: a = %g, b = %g; invalid range\n", a, b);
+      xassert(a < b);
       x = rng_unif_01(rand);
       x = a * (1.0 - x) + b * x;
       xassert(a <= x && x <= b);
       return x;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpscf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/bflib/fhv.c`

 * *Files 25% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpscf.c (Schur complement factorization) */
+/* fhv.c (sparse updatable FHV-factorization) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2012-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,621 +15,570 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wself-assign"
-#endif
-
-#include "glpenv.h"
-#include "glpscf.h"
-#define xfault xerror
-
-#define _GLPSCF_DEBUG 0
-
-#define eps 1e-10
+#include "env.h"
+#include "fhv.h"
 
 /***********************************************************************
-*  NAME
+*  fhv_ft_update - update FHV-factorization (Forrest-Tomlin)
 *
-*  scf_create_it - create Schur complement factorization
+*  This routine updates FHV-factorization of the original matrix A
+*  after replacing its j-th column by a new one. The routine is based
+*  on the method proposed by Forrest and Tomlin [1].
 *
-*  SYNOPSIS
+*  The parameter q specifies the number of column of A, which has been
+*  replaced, 1 <= q <= n, where n is the order of A.
 *
-*  #include "glpscf.h"
-*  SCF *scf_create_it(int n_max);
+*  Row indices and numerical values of non-zero elements of the new
+*  j-th column of A should be placed in locations aq_ind[1], ...,
+*  aq_ind[aq_len] and aq_val[1], ..., aq_val[aq_len], respectively,
+*  where aq_len is the number of non-zeros. Neither zero nor duplicate
+*  elements are allowed.
 *
-*  DESCRIPTION
-*
-*  The routine scf_create_it creates the factorization of matrix C,
-*  which initially has no rows and columns.
-*
-*  The parameter n_max specifies the maximal order of matrix C to be
-*  factorized, 1 <= n_max <= 32767.
+*  The working arrays ind, val, and work should have at least 1+n
+*  elements (0-th elements are not used).
 *
 *  RETURNS
 *
-*  The routine scf_create_it returns a pointer to the structure SCF,
-*  which defines the factorization. */
-
-SCF *scf_create_it(int n_max)
-{     SCF *scf;
-#if _GLPSCF_DEBUG
-      xprintf("scf_create_it: warning: debug mode enabled\n");
-#endif
-      if (!(1 <= n_max && n_max <= 32767))
-         xfault("scf_create_it: n_max = %d; invalid parameter\n",
-            n_max);
-      scf = xmalloc(sizeof(SCF));
-      scf->n_max = n_max;
-      scf->n = 0;
-      scf->f = xcalloc(1 + n_max * n_max, sizeof(double));
-      scf->u = xcalloc(1 + n_max * (n_max + 1) / 2, sizeof(double));
-      scf->p = xcalloc(1 + n_max, sizeof(int));
-      scf->t_opt = SCF_TBG;
-      scf->rank = 0;
-#if _GLPSCF_DEBUG
-      scf->c = xcalloc(1 + n_max * n_max, sizeof(double));
-#else
-      scf->c = NULL;
-#endif
-      scf->w = xcalloc(1 + n_max, sizeof(double));
-      return scf;
-}
-
-/***********************************************************************
-*  The routine f_loc determines location of matrix element F[i,j] in
-*  the one-dimensional array f. */
-
-static int f_loc(SCF *scf, int i, int j)
-{     int n_max = scf->n_max;
-      int n = scf->n;
-      xassert(1 <= i && i <= n);
-      xassert(1 <= j && j <= n);
-      return (i - 1) * n_max + j;
-}
-
-/***********************************************************************
-*  The routine u_loc determines location of matrix element U[i,j] in
-*  the one-dimensional array u. */
-
-static int u_loc(SCF *scf, int i, int j)
-{     int n_max = scf->n_max;
-      int n = scf->n;
-      xassert(1 <= i && i <= n);
-      xassert(i <= j && j <= n);
-      return (i - 1) * n_max + j - i * (i - 1) / 2;
-}
-
-/***********************************************************************
-*  The routine bg_transform applies Bartels-Golub version of gaussian
-*  elimination to restore triangular structure of matrix U.
-*
-*  On entry matrix U has the following structure:
-*
-*        1       k         n
-*     1  * * * * * * * * * *
-*        . * * * * * * * * *
-*        . . * * * * * * * *
-*        . . . * * * * * * *
-*     k  . . . . * * * * * *
-*        . . . . . * * * * *
-*        . . . . . . * * * *
-*        . . . . . . . * * *
-*        . . . . . . . . * *
-*     n  . . . . # # # # # #
-*
-*  where '#' is a row spike to be eliminated.
-*
-*  Elements of n-th row are passed separately in locations un[k], ...,
-*  un[n]. On exit the content of the array un is destroyed.
-*
-*  REFERENCES
-*
-*  R.H.Bartels, G.H.Golub, "The Simplex Method of Linear Programming
-*  Using LU-decomposition", Comm. ACM, 12, pp. 266-68, 1969. */
-
-static void bg_transform(SCF *scf, int k, double un[])
-{     int n = scf->n;
-      double *f = scf->f;
-      double *u = scf->u;
-      int j, k1, kj, kk, n1, nj;
-      double t;
-      xassert(1 <= k && k <= n);
-      /* main elimination loop */
-      for (k = k; k < n; k++)
-      {  /* determine location of U[k,k] */
-         kk = u_loc(scf, k, k);
-         /* determine location of F[k,1] */
-         k1 = f_loc(scf, k, 1);
-         /* determine location of F[n,1] */
-         n1 = f_loc(scf, n, 1);
-         /* if |U[k,k]| < |U[n,k]|, interchange k-th and n-th rows to
-            provide |U[k,k]| >= |U[n,k]| */
-         if (fabs(u[kk]) < fabs(un[k]))
-         {  /* interchange k-th and n-th rows of matrix U */
-            for (j = k, kj = kk; j <= n; j++, kj++)
-               t = u[kj], u[kj] = un[j], un[j] = t;
-            /* interchange k-th and n-th rows of matrix F to keep the
-               main equality F * C = U * P */
-            for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)
-               t = f[kj], f[kj] = f[nj], f[nj] = t;
-         }
-         /* now |U[k,k]| >= |U[n,k]| */
-         /* if U[k,k] is too small in the magnitude, replace U[k,k] and
-            U[n,k] by exact zero */
-         if (fabs(u[kk]) < eps) u[kk] = un[k] = 0.0;
-         /* if U[n,k] is already zero, elimination is not needed */
-         if (un[k] == 0.0) continue;
-         /* compute gaussian multiplier t = U[n,k] / U[k,k] */
-         t = un[k] / u[kk];
-         /* apply gaussian elimination to nullify U[n,k] */
-         /* (n-th row of U) := (n-th row of U) - t * (k-th row of U) */
-         for (j = k+1, kj = kk+1; j <= n; j++, kj++)
-            un[j] -= t * u[kj];
-         /* (n-th row of F) := (n-th row of F) - t * (k-th row of F)
-            to keep the main equality F * C = U * P */
-         for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)
-            f[nj] -= t * f[kj];
-      }
-      /* if U[n,n] is too small in the magnitude, replace it by exact
-         zero */
-      if (fabs(un[n]) < eps) un[n] = 0.0;
-      /* store U[n,n] in a proper location */
-      u[u_loc(scf, n, n)] = un[n];
-      return;
-}
-
-/***********************************************************************
-*  The routine givens computes the parameters of Givens plane rotation
-*  c = cos(teta) and s = sin(teta) such that:
-*
-*     ( c -s ) ( a )   ( r )
-*     (      ) (   ) = (   ) ,
-*     ( s  c ) ( b )   ( 0 )
-*
-*  where a and b are given scalars.
+*  0  The factorization has been successfully updated.
 *
-*  REFERENCES
+*  1  New matrix U = P'* V * Q' is upper triangular with zero diagonal
+*     element u[s,s]. (Elimination was not performed.)
 *
-*  G.H.Golub, C.F.Van Loan, "Matrix Computations", 2nd ed. */
-
-static void givens(double a, double b, double *c, double *s)
-{     double t;
-      if (b == 0.0)
-         (*c) = 1.0, (*s) = 0.0;
-      else if (fabs(a) <= fabs(b))
-         t = - a / b, (*s) = 1.0 / sqrt(1.0 + t * t), (*c) = (*s) * t;
-      else
-         t = - b / a, (*c) = 1.0 / sqrt(1.0 + t * t), (*s) = (*c) * t;
-      return;
-}
-
-/*----------------------------------------------------------------------
-*  The routine gr_transform applies Givens plane rotations to restore
-*  triangular structure of matrix U.
-*
-*  On entry matrix U has the following structure:
-*
-*        1       k         n
-*     1  * * * * * * * * * *
-*        . * * * * * * * * *
-*        . . * * * * * * * *
-*        . . . * * * * * * *
-*     k  . . . . * * * * * *
-*        . . . . . * * * * *
-*        . . . . . . * * * *
-*        . . . . . . . * * *
-*        . . . . . . . . * *
-*     n  . . . . # # # # # #
+*  2  New matrix U = P'* V * Q' is upper triangular, and its diagonal
+*     element u[s,s] or u[t,t] is too small in magnitude. (Elimination
+*     was not performed.)
+*
+*  3  The same as 2, but after performing elimination.
+*
+*  4  The factorization has not been updated, because maximal number of
+*     updates has been reached.
+*
+*  5  Accuracy test failed for the updated factorization.
+*
+*  BACKGROUND
+*
+*  The routine is based on the updating method proposed by Forrest and
+*  Tomlin [1].
+*
+*  Let q-th column of the original matrix A have been replaced by new
+*  column A[q]. Then, to keep the equality A = F * H * V, q-th column
+*  of matrix V should be replaced by column V[q] = inv(F * H) * A[q].
+*  From the standpoint of matrix U = P'* V * Q' such replacement is
+*  equivalent to replacement of s-th column of matrix U, where s is
+*  determined from q by permutation matrix Q. Thus, matrix U loses its
+*  upper triangular form and becomes the following:
+*
+*        1   s       t   n
+*     1  x x * x x x x x x
+*        . x * x x x x x x
+*     s  . . * x x x x x x
+*        . . * x x x x x x
+*        . . * . x x x x x
+*        . . * . . x x x x
+*     t  . . * . . . x x x
+*        . . . . . . . x x
+*     n  . . . . . . . . x
+*
+*  where t is largest row index of a non-zero element in s-th column.
+*
+*  The routine makes matrix U upper triangular as follows. First, it
+*  moves rows and columns s+1, ..., t by one position to the left and
+*  upwards, resp., and moves s-th row and s-th column to position t.
+*  Due to such symmetric permutations matrix U becomes the following
+*  (note that all diagonal elements remain on the diagonal, and element
+*  u[s,s] becomes u[t,t]):
+*
+*        1   s       t   n
+*     1  x x x x x x * x x
+*        . x x x x x * x x
+*     s  . . x x x x * x x
+*        . . . x x x * x x
+*        . . . . x x * x x
+*        . . . . . x * x x
+*     t  . . x x x x * x x
+*        . . . . . . . x x
+*     n  . . . . . . . . x
+*
+*  Then the routine performs gaussian elimination to eliminate
+*  subdiagonal elements u[t,s], ..., u[t,t-1] using diagonal elements
+*  u[s,s], ..., u[t-1,t-1] as pivots. During the elimination process
+*  the routine permutes neither rows nor columns, so only t-th row is
+*  changed. Should note that actually all operations are performed on
+*  matrix V = P * U * Q, since matrix U is not stored.
+*
+*  To keep the equality A = F * H * V, the routine appends new row-like
+*  factor H[k] to matrix H, and every time it applies elementary
+*  gaussian transformation to eliminate u[t,j'] = v[p,j] using pivot
+*  u[j',j'] = v[i,j], it also adds new element f[p,j] = v[p,j] / v[i,j]
+*  (gaussian multiplier) to factor H[k], which initially is a unity
+*  matrix. At the end of elimination process the row-like factor H[k]
+*  may look as follows:
+*
+*        1               n          1   s       t   n
+*     1  1 . . . . . . . .       1  1 . . . . . . . .
+*        . 1 . . . . . . .          . 1 . . . . . . .
+*        . . 1 . . . . . .       s  . . 1 . . . . . .
+*     p  . x x 1 . x . x .          . . . 1 . . . . .
+*        . . . . 1 . . . .          . . . . 1 . . . .
+*        . . . . . 1 . . .          . . . . . 1 . . .
+*        . . . . . . 1 . .       t  . . x x x x 1 . .
+*        . . . . . . . 1 .          . . . . . . . 1 .
+*     n  . . . . . . . . 1       n  . . . . . . . . 1
 *
-*  where '#' is a row spike to be eliminated.
+*              H[k]                 inv(P) * H[k] * P
 *
-*  Elements of n-th row are passed separately in locations un[k], ...,
-*  un[n]. On exit the content of the array un is destroyed.
+*  If, however, s = t, no elimination is needed, in which case no new
+*  row-like factor is created.
 *
 *  REFERENCES
 *
-*  R.H.Bartels, G.H.Golub, "The Simplex Method of Linear Programming
-*  Using LU-decomposition", Comm. ACM, 12, pp. 266-68, 1969. */
-
-static void gr_transform(SCF *scf, int k, double un[])
-{     int n = scf->n;
-      double *f = scf->f;
-      double *u = scf->u;
-      int j, k1, kj, kk, n1, nj;
-      double c, s;
-      xassert(1 <= k && k <= n);
-      /* main elimination loop */
-      for (k = k; k < n; k++)
-      {  /* determine location of U[k,k] */
-         kk = u_loc(scf, k, k);
-         /* determine location of F[k,1] */
-         k1 = f_loc(scf, k, 1);
-         /* determine location of F[n,1] */
-         n1 = f_loc(scf, n, 1);
-         /* if both U[k,k] and U[n,k] are too small in the magnitude,
-            replace them by exact zero */
-         if (fabs(u[kk]) < eps && fabs(un[k]) < eps)
-            u[kk] = un[k] = 0.0;
-         /* if U[n,k] is already zero, elimination is not needed */
-         if (un[k] == 0.0) continue;
-         /* compute the parameters of Givens plane rotation */
-         givens(u[kk], un[k], &c, &s);
-         /* apply Givens rotation to k-th and n-th rows of matrix U */
-         for (j = k, kj = kk; j <= n; j++, kj++)
-         {  double ukj = u[kj], unj = un[j];
-            u[kj] = c * ukj - s * unj;
-            un[j] = s * ukj + c * unj;
-         }
-         /* apply Givens rotation to k-th and n-th rows of matrix F
-            to keep the main equality F * C = U * P */
-         for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)
-         {  double fkj = f[kj], fnj = f[nj];
-            f[kj] = c * fkj - s * fnj;
-            f[nj] = s * fkj + c * fnj;
-         }
-      }
-      /* if U[n,n] is too small in the magnitude, replace it by exact
-         zero */
-      if (fabs(un[n]) < eps) un[n] = 0.0;
-      /* store U[n,n] in a proper location */
-      u[u_loc(scf, n, n)] = un[n];
-      return;
-}
-
-/***********************************************************************
-*  The routine transform restores triangular structure of matrix U.
-*  It is a driver to the routines bg_transform and gr_transform (see
-*  comments to these routines above). */
-
-static void transform(SCF *scf, int k, double un[])
-{     switch (scf->t_opt)
-      {  case SCF_TBG:
-            bg_transform(scf, k, un);
-            break;
-         case SCF_TGR:
-            gr_transform(scf, k, un);
-            break;
-         default:
-            xassert(scf != scf);
+*  1. J.J.H.Forrest and J.A.Tomlin, "Updated triangular factors of the
+*     basis to maintain sparsity in the product form simplex method,"
+*     Math. Prog. 2 (1972), pp. 263-78. */
+
+int fhv_ft_update(FHV *fhv, int q, int aq_len, const int aq_ind[],
+      const double aq_val[], int ind[/*1+n*/], double val[/*1+n*/],
+      double work[/*1+n*/])
+{     LUF *luf = fhv->luf;
+      int n = luf->n;
+      SVA *sva = luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int vr_ref = luf->vr_ref;
+      int *vr_ptr = &sva->ptr[vr_ref-1];
+      int *vr_len = &sva->len[vr_ref-1];
+      int *vr_cap = &sva->cap[vr_ref-1];
+      double *vr_piv = luf->vr_piv;
+      int vc_ref = luf->vc_ref;
+      int *vc_ptr = &sva->ptr[vc_ref-1];
+      int *vc_len = &sva->len[vc_ref-1];
+      int *vc_cap = &sva->cap[vc_ref-1];
+      int *pp_ind = luf->pp_ind;
+      int *pp_inv = luf->pp_inv;
+      int *qq_ind = luf->qq_ind;
+      int *qq_inv = luf->qq_inv;
+      int *hh_ind = fhv->hh_ind;
+      int hh_ref = fhv->hh_ref;
+      int *hh_ptr = &sva->ptr[hh_ref-1];
+      int *hh_len = &sva->len[hh_ref-1];
+#if 1 /* FIXME */
+      const double eps_tol = DBL_EPSILON;
+      const double vpq_tol = 1e-5;
+      const double err_tol = 1e-10;
+#endif
+      int end, i, i_end, i_ptr, j, j_end, j_ptr, k, len, nnz, p, p_end,
+         p_ptr, ptr, q_end, q_ptr, s, t;
+      double f, vpq, temp;
+      /*--------------------------------------------------------------*/
+      /* replace current q-th column of matrix V by new one           */
+      /*--------------------------------------------------------------*/
+      xassert(1 <= q && q <= n);
+      /* convert new q-th column of matrix A to dense format */
+      for (i = 1; i <= n; i++)
+         val[i] = 0.0;
+      xassert(0 <= aq_len && aq_len <= n);
+      for (k = 1; k <= aq_len; k++)
+      {  i = aq_ind[k];
+         xassert(1 <= i && i <= n);
+         xassert(val[i] == 0.0);
+         xassert(aq_val[k] != 0.0);
+         val[i] = aq_val[k];
       }
-      return;
-}
-
-/***********************************************************************
-*  The routine estimate_rank estimates the rank of matrix C.
-*
-*  Since all transformations applied to matrix F are non-singular,
-*  and F is assumed to be well conditioned, from the main equaility
-*  F * C = U * P it follows that rank(C) = rank(U), where rank(U) is
-*  estimated as the number of non-zero diagonal elements of U. */
-
-static int estimate_rank(SCF *scf)
-{     int n_max = scf->n_max;
-      int n = scf->n;
-      double *u = scf->u;
-      int i, ii, inc, rank = 0;
-      for (i = 1, ii = u_loc(scf, i, i), inc = n_max; i <= n;
-         i++, ii += inc, inc--)
-         if (u[ii] != 0.0) rank++;
-      return rank;
-}
-
-#if _GLPSCF_DEBUG
-/***********************************************************************
-*  The routine check_error computes the maximal relative error between
-*  left- and right-hand sides of the main equality F * C = U * P. (This
-*  routine is intended only for debugging.) */
-
-static void check_error(SCF *scf, const char *func)
-{     int n = scf->n;
-      double *f = scf->f;
-      double *u = scf->u;
-      int *p = scf->p;
-      double *c = scf->c;
-      int i, j, k;
-      double d, dmax = 0.0, s, t;
-      xassert(c != NULL);
+      /* compute new q-th column of matrix V:
+       * new V[q] = inv(F * H) * (new A[q]) */
+      luf->pp_ind = fhv->p0_ind;
+      luf->pp_inv = fhv->p0_inv;
+      luf_f_solve(luf, val);
+      luf->pp_ind = pp_ind;
+      luf->pp_inv = pp_inv;
+      fhv_h_solve(fhv, val);
+      /* q-th column of V = s-th column of U */
+      s = qq_inv[q];
+      /* determine row number of element v[p,q] that corresponds to
+       * diagonal element u[s,s] */
+      p = pp_inv[s];
+      /* convert new q-th column of V to sparse format;
+       * element v[p,q] = u[s,s] is not included in the element list
+       * and stored separately */
+      vpq = 0.0;
+      len = 0;
       for (i = 1; i <= n; i++)
-      {  for (j = 1; j <= n; j++)
-         {  /* compute element (i,j) of product F * C */
-            s = 0.0;
-            for (k = 1; k <= n; k++)
-               s += f[f_loc(scf, i, k)] * c[f_loc(scf, k, j)];
-            /* compute element (i,j) of product U * P */
-            k = p[j];
-            t = (i <= k ? u[u_loc(scf, i, k)] : 0.0);
-            /* compute the maximal relative error */
-            d = fabs(s - t) / (1.0 + fabs(t));
-            if (dmax < d) dmax = d;
-         }
-      }
-      if (dmax > 1e-8)
-         xprintf("%s: dmax = %g; relative error too large\n", func,
-            dmax);
-      return;
-}
+      {  temp = val[i];
+#if 1 /* FIXME */
+         if (-eps_tol < temp && temp < +eps_tol)
 #endif
-
-/***********************************************************************
-*  NAME
-*
-*  scf_update_exp - update factorization on expanding C
-*
-*  SYNOPSIS
-*
-*  #include "glpscf.h"
-*  int scf_update_exp(SCF *scf, const double x[], const double y[],
-*     double z);
-*
-*  DESCRIPTION
-*
-*  The routine scf_update_exp updates the factorization of matrix C on
-*  expanding it by adding a new row and column as follows:
-*
-*             ( C  x )
-*     new C = (      )
-*             ( y' z )
-*
-*  where x[1,...,n] is a new column, y[1,...,n] is a new row, and z is
-*  a new diagonal element.
-*
-*  If on entry the factorization is empty, the parameters x and y can
-*  be specified as NULL.
-*
-*  RETURNS
-*
-*  0  The factorization has been successfully updated.
-*
-*  SCF_ESING
-*     The factorization has been successfully updated, however, new
-*     matrix C is singular within working precision. Note that the new
-*     factorization remains valid.
-*
-*  SCF_ELIMIT
-*     There is not enough room to expand the factorization, because
-*     n = n_max. The factorization remains unchanged.
-*
-*  ALGORITHM
-*
-*  We can see that:
-*
-*     ( F  0 ) ( C  x )   ( FC  Fx )   ( UP  Fx )
-*     (      ) (      ) = (        ) = (        ) =
-*     ( 0  1 ) ( y' z )   ( y'   z )   ( y'   z )
-*
-*        ( U   Fx ) ( P  0 )
-*     =  (        ) (      ),
-*        ( y'P' z ) ( 0  1 )
-*
-*  therefore to keep the main equality F * C = U * P we can take:
-*
-*             ( F  0 )           ( U   Fx )           ( P  0 )
-*     new F = (      ),  new U = (        ),  new P = (      ),
-*             ( 0  1 )           ( y'P' z )           ( 0  1 )
-*
-*  and eliminate the row spike y'P' in the last row of new U to restore
-*  its upper triangular structure. */
-
-int scf_update_exp(SCF *scf, const double x[], const double y[],
-      double z)
-{     int n_max = scf->n_max;
-      int n = scf->n;
-      double *f = scf->f;
-      double *u = scf->u;
-      int *p = scf->p;
-#if _GLPSCF_DEBUG
-      double *c = scf->c;
+            /* nop */;
+         else if (i == p)
+            vpq = temp;
+         else
+         {  ind[++len] = i;
+            val[len] = temp;
+         }
+      }
+      /* clear q-th column of matrix V */
+      for (q_end = (q_ptr = vc_ptr[q]) + vc_len[q];
+         q_ptr < q_end; q_ptr++)
+      {  /* get row index of v[i,q] */
+         i = sv_ind[q_ptr];
+         /* find and remove v[i,q] from i-th row */
+         for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
+            sv_ind[i_ptr] != q; i_ptr++)
+            /* nop */;
+         xassert(i_ptr < i_end);
+         sv_ind[i_ptr] = sv_ind[i_end-1];
+         sv_val[i_ptr] = sv_val[i_end-1];
+         vr_len[i]--;
+      }
+      /* now q-th column of matrix V is empty */
+      vc_len[q] = 0;
+      /* put new q-th column of V (except element v[p,q] = u[s,s]) in
+       * column-wise format */
+      if (len > 0)
+      {  if (vc_cap[q] < len)
+         {  if (sva->r_ptr - sva->m_ptr < len)
+            {  sva_more_space(sva, len);
+               sv_ind = sva->ind;
+               sv_val = sva->val;
+            }
+            sva_enlarge_cap(sva, vc_ref-1+q, len, 0);
+         }
+         ptr = vc_ptr[q];
+         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
+         memcpy(&sv_val[ptr], &val[1], len * sizeof(double));
+         vc_len[q] = len;
+      }
+      /* put new q-th column of V (except element v[p,q] = u[s,s]) in
+       * row-wise format, and determine largest row number t such that
+       * u[s,t] != 0 */
+      t = (vpq == 0.0 ? 0 : s);
+      for (k = 1; k <= len; k++)
+      {  /* get row index of v[i,q] */
+         i = ind[k];
+         /* put v[i,q] to i-th row */
+         if (vr_cap[i] == vr_len[i])
+         {  /* reserve extra locations in i-th row to reduce further
+             * relocations of that row */
+#if 1 /* FIXME */
+            int need = vr_len[i] + 5;
 #endif
-      double *un = scf->w;
-      int i, ij, in, j, k, nj, ret = 0;
-      double t;
-      /* check if the factorization can be expanded */
-      if (n == n_max)
-      {  /* there is not enough room */
-         ret = SCF_ELIMIT;
-         goto done;
-      }
-      /* increase the order of the factorization */
-      scf->n = ++n;
-      /* fill new zero column of matrix F */
-      for (i = 1, in = f_loc(scf, i, n); i < n; i++, in += n_max)
-         f[in] = 0.0;
-      /* fill new zero row of matrix F */
-      for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)
-         f[nj] = 0.0;
-      /* fill new unity diagonal element of matrix F */
-      f[f_loc(scf, n, n)] = 1.0;
-      /* compute new column of matrix U, which is (old F) * x */
-      for (i = 1; i < n; i++)
-      {  /* u[i,n] := (i-th row of old F) * x */
-         t = 0.0;
-         for (j = 1, ij = f_loc(scf, i, 1); j < n; j++, ij++)
-            t += f[ij] * x[j];
-         u[u_loc(scf, i, n)] = t;
-      }
-      /* compute new (spiked) row of matrix U, which is (old P) * y */
-      for (j = 1; j < n; j++) un[j] = y[p[j]];
-      /* store new diagonal element of matrix U, which is z */
-      un[n] = z;
-      /* expand matrix P */
-      p[n] = n;
-#if _GLPSCF_DEBUG
-      /* expand matrix C */
-      /* fill its new column, which is x */
-      for (i = 1, in = f_loc(scf, i, n); i < n; i++, in += n_max)
-         c[in] = x[i];
-      /* fill its new row, which is y */
-      for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)
-         c[nj] = y[j];
-      /* fill its new diagonal element, which is z */
-      c[f_loc(scf, n, n)] = z;
+            if (sva->r_ptr - sva->m_ptr < need)
+            {  sva_more_space(sva, need);
+               sv_ind = sva->ind;
+               sv_val = sva->val;
+            }
+            sva_enlarge_cap(sva, vr_ref-1+i, need, 0);
+         }
+         sv_ind[ptr = vr_ptr[i] + (vr_len[i]++)] = q;
+         sv_val[ptr] = val[k];
+         /* v[i,q] is non-zero; increase t */
+         if (t < pp_ind[i])
+            t = pp_ind[i];
+      }
+      /*--------------------------------------------------------------*/
+      /* check if matrix U is already upper triangular                */
+      /*--------------------------------------------------------------*/
+      /* check if there is a spike in s-th column of matrix U, which
+       * is q-th column of matrix V */
+      if (s >= t)
+      {  /* no spike; matrix U is already upper triangular */
+         /* store its diagonal element u[s,s] = v[p,q] */
+         vr_piv[p] = vpq;
+         if (s > t)
+         {  /* matrix U is structurally singular, because its diagonal
+             * element u[s,s] = v[p,q] is exact zero */
+            xassert(vpq == 0.0);
+            return 1;
+         }
+#if 1 /* FIXME */
+         else if (-vpq_tol < vpq && vpq < +vpq_tol)
 #endif
-      /* restore upper triangular structure of matrix U */
-      for (k = 1; k < n; k++)
-         if (un[k] != 0.0) break;
-      transform(scf, k, un);
-      /* estimate the rank of matrices C and U */
-      scf->rank = estimate_rank(scf);
-      if (scf->rank != n) ret = SCF_ESING;
-#if _GLPSCF_DEBUG
-      /* check that the factorization is accurate enough */
-      check_error(scf, "scf_update_exp");
+         {  /* matrix U is not well conditioned, because its diagonal
+             * element u[s,s] = v[p,q] is too small in magnitude */
+            return 2;
+         }
+         else
+         {  /* normal case */
+            return 0;
+         }
+      }
+      /*--------------------------------------------------------------*/
+      /* perform implicit symmetric permutations of rows and columns  */
+      /* of matrix U                                                  */
+      /*--------------------------------------------------------------*/
+      /* currently v[p,q] = u[s,s] */
+      xassert(p == pp_inv[s] && q == qq_ind[s]);
+      for (k = s; k < t; k++)
+      {  pp_ind[pp_inv[k] = pp_inv[k+1]] = k;
+         qq_inv[qq_ind[k] = qq_ind[k+1]] = k;
+      }
+      /* now v[p,q] = u[t,t] */
+      pp_ind[pp_inv[t] = p] = qq_inv[qq_ind[t] = q] = t;
+      /*--------------------------------------------------------------*/
+      /* check if matrix U is already upper triangular                */
+      /*--------------------------------------------------------------*/
+      /* check if there is a spike in t-th row of matrix U, which is
+       * p-th row of matrix V */
+      for (p_end = (p_ptr = vr_ptr[p]) + vr_len[p];
+         p_ptr < p_end; p_ptr++)
+      {  if (qq_inv[sv_ind[p_ptr]] < t)
+            break; /* spike detected */
+      }
+      if (p_ptr == p_end)
+      {  /* no spike; matrix U is already upper triangular */
+         /* store its diagonal element u[t,t] = v[p,q] */
+         vr_piv[p] = vpq;
+#if 1 /* FIXME */
+         if (-vpq_tol < vpq && vpq < +vpq_tol)
 #endif
-done: return ret;
-}
-
-/***********************************************************************
-*  The routine solve solves the system C * x = b.
-*
-*  From the main equation F * C = U * P it follows that:
-*
-*     C * x = b  =>  F * C * x = F * b  =>  U * P * x = F * b  =>
-*
-*     P * x = inv(U) * F * b  =>  x = P' * inv(U) * F * b.
-*
-*  On entry the array x contains right-hand side vector b. On exit this
-*  array contains solution vector x. */
-
-static void solve(SCF *scf, double x[])
-{     int n = scf->n;
-      double *f = scf->f;
-      double *u = scf->u;
-      int *p = scf->p;
-      double *y = scf->w;
-      int i, j, ij;
-      double t;
-      /* y := F * b */
-      for (i = 1; i <= n; i++)
-      {  /* y[i] = (i-th row of F) * b */
-         t = 0.0;
-         for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)
-            t += f[ij] * x[j];
-         y[i] = t;
-      }
-      /* y := inv(U) * y */
-      for (i = n; i >= 1; i--)
-      {  t = y[i];
-         for (j = n, ij = u_loc(scf, i, n); j > i; j--, ij--)
-            t -= u[ij] * y[j];
-         y[i] = t / u[ij];
+         {  /* matrix U is not well conditioned, because its diagonal
+             * element u[t,t] = v[p,q] is too small in magnitude */
+            return 2;
+         }
+         else
+         {  /* normal case */
+            return 0;
+         }
       }
-      /* x := P' * y */
-      for (i = 1; i <= n; i++) x[p[i]] = y[i];
-      return;
-}
-
-/***********************************************************************
-*  The routine tsolve solves the transposed system C' * x = b.
-*
-*  From the main equation F * C = U * P it follows that:
-*
-*     C' * F' = P' * U',
-*
-*  therefore:
-*
-*     C' * x = b  =>  C' * F' * inv(F') * x = b  =>
-*
-*     P' * U' * inv(F') * x = b  =>  U' * inv(F') * x = P * b  =>
-*
-*     inv(F') * x = inv(U') * P * b  =>  x = F' * inv(U') * P * b.
-*
-*  On entry the array x contains right-hand side vector b. On exit this
-*  array contains solution vector x. */
-
-static void tsolve(SCF *scf, double x[])
-{     int n = scf->n;
-      double *f = scf->f;
-      double *u = scf->u;
-      int *p = scf->p;
-      double *y = scf->w;
-      int i, j, ij;
-      double t;
-      /* y := P * b */
-      for (i = 1; i <= n; i++) y[i] = x[p[i]];
-      /* y := inv(U') * y */
-      for (i = 1; i <= n; i++)
-      {  /* compute y[i] */
-         ij = u_loc(scf, i, i);
-         t = (y[i] /= u[ij]);
-         /* substitute y[i] in other equations */
-         for (j = i+1, ij++; j <= n; j++, ij++)
-            y[j] -= u[ij] * t;
+      /*--------------------------------------------------------------*/
+      /* copy p-th row of matrix V, which is t-th row of matrix U, to */
+      /* working array                                                */
+      /*--------------------------------------------------------------*/
+      /* copy p-th row of matrix V, including element v[p,q] = u[t,t],
+       * to the working array in dense format and remove these elements
+       * from matrix V; since no pivoting is used, only this row will
+       * change during elimination */
+      for (j = 1; j <= n; j++)
+         work[j] = 0.0;
+      work[q] = vpq;
+      for (p_end = (p_ptr = vr_ptr[p]) + vr_len[p];
+         p_ptr < p_end; p_ptr++)
+      {  /* get column index of v[p,j] and store this element to the
+          * working array */
+         work[j = sv_ind[p_ptr]] = sv_val[p_ptr];
+         /* find and remove v[p,j] from j-th column */
+         for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];
+            sv_ind[j_ptr] != p; j_ptr++)
+            /* nop */;
+         xassert(j_ptr < j_end);
+         sv_ind[j_ptr] = sv_ind[j_end-1];
+         sv_val[j_ptr] = sv_val[j_end-1];
+         vc_len[j]--;
       }
-      /* x := F' * y (computed as linear combination of rows of F) */
-      for (j = 1; j <= n; j++) x[j] = 0.0;
-      for (i = 1; i <= n; i++)
-      {  t = y[i]; /* coefficient of linear combination */
-         for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)
-            x[j] += f[ij] * t;
+      /* now p-th row of matrix V is temporarily empty */
+      vr_len[p] = 0;
+      /*--------------------------------------------------------------*/
+      /* perform gaussian elimination                                 */
+      /*--------------------------------------------------------------*/
+      /* transform p-th row of matrix V stored in working array, which
+       * is t-th row of matrix U, to eliminate subdiagonal elements
+       * u[t,s], ..., u[t,t-1]; corresponding gaussian multipliers will
+       * form non-trivial row of new row-like factor */
+      nnz = 0; /* number of non-zero gaussian multipliers */
+      for (k = s; k < t; k++)
+      {  /* diagonal element u[k,k] = v[i,j] is used as pivot */
+         i = pp_inv[k], j = qq_ind[k];
+         /* take subdiagonal element u[t,k] = v[p,j] */
+         temp = work[j];
+#if 1 /* FIXME */
+         if (-eps_tol < temp && temp < +eps_tol)
+            continue;
+#endif
+         /* compute and save gaussian multiplier:
+          * f := u[t,k] / u[k,k] = v[p,j] / v[i,j] */
+         ind[++nnz] = i;
+         val[nnz] = f = work[j] / vr_piv[i];
+         /* gaussian transformation to eliminate u[t,k] = v[p,j]:
+          * (p-th row of V) := (p-th row of V) - f * (i-th row of V) */
+         for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];
+            i_ptr < i_end; i_ptr++)
+            work[sv_ind[i_ptr]] -= f * sv_val[i_ptr];
       }
-      return;
+      /* now matrix U is again upper triangular */
+#if 1 /* FIXME */
+      if (-vpq_tol < work[q] && work[q] < +vpq_tol)
+#endif
+      {  /* however, its new diagonal element u[t,t] = v[p,q] is too
+          * small in magnitude */
+         return 3;
+      }
+      /*--------------------------------------------------------------*/
+      /* create new row-like factor H[k] and add to eta file H        */
+      /*--------------------------------------------------------------*/
+      /* (nnz = 0 means that all subdiagonal elements were too small
+       * in magnitude) */
+      if (nnz > 0)
+      {  if (fhv->nfs == fhv->nfs_max)
+         {  /* maximal number of row-like factors has been reached */
+            return 4;
+         }
+         k = ++(fhv->nfs);
+         hh_ind[k] = p;
+         /* store non-trivial row of H[k] in right (dynamic) part of
+          * SVA (diagonal unity element is not stored) */
+         if (sva->r_ptr - sva->m_ptr < nnz)
+         {  sva_more_space(sva, nnz);
+            sv_ind = sva->ind;
+            sv_val = sva->val;
+         }
+         sva_reserve_cap(sva, fhv->hh_ref-1+k, nnz);
+         ptr = hh_ptr[k];
+         memcpy(&sv_ind[ptr], &ind[1], nnz * sizeof(int));
+         memcpy(&sv_val[ptr], &val[1], nnz * sizeof(double));
+         hh_len[k] = nnz;
+      }
+      /*--------------------------------------------------------------*/
+      /* copy transformed p-th row of matrix V, which is t-th row of  */
+      /* matrix U, from working array back to matrix V                */
+      /*--------------------------------------------------------------*/
+      /* copy elements of transformed p-th row of matrix V, which are
+       * non-diagonal elements u[t,t+1], ..., u[t,n] of matrix U, from
+       * working array to corresponding columns of matrix V (note that
+       * diagonal element u[t,t] = v[p,q] not copied); also transform
+       * p-th row of matrix V to sparse format */
+      len = 0;
+      for (k = t+1; k <= n; k++)
+      {  /* j-th column of V = k-th column of U */
+         j = qq_ind[k];
+         /* take non-diagonal element v[p,j] = u[t,k] */
+         temp = work[j];
+#if 1 /* FIXME */
+         if (-eps_tol < temp && temp < +eps_tol)
+            continue;
+#endif
+         /* add v[p,j] to j-th column of matrix V */
+         if (vc_cap[j] == vc_len[j])
+         {  /* reserve extra locations in j-th column to reduce further
+             * relocations of that column */
+#if 1 /* FIXME */
+            int need = vc_len[j] + 5;
+#endif
+            if (sva->r_ptr - sva->m_ptr < need)
+            {  sva_more_space(sva, need);
+               sv_ind = sva->ind;
+               sv_val = sva->val;
+            }
+            sva_enlarge_cap(sva, vc_ref-1+j, need, 0);
+         }
+         sv_ind[ptr = vc_ptr[j] + (vc_len[j]++)] = p;
+         sv_val[ptr] = temp;
+         /* store element v[p,j] = u[t,k] to working sparse vector */
+         ind[++len] = j;
+         val[len] = temp;
+      }
+      /* copy elements from working sparse vector to p-th row of matrix
+       * V (this row is currently empty) */
+      if (vr_cap[p] < len)
+      {  if (sva->r_ptr - sva->m_ptr < len)
+         {  sva_more_space(sva, len);
+            sv_ind = sva->ind;
+            sv_val = sva->val;
+         }
+         sva_enlarge_cap(sva, vr_ref-1+p, len, 0);
+      }
+      ptr = vr_ptr[p];
+      memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));
+      memcpy(&sv_val[ptr], &val[1], len * sizeof(double));
+      vr_len[p] = len;
+      /* store new diagonal element u[t,t] = v[p,q] */
+      vr_piv[p] = work[q];
+      /*--------------------------------------------------------------*/
+      /* perform accuracy test (only if new H[k] was added)           */
+      /*--------------------------------------------------------------*/
+      if (nnz > 0)
+      {  /* copy p-th (non-trivial) row of row-like factor H[k] (except
+          * unity diagonal element) to working array in dense format */
+         for (j = 1; j <= n; j++)
+            work[j] = 0.0;
+         k = fhv->nfs;
+         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)
+            work[sv_ind[ptr]] = sv_val[ptr];
+         /* compute inner product of p-th (non-trivial) row of matrix
+          * H[k] and q-th column of matrix V */
+         temp = vr_piv[p]; /* 1 * v[p,q] */
+         ptr = vc_ptr[q];
+         end = ptr + vc_len[q];
+         for (; ptr < end; ptr++)
+            temp += work[sv_ind[ptr]] * sv_val[ptr];
+         /* inner product should be equal to element v[p,q] *before*
+          * matrix V was transformed */
+         /* compute relative error */
+         temp = fabs(vpq - temp) / (1.0 + fabs(vpq));
+#if 1 /* FIXME */
+         if (temp > err_tol)
+#endif
+         {  /* relative error is too large */
+            return 5;
+         }
+      }
+      /* factorization has been successfully updated */
+      return 0;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  scf_solve_it - solve either system C * x = b or C' * x = b
-*
-*  SYNOPSIS
-*
-*  #include "glpscf.h"
-*  void scf_solve_it(SCF *scf, int tr, double x[]);
+*  fhv_h_solve - solve system H * x = b
 *
-*  DESCRIPTION
-*
-*  The routine scf_solve_it solves either the system C * x = b (if tr
-*  is zero) or the system C' * x = b, where C' is a matrix transposed
-*  to C (if tr is non-zero). C is assumed to be non-singular.
-*
-*  On entry the array x should contain the right-hand side vector b in
-*  locations x[1], ..., x[n], where n is the order of matrix C. On exit
-*  the array x contains the solution vector x in the same locations. */
-
-void scf_solve_it(SCF *scf, int tr, double x[])
-{     if (scf->rank < scf->n)
-         xfault("scf_solve_it: singular matrix\n");
-      if (!tr)
-         solve(scf, x);
-      else
-         tsolve(scf, x);
-      return;
-}
-
-void scf_reset_it(SCF *scf)
-{     /* reset factorization for empty matrix C */
-      scf->n = scf->rank = 0;
+*  This routine solves the system H * x = b, where the matrix H is the
+*  middle factor of the sparse updatable FHV-factorization.
+*
+*  On entry the array x should contain elements of the right-hand side
+*  vector b in locations x[1], ..., x[n], where n is the order of the
+*  matrix H. On exit this array will contain elements of the solution
+*  vector x in the same locations. */
+
+void fhv_h_solve(FHV *fhv, double x[/*1+n*/])
+{     SVA *sva = fhv->luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int nfs = fhv->nfs;
+      int *hh_ind = fhv->hh_ind;
+      int hh_ref = fhv->hh_ref;
+      int *hh_ptr = &sva->ptr[hh_ref-1];
+      int *hh_len = &sva->len[hh_ref-1];
+      int i, k, end, ptr;
+      double x_i;
+      for (k = 1; k <= nfs; k++)
+      {  x_i = x[i = hh_ind[k]];
+         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)
+            x_i -= sv_val[ptr] * x[sv_ind[ptr]];
+         x[i] = x_i;
+      }
       return;
 }
 
 /***********************************************************************
-*  NAME
-*
-*  scf_delete_it - delete Schur complement factorization
-*
-*  SYNOPSIS
-*
-*  #include "glpscf.h"
-*  void scf_delete_it(SCF *scf);
+*  fhv_ht_solve - solve system H' * x = b
 *
-*  DESCRIPTION
-*
-*  The routine scf_delete_it deletes the specified factorization and
-*  frees all the memory allocated to this object. */
-
-void scf_delete_it(SCF *scf)
-{     xfree(scf->f);
-      xfree(scf->u);
-      xfree(scf->p);
-#if _GLPSCF_DEBUG
-      xfree(scf->c);
-#endif
-      xfree(scf->w);
-      xfree(scf);
+*  This routine solves the system H' * x = b, where H' is a matrix
+*  transposed to the matrix H, which is the middle factor of the sparse
+*  updatable FHV-factorization.
+*
+*  On entry the array x should contain elements of the right-hand side
+*  vector b in locations x[1], ..., x[n], where n is the order of the
+*  matrix H. On exit this array will contain elements of the solution
+*  vector x in the same locations. */
+
+void fhv_ht_solve(FHV *fhv, double x[/*1+n*/])
+{     SVA *sva = fhv->luf->sva;
+      int *sv_ind = sva->ind;
+      double *sv_val = sva->val;
+      int nfs = fhv->nfs;
+      int *hh_ind = fhv->hh_ind;
+      int hh_ref = fhv->hh_ref;
+      int *hh_ptr = &sva->ptr[hh_ref-1];
+      int *hh_len = &sva->len[hh_ref-1];
+      int k, end, ptr;
+      double x_j;
+      for (k = nfs; k >= 1; k--)
+      {  if ((x_j = x[hh_ind[k]]) == 0.0)
+            continue;
+         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)
+            x[sv_ind[ptr]] -= sv_val[ptr] * x_j;
+      }
       return;
 }
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpscl.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpscl.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpscl.c */
+/* glpscl.c (problem scaling routines) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2000-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,17 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpapi.h"
+#include "env.h"
+#include "misc.h"
+#include "prob.h"
 
 /***********************************************************************
 *  min_row_aij - determine minimal |a[i,j]| in i-th row
 *
 *  This routine returns minimal magnitude of (non-zero) constraint
 *  coefficients in i-th row of the constraint matrix.
 *
@@ -186,15 +185,15 @@
 *                        j=1
 *
 *  This makes the infinity (maximum) norm of each row of the matrix
 *  equal to 1.
 *
 *  Columns are scaled as follows:
 *
-*                         n
+*                         m
 *     a'[i,j] = a[i,j] / max |a[i,j]|,  j = 1,...,n.
 *                        i=1
 *
 *  This makes the infinity (maximum) norm of each column of the matrix
 *  equal to 1. */
 
 static void eq_scaling(glp_prob *lp, int flag)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/spm.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpspm.c */
+/* glpspm.c (general sparse matrices) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2004-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,17 +15,18 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glphbm.h"
-#include "glprgr.h"
-#include "glpspm.h"
+#include "env.h"
+#include "hbm.h"
+#include "rgr.h"
+#include "spm.h"
 
 /***********************************************************************
 *  NAME
 *
 *  spm_create_mat - create general sparse matrix
 *
 *  SYNOPSIS
@@ -261,15 +259,15 @@
 *  an appropriate error message and returns non-zero. */
 
 int spm_show_mat(const SPM *A, const char *fname)
 {     int m = A->m;
       int n = A->n;
       int i, j, k, ret;
       char *map;
-      xprintf("spm_show_mat: writing matrix pattern to `%s'...\n",
+      xprintf("spm_show_mat: writing matrix pattern to '%s'...\n",
          fname);
       xassert(1 <= m && m <= 32767);
       xassert(1 <= n && n <= 32767);
       map = xmalloc(m * n);
       memset(map, 0x08, m * n);
       for (i = 1; i <= m; i++)
       {  SPME *e;
@@ -341,15 +339,15 @@
       nnzero = hbm->nnzero;
       colptr = hbm->colptr;
       rowind = hbm->rowind;
       values = hbm->values;
       if (!(strcmp(mxtype, "RSA") == 0 || strcmp(mxtype, "PSA") == 0 ||
             strcmp(mxtype, "RUA") == 0 || strcmp(mxtype, "PUA") == 0 ||
             strcmp(mxtype, "RRA") == 0 || strcmp(mxtype, "PRA") == 0))
-      {  xprintf("spm_read_hbm: matrix type `%s' not supported\n",
+      {  xprintf("spm_read_hbm: matrix type '%s' not supported\n",
             mxtype);
          goto fini;
       }
       A = spm_create_mat(nrow, ncol);
       if (mxtype[1] == 'S' || mxtype[1] == 'U')
          xassert(nrow == ncol);
       for (j = 1; j <= ncol; j++)
@@ -481,18 +479,18 @@
 #else
 SPM *spm_read_mat(const char *fname)
 {     SPM *A = NULL;
       PDS *pds;
       jmp_buf jump;
       int i, j, k, m, n, nnz, fail = 0;
       double val;
-      xprintf("spm_read_mat: reading matrix from `%s'...\n", fname);
+      xprintf("spm_read_mat: reading matrix from '%s'...\n", fname);
       pds = pds_open_file(fname);
       if (pds == NULL)
-      {  xprintf("spm_read_mat: unable to open `%s' - %s\n", fname,
+      {  xprintf("spm_read_mat: unable to open '%s' - %s\n", fname,
             strerror(errno));
          fail = 1;
          goto done;
       }
       if (setjmp(jump))
       {  fail = 1;
          goto done;
@@ -577,18 +575,18 @@
       xassert(fname != fname);
       return 0;
 }
 #else
 int spm_write_mat(const SPM *A, const char *fname)
 {     FILE *fp;
       int i, nnz, ret = 0;
-      xprintf("spm_write_mat: writing matrix to `%s'...\n", fname);
+      xprintf("spm_write_mat: writing matrix to '%s'...\n", fname);
       fp = fopen(fname, "w");
       if (fp == NULL)
-      {  xprintf("spm_write_mat: unable to create `%s' - %s\n", fname,
+      {  xprintf("spm_write_mat: unable to create '%s' - %s\n", fname,
             strerror(errno));
          ret = 1;
          goto done;
       }
       /* number of rows, number of columns, number of non-zeros */
       nnz = spm_count_nnz(A);
       fprintf(fp, "%d %d %d\n", A->m, A->n, nnz);
@@ -599,15 +597,15 @@
          for (e = A->row[i]; e != NULL; e = e->r_next)
          {  /* row index, column index, element value */
             fprintf(fp, "%d %d %.*g\n", e->i, e->j, DBL_DIG, e->val);
          }
       }
       fflush(fp);
       if (ferror(fp))
-      {  xprintf("spm_write_mat: writing error on `%s' - %s\n", fname,
+      {  xprintf("spm_write_mat: writing error on '%s' - %s\n", fname,
             strerror(errno));
          ret = 1;
          goto done;
       }
       xprintf("spm_write_mat: %d lines were written\n", 1 + nnz);
 done: if (fp != NULL) fclose(fp);
       return ret;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspm.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/misc/spm.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpspm.h (general sparse matrix) */
+/* spm.h (general sparse matrices) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2004-2018 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,18 +15,18 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPSPM_H
-#define GLPSPM_H
+#ifndef SPM_H
+#define SPM_H
 
-#include "glpdmp.h"
+#include "dmp.h"
 
 typedef struct SPM SPM;
 typedef struct SPME SPME;
 
 struct SPM
 {     /* general sparse matrix */
       int m;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpspx.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/simplex/spxprob.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpspx.h (core simplex solvers) */
+/* spxprob.h */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2015 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,23 +15,48 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPSPX_H
-#define GLPSPX_H
+#ifndef SPXPROB_H
+#define SPXPROB_H
 
-#include "glpapi.h"
+#include "prob.h"
+#include "spxlp.h"
 
-#define spx_primal _glp_spx_primal
-int spx_primal(glp_prob *lp, const glp_smcp *parm);
-/* core LP solver based on the primal simplex method */
-
-#define spx_dual _glp_spx_dual
-int spx_dual(glp_prob *lp, const glp_smcp *parm);
-/* core LP solver based on the dual simplex method */
+#define spx_init_lp _glp_spx_init_lp
+void spx_init_lp(SPXLP *lp, glp_prob *P, int excl);
+/* initialize working LP object */
+
+#define spx_alloc_lp _glp_spx_alloc_lp
+void spx_alloc_lp(SPXLP *lp);
+/* allocate working LP arrays */
+
+#define spx_build_lp _glp_spx_build_lp
+void spx_build_lp(SPXLP *lp, glp_prob *P, int excl, int shift,
+      int map[/*1+P->m+P->n*/]);
+/* convert original LP to working LP */
+
+#define spx_build_basis _glp_spx_build_basis
+void spx_build_basis(SPXLP *lp, glp_prob *P, const int map[]);
+/* convert original LP basis to working LP basis */
+
+#define spx_store_basis _glp_spx_store_basis
+void spx_store_basis(SPXLP *lp, glp_prob *P, const int map[],
+      int daeh[/*1+n*/]);
+/* convert working LP basis to original LP basis */
+
+#define spx_store_sol _glp_spx_store_sol
+void spx_store_sol(SPXLP *lp, glp_prob *P, int shift,
+      const int map[], const int daeh[], const double beta[],
+      const double pi[], const double d[]);
+/* convert working LP solution to original LP solution */
+
+#define spx_free_lp _glp_spx_free_lp
+void spx_free_lp(SPXLP *lp);
+/* deallocate working LP arrays */
 
 #endif
 
 /* eof */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpsql.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mplsql.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,13 @@
-/* glpsql.c */
+/* mplsql.c */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Author: Heinrich Schuchardt <xypron.glpk@gmx.de>.
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2017 Free Software Foundation, Inc.
+*  Written by Heinrich Schuchardt <xypron.glpk@gmx.de>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -20,24 +15,20 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wunused-function"
-#endif
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "glpmpl.h"
-#include "glpsql.h"
+#include "mpl.h"
+#include "mplsql.h"
 
 #ifdef ODBC_DLNAME
 #define HAVE_ODBC
 #define libodbc ODBC_DLNAME
 #define h_odbc (get_env_ptr()->h_odbc)
 #endif
 
@@ -86,19 +77,18 @@
 static char **args_concat(TABDCA *dca)
 {
    const char  *arg;
    int          i;
    int          j;
    int          j0;
    int          j1;
-   int          len;
+   size_t       len;
    int          lentot;
    int          narg;
    int          nline = 0;
-   void        *ret;
    char       **sqllines = NULL;
 
    narg = mpl_tab_num_args(dca);
    /* The SQL statements start with argument 3. */
    if (narg < 3)
       return NULL;
    /* Count the SQL statements */
@@ -116,18 +106,22 @@
    j0     = 3;
    i      = 0;
    lentot = 0;
    for (j = 3; j <= narg; j++)
    {
       arg = mpl_tab_get_arg(dca, j);
       len = strlen(arg);
+      /* add length of part */
       lentot += len;
+      /* add length of space separating parts or 0x00 at end of SQL
+         statement */
+      lentot++;
       if (arg[len-1] == ';' || j == narg)
       {  /* Join arguments for a single SQL statement */
-         sqllines[i] = xmalloc(lentot+1);
+         sqllines[i] = xmalloc(lentot);
          sqllines[i+1] = NULL;
          sqllines[i][0] = 0x00;
          for (j1 = j0; j1 <= j; j1++)
          {  if(j1>j0)
                strcat(sqllines[i], " ");
             strcat(sqllines[i], mpl_tab_get_arg(dca, j1));
          }
@@ -180,20 +174,20 @@
             break;
       }
     }
 
     return count;
 }
 
-static int db_escape_string (char *to, const char *from)
+static void db_escape_string (char *to, const char *from)
 /* escape string*/
 {
    const char *source = from;
    char *target = to;
-   unsigned int remaining;
+   size_t remaining;
 
    remaining = strlen(from);
 
    if (to == NULL)
      to = (char *) (from + remaining);
 
    while (remaining > 0)
@@ -212,16 +206,14 @@
       source++;
       target++;
       remaining--;
       }
 
    /* Write the terminating NUL character. */
    *target = '\0';
-
-   return target - to;
 }
 
 static char *db_generate_select_stmt(TABDCA *dca)
 /* generate select statement */
 {
    char        *arg;
    char const  *field;
@@ -347,14 +339,17 @@
    SQLHENV          henv;         /*environment handle*/
    SQLHSTMT         hstmt;        /*statement handle*/
    SQLSMALLINT      nresultcols;  /* columns in result*/
    SQLULEN          collen[SQL_FIELD_MAX+1];
    SQLLEN           outlen[SQL_FIELD_MAX+1];
    SQLSMALLINT      coltype[SQL_FIELD_MAX+1];
    SQLCHAR          data[SQL_FIELD_MAX+1][SQL_FDLEN_MAX+1];
+#if 1 /* 12/I-2014 */
+   SQLDOUBLE        datanum[SQL_FIELD_MAX+1];
+#endif
    SQLCHAR          colname[SQL_FIELD_MAX+1][SQL_FDLEN_MAX+1];
    int              isnumeric[SQL_FIELD_MAX+1];
    int              nf;
    /* number of fields in the csv file */
    int              ref[1+SQL_FIELD_MAX];
    /* ref[k] = k', if k-th field of the csv file corresponds to
       k'-th field in the table statement; if ref[k] = 0, k-th field
@@ -650,15 +645,15 @@
 /***********************************************************************
 *  NAME
 *
 *  db_iodbc_open - open connection to ODBC data base
 *
 *  SYNOPSIS
 *
-*  #include "glpsql.h"
+*  #include "mplsql.h"
 *  void *db_iodbc_open(TABDCA *dca, int mode);
 *
 *  DESCRIPTION
 *
 *  The routine db_iodbc_open opens a connection to an ODBC data base.
 *  It then executes the sql statements passed.
 *
@@ -705,15 +700,15 @@
    }
 
    if (h_odbc == NULL)
    {
       h_odbc = xdlopen(libodbc);
       if (h_odbc == NULL)
       {  xprintf("unable to open library %s\n", libodbc);
-         xprintf("%s\n", xerrmsg());
+         xprintf("%s\n", get_err_msg());
          return NULL;
       }
    }
 
    sql = (struct db_odbc *) xmalloc(sizeof(struct db_odbc));
    if (sql == NULL)
          return NULL;
@@ -840,16 +835,25 @@
       {  /* return a set of attributes for a column */
          ret = dl_SQLDescribeCol(sql->hstmt, (SQLSMALLINT) i,
             sql->colname[i], SQL_FDLEN_MAX,
             &colnamelen, &(sql->coltype[i]), &(sql->collen[i]), &scale,
             &nullable);
          sql->isnumeric[i] = is_numeric(sql->coltype[i]);
          /* bind columns to program vars, converting all types to CHAR*/
-         dl_SQLBindCol(sql->hstmt, i, SQL_CHAR, sql->data[i],
-            SQL_FDLEN_MAX, &(sql->outlen[i]));
+         if (sql->isnumeric[i])
+#if 0 /* 12/I-2014 */
+         {  dl_SQLBindCol(sql->hstmt, i, SQL_DOUBLE, sql->data[i],
+#else
+         {  dl_SQLBindCol(sql->hstmt, i, SQL_DOUBLE, &sql->datanum[i],
+#endif
+               SQL_FDLEN_MAX, &(sql->outlen[i]));
+         } else
+         {  dl_SQLBindCol(sql->hstmt, i, SQL_CHAR, sql->data[i],
+               SQL_FDLEN_MAX, &(sql->outlen[i]));
+         }
          for (j = sql->nf; j >= 1; j--)
          {  if (strcmp(mpl_tab_get_name(dca, j), sql->colname[i]) == 0)
             break;
          }
          sql->ref[i] = j;
       }
    }
@@ -893,31 +897,30 @@
    for (i=1; i <= sql->nresultcols; i++)
    {
       if (sql->ref[i] > 0)
       {
          len = sql->outlen[i];
          if (len != SQL_NULL_DATA)
          {
-            if (len > SQL_FDLEN_MAX)
-               len = SQL_FDLEN_MAX;
-            else if (len < 0)
-               len = 0;
-            strncpy(buf, (const char *) sql->data[i], len);
-            buf[len] = 0x00;
-            if (0 != (sql->isnumeric[i]))
-            {  strspx(buf); /* remove spaces*/
-               if (str2num(buf, &num) != 0)
-               {  xprintf("'%s' cannot be converted to a number.\n",
-                     buf);
-                  return 1;
-               }
-               mpl_tab_set_num(dca, sql->ref[i], num);
+            if (sql->isnumeric[i])
+            {  mpl_tab_set_num(dca, sql->ref[i],
+#if 0 /* 12/I-2014 */
+                               *((const double *) sql->data[i]));
+#else
+                               (const double) sql->datanum[i]);
+#endif
             }
             else
-            {  mpl_tab_set_str(dca, sql->ref[i], strtrim(buf));
+            {  if (len > SQL_FDLEN_MAX)
+                  len = SQL_FDLEN_MAX;
+               else if (len < 0)
+                  len = 0;
+               strncpy(buf, (const char *) sql->data[i], len);
+               buf[len] = 0x00;
+               mpl_tab_set_str(dca, sql->ref[i], strtrim(buf));
             }
          }
       }
    }
    return 0;
 }
 
@@ -952,16 +955,21 @@
             break;
               default:
                         xassert(dca != dca);
          }
    }
    query = xmalloc( (len + 1 ) * sizeof(char) );
    query[0] = 0x00;
+#if 0 /* 29/I-2017 */
    for (k = 1, part = strtok (template, "?"); (part != NULL);
       part = strtok (NULL, "?"), k++)
+#else
+   for (k = 1, part = xstrtok (template, "?"); (part != NULL);
+      part = xstrtok (NULL, "?"), k++)
+#endif
    {
       if (k > nf) break;
       strcat( query, part );
       switch (mpl_tab_get_type(dca, k))
       {  case 'N':
 #if 0 /* 02/XI-2010 by xypron */
             sprintf(num, "%-18g",mpl_tab_get_num(dca, k));
@@ -1102,16 +1110,18 @@
 #include <windows.h>
 #endif
 
 #ifdef __CYGWIN__
 #define byte_defined 1
 #endif
 
+#if 0 /* 12/II-2014; to fix namespace bug */
 #include <my_global.h>
 #include <my_sys.h>
+#endif
 #include <mysql.h>
 
 struct db_mysql
 {
    int              mode;  /*'R' = Read, 'W' = Write*/
    MYSQL           *con;   /*connection*/
    MYSQL_RES       *res;    /*result*/
@@ -1255,15 +1265,15 @@
 /***********************************************************************
 *  NAME
 *
 *  db_mysql_open - open connection to ODBC data base
 *
 *  SYNOPSIS
 *
-*  #include "glpsql.h"
+*  #include "mplsql.h"
 *  void *db_mysql_open(TABDCA *dca, int mode);
 *
 *  DESCRIPTION
 *
 *  The routine db_mysql_open opens a connection to a MySQL data base.
 *  It then executes the sql statements passed.
 *
@@ -1317,15 +1327,15 @@
    }
 
    if (h_mysql == NULL)
    {
       h_mysql = xdlopen(libmysql);
       if (h_mysql == NULL)
       {  xprintf("unable to open library %s\n", libmysql);
-         xprintf("%s\n", xerrmsg());
+         xprintf("%s\n", get_err_msg());
          return NULL;
       }
    }
 
    sql = (struct db_mysql *) xmalloc(sizeof(struct db_mysql));
    if (sql == NULL)
          return NULL;
@@ -1342,18 +1352,27 @@
    dsn = (char *) mpl_tab_get_arg(dca, 2);
       /* copy connection string*/
    i = strlen(dsn);
    i++;
    arg = xmalloc(i * sizeof(char));
    strcpy(arg, dsn);
    /*tokenize connection string*/
+#if 0 /* 29/I-2017 */
    for (i = 1, keyword = strtok (arg, "="); (keyword != NULL);
       keyword = strtok (NULL, "="), i++)
+#else
+   for (i = 1, keyword = xstrtok (arg, "="); (keyword != NULL);
+      keyword = xstrtok (NULL, "="), i++)
+#endif
    {
+#if 0 /* 29/I-2017 */
          value = strtok (NULL, ";");
+#else
+         value = xstrtok (NULL, ";");
+#endif
       if (value==NULL)
          {
             xprintf("db_mysql_open: Missing value for keyword %s\n",
                keyword);
             xfree(arg);
             xfree(sql);
             return NULL;
@@ -1568,16 +1587,21 @@
             break;
               default:
                         xassert(dca != dca);
          }
    }
    query = xmalloc( (len + 1 ) * sizeof(char) );
    query[0] = 0x00;
+#if 0 /* 29/I-2017 */
    for (k = 1, part = strtok (template, "?"); (part != NULL);
       part = strtok (NULL, "?"), k++)
+#else
+   for (k = 1, part = xstrtok (template, "?"); (part != NULL);
+      part = xstrtok (NULL, "?"), k++)
+#endif
    {
       if (k > nf) break;
       strcat( query, part );
       switch (mpl_tab_get_type(dca, k))
       {  case 'N':
 #if 0 /* 02/XI-2010 by xypron */
             sprintf(num, "%-18g",mpl_tab_get_num(dca, k));
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpsql.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/mpl/mplsql.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,18 +1,13 @@
-/* glpsql.h */
+/* mplsql.h */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Author: Heinrich Schuchardt <heinrich.schuchardt@gmx.de>.
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2016 Free Software Foundation, Inc.
+*  Written by Heinrich Schuchardt <xypron.glpk@gmx.de>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -20,16 +15,16 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifndef GLPSQL_H
-#define GLPSQL_H
+#ifndef MPLSQL_H
+#define MPLSQL_H
 
 #define db_iodbc_open _glp_db_iodbc_open
 void *db_iodbc_open(TABDCA *dca, int mode);
 /* open iODBC database connection */
 
 #define db_iodbc_read _glp_db_iodbc_read
 int db_iodbc_read(TABDCA *dca, void *link);
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpssx.h` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpssx.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpssx.h (simplex method, bignum arithmetic) */
+/* glpssx.h (simplex method, rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -21,16 +18,19 @@
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
 #ifndef GLPSSX_H
 #define GLPSSX_H
 
-#include "glpbfx.h"
-#include "glpenv.h"
+#include "bfx.h"
+#include "env.h"
+#if 1 /* 25/XI-2017 */
+#include "glpk.h"
+#endif
 
 typedef struct SSX SSX;
 
 struct SSX
 {     /* simplex solver workspace */
 /*----------------------------------------------------------------------
 // LP PROBLEM DATA
@@ -301,14 +301,22 @@
       int p_stat;
       /* non-basic status which should be assigned to basic variable
          xB[p] when it has left the basis and become xN[q] */
       mpq_t delta;
       /* actual change of xN[q] in the adjacent basis (it has the same
          sign as q_dir) */
 /*--------------------------------------------------------------------*/
+#if 1 /* 25/XI-2017 */
+      int msg_lev;
+      /* verbosity level:
+         GLP_MSG_OFF no output
+         GLP_MSG_ERR report errors and warnings
+         GLP_MSG_ON  normal output
+         GLP_MSG_ALL highest verbosity */
+#endif
       int it_lim;
       /* simplex iterations limit; if this value is positive, it is
          decreased by one each time when one simplex iteration has been
          performed, and reaching zero value signals the solver to stop
          the search; negative value means no iterations limit */
       int it_cnt;
       /* simplex iterations count; this count is increased by one each
@@ -319,18 +327,26 @@
          performed by the amount of time spent for the iteration, and
          reaching zero value signals the solver to stop the search;
          negative value means no time limit */
       double out_frq;
       /* output frequency, in seconds; this parameter specifies how
          frequently the solver sends information about the progress of
          the search to the standard output */
+#if 0 /* 10/VI-2013 */
       glp_long tm_beg;
+#else
+      double tm_beg;
+#endif
       /* starting time of the search, in seconds; the total time of the
          search is the difference between xtime() and tm_beg */
+#if 0 /* 10/VI-2013 */
       glp_long tm_lag;
+#else
+      double tm_lag;
+#endif
       /* the most recent time, in seconds, at which the progress of the
          the search was displayed */
 };
 
 #define ssx_create            _glp_ssx_create
 #define ssx_factorize         _glp_ssx_factorize
 #define ssx_get_xNj           _glp_ssx_get_xNj
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpssx01.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpssx01.c`

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpssx01.c */
+/* glpssx01.c (simplex method, rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,20 +15,15 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
-#pragma clang diagnostic ignored "-Wunused-value"
-#endif
-
-#include "glpenv.h"
+#include "env.h"
 #include "glpssx.h"
 #define xfault xerror
 
 /*----------------------------------------------------------------------
 // ssx_create - create simplex solver workspace.
 //
 // This routine creates the workspace used by simplex solver routines,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/glpk/glpssx02.c` & `igraph-0.9.9/vendor/source/igraph/vendor/glpk/draft/glpssx02.c`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-/* glpssx02.c */
+/* glpssx02.c (simplex method, rational arithmetic) */
 
 /***********************************************************************
 *  This code is part of GLPK (GNU Linear Programming Kit).
-*
-*  Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-*  2009, 2010 Andrew Makhorin, Department for Applied Informatics,
-*  Moscow Aviation Institute, Moscow, Russia. All rights reserved.
-*  E-mail: <mao@gnu.org>.
+*  Copyright (C) 2003-2013 Free Software Foundation, Inc.
+*  Written by Andrew Makhorin <mao@gnu.org>.
 *
 *  GLPK is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  GLPK is distributed in the hope that it will be useful, but WITHOUT
@@ -18,15 +15,15 @@
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with GLPK. If not, see <http://www.gnu.org/licenses/>.
 ***********************************************************************/
 
-#include "glpenv.h"
+#include "env.h"
 #include "glpssx.h"
 
 static void show_progress(SSX *ssx, int phase)
 {     /* this auxiliary routine displays information about progress of
          the search */
       int i, def = 0;
       for (i = 1; i <= ssx->m; i++)
@@ -128,18 +125,24 @@
       /* now the initial basic solution should be primal feasible due
          to changes of bounds of some basic variables, which turned to
          implicit artifical variables */
       /* compute simplex multipliers and reduced costs */
       ssx_eval_pi(ssx);
       ssx_eval_cbar(ssx);
       /* display initial progress of the search */
+#if 1 /* 25/XI-2017 */
+      if (ssx->msg_lev >= GLP_MSG_ON)
+#endif
       show_progress(ssx, 1);
       /* main loop starts here */
       for (;;)
       {  /* display current progress of the search */
+#if 1 /* 25/XI-2017 */
+         if (ssx->msg_lev >= GLP_MSG_ON)
+#endif
 #if 0
          if (utime() - ssx->tm_lag >= ssx->out_frq - 0.001)
 #else
          if (xdifftime(xtime(), ssx->tm_lag) >= ssx->out_frq - 0.001)
 #endif
             show_progress(ssx, 1);
          /* we do not need to wait until all artificial variables have
@@ -239,14 +242,17 @@
          /* jump to the adjacent vertex of the polyhedron */
          ssx_change_basis(ssx);
          /* one simplex iteration has been performed */
          if (ssx->it_lim > 0) ssx->it_lim--;
          ssx->it_cnt++;
       }
       /* display final progress of the search */
+#if 1 /* 25/XI-2017 */
+      if (ssx->msg_lev >= GLP_MSG_ON)
+#endif
       show_progress(ssx, 1);
       /* restore components of the original problem, which were changed
          by the routine */
       for (k = 1; k <= m+n; k++)
       {  type[k] = orig_type[k];
          mpq_set(lb[k], orig_lb[k]);
          mpq_clear(orig_lb[k]);
@@ -278,18 +284,24 @@
 // 2 - iterations limit exceeded;
 // 3 - time limit exceeded.
 ----------------------------------------------------------------------*/
 
 int ssx_phase_II(SSX *ssx)
 {     int ret;
       /* display initial progress of the search */
+#if 1 /* 25/XI-2017 */
+      if (ssx->msg_lev >= GLP_MSG_ON)
+#endif
       show_progress(ssx, 2);
       /* main loop starts here */
       for (;;)
       {  /* display current progress of the search */
+#if 1 /* 25/XI-2017 */
+         if (ssx->msg_lev >= GLP_MSG_ON)
+#endif
 #if 0
          if (utime() - ssx->tm_lag >= ssx->out_frq - 0.001)
 #else
          if (xdifftime(xtime(), ssx->tm_lag) >= ssx->out_frq - 0.001)
 #endif
             show_progress(ssx, 2);
          /* check if the iterations limit has been exhausted */
@@ -343,14 +355,17 @@
          /* jump to the adjacent vertex of the polyhedron */
          ssx_change_basis(ssx);
          /* one simplex iteration has been performed */
          if (ssx->it_lim > 0) ssx->it_lim--;
          ssx->it_cnt++;
       }
       /* display final progress of the search */
+#if 1 /* 25/XI-2017 */
+      if (ssx->msg_lev >= GLP_MSG_ON)
+#endif
       show_progress(ssx, 2);
       /* return to the calling program */
       return ret;
 }
 
 /*----------------------------------------------------------------------
 // ssx_driver - base driver to exact simplex method.
@@ -377,15 +392,20 @@
       mpq_t *ub = ssx->ub;
       int *Q_col = ssx->Q_col;
       mpq_t *bbar = ssx->bbar;
       int i, k, ret;
       ssx->tm_beg = xtime();
       /* factorize the initial basis matrix */
       if (ssx_factorize(ssx))
+#if 0 /* 25/XI-2017 */
       {  xprintf("Initial basis matrix is singular\n");
+#else
+      {  if (ssx->msg_lev >= GLP_MSG_ERR)
+            xprintf("Initial basis matrix is singular\n");
+#endif
          ret = 7;
          goto done;
       }
       /* compute values of basic variables */
       ssx_eval_bbar(ssx);
       /* check if the initial basic solution is primal feasible */
       for (i = 1; i <= m; i++)
@@ -415,22 +435,31 @@
       /* phase I: find primal feasible solution */
       ret = ssx_phase_I(ssx);
       switch (ret)
       {  case 0:
             ret = 0;
             break;
          case 1:
+#if 1 /* 25/XI-2017 */
+            if (ssx->msg_lev >= GLP_MSG_ALL)
+#endif
             xprintf("PROBLEM HAS NO FEASIBLE SOLUTION\n");
             ret = 1;
             break;
          case 2:
+#if 1 /* 25/XI-2017 */
+            if (ssx->msg_lev >= GLP_MSG_ALL)
+#endif
             xprintf("ITERATIONS LIMIT EXCEEDED; SEARCH TERMINATED\n");
             ret = 3;
             break;
          case 3:
+#if 1 /* 25/XI-2017 */
+            if (ssx->msg_lev >= GLP_MSG_ALL)
+#endif
             xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
             ret = 5;
             break;
          default:
             xassert(ret != ret);
       }
       /* compute values of basic variables (actually only the objective
@@ -442,26 +471,38 @@
       ssx_eval_cbar(ssx);
       /* if phase I failed, do not start phase II */
       if (ret != 0) goto done;
       /* phase II: find optimal solution */
       ret = ssx_phase_II(ssx);
       switch (ret)
       {  case 0:
+#if 1 /* 25/XI-2017 */
+            if (ssx->msg_lev >= GLP_MSG_ALL)
+#endif
             xprintf("OPTIMAL SOLUTION FOUND\n");
             ret = 0;
             break;
          case 1:
+#if 1 /* 25/XI-2017 */
+            if (ssx->msg_lev >= GLP_MSG_ALL)
+#endif
             xprintf("PROBLEM HAS UNBOUNDED SOLUTION\n");
             ret = 2;
             break;
          case 2:
+#if 1 /* 25/XI-2017 */
+            if (ssx->msg_lev >= GLP_MSG_ALL)
+#endif
             xprintf("ITERATIONS LIMIT EXCEEDED; SEARCH TERMINATED\n");
             ret = 4;
             break;
          case 3:
+#if 1 /* 25/XI-2017 */
+            if (ssx->msg_lev >= GLP_MSG_ALL)
+#endif
             xprintf("TIME LIMIT EXCEEDED; SEARCH TERMINATED\n");
             ret = 6;
             break;
          default:
             xassert(ret != ret);
       }
 done: /* decrease the time limit by the spent amount of time */
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dasum.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dasum.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/daxpy.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/daxpy.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dcopy.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dcopy.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/ddot.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/ddot.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgebak.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgebak.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgebal.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgebal.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgeev.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgeev.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgeevx.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgeevx.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgehd2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgehd2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgehrd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgehrd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgemm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgemm.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgemv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgemv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgeqr2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgeqr2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dger.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dger.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgesv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgesv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetf2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetf2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetrf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetrf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetrs.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetrs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dgetv0.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dgetv0.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dhseqr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dhseqr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/disnan.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/disnan.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlabad.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlabad.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlacn2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlacn2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlacpy.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlacpy.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dladiv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dladiv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlae2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlae2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaebz.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaebz.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaev2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaev2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaexc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaexc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlagtf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlagtf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlagts.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlagts.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlahqr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlahqr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlahr2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlahr2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaisnan.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaisnan.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaln2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaln2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlamch.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlamch.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaneg.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaneg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlange.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlange.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlanhs.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlanhs.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlanst.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlanst.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlansy.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlansy.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlanv2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlanv2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlapy2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlapy2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr0.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr0.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr1.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr1.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr3.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr4.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr4.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqr5.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqr5.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqrb.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqrb.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaqtr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaqtr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlar1v.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlar1v.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarfb.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarfb.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarfg.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarfg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarft.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarft.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarfx.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarfx.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarnv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarnv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarra.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarra.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrb.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrb.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarre.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarre.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrj.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrj.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrk.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrk.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlarrv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlarrv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlartg.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlartg.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaruv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaruv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlascl.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlascl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaset.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaset.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq3.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq3.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq4.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq4.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq5.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq5.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasq6.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasq6.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasrt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasrt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlassq.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlassq.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlaswp.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlaswp.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlasy2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlasy2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dlatrd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dlatrd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dmout.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dmout.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnaitr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnaitr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnapps.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnapps.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnaup2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnaup2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnaupd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnaupd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnconv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnconv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dneigh.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dneigh.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dneupd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dneupd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dngets.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dngets.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dnrm2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dnrm2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorg2r.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorg2r.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorghr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorghr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorgqr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorgqr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorm2l.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorm2l.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dorm2r.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dorm2r.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormhr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormhr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormql.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormql.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormqr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormqr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dormtr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dormtr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dpotf2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dpotf2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dpotrf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dpotrf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/drot.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/drot.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsaitr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsaitr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsapps.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsapps.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsaup2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsaup2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsaupd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsaupd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dscal.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dscal.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsconv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsconv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dseigt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dseigt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsesrt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsesrt.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dseupd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dseupd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsgets.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsgets.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsortc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsortc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsortr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsortr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstatn.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstatn.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstats.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstats.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstebz.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstebz.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstein.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstein.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstemr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstemr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsteqr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsteqr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsterf.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsterf.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dstqrb.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dstqrb.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dswap.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dswap.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyevr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyevr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsymv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsymv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyr2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyr2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyr2k.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyr2k.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsyrk.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsyrk.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsytd2.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsytd2.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dsytrd.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dsytrd.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrevc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrevc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrexc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrexc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrmm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrmm.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrmv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrmv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsen.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsen.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsm.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsm.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsna.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsna.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dtrsyl.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dtrsyl.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/dvout.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/dvout.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/fortran_intrinsics.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/fortran_intrinsics.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/idamax.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/idamax.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/ieeeck.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/ieeeck.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/iladlc.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/iladlc.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/iladlr.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/iladlr.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/ilaenv.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/ilaenv.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/iparmq.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/iparmq.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/ivout.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/ivout.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/len_trim.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/len_trim.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/lsame.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/lsame.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/second.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/second.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/lapack/xerbla.c` & `igraph-0.9.9/vendor/source/igraph/vendor/lapack/xerbla.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/mini-gmp/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/vendor/mini-gmp/CMakeLists.txt`

 * *Files 18% similar despite different names*

```diff
@@ -6,14 +6,16 @@
   mini-gmp.c
 )
 
 target_include_directories(
   gmp_vendored
   PRIVATE
   ${CMAKE_CURRENT_SOURCE_DIR}
+  ${PROJECT_SOURCE_DIR}/include
+  ${PROJECT_BINARY_DIR}/include
 )
 
 if (BUILD_SHARED_LIBS)
   set_property(TARGET gmp_vendored PROPERTY POSITION_INDEPENDENT_CODE ON)
 endif()
 
 use_all_warnings(gmp_vendored)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/mini-gmp/mini-gmp.c` & `igraph-0.9.9/vendor/source/igraph/vendor/mini-gmp/mini-gmp.c`

 * *Files 0% similar despite different names*

```diff
@@ -50,14 +50,16 @@
 
 #include "mini-gmp.h"
 
 #if !defined(MINI_GMP_DONT_USE_FLOAT_H)
 #include <float.h>
 #endif
 
+#include "igraph_error.h"
+
 
 /* Macros */
 #define GMP_LIMB_BITS (sizeof(mp_limb_t) * CHAR_BIT)
 
 #define GMP_LIMB_MAX ((mp_limb_t) ~ (mp_limb_t) 0)
 #define GMP_LIMB_HIGHBIT ((mp_limb_t) 1 << (GMP_LIMB_BITS - 1))
 
@@ -274,16 +276,19 @@
 const int mp_bits_per_limb = GMP_LIMB_BITS;
 
 
 /* Memory allocation and other helper functions. */
 static void
 gmp_die (const char *msg)
 {
+  /*
   fprintf (stderr, "%s\n", msg);
   abort();
+  */
+  IGRAPH_FATAL(msg);
 }
 
 static void *
 gmp_default_alloc (size_t size)
 {
   void *p;
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/mini-gmp/mini-gmp.h` & `igraph-0.9.9/vendor/source/igraph/vendor/mini-gmp/mini-gmp.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/CMakeLists.txt` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/CMakeLists.txt`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-# Declare the files needed to compile plfit
+# Declare the files needed to compile our vendored plfit copy
 add_library(
-  plfit
+  plfit_vendored
   OBJECT
   EXCLUDE_FROM_ALL
   gss.c
   hzeta.c
   kolmogorov.c
   lbfgs.c
   mt.c
@@ -13,30 +13,35 @@
   plfit.c
   plfit_error.c
   rbinom.c
   sampling.c
 )
 
 target_include_directories(
-  plfit
+  plfit_vendored
   PRIVATE
   ${PROJECT_SOURCE_DIR}/include
   ${PROJECT_BINARY_DIR}/include
+  PUBLIC
+  ${CMAKE_CURRENT_SOURCE_DIR}
 )
 
 if (BUILD_SHARED_LIBS)
-  set_property(TARGET plfit PROPERTY POSITION_INDEPENDENT_CODE ON)
+  set_property(TARGET plfit_vendored PROPERTY POSITION_INDEPENDENT_CODE ON)
 endif()
 
 # Since these are included as object files, they should call the
 # function as is (without visibility specification)
-target_compile_definitions(plfit PRIVATE IGRAPH_STATIC)
+target_compile_definitions(plfit_vendored PRIVATE IGRAPH_STATIC)
 
-use_all_warnings(plfit)
+use_all_warnings(plfit_vendored)
 
 if (MSVC)
-  target_compile_options(plfit PRIVATE /wd4100) # disable unreferenced parameter warning
+  target_compile_options(
+    plfit_vendored PRIVATE
+    /wd4100
+  ) # disable unreferenced parameter warning
 endif()
 
 if(IGRAPH_OPENMP_SUPPORT)
-  target_link_libraries(plfit PRIVATE OpenMP::OpenMP_C)
+  target_link_libraries(plfit_vendored PRIVATE OpenMP::OpenMP_C)
 endif()
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/arithmetic_ansi.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/arithmetic_ansi.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/arithmetic_sse_double.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/arithmetic_sse_double.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/arithmetic_sse_float.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/arithmetic_sse_float.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/error.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_error.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* error.h
+/* plfit_error.h
  *
  * Copyright (C) 2010-2011 Tamas Nepusz
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or (at
  * your option) any later version.
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/gss.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/gss.c`

 * *Files 2% similar despite different names*

```diff
@@ -16,15 +16,15 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
 #include <float.h>
 #include <math.h>
 #include <string.h>
-#include "error.h"
+#include "plfit_error.h"
 #include "gss.h"
 #include "platform.h"
 
 /**
  * \def PHI
  *
  * The golden ratio, i.e. 1+sqrt(5)/2
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/gss.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/gss.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/hzeta.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/hzeta.c`

 * *Files 1% similar despite different names*

```diff
@@ -45,16 +45,16 @@
 #ifdef _MSC_VER
 #define _USE_MATH_DEFINES
 #endif
 
 #include <math.h>
 #include <stdio.h>
 #include "hzeta.h"
-#include "error.h"
-#include "platform.h"
+#include "plfit_error.h"
+#include "platform.h"   /* because of NAN */
 
 /* imported from gsl_machine.h */
 
 #define GSL_LOG_DBL_MIN (-7.0839641853226408e+02)
 #define GSL_LOG_DBL_MAX 7.0978271289338397e+02
 #define GSL_DBL_EPSILON 2.2204460492503131e-16
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/hzeta.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/hzeta.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/kolmogorov.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/kolmogorov.c`

 * *Files 5% similar despite different names*

```diff
@@ -54,13 +54,13 @@
         return 2*(r[0] - r[1] + r[2] - r[3]);
     }
 
     return 0;
 }
 
 double plfit_ks_test_one_sample_p(double d, size_t n) {
-    return plfit_kolmogorov(d * sqrt(n));
+    return plfit_kolmogorov(d * sqrt((double) n));
 }
 
 double plfit_ks_test_two_sample_p(double d, size_t n1, size_t n2) {
     return plfit_kolmogorov(d * sqrt(n1*n2 / ((double)(n1+n2))));
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/kolmogorov.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/kolmogorov.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/lbfgs.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/lbfgs.c`

 * *Files 0% similar despite different names*

```diff
@@ -70,14 +70,15 @@
 #endif
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 
 #include "lbfgs.h"
+#include "platform.h"
 
 #ifdef  _MSC_VER
 #define inline  __inline
 typedef unsigned int uint32_t;
 #endif/*_MSC_VER*/
 
 #if     defined(USE_SSE) && defined(__SSE2__) && LBFGS_FLOAT == 64
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/lbfgs.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/lbfgs.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/mt.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/mt.c`

 * *Files 18% similar despite different names*

```diff
@@ -11,70 +11,70 @@
  * This file has been placed in the public domain.
  */
 
 #include <stdlib.h>
 
 #include "igraph_random.h"
 
-#include "mt.h"
+#include "plfit_mt.h"
 
 static uint16_t get_random_uint16() {
     return RNG_INT31() & 0xFFFF;
 }
 
-void mt_init(mt_rng_t* rng) {
-    mt_init_from_rng(rng, 0);
+void plfit_mt_init(plfit_mt_rng_t* rng) {
+    plfit_mt_init_from_rng(rng, 0);
 }
 
-void mt_init_from_rng(mt_rng_t* rng, mt_rng_t* seeder) {
+void plfit_mt_init_from_rng(plfit_mt_rng_t* rng, plfit_mt_rng_t* seeder) {
     int i;
 
     if (seeder == 0) {
-        for (i = 0; i < MT_LEN; i++) {
+        for (i = 0; i < PLFIT_MT_LEN; i++) {
             /* RAND_MAX is guaranteed to be at least 32767, so we can use two
              * calls to rand() to produce a random 32-bit number */
             rng->mt_buffer[i] = (get_random_uint16() << 16) + get_random_uint16();
         }
     } else {
-        for (i = 0; i < MT_LEN; i++) {
-            rng->mt_buffer[i] = mt_random(seeder);
+        for (i = 0; i < PLFIT_MT_LEN; i++) {
+            rng->mt_buffer[i] = plfit_mt_random(seeder);
         }
     }
 
     rng->mt_index = 0;
 }
 
 #define MT_IA           397
-#define MT_IB           (MT_LEN - MT_IA)
+#define MT_IB           (PLFIT_MT_LEN - MT_IA)
 #define UPPER_MASK      0x80000000
 #define LOWER_MASK      0x7FFFFFFF
 #define MATRIX_A        0x9908B0DF
 #define TWIST(b,i,j)    ((b)[i] & UPPER_MASK) | ((b)[j] & LOWER_MASK)
 #define MAGIC(s)        (((s)&1)*MATRIX_A)
 
-uint32_t mt_random(mt_rng_t* rng) {
+uint32_t plfit_mt_random(plfit_mt_rng_t* rng) {
     uint32_t * b = rng->mt_buffer;
     int idx = rng->mt_index;
     uint32_t s;
     int i;
 	
-    if (idx == MT_LEN * sizeof(uint32_t)) {
+    if (idx == PLFIT_MT_LEN * sizeof(uint32_t)) {
         idx = 0;
         i = 0;
         for (; i < MT_IB; i++) {
             s = TWIST(b, i, i+1);
             b[i] = b[i + MT_IA] ^ (s >> 1) ^ MAGIC(s);
         }
-        for (; i < MT_LEN-1; i++) {
+        for (; i < PLFIT_MT_LEN-1; i++) {
             s = TWIST(b, i, i+1);
             b[i] = b[i - MT_IB] ^ (s >> 1) ^ MAGIC(s);
         }
         
-        s = TWIST(b, MT_LEN-1, 0);
-        b[MT_LEN-1] = b[MT_IA-1] ^ (s >> 1) ^ MAGIC(s);
+        s = TWIST(b, PLFIT_MT_LEN-1, 0);
+        b[PLFIT_MT_LEN-1] = b[MT_IA-1] ^ (s >> 1) ^ MAGIC(s);
     }
 
     rng->mt_index = idx + sizeof(uint32_t);
     return *(uint32_t *)((unsigned char *)b + idx);
     /*
     Matsumoto and Nishimura additionally confound the bits returned to the caller
     but this doesn't increase the randomness, and slows down the generator by
@@ -84,12 +84,10 @@
     r ^= (r << 7) & 0x9D2C5680;
     r ^= (r << 15) & 0xEFC60000;
     r ^= (r >> 18);
     */
 }
 
 
-double mt_uniform_01(mt_rng_t* rng) {
-    return ((double)mt_random(rng)) / MT_RAND_MAX;
+double plfit_mt_uniform_01(plfit_mt_rng_t* rng) {
+    return ((double)plfit_mt_random(rng)) / PLFIT_MT_RAND_MAX;
 }
-
-
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/mt.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_mt.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-/* mt.h
+/* plfit_mt.h
  *
  * Mersenne Twister random number generator, based on the implementation of
  * Michael Brundage (which has been placed in the public domain).
  *
  * Author: Tamas Nepusz (original by Michael Brundage)
  *
  * See the following URL for the original implementation:
  * http://www.qbrundage.com/michaelb/pubs/essays/random_number_generation.html
  *
  * This file has been placed in the public domain.
  */
 
-#ifndef __MT_H__
-#define __MT_H__
+#ifndef __PLFIT_MT_H__
+#define __PLFIT_MT_H__
 
 /* VS 2010, i.e. _MSC_VER == 1600, already has stdint.h */
 #if defined(_MSC_VER) && _MSC_VER < 1600
-#  define uint32_t __int32
+#  define uint32_t unsigned __int32
 #else
 #  include <stdint.h>
 #endif
 
 #undef __BEGIN_DECLS
 #undef __END_DECLS
 #ifdef __cplusplus
@@ -29,75 +29,73 @@
 #else
 # define __BEGIN_DECLS /* empty */
 # define __END_DECLS /* empty */
 #endif
 
 __BEGIN_DECLS
 
-#define MT_LEN       624
+#define PLFIT_MT_LEN       624
 
 /**
- * \def MT_RAND_MAX
+ * \def PLFIT_MT_RAND_MAX
  *
- * The maximum random number that \c mt_random() can generate.
+ * The maximum random number that \c plfit_mt_random() can generate.
  */
-#define MT_RAND_MAX 0xFFFFFFFF
+#define PLFIT_MT_RAND_MAX 0xFFFFFFFF
 
 /**
  * Struct that stores the internal state of a Mersenne Twister random number
  * generator.
  */
 typedef struct {
     int mt_index;
-    uint32_t mt_buffer[MT_LEN];
-} mt_rng_t;
+    uint32_t mt_buffer[PLFIT_MT_LEN];
+} plfit_mt_rng_t;
 
 /**
  * \brief Initializes a Mersenne Twister random number generator.
  *
  * The random number generator is seeded with random 32-bit numbers obtained
  * from the \em built-in random number generator using consecutive calls to
  * \c rand().
  *
  * \param  rng  the random number generator to initialize
  */
-void mt_init(mt_rng_t* rng);
+void plfit_mt_init(plfit_mt_rng_t* rng);
 
 /**
  * \brief Initializes a Mersenne Twister random number generator, seeding it
  *        from another one.
  *
  * The random number generator is seeded with random 32-bit numbers obtained
  * from another, initialized Mersenne Twister random number generator.
  *
  * \param  rng     the random number generator to initialize
  * \param  seeder  the random number generator that will seed the one being
  *                 initialized. When null, the random number generator will
- *                 be initialized from the built-in RNG as if \ref mt_init()
+ *                 be initialized from the built-in RNG as if \ref plfit_mt_init()
  *                 was called.
  */
-void mt_init_from_rng(mt_rng_t* rng, mt_rng_t* seeder);
+void plfit_mt_init_from_rng(plfit_mt_rng_t* rng, plfit_mt_rng_t* seeder);
 
 /**
  * \brief Returns the next 32-bit random number from the given Mersenne Twister
  * random number generator.
  *
  * \param  rng  the random number generator to use
  * \return the next 32-bit random number from the generator
  */
-uint32_t mt_random(mt_rng_t* rng);
+uint32_t plfit_mt_random(plfit_mt_rng_t* rng);
 
 /**
  * \brief Returns a uniformly distributed double from the interval [0;1)
  * based on the next value of the given Mersenne Twister random number
  * generator.
  *
  * \param  rng  the random number generator to use
  * \return a uniformly distributed random number from the interval [0;1)
  */
-double mt_uniform_01(mt_rng_t* rng);
+double plfit_mt_uniform_01(plfit_mt_rng_t* rng);
 
 __END_DECLS
 
 #endif
-
-
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/options.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/options.c`

 * *Files 1% similar despite different names*

```diff
@@ -13,15 +13,15 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
-#include "error.h"
+#include "plfit_error.h"
 #include "plfit.h"
 
 const plfit_continuous_options_t plfit_continuous_default_options = {
     /* .finite_size_correction = */ 0,
     /* .xmin_method = */ PLFIT_DEFAULT_CONTINUOUS_METHOD,
     /* .p_value_method = */ PLFIT_DEFAULT_P_VALUE_METHOD,
     /* .p_value_precision = */ 0.01,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/platform.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/platform.c`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/platform.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/platform.h`

 * *Files identical despite different names*

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/plfit.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit.c`

 * *Files 1% similar despite different names*

```diff
@@ -20,21 +20,21 @@
 
 #include <stdio.h>
 #include <float.h>
 #include <math.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
-#include "error.h"
+#include "plfit_error.h"
 #include "gss.h"
 #include "lbfgs.h"
 #include "platform.h"
 #include "plfit.h"
 #include "kolmogorov.h"
-#include "sampling.h"
+#include "plfit_sampling.h"
 #include "hzeta.h"
 
 /* #define PLFIT_DEBUG */
 
 #define DATA_POINTS_CHECK \
     if (n <= 0) { \
         PLFIT_ERROR("no data points", PLFIT_EINVAL); \
@@ -46,18 +46,18 @@
     }
 #define XMIN_CHECK_ONE \
     if (xmin < 1) { \
         PLFIT_ERROR("xmin must be at least 1", PLFIT_EINVAL); \
     }
 
 static int plfit_i_resample_continuous(double* xs_head, size_t num_smaller,
-        size_t n, double alpha, double xmin, size_t num_samples, mt_rng_t* rng,
+        size_t n, double alpha, double xmin, size_t num_samples, plfit_mt_rng_t* rng,
         double* result);
 static int plfit_i_resample_discrete(double* xs_head, size_t num_smaller,
-        size_t n, double alpha, double xmin, size_t num_samples, mt_rng_t* rng,
+        size_t n, double alpha, double xmin, size_t num_samples, plfit_mt_rng_t* rng,
         double* result);
 
 static int double_comparator(const void *a, const void *b) {
     const double *da = (const double*)a;
     const double *db = (const double*)b;
     return (*da > *db) - (*da < *db);
 }
@@ -137,15 +137,16 @@
 /**
  * Given a sorted array of doubles, return another array that contains pointers
  * into the array for the start of each block of identical elements.
  *
  * \param  begin          pointer to the beginning of the array
  * \param  end            pointer to the first element after the end of the array
  * \param  result_length  if not \c NULL, the number of unique elements in the
- *                        given array is returned here
+ *                        given array is returned here. It is left unchanged if
+ *                        the function returns with an error.
  *
  * \return pointer to the head of the new array or 0 if there is not enough
  * memory
  */
 static double** unique_element_pointers(double* begin, double* end, size_t* result_length) {
     double* ptr = begin;
     double** result;
@@ -154,14 +155,17 @@
     size_t used_elts = 0;
 
     /* Special case: empty array */
     if (begin == end) {
         result = calloc(1, sizeof(double*));
         if (result != 0) {
             result[0] = 0;
+            if (result_length != 0) {
+                *result_length = 0;
+            }
         }
         return result;
     }
 
     /* Allocate initial result array, including the guard element */
     result = calloc(num_elts+1, sizeof(double*));
     if (result == 0)
@@ -324,26 +328,26 @@
     {
         /* Parallel section starts here. If we are compiling using OpenMP, each
          * thread will use its own RNG that is seeded from the master RNG. If
          * we are compiling without OpenMP, there is only one thread and it uses
          * the master RNG. This section must be critical to ensure that only one
          * thread is using the master RNG at the same time. */
 #ifdef _OPENMP
-        mt_rng_t private_rng;
+        plfit_mt_rng_t private_rng;
 #endif
-        mt_rng_t *p_rng;
+        plfit_mt_rng_t *p_rng;
         double *ys;
         long int i;
         plfit_result_t result_synthetic;
 
 #ifdef _OPENMP
 #pragma omp critical
         {
             p_rng = &private_rng;
-            mt_init_from_rng(p_rng, options->rng);
+            plfit_mt_init_from_rng(p_rng, options->rng);
         }
 #else
         p_rng = options->rng;
 #endif
 
         /* Allocate memory to sample into */
         ys = calloc(n, sizeof(double));
@@ -479,18 +483,18 @@
     /* Continue only if `left' and `right' point to different integers */
     return (int)left == (int)right;
 }
 
 static int plfit_i_continuous_xmin_opt_linear_scan(
         plfit_continuous_xmin_opt_data_t* opt_data, plfit_result_t* best_result,
         size_t* best_n) {
-    /* i must be signed, otherwise OpenMP on Windows will complain as it
-     * supports signed types only. ssize_t is a POSIX extension so it won't
-     * work */
-    ptrdiff_t i = 0; /* initialize to work around incorrect warning issued by clang 9.0 */
+    /* this must be signed because OpenMP with Windows MSVC needs signed for
+     * loop index variables. ssize_t will not work because that is a POSIX
+     * extension */
+    ptrdiff_t i = 0; /* initialize to work around incorrect warning issued by Clang 9.0 */
     plfit_result_t global_best_result;
     size_t global_best_n;
 
     /* Prepare some variables */
     global_best_n = 0;
     global_best_result.D = DBL_MAX;
     global_best_result.xmin = 0;
@@ -514,15 +518,16 @@
         size_t local_best_n;
 
         /* Initialize the local_best_result and local_best_n variables */
         local_best_n = 0;
         local_best_result.D = DBL_MAX;
         local_best_result.xmin = 0;
         local_best_result.alpha = 0;
-        local_best_result.p = 0;
+        local_best_result.p = NAN;
+        local_best_result.L = NAN;
 
         /* The range of the for loop below is divided among the threads.
          * nowait means that there will be no implicit barrier at the end
          * of the loop so threads that get there earlier can enter the
          * critical section without waiting for the others */
 #ifdef _OPENMP
 #pragma omp for nowait schedule(dynamic,10)
@@ -625,22 +630,27 @@
                 /* Try stratified sampling to narrow down the interval where the minimum
                  * is likely to reside. We check 10% of the unique items, distributed
                  * evenly, find the one with the lowest D-score, and then check the
                  * area around it more thoroughly. */
                 const size_t subdivision_length = 10;
                 size_t num_strata = num_uniques / subdivision_length;
                 double **strata = calloc(num_strata, sizeof(double*));
+                int error_code;
 
                 for (i = 0; i < num_strata; i++) {
                     strata[i] = uniques[i * subdivision_length];
                 }
 
                 opt_data.probes = strata;
                 opt_data.num_probes = num_strata;
-                plfit_i_continuous_xmin_opt_linear_scan(&opt_data, &best_result, &best_n);
+                error_code = plfit_i_continuous_xmin_opt_linear_scan(&opt_data, &best_result, &best_n);
+                if (error_code != PLFIT_SUCCESS) {
+                    free(strata);
+                    return error_code;
+                }
 
                 opt_data.num_probes = 0;
                 for (i = 0; i < num_strata; i++) {
                     if (*strata[i] == best_result.xmin) {
                         /* Okay, scan more thoroughly from strata[i-1] to strata[i+1],
                          * which is from uniques[(i-1)*subdivision_length] to
                          * uniques[(i+1)*subdivision_length */
@@ -653,16 +663,19 @@
                         break;
                     }
                 }
 
                 free(strata);
                 if (opt_data.num_probes > 0) {
                     /* Do a strict linear scan in the subrange determined above */
-                    plfit_i_continuous_xmin_opt_linear_scan(&opt_data,
-                            &best_result, &best_n);
+                    PLFIT_CHECK(
+                        plfit_i_continuous_xmin_opt_linear_scan(
+                            &opt_data, &best_result, &best_n
+                        )
+                    ); 
                     success = 1;
                 } else {
                     /* This should not happen, but we handle it anyway */
                     success = 0;
                 }
             }
             break;
@@ -672,15 +685,15 @@
             break;
     }
 
     if (!success) {
         /* More advanced search methods failed or were skipped; try linear search */
         opt_data.probes = uniques;
         opt_data.num_probes = num_uniques;
-        plfit_i_continuous_xmin_opt_linear_scan(&opt_data, &best_result, &best_n);
+        PLFIT_CHECK(plfit_i_continuous_xmin_opt_linear_scan(&opt_data, &best_result, &best_n));
         success = 1;
     }
 
     /* Get rid of the uniques array, we don't need it any more */
     free(uniques);
 
     /* Sort out the result */
@@ -1005,26 +1018,26 @@
     {
         /* Parallel section starts here. If we are compiling using OpenMP, each
          * thread will use its own RNG that is seeded from the master RNG. If
          * we are compiling without OpenMP, there is only one thread and it uses
          * the master RNG. This section must be critical to ensure that only one
          * thread is using the master RNG at the same time. */
 #ifdef _OPENMP
-        mt_rng_t private_rng;
+        plfit_mt_rng_t private_rng;
 #endif
-        mt_rng_t *p_rng;
+        plfit_mt_rng_t *p_rng;
         double *ys;
         long int i;
         plfit_result_t result_synthetic;
 
 #ifdef _OPENMP
 #pragma omp critical
         {
             p_rng = &private_rng;
-            mt_init_from_rng(p_rng, options->rng);
+            plfit_mt_init_from_rng(p_rng, options->rng);
         }
 #else
         p_rng = options->rng;
 #endif
 
         /* Allocate memory to sample into */
         ys = calloc(n, sizeof(double));
@@ -1154,32 +1167,47 @@
     PLFIT_CHECK(plfit_i_copy_and_sort(xs, n, &xs_copy));
 
     best_result.D = DBL_MAX;
     best_result.xmin = 1;
     best_result.alpha = 1;
     best_n = 0;
 
+    /* Skip initial values from xs_copy until we get to a positive element or
+     * until we reach the end of the array */
+    px = xs_copy; end = px + n; end_xmin = end - 1;
+    while (px < end && *px < 1) {
+        px++;
+    }
+
     /* Make sure there are at least three distinct values if possible */
-    px = xs_copy; end = px + n; end_xmin = end - 1; m = 0;
+    m = px - xs_copy;
     prev_x = *end_xmin;
-    while (*end_xmin == prev_x && end_xmin > px)
+    while (end_xmin > px && *end_xmin == prev_x) {
         end_xmin--;
+    }
     prev_x = *end_xmin;
-    while (*end_xmin == prev_x && end_xmin > px)
+    while (end_xmin > px && *end_xmin == prev_x) {
         end_xmin--;
+    }
 
     prev_x = 0;
+    end_xmin++;
     while (px < end_xmin) {
         while (px < end_xmin && *px == prev_x) {
             px++; m++;
         }
 
-        plfit_i_estimate_alpha_discrete(px, n-m, *px, &curr_alpha, options,
-                /* sorted = */ 1);
-        plfit_i_ks_test_discrete(px, end, curr_alpha, *px, &curr_D);
+        PLFIT_CHECK(
+            plfit_i_estimate_alpha_discrete(
+                px, n-m, *px, &curr_alpha, options, /* sorted = */ 1
+            )
+        );
+        PLFIT_CHECK(
+            plfit_i_ks_test_discrete(px, end, curr_alpha, *px, &curr_D)
+        );
 
         if (curr_D < best_result.D) {
             best_result.alpha = curr_alpha;
             best_result.xmin = *px;
             best_result.D = curr_D;
             best_n = n-m;
         }
@@ -1200,15 +1228,15 @@
 
     return PLFIT_SUCCESS;
 }
 
 /***** resampling routines to generate synthetic replicates ****/
 
 static int plfit_i_resample_continuous(double* xs_head, size_t num_smaller,
-        size_t n, double alpha, double xmin, size_t num_samples, mt_rng_t* rng,
+        size_t n, double alpha, double xmin, size_t num_samples, plfit_mt_rng_t* rng,
         double* result)
 {
     size_t num_orig_samples, i;
 
     /* Calculate how many samples have to be drawn from xs_head */
     num_orig_samples = (size_t) plfit_rbinom(num_samples, num_smaller / (double)n, rng);
 
@@ -1221,15 +1249,15 @@
     PLFIT_CHECK(plfit_rpareto_array(xmin, alpha-1, num_samples-num_orig_samples, rng,
             result));
 
     return PLFIT_SUCCESS;
 }
 
 int plfit_resample_continuous(double* xs, size_t n, double alpha, double xmin,
-        size_t num_samples, mt_rng_t* rng, double* result) {
+        size_t num_samples, plfit_mt_rng_t* rng, double* result) {
     double *xs_head;
     size_t num_smaller = 0;
     int retval;
 
     /* Extract the head of xs that contains elements smaller than xmin */
     xs_head = extract_smaller(xs, xs+n, xmin, &num_smaller);
     if (xs_head == 0)
@@ -1241,15 +1269,15 @@
     /* Free xs_head; we don't need it any more */
     free(xs_head);
 
     return retval;
 }
 
 static int plfit_i_resample_discrete(double* xs_head, size_t num_smaller, size_t n,
-        double alpha, double xmin, size_t num_samples, mt_rng_t* rng,
+        double alpha, double xmin, size_t num_samples, plfit_mt_rng_t* rng,
         double* result)
 {
     size_t num_orig_samples, i;
 
     /* Calculate how many samples have to be drawn from xs_head */
     num_orig_samples = (size_t) plfit_rbinom(num_samples, num_smaller / (double)n, rng);
 
@@ -1262,15 +1290,15 @@
     PLFIT_CHECK(plfit_rzeta_array((long int)xmin, alpha,
                 num_samples-num_orig_samples, rng, result));
 
     return PLFIT_SUCCESS;
 }
 
 int plfit_resample_discrete(double* xs, size_t n, double alpha, double xmin,
-        size_t num_samples, mt_rng_t* rng, double* result) {
+        size_t num_samples, plfit_mt_rng_t* rng, double* result) {
     double *xs_head;
     size_t num_smaller = 0;
     int retval;
 
     /* Extract the head of xs that contains elements smaller than xmin */
     xs_head = extract_smaller(xs, xs+n, xmin, &num_smaller);
     if (xs_head == 0)
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/plfit.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit.h`

 * *Files 6% similar despite different names*

```diff
@@ -18,32 +18,29 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
 #ifndef __PLFIT_H__
 #define __PLFIT_H__
 
 #include <stdlib.h>
-#include "mt.h"
+#include "plfit_mt.h"
+#include "plfit_version.h"
 
 #undef __BEGIN_DECLS
 #undef __END_DECLS
 #ifdef __cplusplus
 # define __BEGIN_DECLS extern "C" {
 # define __END_DECLS }
 #else
 # define __BEGIN_DECLS /* empty */
 # define __END_DECLS /* empty */
 #endif
 
 __BEGIN_DECLS
 
-#define PLFIT_VERSION_MAJOR 0
-#define PLFIT_VERSION_MINOR 8
-#define PLFIT_VERSION_STRING "0.8"
-
 typedef unsigned short int plfit_bool_t;
 
 typedef enum {
     PLFIT_LINEAR_ONLY,
     PLFIT_STRATIFIED_SAMPLING,
     PLFIT_GSS_OR_LINEAR,
     PLFIT_DEFAULT_CONTINUOUS_METHOD = PLFIT_STRATIFIED_SAMPLING
@@ -74,28 +71,28 @@
 /********** structure that holds the options of plfit **********/
 
 typedef struct _plfit_continuous_options_t {
     plfit_bool_t finite_size_correction;
     plfit_continuous_method_t xmin_method;
     plfit_p_value_method_t p_value_method;
     double p_value_precision;
-    mt_rng_t* rng;
+    plfit_mt_rng_t* rng;
 } plfit_continuous_options_t;
 
 typedef struct _plfit_discrete_options_t {
     plfit_bool_t finite_size_correction;
     plfit_discrete_method_t alpha_method;
     struct {
         double min;
         double max;
         double step;
     } alpha;
     plfit_p_value_method_t p_value_method;
     double p_value_precision;
-    mt_rng_t* rng;
+    plfit_mt_rng_t* rng;
 } plfit_discrete_options_t;
 
 int plfit_continuous_options_init(plfit_continuous_options_t* options);
 int plfit_discrete_options_init(plfit_discrete_options_t* options);
 
 extern const plfit_continuous_options_t plfit_continuous_default_options;
 extern const plfit_discrete_options_t plfit_discrete_default_options;
@@ -116,17 +113,17 @@
 int plfit_log_likelihood_discrete(double* xs, size_t n, double alpha, double xmin, double* l);
 int plfit_discrete(double* xs, size_t n, const plfit_discrete_options_t* options,
         plfit_result_t* result);
 
 /***** resampling routines to generate synthetic replicates ****/
 
 int plfit_resample_continuous(double* xs, size_t n, double alpha, double xmin,
-        size_t num_samples, mt_rng_t* rng, double* result);
+        size_t num_samples, plfit_mt_rng_t* rng, double* result);
 int plfit_resample_discrete(double* xs, size_t n, double alpha, double xmin,
-        size_t num_samples, mt_rng_t* rng, double* result);
+        size_t num_samples, plfit_mt_rng_t* rng, double* result);
 
 /******** calculating the p-value of a fitted model only *******/
 
 int plfit_calculate_p_value_continuous(double* xs, size_t n,
         const plfit_continuous_options_t* options, plfit_bool_t xmin_fixed,
         plfit_result_t *result);
 int plfit_calculate_p_value_discrete(double* xs, size_t n,
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/plfit_error.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_error.c`

 * *Files 8% similar despite different names*

```diff
@@ -15,28 +15,28 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
 #include <stdio.h>
 #include <stdlib.h>
-#include "error.h"
+#include "plfit_error.h"
 #include "platform.h"
 
 static char *plfit_i_error_strings[] = {
     "No error",
     "Failed",
     "Invalid value",
     "Underflow",
     "Overflow",
     "Not enough memory"
 };
 
 #ifndef USING_R
-static plfit_error_handler_t* plfit_error_handler = plfit_error_handler_abort;
+static plfit_error_handler_t* plfit_error_handler = plfit_error_handler_printignore;
 #else
 /* This is overwritten, anyway */
 static plfit_error_handler_t* plfit_error_handler = plfit_error_handler_ignore;
 #endif
 
 const char* plfit_strerror(const int plfit_errno) {
   return plfit_i_error_strings[plfit_errno];
@@ -50,23 +50,14 @@
 
 void plfit_error(const char *reason, const char *file, int line,
         int plfit_errno) {
     plfit_error_handler(reason, file, line, plfit_errno);
 }
 
 #ifndef USING_R
-void plfit_error_handler_abort(const char *reason, const char *file, int line,
-        int plfit_errno) {
-    fprintf(stderr, "Error at %s:%i : %s, %s\n", file, line, reason,
-            plfit_strerror(plfit_errno));
-    abort();
-}
-#endif
-
-#ifndef USING_R
 void plfit_error_handler_printignore(const char *reason, const char *file, int line,
         int plfit_errno) {
     fprintf(stderr, "Error at %s:%i : %s, %s\n", file, line, reason,
             plfit_strerror(plfit_errno));
 }
 #endif
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/rbinom.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/rbinom.c`

 * *Files 0% similar despite different names*

```diff
@@ -40,20 +40,20 @@
  * better with plfit. The license of the original file applies to the
  * modifications as well.
  */
 
 #include <limits.h>
 #include <math.h>
 #include <stdlib.h>
-#include "sampling.h"
+#include "plfit_sampling.h"
 #include "platform.h"
 
 #define repeat for(;;)
 
-double plfit_rbinom(double nin, double pp, mt_rng_t* rng)
+double plfit_rbinom(double nin, double pp, plfit_mt_rng_t* rng)
 {
     /* FIXME: These should become THREAD_specific globals : */
 
     static double c, fm, npq, p1, p2, p3, p4, qn;
     static double xl, xll, xlr, xm, xr;
 
     static double psave = -1.0;
@@ -202,8 +202,7 @@
      }
   }
  finis:
     if (psave > 0.5)
 	 ix = n - ix;
   return (double)ix;
 }
-
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/sampling.c` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/sampling.c`

 * *Files 2% similar despite different names*

```diff
@@ -13,46 +13,47 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
+#include <limits.h>
 #include <math.h>
 
 #include "igraph_random.h"
 
-#include "error.h"
-#include "sampling.h"
+#include "plfit_error.h"
+#include "plfit_sampling.h"
 #include "platform.h"
 
-inline double plfit_runif(double lo, double hi, mt_rng_t* rng) {
+inline double plfit_runif(double lo, double hi, plfit_mt_rng_t* rng) {
     if (rng == 0) {
         return RNG_UNIF(lo, hi);
     }
-    return lo + mt_uniform_01(rng) * (hi-lo);
+    return lo + plfit_mt_uniform_01(rng) * (hi-lo);
 }
 
-inline double plfit_runif_01(mt_rng_t* rng) {
+inline double plfit_runif_01(plfit_mt_rng_t* rng) {
     if (rng == 0) {
         return RNG_UNIF01();
     }
-    return mt_uniform_01(rng);
+    return plfit_mt_uniform_01(rng);
 }
 
-inline double plfit_rpareto(double xmin, double alpha, mt_rng_t* rng) {
+inline double plfit_rpareto(double xmin, double alpha, plfit_mt_rng_t* rng) {
     if (alpha <= 0 || xmin <= 0)
         return NAN;
 
     /* 1-u is used in the base here because we want to avoid the case of
      * sampling zero */
     return pow(1-plfit_runif_01(rng), -1.0 / alpha) * xmin;
 }
 
-int plfit_rpareto_array(double xmin, double alpha, size_t n, mt_rng_t* rng,
+int plfit_rpareto_array(double xmin, double alpha, size_t n, plfit_mt_rng_t* rng,
         double* result) {
     double gamma;
 
     if (alpha <= 0 || xmin <= 0)
         return PLFIT_EINVAL;
 
     if (result == 0 || n == 0)
@@ -65,15 +66,15 @@
         *result = pow(1-plfit_runif_01(rng), gamma) * xmin;
         result++; n--;
     }
 
     return PLFIT_SUCCESS;
 }
 
-inline double plfit_rzeta(long int xmin, double alpha, mt_rng_t* rng) {
+inline double plfit_rzeta(long int xmin, double alpha, plfit_mt_rng_t* rng) {
     double u, v, t;
     long int x;
     double alpha_minus_1 = alpha-1;
     double minus_1_over_alpha_minus_1 = -1.0 / (alpha-1);
     double b;
     double one_over_b_minus_1;
 
@@ -126,15 +127,15 @@
         } while (x < xmin);
         t = pow((x+1.0)/x, alpha_minus_1);
     } while (v*x*(t-1)*one_over_b_minus_1*b > t*xmin);
 
     return x;
 }
 
-int plfit_rzeta_array(long int xmin, double alpha, size_t n, mt_rng_t* rng,
+int plfit_rzeta_array(long int xmin, double alpha, size_t n, plfit_mt_rng_t* rng,
         double* result) {
     double u, v, t;
     long int x;
     double alpha_minus_1 = alpha-1;
     double minus_1_over_alpha_minus_1 = -1.0 / (alpha-1);
     double b, one_over_b_minus_1;
 
@@ -171,17 +172,21 @@
 
 int plfit_walker_alias_sampler_init(plfit_walker_alias_sampler_t* sampler,
         double* ps, size_t n) {
     double *p, *p2, *ps_end;
     double sum;
     long int *short_sticks, *long_sticks;
     long int num_short_sticks, num_long_sticks;
-    size_t i;
+    long int i;
 
-    sampler->num_bins = n;
+    if (n > LONG_MAX) {
+        return PLFIT_EINVAL;
+    }
+
+    sampler->num_bins = (long int) n;
 
     ps_end = ps + n;
 
     /* Initialize indexes and probs */
     sampler->indexes = (long int*)calloc(n, sizeof(long int));
     if (sampler->indexes == 0) {
         return PLFIT_ENOMEM;
@@ -254,14 +259,17 @@
         sampler->probs[i] = 1;
     }
     while (num_short_sticks) {
         i = short_sticks[--num_short_sticks];
         sampler->probs[i] = 1;
     }
 
+    free(short_sticks);
+    free(long_sticks);
+
     return PLFIT_SUCCESS;
 }
 
 
 void plfit_walker_alias_sampler_destroy(plfit_walker_alias_sampler_t* sampler) {
     if (sampler->indexes) {
         free(sampler->indexes);
@@ -271,15 +279,15 @@
         free(sampler->probs);
         sampler->probs = 0;
     }
 }
 
 
 int plfit_walker_alias_sampler_sample(const plfit_walker_alias_sampler_t* sampler,
-        long int *xs, size_t n, mt_rng_t* rng) {
+        long int *xs, size_t n, plfit_mt_rng_t* rng) {
     double u;
     long int j;
     long int *x;
 
     x = xs;
 
     if (rng == 0) {
@@ -289,16 +297,16 @@
             j = RNG_INTEGER(0, sampler->num_bins - 1);
             *x = (u < sampler->probs[j]) ? j : sampler->indexes[j];
             n--; x++;
         }
     } else {
         /* Using Mersenne Twister */
         while (n > 0) {
-            u = mt_uniform_01(rng);
-            j = mt_random(rng) % sampler->num_bins;
+            u = plfit_mt_uniform_01(rng);
+            j = plfit_mt_random(rng) % sampler->num_bins;
             *x = (u < sampler->probs[j]) ? j : sampler->indexes[j];
             n--; x++;
         }
     }
 
     return PLFIT_SUCCESS;
 }
```

### Comparing `igraph-0.9.8/vendor/source/igraph/vendor/plfit/sampling.h` & `igraph-0.9.9/vendor/source/igraph/vendor/plfit/plfit_sampling.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* sampling.h
+/* plfit_sampling.h
  *
  * Copyright (C) 2012 Tamas Nepusz
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or (at
  * your option) any later version.
@@ -17,15 +17,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
 #ifndef __SAMPLING_H__
 #define __SAMPLING_H__
 
 #include <stdlib.h>
-#include "mt.h"
+#include "plfit_mt.h"
 
 #undef __BEGIN_DECLS
 #undef __END_DECLS
 #ifdef __cplusplus
 # define __BEGIN_DECLS extern "C" {
 # define __END_DECLS }
 #else
@@ -45,94 +45,94 @@
  * The function is \em not thread-safe.
  *
  * \param  n    the number of trials
  * \param  p    the success probability of each trial
  * \param  rng  the Mersenne Twister random number generator to use
  * \return the value drawn from the given binomial distribution.
  */
-double plfit_rbinom(double n, double p, mt_rng_t* rng);
+double plfit_rbinom(double n, double p, plfit_mt_rng_t* rng);
 
 /**
  * Draws a sample from a Pareto distribution with the given minimum value and
  * power-law exponent.
  *
  * \param  xmin    the minimum value of the distribution. Must be positive.
  * \param  alpha   the exponent. Must be positive
  * \param  rng     the Mersenne Twister random number generator to use
  *
  * \return the sample or NaN if one of the parameters is invalid
  */
-extern double plfit_rpareto(double xmin, double alpha, mt_rng_t* rng);
+extern double plfit_rpareto(double xmin, double alpha, plfit_mt_rng_t* rng);
 
 /**
  * Draws a given number of samples from a Pareto distribution with the given
  * minimum value and power-law exponent.
  *
  * \param  xmin    the minimum value of the distribution. Must be positive.
  * \param  alpha   the exponent. Must be positive
  * \param  n       the number of samples to draw
  * \param  rng     the Mersenne Twister random number generator to use
  * \param  result  the array where the result should be written. It must
  *                 have enough space to store n items
  *
  * \return \c PLFIT_EINVAL if one of the parameters is invalid, zero otherwise
  */
-int plfit_rpareto_array(double xmin, double alpha, size_t n, mt_rng_t* rng,
+int plfit_rpareto_array(double xmin, double alpha, size_t n, plfit_mt_rng_t* rng,
         double* result);
 
 /**
  * Draws a sample from a zeta distribution with the given minimum value and
  * power-law exponent.
  *
  * \param  xmin    the minimum value of the distribution. Must be positive.
  * \param  alpha   the exponent. Must be positive
  * \param  rng     the Mersenne Twister random number generator to use
  *
  * \return the sample or NaN if one of the parameters is invalid
  */
-extern double plfit_rzeta(long int xmin, double alpha, mt_rng_t* rng);
+extern double plfit_rzeta(long int xmin, double alpha, plfit_mt_rng_t* rng);
 
 /**
  * Draws a given number of samples from a zeta distribution with the given
  * minimum value and power-law exponent.
  *
  * \param  xmin    the minimum value of the distribution. Must be positive.
  * \param  alpha   the exponent. Must be positive
  * \param  n       the number of samples to draw
  * \param  rng     the Mersenne Twister random number generator to use
  * \param  result  the array where the result should be written. It must
  *                 have enough space to store n items
  *
  * \return \c PLFIT_EINVAL if one of the parameters is invalid, zero otherwise
  */
-int plfit_rzeta_array(long int xmin, double alpha, size_t n, mt_rng_t* rng,
+int plfit_rzeta_array(long int xmin, double alpha, size_t n, plfit_mt_rng_t* rng,
         double* result);
 
 /**
  * Draws a sample from a uniform distribution with the given lower and
  * upper bounds.
  *
  * The lower bound is inclusive, the uppoer bound is not.
  *
  * \param  lo   the lower bound
  * \param  hi   the upper bound
  * \param  rng  the Mersenne Twister random number generator to use
  * \return the value drawn from the given uniform distribution.
  */
-extern double plfit_runif(double lo, double hi, mt_rng_t* rng);
+extern double plfit_runif(double lo, double hi, plfit_mt_rng_t* rng);
 
 /**
  * Draws a sample from a uniform distribution over the [0; 1) interval.
  *
  * The interval is closed from the left and open from the right.
  *
  * \param  rng  the Mersenne Twister random number generator to use
  * \return the value drawn from the given uniform distribution.
  */
-extern double plfit_runif_01(mt_rng_t* rng);
+extern double plfit_runif_01(plfit_mt_rng_t* rng);
 
 /**
  * Random sampler using Walker's alias method.
  */
 typedef struct {
     long int num_bins;            /**< Number of bins */
     long int* indexes;            /**< Index of the "other" element in each bin */
@@ -166,12 +166,12 @@
  * \param  xs       pointer to an array where the sampled items should be
  *                  written
  * \param  n        the number of samples to draw
  * \param  rng      the Mersenne Twister random number generator to use
  * \return error code
  */
 int plfit_walker_alias_sampler_sample(const plfit_walker_alias_sampler_t* sampler,
-        long int* xs, size_t n, mt_rng_t* rng);
+        long int* xs, size_t n, plfit_mt_rng_t* rng);
 
 __END_DECLS
 
 #endif
```

