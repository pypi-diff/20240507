# Comparing `tmp/iota_sdk-1.1.4-cp39-none-win_amd64.whl.zip` & `tmp/iota_sdk-2.0.0a1-cp312-none-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,53 +1,66 @@
-Zip file size: 8457604 bytes, number of entries: 51
--rw-r--r--  4.6 unx     3827 b- defN 24-May-03 19:11 iota_sdk-1.1.4.dist-info/METADATA
--rw-r--r--  4.6 unx       94 b- defN 24-May-03 19:11 iota_sdk-1.1.4.dist-info/WHEEL
--rw-r--r--  4.6 unx    22373 b- defN 24-May-03 19:11 iota_sdk/client/client.py
--rw-r--r--  4.6 unx    10861 b- defN 24-May-03 19:11 iota_sdk/client/_high_level_api.py
--rw-r--r--  4.6 unx     9206 b- defN 24-May-03 19:11 iota_sdk/client/_node_core_api.py
--rw-r--r--  4.6 unx     9922 b- defN 24-May-03 19:11 iota_sdk/client/_node_indexer_api.py
--rw-r--r--  4.6 unx     3262 b- defN 24-May-03 19:11 iota_sdk/client/_utils.py
--rw-r--r--  4.6 unx      395 b- defN 24-May-03 19:11 iota_sdk/external.py
--rw-r--r--  4.6 unx      445 b- defN 24-May-03 19:11 iota_sdk/prefix_hex.py
--rw-r--r--  4.6 unx        0 b- defN 24-May-03 19:11 iota_sdk/py.typed
--rw-r--r--  4.6 unx    10236 b- defN 24-May-03 19:11 iota_sdk/secret_manager/secret_manager.py
--rw-r--r--  4.6 unx     1867 b- defN 24-May-03 19:11 iota_sdk/types/address.py
--rw-r--r--  4.6 unx     2411 b- defN 24-May-03 19:11 iota_sdk/types/balance.py
--rw-r--r--  4.6 unx     6234 b- defN 24-May-03 19:11 iota_sdk/types/block.py
--rw-r--r--  4.6 unx     1097 b- defN 24-May-03 19:11 iota_sdk/types/block_builder_options.py
--rw-r--r--  4.6 unx     2130 b- defN 24-May-03 19:11 iota_sdk/types/burn.py
--rw-r--r--  4.6 unx     4462 b- defN 24-May-03 19:11 iota_sdk/types/client_options.py
--rw-r--r--  4.6 unx     2542 b- defN 24-May-03 19:11 iota_sdk/types/common.py
--rw-r--r--  4.6 unx      664 b- defN 24-May-03 19:11 iota_sdk/types/consolidation_params.py
--rw-r--r--  4.6 unx      758 b- defN 24-May-03 19:11 iota_sdk/types/event.py
--rw-r--r--  4.6 unx     2114 b- defN 24-May-03 19:11 iota_sdk/types/feature.py
--rw-r--r--  4.6 unx      540 b- defN 24-May-03 19:11 iota_sdk/types/filter_options.py
--rw-r--r--  4.6 unx      990 b- defN 24-May-03 19:11 iota_sdk/types/input.py
--rw-r--r--  4.6 unx     2786 b- defN 24-May-03 19:11 iota_sdk/types/irc_27.py
--rw-r--r--  4.6 unx     1749 b- defN 24-May-03 19:11 iota_sdk/types/irc_30.py
--rw-r--r--  4.6 unx      378 b- defN 24-May-03 19:11 iota_sdk/types/native_token.py
--rw-r--r--  4.6 unx      376 b- defN 24-May-03 19:11 iota_sdk/types/network_info.py
--rw-r--r--  4.6 unx     5059 b- defN 24-May-03 19:11 iota_sdk/types/node_info.py
--rw-r--r--  4.6 unx    11663 b- defN 24-May-03 19:11 iota_sdk/types/output.py
--rw-r--r--  4.6 unx     1260 b- defN 24-May-03 19:11 iota_sdk/types/output_data.py
--rw-r--r--  4.6 unx     2183 b- defN 24-May-03 19:11 iota_sdk/types/output_id.py
--rw-r--r--  4.6 unx     1491 b- defN 24-May-03 19:11 iota_sdk/types/output_params.py
--rw-r--r--  4.6 unx     5492 b- defN 24-May-03 19:11 iota_sdk/types/payload.py
--rw-r--r--  4.6 unx     4127 b- defN 24-May-03 19:11 iota_sdk/types/send_params.py
--rw-r--r--  4.6 unx      982 b- defN 24-May-03 19:11 iota_sdk/types/signature.py
--rw-r--r--  4.6 unx     1266 b- defN 24-May-03 19:11 iota_sdk/types/token_scheme.py
--rw-r--r--  4.6 unx     2126 b- defN 24-May-03 19:11 iota_sdk/types/transaction.py
--rw-r--r--  4.6 unx     3686 b- defN 24-May-03 19:11 iota_sdk/types/transaction_data.py
--rw-r--r--  4.6 unx     3470 b- defN 24-May-03 19:11 iota_sdk/types/transaction_options.py
--rw-r--r--  4.6 unx     2358 b- defN 24-May-03 19:11 iota_sdk/types/unlock.py
--rw-r--r--  4.6 unx     4490 b- defN 24-May-03 19:11 iota_sdk/types/unlock_condition.py
--rw-r--r--  4.6 unx      455 b- defN 24-May-03 19:11 iota_sdk/types/utxo_changes.py
--rw-r--r--  4.6 unx     9577 b- defN 24-May-03 19:11 iota_sdk/utils.py
--rw-r--r--  4.6 unx    22510 b- defN 24-May-03 19:11 iota_sdk/wallet/account.py
--rw-r--r--  4.6 unx     2715 b- defN 24-May-03 19:11 iota_sdk/wallet/common.py
--rw-r--r--  4.6 unx     2796 b- defN 24-May-03 19:11 iota_sdk/wallet/prepared_transaction.py
--rw-r--r--  4.6 unx     5719 b- defN 24-May-03 19:11 iota_sdk/wallet/sync_options.py
--rw-r--r--  4.6 unx     9803 b- defN 24-May-03 19:11 iota_sdk/wallet/wallet.py
--rw-r--r--  4.6 unx     1530 b- defN 24-May-03 19:11 iota_sdk/__init__.py
--rwxr-xr-x  4.6 unx 21927424 b- defN 24-May-03 19:11 iota_sdk/iota_sdk.cp39-win_amd64.pyd
--rw-r--r--  4.6 unx     4289 b- defN 24-May-03 19:11 iota_sdk-1.1.4.dist-info/RECORD
-51 files, 22138190 bytes uncompressed, 8450822 bytes compressed:  61.8%
+Zip file size: 8589271 bytes, number of entries: 64
+-rw-r--r--  4.6 unx     3825 b- defN 24-May-07 17:16 iota_sdk-2.0.0a1.dist-info/METADATA
+-rw-r--r--  4.6 unx       95 b- defN 24-May-07 17:16 iota_sdk-2.0.0a1.dist-info/WHEEL
+-rw-r--r--  4.6 unx    13750 b- defN 24-May-07 17:16 iota_sdk/client/client.py
+-rw-r--r--  4.6 unx      923 b- defN 24-May-07 17:16 iota_sdk/client/common.py
+-rw-r--r--  4.6 unx    15954 b- defN 24-May-07 17:16 iota_sdk/client/responses.py
+-rw-r--r--  4.6 unx     4628 b- defN 24-May-07 17:16 iota_sdk/client/_high_level_api.py
+-rw-r--r--  4.6 unx    17422 b- defN 24-May-07 17:16 iota_sdk/client/_node_core_api.py
+-rw-r--r--  4.6 unx    14567 b- defN 24-May-07 17:16 iota_sdk/client/_node_indexer_api.py
+-rw-r--r--  4.6 unx     2631 b- defN 24-May-07 17:16 iota_sdk/client/_utils.py
+-rw-r--r--  4.6 unx     1802 b- defN 24-May-07 17:16 iota_sdk/common.py
+-rw-r--r--  4.6 unx      395 b- defN 24-May-07 17:16 iota_sdk/external.py
+-rw-r--r--  4.6 unx      445 b- defN 24-May-07 17:16 iota_sdk/prefix_hex.py
+-rw-r--r--  4.6 unx        0 b- defN 24-May-07 17:16 iota_sdk/py.typed
+-rw-r--r--  4.6 unx    12943 b- defN 24-May-07 17:16 iota_sdk/secret_manager/secret_manager.py
+-rw-r--r--  4.6 unx     6082 b- defN 24-May-07 17:16 iota_sdk/types/address.py
+-rw-r--r--  4.6 unx     3588 b- defN 24-May-07 17:16 iota_sdk/types/balance.py
+-rw-r--r--  4.6 unx     3501 b- defN 24-May-07 17:16 iota_sdk/types/block/block.py
+-rw-r--r--  4.6 unx     1510 b- defN 24-May-07 17:16 iota_sdk/types/block/body/basic.py
+-rw-r--r--  4.6 unx      349 b- defN 24-May-07 17:16 iota_sdk/types/block/body/type.py
+-rw-r--r--  4.6 unx     1534 b- defN 24-May-07 17:16 iota_sdk/types/block/body/validation.py
+-rw-r--r--  4.6 unx      201 b- defN 24-May-07 17:16 iota_sdk/types/block/id.py
+-rw-r--r--  4.6 unx     1432 b- defN 24-May-07 17:16 iota_sdk/types/block_builder_options.py
+-rw-r--r--  4.6 unx     2010 b- defN 24-May-07 17:16 iota_sdk/types/block_issuer_key.py
+-rw-r--r--  4.6 unx     2772 b- defN 24-May-07 17:16 iota_sdk/types/burn.py
+-rw-r--r--  4.6 unx     3138 b- defN 24-May-07 17:16 iota_sdk/types/client_options.py
+-rw-r--r--  4.6 unx     4577 b- defN 24-May-07 17:16 iota_sdk/types/common.py
+-rw-r--r--  4.6 unx      715 b- defN 24-May-07 17:16 iota_sdk/types/consolidation_params.py
+-rw-r--r--  4.6 unx     3281 b- defN 24-May-07 17:16 iota_sdk/types/context_input.py
+-rw-r--r--  4.6 unx      438 b- defN 24-May-07 17:16 iota_sdk/types/decayed_mana.py
+-rw-r--r--  4.6 unx     1521 b- defN 24-May-07 17:16 iota_sdk/types/event.py
+-rw-r--r--  4.6 unx     6675 b- defN 24-May-07 17:16 iota_sdk/types/feature.py
+-rw-r--r--  4.6 unx      596 b- defN 24-May-07 17:16 iota_sdk/types/filter_options.py
+-rw-r--r--  4.6 unx     1917 b- defN 24-May-07 17:16 iota_sdk/types/input.py
+-rw-r--r--  4.6 unx     2798 b- defN 24-May-07 17:16 iota_sdk/types/irc_27.py
+-rw-r--r--  4.6 unx     1761 b- defN 24-May-07 17:16 iota_sdk/types/irc_30.py
+-rw-r--r--  4.6 unx      652 b- defN 24-May-07 17:16 iota_sdk/types/mana.py
+-rw-r--r--  4.6 unx      536 b- defN 24-May-07 17:16 iota_sdk/types/native_token.py
+-rw-r--r--  4.6 unx    13838 b- defN 24-May-07 17:16 iota_sdk/types/node_info.py
+-rw-r--r--  4.6 unx    13970 b- defN 24-May-07 17:16 iota_sdk/types/output.py
+-rw-r--r--  4.6 unx      961 b- defN 24-May-07 17:16 iota_sdk/types/output_data.py
+-rw-r--r--  4.6 unx     2550 b- defN 24-May-07 17:16 iota_sdk/types/output_id.py
+-rw-r--r--  4.6 unx     3080 b- defN 24-May-07 17:16 iota_sdk/types/output_id_proof.py
+-rw-r--r--  4.6 unx     3076 b- defN 24-May-07 17:16 iota_sdk/types/output_metadata.py
+-rw-r--r--  4.6 unx     1783 b- defN 24-May-07 17:16 iota_sdk/types/output_params.py
+-rw-r--r--  4.6 unx     6026 b- defN 24-May-07 17:16 iota_sdk/types/payload.py
+-rw-r--r--  4.6 unx     5492 b- defN 24-May-07 17:16 iota_sdk/types/send_params.py
+-rw-r--r--  4.6 unx      959 b- defN 24-May-07 17:16 iota_sdk/types/signature.py
+-rw-r--r--  4.6 unx     1512 b- defN 24-May-07 17:16 iota_sdk/types/slot.py
+-rw-r--r--  4.6 unx     1015 b- defN 24-May-07 17:16 iota_sdk/types/token_scheme.py
+-rw-r--r--  4.6 unx     2524 b- defN 24-May-07 17:16 iota_sdk/types/transaction_data.py
+-rw-r--r--  4.6 unx      213 b- defN 24-May-07 17:16 iota_sdk/types/transaction_id.py
+-rw-r--r--  4.6 unx     9734 b- defN 24-May-07 17:16 iota_sdk/types/transaction_metadata.py
+-rw-r--r--  4.6 unx     2431 b- defN 24-May-07 17:16 iota_sdk/types/transaction_options.py
+-rw-r--r--  4.6 unx     2686 b- defN 24-May-07 17:16 iota_sdk/types/transaction_with_metadata.py
+-rw-r--r--  4.6 unx     5597 b- defN 24-May-07 17:16 iota_sdk/types/unlock.py
+-rw-r--r--  4.6 unx     6679 b- defN 24-May-07 17:16 iota_sdk/types/unlock_condition.py
+-rw-r--r--  4.6 unx    11948 b- defN 24-May-07 17:16 iota_sdk/utils.py
+-rw-r--r--  4.6 unx      923 b- defN 24-May-07 17:16 iota_sdk/wallet/common.py
+-rw-r--r--  4.6 unx     5290 b- defN 24-May-07 17:16 iota_sdk/wallet/prepared_transaction.py
+-rw-r--r--  4.6 unx     3804 b- defN 24-May-07 17:16 iota_sdk/wallet/sync_options.py
+-rw-r--r--  4.6 unx    33680 b- defN 24-May-07 17:16 iota_sdk/wallet/wallet.py
+-rw-r--r--  4.6 unx     2030 b- defN 24-May-07 17:16 iota_sdk/__init__.py
+-rwxr-xr-x  4.6 unx 22576128 b- defN 24-May-07 17:16 iota_sdk/iota_sdk.cp312-win_amd64.pyd
+-rw-r--r--  4.6 unx     5449 b- defN 24-May-07 17:16 iota_sdk-2.0.0a1.dist-info/RECORD
+64 files, 22864342 bytes uncompressed, 8580663 bytes compressed:  62.5%
```

## zipnote {}

```diff
@@ -1,28 +1,37 @@
-Filename: iota_sdk-1.1.4.dist-info/METADATA
+Filename: iota_sdk-2.0.0a1.dist-info/METADATA
 Comment: 
 
-Filename: iota_sdk-1.1.4.dist-info/WHEEL
+Filename: iota_sdk-2.0.0a1.dist-info/WHEEL
 Comment: 
 
 Filename: iota_sdk/client/client.py
 Comment: 
 
+Filename: iota_sdk/client/common.py
+Comment: 
+
+Filename: iota_sdk/client/responses.py
+Comment: 
+
 Filename: iota_sdk/client/_high_level_api.py
 Comment: 
 
 Filename: iota_sdk/client/_node_core_api.py
 Comment: 
 
 Filename: iota_sdk/client/_node_indexer_api.py
 Comment: 
 
 Filename: iota_sdk/client/_utils.py
 Comment: 
 
+Filename: iota_sdk/common.py
+Comment: 
+
 Filename: iota_sdk/external.py
 Comment: 
 
 Filename: iota_sdk/prefix_hex.py
 Comment: 
 
 Filename: iota_sdk/py.typed
@@ -33,32 +42,53 @@
 
 Filename: iota_sdk/types/address.py
 Comment: 
 
 Filename: iota_sdk/types/balance.py
 Comment: 
 
-Filename: iota_sdk/types/block.py
+Filename: iota_sdk/types/block/block.py
+Comment: 
+
+Filename: iota_sdk/types/block/body/basic.py
+Comment: 
+
+Filename: iota_sdk/types/block/body/type.py
+Comment: 
+
+Filename: iota_sdk/types/block/body/validation.py
+Comment: 
+
+Filename: iota_sdk/types/block/id.py
 Comment: 
 
 Filename: iota_sdk/types/block_builder_options.py
 Comment: 
 
+Filename: iota_sdk/types/block_issuer_key.py
+Comment: 
+
 Filename: iota_sdk/types/burn.py
 Comment: 
 
 Filename: iota_sdk/types/client_options.py
 Comment: 
 
 Filename: iota_sdk/types/common.py
 Comment: 
 
 Filename: iota_sdk/types/consolidation_params.py
 Comment: 
 
+Filename: iota_sdk/types/context_input.py
+Comment: 
+
+Filename: iota_sdk/types/decayed_mana.py
+Comment: 
+
 Filename: iota_sdk/types/event.py
 Comment: 
 
 Filename: iota_sdk/types/feature.py
 Comment: 
 
 Filename: iota_sdk/types/filter_options.py
@@ -69,69 +99,78 @@
 
 Filename: iota_sdk/types/irc_27.py
 Comment: 
 
 Filename: iota_sdk/types/irc_30.py
 Comment: 
 
-Filename: iota_sdk/types/native_token.py
+Filename: iota_sdk/types/mana.py
 Comment: 
 
-Filename: iota_sdk/types/network_info.py
+Filename: iota_sdk/types/native_token.py
 Comment: 
 
 Filename: iota_sdk/types/node_info.py
 Comment: 
 
 Filename: iota_sdk/types/output.py
 Comment: 
 
 Filename: iota_sdk/types/output_data.py
 Comment: 
 
 Filename: iota_sdk/types/output_id.py
 Comment: 
 
+Filename: iota_sdk/types/output_id_proof.py
+Comment: 
+
+Filename: iota_sdk/types/output_metadata.py
+Comment: 
+
 Filename: iota_sdk/types/output_params.py
 Comment: 
 
 Filename: iota_sdk/types/payload.py
 Comment: 
 
 Filename: iota_sdk/types/send_params.py
 Comment: 
 
 Filename: iota_sdk/types/signature.py
 Comment: 
 
-Filename: iota_sdk/types/token_scheme.py
+Filename: iota_sdk/types/slot.py
 Comment: 
 
-Filename: iota_sdk/types/transaction.py
+Filename: iota_sdk/types/token_scheme.py
 Comment: 
 
 Filename: iota_sdk/types/transaction_data.py
 Comment: 
 
-Filename: iota_sdk/types/transaction_options.py
+Filename: iota_sdk/types/transaction_id.py
 Comment: 
 
-Filename: iota_sdk/types/unlock.py
+Filename: iota_sdk/types/transaction_metadata.py
 Comment: 
 
-Filename: iota_sdk/types/unlock_condition.py
+Filename: iota_sdk/types/transaction_options.py
 Comment: 
 
-Filename: iota_sdk/types/utxo_changes.py
+Filename: iota_sdk/types/transaction_with_metadata.py
 Comment: 
 
-Filename: iota_sdk/utils.py
+Filename: iota_sdk/types/unlock.py
 Comment: 
 
-Filename: iota_sdk/wallet/account.py
+Filename: iota_sdk/types/unlock_condition.py
+Comment: 
+
+Filename: iota_sdk/utils.py
 Comment: 
 
 Filename: iota_sdk/wallet/common.py
 Comment: 
 
 Filename: iota_sdk/wallet/prepared_transaction.py
 Comment: 
@@ -141,14 +180,14 @@
 
 Filename: iota_sdk/wallet/wallet.py
 Comment: 
 
 Filename: iota_sdk/__init__.py
 Comment: 
 
-Filename: iota_sdk/iota_sdk.cp39-win_amd64.pyd
+Filename: iota_sdk/iota_sdk.cp312-win_amd64.pyd
 Comment: 
 
-Filename: iota_sdk-1.1.4.dist-info/RECORD
+Filename: iota_sdk-2.0.0a1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## iota_sdk/client/client.py

```diff
@@ -1,123 +1,98 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from json import dumps, loads
+from json import dumps
 from datetime import timedelta
 from typing import Any, Dict, List, Optional, Union
 import humps
-from dacite import from_dict
-
-from iota_sdk.external import create_client, call_client_method, listen_mqtt
+from iota_sdk.external import create_client, listen_mqtt
 from iota_sdk.client._node_core_api import NodeCoreAPI
 from iota_sdk.client._node_indexer_api import NodeIndexerAPI
 from iota_sdk.client._high_level_api import HighLevelAPI
 from iota_sdk.client._utils import ClientUtils
-from iota_sdk.secret_manager.secret_manager import LedgerNanoSecretManager, MnemonicSecretManager, StrongholdSecretManager, SeedSecretManager
-from iota_sdk.types.block import Block
-from iota_sdk.types.common import HexStr, Node, AddressAndAmount
+from iota_sdk.client.common import _call_client_method_routine
+from iota_sdk.types.block.block import UnsignedBlock
+from iota_sdk.types.client_options import MqttBrokerOptions
+from iota_sdk.types.common import HexStr, Node
 from iota_sdk.types.feature import Feature
-from iota_sdk.types.native_token import NativeToken
-from iota_sdk.types.network_info import NetworkInfo
-from iota_sdk.types.output import AliasOutput, BasicOutput, FoundryOutput, NftOutput, output_from_dict
-from iota_sdk.types.payload import Payload, TransactionPayload
+from iota_sdk.types.node_info import ProtocolParameters
+from iota_sdk.types.output import AccountOutput, BasicOutput, FoundryOutput, NftOutput, deserialize_output
+from iota_sdk.types.payload import Payload
 from iota_sdk.types.token_scheme import SimpleTokenScheme
 from iota_sdk.types.unlock_condition import UnlockCondition
-from iota_sdk.types.transaction_data import PreparedTransactionData
-
-
-class ClientError(Exception):
-    """Represents a client error."""
 
 
 class Client(NodeCoreAPI, NodeIndexerAPI, HighLevelAPI, ClientUtils):
     """Represents an IOTA client.
 
     Attributes:
         handle: The handle to the inner client object.
     """
 
     # pylint: disable=unused-argument
     def __init__(
         self,
-        nodes: Optional[Union[str, List[str]]] = None,
-        primary_node: Optional[str] = None,
-        primary_pow_node: Optional[str] = None,
-        permanode: Optional[str] = None,
+        primary_nodes: Optional[Union[Union[str, Node],
+                                      List[Union[str, Node]]]] = None,
+        nodes: Optional[Union[Union[str, Node],
+                              List[Union[str, Node]]]] = None,
+        protocol_parameters: Optional[ProtocolParameters] = None,
         ignore_node_health: Optional[bool] = None,
         api_timeout: Optional[timedelta] = None,
         node_sync_interval: Optional[timedelta] = None,
-        remote_pow_timeout: Optional[timedelta] = None,
-        tips_interval: Optional[int] = None,
         quorum: Optional[bool] = None,
         min_quorum_size: Optional[int] = None,
         quorum_threshold: Optional[int] = None,
         user_agent: Optional[str] = None,
-        local_pow: Optional[bool] = None,
-        fallback_to_local_pow: Optional[bool] = None,
-        pow_worker_count: Optional[int] = None,
+        broker_options: Optional[MqttBrokerOptions] = None,
         max_parallel_api_requests: Optional[int] = None,
         client_handle=None
     ):
         """Initialize the IOTA Client.
 
         **Arguments**
+        primary_nodes :
+            Nodes which will be tried first for all requests.
         nodes :
             A single Node URL or an array of URLs.
-        primary_node :
-            Node which will be tried first for all requests.
-        primary_pow_node :
-            Node which will be tried first when using remote PoW, even before the primary_node.
-        permanode :
-            Permanode URL.
         ignore_node_health :
             If the node health should be ignored.
         api_timeout :
             Timeout for API requests.
         node_sync_interval :
-            Interval in which nodes will be checked for their sync status and the [NetworkInfo](crate::NetworkInfo) gets updated.
-        remote_pow_timeout :
-            Timeout when sending a block that requires remote proof of work.
-        tips_interval :
-            Tips request interval during PoW in seconds.
+            Interval in which nodes will be checked for their sync status and the network info gets updated.
         quorum :
             If node quorum is enabled. Will compare the responses from multiple nodes and only returns the response if 'quorum_threshold'% of the nodes return the same one.
         min_quorum_size :
             Minimum amount of nodes required for request when quorum is enabled.
         quorum_threshold :
             % of nodes that have to return the same response so it gets accepted.
         user_agent :
             The User-Agent header for requests.
-        local_pow :
-            Local proof of work.
-        fallback_to_local_pow :
-            Fallback to local proof of work if the node doesn't support remote PoW.
-        pow_worker_count :
-            The amount of threads to be used for proof of work.
+        broker_options (MqttBrokerOptions):
+            Options for the MQTT broker.
         max_parallel_api_requests :
             Set maximum parallel API requests.
         client_handle :
             An instance of a node client.
         """
         client_config = dict(locals())
         del client_config['self']
         # Delete client_handle, because it's not needed here and can't be
         # serialized.
         if "client_handle" in client_config:
             del client_config["client_handle"]
 
-        if isinstance(nodes, list):
-            nodes = [node.as_dict() if isinstance(node, Node)
-                     else node for node in nodes]
-        elif nodes:
-            if isinstance(nodes, Node):
-                nodes = [nodes.as_dict()]
-            else:
-                nodes = [nodes]
-        client_config['nodes'] = nodes
+        client_config['primary_nodes'] = convert_nodes(primary_nodes)
+        client_config['nodes'] = convert_nodes(nodes)
+        if broker_options is not None:
+            client_config['broker_options'] = broker_options.to_dict()
+        if protocol_parameters is not None:
+            client_config['protocol_parameters'] = protocol_parameters.to_dict()
 
         client_config = {
             k: v for k,
             v in client_config.items() if v is not None}
 
         def get_remaining_nano_seconds(duration: timedelta):
             return (int(duration / timedelta(microseconds=1)) -
@@ -125,401 +100,205 @@
 
         if 'api_timeout' in client_config:
             client_config['api_timeout'] = {'secs': int(client_config['api_timeout'].total_seconds(
             )), 'nanos': get_remaining_nano_seconds(client_config['api_timeout'])}
         if 'node_sync_interval' in client_config:
             client_config['node_sync_interval'] = {'secs': int(client_config['node_sync_interval'].total_seconds(
             )), 'nanos': get_remaining_nano_seconds(client_config['node_sync_interval'])}
-        if 'remote_pow_timeout' in client_config:
-            client_config['remote_pow_timeout'] = {'secs': int(client_config['remote_pow_timeout'].total_seconds(
-            )), 'nanos': get_remaining_nano_seconds(client_config['remote_pow_timeout'])}
 
         client_config = humps.camelize(client_config)
         client_config_str = dumps(client_config)
 
         # Create the message handler
         if client_handle is None:
             self.handle = create_client(client_config_str)
         else:
             self.handle = client_handle
 
+    @_call_client_method_routine
     def _call_method(self, name, data=None):
         """Dumps json string and calls `call_client_method()`
         """
         message = {
             'name': name
         }
         if data:
             message['data'] = data
-        message = dumps(message)
-
-        # Send message to the Rust library
-        response = call_client_method(self.handle, message)
-
-        json_response = loads(response)
-
-        if "type" in json_response:
-            if json_response["type"] == "error":
-                raise ClientError(json_response['payload'])
-
-        if "payload" in json_response:
-            return json_response['payload']
-        return response
+        return message
 
     def get_handle(self):
         """Get the client handle.
 
         Returns:
             The inner client object.
         """
         return self.handle
 
-    def build_alias_output(self,
-                           alias_id: HexStr,
-                           unlock_conditions: List[UnlockCondition],
-                           amount: Optional[int] = None,
-                           native_tokens: Optional[List[NativeToken]] = None,
-                           state_index: Optional[int] = None,
-                           state_metadata: Optional[str] = None,
-                           foundry_counter: Optional[int] = None,
-                           features: Optional[List[Feature]] = None,
-                           immutable_features: Optional[List[Feature]] = None) -> AliasOutput:
-        """Build an AliasOutput.
+    def build_account_output(self,
+                             account_id: HexStr,
+                             unlock_conditions: List[UnlockCondition],
+                             amount: Optional[int] = None,
+                             mana: Optional[int] = None,
+                             foundry_counter: Optional[int] = None,
+                             features: Optional[List[Feature]] = None,
+                             immutable_features: Optional[List[Feature]] = None) -> AccountOutput:
+        """Build an AccountOutput.
 
         Args:
-            alias_id: A unique ID for the new alias.
+            account_id: A unique ID for the new account.
             unlock_conditions: The unlock conditions for the new output.
             amount: The amount of base coins in the new output.
-            native_tokens: Native tokens added to the new output.
-            state_index: A counter that must increase by 1 every time the alias is state transitioned.
-            state_metadata: Metadata that can only be changed by the state controller.
-            foundry_counter: A counter that denotes the number of foundries created by this alias account.
+            mana: Amount of stored Mana held by this output.
+            foundry_counter: A counter that denotes the number of foundries created by this account output.
             features: A list of features.
             immutable_features: A list of immutable features.
 
         Returns:
-            The alias output as dict.
+            The account output as dict.
         """
 
-        unlock_conditions = [unlock_condition.as_dict()
-                             for unlock_condition in unlock_conditions]
-
-        if native_tokens:
-            native_tokens = [native_token.as_dict()
-                             for native_token in native_tokens]
-
-        if features:
-            features = [feature.as_dict() for feature in features]
-        if immutable_features:
-            immutable_features = [immutable_feature.as_dict()
-                                  for immutable_feature in immutable_features]
-
-        if amount:
-            amount = str(amount)
-
-        return output_from_dict(self._call_method('buildAliasOutput', {
-            'aliasId': alias_id,
+        return deserialize_output(self._call_method('buildAccountOutput', {
+            'accountId': account_id,
             'unlockConditions': unlock_conditions,
-            'amount': amount,
-            'nativeTokens': native_tokens,
-            'stateIndex': state_index,
-            'stateMetadata': state_metadata,
+            'amount': None if amount is None else str(amount),
+            'mana': None if mana is None else str(mana),
             'foundryCounter': foundry_counter,
             'features': features,
             'immutableFeatures': immutable_features
         }))
 
     def build_basic_output(self,
                            unlock_conditions: List[UnlockCondition],
                            amount: Optional[int] = None,
-                           native_tokens: Optional[List[NativeToken]] = None,
+                           mana: Optional[int] = None,
                            features: Optional[List[Feature]] = None) -> BasicOutput:
         """Build a BasicOutput.
 
         Args:
             unlock_conditions: The unlock conditions for the new output.
             amount: The amount of base coins in the new output.
-            native_tokens: Native tokens added to the new output.
+            mana: Amount of stored Mana held by this output.
             features: Features that add utility to the output but do not impose unlocking conditions.
 
         Returns:
             The basic output as dict.
         """
 
-        unlock_conditions = [unlock_condition.as_dict()
-                             for unlock_condition in unlock_conditions]
-
-        if native_tokens:
-            native_tokens = [native_token.as_dict()
-                             for native_token in native_tokens]
-
-        if features:
-            features = [feature.as_dict() for feature in features]
-
-        if amount:
-            amount = str(amount)
-
-        return output_from_dict(self._call_method('buildBasicOutput', {
+        return deserialize_output(self._call_method('buildBasicOutput', {
             'unlockConditions': unlock_conditions,
-            'amount': amount,
-            'nativeTokens': native_tokens,
+            'amount': None if amount is None else str(amount),
+            'mana': None if mana is None else str(mana),
             'features': features,
         }))
 
     def build_foundry_output(self,
                              serial_number: int,
                              token_scheme: SimpleTokenScheme,
                              unlock_conditions: List[UnlockCondition],
                              amount: Optional[int] = None,
-                             native_tokens: Optional[List[NativeToken]] = None,
                              features: Optional[List[Feature]] = None,
                              immutable_features: Optional[List[Feature]] = None) -> FoundryOutput:
         """Build a FoundryOutput.
 
         Args:
-            serial_number: The serial number of the foundry with respect to the controlling alias.
+            serial_number: The serial number of the foundry with respect to the controlling account.
             token_scheme: Defines the supply control scheme of the tokens controlled by the foundry. Currently only a simple scheme is supported.
             unlock_conditions: The unlock conditions for the new output.
             amount: The amount of base coins in the new output.
-            native_tokens: Native tokens added to the new output.
             features: Features that add utility to the output but do not impose unlocking conditions.
             immutable_features: Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
 
         Returns:
             The foundry output as dict.
         """
 
-        unlock_conditions = [unlock_condition.as_dict()
-                             for unlock_condition in unlock_conditions]
-
-        if native_tokens:
-            native_tokens = [native_token.__dict__
-                             for native_token in native_tokens]
-
-        if features:
-            features = [feature.as_dict() for feature in features]
-        if immutable_features:
-            immutable_features = [immutable_feature.as_dict()
-                                  for immutable_feature in immutable_features]
-
-        if amount:
-            amount = str(amount)
-
-        return output_from_dict(self._call_method('buildFoundryOutput', {
+        return deserialize_output(self._call_method('buildFoundryOutput', {
             'serialNumber': serial_number,
-            'tokenScheme': token_scheme.as_dict(),
+            'tokenScheme': token_scheme,
             'unlockConditions': unlock_conditions,
-            'amount': amount,
-            'nativeTokens': native_tokens,
+            'amount': None if amount is None else str(amount),
             'features': features,
             'immutableFeatures': immutable_features
         }))
 
     def build_nft_output(self,
                          nft_id: HexStr,
                          unlock_conditions: List[UnlockCondition],
                          amount: Optional[int] = None,
-                         native_tokens: Optional[List[NativeToken]] = None,
+                         mana: Optional[int] = None,
                          features: Optional[List[Feature]] = None,
                          immutable_features: Optional[List[Feature]] = None) -> NftOutput:
         """Build an NftOutput.
 
         Args:
             nft_id: A unique ID for the new NFT.
             unlock_conditions: The unlock conditions for the new output.
             amount: The amount of base coins in the new output.
-            native_tokens: Native tokens added to the new output.
+            mana: Amount of stored Mana held by this output.
             features: Features that add utility to the output but do not impose unlocking conditions.
             immutable_features: Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
 
         Returns:
             The NFT output as dict.
         """
 
-        unlock_conditions = [unlock_condition.as_dict()
-                             for unlock_condition in unlock_conditions]
-
-        if native_tokens:
-            native_tokens = [native_token.__dict__
-                             for native_token in native_tokens]
-
-        if features:
-            features = [feature.as_dict() for feature in features]
-        if immutable_features:
-            immutable_features = [immutable_feature.as_dict()
-                                  for immutable_feature in immutable_features]
-
-        if amount:
-            amount = str(amount)
-
-        return output_from_dict(self._call_method('buildNftOutput', {
+        return deserialize_output(self._call_method('buildNftOutput', {
             'nftId': nft_id,
             'unlockConditions': unlock_conditions,
-            'amount': amount,
-            'nativeTokens': native_tokens,
+            'amount': None if amount is None else str(amount),
+            'mana': None if mana is None else str(mana),
             'features': features,
             'immutableFeatures': immutable_features
         }))
 
-    # pylint: disable=unused-argument
-    def build_and_post_block(self,
-                             secret_manager: Optional[Union[LedgerNanoSecretManager, MnemonicSecretManager,
-                                                      SeedSecretManager, StrongholdSecretManager]] = None,
-                             account_index: Optional[int] = None,
-                             coin_type: Optional[int] = None,
-                             custom_remainder_address: Optional[str] = None,
-                             data: Optional[HexStr] = None,
-                             initial_address_index: Optional[int] = None,
-                             input_range_start: Optional[int] = None,
-                             input_range_end: Optional[int] = None,
-                             inputs: Optional[List[Dict[str, Any]]] = None,
-                             output: Optional[AddressAndAmount] = None,
-                             outputs: Optional[List[Any]] = None,
-                             tag: Optional[HexStr] = None) -> List[Union[HexStr, Block]]:
-        """Build and post a block.
-
-        **Arguments**
-        account_index : The account index to issue the block with.
-        coin_type : The type of base coin.
-        custom_remainder_address : Address to send the remainder funds to.
-        data : Hex encoded data.
-        initial_address_index : Initial address index.
-        input_range_start : Start of the input range.
-        input_range_end : End of the input range.
-        inputs : Inputs to use.
-        output : Address and amount to send to.
-        outputs : Outputs to use.
-        tag : Hex encoded tag.
-
-        Returns:
-            The created block as dict.
-        """
-
-        options = dict(locals())
-
-        del options['self']
-        del options['secret_manager']
-
-        options = {k: v for k, v in options.items() if v is not None}
-
-        if 'output' in options:
-            options['output'] = options.pop('output').as_dict()
-
-        if 'outputs' in options:
-            options['outputs'] = [v.as_dict() for v in options['outputs']]
-
-        if 'coin_type' in options:
-            options['coin_type'] = int(options.pop('coin_type'))
-
-        is_start_set = 'input_range_start' in options
-        is_end_set = 'input_range_end' in options
-        if is_start_set or is_end_set:
-            options['input_range'] = {}
-            if is_start_set:
-                options['input_range']['start'] = options.pop(
-                    'input_range_start')
-            if is_end_set:
-                options['input_range']['end'] = options.pop('input_range_end')
-
-        options = humps.camelize(options)
-
-        result = self._call_method('buildAndPostBlock', {
-            'secretManager': secret_manager,
-            'options': options
-        })
-        result[1] = Block.from_dict(result[1])
-        return result
-
     def get_node(self) -> Dict[str, Any]:
         """Get a node candidate from the healthy node pool.
         """
         return self._call_method('getNode')
 
-    def get_network_info(self) -> NetworkInfo:
-        """Gets the network related information such as network_id and min_pow_score.
+    def get_protocol_parameters(self) -> ProtocolParameters:
+        """Gets the protocol parameters.
         """
-        return from_dict(NetworkInfo, self._call_method('getNetworkInfo'))
+        return ProtocolParameters.from_dict(
+            self._call_method('getProtocolParameters'))
 
     def get_network_id(self) -> int:
         """Gets the network id of the node we're connecting to.
         """
         return int(self._call_method('getNetworkId'))
 
     def get_bech32_hrp(self) -> str:
         """Returns the bech32_hrp.
         """
         return self._call_method('getBech32Hrp')
 
-    def get_min_pow_score(self) -> int:
-        """Returns the min pow score.
-        """
-        return int(self._call_method('getMinPowScore'))
-
-    def get_tips_interval(self) -> int:
-        """Returns the tips interval.
-        """
-        return int(self._call_method('getTipsInterval'))
-
-    def get_local_pow(self) -> bool:
-        """Returns if local pow should be used or not.
-        """
-        return self._call_method('getLocalPow')
-
-    def get_fallback_to_local_pow(self) -> bool:
-        """Get fallback to local proof of work timeout.
-        """
-        return self._call_method('getFallbackToLocalPow')
-
     def unhealthy_nodes(self) -> List[Dict[str, Any]]:
         """Returns the unhealthy nodes.
         """
         return self._call_method('unhealthyNodes')
 
-    def prepare_transaction(self,
-                            secret_manager: Optional[Union[LedgerNanoSecretManager, MnemonicSecretManager,
-                                                     SeedSecretManager, StrongholdSecretManager]] = None,
-                            options=None):
-        """Prepare a transaction for signing.
-
-        Args:
-            secret_manager: One of the supported secret managers.
-            options: the transaction options.
-        """
-        return from_dict(PreparedTransactionData, self._call_method('prepareTransaction', {
-            'secretManager': secret_manager,
-            'options': options
-        }))
-
-    def sign_transaction(self, secret_manager: Union[LedgerNanoSecretManager, MnemonicSecretManager,
-                                                     SeedSecretManager, StrongholdSecretManager], prepared_transaction_data: PreparedTransactionData) -> TransactionPayload:
-        """Sign a transaction.
-
-        Args:
-            secret_manager: One of the supported secret managers.
-            prepared_transaction_data: a prepared transaction to sign.
-        """
-        return from_dict(TransactionPayload, self._call_method('signTransaction', {
-            'secretManager': secret_manager,
-            'preparedTransactionData': prepared_transaction_data
-        }))
-
-    def submit_payload(self, payload: Payload) -> List[Union[HexStr, Block]]:
-        """Submit a payload in a block.
+    def build_basic_block(
+        self,
+        issuer_id: HexStr,
+        payload: Optional[Payload] = None,
+    ) -> UnsignedBlock:
+        """Build a basic block.
 
         Args:
-            payload : The payload to submit.
+            issuer_id: The identifier of the block issuer account.
+            payload: The payload to submit.
 
         Returns:
-            List of HexStr or Block.
+            An unsigned block.
         """
-        result = self._call_method('postBlockPayload', {
-            'payload': payload.as_dict()
+        result = self._call_method('buildBasicBlock', {
+            'issuerId': issuer_id,
+            'payload': payload,
         })
-        result[1] = Block.from_dict(result[1])
-        return result
+        return UnsignedBlock.from_dict(result)
 
     def listen_mqtt(self, topics: List[str], handler):
         """Listen to MQTT events.
 
         Args:
             topics: The topics to listen to.
             handler: A callback function for MQTT events.
@@ -531,7 +310,21 @@
 
         Args:
             topics: The topics to stop listening to.
         """
         return self._call_method('clearListeners', {
             'topics': topics
         })
+
+
+def convert_nodes(
+        nodes: Optional[Union[Union[str, Node], List[Union[str, Node]]]] = None):
+    """Helper function to convert provided nodes to a list for the client options.
+    """
+    if isinstance(nodes, list):
+        return [node.to_dict() if isinstance(node, Node)
+                else node for node in nodes]
+    if isinstance(nodes, Node):
+        return [nodes.to_dict()]
+    if nodes is not None:
+        return [nodes]
+    return None
```

## iota_sdk/client/_high_level_api.py

```diff
@@ -1,89 +1,63 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from typing import List, Optional, Union
+from typing import List, Optional
+from dataclasses import dataclass
 from abc import ABCMeta, abstractmethod
-from dacite import from_dict
-from iota_sdk.types.block import Block
-from iota_sdk.types.common import CoinType, HexStr
-from iota_sdk.types.output import OutputWithMetadata
+from iota_sdk.client.responses import OutputResponse
+from iota_sdk.types.block.block import Block
+from iota_sdk.types.block.id import BlockId
+from iota_sdk.types.common import CoinType, json
 from iota_sdk.types.output_id import OutputId
-from iota_sdk.secret_manager.secret_manager import LedgerNanoSecretManager, MnemonicSecretManager, StrongholdSecretManager, SeedSecretManager
 
 
+@json
+@dataclass
 class Range:
     """Represents a range of address indexes.
 
     Attributes:
         start: The start index of the address range.
         end: The end index of the address range.
     """
+    start: int
+    end: int
 
-    def __init__(self, start: int, end: int):
-        self.start = start
-        self.end = end
 
-
-class GenerateAddressOptions():
+@json
+@dataclass
+class GenerateAddressOptions:
     """Options for generating an address.
 
     Attributes:
         internal: Whether to generate an internal address.
-        ledgerNanoPrompt: Whether to display the generated address on Ledger Nano devices.
+        ledger_nano_prompt: Whether to display the generated address on Ledger Nano devices.
     """
-
-    def __init__(self, internal: bool, ledgerNanoPrompt: bool):
-        """Initialize GenerateAddressOptions.
-        """
-        self.internal = internal
-        self.ledgerNanoPrompt = ledgerNanoPrompt
+    internal: bool
+    ledger_nano_prompt: bool
 
 
-class GenerateAddressesOptions():
+@json
+@dataclass
+class GenerateAddressesOptions:
     """Options for generating addresses.
 
     Attributes:
-        coinType: The type of coin.
+        coin_type: The type of coin.
         range: The range of addresses to generate.
-        bech32Hrp: The bech32 HRP (human readable part) to use.
-        accountIndex: An account index.
+        bech32_hrp: The bech32 HRP (human readable part) to use.
+        account_index: An account index.
         options: An instance of `GenerateAddressOptions`.
     """
-
-    # pylint: disable=redefined-builtin
-    def __init__(self, coinType: CoinType,
-                 range: Range,
-                 bech32Hrp: str,
-                 accountIndex: Optional[int] = None,
-                 options: Optional[GenerateAddressOptions] = None):
-        """Initialize GenerateAddressesOptions.
-
-        Args:
-            coinType: The type of coin.
-            range: The range of addresses to generate.
-            bech32Hrp: The bech32 HRP (human readable part) to use.
-            accountIndex: An account index.
-            options: An instance of `GenerateAddressOptions`.
-        """
-        self.coinType = coinType
-        self.range = range
-        self.bech32Hrp = bech32Hrp
-        self.accountIndex = accountIndex
-        self.options = options
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        config["range"] = config["range"].__dict__
-        if "options" in config:
-            config["options"] = config["options"].__dict__
-        return config
+    coin_type: CoinType
+    range: Range
+    bech32_hrp: str
+    account_index: Optional[int] = None
+    options: Optional[GenerateAddressOptions] = None
 
 
 class HighLevelAPI(metaclass=ABCMeta):
     """High level API.
     """
 
     @abstractmethod
@@ -104,184 +78,62 @@
         Returns:
 
         The method returns either the payload from the JSON response or the entire response if there is
         no payload.
         """
 
     def get_outputs(
-            self, output_ids: List[OutputId]) -> List[OutputWithMetadata]:
-        """Fetch OutputWithMetadata from provided OutputIds (requests are sent in parallel).
+            self, output_ids: List[OutputId]) -> List[OutputResponse]:
+        """Fetch OutputResponse from provided OutputIds (requests are sent in parallel).
 
         Args:
             output_ids: A list of output ids.
 
         Returns:
-            A list of corresponding `OutputWithMetadata` objects.
+            A list of corresponding `OutputResponse` objects.
         """
         outputs = self._call_method('getOutputs', {
             'outputIds': list(map(lambda o: o.output_id, output_ids))
         })
-        return [from_dict(OutputWithMetadata, o) for o in outputs]
+        return [OutputResponse.from_dict(o) for o in outputs]
 
-    def get_outputs_ignore_errors(
-            self, output_ids: List[OutputId]) -> List[OutputWithMetadata]:
-        """Try to get OutputWithMetadata from provided OutputIds.
+    def get_outputs_ignore_not_found(
+            self, output_ids: List[OutputId]) -> List[OutputResponse]:
+        """Try to get OutputResponse from provided OutputIds.
         Requests are sent in parallel and errors are ignored, can be useful for spent outputs.
 
         Args:
             output_ids: A list of output ids.
 
         Returns:
-            A list of corresponding `OutputWithMetadata` objects.
+            A list of corresponding `OutputResponse` objects.
         """
-        outputs = self._call_method('getOutputsIgnoreErrors', {
+        outputs = self._call_method('getOutputsIgnoreNotFound', {
             'outputIds': list(map(lambda o: o.output_id, output_ids))
         })
-        return [from_dict(OutputWithMetadata, o) for o in outputs]
+        return [OutputResponse.from_dict(o) for o in outputs]
 
-    def find_blocks(self, block_ids: List[HexStr]) -> List[Block]:
+    def find_blocks(self, block_ids: List[BlockId]) -> List[Block]:
         """Find all blocks by provided block IDs.
 
         Args:
             block_ids: A list of block ids.
 
         Returns:
             A list of corresponding `Block`s.
         """
         blocks = self._call_method('findBlocks', {
             'blockIds': block_ids
         })
         return [Block.from_dict(block) for block in blocks]
 
-    def retry(self, block_id: HexStr) -> List[Union[HexStr, Block]]:
-        """Retries (promotes or reattaches) a block for provided block id. Block should only be
-        retried only if they are valid and haven't been confirmed for a while.
-
-        Args:
-            block_id: A block id.
-
-        Returns:
-            A list where the first element is the block id and the second one the block.
-        """
-        result = self._call_method('retry', {'blockId': block_id})
-        result[1] = Block.from_dict(result[1])
-        return result
-
-    def retry_until_included(
-            self, block_id: HexStr, interval: Optional[int] = None, max_attempts: Optional[int] = None) -> List[List[Union[HexStr, Block]]]:
-        """Retries (promotes or reattaches) a block for provided block id until it's included (referenced by a
-        milestone). Default interval is 5 seconds and max attempts is 40. Returns the included block at first
-        position and additional reattached blocks.
-
-        Args:
-            block_id: A block id.
-            interval: A retry interval in seconds. Defaults to 5.
-            max_attempts: A maximum number of retries. Defaults to 40.
-
-        Returns:
-            A list of lists where the first element is the block id and the second one the block.
-        """
-        result = self._call_method('retryUntilIncluded', {
-            'blockId': block_id,
-            'interval': interval,
-            'maxAttempts': max_attempts
-        })
-
-        def block_class(block_id_and_block):
-            block_id_and_block[1] = Block.from_dict(block_id_and_block[1])
-            return block_id_and_block
-        blockIdsAndBlocks = [block_class(block_id_and_block)
-                             for block_id_and_block in result]
-        return blockIdsAndBlocks
-
-    def consolidate_funds(self, secret_manager: Union[LedgerNanoSecretManager, MnemonicSecretManager, SeedSecretManager,
-                          StrongholdSecretManager], generate_addresses_options: GenerateAddressesOptions) -> str:
-        """Function to consolidate all funds from a range of addresses to the address with the lowest index in that range.
-        Returns the address to which the funds got consolidated, if any were available.
-
-        Args:
-            secret_manager: A supported secret manager.
-            generate_addresses_options: Options to generate addresses.
-
-        Returns:
-            An address to which the funds got consolidated.
-        """
-        return self._call_method('consolidateFunds', {
-            'secretManager': secret_manager,
-            'generateAddressesOptions': generate_addresses_options.as_dict(),
-        })
-
     def find_inputs(self, addresses: List[str], amount: int):
         """Function to find inputs from addresses for a provided amount(useful for offline signing).
 
         Args:
             addresses: A list of included addresses.
             amount: The amount to find inputs for.
         """
         return self._call_method('findInputs', {
             'addresses': addresses,
             'amount': amount
         })
-
-    def reattach(self, block_id: HexStr) -> List[Union[HexStr, Block]]:
-        """Reattaches blocks for a provided block id. Blocks can be reattached only if they are valid and
-        haven't been confirmed for a while .
-
-        Args:
-            block_id: A block id of a block that should be reattached.
-
-        Returns:
-            The reattached block id and block.
-        """
-        result = self._call_method('reattach', {
-            'blockId': block_id
-        })
-        result[1] = Block.from_dict(result[1])
-        return result
-
-    def reattach_unchecked(
-            self, block_id: HexStr) -> List[Union[HexStr, Block]]:
-        """Reattach a block without checking if it should be reattached.
-
-        Args:
-            block_id: A block id of a block that should be reattached.
-
-        Returns:
-            The reattached block id and block.
-        """
-        result = self._call_method('reattachUnchecked', {
-            'blockId': block_id
-        })
-        result[1] = Block.from_dict(result[1])
-        return result
-
-    def promote(self, block_id: HexStr) -> List[Union[HexStr, Block]]:
-        """Promotes a block. The method should validate if a promotion is necessary through get_block.
-        If not, the method should error out and should not allow unnecessary promotions.
-
-        Args:
-            block_id: A block id of a block that should be promoted.
-
-        Returns:
-            The block id and block that promoted the provided block.
-        """
-        result = self._call_method('promote', {
-            'blockId': block_id
-        })
-        result[1] = Block.from_dict(result[1])
-        return result
-
-    def promote_unchecked(
-            self, block_id: HexStr) -> List[Union[HexStr, Block]]:
-        """Promote a block without checking if it should be promoted.
-
-        Args:
-            block_id: A block id of a block that should be promoted.
-
-        Returns:
-            The block id and block that promoted the provided block.
-        """
-        result = self._call_method('promoteUnchecked', {
-            'blockId': block_id
-        })
-        result[1] = Block.from_dict(result[1])
-        return result
```

## iota_sdk/client/_node_core_api.py

```diff
@@ -1,21 +1,20 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from typing import List, Union
+from typing import List, Optional, Union
 from abc import ABCMeta, abstractmethod
-from dacite import from_dict
-
-from iota_sdk.types.block import Block, BlockMetadata
-from iota_sdk.types.common import HexStr
-from iota_sdk.types.node_info import NodeInfo, NodeInfoWrapper
-from iota_sdk.types.output import OutputWithMetadata, OutputMetadata
+from iota_sdk.client.responses import InfoResponse, NodeInfoResponse, NetworkMetricsResponse, RoutesResponse, CongestionResponse, ManaRewardsResponse, CommitteeResponse, ValidatorResponse, ValidatorsResponse, IssuanceBlockHeaderResponse, BlockMetadataResponse, BlockWithMetadataResponse, OutputResponse, OutputWithMetadataResponse, TransactionMetadataResponse, UtxoChangesResponse, UtxoChangesFullResponse
+from iota_sdk.types.block.block import Block
+from iota_sdk.types.block.id import BlockId
+from iota_sdk.types.common import HexStr, EpochIndex, SlotIndex
 from iota_sdk.types.output_id import OutputId
-from iota_sdk.types.payload import MilestonePayload
-from iota_sdk.types.utxo_changes import UtxoChanges
+from iota_sdk.types.output_metadata import OutputMetadata
+from iota_sdk.types.slot import SlotCommitment, SlotCommitmentId
+from iota_sdk.types.transaction_id import TransactionId
 
 
 class NodeCoreAPI(metaclass=ABCMeta):
     """Node core API.
     """
 
     @abstractmethod
@@ -35,217 +34,414 @@
 
         Returns:
 
         The method returns either the payload from the JSON response or the entire response if there is
         no payload.
         """
 
-    def get_health(self, url: str):
-        """ Get node health.
+    # Node routes.
+
+    def get_health(self, url: str) -> bool:
+        """Returns the health of the node.
+        GET /health
 
         Args:
             url: The node's url.
         """
         return self._call_method('getHealth', {
             'url': url
         })
 
-    def get_node_info(self, url: str, auth=None) -> NodeInfo:
-        """Get node info.
+    def get_routes(self) -> RoutesResponse:
+        """Returns the available API route groups of the node.
+        GET /api/routes
+        """
+        return RoutesResponse.from_dict(self._call_method('getRoutes'))
+
+    def get_node_info(self) -> NodeInfoResponse:
+        """Returns general information about a node together with its URL.
+        GET /api/core/v3/info
+
+        Returns:
+            The node info with its URL.
+        """
+        return NodeInfoResponse.from_dict(self._call_method('getNodeInfo'))
+
+    def get_info(self, url: str, auth=None) -> InfoResponse:
+        """Returns general information about the node.
+        GET /api/core/v3/info
 
         Args:
             url: The node's url.
             auth: A JWT or username/password authentication object.
+
+        Returns:
+            The node info.
         """
-        return from_dict(NodeInfo, self._call_method('getNodeInfo', {
+        return InfoResponse.from_dict(self._call_method('getInfo', {
             'url': url,
             'auth': auth
         }))
 
-    def get_info(self) -> NodeInfoWrapper:
-        """Return node information together with the url of the used node.
+    def get_network_metrics(self) -> NetworkMetricsResponse:
+        """Returns network metrics.
+        GET /api/core/v3/network/metrics
+
+        Returns:
+            Network metrics.
+        """
+        return NetworkMetricsResponse.from_dict(
+            self._call_method('getNetworkMetrics'))
+
+    # Accounts routes.
+
+    def get_account_congestion(
+            self, account_id: HexStr, work_score: Optional[int] = None) -> CongestionResponse:
+        """Checks if the account is ready to issue a block.
+        GET /api/core/v3/accounts/{bech32Address}/congestion
         """
-        return from_dict(NodeInfoWrapper, self._call_method('getInfo'))
+        return CongestionResponse.from_dict(self._call_method('getAccountCongestion', {
+            'accountId': account_id,
+            'workScore': work_score
+        }))
+
+    # Rewards routes.
+
+    def get_output_mana_rewards(
+            self, output_id: OutputId, slot_index: Optional[SlotIndex] = None) -> ManaRewardsResponse:
+        """Returns the total available Mana rewards of an account or delegation output decayed up to `epochEnd` index
+        provided in the response.
+        Note that rewards for an epoch only become available at the beginning of the next epoch. If the end epoch of a
+        staking feature is equal or greater than the current epoch, the rewards response will not include the potential
+        future rewards for those epochs. `epochStart` and `epochEnd` indicates the actual range for which reward value
+        is returned and decayed for.
+        GET /api/core/v3/rewards/{outputId}
+        """
+        return ManaRewardsResponse.from_dict(self._call_method('getOutputManaRewards', {
+            'outputId': output_id,
+            'slotIndex': slot_index
+        }))
+
+    # Validators routes.
+
+    def get_validators(
+            self, page_size: Optional[int] = None, cursor: Optional[str] = None) -> ValidatorsResponse:
+        """Returns information of all stakers (registered validators) and if they are active, ordered by their holding stake.
+        GET /api/core/v3/validators
+        """
+        return ValidatorsResponse.from_dict(self._call_method('getValidators', {
+            'pageSize': page_size,
+            'cursor': cursor
+        }))
 
-    def get_peers(self):
-        """Get the peers of the node.
+    def get_validator(self, account_id: HexStr) -> ValidatorResponse:
+        """Return information about a staker (registered validator).
+        GET /api/core/v3/validators/{bech32Address}
         """
-        return self._call_method('getPeers')
+        return ValidatorResponse.from_dict(self._call_method('getValidator', {
+            'accountId': account_id
+        }))
 
-    def get_tips(self) -> List[HexStr]:
-        """Request tips from the node.
+    # Committee routes.
+
+    def get_committee(
+            self, epoch: Optional[EpochIndex] = None) -> CommitteeResponse:
+        """Returns the information of committee members at the given epoch index. If epoch index is not provided, the
+        current committee members are returned.
+        GET /api/core/v3/committee/?epoch
         """
-        return self._call_method('getTips')
+        return CommitteeResponse.from_dict(self._call_method('getCommittee', {
+            'epoch': epoch
+        }))
 
-    def post_block(self, block: Block) -> HexStr:
-        """Post a block.
+    # Block routes.
+
+    def get_issuance(self) -> IssuanceBlockHeaderResponse:
+        """Returns information that is ideal for attaching a block in the network.
+        GET /api/core/v3/blocks/issuance
+        """
+        return IssuanceBlockHeaderResponse.from_dict(
+            self._call_method('getIssuance'))
+
+    def post_block(self, block: Block) -> BlockId:
+        """Returns the BlockId of the submitted block.
+        POST /api/core/v3/blocks
 
         Args:
             block: The block to post.
 
         Returns:
             The block id of the posted block.
         """
         return self._call_method('postBlock', {
-            'block': block.__dict__
+            'block': block
         })
 
-    def get_block_data(self, block_id: HexStr) -> Block:
-        """Get the block corresponding to the given block id.
+    def post_block_raw(self, block_bytes: bytes) -> BlockId:
+        """Returns the BlockId of the submitted block.
+        POST /api/core/v3/blocks
+
+        Returns:
+            The corresponding block id of the block.
         """
-        return Block.from_dict(self._call_method('getBlock', {
-            'blockId': block_id
-        }))
+        return self._call_method('postBlockRaw', {
+            'blockBytes': block_bytes
+        })
 
-    def get_block_metadata(self, block_id: HexStr) -> BlockMetadata:
-        """Get the block metadata corresponding to the given block id.
+    def get_block(self, block_id: BlockId) -> Block:
+        """Finds a block by its ID and returns it as object.
+        GET /api/core/v3/blocks/{blockId}
+
+        Returns:
+            The corresponding block.
         """
-        return BlockMetadata.from_dict(self._call_method('getBlockMetadata', {
+        return Block.from_dict(self._call_method('getBlock', {
             'blockId': block_id
         }))
 
-    def get_block_raw(self, block_id: HexStr) -> List[int]:
-        """Get the raw bytes of the block corresponding to the given block id.
+    def get_block_raw(self, block_id: BlockId) -> List[int]:
+        """Finds a block by its ID and returns it as raw bytes.
+        GET /api/core/v3/blocks/{blockId}
+
+        Returns:
+            The corresponding raw bytes of a block.
         """
         return self._call_method('getBlockRaw', {
             'blockId': block_id
         })
 
-    def post_block_raw(self, block_bytes: List[int]) -> HexStr:
-        """Post a block as raw bytes.
+    def get_block_metadata(self, block_id: BlockId) -> BlockMetadataResponse:
+        """Returns the metadata of a block.
+        GET /api/core/v3/blocks/{blockId}/metadata
 
         Returns:
-            The corresponding block id of the block.
+            The corresponding block metadata.
         """
-        return self._call_method('postBlockRaw', {
-            'blockBytes': block_bytes
-        })
+        return BlockMetadataResponse.from_dict(self._call_method('getBlockMetadata', {
+            'blockId': block_id
+        }))
+
+    def get_block_with_metadata(
+            self, block_id: BlockId) -> BlockWithMetadataResponse:
+        """Returns a block with its metadata.
+        GET /api/core/v2/blocks/{blockId}/full
+
+        Returns:
+            The corresponding block with it metadata.
+        """
+        return BlockWithMetadataResponse.from_dict(self._call_method('getBlockWithMetadata', {
+            'blockId': block_id
+        }))
+
+    # UTXO routes.
 
     def get_output(
-            self, output_id: Union[OutputId, HexStr]) -> OutputWithMetadata:
-        """Get the output corresponding to the given output id.
+            self, output_id: Union[OutputId, HexStr]) -> OutputResponse:
+        """Finds an output by its ID and returns it as object.
+        GET /api/core/v3/outputs/{outputId}
 
         Returns:
-            The output itself with its metadata.
+            The corresponding output.
         """
         output_id_str = output_id.output_id if isinstance(
             output_id, OutputId) else output_id
-        return from_dict(OutputWithMetadata, self._call_method('getOutput', {
+        return OutputResponse.from_dict(self._call_method('getOutput', {
             'outputId': output_id_str
         }))
 
+    def get_output_raw(
+            self, output_id: Union[OutputId, HexStr]) -> List[int]:
+        """Finds an output by its ID and returns it as raw bytes.
+        GET /api/core/v3/outputs/{outputId}
+
+        Returns:
+            The raw bytes of the corresponding output.
+        """
+        output_id_str = output_id.output_id if isinstance(
+            output_id, OutputId) else output_id
+        return self._call_method('getOutputRaw', {
+            'outputId': output_id_str
+        })
+
     def get_output_metadata(
             self, output_id: Union[OutputId, HexStr]) -> OutputMetadata:
-        """Get the output metadata corresponding to the given output id.
+        """Finds output metadata by output ID.
+        GET /api/core/v3/outputs/{outputId}/metadata
 
         Returns:
             The output metadata.
         """
         output_id_str = output_id.output_id if isinstance(
             output_id, OutputId) else output_id
-        return from_dict(OutputMetadata, self._call_method('getOutputMetadata', {
+        return OutputMetadata.from_dict(self._call_method('getOutputMetadata', {
             'outputId': output_id_str
         }))
 
-    def get_milestone_by_id(self, milestone_id: HexStr) -> MilestonePayload:
-        """Get the milestone corresponding to the given milestone id.
+    def get_output_with_metadata(
+            self, output_id: Union[OutputId, HexStr]) -> OutputWithMetadataResponse:
+        """Finds an output with its metadata by output ID.
+        GET /api/core/v3/outputs/{outputId}/full
 
         Returns:
-            The milestone payload.
+            The corresponding output with its metadata.
         """
-        result = self._call_method('getMilestoneById', {
-            'milestoneId': milestone_id
-        })
-        return MilestonePayload.from_dict(result)
+        output_id_str = output_id.output_id if isinstance(
+            output_id, OutputId) else output_id
+        return OutputWithMetadataResponse.from_dict(self._call_method('getOutputWithMetadata', {
+            'outputId': output_id_str
+        }))
 
-    def get_milestone_by_id_raw(self, milestone_id: HexStr) -> List[int]:
-        """Get the raw bytes of the milestone corresponding to the given milestone id.
+    def get_included_block(self, transaction_id: TransactionId) -> Block:
+        """Returns the earliest confirmed block containing the transaction with the given ID.
+        GET /api/core/v3/transactions/{transactionId}/included-block
 
         Returns:
-            The raw bytes of the milestone.
+            The included block.
         """
-        return self._call_method('getMilestoneByIdRaw', {
-            'milestoneId': milestone_id
-        })
+        return Block.from_dict(self._call_method('getIncludedBlock', {
+            'transactionId': transaction_id
+        }))
 
-    def get_milestone_by_index(self, index: int) -> MilestonePayload:
-        """Get the milestone by the given milestone index.
+    def get_included_block_raw(
+            self, transaction_id: TransactionId) -> List[int]:
+        """Returns the earliest confirmed block containing the transaction with the given ID, as raw bytes.
+        GET /api/core/v3/transactions/{transactionId}/included-block
 
         Returns:
-            The milestone payload.
+            The raw bytes of the included block.
         """
-        result = self._call_method('getMilestoneByIndex', {
-            'index': index
+        return self._call_method('getIncludedBlockRaw', {
+            'transactionId': transaction_id
         })
-        return MilestonePayload.from_dict(result)
 
-    def get_milestone_by_index_raw(self, index: int) -> List[int]:
-        """Get the raw bytes of the milestone corresponding to the given milestone index.
+    def get_included_block_metadata(
+            self, transaction_id: TransactionId) -> BlockMetadataResponse:
+        """Returns the metadata of the earliest block containing the tx that was confirmed.
+        GET /api/core/v3/transactions/{transactionId}/included-block/metadata
 
         Returns:
-            The raw bytes of the milestone.
+            The metadata of the included block.
         """
-        return self._call_method('getMilestoneByIndexRaw', {
-            'index': index
-        })
+        return BlockMetadataResponse.from_dict(self._call_method('getIncludedBlockMetadata', {
+            'transactionId': transaction_id
+        }))
+
+    def get_transaction_metadata(
+            self, transaction_id: TransactionId) -> TransactionMetadataResponse:
+        """Finds the metadata of a transaction.
+        GET /api/core/v3/transactions/{transactionId}/metadata
 
-    def get_utxo_changes_by_id(self, milestone_id: HexStr) -> UtxoChanges:
-        """Get the UTXO changes applied in the given milestone.
+        Returns:
+            The transaction metadata.
         """
-        return from_dict(UtxoChanges, self._call_method('getUtxoChangesById', {
-            'milestoneId': milestone_id
+        return TransactionMetadataResponse.from_dict(self._call_method('getTransactionMetadata', {
+            'transactionId': transaction_id
         }))
 
-    def get_utxo_changes_by_index(self, index: int) -> UtxoChanges:
-        """Get the UTXO changes applied at the given milestone index.
+    # Commitments routes.
+
+    def get_commitment(
+            self, commitment_id: SlotCommitmentId) -> SlotCommitment:
+        """Finds a slot commitment by its ID and returns it as object.
+        GET /api/core/v3/commitments/{commitmentId}
+
+        Returns:
+            The corresponding slot commitment.
         """
-        return from_dict(UtxoChanges, self._call_method('getUtxoChangesByIndex', {
-            'index': index
+        return SlotCommitment.from_dict(self._call_method('getCommitment', {
+            'commitmentId': commitment_id
         }))
 
-    def get_receipts(self):
-        """Get all receipts.
-        """
-        return self._call_method('getReceipts')
+    def get_commitment_raw(
+            self, commitment_id: SlotCommitmentId) -> List[int]:
+        """Finds a slot commitment by its ID and returns it as raw bytes.
+        GET /api/core/v3/commitments/{commitmentId}
 
-    def get_receipts_migrated_at(self, milestone_index: int):
-        """Get the receipts that were migrated at the given milestone index.
+        Returns:
+            The raw bytes of the corresponding slot commitment.
         """
-        return self._call_method('getReceiptsMigratedAt', {
-            'milestoneIndex': milestone_index
+        return self._call_method('getCommitmentRaw', {
+            'commitmentId': commitment_id
         })
 
-    def get_treasury(self):
-        """Get the treasury output.
+    def get_utxo_changes(
+            self, commitment_id: SlotCommitmentId) -> UtxoChangesResponse:
+        """Get all UTXO changes of a given slot by slot commitment ID.
+        GET /api/core/v3/commitments/{commitmentId}/utxo-changes
+
+        Returns:
+            The corresponding UTXO changes.
         """
-        return self._call_method('getTreasury')
+        return UtxoChangesResponse.from_dict(self._call_method('getUtxoChanges', {
+            'commitmentId': commitment_id
+        }))
 
-    def get_included_block(self, transaction_id: HexStr) -> Block:
-        """Returns the included block of the given transaction.
+    def get_utxo_changes_full(
+            self, commitment_id: SlotCommitmentId) -> UtxoChangesFullResponse:
+        """Get all full UTXO changes of a given slot by slot commitment ID.
+        GET /api/core/v3/commitments/{commitmentId}/utxo-changes/full
 
         Returns:
-            The included block.
+            The full UTXO changes.
         """
-        return Block.from_dict(self._call_method('getIncludedBlock', {
-            'transactionId': transaction_id
+        return UtxoChangesFullResponse.from_dict(self._call_method('getUtxoChangesFull', {
+            'commitmentId': commitment_id
         }))
 
-    def get_included_block_metadata(
-            self, transaction_id: HexStr) -> BlockMetadata:
-        """Returns the metadata of the included block of the given transaction.
+    def get_commitment_by_slot(
+            self, slot: SlotIndex) -> SlotCommitment:
+        """Finds a slot commitment by slot index and returns it as object.
+        GET /api/core/v3/commitments/by-slot/{slot}
 
         Returns:
-            The metadata of the included block.
+            The corresponding slot commitment.
         """
-        return BlockMetadata.from_dict(self._call_method('getIncludedBlockMetadata', {
-            'transactionId': transaction_id
+        return SlotCommitment.from_dict(self._call_method('getCommitmentBySlot', {
+            'slot': slot
         }))
 
+    def get_commitment_by_slot_raw(
+            self, slot: SlotIndex) -> List[int]:
+        """Finds a slot commitment by slot index and returns it as raw bytes.
+        GET /api/core/v3/commitments/by-slot/{slot}
+
+        Returns:
+            The raw bytes of the corresponding slot commitment.
+        """
+        return self._call_method('getCommitmentBySlotRaw', {
+            'slot': slot
+        })
+
+    def get_utxo_changes_by_slot(self, slot: SlotIndex) -> UtxoChangesResponse:
+        """Get all UTXO changes of a given slot by its index.
+        GET /api/core/v3/commitments/by-slot/{slot}/utxo-changes
+
+        Returns:
+            The corresponding UTXO changes.
+        """
+        return UtxoChangesResponse.from_dict(self._call_method('getUtxoChangesBySlot', {
+            'slot': slot
+        }))
+
+    def get_utxo_changes_full_by_slot(
+            self, slot: SlotIndex) -> UtxoChangesFullResponse:
+        """Get all full UTXO changes of a given slot by its index.
+        GET /api/core/v3/commitments/by-slot/{slot}/utxo-changes/full
+
+        Returns:
+            The full UTXO changes.
+        """
+        return UtxoChangesFullResponse.from_dict(self._call_method('getUtxoChangesFullBySlot', {
+            'slot': slot
+        }))
+
+    # Plugin routes.
+
     def call_plugin_route(self, base_plugin_path: str, method: str,
-                          endpoint: str, query_params: [str] = None, request: str = None):
+                          endpoint: str, query_params: Optional[List[str]] = None, request: Optional[str] = None):
         """Extension method which provides request methods for plugins.
 
         Args:
             base_plugin_path: The base path of the routes provided by the plugin.
             method: The HTTP method.
             endpoint: The endpoint to query provided by the plugin.
             query_params: The parameters of the query.
```

## iota_sdk/client/_node_indexer_api.py

```diff
@@ -1,246 +1,375 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from dataclasses import dataclass
-from typing import Dict, Optional
+from typing import Optional
 from abc import ABCMeta, abstractmethod
-import humps
-
-from iota_sdk.types.common import HexStr
+from iota_sdk.client.responses import OutputIdsResponse
+from iota_sdk.types.common import HexStr, json, SlotIndex
 from iota_sdk.types.output_id import OutputId
 
 
-class OutputIdsResponse:
-    """Response type for output IDs.
-
-    Attributes:
-        ledger_index: The ledger index for which the response is valid.
-        cursor: The cursor to the next page of results.
-        items: The query results.
+class NodeIndexerAPI(metaclass=ABCMeta):
+    """Node indexer API.
     """
 
-    def __init__(self, output_dict: Dict):
-        self.ledgerIndex = output_dict["ledgerIndex"]
-        self.cursor = output_dict["cursor"]
-        self.items = [OutputId.from_string(
-            output_id) for output_id in output_dict["items"]]
+    @json
+    @dataclass
+    class CommonQueryParameters:
+        """Common Query parameters
 
+        **Attributes:**
 
-class NodeIndexerAPI(metaclass=ABCMeta):
-    """Node indexer API.
-    """
+        page_size:
+            The maximum amount of items returned in one call. If there are more items, a cursor to the next page is
+            returned too. The parameter is ignored when pageSize is defined via the cursor parameter.
+        cursor:
+            Starts the search from the cursor (createdSlotIndex+outputId.pageSize).
+            If an empty string is provided, only the first page is returned.
+        created_before:
+            Returns outputs that were created before a certain slot index.
+        created_after:
+            Returns outputs that were created after a certain slot index.
+        """
+        page_size: Optional[int] = None
+        cursor: Optional[str] = None
+        created_before: Optional[SlotIndex] = None
+        created_after: Optional[SlotIndex] = None
 
+    @json
     @dataclass
-    class QueryParameters:
-        """Query parameters
+    class OutputQueryParameters(CommonQueryParameters):
+        """Output Query parameters
 
         **Attributes:**
-        address :
+
+        has_native_token:
+            Filters outputs based on the presence of a native token.
+        native_token:
+            Filters outputs based on the presence of a specific native token.
+        unlockable_by_address:
+            Returns outputs that are unlockable by the bech32 address.
+        """
+        has_native_token: Optional[bool] = None
+        native_token: Optional[HexStr] = None
+        unlockable_by_address: Optional[str] = None
+
+    @json
+    @dataclass
+    class BasicOutputQueryParameters(CommonQueryParameters):
+        """Basic Output Query parameters
+
+        **Attributes: **
+        has_native_token:
+            Filters outputs based on the presence of a native token.
+        native_token:
+            Filters outputs based on the presence of a specific native token.
+        unlockable_by_address:
+            Returns outputs that are unlockable by the bech32 address.
+        address:
             Bech32-encoded address that should be searched for.
-        alias_address :
-            Filter foundry outputs based on bech32-encoded address of the controlling alias.
-        created_after :
-            Returns outputs that were created after a certain Unix timestamp.
-            created_before :
-            Returns outputs that were created before a certain Unix timestamp.
-            cursor :
-            Starts the search from the cursor (confirmationMS+outputId.pageSize).
-            expiration_return_address :
-            Filters outputs based on the presence of a specific Bech32-encoded return address in the expiration unlock
-            condition.
-            expires_after :
-            Returns outputs that expire after a certain Unix timestamp.
-            expires_before :
-            Returns outputs that expire before a certain Unix timestamp.
-            governor :
-            Filters outputs based on bech32-encoded governor (governance controller) address.
-            has_expiration :
-            Filters outputs based on the presence of expiration unlock condition.
-            has_native_tokens :
-            Filters outputs based on the presence of native tokens.
-            has_storage_deposit_return :
+        has_storage_deposit_return:
             Filters outputs based on the presence of storage deposit return unlock condition.
-            has_timelock :
+        storage_deposit_return_address:
+            Filters outputs based on the presence of a specific return address in the storage deposit return unlock condition.
+        has_expiration:
+            Filters outputs based on the presence of expiration unlock condition.
+        expiration_return_address:
+            Filters outputs based on the presence of a specific Bech32-encoded return address in the expiration unlock condition.
+        expires_before:
+            Returns outputs that expire before a certain slot index.
+        expires_after:
+            Returns outputs that expire after a certain slot index.
+        has_timelock:
             Filters outputs based on the presence of timelock unlock condition.
-            issuer:
-            Filters outputs based on bech32-encoded issuer address.
-            max_native_token_count :
-            Filters outputs that have at most a certain number of distinct native tokens.
-            min_native_token_count :
-            Filters outputs that have at least a certain number of distinct native tokens.
-            page_size :
-            The maximum amount of items returned in one call. If there are more items, a cursor to the next page is
-            returned too. The parameter is ignored when pageSize is defined via the cursor parameter.
-            sender :
+        timelocked_before:
+            Returns outputs that are timelocked before a certain slot index.
+        timelocked_after:
+            Returns outputs that are timelocked after a certain slot index.
+        sender:
             Filters outputs based on the presence of validated Sender (bech32 encoded).
-            state_controller :
-            Filters outputs based on bech32-encoded state controller address.
-            storage_deposit_return_address :
-            Filters outputs based on the presence of a specific return address in the storage deposit return unlock
-            condition.
-            tag :
+        tag:
             Filters outputs based on matching Tag Block.
-            timelocked_after :
-            Returns outputs that are timelocked after a certain Unix timestamp.
-            timelocked_before :
-            Returns outputs that are timelocked before a certain Unix timestamp.
-         unlockable_by_address :
-            Returns outputs that are unlockable by the bech32 address.
         """
+        has_native_token: Optional[bool] = None
+        native_token: Optional[HexStr] = None
+        unlockable_by_address: Optional[str] = None
         address: Optional[str] = None
-        alias_address: Optional[str] = None
-        created_after: Optional[int] = None
-        created_before: Optional[int] = None
-        cursor: Optional[str] = None
-        expiration_return_address: Optional[str] = None
-        expires_after: Optional[int] = None
-        expires_before: Optional[int] = None
-        governor: Optional[str] = None
-        has_expiration: Optional[bool] = None
-        has_native_tokens: Optional[bool] = None
         has_storage_deposit_return: Optional[bool] = None
+        storage_deposit_return_address: Optional[str] = None
+        has_expiration: Optional[bool] = None
+        expiration_return_address: Optional[str] = None
+        expires_before: Optional[SlotIndex] = None
+        expires_after: Optional[SlotIndex] = None
         has_timelock: Optional[bool] = None
+        timelocked_before: Optional[SlotIndex] = None
+        timelocked_after: Optional[SlotIndex] = None
+        sender: Optional[str] = None
+        tag: Optional[HexStr] = None
+
+    @json
+    @dataclass
+    class AccountOutputQueryParameters(CommonQueryParameters):
+        """Account Output Query parameters
+
+        **Attributes: **
+        address:
+            Bech32-encoded address that should be searched for.
+        issuer:
+            Filters outputs based on bech32-encoded issuer address.
+        sender:
+            Filters outputs based on the presence of validated Sender (bech32 encoded).
+        """
+        address: Optional[str] = None
         issuer: Optional[str] = None
-        max_native_token_count: Optional[int] = None
-        min_native_token_count: Optional[int] = None
-        page_size: Optional[int] = None
         sender: Optional[str] = None
-        state_controller: Optional[str] = None
-        storage_deposit_return_address: Optional[str] = None
-        tag: Optional[str] = None
-        timelocked_after: Optional[int] = None
-        timelocked_before: Optional[int] = None
+
+    @json
+    @dataclass
+    class AnchorOutputQueryParameters(CommonQueryParameters):
+        """Anchor Output Query parameters
+
+        **Attributes: **
+        unlockable_by_address:
+            Returns outputs that are unlockable by the bech32 address.
+        state_controller:
+            Filters outputs based on bech32-encoded state controller address.
+        governor:
+            Filters outputs based on bech32-encoded governor (governance controller) address.
+        issuer:
+            Filters outputs based on bech32-encoded issuer address.
+        sender:
+            Filters outputs based on the presence of validated Sender (bech32 encoded).
+        """
         unlockable_by_address: Optional[str] = None
+        state_controller: Optional[str] = None
+        governor: Optional[str] = None
+        issuer: Optional[str] = None
+        sender: Optional[str] = None
 
-        def as_dict(self):
-            """Converts this object to a dict.
-            """
-            return humps.camelize(
-                [{k: v} for k, v in self.__dict__.items() if v is not None])
+    @json
+    @dataclass
+    class DelegationOutputQueryParameters(CommonQueryParameters):
+        """Delegation Output Query parameters
 
-    @abstractmethod
-    def _call_method(self, name, data=None):
+        **Attributes: **
+        address:
+            Bech32-encoded address that should be searched for.
+        validator:
+            Filter foundry outputs based on bech32-encoded address of the validator.
         """
-        Sends a message to the Rust library and returns the response.
-        It is abstract here as its implementation is located in `client.py`, which is a composite class.
+        address: Optional[str] = None
+        validator: Optional[str] = None
 
-        Arguments:
+    @json
+    @dataclass
+    class FoundryOutputQueryParameters(CommonQueryParameters):
+        """Foundry Output Query parameters
 
-        * `name`: The `name` parameter is a string that represents the name of the method to be called.
-        It is used to identify the specific method to be executed in the Rust library.
-        * `data`: The `data` parameter is an optional parameter that represents additional data to be
-        sent along with the method call. It is a dictionary that contains key-value pairs of data. If
-        the `data` parameter is provided, it will be included in the `message` dictionary as the 'data'
-        key.
+        **Attributes: **
+        has_native_token:
+            Filters outputs based on the presence of a native token.
+        native_token:
+            Filters outputs based on the presence of a specific native token.
+        account:
+            Filter foundry outputs based on bech32-encoded address of the controlling account.
+        """
+        has_native_token: Optional[bool] = None
+        native_token: Optional[HexStr] = None
+        account: Optional[str] = None
 
-        Returns:
+    @json
+    @dataclass
+    class NftOutputQueryParameters(CommonQueryParameters):
+        """NFT Output Query parameters
 
-        The method returns either the payload from the JSON response or the entire response if there is
-        no payload.
+        **Attributes: **
+        unlockable_by_address:
+            Returns outputs that are unlockable by the bech32 address.
+        address:
+            Bech32-encoded address that should be searched for.
+        has_storage_deposit_return:
+            Filters outputs based on the presence of storage deposit return unlock condition.
+        storage_deposit_return_address:
+            Filters outputs based on the presence of a specific return address in the storage deposit return unlock condition.
+        has_expiration:
+            Filters outputs based on the presence of expiration unlock condition.
+        expiration_return_address:
+            Filters outputs based on the presence of a specific Bech32-encoded return address in the expiration unlock condition.
+        expires_before:
+            Returns outputs that expire before a certain slot index.
+        expires_after:
+            Returns outputs that expire after a certain slot index.
+        has_timelock:
+            Filters outputs based on the presence of timelock unlock condition.
+        timelocked_before:
+            Returns outputs that are timelocked before a certain slot index.
+        timelocked_after:
+            Returns outputs that are timelocked after a certain slot index.
+        issuer:
+            Filters outputs based on bech32-encoded issuer address.
+        sender:
+            Filters outputs based on the presence of validated Sender (bech32 encoded).
+        tag:
+            Filters outputs based on matching Tag Block.
         """
+        unlockable_by_address: Optional[str] = None
+        address: Optional[str] = None
+        has_storage_deposit_return: Optional[bool] = None
+        storage_deposit_return_address: Optional[str] = None
+        has_expiration: Optional[bool] = None
+        expiration_return_address: Optional[str] = None
+        expires_before: Optional[SlotIndex] = None
+        expires_after: Optional[SlotIndex] = None
+        has_timelock: Optional[bool] = None
+        timelocked_before: Optional[SlotIndex] = None
+        timelocked_after: Optional[SlotIndex] = None
+        issuer: Optional[str] = None
+        sender: Optional[str] = None
+        tag: Optional[HexStr] = None
+
+    @abstractmethod
+    def _call_method(self, name, data=None):
+        return {}
 
     def output_ids(
-            self, query_parameters: QueryParameters) -> OutputIdsResponse:
-        """Fetch alias/basic/NFT/foundry output IDs from the given query parameters.
+            self, query_parameters: OutputQueryParameters) -> OutputIdsResponse:
+        """Fetch account/anchor/basic/delegation/NFT/foundry output IDs from the given query parameters.
         Supported query parameters are: "hasNativeTokens", "minNativeTokenCount", "maxNativeTokenCount", "unlockableByAddress", "createdBefore", "createdAfter", "cursor", "pageSize".
 
         Returns:
             The corresponding output IDs of the outputs.
         """
 
-        query_parameters_camelized = query_parameters.as_dict()
-
         response = self._call_method('outputIds', {
-            'queryParameters': query_parameters_camelized,
+            'queryParameters': query_parameters,
         })
         return OutputIdsResponse(response)
 
     def basic_output_ids(
-            self, query_parameters: QueryParameters) -> OutputIdsResponse:
+            self, query_parameters: BasicOutputQueryParameters) -> OutputIdsResponse:
         """Fetch basic output IDs from the given query parameters.
 
         Returns:
             The corresponding output IDs of the basic outputs.
         """
 
-        query_parameters_camelized = query_parameters.as_dict()
-
         response = self._call_method('basicOutputIds', {
-            'queryParameters': query_parameters_camelized,
+            'queryParameters': query_parameters,
         })
         return OutputIdsResponse(response)
 
-    def alias_output_ids(
-            self, query_parameters: QueryParameters) -> OutputIdsResponse:
-        """Fetch alias output IDs from the given query parameters.
+    def account_output_ids(
+            self, query_parameters: AccountOutputQueryParameters) -> OutputIdsResponse:
+        """Fetch account output IDs from the given query parameters.
 
         Returns:
-            The corresponding output IDs of the alias outputs.
+            The corresponding output IDs of the account outputs.
         """
 
-        query_parameters_camelized = query_parameters.as_dict()
-
-        response = self._call_method('aliasOutputIds', {
-            'queryParameters': query_parameters_camelized,
+        response = self._call_method('accountOutputIds', {
+            'queryParameters': query_parameters,
         })
         return OutputIdsResponse(response)
 
-    def alias_output_id(self, alias_id: HexStr) -> OutputId:
-        """Fetch alias output ID from the given alias ID.
+    def account_output_id(self, account_id: HexStr) -> OutputId:
+        """Fetch account output ID from the given account ID.
 
         Returns:
-            The output ID of the alias output.
+            The output ID of the account output.
         """
-        return OutputId.from_string(self._call_method('aliasOutputId', {
-            'aliasId': alias_id
+        return OutputId(self._call_method('accountOutputId', {
+            'accountId': account_id
         }))
 
-    def nft_output_ids(
-            self, query_parameters: QueryParameters) -> OutputIdsResponse:
-        """Fetch NFT output IDs from the given query parameters.
+    def anchor_output_ids(
+            self, query_parameters: AnchorOutputQueryParameters) -> OutputIdsResponse:
+        """Fetch anchor output IDs from the given query parameters.
 
         Returns:
-            The corresponding output IDs of the NFT outputs.
+            The corresponding output IDs of the anchor outputs.
         """
 
-        query_parameters_camelized = query_parameters.as_dict()
+        response = self._call_method('anchorOutputIds', {
+            'queryParameters': query_parameters,
+        })
+        return OutputIdsResponse(response)
 
-        response = self._call_method('nftOutputIds', {
-            'queryParameters': query_parameters_camelized,
+    def anchor_output_id(self, anchor_id: HexStr) -> OutputId:
+        """Fetch anchor output ID from the given anchor ID.
+
+        Returns:
+            The output ID of the anchor output.
+        """
+        return OutputId(self._call_method('anchorOutputId', {
+            'anchorId': anchor_id
+        }))
+
+    def delegation_output_ids(
+            self, query_parameters: DelegationOutputQueryParameters) -> OutputIdsResponse:
+        """Fetch delegation output IDs from the given query parameters.
+
+        Returns:
+            The corresponding output IDs of the delegation outputs.
+        """
+
+        response = self._call_method('delegationOutputIds', {
+            'queryParameters': query_parameters,
         })
         return OutputIdsResponse(response)
 
-    def nft_output_id(self, nft_id: HexStr) -> OutputId:
-        """Fetch NFT output ID from the given NFT ID.
+    def delegation_output_id(self, delegation_id: HexStr) -> OutputId:
+        """Fetch delegation output ID from the given delegation ID.
 
         Returns:
-            The output ID of the NFT output.
+            The output ID of the delegation output.
         """
-        return OutputId.from_string(self._call_method('nftOutputId', {
-            'nftId': nft_id
+        return OutputId(self._call_method('delegationOutputId', {
+            'delegationId': delegation_id
         }))
 
     def foundry_output_ids(
-            self, query_parameters: QueryParameters) -> OutputIdsResponse:
+            self, query_parameters: FoundryOutputQueryParameters) -> OutputIdsResponse:
         """Fetch foundry Output IDs from the given query parameters.
 
         Returns:
             The corresponding output IDs of the foundry outputs.
         """
 
-        query_parameters_camelized = query_parameters.as_dict()
-
         response = self._call_method('foundryOutputIds', {
-            'queryParameters': query_parameters_camelized,
+            'queryParameters': query_parameters,
         })
         return OutputIdsResponse(response)
 
     def foundry_output_id(self, foundry_id: HexStr) -> OutputId:
         """Fetch foundry Output ID from the given foundry ID.
 
         Returns:
             The output ID of the foundry output.
         """
-        return OutputId.from_string(self._call_method('foundryOutputId', {
+        return OutputId(self._call_method('foundryOutputId', {
             'foundryId': foundry_id
         }))
+
+    def nft_output_ids(
+            self, query_parameters: NftOutputQueryParameters) -> OutputIdsResponse:
+        """Fetch NFT output IDs from the given query parameters.
+
+        Returns:
+            The corresponding output IDs of the NFT outputs.
+        """
+
+        response = self._call_method('nftOutputIds', {
+            'queryParameters': query_parameters,
+        })
+        return OutputIdsResponse(response)
+
+    def nft_output_id(self, nft_id: HexStr) -> OutputId:
+        """Fetch NFT output ID from the given NFT ID.
+
+        Returns:
+            The output ID of the NFT output.
+        """
+        return OutputId(self._call_method('nftOutputId', {
+            'nftId': nft_id
+        }))
```

## iota_sdk/client/_utils.py

```diff
@@ -1,14 +1,15 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from typing import Optional
 from abc import ABCMeta, abstractmethod
-
-from iota_sdk.types.common import HexStr
+from iota_sdk.types.address import Address
+from iota_sdk.types.block.block import Block
+from iota_sdk.types.block.id import BlockId
 from iota_sdk.types.output import Output
 
 
 class ClientUtils(metaclass=ABCMeta):
     """Client utility functions.
     """
 
@@ -29,60 +30,41 @@
 
         Returns:
 
         The method returns either the payload from the JSON response or the entire response if there is
         no payload.
         """
 
-    # pylint: disable=redefined-builtin
-    def hex_to_bech32(self, hex: HexStr, bech32_hrp: str) -> str:
-        """Transforms a hex encoded address to a bech32 encoded address.
-        """
-        return self._call_method('hexToBech32', {
-            'hex': hex,
-            'bech32Hrp': bech32_hrp
-        })
-
-    def alias_id_to_bech32(self, alias_id: HexStr, bech32_hrp: str) -> str:
-        """Transforms an alias id to a bech32 encoded address.
+    def address_to_bech32(self, address: Address,
+                          bech32_hrp: Optional[str] = None) -> str:
+        """Converts an address to its bech32 representation.
         """
-        return self._call_method('aliasIdToBech32', {
-            'aliasId': alias_id,
+        return self._call_method('addressToBech32', {
+            'address': address,
             'bech32Hrp': bech32_hrp
         })
 
-    def nft_id_to_bech32(self, nft_id: HexStr, bech32_hrp: str) -> str:
-        """Transforms an nft id to a bech32 encoded address.
-        """
-        return self._call_method('nftIdToBech32', {
-            'nftId': nft_id,
-            'bech32Hrp': bech32_hrp
-        })
-
-    # pylint: disable=redefined-builtin
-    def hex_public_key_to_bech32_address(
-            self, hex: HexStr, bech32_hrp: Optional[str] = None) -> str:
-        """Transforms a hex encoded public key to a bech32 encoded address.
-        """
-        return self._call_method('hexPublicKeyToBech32Address', {
-            'hex': hex,
-            'bech32Hrp': bech32_hrp
-        })
-
-    def minimum_required_storage_deposit(self, output: Output) -> int:
-        """Minimum required storage deposit.
+    def computer_minimum_output_amount(self, output: Output) -> int:
+        """Minimum required output amount.
         """
         return int(self._call_method(
-            'minimumRequiredStorageDeposit', {
-                'output': output.as_dict()
+            'computeMinimumOutputAmount', {
+                'output': output.to_dict()
             }
         ))
 
     def request_funds_from_faucet(self, url: str, address: str) -> str:
         """Requests funds from the faucet, for example `https://faucet.testnet.shimmer.network/api/enqueue` or `http://localhost:8091/api/enqueue`.
         """
         return self._call_method(
             'requestFundsFromFaucet', {
                 'url': url,
                 'address': address,
             }
         )
+
+    def block_id(self, block: Block) -> BlockId:
+        """ Return a block ID (Blake2b256 hash of block bytes) from a block.
+        """
+        return BlockId(self._call_method('blockId', {
+            'block': block,
+        }))
```

## iota_sdk/secret_manager/secret_manager.py

```diff
@@ -1,20 +1,20 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from json import dumps, loads
 from typing import Optional, Union
-from dacite import from_dict
 import humps
-
 from iota_sdk.external import create_secret_manager, call_secret_manager_method
+from iota_sdk.types.block.block import Block, UnsignedBlock
 from iota_sdk.types.common import HexStr
+from iota_sdk.types.node_info import ProtocolParameters
+from iota_sdk.types.payload import SignedTransactionPayload
 from iota_sdk.types.signature import Ed25519Signature, Bip44
 from iota_sdk.types.transaction_data import PreparedTransactionData
-from iota_sdk.types.payload import TransactionPayload
 
 
 class LedgerNanoSecretManager(dict):
     """Secret manager that uses a Ledger Nano hardware wallet or a Speculos simulator.
     """
 
     def __init__(self, is_simulator):
@@ -80,15 +80,15 @@
 
 
 class SecretManagerError(Exception):
     """Secret manager error.
     """
 
 
-class SecretManager():
+class SecretManager:
     """Secret manager wrapper.
     """
 
     def __init__(self, secret_manager: Optional[Union[LedgerNanoSecretManager, MnemonicSecretManager,
                  SeedSecretManager, StrongholdSecretManager]] = None, secret_manager_handle=None):
         """Initialize a secret manager.
 
@@ -121,32 +121,77 @@
             if json_response["type"] == "error":
                 raise SecretManagerError(json_response['payload'])
 
         if "payload" in json_response:
             return json_response['payload']
         return response
 
+    # TODO: Should we include `bech32` in the method name?
+    def generate_ed25519_address(self,
+                                 coin_type: int,
+                                 bech32_hrp: str,
+                                 account_index: Optional[int] = None,
+                                 address_index: Optional[int] = None,
+                                 internal: Optional[bool] = None,
+                                 legder_nano_prompt: Optional[bool] = None):
+        """Generate a single Ed25519 address.
+
+        Args:
+            coin_type: The coin type to generate the address for.
+            bech32_hrp: The bech32 HRP (human readable part) to use.
+            account_index: An account index.
+            address_index: An address index.
+            internal: Whether the generated address should be internal.
+            ledger_nano_prompt: Whether to display the address on Ledger Nano devices.
+
+        Returns:
+            The generated Ed25519 address.
+        """
+
+        options = {}
+        options['coinType'] = coin_type
+        options['bech32Hrp'] = bech32_hrp
+        if address_index is not None:
+            options['range'] = {}
+            options['range']['start'] = address_index
+            options['range']['end'] = address_index + 1
+        if account_index is not None:
+            options['accountIndex'] = account_index
+        if internal is not None or legder_nano_prompt is not None:
+            options['options'] = {}
+            if internal is not None:
+                options['options']['internal'] = internal
+            if legder_nano_prompt is not None:
+                options['options']['ledgerNanoPrompot'] = legder_nano_prompt
+
+        return self._call_method('generateEd25519Addresses', {
+            'options': options
+        })[0]
+
     # pylint: disable=unused-argument
+
+    # TODO: Should `coin_type` and `bech32_hrp` be mandatory to provide?
+    # TODO: Should we include `bech32` in the method name?
     def generate_ed25519_addresses(self,
+                                   coin_type: Optional[int] = None,
+                                   bech32_hrp: Optional[str] = None,
                                    account_index: Optional[int] = None,
                                    start: Optional[int] = None,
                                    end: Optional[int] = None,
                                    internal: Optional[bool] = None,
-                                   coin_type: Optional[int] = None,
-                                   bech32_hrp: Optional[str] = None,
                                    ledger_nano_prompt: Optional[bool] = None):
-        """Generate Ed25519 addresses.
+        """Generate multiple Ed25519 addresses at once.
 
         Args:
+            coin_type: The coin type to generate addresses for.
+            bech32_hrp: The bech32 HRP (human readable part) to use.
             account_index: An account index.
             start: The start index of the addresses to generate.
             end: The end index of the addresses to generate.
             internal: Whether the generated addresses should be internal.
-            coin_type: The coin type to generate addresses for.
-            bech32_hrp: The bech32 HRP (human readable part) to use.
             ledger_nano_prompt: Whether to display the address on Ledger Nano devices.
 
         Returns:
             The generated Ed25519 addresses.
         """
         options = dict(locals())
         del options['self']
@@ -246,46 +291,61 @@
         Args:
             message: The given message to sign.
             chain: The chain to sign with.
 
         Returns:
             The Ed25519 signature.
         """
-        return from_dict(Ed25519Signature, self._call_method('signEd25519', {
+        return Ed25519Signature.from_dict(self._call_method('signEd25519', {
             'message': message,
-            'chain': chain.__dict__,
+            'chain': chain.to_dict(),
         }))
 
     def sign_secp256k1_ecdsa(self, message: HexStr, chain: Bip44):
         """Signs a message with an Secp256k1Ecdsa private key.
 
         Args:
             message: The given message to sign.
             chain: The chain to sign with.
         """
         return self._call_method('signSecp256k1Ecdsa', {
             'message': message,
-            'chain': chain.__dict__,
+            'chain': chain.to_dict(),
         })
 
     def sign_transaction(
-            self, prepared_transaction_data: PreparedTransactionData) -> TransactionPayload:
+            self, prepared_transaction_data: PreparedTransactionData, protocol_parameters: ProtocolParameters) -> SignedTransactionPayload:
         """Sign a transaction.
 
         Args:
             prepare_transaction_data: The prepared transaction data that needs to be signed.
+            protocol_parameters: The protocol parameters used in creating the signed transaction.
+        """
+        return SignedTransactionPayload.from_dict(self._call_method('signTransaction', {
+            'preparedTransactionData': prepared_transaction_data.to_dict(),
+            'protocolParameters': protocol_parameters
+        }))
+
+    def sign_block(
+            self, unsigned_block: UnsignedBlock, chain: Bip44) -> Block:
+        """Sign a block.
+
+        Args:
+            unsigned_block: The unsigned block data.
+            chain: The Bip44 chain to use.
         """
-        return from_dict(TransactionPayload, self._call_method('signTransaction', {
-            'preparedTransactionData': prepared_transaction_data.as_dict()
+        return Block.from_dict(self._call_method('signBlock', {
+            'unsignedBlock': unsigned_block.to_dict(),
+            'chain': chain.to_dict()
         }))
 
-    def signature_unlock(self, transaction_essence_hash: HexStr, chain: Bip44):
-        """Sign a transaction essence hash.
+    def signature_unlock(self, transaction_signing_hash: HexStr, chain: Bip44):
+        """Sign a transaction hash.
 
         Args:
-            transaction_essence_hash: The transaction essence hash to sign.
+            transaction_signing_hash: The transaction hash to sign.
             chain: The chain to sign with.
         """
         return self._call_method('signatureUnlock', {
-            'transactionEssenceHash': transaction_essence_hash,
-            'chain': chain.__dict__,
+            'transactionSigningHash': transaction_signing_hash,
+            'chain': chain.to_dict(),
         })
```

## iota_sdk/types/address.py

```diff
@@ -1,87 +1,192 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from dataclasses import dataclass, field
 from enum import IntEnum
-from iota_sdk.types.common import HexStr
+from dataclasses import dataclass, field
+from typing import Any, Dict, List, Optional, TypeAlias, Union
+from iota_sdk.types.common import HexStr, json
 
 
 class AddressType(IntEnum):
     """Address type variants.
 
      Attributes:
         ED25519 (0): Ed25519 address.
-        ALIAS (8): Alias address.
+        ACCOUNT (8): Account address.
         NFT (16): Nft address.
+        ANCHOR (24): Anchor address.
+        IMPLICIT_ACCOUNT_CREATION (32): Implicit Account Creation address.
+        MULTI (40): Multi address.
+        RESTRICTED (48): Address with restricted capabilities.
+
     """
     ED25519 = 0
-    ALIAS = 8
+    ACCOUNT = 8
     NFT = 16
+    ANCHOR = 24
+    IMPLICIT_ACCOUNT_CREATION = 32
+    MULTI = 40
+    RESTRICTED = 48
 
 
+@json
 @dataclass
-class Address():
-    """Base class for addresses.
-    """
-    type: int
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        return {k: v for k, v in self.__dict__.items() if v is not None}
-
-
-@dataclass
-class Ed25519Address(Address):
+class Ed25519Address:
     """Represents an Ed25519 address.
     Attributes:
-        pubKeyHash: The hex encoded Ed25519 public key hash.
+        pub_key_hash: The hex encoded Ed25519 public key hash.
     """
-    pubKeyHash: HexStr
     type: int = field(
         default_factory=lambda: int(
             AddressType.ED25519),
         init=False)
+    pub_key_hash: HexStr
 
 
+@json
 @dataclass
-class AliasAddress(Address):
-    """Represents an Alias address.
+class AccountAddress:
+    """Represents an Account address.
     Attributes:
-        aliasId: The hex encoded alias id.
+        account_id: The hex encoded account id.
     """
-    aliasId: HexStr
     type: int = field(
         default_factory=lambda: int(
-            AddressType.ALIAS),
+            AddressType.ACCOUNT),
         init=False)
+    account_id: HexStr
 
 
+@json
 @dataclass
-class NFTAddress(Address):
+class NFTAddress:
     """Represents an NFT address.
     Attributes:
-        nftId: The hex encoded NFT id.
+        nft_id: The hex encoded NFT id.
     """
-    nftId: HexStr
     type: int = field(default_factory=lambda: int(AddressType.NFT), init=False)
+    nft_id: HexStr
 
 
+@json
 @dataclass
-class AccountAddress():
-    """An Address of the Account.
+class AnchorAddress:
+    """Represents an Anchor address.
+    Attributes:
+        anchor_id: The hex encoded anchor id.
     """
-    address: str
-    keyIndex: int
-    internal: bool
-    used: bool
+    type: int = field(
+        default_factory=lambda: int(
+            AddressType.ANCHOR),
+        init=False)
+    anchor_id: HexStr
 
 
+@json
 @dataclass
-class AddressWithUnspentOutputs():
-    """An Address with unspent outputs.
+class ImplicitAccountCreationAddress:
+    """An implicit account creation address that can be used to convert a Basic Output to an Account Output.
+    Attributes:
+        address: The hex encoded Ed25519 Address.
+    """
+    type: int = field(default_factory=lambda: int(
+        AddressType.IMPLICIT_ACCOUNT_CREATION), init=False)
+    pub_key_hash: HexStr
+
+
+@json
+@dataclass
+class WeightedAddress:
+    """An address with an assigned weight.
+    Attributes:
+        address: The unlocked address.
+        weight: The weight of the unlocked address.
+    """
+    address: Union[Ed25519Address, AccountAddress, NFTAddress, AnchorAddress]
+    weight: int
+
+
+@json
+@dataclass
+class MultiAddress:
+    """An address that consists of addresses with weights and a threshold value.
+    The Multi Address can be unlocked if the cumulative weight of all unlocked addresses is equal to or exceeds the
+    threshold.
+    Attributes:
+        addresses: The weighted unlocked addresses.
+        threshold: The threshold that needs to be reached by the unlocked addresses in order to unlock the multi address.
+    """
+    type: int = field(default_factory=lambda: int(
+        AddressType.MULTI), init=False)
+    addresses: List[WeightedAddress]
+    threshold: int
+
+
+@json
+@dataclass
+class RestrictedAddress:
+    """Represents an address with restricted capabilities.
+    Attributes:
+        address: The inner restricted Address.
+        allowed_capabilities: The allowed capabilities bitflags.
+    """
+    type: int = field(default_factory=lambda: int(
+        AddressType.RESTRICTED), init=False)
+    address: Union[Ed25519Address, AccountAddress, NFTAddress]
+    allowed_capabilities: Optional[HexStr] = field(default=None, init=False)
+
+    def with_allowed_capabilities(self, capabilities: bytes):
+        """Sets the allowed capabilities from a byte array.
+        Attributes:
+            capabilities: The allowed capabilities bitflags.
+        """
+        if any(c != 0 for c in capabilities):
+            self.allowed_capabilities = '0x' + capabilities.hex()
+        else:
+            self.allowed_capabilities = None
+
+
+Address: TypeAlias = Union[Ed25519Address,
+                           AccountAddress,
+                           NFTAddress,
+                           AnchorAddress,
+                           ImplicitAccountCreationAddress,
+                           MultiAddress,
+                           RestrictedAddress]
+
+
+# pylint: disable=too-many-return-statements
+def deserialize_address(d: Dict[str, Any]) -> Address:
+    """
+    Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    address_type = d['type']
+    if address_type == AddressType.ED25519:
+        return Ed25519Address.from_dict(d)
+    if address_type == AddressType.ACCOUNT:
+        return AccountAddress.from_dict(d)
+    if address_type == AddressType.NFT:
+        return NFTAddress.from_dict(d)
+    if address_type == AddressType.ANCHOR:
+        return AnchorAddress.from_dict(d)
+    if address_type == AddressType.IMPLICIT_ACCOUNT_CREATION:
+        return ImplicitAccountCreationAddress.from_dict(d)
+    if address_type == AddressType.MULTI:
+        return MultiAddress.from_dict(d)
+    if address_type == AddressType.RESTRICTED:
+        return RestrictedAddress.from_dict(d)
+    raise Exception(f'invalid address type: {address_type}')
+
+
+def deserialize_addresses(
+        dicts: List[Dict[str, Any]]) -> List[Address]:
+    """
+    Takes a list of dictionaries as input and returns a list with specific instances of classes based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `dicts`: A list of dictionaries that are expected to have a key called 'type' which specifies the type of the returned value.
     """
-    address: str
-    keyIndex: int
-    internal: bool
-    outputIds: bool
+    return list(map(deserialize_address, dicts))
```

## iota_sdk/types/balance.py

```diff
@@ -1,85 +1,127 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
 from typing import List, Optional
-from iota_sdk.types.common import HexStr
+from dataclasses import dataclass, field
+from dataclasses_json import config
+from iota_sdk.types.decayed_mana import DecayedMana
+from iota_sdk.types.common import hex_str_decoder, HexStr, json
+from iota_sdk.types.output_id import OutputId
 
 
+@json
 @dataclass
 class BaseCoinBalance:
     """Base coin fields for Balance.
 
     Attributes:
         total: The total balance.
         available: The available amount of the total balance.
+        # voting_power: The voting power of the wallet.
     """
-    total: str
-    available: str
+    total: int = field(metadata=config(
+        encoder=str
+    ))
+    available: int = field(metadata=config(
+        encoder=str
+    ))
+    # TODO https://github.com/iotaledger/iota-sdk/issues/1822
+    # voting_power: int = field(metadata=config(
+    # encoder=str
+    # ))
 
 
+@json
+@dataclass
+class ManaBalance:
+    """Mana fields for Balance.
+
+    Attributes:
+        total: The total balance.
+        available: The available amount of the total balance.
+        rewards: Mana rewards of account and delegation outputs.
+    """
+    total: DecayedMana
+    available: DecayedMana
+    rewards: int = field(metadata=config(
+        encoder=str
+    ))
+
+
+@json
 @dataclass
 class RequiredStorageDeposit:
-    """Required storage deposit for the outputs in the account.
+    """Required storage deposit for the outputs in the wallet.
 
     Attributes:
-        alias: The required amount for alias outputs.
         basic: The required amount for basic outputs.
+        account: The required amount for account outputs.
         foundry: The required amount for foundry outputs.
         nft: The required amount for nft outputs.
+        delegation: The required amount for delegation outputs.
     """
-    alias: str
-    basic: str
-    foundry: str
-    nft: str
+    basic: int = field(metadata=config(
+        encoder=str
+    ))
+    account: int = field(metadata=config(
+        encoder=str
+    ))
+    foundry: int = field(metadata=config(
+        encoder=str
+    ))
+    nft: int = field(metadata=config(
+        encoder=str
+    ))
+    delegation: int = field(metadata=config(
+        encoder=str
+    ))
 
 
+@json
 @dataclass
 class NativeTokensBalance:
     """Native tokens fields for Balance.
 
     Attributes:
-        tokenId: The native token id.
+        token_id: The native token id.
         total: The total native token balance.
         available: The available amount of the total native token balance.
         metadata: Some metadata of the native token.
     """
-    tokenId: HexStr
-    total: HexStr
-    available: HexStr
+    total: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
+    available: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
     metadata: Optional[HexStr]
 
 
+@json
 @dataclass
 class Balance:
     """The balance of an account.
 
     Attributes:
-        baseCoin: The base coin balance.
-        requiredStorageDeposit: The required storage deposit.
-        nativeTokens: The balances of all native tokens.
-        nfts: All owned NFTs.
-        aliases: All owned aliases.
+        base_coin: The base coin balance.
+        mana: Total and available mana.
+        required_storage_deposit: The required storage deposit.
+        native_tokens: The balances of all native tokens.
+        accounts: All owned accounts.
         foundries: All owned foundries.
-        potentiallyLockedOutputs: A list of potentially locked outputs.
+        nfts: All owned NFTs.
+        delegations: All owned delegation outputs.
+        potentially_locked_outputs: A list of potentially locked outputs.
     """
-    baseCoin: BaseCoinBalance
-    requiredStorageDeposit: RequiredStorageDeposit
-    nativeTokens: List[NativeTokensBalance]
-    nfts: List[HexStr]
-    aliases: List[HexStr]
+    base_coin: BaseCoinBalance
+    mana: ManaBalance
+    required_storage_deposit: RequiredStorageDeposit
+    native_tokens: dict[HexStr, NativeTokensBalance]
+    accounts: List[HexStr]
     foundries: List[HexStr]
-    potentiallyLockedOutputs: dict[HexStr, bool]
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = self.__dict__
-
-        config['baseCoin'] = config['baseCoin'].__dict__
-        config['requiredStorageDeposit'] = config['requiredStorageDeposit'].__dict__
-        config['nativeTokens'] = [nt.__dict__
-                                  for nt in config['nativeTokens']]
-
-        return config
+    nfts: List[HexStr]
+    delegations: List[HexStr]
+    potentially_locked_outputs: dict[OutputId, bool]
```

## iota_sdk/types/block_builder_options.py

```diff
@@ -1,32 +1,41 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
 from typing import Any, Dict, List, Optional
-from iota_sdk.types.common import HexStr, AddressAndAmount
+from dataclasses import dataclass, field
+from dataclasses_json import config
+from iota_sdk.types.common import HexStr, AddressAndAmount, json
 from iota_sdk.client._high_level_api import Range
+from iota_sdk.types.block.id import BlockId
 from iota_sdk.types.burn import Burn
 from iota_sdk.types.output import Output
 from iota_sdk.types.input import UtxoInput
 
 
+@json
 @dataclass
 class BlockBuilderOptions:
     """Options to build a block.
     """
-    total: str
-    available: str
-    coinType: Optional[int] = None
-    accountInde: Optional[int] = None
-    initialAddressIndex: Optional[int] = None
+    total: int = field(metadata=config(
+        encoder=str
+    ))
+    available: int = field(metadata=config(
+        encoder=str
+    ))
+    coin_type: Optional[int] = None
+    account_index: Optional[int] = None
+    initial_address_index: Optional[int] = None
     inputs: Optional[List[UtxoInput]] = None
-    inputRange: Optional[Range] = None
+    input_range: Optional[Range] = None
     output: Optional[AddressAndAmount] = None
-    outputHex: Optional[List[Dict[str, Any]]] = None
+    output_hex: Optional[List[Dict[str, Any]]] = None
     outputs: Optional[List[Output]] = None
-    customRemainderAddress: Optional[str] = None
+    custom_remainder_address: Optional[str] = None
     tag: Optional[HexStr] = None
     data: Optional[HexStr] = None
-    parents: Optional[List[HexStr]] = None
+    strong_parents: Optional[List[BlockId]] = None
+    weak_parents: Optional[List[BlockId]] = None
+    shallow_like_parents: Optional[List[BlockId]] = None
     burn: Optional[Burn] = None
```

## iota_sdk/types/burn.py

```diff
@@ -1,68 +1,85 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations  # Allow reference to Burn in Burn class
+from typing import List, Optional
 from dataclasses import dataclass
-from typing import List, Optional, Dict, Any
 from iota_sdk.types.native_token import NativeToken
-from iota_sdk.types.common import HexStr
+from iota_sdk.types.common import HexStr, json
 
 
+@json
 @dataclass
 class Burn:
     """A DTO for `Burn`.
 
     Attributes:
-        aliases: The aliases to burn.
-        nfts: The NFTs to burn.
+        mana: Whether initial excess mana should be burned (only from inputs/outputs that have been specified manually).
+        generated_mana: Whether generated mana should be burned.
+        accounts: The accounts to burn.
         foundries: The foundries to burn.
-        nativeTokens: The native tokens to burn.
+        nfts: The NFTs to burn.
+        delegations: The delegations to burn.
+        native_tokens: The native tokens to burn.
     """
 
-    aliases: Optional[List[HexStr]] = None
-    nfts: Optional[List[HexStr]] = None
+    mana: Optional[bool] = None
+    generated_mana: Optional[bool] = None
+    accounts: Optional[List[HexStr]] = None
     foundries: Optional[List[HexStr]] = None
-    nativeTokens: Optional[List[NativeToken]] = None
+    nfts: Optional[List[HexStr]] = None
+    delegations: Optional[List[HexStr]] = None
+    native_tokens: Optional[List[NativeToken]] = None
 
-    def add_alias(self, alias: HexStr) -> Burn:
-        """Add an alias to the burn.
+    def set_mana(self, burn_mana: bool) -> Burn:
+        """Burn excess initial mana (only from inputs/outputs that have been specified manually).
         """
-        if self.aliases is None:
-            self.aliases = []
-        self.aliases.append(alias)
+        self.mana = burn_mana
         return self
 
-    def add_nft(self, nft: HexStr) -> Burn:
-        """Add an NFT to the burn.
+    def set_generated_mana(self, burn_generated_mana: bool) -> Burn:
+        """Burn generated mana.
         """
-        if self.nfts is None:
-            self.nfts = []
-        self.nfts.append(nft)
+        self.generated_mana = burn_generated_mana
+        return self
+
+    def add_account(self, account: HexStr) -> Burn:
+        """Add an account to the burn.
+        """
+        if self.accounts is None:
+            self.accounts = []
+        self.accounts.append(account)
         return self
 
     def add_foundry(self, foundry: HexStr) -> Burn:
         """Add a foundry to the burn.
         """
         if self.foundries is None:
             self.foundries = []
         self.foundries.append(foundry)
         return self
 
-    def add_native_token(self, native_token: NativeToken) -> Burn:
-        """Add a native token to the burn.
+    def add_nft(self, nft: HexStr) -> Burn:
+        """Add an NFT to the burn.
         """
-        if self.nativeTokens is None:
-            self.nativeTokens = [native_token]
-        else:
-            self.nativeTokens.append(native_token)
+        if self.nfts is None:
+            self.nfts = []
+        self.nfts.append(nft)
         return self
 
-    def as_dict(self) -> Dict[str, Any]:
-        """Converts this object to a dict.
+    def add_delegation(self, delegation: HexStr) -> Burn:
+        """Add a delegation to the burn.
         """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
+        if self.delegations is None:
+            self.delegations = []
+        self.delegations.append(delegation)
+        return self
 
-        if "nativeTokens" in config:
-            config["nativeTokens"] = {nativeToken.__dict__["id"]: nativeToken.__dict__[
-                "amount"] for nativeToken in config["nativeTokens"]}
-        return config
+    def add_native_token(self, native_token: NativeToken) -> Burn:
+        """Add a native token to the burn.
+        """
+        if self.native_tokens is None:
+            self.native_tokens = [native_token]
+        else:
+            self.native_tokens.append(native_token)
+        return self
```

## iota_sdk/types/client_options.py

```diff
@@ -1,120 +1,87 @@
-# Copyright 2023 IOTA Stiftung
+# Copyright 2024 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
 from dataclasses import dataclass
 from typing import List, Optional
-from iota_sdk.types.node_info import NodeInfoProtocol
+from iota_sdk.types.common import json
+from iota_sdk.types.node_info import ProtocolParameters
 
 
+@json
 @dataclass
 class Duration:
     """Time duration.
     """
     secs: int
     nanos: int
 
 
+@json
 @dataclass
 class MqttBrokerOptions:
     """Options for the MQTT broker.
 
         Attributes:
-        automaticDisconnect (bool):
+        automatic_disconnect (bool):
             Whether the MQTT broker should be automatically disconnected when all topics are unsubscribed or not.
         timeout (Duration):
             Sets the timeout used for the MQTT operations.
-        useWs (bool):
+        use_ws (bool):
             Sets the use_ws used for the MQTT operations.
         port (int):
             Sets the port used for the MQTT operations.
-        maxReconnectionAttempts (int):
+        max_reconnection_attempts (int):
             Sets the maximum number of reconnection attempts. 0 is unlimited.
     """
-    automaticDisconnect: Optional[bool] = None
+    automatic_disconnect: Optional[bool] = None
     timeout: Optional[Duration] = None
-    useWs: Optional[bool] = None
+    use_ws: Optional[bool] = None
     port: Optional[int] = None
-    maxReconnectionAttempts: Optional[int] = None
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        return {k: v for k, v in self.__dict__.items() if v is not None}
+    max_reconnection_attempts: Optional[int] = None
 
 
+@json
 @dataclass
 class ClientOptions:
     """Client options.
 
-
         Attributes:
-        primary_node (str):
-            Node which will be tried first for all requests.
-        primary_pow_node (str):
-            Node which will be tried first when using remote PoW, even before the primary_node.
+        primary_nodes (List[str]):
+            Nodes which will be tried first for all requests.
         nodes (List[str]):
             Array of Node URLs.
-        permanode (str):
-            Permanode URL.
-        ignoreNodeHealth (bool):
+        ignore_node_health (bool):
             If the node health should be ignored.
-        nodeSyncInterval (Duration):
-            Interval in which nodes will be checked for their sync status and the [NetworkInfo](crate::NetworkInfo) gets updated.
+        node_sync_interval (Duration):
+            Interval in which nodes will be checked for their sync status and the network info gets updated.
         quorum (bool):
             If node quorum is enabled. Will compare the responses from multiple nodes
             and only returns the response if `quorum_threshold`% of the nodes return the same one.
-        minQuorumSize (int):
+        min_quorum_size (int):
             Minimum amount of nodes required for request when quorum is enabled.
-        quorumThreshold (int):
+        quorum_threshold (int):
             % of nodes that have to return the same response so it gets accepted.
-        userAgent (str):
+        user_agent (str):
             The User-Agent header for requests.
-        brokerOptions (MqttBrokerOptions):
+        broker_options (MqttBrokerOptions):
             Options for the MQTT broker.
-        protocolParameters (NodeInfoProtocol):
+        protocol_parameters (ProtocolParameters):
             Protocol parameters.
-        localPow (bool):
-            Local proof of work.
-        fallbackToLocalPow (bool):
-            Fallback to local proof of work if the node doesn't support remote PoW.
-        tipsInterval (int):
-            Tips request interval during PoW in seconds.
-        apiTimeout (Duration):
+        api_timeout (Duration):
             Timeout for API requests.
-        remotePowTimeout (Duration):
-            Timeout when sending a block that requires remote proof of work.
-        powWorkerCount (int):
-            The amount of threads to be used for proof of work.
-        maxParallelApiRequests (int):
+        max_parallel_api_requests (int):
             The maximum parallel API requests.
     """
-    primaryNode: Optional[str] = None
-    primaryPowNode: Optional[str] = None
+    primary_nodes: Optional[List[str]] = None
     nodes: Optional[List[str]] = None
-    permanodes: Optional[List[str]] = None
-    ignoreNodeHealth: Optional[bool] = None
-    nodeSyncInterval: Optional[Duration] = None
+    ignore_node_health: Optional[bool] = None
+    node_sync_interval: Optional[Duration] = None
     quorum: Optional[bool] = None
-    minQuorumSize: Optional[int] = None
-    quorumThreshold: Optional[int] = None
-    userAgent: Optional[str] = None
-    brokerOptions: Optional[MqttBrokerOptions] = None
-    protocolParameters: Optional[NodeInfoProtocol] = None
-    localPow: Optional[bool] = None
-    fallbackToLocalPow: Optional[bool] = None
-    tipsInterval: Optional[int] = None
-    apiTimeout: Optional[Duration] = None
-    remotePowTimeout: Optional[Duration] = None
-    powWorkerCount: Optional[int] = None
-    maxParallelApiRequests: Optional[int] = None
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        if 'brokerOptions' in config:
-            config['brokerOptions'] = config['brokerOptions'].as_dict()
-
-        return config
+    min_quorum_size: Optional[int] = None
+    quorum_threshold: Optional[int] = None
+    user_agent: Optional[str] = None
+    broker_options: Optional[MqttBrokerOptions] = None
+    protocol_parameters: Optional[ProtocolParameters] = None
+    api_timeout: Optional[Duration] = None
+    max_parallel_api_requests: Optional[int] = None
```

## iota_sdk/types/common.py

```diff
@@ -1,14 +1,60 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
+from typing import NewType, Optional
 from enum import IntEnum
-from typing import NewType
+from dataclasses import dataclass, field
+from dataclasses_json import DataClassJsonMixin, dataclass_json, LetterCase, Undefined, config
 
 HexStr = NewType("HexStr", str)
+EpochIndex = NewType("EpochIndex", int)
+SlotIndex = NewType("SlotIndex", int)
+
+
+def json(cls):
+    """Decorator to add to_dict and to_json methods to a dataclass."""
+
+    # Get potential override method
+    to_dict = getattr(cls, "to_dict", None)
+
+    # Apply the dataclass_json decorator to get the default behavior
+    cls = dataclass_json(
+        letter_case=LetterCase.CAMEL,
+        undefined=Undefined.RAISE)(cls)
+
+    # If no custom one is defined, set the default from dataclass_json
+    if to_dict is None:
+        to_dict = cls.to_dict
+
+    # Override to_dict to remove None values
+    def custom_to_dict(self, *args, **kwargs):
+        # pylint: disable=protected-access
+        original_dict = to_dict(self, *args, **kwargs)
+
+        # recursive remove the None values
+        def filter_none(value):
+            if isinstance(value, dict):
+                return {k: filter_none(v)
+                        for k, v in value.items() if v is not None}
+            if isinstance(value, list):
+                return [filter_none(item)
+                        for item in value if item is not None]
+            return value
+
+        return filter_none(original_dict)
+
+    def custom_to_json(self, *args, **kwargs):
+        # Use the custom to_dict method for serialization
+        return DataClassJsonMixin.to_json(self, *args, **kwargs)
+
+    setattr(cls, "to_dict", custom_to_dict)
+    setattr(cls, "to_json", custom_to_json)
+
+    return cls
 
 
 class CoinType(IntEnum):
     """Coin types.
 
     Attributes:
         IOTA (4218): IOTA
@@ -19,70 +65,95 @@
     SHIMMER = 4219
     ETHER = 60
 
     def __int__(self):
         return self.value
 
 
-class Node():
+@json
+@dataclass
+class Node:
     """Represents a node in the network.
-    """
 
-    def __init__(self, url=None, jwt=None, username=None,
-                 password=None, disabled=None):
-        """Initialize a Node.
-
-        Args:
+        Attributes:
             url: The node url.
             jwt: A JWT token for authentication.
             username: A username for basic authentication.
             password: A password for basic authentication.
             disabled: Whether the node should be used for API requests or not.
-        """
-        self.url = url
-        self.jwt = jwt
-        self.username = username
-        self.password = password
-        self.disabled = disabled
+            permanode: Whether the node is a permanode or not.
+    """
 
-    def as_dict(self):
-        """Converts this object to a dict.
+    url: Optional[str] = None
+    jwt: Optional[str] = None
+    username: Optional[str] = None
+    password: Optional[str] = None
+    disabled: Optional[bool] = None
+    permanode: Optional[bool] = None
+
+    def to_dict(self) -> dict:
+        """Custom dict conversion.
         """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
-        if 'jwt' in config or 'username' in config or 'password' in config:
-            config['auth'] = {}
-            if 'jwt' in config:
-                config['auth']['jwt'] = config.pop('jwt')
-            if 'username' in config or 'password' in config:
-                basic_auth = config['auth']['basicAuthNamePwd'] = []
-                if 'username' in config:
-                    basic_auth.append(config.pop('username'))
-                if 'password' in config:
-                    basic_auth.append(config.pop('password'))
+        res = {
+            'url': self.url,
+            'disabled': self.disabled,
+            'permanode': self.permanode
+        }
+        if self.jwt is not None or self.username is not None or self.password is not None:
+            auth = res['auth'] = {}
+            if self.jwt is not None:
+                auth['jwt'] = self.jwt
+            if self.username is not None or self.password is not None:
+                basic_auth = auth['basicAuthNamePwd'] = []
+                if self.username is not None:
+                    basic_auth.append(self.username)
+                if self.password is not None:
+                    basic_auth.append(self.password)
 
-        return config
+        return res
 
 
-class AddressAndAmount():
-    """Parameters to send a certain amount of coins to an address.
+def opt_int_encoder(value):
+    """Transforms int to string if Optional is not None
+
+     Attributes:
+            value: The optional int
     """
+    if value is not None:
+        return str(value)
+    return None
 
-    def __init__(self, amount: int, address: str):
-        """Initialize AddressAndAmount for options in Client::build_and_post_block()
 
-        Args:
+def hex_str_decoder(value: str) -> int:
+    """Parses a given string as a hexadecimal integer."""
+    return int(value, 16)
+
+
+@json
+@dataclass
+class AddressAndAmount:
+    """Parameters to send a certain amount of coins to an address.
+
+     Attributes:
             amount: The base coin amount to send.
             address: The receive address.
-        """
-        self.amount = amount
-        self.address = address
+    """
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    address: str
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
-        if 'amount' in config:
-            config['amount'] = str(config['amount'])
+class IdWithSlotIndex(str):
+    """Represents an hex encoded ID that contains a slot index at the end.
+
+    Attributes:
+        id: The hex encoded ID with a slot index.
+
+    """
 
-        return config
+    def slot_index(self):
+        """Returns the slot index of the ID.
+        """
+        return int.from_bytes(
+            bytes.fromhex(self[-8:]), 'little')
```

## iota_sdk/types/consolidation_params.py

```diff
@@ -1,23 +1,25 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from dataclasses import dataclass
 from typing import Optional
+from dataclasses import dataclass
+from iota_sdk.types.common import json
 
 
+@json
 @dataclass
 class ConsolidationParams:
     """Parameters for consolidation.
 
         Attributes:
         force (bool):
             Ignores the output_threshold if set to `true`.
-        outputThreshold (Optional[int]):
+        output_threshold (Optional[int]):
             Consolidates if the output number is >= the output_threshold.
-        targetAddress (Optional[str]):
+        target_address (Optional[str]):
             Address to which the consolidated output should be sent.
     """
 
     force: bool
-    outputThreshold: Optional[int] = None
-    targetAddress: Optional[str] = None
+    output_threshold: Optional[int] = None
+    target_address: Optional[str] = None
```

## iota_sdk/types/event.py

```diff
@@ -4,20 +4,39 @@
 from enum import IntEnum
 
 
 class WalletEventType(IntEnum):
     """Types of wallet events.
 
     Attributes:
-        ConsolidationRequired (0): Consolidation is required.
-        LedgerAddressGeneration (1): Nano Ledger has generated an address.
-        NewOutput (2): A new output was created.
-        SpentOutput (3): An output was spent.
-        TransactionInclusion (4): A transaction was included into the ledger.
-        TransactionProgress (5): A progress update while submitting a transaction.
+        LedgerAddressGeneration (0): Nano Ledger has generated an address.
+        NewOutput (1): A new output was created.
+        SpentOutput (2): An output was spent.
+        TransactionInclusion (3): A transaction was included into the ledger.
+        TransactionProgress (4): A progress update while submitting a transaction.
     """
-    ConsolidationRequired = 0
-    LedgerAddressGeneration = 1
-    NewOutput = 2
-    SpentOutput = 3
-    TransactionInclusion = 4
-    TransactionProgress = 5
+    LedgerAddressGeneration = 0
+    NewOutput = 1
+    SpentOutput = 2
+    TransactionInclusion = 3
+    TransactionProgress = 4
+
+
+class TransactionProgressEvent(IntEnum):
+    """Types of transaction progress events.
+
+    Attributes:
+        BuildingTransaction (0): Building a transaction.
+        GeneratingRemainderDepositAddress (1): Generating remainder value deposit address.
+        PreparedTransaction (2): Prepared transaction.
+        SigningTransaction (3): Signing a transaction.
+        PreparedTransactionSigningHash (4): Prepared transaction signing hash hex encoded, required for blindsigning with a Ledger Nano.
+        PreparedBlockSigningInput (5): Prepared block signing input.
+        Broadcasting (6): Broadcasting.
+    """
+    BuildingTransaction = 0
+    GeneratingRemainderDepositAddress = 1
+    PreparedTransaction = 2
+    SigningTransaction = 3
+    PreparedTransactionSigningHash = 4
+    PreparedBlockSigningInput = 5
+    Broadcasting = 6
```

## iota_sdk/types/feature.py

```diff
@@ -1,87 +1,204 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from enum import IntEnum
-from typing import Union
+from typing import Dict, List, TypeAlias, Union, Any
 from dataclasses import dataclass, field
-from iota_sdk.types.address import Ed25519Address, AliasAddress, NFTAddress
-from iota_sdk.types.common import HexStr
+from dataclasses_json import config
+from iota_sdk.types.address import Address, deserialize_address
+from iota_sdk.types.block_issuer_key import BlockIssuerKey
+from iota_sdk.types.common import EpochIndex, HexStr, hex_str_decoder, json, SlotIndex
 
 
 class FeatureType(IntEnum):
     """Types of features.
 
     Attributes:
         Sender (0): The sender feature.
         Issuer (1): The issuer feature.
         Metadata (2): The metadata feature.
-        Tag (3): The tag feature.
+        StateMetadata (3): The state metadata feature.
+        Tag (4): The tag feature.
+        NativeToken (5): The native token feature.
+        BlockIssuer (6): The block issuer feature.
+        Staking (7): The staking feature.
     """
     Sender = 0
     Issuer = 1
     Metadata = 2
-    Tag = 3
+    StateMetadata = 3
+    Tag = 4
+    NativeToken = 5
+    BlockIssuer = 6
+    Staking = 7
 
 
+@json
 @dataclass
-class Feature():
-    """Base class of a feature.
-    """
-    type: int
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        res = {k: v for k, v in self.__dict__.items() if v is not None}
-        if 'address' in res:
-            res['address'] = res['address'].as_dict()
-        return res
-
-
-@dataclass
-class SenderFeature(Feature):
-    """Sender feature.
+class SenderFeature:
+    """Identifies the validated sender of an output.
     Attributes:
         address: A given sender address.
     """
-    address: Union[Ed25519Address, AliasAddress, NFTAddress]
     type: int = field(
         default_factory=lambda: int(
             FeatureType.Sender),
         init=False)
+    address: Address = field(
+        metadata=config(
+            decoder=deserialize_address
+        ))
 
 
+@json
 @dataclass
-class IssuerFeature(Feature):
-    """Issuer feature.
+class IssuerFeature:
+    """Identifies the validated issuer of the UTXO state machine.
     Attributes:
         address: A given issuer address.
     """
-    address: Union[Ed25519Address, AliasAddress, NFTAddress]
     type: int = field(
         default_factory=lambda: int(
             FeatureType.Issuer),
         init=False)
+    address: Address = field(
+        metadata=config(
+            decoder=deserialize_address
+        ))
 
 
+@json
 @dataclass
-class MetadataFeature(Feature):
-    """Metadata feature.
+class MetadataFeature:
+    """Defines metadata, arbitrary binary data, that will be stored in the output.
     Attributes:
-        data: Some hex encoded metadata.
+        entries: A key-value map where the keys are graphic ASCII strings and the values hex-encoded binary data.
     """
-    data: HexStr
     type: int = field(
         default_factory=lambda: int(
             FeatureType.Metadata),
         init=False)
+    entries: Dict[str, HexStr]
+
+
+@json
+@dataclass
+class StateMetadataFeature:
+    """A Metadata Feature that can only be changed by the State Controller.
+    Attributes:
+        entries: A key-value map where the keys are graphic ASCII strings and the values hex-encoded binary data.
+    """
+    type: int = field(
+        default_factory=lambda: int(
+            FeatureType.StateMetadata),
+        init=False)
+    entries: Dict[str, HexStr]
 
 
+@json
 @dataclass
-class TagFeature(Feature):
-    """Tag feature.
+class TagFeature:
+    """Makes it possible to tag outputs with an index, so they can be retrieved through an indexer API.
     Attributes:
         tag: A hex encoded tag used to index the output.
     """
-    tag: HexStr
     type: int = field(default_factory=lambda: int(FeatureType.Tag), init=False)
+    tag: HexStr
+
+
+@json
+@dataclass
+class NativeTokenFeature:
+    """Contains a native token.
+        id: The unique identifier of the native token.
+        amount: The amount of native tokens.
+    """
+    type: int = field(default_factory=lambda: int(
+        FeatureType.NativeToken), init=False)
+    id: HexStr
+    amount: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
+
+
+@json
+@dataclass
+class BlockIssuerFeature:
+    """Contains the public keys to verify block signatures and allows for unbonding the issuer deposit.
+    Attributes:
+        expiry_slot: The slot index at which the Block Issuer Feature expires and can be removed.
+        block_issuer_keys: The Block Issuer Keys.
+    """
+    type: int = field(
+        default_factory=lambda: int(
+            FeatureType.BlockIssuer),
+        init=False)
+    expiry_slot: SlotIndex
+    block_issuer_keys: List[BlockIssuerKey]
+
+
+@json
+@dataclass
+class StakingFeature:
+    """Stakes IOTA coins to become eligible for committee selection, validate the network and receive Mana rewards.
+    Attributes:
+        staked_amount: The amount of IOTA coins that are locked and staked in the containing account.
+        fixed_cost: The fixed cost of the validator, which it receives as part of its Mana rewards.
+        start_epoch: The epoch index in which the staking started.
+        end_epoch: The epoch index in which the staking ends.
+    """
+    type: int = field(
+        default_factory=lambda: int(
+            FeatureType.Staking),
+        init=False)
+    staked_amount: int = field(metadata=config(
+        encoder=str
+    ))
+    fixed_cost: int = field(metadata=config(
+        encoder=str
+    ))
+    start_epoch: EpochIndex
+    end_epoch: EpochIndex
+
+
+Feature: TypeAlias = Union[SenderFeature, IssuerFeature,
+                           MetadataFeature, StateMetadataFeature, TagFeature, NativeTokenFeature, BlockIssuerFeature, StakingFeature]
+
+
+# pylint: disable=too-many-return-statements
+def deserialize_feature(d: Dict[str, Any]) -> Feature:
+    """
+    Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    feature_type = d['type']
+    if feature_type == FeatureType.Sender:
+        return SenderFeature.from_dict(d)
+    if feature_type == FeatureType.Issuer:
+        return IssuerFeature.from_dict(d)
+    if feature_type == FeatureType.Metadata:
+        return MetadataFeature.from_dict(d)
+    if feature_type == FeatureType.StateMetadata:
+        return StateMetadataFeature.from_dict(d)
+    if feature_type == FeatureType.Tag:
+        return TagFeature.from_dict(d)
+    if feature_type == FeatureType.NativeToken:
+        return NativeTokenFeature.from_dict(d)
+    if feature_type == FeatureType.BlockIssuer:
+        return BlockIssuerFeature.from_dict(d)
+    if feature_type == FeatureType.Staking:
+        return StakingFeature.from_dict(d)
+    raise Exception(f'invalid feature type: {feature_type}')
+
+
+def deserialize_features(dicts: List[Dict[str, Any]]) -> List[Feature]:
+    """
+    Takes a list of dictionaries as input and returns a list with specific instances of classes based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `dicts`: A list of dictionaries that are expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    return list(map(deserialize_feature, dicts))
```

## iota_sdk/types/filter_options.py

```diff
@@ -1,19 +1,21 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
 from typing import List, Optional
+from dataclasses import dataclass
+from iota_sdk.types.common import json, SlotIndex
 
 
+@json
 @dataclass
 class FilterOptions:
     """Options to filter outputs.
     """
 
-    lowerBoundBookedTimestamp: Optional[int] = None
-    upperBoundBookedTimestamp: Optional[int] = None
+    includedBelowSlot: Optional[SlotIndex] = None
+    includedAboveSlot: Optional[SlotIndex] = None
     outputTypes: Optional[List[int]] = None
-    aliasIds: Optional[List[str]] = None
+    accountIds: Optional[List[str]] = None
     foundryIds: Optional[List[str]] = None
     nftIds: Optional[List[str]] = None
```

## iota_sdk/types/input.py

```diff
@@ -1,44 +1,62 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
 from enum import IntEnum
-from iota_sdk.types.common import HexStr
+from typing import Dict, List, TypeAlias, Union, Any
+from dataclasses import dataclass, field
+from iota_sdk.types.common import json
+from iota_sdk.types.transaction_id import TransactionId
 
 
 class InputType(IntEnum):
     """Input types.
 
     Attributes:
         Utxo: An unspent transaction output.
-        Treasury: The treasury output.
     """
     Utxo = 0
-    Treasury = 1
 
 
+@json
 @dataclass
 class UtxoInput:
     """Represents an input referencing an output.
 
     Attributes:
         type: The type of input.
-        transactionId: The transaction id that created the output.
-        transactionOutputIndex: The output index.
+        transaction_id: The transaction id that created the output.
+        transaction_output_index: The output index.
     """
-    type: int
-    transactionId: HexStr
-    transactionOutputIndex: int
+    type: int = field(
+        default_factory=lambda: int(
+            InputType.Utxo),
+        init=False)
+    transaction_id: TransactionId
+    transaction_output_index: int
 
 
-@dataclass
-class TreasuryInput:
-    """A treasury input.
+Input: TypeAlias = Union[UtxoInput]
 
-    Attributes:
-        type: The type of input.
-        milestoneId: The milestone id that created the treasury output.
+
+def deserialize_input(d: Dict[str, Any]) -> Input:
+    """
+    Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    input_type = d['type']
+    if input_type == InputType.Utxo:
+        return UtxoInput.from_dict(d)
+    raise Exception(f'invalid input type: {input_type}')
+
+
+def deserialize_inputs(dicts: List[Dict[str, Any]]) -> List[Input]:
+    """
+    Takes a list of dictionaries as input and returns a list with specific instances of classes based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `dicts`: A list of dictionaries that are expected to have a key called 'type' which specifies the type of the returned value.
     """
-    type: int
-    milestoneId: HexStr
+    return list(map(deserialize_input, dicts))
```

## iota_sdk/types/irc_27.py

```diff
@@ -66,8 +66,8 @@
         """Turns this schema into a hex encoded string
         """
         utf8_to_hex(json.dumps(asdict(self), separators=(",", ":")))
 
     def as_feature(self):
         """Turns this schema into a MetadataFeature type
         """
-        MetadataFeature(self.as_hex())
+        MetadataFeature({'irc-27': self.as_hex()})
```

## iota_sdk/types/irc_30.py

```diff
@@ -43,8 +43,8 @@
         """Turns this schema into a hex encoded string
         """
         utf8_to_hex(json.dumps(asdict(self), separators=(",", ":")))
 
     def as_feature(self):
         """Turns this schema into a MetadataFeature type
         """
-        MetadataFeature(self.as_hex())
+        MetadataFeature({'irc-30': self.as_hex()})
```

## iota_sdk/types/native_token.py

```diff
@@ -1,17 +1,22 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from dataclasses import dataclass
-from iota_sdk.types.common import HexStr
+from dataclasses import dataclass, field
+from dataclasses_json import config
+from iota_sdk.types.common import hex_str_decoder, HexStr, json
 
 
+@json
 @dataclass
-class NativeToken():
+class NativeToken:
     """A native token.
 
     Attributes:
         id: The unique identifier of the native token.
         amount: The amount of native tokens.
     """
     id: HexStr
-    amount: HexStr
+    amount: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
```

## iota_sdk/types/node_info.py

```diff
@@ -1,176 +1,304 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 from typing import List, Optional
-from iota_sdk.types.common import HexStr
+from dataclasses_json import config
+from iota_sdk.types.common import EpochIndex, json, SlotIndex
+from iota_sdk.types.slot import SlotCommitmentId
 
 
+@json
 @dataclass
-class NodeInfoMilestone:
-    """Milestone info.
-
-    Attributes:
-        index: The milestone index.
-        timestamp: The milestone timestamp.
-        milestoneId: The milestone ID.
-    """
-    index: int
-    timestamp: Optional[int] = None
-    milestoneId: Optional[HexStr] = None
-
-
-@dataclass
-class NodeInfoStatus:
+class StatusResponse:
     """Node status.
 
     Attributes:
-        isHealthy: Whether the node is healthy.
-        latestMilestone: The latest milestone info.
-        confirmedMilestone: The latest confirmed milestone info.
-        pruningIndex: The pruning index of the node.
-    """
-    isHealthy: bool
-    latestMilestone: NodeInfoMilestone
-    confirmedMilestone: NodeInfoMilestone
-    pruningIndex: int
-
-
-@dataclass
-class NodeInfoMetrics:
-    """Node metrics.
-
-    Attributes:
-        blocksPerSecond: The blocks per second gossiped in the network.
-        referencedBlocksPerSecond: The referenced blocks per second in the network.
-        referencedRate: The percentage of blocks that get referenced.
+        is_healthy: Tells whether the node is healthy or not.
+        is_network_healthy: Tells whether the network is healthy (finalization is not delayed).
+        accepted_tangle_time: A notion of time that is anchored to the latest accepted block.
+        relative_accepted_tangle_time: The time after Accepted Tangle Time has advanced with the system clock.
+        confirmed_tangle_time: A notion of time that is anchored to the latest confirmed block.
+        relative_confirmed_tangle_time: The time after Confirmed Tangle Time has advanced with the system clock.
+        latest_commitment_id: The latest slot that the node has committed to.
+        latest_finalized_slot: The index of the latest finalized slot.
+        latest_accepted_block_slot: The slot index of the latest accepted block.
+        latest_confirmed_block_slot: The slot index of the latest confirmed block.
+        pruning_epoch: The index of the epoch before which the tangle history is pruned.
     """
-    blocksPerSecond: float
-    referencedBlocksPerSecond: float
-    referencedRate: float
+    is_healthy: bool
+    is_network_healthy: bool
+    accepted_tangle_time: int = field(metadata=config(
+        encoder=str
+    ))
+    relative_accepted_tangle_time: int = field(metadata=config(
+        encoder=str
+    ))
+    confirmed_tangle_time: int = field(metadata=config(
+        encoder=str
+    ))
+    relative_confirmed_tangle_time: int = field(metadata=config(
+        encoder=str
+    ))
+    latest_commitment_id: SlotCommitmentId
+    latest_finalized_slot: SlotIndex
+    latest_accepted_block_slot: SlotIndex
+    latest_confirmed_block_slot: SlotIndex
+    pruning_epoch: EpochIndex
 
 
+@json
 @dataclass
-class RentStructure:
-    """Rent structure for the storage deposit.
+class StorageScoreParameters:
+    """Defines the parameters of storage score calculations on objects which take node resources.
 
     Attributes:
-        vByteCost: The cost of base coin per virtual byte.
-        vByteFactorData: The weight factor used for key fields in the outputs.
-        vByteFactorKey: The weight factor used for data fields in the outputs.
+        storage_cost: Defines the number of IOTA tokens required per unit of storage score.
+        factor_data: Defines the factor to be used for data only fields.
+        offset_output_overhead: Defines the offset to be applied to all outputs for the overhead of handling them in storage.
+        offset_ed25519_block_issuer_key: Defines the offset to be used for block issuer feature public keys.
+        offset_staking_feature: Defines the offset to be used for staking feature.
+        offset_delegation: Defines the offset to be used for delegation output.
     """
-    vByteCost: int
-    vByteFactorData: int
-    vByteFactorKey: int
+    storage_cost: int = field(metadata=config(
+        encoder=str
+    ))
+    factor_data: int
+    offset_output_overhead: int = field(metadata=config(
+        encoder=str
+    ))
+    offset_ed25519_block_issuer_key: int = field(metadata=config(
+        encoder=str
+    ))
+    offset_staking_feature: int = field(metadata=config(
+        encoder=str
+    ))
+    offset_delegation: int = field(metadata=config(
+        encoder=str
+    ))
 
     def as_dict(self):
         """Converts this object to a dict.
         """
         res = {k: v for k, v in self.__dict__.items() if v is not None}
         return res
 
 
+@json
 @dataclass
-class NodeInfoProtocol:
-    """Protocol info.
+class WorkScoreParameters:
+    """Work Score Parameters lists the work score of each type, it is used to denote the computation costs of processing an object.
 
     Attributes:
-        networkName: The human friendly name of the network.
-        bech32Hrp: The HRP prefix used for Bech32 addresses in the network.
-        tokenSupply: TokenSupply defines the current token supply on the network.
-        version: The version of the protocol running.
-        belowMaxDepth: The below max depth parameter of the network.
-        minPowScore: The minimum pow score of the network.
-        rentStructure: The rent structure used by given node/network.
-    """
-    networkName: str
-    bech32Hrp: str
-    tokenSupply: str
-    version: int
-    belowMaxDepth: int
-    minPowScore: float
-    rentStructure: RentStructure
+        data_byte: Data_kibibyte accounts for the network traffic per kibibyte.
+        block: Block accounts for work done to process a block in the node software.
+        input: Input accounts for loading the UTXO from the database and performing the mana calculations.
+        context_input: Context_input accounts for loading and checking the context input.
+        output: Output accounts for storing the UTXO in the database.
+        native_token: Native_token accounts for calculations done with native tokens.
+        staking: Staking accounts for the existence of a staking feature in the output.
+        block_issuer: BlockIssuer accounts for the existence of a block issuer feature in the output.
+        allotment: Allotment accounts for accessing the account-based ledger to transform the mana to block issuance credits.
+        signature_ed25519: SignatureEd25519 accounts for an Ed25519 signature check.
+    """
+    data_byte: int
+    block: int
+    input: int
+    context_input: int
+    output: int
+    native_token: int
+    staking: int
+    block_issuer: int
+    allotment: int
+    signature_ed25519: int
 
     def as_dict(self):
         """Converts this object to a dict.
         """
         res = {k: v for k, v in self.__dict__.items() if v is not None}
         if res["rentStructure"]:
             res["rentStructure"] = res["rentStructure"].as_dict()
         return res
 
 
+@json
 @dataclass
-class PendingProtocolParameter:
-    """Pending protocol parameters.
+class CongestionControlParameters:
+    """Congestion Control Parameters defines the parameters used to calculate the Reference Mana Cost (RMC).
 
     Attributes:
-        type: Type of change.
-        targetMilestoneIndex: Milestone index at which the new protocol parameters become active.
-        protocolVersion: The new protocol version.
-        params: The new protocol parameters.
+        min_reference_mana_cost: The minimum value of the reference Mana cost.
+        increase: The increase step size of the reference Mana cost.
+        decrease: The decrease step size of the reference Mana cost.
+        increase_threshold: The threshold for increasing the reference Mana cost.
+        decrease_threshold: The threshold for decreasing the reference Mana cost.
+        scheduler_rate: The rate at which the scheduler runs in workscore units per second.
+        max_buffer_size: The maximum size of the buffer in the scheduler.
+        max_validation_buffer_size: The maximum number of blocks in the validation buffer.
     """
-    type: int
-    targetMilestoneIndex: int
-    protocolVersion: int
-    params: str
+    min_reference_mana_cost: int = field(metadata=config(
+        encoder=str
+    ))
+    increase: int = field(metadata=config(
+        encoder=str
+    ))
+    decrease: int = field(metadata=config(
+        encoder=str
+    ))
+    increase_threshold: int
+    decrease_threshold: int
+    scheduler_rate: int
+    max_buffer_size: int
+    max_validation_buffer_size: int
 
 
+@json
 @dataclass
-class NodeInfoBaseToken:
-    """The base coin info.
+class VersionSignalingParameters:
+    """Version Signaling defines the parameters used by signaling protocol parameters upgrade.
 
     Attributes:
-        name: Name of the base coin.
-        tickerSymbol: Base coin ticker symbol.
-        unit: Base coin unit.
-        decimals: Number of decimals.
-        useMetricPrefix: Whether the coin uses a metric prefix.
-        subunit: Base coin subunit.
+        window_size: The size of the window in epochs to find which version of protocol parameters was most signaled, from current_epoch - window_size to current_epoch.
+        window_target_ratio: The target number of supporters for a version to win in a window_size.
+        activation_offset: The offset in epochs to activate the new version of protocol parameters.
     """
-    name: str
-    tickerSymbol: str
-    unit: str
-    decimals: int
-    useMetricPrefix: bool
-    subunit: Optional[str] = None
+    window_size: int
+    window_target_ratio: int
+    activation_offset: int
 
 
+@json
 @dataclass
-class NodeInfo:
-    """Response from the /info endpoint.
+class ManaParameters:
+    """ManaParameters defines the parameters used by mana calculation.
 
     Attributes:
-        name: The name of the node (e.g. Hornet).
-        version: The version of the node.
-        status: The status of the node.
-        metrics: Some node metrics.
-        supportedProtocolVersions: Supported protocol versions by the node.
-        protocol: Information about the running protocol.
-        pendingProtocolParameters: A list of pending (not yet active) protocol parameters.
-        baseToken: Information about the base token.
-        features: List of features supported by the node.
+        bits_count: The number of bits used to represent Mana.
+        generation_rate: The amount of potential Mana generated by 1 IOTA in 1 slot.
+        generation_rate_exponent: The scaling of generation_rate expressed as an exponent of 2.
+        decay_factors: A lookup table of epoch index diff to mana decay factor (slice index 0 = 1 epoch).
+        decay_factors_exponent: The scaling of decay_factors expressed as an exponent of 2.
+        decay_factor_epochs_sum: An integer approximation of the sum of decay over epochs.
+        decay_factor_epochs_sum_exponent: The scaling of decay_factor_epochs_sum expressed as an exponent of 2.
+        annual_decay_factor_percentage: Decay factor for 1 year.
     """
+    bits_count: int
+    generation_rate: int
+    generation_rate_exponent: int
+    decay_factors: List[int]
+    decay_factors_exponent: int
+    decay_factor_epochs_sum: int
+    decay_factor_epochs_sum_exponent: int
+    annual_decay_factor_percentage: int
 
-    name: str
-    version: str
-    status: NodeInfoStatus
-    metrics: NodeInfoMetrics
-    supportedProtocolVersions: List[int]
-    protocol: NodeInfoProtocol
-    pendingProtocolParameters: List[PendingProtocolParameter]
-    baseToken: NodeInfoBaseToken
-    features: List[str]
+
+@json
+@dataclass
+class RewardsParameters:
+    """Rewards Parameters defines the parameters that are used to calculate Mana rewards.
+
+    Attributes:
+        profit_margin_exponent: Used for shift operation during calculation of profit margin.
+        bootstrapping_duration: The length of the bootstrapping phase in epochs.
+        reward_to_generation_ratio: The ratio of the final rewards rate to the generation rate of Mana.
+        initial_target_rewards_rate: The rate of Mana rewards at the start of the bootstrapping phase.
+        final_target_rewards_rate: The rate of Mana rewards after the bootstrapping phase.
+        pool_coefficient_exponent: The exponent used for shifting operation during the pool rewards calculations.
+        retention_period: The number of epochs for which rewards are retained.
+    """
+    profit_margin_exponent: int
+    bootstrapping_duration: int
+    reward_to_generation_ratio: int
+    initial_target_rewards_rate: int = field(metadata=config(
+        encoder=str
+    ))
+    final_target_rewards_rate: int = field(metadata=config(
+        encoder=str
+    ))
+    pool_coefficient_exponent: int
+    retention_period: int
 
 
+@json
 @dataclass
-class NodeInfoWrapper:
-    """NodeInfo wrapper which contains the node info and the url from the node.
+class ProtocolParameters:
+    """The protocol parameters.
 
     Attributes:
-        nodeInfo: A NodeInfo object.
-        url: The URL of the node.
+        type: Set to value 0 to denote a IOTA 2.0 protocol parameter.
+        version: Protocol version used by the network.
+        network_name: The Name of the network from which the networkId is derived.
+        bech32_hrp: Tells whether the node supports mainnet or testnet addresses.
+                    Value `iota` indicates that the node supports mainnet addresses.
+                    Value `atoi` indicates that the node supports testnet addresses.
+        storage_score_parameters: The storage score parameters used by given node/network.
+        work_score_parameters: Work Score Parameters lists the work score of each type, it is used to denote the computation costs of processing an object.
+        token_supply: Current supply of the base token. Plain string encoded number.
+        genesis_slot: Defines the slot of the genesis.
+        genesis_unix_timestamp: The genesis timestamp at which the slots start to count.
+        slot_duration_in_seconds: The duration of a slot, in seconds.
+        slots_per_epoch_exponent: The number of slots in an epoch expressed as an exponent of 2.
+        mana_parameters: ManaParameters defines the parameters used by mana calculation.
+        staking_unbonding_period: The unbonding period in epochs before an account can stop staking.
+        validation_blocks_per_slot: Validation Blocks Per Slot is the number of validation blocks that each validator should issue each slot.
+        punishment_epochs: The number of epochs worth of Mana that a node is punished with for each additional validation block it issues.
+        liveness_threshold_lower_bound: Used by tip-selection to determine if a block is eligible by evaluating issuing times.
+        liveness_threshold_upper_bound: Used by tip-selection to determine if a block is eligible by evaluating issuing times.
+        min_committable_age: Min_committable_age is the minimum age relative to the accepted tangle time slot index that a slot can be committed.
+        max_committable_age: Max_committable_age is the maximum age for a slot commitment to be included in a block relative to the slot index of the block issuing time.
+        epoch_nearing_threshold: Determine the slot that should trigger a new committee selection for the next and upcoming epoch.
+        congestion_control_parameters: Congestion Control Parameters defines the parameters used to calculate the Reference Mana Cost (RMC).
+        version_signaling_parameters: The version signaling parameters.
+        rewards_parameters: Rewards Parameters defines the parameters that are used to calculate Mana rewards.
+        target_committee_size: Defines the target size of the committee. If there's fewer candidates the actual committee size could be smaller in a given epoch.
+        chain_switching_threshold: Defines the number of heavier slots that a chain needs to be ahead of the current chain to be considered for switching.
     """
-    nodeInfo: NodeInfo
-    url: str
+    type: int
+    version: int
+    network_name: str
+    bech32_hrp: str
+    storage_score_parameters: StorageScoreParameters
+    work_score_parameters: WorkScoreParameters
+    mana_parameters: ManaParameters
+    token_supply: int = field(metadata=config(
+        encoder=str
+    ))
+    genesis_slot: int
+    genesis_unix_timestamp: int = field(metadata=config(
+        encoder=str
+    ))
+    slot_duration_in_seconds: int
+    slots_per_epoch_exponent: int
+    staking_unbonding_period: int
+    validation_blocks_per_slot: int
+    punishment_epochs: int
+    liveness_threshold_lower_bound: int
+    liveness_threshold_upper_bound: int
+    min_committable_age: int
+    max_committable_age: int
+    epoch_nearing_threshold: int
+    congestion_control_parameters: CongestionControlParameters
+    version_signaling_parameters: VersionSignalingParameters
+    rewards_parameters: RewardsParameters
+    target_committee_size: int
+    chain_switching_threshold: int
+
+
+@json
+@dataclass
+class BaseTokenResponse:
+    """The base coin info.
+
+    Attributes:
+        name: The name of the base token of the network.
+        ticker_symbol: Ticker symbol of the token to be displayed on trading platforms.
+        unit: The primary unit of the token.
+        subunit: The name of the smallest possible denomination of the primary unit. subunit * 10^decimals = unit.
+        decimals: Number of decimals the primary unit is divisible up to.
+    """
+    name: str
+    ticker_symbol: str
+    unit: str
+    decimals: int
+    subunit: Optional[str] = None
```

## iota_sdk/types/output.py

```diff
@@ -1,316 +1,334 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass, field
 from enum import IntEnum
-from typing import Dict, Optional, List, Union
-from dacite import from_dict
-from iota_sdk.types.common import HexStr
-from iota_sdk.types.feature import SenderFeature, IssuerFeature, MetadataFeature, TagFeature
-from iota_sdk.types.native_token import NativeToken
+from typing import Dict, Optional, List, TypeAlias, Union, Any
+from dataclasses import dataclass, field
+from dataclasses_json import config
+from iota_sdk.types.common import HexStr, json, EpochIndex
+from iota_sdk.types.feature import deserialize_features, SenderFeature, IssuerFeature, MetadataFeature, TagFeature, NativeTokenFeature
 from iota_sdk.types.token_scheme import SimpleTokenScheme
-from iota_sdk.types.unlock_condition import AddressUnlockCondition, StorageDepositReturnUnlockCondition, TimelockUnlockCondition, ExpirationUnlockCondition, StateControllerAddressUnlockCondition, GovernorAddressUnlockCondition, ImmutableAliasAddressUnlockCondition
+from iota_sdk.types.unlock_condition import deserialize_unlock_conditions, AddressUnlockCondition, StateControllerAddressUnlockCondition, GovernorAddressUnlockCondition, StorageDepositReturnUnlockCondition, TimelockUnlockCondition, ExpirationUnlockCondition, ImmutableAccountAddressUnlockCondition
+from iota_sdk.types.address import AccountAddress
 
 
 class OutputType(IntEnum):
     """Output types.
 
     Attributes:
-        Treasury (2): A treasury output.
-        Basic (3): A basic output.
-        Alias (4): An alias output.
-        Foundry (5): A foundry output.
-        Nft (6): An NFT output.
-    """
-    Treasury = 2
-    Basic = 3
-    Alias = 4
-    Foundry = 5
-    Nft = 6
+        Basic (0): A basic output.
+        Account (1): An account output.
+        Anchor (2): An anchor output.
+        Foundry (3): A foundry output.
+        Nft (4): An NFT output.
+        Delegation (5): A delegation output.
+
+    """
+    Basic = 0
+    Account = 1
+    Anchor = 2
+    Foundry = 3
+    Nft = 4
+    Delegation = 5
 
 
+@json
 @dataclass
-class Output():
-    """An output in a UTXO ledger.
-    """
-    type: int
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        if 'unlockConditions' in config:
-            config['unlockConditions'] = list(map(
-                lambda x: x.as_dict(), config['unlockConditions']))
-        if 'nativeTokens' in config:
-            config['nativeTokens'] = list(map(
-                lambda x: x.__dict__, config['nativeTokens']))
-        if 'features' in config:
-            config['features'] = list(map(
-                lambda x: x.as_dict(), config['features']))
-        if 'immutableFeatures' in config:
-            config['immutableFeatures'] = list(map(
-                lambda x: x.as_dict(), config['immutableFeatures']))
-        if 'tokenScheme' in config:
-            config['tokenScheme'] = config['tokenScheme'].__dict__
-
-        return config
-
+class BasicOutput:
+    """Describes a basic output.
 
-@dataclass
-class TreasuryOutput(Output):
-    """Describes a treasury output.
     Attributes:
         amount :
             The base coin amount of the output.
+        mana :
+            Amount of stored Mana held by this output.
+        unlock_conditions :
+            The conditions to unlock the output.
+        features :
+            Features that add utility to the output but do not impose unlocking conditions.
         type :
             The type of output.
     """
-    amount: str
     type: int = field(
         default_factory=lambda: int(
-            OutputType.Treasury),
+            OutputType.Basic),
         init=False)
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    mana: int = field(metadata=config(
+        encoder=str
+    ))
+    unlock_conditions: List[Union[AddressUnlockCondition, ExpirationUnlockCondition, StorageDepositReturnUnlockCondition,
+                                  TimelockUnlockCondition]] = field(metadata=config(
+                                                                    decoder=deserialize_unlock_conditions
+                                                                    ))
+    features: Optional[List[Union[SenderFeature,
+                            MetadataFeature, TagFeature, NativeTokenFeature]]] = field(default=None,
+                                                                                       metadata=config(
+                                                                                           decoder=deserialize_features
+                                                                                       ))
 
 
+@json
 @dataclass
-class BasicOutput(Output):
-    """Describes a basic output.
+class AccountOutput:
+    """Describes an account output.
+
     Attributes:
         amount :
             The base coin amount of the output.
-        unlockConditions :
+        mana :
+            Amount of stored Mana held by this output.
+        unlock_conditions:
             The conditions to unlock the output.
+        account_id :
+            The account ID if it's an account output.
+        foundry_counter :
+            A counter that denotes the number of foundries created by this account output.
         features :
             Features that add utility to the output but do not impose unlocking conditions.
-        nativeTokens :
-            Native tokens added to the new output.
+        immutable_features :
+            Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
         type :
             The type of output.
     """
-    amount: str
-    unlockConditions: List[Union[AddressUnlockCondition, ExpirationUnlockCondition, StorageDepositReturnUnlockCondition,
-                           TimelockUnlockCondition]]
-    features: Optional[List[Union[SenderFeature,
-                            MetadataFeature, TagFeature]]] = None
-    nativeTokens: Optional[List[NativeToken]] = None
     type: int = field(
         default_factory=lambda: int(
-            OutputType.Basic),
+            OutputType.Account),
         init=False)
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    mana: int = field(metadata=config(
+        encoder=str
+    ))
+    account_id: HexStr
+    foundry_counter: int
+    unlock_conditions: List[AddressUnlockCondition] = field(
+        metadata=config(
+            decoder=deserialize_unlock_conditions
+        ))
+    features: Optional[List[Union[SenderFeature,
+                            MetadataFeature]]] = field(default=None,
+                                                       metadata=config(
+                                                           decoder=deserialize_features
+                                                       ))
+    immutable_features: Optional[List[Union[IssuerFeature,
+                                            MetadataFeature]]] = field(default=None,
+                                                                       metadata=config(
+                                                                           decoder=deserialize_features
+                                                                       ))
 
 
+@json
 @dataclass
-class AliasOutput(Output):
-    """Describes an alias output.
+class AnchorOutput:
+    """Describes an anchor output.
+
     Attributes:
         amount :
             The base coin amount of the output.
-        unlockConditions :
+        mana :
+            Amount of stored Mana held by this output.
+        anchor_id :
+            The anchor ID if it's an anchor output.
+        state_index :
+            A counter that must increase by 1 every time the anchor is state transitioned.
+        unlock_conditions:
             The conditions to unlock the output.
-        aliasId :
-            The alias ID if it's an alias output.
-        stateIndex :
-            A counter that must increase by 1 every time the alias is state transitioned.
-        stateMetadata :
-            Metadata that can only be changed by the state controller.
-        foundryCounter :
-            A counter that denotes the number of foundries created by this alias account.
         features :
             Features that add utility to the output but do not impose unlocking conditions.
-        nativeTokens :
-            Native tokens added to the new output.
-        immutableFeatures :
+        immutable_features :
             Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
         type :
             The type of output.
     """
-    amount: str
-    aliasId: HexStr
-    stateIndex: int
-    foundryCounter: int
-    unlockConditions: List[Union[StateControllerAddressUnlockCondition,
-                           GovernorAddressUnlockCondition]]
-    features: Optional[List[Union[SenderFeature,
-                            MetadataFeature]]] = None
-    immutableFeatures: Optional[List[Union[IssuerFeature,
-                                     MetadataFeature]]] = None
-    stateMetadata: Optional[HexStr] = None
-    nativeTokens: Optional[List[NativeToken]] = None
     type: int = field(
         default_factory=lambda: int(
-            OutputType.Alias),
+            OutputType.Anchor),
         init=False)
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    mana: int = field(metadata=config(
+        encoder=str
+    ))
+    anchor_id: HexStr
+    state_index: int
+    unlock_conditions: List[Union[StateControllerAddressUnlockCondition,
+                                  GovernorAddressUnlockCondition]] = field(
+        metadata=config(
+            decoder=deserialize_unlock_conditions
+        ))
+    features: Optional[List[Union[SenderFeature,
+                            MetadataFeature]]] = field(default=None,
+                                                       metadata=config(
+                                                           decoder=deserialize_features
+                                                       ))
+    immutable_features: Optional[List[Union[IssuerFeature,
+                                            MetadataFeature]]] = field(default=None,
+                                                                       metadata=config(
+                                                                           decoder=deserialize_features
+                                                                       ))
 
 
+@json
 @dataclass
-class FoundryOutput(Output):
+class FoundryOutput:
     """Describes a foundry output.
+
     Attributes:
         amount :
             The base coin amount of the output.
-        unlockConditions :
+        unlock_conditions :
             The conditions to unlock the output.
         features :
             Features that add utility to the output but do not impose unlocking conditions.
-        nativeTokens :
-            Native tokens added to the new output.
-        immutableFeatures :
+        immutable_features :
             Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
-        serialNumber :
-            The serial number of the foundry with respect to the controlling alias.
-        tokenScheme :
+        serial_number :
+            The serial number of the foundry with respect to the controlling account.
+        token_scheme :
             Defines the supply control scheme of the tokens controlled by the foundry. Currently only a simple scheme is supported.
         type :
             The type of output.
     """
-    amount: str
-    serialNumber: int
-    tokenScheme: SimpleTokenScheme
-    unlockConditions: List[ImmutableAliasAddressUnlockCondition]
-    features: Optional[List[MetadataFeature]] = None
-    immutableFeatures: Optional[List[MetadataFeature]] = None
-    nativeTokens: Optional[List[NativeToken]] = None
     type: int = field(
         default_factory=lambda: int(
             OutputType.Foundry),
         init=False)
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    serial_number: int
+    token_scheme: SimpleTokenScheme
+    unlock_conditions: List[ImmutableAccountAddressUnlockCondition]
+    features: Optional[List[Union[MetadataFeature, NativeTokenFeature]]] = field(default=None,
+                                                                                 metadata=config(
+                                                                                     decoder=deserialize_features
+                                                                                 ))
+    immutable_features: Optional[List[MetadataFeature]] = field(default=None,
+                                                                metadata=config(
+                                                                    decoder=deserialize_features
+                                                                ))
 
 
+@json
 @dataclass
-class NftOutput(Output):
+class NftOutput:
     """Describes an NFT output.
+
     Attributes:
         amount :
             The base coin amount of the output.
-        unlockConditions :
+        mana :
+            Amount of stored Mana held by this output.
+        unlock_conditions :
             The conditions to unlock the output.
-        nftId :
+        nft_id :
             The NFT ID if it's an NFT output.
         features :
             Features that add utility to the output but do not impose unlocking conditions.
-        nativeTokens :
-            Native tokens added to the new output.
-        immutableFeatures :
+        immutable_features :
             Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
         type :
             The type of output.
     """
-    amount: str
-    nftId: HexStr
-    unlockConditions: List[Union[AddressUnlockCondition, ExpirationUnlockCondition,
-                           StorageDepositReturnUnlockCondition, TimelockUnlockCondition]]
-    features: Optional[List[Union[SenderFeature,
-                            MetadataFeature, TagFeature]]] = None
-    immutableFeatures: Optional[List[Union[
-        IssuerFeature, MetadataFeature]]] = None
-    nativeTokens: Optional[List[NativeToken]] = None
     type: int = field(default_factory=lambda: int(OutputType.Nft), init=False)
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    mana: int = field(metadata=config(
+        encoder=str
+    ))
+    nft_id: HexStr
+    unlock_conditions: List[Union[AddressUnlockCondition, ExpirationUnlockCondition,
+                                  StorageDepositReturnUnlockCondition, TimelockUnlockCondition]] = field(
+        metadata=config(
+            decoder=deserialize_unlock_conditions
+        ))
+    features: Optional[List[Union[SenderFeature,
+                            MetadataFeature, TagFeature]]] = field(default=None,
+                                                                   metadata=config(
+                                                                       decoder=deserialize_features
+                                                                   ))
+    immutable_features: Optional[List[Union[
+        IssuerFeature, MetadataFeature]]] = field(default=None,
+                                                  metadata=config(
+                                                      decoder=deserialize_features
+                                                  ))
 
 
+@json
 @dataclass
-class OutputMetadata:
-    """Metadata about an output.
-
-    Attributes:
-        blockId: The ID of the block in which the output appeared in.
-        transactionId: The ID of the transaction in which the output was created.
-        outputIndex: The index of the output within the corresponding transaction.
-        isSpent: Whether the output is already spent.
-        milestoneIndexBooked: The index of the milestone which booked/created the output.
-        milestoneTimestampBooked: The timestamp of the milestone which booked/created the output.
-        ledgerIndex: The current ledger index.
-        milestoneIndexSpent: The index of the milestone which spent the output.
-        milestoneTimestampSpent: The timestamp of the milestone which spent the output.
-        transactionIdSpent: The ID of the transaction that spent the output.
-    """
-    blockId: HexStr
-    transactionId: HexStr
-    outputIndex: int
-    isSpent: bool
-    milestoneIndexBooked: int
-    milestoneTimestampBooked: int
-    ledgerIndex: int
-    milestoneIndexSpent: Optional[int] = None
-    milestoneTimestampSpent: Optional[int] = None
-    transactionIdSpent: Optional[HexStr] = None
-
-    # pylint: disable=redefined-builtin
-    @classmethod
-    def from_dict(cls, dict: Dict) -> OutputMetadata:
-        """Converts a dict to a OutputMetadata
-        """
-        obj = cls.__new__(cls)
-        super(OutputMetadata, obj).__init__()
-        for k, v in dict.items():
-            setattr(obj, k, v)
-        return obj
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        return {k: v for k, v in self.__dict__.items() if v is not None}
-
-
-@dataclass
-class OutputWithMetadata:
-    """An output with its metadata.
+class DelegationOutput:
+    """An output which delegates its contained IOTA coins as voting power to a validator.
 
     Attributes:
-        metadata: The `OutputMetadata` object that belongs to `output`.
-        output: An `Output` object.
-    """
-
-    metadata: OutputMetadata
-    output: Union[AliasOutput, FoundryOutput, NftOutput, BasicOutput]
+        amount: The amount of IOTA coins held by the output.
+        delegated_amount: The amount of delegated IOTA coins.
+        delegation_id: Unique identifier of the Delegation Output
+        validator_address: The Account Address of the validator to which this output is delegating.
+        start_epoch: The index of the first epoch for which this output delegates.
+        end_epoch: The index of the last epoch for which this output delegates.
+        unlock_conditions: Define how the output can be unlocked in a transaction.
+        type: The type of output.
+    """
+    type: int = field(default_factory=lambda: int(
+        OutputType.Delegation), init=False)
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    delegated_amount: int = field(metadata=config(
+        encoder=str
+    ))
+    delegation_id: HexStr
+    validator_address: AccountAddress
+    start_epoch: EpochIndex
+    end_epoch: EpochIndex
+    unlock_conditions: List[AddressUnlockCondition] = field(metadata=config(
+        decoder=deserialize_unlock_conditions
+    ))
+
+
+Output: TypeAlias = Union[BasicOutput,
+                          AccountOutput,
+                          AnchorOutput,
+                          FoundryOutput,
+                          NftOutput,
+                          DelegationOutput]
 
-    # pylint: disable=redefined-builtin
-    @classmethod
-    def from_dict(cls, dict: Dict) -> OutputWithMetadata:
-        """Creates an output with metadata instance from the dict object.
-        """
-        obj = cls.__new__(cls)
-        super(OutputWithMetadata, obj).__init__()
-        for k, v in dict.items():
-            setattr(obj, k, v)
-        return obj
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {}
-
-        config['metadata'] = self.metadata.__dict__
-        config['output'] = self.output.as_dict()
-
-        return config
-
-
-def output_from_dict(
-        output: Dict[str, any]) -> Union[TreasuryOutput, BasicOutput, AliasOutput, FoundryOutput, NftOutput, Output]:
+def deserialize_output(d: Dict[str, Any]) -> Output:
     """
-    Takes a dictionary as input and returns an instance of a specific
-    output class based on the value of the 'type' key in the dictionary.
+    Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
 
     Arguments:
-
-    * `output`: The `output` parameter is a dictionary that contains information about the output. It is
-    expected to have a key called 'type' which specifies the type of the output. The value of 'type'
-    should be one of the values defined in the `OutputType` enum.
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
     """
-    output_type = OutputType(output['type'])
-
-    if output_type == OutputType.Treasury:
-        return from_dict(TreasuryOutput, output)
+    output_type = d['type']
     if output_type == OutputType.Basic:
-        return from_dict(BasicOutput, output)
-    if output_type == OutputType.Alias:
-        return from_dict(AliasOutput, output)
+        return BasicOutput.from_dict(d)
+    if output_type == OutputType.Account:
+        return AccountOutput.from_dict(d)
+    if output_type == OutputType.Anchor:
+        return AnchorOutput.from_dict(d)
     if output_type == OutputType.Foundry:
-        return from_dict(FoundryOutput, output)
+        return FoundryOutput.from_dict(d)
     if output_type == OutputType.Nft:
-        return from_dict(NftOutput, output)
+        return NftOutput.from_dict(d)
+    if output_type == OutputType.Delegation:
+        return DelegationOutput.from_dict(d)
+    raise Exception(f'invalid output type: {output_type}')
 
-    return from_dict(Output, output)
+
+def deserialize_outputs(dicts: List[Dict[str, Any]]) -> List[Output]:
+    """
+    Takes a list of dictionaries as input and returns a list with specific instances of classes based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `dicts`: A list of dictionaries that are expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    return list(map(deserialize_output, dicts))
```

## iota_sdk/types/output_data.py

```diff
@@ -1,35 +1,31 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
 from dataclasses import dataclass
-from typing import Optional, Union
-from iota_sdk.types.address import Ed25519Address, AliasAddress, NFTAddress
-from iota_sdk.types.common import HexStr
-from iota_sdk.types.output import BasicOutput, AliasOutput, FoundryOutput, NftOutput, OutputMetadata
-from iota_sdk.types.signature import Bip44
+from iota_sdk.types.common import json
+from iota_sdk.types.output import Output
+from iota_sdk.types.output_id import OutputId
+from iota_sdk.types.output_id_proof import OutputIdProof
+from iota_sdk.types.output_metadata import OutputMetadata
 
 
+@json
 @dataclass
-class OutputData():
-    """Output data.
+class OutputData:
+    """An output with additional data.
 
     Attributes:
-        outputId: With the output data corresponding output ID.
-        metadata: With the output corresponding metadata.
-        output: The output object itself.
-        isSpent: Whether the output is spent.
-        address: The address associated with the output.
-        networkId: The network ID the output belongs to.
+        output: The output itself.
+        metadata: The metadata of the output.
+        output_id_proof: The output ID proof.
+        output_id: The corresponding output ID.
+        network_id: The network ID the output belongs to.
         remainder: Whether the output represents a remainder amount.
-        chain: A list of chain state indexes.
     """
-
-    outputId: HexStr
+    output: Output
     metadata: OutputMetadata
-    output: Union[AliasOutput, FoundryOutput, NftOutput, BasicOutput]
-    isSpent: bool
-    address: Union[Ed25519Address, AliasAddress, NFTAddress]
-    networkId: str
+    output_id_proof: OutputIdProof
+    output_id: OutputId
+    network_id: str
     remainder: bool
-    chain: Optional[Bip44] = None
```

## iota_sdk/types/output_id.py

```diff
@@ -1,60 +1,80 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from iota_sdk.types.common import HexStr
+from dataclasses import dataclass
+from iota_sdk.types.common import json
+from iota_sdk.types.output import Output
+from iota_sdk.types.transaction_id import TransactionId
 
 
-class OutputId(dict):
+class OutputId(str):
     """Represents an output ID.
 
     Attributes:
         output_id: The unique id of an output.
-        transaction_id: The transaction id associated with the output.
-        output_index: The index of the output within a transaction.
-
     """
 
-    def __init__(self, transaction_id: HexStr, output_index: int):
+    def __new__(cls, output_id: str):
         """Initialize OutputId
         """
-        if len(transaction_id) != 66:
+        if len(output_id) != 78:
             raise ValueError(
-                'transaction_id length must be 66 characters with 0x prefix')
-        if not transaction_id.startswith('0x'):
-            raise ValueError('transaction_id must start with 0x')
+                'output_id length must be 78 characters with 0x prefix')
+        if not output_id.startswith('0x'):
+            raise ValueError('output_id must start with 0x')
         # Validate that it has only valid hex characters
-        int(transaction_id[2:], 16)
-        if output_index not in range(0, 129):
-            raise ValueError('output_index must be a value from 0 to 128')
-        output_index_hex = (output_index).to_bytes(2, "little").hex()
-        self.output_id = transaction_id + output_index_hex
-        self.transaction_id = transaction_id
-        self.output_index = output_index
+        int(output_id[2:], 16)
+        instance = super().__new__(cls, output_id)
+        return instance
 
     @classmethod
-    def from_string(cls, output_id: HexStr):
-        """Creates an `OutputId` instance from a `HexStr`.
+    def from_transaction_id_and_output_index(
+            cls, transaction_id: TransactionId, output_index: int):
+        """Creates an `OutputId` instance from its transaction id and output index.
 
         Args:
-            output_id: The unique id of an output as a hex string.
+            transaction_id: The transaction id associated with the output.
+            output_index: The index of the output within a transaction.
 
         Returns:
             OutputId: The unique id of an output.
         """
-        obj = cls.__new__(cls)
-        super(OutputId, obj).__init__()
-        if len(output_id) != 70:
+        if len(transaction_id) != 74:
             raise ValueError(
-                'output_id length must be 70 characters with 0x prefix')
-        if not output_id.startswith('0x'):
+                'transaction_id length must be 74 characters with 0x prefix')
+        if not transaction_id.startswith('0x'):
             raise ValueError('transaction_id must start with 0x')
         # Validate that it has only valid hex characters
-        int(output_id[2:], 16)
-        obj.output_id = output_id
-        obj.transaction_id = HexStr(output_id[:66])
-        obj.output_index = int.from_bytes(
-            bytes.fromhex(output_id[66:]), 'little')
-        return obj
+        int(transaction_id[2:], 16)
+        output_index_hex = (output_index).to_bytes(2, "little").hex()
+        return OutputId(transaction_id + output_index_hex)
+
+    def transaction_id(self) -> TransactionId:
+        """Returns the TransactionId of an OutputId.
+        """
+        return TransactionId(self[:74])
 
-    def __repr__(self):
-        return self.output_id
+    def output_index(self) -> int:
+        """Returns the output index of an OutputId.
+        """
+        return int.from_bytes(
+            bytes.fromhex(self[74:]), 'little')
+
+    @classmethod
+    def from_dict(cls, output_id_dict: dict):
+        """Init an OutputId from a dict.
+        """
+        return OutputId(output_id_dict)
+
+
+@json
+@dataclass
+class OutputWithId:
+    """An Output with its ID.
+
+    Arguments:
+        output: Output,
+        output_id: OutputId,
+    """
+    output: Output
+    output_id: OutputId
```

## iota_sdk/types/output_params.py

```diff
@@ -1,62 +1,74 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 from enum import Enum
-from typing import List, Optional
-from iota_sdk.types.common import HexStr
+from typing import Optional
+from dataclasses_json import config
+from iota_sdk.types.common import HexStr, json, opt_int_encoder
 from iota_sdk.types.native_token import NativeToken
 
 
+@json
 @dataclass
-class Assets():
+class Assets:
     """Assets for OutputParams.
     """
-    nativeTokens: Optional[List[NativeToken]] = None
-    nftId: Optional[HexStr] = None
+    nft_id: Optional[HexStr] = None
 
 
+@json
 @dataclass
-class Features():
+class Features:
     """Features for OutputParams.
     """
     tag: Optional[HexStr] = None
     metadata: Optional[HexStr] = None
     issuer: Optional[str] = None
     sender: Optional[str] = None
+    native_token: Optional[NativeToken] = None
 
 
+@json
 @dataclass
-class Unlocks():
+class Unlocks:
     """Unlocks for OutputParams.
     """
-    expirationUnixTime: Optional[int] = None
-    timelockUnixTime: Optional[int] = None
+    expiration_slot_index: Optional[int] = field(default=None, metadata=config(
+        encoder=opt_int_encoder
+    ))
+    timelock_slot_index: Optional[int] = field(default=None, metadata=config(
+        encoder=opt_int_encoder
+    ))
 
 
 class ReturnStrategy(str, Enum):
     """Return strategy for the StorageDeposit.
     """
     Return = 'Return'
     Gift = 'Gift'
 
 
+@json
 @dataclass
-class StorageDeposit():
+class StorageDeposit:
     """Storage deposit options for OutputParams.
     """
-    returnStrategy: Optional[ReturnStrategy] = None
-    useExcessIfLow: Optional[bool] = None
+    return_strategy: Optional[ReturnStrategy] = None
+    use_excess_if_low: Optional[bool] = None
 
 
+@json
 @dataclass
-class OutputParams():
-    """Params for `Account.prepare_output()`.
+class OutputParams:
+    """Params for `Wallet.prepare_output()`.
     """
-    recipientAddress: str
-    amount: str
+    recipient_address: str
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
     assets: Optional[Assets] = None
     features: Optional[Features] = None
     unlocks: Optional[Unlocks] = None
-    storageDeposit: Optional[StorageDeposit] = None
+    storage_deposit: Optional[StorageDeposit] = None
```

## iota_sdk/types/payload.py

```diff
@@ -1,167 +1,160 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass, field
 from enum import IntEnum
-from typing import Any, Optional, List, Union
-from dacite import from_dict
-from iota_sdk.types.common import HexStr
-from iota_sdk.types.output import BasicOutput, AliasOutput, FoundryOutput, NftOutput
-from iota_sdk.types.input import UtxoInput
-from iota_sdk.types.signature import Ed25519Signature
-from iota_sdk.types.unlock import SignatureUnlock, ReferenceUnlock
+from typing import Any, Dict, List, Optional, TypeAlias, Union
+from dataclasses import dataclass, field
+from dataclasses_json import config
+from iota_sdk.types.common import HexStr, json, SlotIndex
+from iota_sdk.types.mana import ManaAllotment
+from iota_sdk.types.input import UtxoInput, deserialize_inputs
+from iota_sdk.types.context_input import ContextInput, deserialize_context_inputs
+from iota_sdk.types.output import Output, deserialize_outputs
+from iota_sdk.types.unlock import Unlock, deserialize_unlocks
 
 
 class PayloadType(IntEnum):
     """Block payload types.
 
     Attributes:
-        TreasuryTransaction (4): A treasury transaction payload.
-        TaggedData (5): A tagged data payload.
-        Transaction (6): A transaction payload.
-        Milestone (7): A milestone payload.
-    """
-    TreasuryTransaction = 4
-    TaggedData = 5
-    Transaction = 6
-    Milestone = 7
-
-
-@dataclass
-class TransactionEssence:
-    """ Base essence class
+        TaggedData (0): A tagged data payload.
+        SignedTransaction (1): A signed transaction payload.
+        CandidacyAnnouncement (2): A candidacy announcement payload.
     """
-    type: int
+    TaggedData = 0
+    SignedTransaction = 1
+    CandidacyAnnouncement = 2
 
 
+@json
 @dataclass
-class RegularTransactionEssence(TransactionEssence):
-    """Describes the essence data making up a transaction by defining its inputs, outputs, and an optional payload.
+class TaggedDataPayload:
+    """A tagged data payload.
 
     Attributes:
-        networkId: The unique value denoting whether the block was meant for mainnet, shimmer, testnet, or a private network.
-        inputsCommitment: BLAKE2b-256 hash serving as a commitment to the serialized outputs referenced by Inputs.
-        inputs: The inputs to consume in order to fund the outputs of the Transaction Payload.
-        outputs: The outputs that are created by the Transaction Payload
-        payload: An optional tagged data payload
+        tag: The tag part of the tagged data payload.
+        data: The data part of the tagged data payload.
     """
-    networkId: str
-    inputsCommitment: HexStr
-    inputs: List[UtxoInput]
-    outputs: List[Union[AliasOutput, FoundryOutput, NftOutput, BasicOutput]]
-    payload: Optional[TaggedDataPayload] = None
-    type: int = field(default_factory=lambda: 1, init=False)
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
+    type: int = field(
+        default_factory=lambda: int(
+            PayloadType.TaggedData),
+        init=False)
+    tag: Optional[HexStr] = None
+    data: Optional[HexStr] = None
 
-        if 'payload' in config:
-            config['payload'] = config['payload'].as_dict()
 
-        config['inputs'] = list(map(
-            lambda x: x.__dict__, config['inputs']))
+def deserialize_payload(d: Dict[str, Any]) -> Payload:
+    """Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
 
-        config['outputs'] = list(map(
-            lambda x: x.as_dict(), config['outputs']))
+    Arguments:
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    payload_type = d['type']
+    if payload_type == PayloadType.TaggedData:
+        return TaggedDataPayload.from_dict(d)
+    if payload_type == PayloadType.SignedTransaction:
+        return SignedTransactionPayload.from_dict(d)
+    if payload_type == PayloadType.CandidacyAnnouncement:
+        return CandidacyAnnouncementPayload.from_dict(d)
+    raise Exception(f'invalid payload type: {payload_type}')
 
-        return config
 
+def deserialize_payloads(
+        dicts: List[Dict[str, Any]]) -> List[Payload]:
+    """Takes a list of dictionaries as input and returns a list with specific instances of classes based on the value of the 'type' key in the dictionary.
 
-@dataclass
-class Payload():
-    """Initialize a Payload.
+    Arguments:
+    * `dicts`: A list of dictionaries that are expected to have a key called 'type' which specifies the type of the returned value.
     """
-    type: int
+    return list(map(deserialize_payload, dicts))
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
-        if 'essence' in config:
-            config['essence'] = config['essence'].as_dict()
-        if 'unlocks' in config:
-            def convert_to_dict(c):
-                try:
-                    return c.as_dict()
-                except AttributeError:
-                    return c.__dict__
-            config['unlocks'] = list(map(convert_to_dict, config['unlocks']))
-        if 'signatures' in config:
-            config['signatures'] = list(map(
-                lambda x: x.__dict__, config['signatures']))
+def deserialize_tagged_data_payload(d: Dict[str, Any]) -> Payload:
+    """Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
 
-        return config
+    Arguments:
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    payload_type = d['type']
+    if payload_type == PayloadType.TaggedData:
+        return TaggedDataPayload.from_dict(d)
+    raise Exception(f'invalid payload type: {payload_type}')
 
 
+@json
 @dataclass
-class MilestonePayload(Payload):
-    """A milestone payload.
+class Transaction:
+    """A transaction consuming inputs, creating outputs and carrying an optional payload.
 
     Attributes:
-        index: The index of corresponding milestone.
-        timestamp: The timestamp of the corresponding milestone.
-        protocolVersion: The current protocol version.
-        previousMilestoneId: The ID of the previous milestone.
-        parents: The parents of the milestone.
-        inclusionMerkleRoot: The merkle root of all blocks included in the milestone cone.
-        appliedMerkleRoot: The merkle root of all applied transactions in the milestone cone.
-        signatures: The signatures that verify the milestone.
-        options: The milestone options (e.g. receipt milestone option).
-        metadata: Some hex encoded milestone metadata.
-    """
-    index: int
-    timestamp: int
-    protocolVersion: int
-    previousMilestoneId: HexStr
-    parents: List[HexStr]
-    inclusionMerkleRoot: HexStr
-    appliedMerkleRoot: HexStr
-    signatures: List[Ed25519Signature]
-    options: Optional[List[Any]] = None
-    metadata: Optional[HexStr] = None
-    type: int = field(
-        default_factory=lambda: int(
-            PayloadType.Milestone),
-        init=False)
-
-    @classmethod
-    def from_dict(cls, milestone_dict) -> MilestonePayload:
-        """Converts a dict to a MilestonePayload
+        network_id: The unique value denoting whether the block was meant for mainnet, shimmer, testnet, or a private network.
+                    It consists of the first 8 bytes of the BLAKE2b-256 hash of the network name.
+        creation_slot: The slot index in which the transaction was created.
+        context_inputs: The inputs that provide additional contextual information for the execution of a transaction.
+        inputs: The inputs to consume in order to fund the outputs of the Transaction Payload.
+        allotments: The allotments of Mana which which will be added upon commitment of the slot.
+        capabilities: The capability bitflags of the transaction.
+        outputs: The outputs that are created by the Transaction Payload
+        payload: An optional tagged data payload
+    """
+    network_id: str
+    creation_slot: SlotIndex
+    inputs: List[UtxoInput] = field(metadata=config(
+        decoder=deserialize_inputs
+    ))
+    outputs: List[Output] = field(metadata=config(
+        decoder=deserialize_outputs
+    ))
+    capabilities: Optional[HexStr] = None
+    context_inputs: Optional[List[ContextInput]] = field(default=None, metadata=config(
+        decoder=deserialize_context_inputs
+    ))
+    allotments: Optional[List[ManaAllotment]] = None
+    payload: Optional[Payload] = field(default=None, metadata=config(
+        decoder=deserialize_tagged_data_payload
+    ))
+
+    def with_capabilities(self, capabilities: bytes):
+        """Sets the transaction capabilities from a byte array.
+        Attributes:
+            capabilities: The transaction capabilities bitflags.
         """
-        return from_dict(MilestonePayload, milestone_dict)
+        if any(c != 0 for c in capabilities):
+            self.capabilities = '0x' + capabilities.hex()
+        else:
+            self.capabilities = None
 
 
+@json
 @dataclass
-class TaggedDataPayload(Payload):
-    """A tagged data payload.
+class SignedTransactionPayload:
+    """A signed transaction payload.
 
     Attributes:
-        tag: The tag part of the tagged data payload.
-        data: The data part of the tagged data payload.
+        transaction: The transaction.
+        unlocks: The unlocks of the transaction.
     """
-    tag: Optional[HexStr] = None
-    data: Optional[HexStr] = None
     type: int = field(
         default_factory=lambda: int(
-            PayloadType.TaggedData),
+            PayloadType.SignedTransaction),
         init=False)
+    transaction: Transaction
+    unlocks: List[Unlock] = field(metadata=config(
+        decoder=deserialize_unlocks
+    ))
 
 
+@json
 @dataclass
-class TransactionPayload(Payload):
-    """A transaction payload.
-
-    Attributes:
-        essence: The transaction essence.
-        unlocks: The unlocks of the transaction.
+class CandidacyAnnouncementPayload:
+    """A payload which is used to indicate candidacy for committee selection for the next epoch.
     """
-    essence: RegularTransactionEssence
-    unlocks: List[Union[SignatureUnlock, ReferenceUnlock]]
     type: int = field(
         default_factory=lambda: int(
-            PayloadType.Transaction),
+            PayloadType.CandidacyAnnouncement),
         init=False)
+
+
+Payload: TypeAlias = Union[TaggedDataPayload,
+                           SignedTransactionPayload, CandidacyAnnouncementPayload]
```

## iota_sdk/types/send_params.py

```diff
@@ -1,130 +1,173 @@
-# Copyright 2023 IOTA Stiftung
+# Copyright 2024 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
-from typing import Optional, List
-from iota_sdk.types.common import HexStr
+from dataclasses import dataclass, field
+from typing import Optional
+from dataclasses_json import config
+from iota_sdk.types.address import AccountAddress
+from iota_sdk.types.common import hex_str_decoder, HexStr, json
+from iota_sdk.types.feature import MetadataFeature
 from iota_sdk.types.native_token import NativeToken
+from iota_sdk.types.output_params import ReturnStrategy
 
 
+@json
 @dataclass
-class SendParams():
+class SendParams:
     """Parameters for sending base coins.
 
     Attributes:
         address: The address to send to.
         amount: The amount to send.
-        returnAddress: The address to return the funds to if not claimed.
+        return_address: The address to return the funds to if not claimed.
         expiration: Expiration in seconds, after which the output will be available for the sender again, if not spent by the
         receiver already. The expiration will only be used if one is necessary given the provided amount. If an
         expiration is needed but not provided, it will default to one day.
     """
     address: str
-    amount: str
-    returnAddress: Optional[str] = None
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    return_address: Optional[str] = None
     expiration: Optional[int] = None
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        config['amount'] = str(config['amount'])
-
-        return config
-
 
+@json
 @dataclass
-class SendNativeTokensParams():
-    """Parameters for sending native tokens
+class SendNativeTokenParams:
+    """Parameters for sending a native token
 
     Attributes:
         address: The address to send to.
-        nativeTokens: The native tokens to send.
-        returnAddress: The address to return the native tokens to if not claimed.
-        expiration: The expiration timestamp until native tokens can be claimed.
+        native_token: The native token to send.
+        return_address: The address to return the native token to if not claimed.
+        expiration: The expiration timestamp until the native token can be claimed.
     """
     address: str
-    nativeTokens: List[NativeToken]
-    returnAddress: Optional[str] = None
+    native_token: NativeToken
+    return_address: Optional[str] = None
     expiration: Optional[int] = None
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        return {k: v for k, v in self.__dict__.items() if v is not None}
-
 
+@json
 @dataclass
-class SendNftParams():
+class SendNftParams:
     """Parameters for sending NFTs.
 
     Attributes:
         address: The address to send the NFT to.
-        nftId: The ID of the NFT to send.
+        nft_id: The ID of the NFT to send.
     """
     address: str
-    nftId: HexStr
+    nft_id: HexStr
 
 
+@json
 @dataclass
-class CreateNativeTokenParams():
+class CreateNativeTokenParams:
     """Parameters for creating native tokens.
 
     Attributes:
-        circulatingSupply: The circulating supply of the native token.
-        maximumSupply: The maximum supply of the native token.
-        foundryMetadata: The foundry metadata of the native token.
-        aliasId: The ID of the corresponding alias.
-    """
-    circulatingSupply: int
-    maximumSupply: int
-    foundryMetadata: Optional[str] = None
-    aliasId: Optional[str] = None
+        circulating_supply: The circulating supply of the native token.
+        maximum_supply: The maximum supply of the native token.
+        foundry_metadata: The foundry metadata of the native token.
+        account_id: The ID of the corresponding account.
+    """
+    circulating_supply: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
+    maximum_supply: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
+    foundry_metadata: Optional[MetadataFeature] = None
+    account_id: Optional[str] = None
+
+
+@json
+@dataclass
+class CreateDelegationParams:
+    """Parameters for creating a delegation output.
+
+    Attributes:
+        delegated_amount: The amount to delegate.
+        validator_address: The Account Address of the validator to which this output will delegate.
+        address: Bech32 encoded address which will control the delegation. By default, the ed25519 wallet address will be used.
+    """
+    delegated_amount: int = field(metadata=config(
+        encoder=str
+    ))
+    validator_address: AccountAddress
+    address: Optional[str] = None
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
-        config['circulatingSupply'] = hex(config['circulatingSupply'])
-        config['maximumSupply'] = hex(config['maximumSupply'])
+@json
+@dataclass
+class BeginStakingParams:
+    """Parameters for beginning staking.
 
-        return config
+    Attributes:
+        account_id: The account id which will become a validator.
+        staked_amount: The amount of tokens to stake.
+        fixed_cost: The fixed cost of the validator, which it receives as part of its Mana rewards.
+        staking_period: The staking period (in epochs). Will default to the staking unbonding period.
+    """
+    account_id: HexStr
+    staked_amount: int
+    fixed_cost: int
+    staking_period: Optional[int] = None
 
 
+@json
 @dataclass
-class MintNftParams():
+class MintNftParams:
     """Parameters for minting NFTs.
 
     Attributes:
-        address: A Bech32 encoded address to which the NFT will be minted. Default will use the first address of the account.
+        address: A Bech32 encoded address to which the NFT will be minted. Default will use the address of the wallet.
         sender: An NFT sender feature.
         metadata: An NFT metadata feature.
         tag: An NFT tag feature.
         issuer: An NFT issuer feature.
-        immutableMetadata: An NFT immutable metadata feature.
+        immutable_metadata: An NFT immutable metadata feature.
     """
     address: Optional[str] = None
     sender: Optional[str] = None
-    metadata: Optional[str] = None
+    metadata: Optional[MetadataFeature] = None
     tag: Optional[str] = None
     issuer: Optional[str] = None
-    immutableMetadata: Optional[str] = None
+    immutable_metadata: Optional[MetadataFeature] = None
+
+
+@json
+@dataclass
+class CreateAccountOutputParams:
+    """Parameters for creating accounts.
+
+    Attributes:
+        address: A Bech32 encoded address which will control the account. Default will use the address of the wallet.
+        immutable_metadata: Immutable account metadata.
+        metadata: Account metadata.
+    """
+    address: str
+    immutable_metadata: Optional[MetadataFeature] = None
+    metadata: Optional[MetadataFeature] = None
 
 
+@json
 @dataclass
-class CreateAliasOutputParams():
-    """Parameters for creating aliases.
+class SendManaParams:
+    """Parameters for sending mana.
 
     Attributes:
-        address: A Bech32 encoded address which will control the alias. Default will use the first address of the account.
-        immutableMetadata: Immutable alias metadata.
-        metadata: Alias metadata.
-        stateMetadata: Alias state metadata.
+        mana: Amount of mana to send, e.g. 1000000.
+        address: Recipient address, e.g. rms1qztwng6cty8cfm42nzvq099ev7udhrnk0rw8jt8vttf9kpqnxhpsx869vr3.
+        return_strategy: Whether to gift the storage deposit or not.
     """
+    mana: int = field(metadata=config(
+        encoder=str
+    ))
     address: str
-    immutableMetadata: Optional[str] = None
-    metadata: Optional[str] = None
-    stateMetadata: Optional[str] = None
+    return_strategy: Optional[ReturnStrategy] = None
```

## iota_sdk/types/signature.py

```diff
@@ -1,42 +1,41 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
+from typing import TypeAlias
 from dataclasses import dataclass, field
-from iota_sdk.types.common import HexStr, CoinType
+from iota_sdk.types.common import HexStr, CoinType, json
 
 
+@json
 @dataclass
-class Signature():
-    """Base class of a signature.
-    """
-    type: int
-
-
-@dataclass
-class Ed25519Signature(Signature):
+class Ed25519Signature:
     """An Ed25519 signature.
 
     Attributes:
-        publicKey: The Ed25519 public key.
+        public_key: The Ed25519 public key.
         signature: The Ed25519 signature of some message.
         type: The Ed25519 signature type.
     """
-    publicKey: HexStr
+    type: int = field(default=0, init=False)
+    public_key: HexStr
     signature: HexStr
-    type: int = field(default_factory=lambda: 0, init=False)
 
 
+Signature: TypeAlias = Ed25519Signature
+
+
+@json
 @dataclass
-class Bip44():
+class Bip44:
     """A BIP44 chain.
 
     Attributes:
-        coinType: The coin type segment.
+        coin_type: The coin type segment.
         account: The account segment.
         change: The change segment.
-        addressIndex: The address index segment.
+        address_index: The address index segment.
     """
-    coinType: int = CoinType.IOTA
+    coin_type: int = CoinType.IOTA
     account: int = 0
     change: int = 0
-    addressIndex: int = 0
+    address_index: int = 0
```

## iota_sdk/types/token_scheme.py

```diff
@@ -1,42 +1,36 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
+from typing import TypeAlias
 from dataclasses import dataclass, field
-from iota_sdk.types.common import HexStr
+from dataclasses_json import config
+from iota_sdk.types.common import hex_str_decoder, json
 
 
+@json
 @dataclass
-class TokenScheme():
-    """Base class of a token scheme.
-    """
-    type: int
-
-
-@dataclass
-class SimpleTokenScheme(TokenScheme):
+class SimpleTokenScheme:
     """A simple token scheme.
 
     Attributes:
-        mintedTokens: The number of tokens that were minted.
-        meltedTokens: The number of tokens that were melted.
-        maximumSupply: The maximum supply of the token.
+        minted_tokens: The number of tokens that were minted.
+        melted_tokens: The number of tokens that were melted.
+        maximum_supply: The maximum supply of the token.
         type: The type code of the token scheme.
     """
-    mintedTokens: HexStr
-    meltedTokens: HexStr
-    maximumSupply: HexStr
-    type: int = field(default_factory=lambda: 0, init=False)
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = dict(self.__dict__)
-
-        if isinstance(config['mintedTokens'], int):
-            config['mintedTokens'] = str(hex(config['mintedTokens']))
-        if isinstance(config['meltedTokens'], int):
-            config['meltedTokens'] = str(hex(config['meltedTokens']))
-        if isinstance(config['maximumSupply'], int):
-            config['maximumSupply'] = str(hex(config['maximumSupply']))
+    type: int = field(default=0, init=False)
+    minted_tokens: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
+    melted_tokens: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
+    maximum_supply: int = field(metadata=config(
+        encoder=hex,
+        decoder=hex_str_decoder,
+    ))
+
 
-        return config
+TokenScheme: TypeAlias = SimpleTokenScheme
```

## iota_sdk/types/transaction_data.py

```diff
@@ -1,115 +1,79 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass, asdict
-from typing import Optional, List, Union
-from iota_sdk.types.address import Ed25519Address, AliasAddress, NFTAddress
-from iota_sdk.types.output import BasicOutput, AliasOutput, FoundryOutput, NftOutput, OutputMetadata
-from iota_sdk.types.payload import RegularTransactionEssence, TransactionPayload
+from dataclasses import dataclass
+from typing import Optional, List
+from iota_sdk.types.output_id import OutputId
+from iota_sdk.types.address import Address
+from iota_sdk.types.output import Output
+from iota_sdk.types.output_metadata import OutputMetadata
+from iota_sdk.types.payload import Transaction, SignedTransactionPayload
 from iota_sdk.types.signature import Bip44
+from iota_sdk.types.common import json, HexStr
 
 
+@json
 @dataclass
 class InputSigningData:
     """Data for transaction inputs for signing and ordering of unlock blocks.
 
     Attributes:
         output: The output.
-        outputMetadata: The output metadata.
+        output_metadata: The output metadata.
         chain: The BIP44 chain for the address to unlock the output.
     """
-    output: Union[AliasOutput, FoundryOutput, NftOutput, BasicOutput]
-    outputMetadata: OutputMetadata
+    output: Output
+    output_metadata: OutputMetadata
     chain: Optional[Bip44] = None
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        config['output'] = config['output'].as_dict()
-        config['outputMetadata'] = config['outputMetadata'].as_dict()
-        if 'chain' in config:
-            config['chain'] = asdict(config['chain'])
-
-        return config
-
 
+@json
 @dataclass
 class RemainderData:
     """Data for a remainder output, used for ledger nano.
 
     Attributes:
         output: The output.
         address: The remainder address.
         chain: The BIP44 chain for the remainder address.
     """
-    output: Union[AliasOutput, FoundryOutput, NftOutput, BasicOutput]
-    address: Union[Ed25519Address, AliasAddress, NFTAddress]
+    output: Output
+    address: Address
     chain: Optional[Bip44] = None
 
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        config['output'] = config['output'].as_dict()
-        config['address'] = config['address'].as_dict()
-        if 'chain' in config:
-            config['chain'] = asdict(config['chain'])
-
-        return config
-
 
+@json
 @dataclass
 class PreparedTransactionData:
     """Helper class for offline signing.
 
     Attributes:
-        essence: The transaction essence.
-        inputsData: Data about the inputs which is required for signing.
-        remainder: Data about a remainder.
+        transaction: The transaction.
+        inputs_data: Data about the inputs which is required for signing.
+        remainders: Data about remainder outputs.
+        mana_rewards: Mana rewards by input.
+        issuer_id: The block issuer id from which the BIC for the block containing this transaction should be burned.
     """
-    essence: RegularTransactionEssence
-    inputsData: List[InputSigningData]
-    remainder: Optional[RemainderData] = None
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        config['essence'] = config['essence'].as_dict()
-
-        config['inputsData'] = list(map(
-            lambda x: x.as_dict(), config['inputsData']))
-
-        if 'remainder' in config:
-            config['remainder'] = config['remainder'].as_dict()
-
-        return config
+    transaction: Transaction
+    inputs_data: List[InputSigningData]
+    remainders: Optional[List[RemainderData]] = None
+    mana_rewards: Optional[dict[OutputId, int]] = None
+    issuer_id: Optional[HexStr] = None
 
 
+@json
 @dataclass
 class SignedTransactionData:
     """Helper class for offline signing.
 
     Attributes:
-        transactionPayload: The transaction payload.
-        inputsData: Data about the inputs consumed in the transaction.
+        payload: The transaction payload.
+        inputs_data: Data about the inputs consumed in the transaction.
+        mana_rewards: Mana rewards by input.
+        issuer_id: The block issuer id from which the BIC for the block containing this transaction should be burned.
     """
-    transactionPayload: TransactionPayload
-    inputsData: List[InputSigningData]
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        config['transactionPayload'] = config['transactionPayload'].as_dict()
-
-        config['inputsData'] = list(map(
-            lambda x: x.as_dict(), config['inputsData']))
-
-        return config
+    payload: SignedTransactionPayload
+    inputs_data: List[InputSigningData]
+    mana_rewards: Optional[dict[OutputId, int]] = None
+    issuer_id: Optional[HexStr] = None
```

## iota_sdk/types/transaction_options.py

```diff
@@ -1,91 +1,68 @@
-# Copyright 2023 IOTA Stiftung
+# Copyright 2024 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from enum import Enum
 from typing import Optional, List, Union
+from dataclasses import dataclass, field
+from iota_sdk.types.address import Address
 from iota_sdk.types.burn import Burn
+from iota_sdk.types.common import HexStr, json
 from iota_sdk.types.output_id import OutputId
 from iota_sdk.types.payload import TaggedDataPayload
 
 
+@json
+@dataclass
 class RemainderValueStrategyCustomAddress:
     """Remainder value strategy for custom addresses.
 
     Attributes:
-        address: An address to move the remainder value to.
-        key_index: The address key index.
-        internal: Determines if an address is a public or an internal (change) address.
-        used: Indicates whether an address has been used already.
+        value: An address to move the remainder value to.
     """
-
-    def __init__(self,
-                 address: str,
-                 key_index: int,
-                 internal: bool,
-                 used: bool):
-        self.address = address
-        self.keyIndex = key_index
-        self.internal = internal
-        self.used = used
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        return dict({"strategy": "CustomAddress", "value": self.__dict__})
+    strategy: str = field(default_factory=lambda: 'CustomAddress', init=False)
+    value: Address
 
 
 class RemainderValueStrategy(Enum):
     """Remainder value strategy variants.
 
     Attributes:
-        ChangeAddress: Allows to move the remainder value to a change address.
         ReuseAddress: Allows to keep the remainder value on the source address.
     """
-    ChangeAddress = None
     ReuseAddress = None
 
-    def as_dict(self):
-        """Converts this object to a dict.
+    def to_dict(self) -> dict:
+        """Custom dict conversion.
         """
-        return dict({"strategy": self.name, "value": self.value[0]})
 
+        return {
+            'strategy': self.name,
+        }
 
-class TransactionOptions():
+
+@json
+@dataclass
+class TransactionOptions:
     """Transaction options.
 
     Attributes:
         remainder_value_strategy: The strategy applied for base coin remainders.
         tagged_data_payload: An optional tagged data payload.
-        custom_inputs: If custom inputs are provided only those are used. If also other additional inputs should be used, `mandatory_inputs` should be used instead.
-        mandatory_inputs: Inputs that must be used for the transaction.
-        burn: Specifies what needs to be burned during input selection.
+        required_inputs: Inputs that must be used for the transaction.
+        burn: Specifies what needs to be burned in the transaction.
         note: A string attached to the transaction.
         allow_micro_amount: Whether to allow sending a micro amount.
+        allow_additional_input_selection: Whether to allow the selection of additional inputs for this transaction.
+        mana_allotments: Mana allotments for the transaction.
+        issuer_id: Optional block issuer to which the transaction will have required mana allotted.
     """
-
-    def __init__(self, remainder_value_strategy: Optional[Union[RemainderValueStrategy, RemainderValueStrategyCustomAddress]] = None,
-                 tagged_data_payload: Optional[TaggedDataPayload] = None,
-                 custom_inputs: Optional[List[OutputId]] = None,
-                 mandatory_inputs: Optional[List[OutputId]] = None,
-                 burn: Optional[Burn] = None,
-                 note: Optional[str] = None,
-                 allow_micro_amount: Optional[bool] = None):
-        """Initialize transaction options.
-        """
-        self.remainder_value_strategy = remainder_value_strategy
-        self.tagged_data_payload = tagged_data_payload
-        self.custom_inputs = custom_inputs
-        self.mandatory_inputs = mandatory_inputs
-        self.burn = burn
-        self.note = note
-        self.allow_micro_amount = allow_micro_amount
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        if 'remainder_value_strategy' in config:
-            config['remainder_value_strategy'] = config['remainder_value_strategy'].as_dict()
-
-        return config
+    remainder_value_strategy: Optional[Union[RemainderValueStrategy,
+                                             RemainderValueStrategyCustomAddress]] = None
+    tagged_data_payload: Optional[TaggedDataPayload] = None
+    required_inputs: Optional[List[OutputId]] = None
+    burn: Optional[Burn] = None
+    note: Optional[str] = None
+    allow_micro_amount: Optional[bool] = None
+    allow_additional_input_selection: Optional[bool] = None
+    mana_allotments: Optional[dict[HexStr, int]] = None
+    issuer_id: Optional[HexStr] = None
```

## iota_sdk/types/unlock.py

```diff
@@ -1,80 +1,169 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
 from dataclasses import dataclass, field
 from enum import IntEnum
+from typing import Dict, List, TypeAlias, Union, Any
+from dataclasses_json import config
 from iota_sdk.types.signature import Ed25519Signature
+from iota_sdk.types.common import json
 
 
 class UnlockType(IntEnum):
     """Unlock variants.
 
     Attributes:
         Signature (0): An unlock holding a signature unlocking one or more inputs.
         Reference (1): An unlock which must reference a previous unlock which unlocks also the input at the same index as this Reference Unlock.
-        Alias (2): An unlock which must reference a previous unlock which unlocks the alias that the input is locked to.
-        Nft (3): An unlock which must reference a previous unlock which unlocks the NFT that the input is locked to.
+        Account (2): An unlock which must reference a previous unlock which unlocks the account that the input is locked to.
+        Anchor (3): An unlock which must reference a previous unlock which unlocks the anchor that the input is locked to.
+        Nft (4): An unlock which must reference a previous unlock which unlocks the NFT that the input is locked to.
+        Multi (5): Unlocks a MultiAddress with a list of other unlocks.
+        Empty (6): Used to maintain correct index relationship between addresses and signatures when unlocking a MultiUnlock where not all addresses are unlocked.
+
     """
     Signature = 0
     Reference = 1
-    Alias = 2
-    Nft = 3
+    Account = 2
+    Anchor = 3
+    Nft = 4
+    Multi = 5
+    Empty = 6
 
 
+@json
 @dataclass
-class Unlock:
-    """Unlock type.
-    """
-    type: int
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        if 'signature' in config:
-            config['signature'] = config['signature'].__dict__
-
-        return config
-
-
-@dataclass
-class SignatureUnlock(Unlock):
+class SignatureUnlock:
     """An unlock holding a signature unlocking one or more inputs.
     """
-    signature: Ed25519Signature
     type: int = field(
         default_factory=lambda: int(
             UnlockType.Signature),
         init=False)
+    signature: Ed25519Signature
 
 
+@json
 @dataclass
-class ReferenceUnlock(Unlock):
+class ReferenceUnlock:
     """An unlock which must reference a previous unlock which unlocks also the input at the same index as this Reference Unlock.
     """
-    reference: int
     type: int = field(
         default_factory=lambda: int(
             UnlockType.Reference),
         init=False)
+    reference: int
 
 
+@json
 @dataclass
-class AliasUnlock:
-    """An unlock which must reference a previous unlock which unlocks the alias that the input is locked to.
+class AccountUnlock:
+    """An unlock which must reference a previous unlock which unlocks the account that the input is locked to.
     """
+    type: int = field(
+        default_factory=lambda: int(
+            UnlockType.Account),
+        init=False)
     reference: int
+
+
+@json
+@dataclass
+class AnchorUnlock:
+    """An unlock which must reference a previous unlock which unlocks the anchor that the input is locked to.
+    """
     type: int = field(
         default_factory=lambda: int(
-            UnlockType.Alias),
+            UnlockType.Anchor),
         init=False)
+    reference: int
 
 
+@json
 @dataclass
 class NftUnlock:
     """An unlock which must reference a previous unlock which unlocks the NFT that the input is locked to.
     """
-    reference: int
     type: int = field(default_factory=lambda: int(UnlockType.Nft), init=False)
+    reference: int
+
+
+# pylint: disable=missing-function-docstring,unused-argument
+def deserialize_unlocks(dicts: List[Dict[str, Any]]) -> List[Unlock]:
+    # Function gets overwritten further below, but needs to be defined here
+    # already
+    pass
+
+
+@json
+@dataclass
+class MultiUnlock:
+    """Unlocks a MultiAddress with a list of other unlocks.
+    """
+    type: int = field(
+        default_factory=lambda: int(
+            UnlockType.Multi),
+        init=False)
+    unlocks: List[Unlock] = field(metadata=config(
+        decoder=deserialize_unlocks
+    ))
+
+
+@json
+@dataclass
+class EmptyUnlock:
+    """Used to maintain correct index relationship between addresses and signatures when unlocking a MultiUnlock where not all addresses are unlocked.
+    """
+    type: int = field(
+        default_factory=lambda: int(
+            UnlockType.Empty),
+        init=False)
+
+
+Unlock: TypeAlias = Union[SignatureUnlock,
+                          ReferenceUnlock,
+                          AccountUnlock,
+                          AnchorUnlock,
+                          NftUnlock,
+                          MultiUnlock,
+                          EmptyUnlock]
+
+# pylint: disable=too-many-return-statements
+
+
+def deserialize_unlock(d: Dict[str, Any]) -> Unlock:
+    """
+    Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    unlock_type = d['type']
+    if unlock_type == UnlockType.Signature:
+        return SignatureUnlock.from_dict(d)
+    if unlock_type == UnlockType.Reference:
+        return ReferenceUnlock.from_dict(d)
+    if unlock_type == UnlockType.Account:
+        return AccountUnlock.from_dict(d)
+    if unlock_type == UnlockType.Anchor:
+        return AnchorUnlock.from_dict(d)
+    if unlock_type == UnlockType.Nft:
+        return NftUnlock.from_dict(d)
+    if unlock_type == UnlockType.Multi:
+        return MultiUnlock.from_dict(d)
+    if unlock_type == UnlockType.Empty:
+        return EmptyUnlock.from_dict(d)
+    raise Exception(f'invalid unlock type: {unlock_type}')
+
+# pylint: disable=function-redefined
+
+
+def deserialize_unlocks(dicts: List[Dict[str, Any]]) -> List[Unlock]:
+    """
+    Takes a list of dictionaries as input and returns a list with specific instances of classes based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `dicts`: A list of dictionaries that are expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    return list(map(deserialize_unlock, dicts))
```

## iota_sdk/types/unlock_condition.py

```diff
@@ -1,140 +1,185 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from enum import IntEnum
 from dataclasses import dataclass, field
-from typing import Union
-from iota_sdk.types.address import Ed25519Address, AliasAddress, NFTAddress
+from typing import Dict, List, TypeAlias, Union, Any
+from dataclasses_json import config
+from iota_sdk.types.address import Address, AccountAddress
+from iota_sdk.types.common import json, SlotIndex
+from iota_sdk.types.address import deserialize_address
 
 
 class UnlockConditionType(IntEnum):
     """Unlock condition variants.
 
     Attributes:
         Address (0): An address unlock condition.
         StorageDepositReturn (1): A storage deposit return unlock condition.
         Timelock (2): A timelock unlock condition.
         Expiration (3): An expiration unlock condition.
         StateControllerAddress (4): A state controller address unlock condition.
         GovernorAddress (5): A governor address unlock condition.
-        ImmutableAliasAddress (6): An immutable alias address unlock condition.
+        ImmutableAccountAddress (6): An immutable account address unlock condition.
     """
     Address = 0
     StorageDepositReturn = 1
     Timelock = 2
     Expiration = 3
     StateControllerAddress = 4
     GovernorAddress = 5
-    ImmutableAliasAddress = 6
+    ImmutableAccountAddress = 6
 
 
+@json
 @dataclass
-class UnlockCondition():
-    """Base class for unlock conditions.
-    """
-    type: int
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        config = {k: v for k, v in self.__dict__.items() if v is not None}
-
-        if 'amount' in config:
-            if isinstance(config['amount'], int):
-                config['amount'] = str(config['amount'])
-
-        if 'address' in config:
-            config['address'] = config['address'].as_dict()
-
-        if 'returnAddress' in config:
-            config['returnAddress'] = config['returnAddress'].as_dict()
-
-        return config
-
-
-@dataclass
-class AddressUnlockCondition(UnlockCondition):
+class AddressUnlockCondition:
     """An address unlock condition.
 
     Args:
         address: An address unlocked with a private key.
     """
-    address: Union[Ed25519Address, AliasAddress, NFTAddress]
     type: int = field(
         default_factory=lambda: int(
             UnlockConditionType.Address),
         init=False)
+    address: Address = field(
+        metadata=config(
+            decoder=deserialize_address
+        ))
 
 
+@json
 @dataclass
-class StorageDepositReturnUnlockCondition(UnlockCondition):
+class StorageDepositReturnUnlockCondition:
     """A storage-deposit-return unlock condition.
     Args:
         amount: The amount of base coins the consuming transaction must deposit to `return_address`.
         return_address: The address to return the amount to.
     """
-    amount: str
-    returnAddress: Union[Ed25519Address, AliasAddress, NFTAddress]
     type: int = field(default_factory=lambda: int(
         UnlockConditionType.StorageDepositReturn), init=False)
+    amount: int = field(metadata=config(
+        encoder=str
+    ))
+    return_address: Address = field(
+        metadata=config(
+            decoder=deserialize_address
+        ))
 
 
+@json
 @dataclass
-class TimelockUnlockCondition(UnlockCondition):
-    """A timelock unlock condition.
+class TimelockUnlockCondition:
+    """Defines a slot index until which the output can not be unlocked.
     Args:
-        unix_time: The Unix timestamp marking the end of the timelock.
+        slot_index: Slot index that defines when the output can be consumed.
     """
-    unixTime: int
     type: int = field(
         default_factory=lambda: int(
             UnlockConditionType.Timelock),
         init=False)
+    slot_index: SlotIndex
 
 
+@json
 @dataclass
-class ExpirationUnlockCondition(UnlockCondition):
-    """An expiration unlock condition.
+class ExpirationUnlockCondition:
+    """Defines a slot index until which only the Address defined in the Address Unlock Condition is allowed to unlock the output. After the slot index is reached/passed, only the Return Address can unlock it.
     Args:
-        unix_time: Unix timestamp marking the expiration of the claim.
+        slot_index: Before this slot index, Address Unlock Condition is allowed to unlock the output,
+                    after that only the address defined in Return Address.
         return_address: The return address if the output was not claimed in time.
     """
-    unixTime: int
-    returnAddress: Union[Ed25519Address, AliasAddress, NFTAddress]
     type: int = field(
         default_factory=lambda: int(
             UnlockConditionType.Expiration),
         init=False)
+    slot_index: SlotIndex
+    return_address: Address = field(
+        metadata=config(
+            decoder=deserialize_address
+        ))
 
 
+@json
 @dataclass
-class StateControllerAddressUnlockCondition(UnlockCondition):
+class StateControllerAddressUnlockCondition:
     """A state controller address unlock condition.
     Args:
         address: The state controller address that owns the output.
     """
-    address: Union[Ed25519Address, AliasAddress, NFTAddress]
     type: int = field(default_factory=lambda: int(
         UnlockConditionType.StateControllerAddress), init=False)
+    address: Address = field(
+        metadata=config(
+            decoder=deserialize_address
+        ))
 
 
+@json
 @dataclass
-class GovernorAddressUnlockCondition(UnlockCondition):
+class GovernorAddressUnlockCondition:
     """A governor address unlock condition.
     Args:
         address: The governor address that owns the output.
     """
-    address: Union[Ed25519Address, AliasAddress, NFTAddress]
     type: int = field(default_factory=lambda: int(
         UnlockConditionType.GovernorAddress), init=False)
+    address: Address = field(
+        metadata=config(
+            decoder=deserialize_address
+        ))
 
 
+@json
 @dataclass
-class ImmutableAliasAddressUnlockCondition(UnlockCondition):
-    """An immutable alias address unlock condition.
+class ImmutableAccountAddressUnlockCondition:
+    """An immutable account address unlock condition.
     Args:
-        address: The permanent alias address that owns this output.
+        address: The permanent account address that owns this output.
     """
-    address: AliasAddress
     type: int = field(default_factory=lambda: int(
-        UnlockConditionType.ImmutableAliasAddress), init=False)
+        UnlockConditionType.ImmutableAccountAddress), init=False)
+    address: AccountAddress
+
+
+UnlockCondition: TypeAlias = Union[AddressUnlockCondition, StorageDepositReturnUnlockCondition, TimelockUnlockCondition,
+                                   ExpirationUnlockCondition, StateControllerAddressUnlockCondition, GovernorAddressUnlockCondition, ImmutableAccountAddressUnlockCondition]
+
+
+def deserialize_unlock_condition(d: Dict[str, Any]) -> UnlockCondition:
+    """
+    Takes a dictionary as input and returns an instance of a specific class based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `d`: A dictionary that is expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    # pylint: disable=too-many-return-statements
+    uc_type = d['type']
+    if uc_type == UnlockConditionType.Address:
+        return AddressUnlockCondition.from_dict(d)
+    if uc_type == UnlockConditionType.StorageDepositReturn:
+        return StorageDepositReturnUnlockCondition.from_dict(d)
+    if uc_type == UnlockConditionType.Timelock:
+        return TimelockUnlockCondition.from_dict(d)
+    if uc_type == UnlockConditionType.Expiration:
+        return ExpirationUnlockCondition.from_dict(d)
+    if uc_type == UnlockConditionType.StateControllerAddress:
+        return StateControllerAddressUnlockCondition.from_dict(d)
+    if uc_type == UnlockConditionType.GovernorAddress:
+        return GovernorAddressUnlockCondition.from_dict(d)
+    if uc_type == UnlockConditionType.ImmutableAccountAddress:
+        return ImmutableAccountAddressUnlockCondition.from_dict(d)
+    raise Exception(f'invalid unlock condition type: {uc_type}')
+
+
+def deserialize_unlock_conditions(
+        dicts: List[Dict[str, Any]]) -> List[UnlockCondition]:
+    """
+    Takes a list of dictionaries as input and returns a list with specific instances of classes based on the value of the 'type' key in the dictionary.
+
+    Arguments:
+    * `dicts`: A list of dictionaries that are expected to have a key called 'type' which specifies the type of the returned value.
+    """
+    return list(map(deserialize_unlock_condition, dicts))
```

## iota_sdk/utils.py

```diff
@@ -1,97 +1,66 @@
-# Copyright 2023 IOTA Stiftung
+# Copyright 2024 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from json import dumps, loads
-from typing import TYPE_CHECKING, List
-from dacite import from_dict
-
+import json
+from typing import TYPE_CHECKING, List, Optional
+from iota_sdk.common import custom_encoder
+from iota_sdk.types.block.id import BlockId
 from iota_sdk.types.signature import Ed25519Signature
-from iota_sdk.types.address import Address, AddressType, Ed25519Address, AliasAddress, NFTAddress
+from iota_sdk.types.address import Address, Ed25519Address, deserialize_address
 from iota_sdk.types.common import HexStr
-from iota_sdk.types.output_id import OutputId
+from iota_sdk.types.decayed_mana import DecayedMana
+from iota_sdk.types.payload import Transaction, SignedTransactionPayload
+from iota_sdk.types.node_info import ProtocolParameters, WorkScoreParameters
 from iota_sdk.types.output import Output
+from iota_sdk.types.output_id import OutputId
+from iota_sdk.types.unlock import Unlock
 from iota_sdk.types.transaction_data import InputSigningData
+from iota_sdk.types.transaction_id import TransactionId
 from iota_sdk.external import call_utils_method
-from iota_sdk.types.node_info import NodeInfoProtocol
-from iota_sdk.types.payload import TransactionPayload
 
 # Required to prevent circular import
 if TYPE_CHECKING:
-    from iota_sdk.types.block import Block
+    from iota_sdk.types.block.block import Block
 
+# pylint: disable=too-many-public-methods
 
-class Utils():
+
+class Utils:
     """Utility functions.
     """
-
     @staticmethod
-    def bech32_to_hex(bech32: str) -> HexStr:
-        """Convert a Bech32 string to a hex string.
+    def address_to_bech32(address: Address, bech32_hrp: str) -> str:
+        """Convert an address to its bech32 representation.
         """
-        return _call_method('bech32ToHex', {
-            'bech32': bech32
-        })
-
-    # pylint: disable=redefined-builtin
-    @staticmethod
-    def hex_to_bech32(hex: HexStr, bech32_hrp: str) -> str:
-        """Convert a hex encoded address to a Bech32 encoded address.
-        """
-        return _call_method('hexToBech32', {
-            'hex': hex,
-            'bech32Hrp': bech32_hrp
-        })
-
-    @staticmethod
-    def alias_id_to_bech32(alias_id: HexStr, bech32_hrp: str) -> str:
-        """Convert an alias id to a Bech32 encoded address.
-        """
-        return _call_method('aliasIdToBech32', {
-            'aliasId': alias_id,
-            'bech32Hrp': bech32_hrp
-        })
-
-    @staticmethod
-    def nft_id_to_bech32(nft_id: HexStr, bech32_hrp: str) -> str:
-        """Convert an NFT ID to a Bech32 encoded address.
-        """
-        return _call_method('nftIdToBech32', {
-            'nftId': nft_id,
+        return _call_method('addressToBech32', {
+            'address': address,
             'bech32Hrp': bech32_hrp
         })
 
     # pylint: disable=redefined-builtin
     @staticmethod
-    def hex_public_key_to_bech32_address(hex: HexStr, bech32_hrp: str) -> str:
-        """Convert a hex encoded public key to a Bech32 encoded address.
+    def public_key_hash(
+            hex_str: HexStr) -> Ed25519Address:
+        """Hashes a hex encoded public key with Blake2b256.
         """
-        return _call_method('hexPublicKeyToBech32Address', {
-            'hex': hex,
-            'bech32Hrp': bech32_hrp
-        })
+        return Ed25519Address(_call_method('blake2b256Hash', {
+            'bytes': hex_str,
+        }))
 
     @staticmethod
     def parse_bech32_address(address: str) -> Address:
         """Parse a string into a valid address.
         """
         response = _call_method('parseBech32Address', {
             'address': address
         })
 
-        address_type = AddressType(response['type'])
-
-        if address_type == AddressType.ED25519:
-            return from_dict(Ed25519Address, response)
-        if address_type == AddressType.ALIAS:
-            return from_dict(AliasAddress, response)
-        if address_type == AddressType.NFT:
-            return from_dict(NFTAddress, response)
-        return from_dict(Address, response)
+        return deserialize_address(response)
 
     @staticmethod
     def is_address_valid(address: str) -> bool:
         """Check whether a string is a valid Bech32 encoded address.
         """
         return _call_method('isAddressValid', {
             'address': address
@@ -108,108 +77,118 @@
         """Convert a mnemonic to a hex encoded seed.
         """
         return _call_method('mnemonicToHexSeed', {
             'mnemonic': mnemonic
         })
 
     @staticmethod
-    def compute_alias_id(output_id: OutputId) -> HexStr:
-        """Compute the alias id for the given alias output id.
+    def compute_account_id(output_id: OutputId) -> HexStr:
+        """Compute the account id for the given account output id.
+        """
+        return _call_method('blake2b256Hash', {
+            'bytes': output_id
+        })
+
+    @staticmethod
+    def compute_delegation_id(output_id: OutputId) -> HexStr:
+        """Compute the delegation id for the given account output id.
         """
-        return _call_method('computeAliasId', {
-            'outputId': repr(output_id)
+        return _call_method('blake2b256Hash', {
+            'bytes': output_id
         })
 
     @staticmethod
-    def compute_foundry_id(alias_id: HexStr, serial_number: int,
+    def compute_foundry_id(account_id: HexStr, serial_number: int,
                            token_scheme_type: int) -> HexStr:
         """Compute the foundry id.
         """
         return _call_method('computeFoundryId', {
-            'aliasId': alias_id,
+            'accountId': account_id,
             'serialNumber': serial_number,
             'tokenSchemeType': token_scheme_type
         })
 
     @staticmethod
-    def compute_inputs_commitment(inputs: List[Output]) -> HexStr:
-        """Compute the input commitment from the output objects that are used as inputs to fund the transaction.
-        """
-        return _call_method('computeInputsCommitment', {
-            'inputs': [i.as_dict() for i in inputs]
-        })
-
-    @staticmethod
-    def compute_storage_deposit(output, rent) -> HexStr:
-        """Compute the required storage deposit of an output.
+    def compute_minimum_output_amount(output, storage_score_parameters) -> int:
+        """Calculate the minimum required amount for an output.
         """
-        return _call_method('computeStorageDeposit', {
+        return int(_call_method('computeMinimumOutputAmount', {
             'output': output,
-            'rent': rent
-        })
+            'storageScoreParameters': storage_score_parameters
+        }))
 
     @staticmethod
     def compute_nft_id(output_id: OutputId) -> HexStr:
         """Compute the NFT id for the given NFT output id.
         """
-        return _call_method('computeNftId', {
-            'outputId': repr(output_id)
+        return _call_method('blake2b256Hash', {
+            'bytes': output_id
         })
 
     @staticmethod
-    def compute_output_id(transaction_id: HexStr, index: int) -> OutputId:
+    def compute_output_id(transaction_id: TransactionId,
+                          index: int) -> OutputId:
         """Compute the output id from transaction id and output index.
         """
-        return OutputId.from_string(_call_method('computeOutputId', {
+        return OutputId(_call_method('computeOutputId', {
             'id': transaction_id,
             'index': index,
         }))
 
     @staticmethod
-    def compute_token_id(alias_id: HexStr, serial_number: int,
+    def compute_token_id(account_id: HexStr, serial_number: int,
                          token_scheme_type: int) -> HexStr:
-        """Compute a token id from the alias id, serial number and token scheme type.
+        """Compute a token id from the account id, serial number and token scheme type.
         """
         return _call_method('computeTokenId', {
-            'aliasId': alias_id,
+            'accountId': account_id,
             'serialNumber': serial_number,
             'tokenSchemeType': token_scheme_type
         })
 
     @staticmethod
-    def block_id(block: Block) -> HexStr:
+    def block_id(block: Block, params: ProtocolParameters) -> BlockId:
         """ Return a block ID (Blake2b256 hash of block bytes) from a block.
         """
-        return _call_method('blockId', {
-            'block': block.as_dict()
-        })
+        return BlockId(_call_method('blockId', {
+            'block': block,
+            'protocolParameters': params,
+        }))
 
     @staticmethod
-    def transaction_id(transaction_payload: TransactionPayload) -> HexStr:
+    def transaction_id(payload: SignedTransactionPayload) -> TransactionId:
         """ Compute the transaction ID (Blake2b256 hash of the provided transaction payload) of a transaction payload.
         """
-        return _call_method('transactionId', {
-            'payload': transaction_payload.as_dict()
+        return TransactionId(_call_method('transactionId', {
+            'payload': payload
+        }))
+
+    @staticmethod
+    def protocol_parameters_hash(params: ProtocolParameters) -> HexStr:
+        """ Compute the hash of a ProtocolParameters instance.
+        """
+        return _call_method('protocolParametersHash', {
+            'protocolParameters': params,
         })
 
     @staticmethod
-    def hash_transaction_essence(essence) -> HexStr:
-        """ Compute the hash of a transaction essence.
+    def transaction_signing_hash(transaction: Transaction) -> HexStr:
+        """ Compute the signing hash of a transaction.
         """
-        return _call_method('hashTransactionEssence', {
-            'essence': essence
+        return _call_method('transactionSigningHash', {
+            'transaction': transaction,
         })
 
     @staticmethod
     def verify_ed25519_signature(
             signature: Ed25519Signature, message: HexStr) -> bool:
         """Verify an Ed25519 signature against a message.
         """
         return _call_method('verifyEd25519Signature', {
-            'signature': signature.__dict__,
+            'signature': signature,
             'message': message,
         })
 
     @staticmethod
     def verify_secp256k1_ecdsa_signature(
             public_key: HexStr, signature: HexStr, message: HexStr) -> bool:
         """Verify a Secp256k1Ecdsa signature against a message.
@@ -218,26 +197,69 @@
             'publicKey': public_key,
             'signature': signature,
             'message': message,
         })
 
     @staticmethod
     def verify_transaction_semantic(
-            inputs: List[InputSigningData], transaction: TransactionPayload, time: int) -> str:
+            transaction: Transaction, inputs: List[InputSigningData], protocol_parameters: ProtocolParameters, unlocks: Optional[List[Unlock]] = None, mana_rewards: Optional[dict[OutputId, int]] = None):
         """Verifies the semantic of a transaction.
         """
-        return _call_method('verifyTransactionSemantic', {
-            'inputs': [i.as_dict() for i in inputs],
-            'transaction': transaction.as_dict(),
-            'time': time,
+        _call_method('verifyTransactionSemantic', {
+            'transaction': transaction,
+            'inputs': inputs,
+            'unlocks': unlocks,
+            'manaRewards': mana_rewards,
+            'protocolParameters': protocol_parameters,
         })
 
     @staticmethod
+    def mana_with_decay(
+            mana: int, slot_index_created: int, slot_index_target: int, protocol_parameters: ProtocolParameters) -> int:
+        """Applies mana decay to the given mana.
+        """
+        return int(_call_method('manaWithDecay', {
+            'mana': str(mana),
+            'slotIndexCreated': slot_index_created,
+            'slotIndexTarget': slot_index_target,
+            'protocolParameters': protocol_parameters,
+        }))
+
+    @staticmethod
+    def generate_mana_with_decay(
+            amount: int, slot_index_created: int, slot_index_target: int, protocol_parameters: ProtocolParameters) -> int:
+        """Calculates the potential mana that is generated by holding `amount` tokens from `slot_index_created` to
+        `slot_index_target` and applies the decay to the result.
+        """
+        return int(_call_method('generateManaWithDecay', {
+            'amount': str(amount),
+            'slotIndexCreated': slot_index_created,
+            'slotIndexTarget': slot_index_target,
+            'protocolParameters': protocol_parameters,
+        }))
+
+    @staticmethod
+    def output_mana_with_decay(
+            output: Output, slot_index_created: int, slot_index_target: int, protocol_parameters: ProtocolParameters) -> DecayedMana:
+        """Calculates the potential mana that is generated by holding `amount` tokens from `slot_index_created` to
+        `slot_index_target` and applies the decay to the result.
+        """
+        decayed_mana = _call_method('outputManaWithDecay', {
+            'output': output,
+            'slotIndexCreated': slot_index_created,
+            'slotIndexTarget': slot_index_target,
+            'protocolParameters': protocol_parameters,
+        })
+
+        return DecayedMana(int(decayed_mana["stored"]), int(
+            decayed_mana["potential"]))
+
+    @staticmethod
     def verify_transaction_syntax(
-            transaction: TransactionPayload, protocol_parameters: NodeInfoProtocol):
+            transaction: SignedTransactionPayload, protocol_parameters: ProtocolParameters):
         """Verifies the syntax of a transaction.
         """
         _call_method('verifyTransactionSyntax', {
             'transaction': transaction.as_dict(),
             'protocolParameters': protocol_parameters.as_dict(),
         })
 
@@ -247,42 +269,65 @@
         """Returns the serialized bytes of a block.
         """
         return bytes(_call_method('blockBytes', {
             'block': block.as_dict(),
         }))
 
     @staticmethod
-    def block_hash_without_nonce(
-            block: Block) -> HexStr:
-        """Returns a block hash (Blake2b256 hash of block bytes without nonce) from a block for PoW.
+    def iota_mainnet_protocol_parameters() -> ProtocolParameters:
+        """Returns sample protocol parameters for IOTA mainnet.
         """
-        return _call_method('blockHashWithoutNonce', {
-            'block': block.as_dict(),
+        return ProtocolParameters.from_dict(
+            _call_method('iotaMainnetProtocolParameters'))
+
+    @staticmethod
+    def shimmer_mainnet_protocol_parameters() -> ProtocolParameters:
+        """Returns sample protocol parameters for Shimmer mainnet.
+        """
+        return ProtocolParameters.from_dict(
+            _call_method('shimmerMainnetProtocolParameters'))
+
+    @staticmethod
+    def block_work_score(
+            block: Block, work_score_parameters: WorkScoreParameters) -> int:
+        """Returns the work score of a block.
+        """
+        return _call_method('blockWorkScore', {
+            'block': block,
+            'workScoreParameters': work_score_parameters,
         })
 
 
 class UtilsError(Exception):
     """A utils error."""
 
 
-def _call_method(name: str, data=None):
-    """Dumps json string and call call_utils_method().
+def _call_utils_method_routine(func):
+    """The routine of dump json string and call call_client_method().
+    """
+    def wrapper(*args, **kwargs):
+        message = custom_encoder(func, *args, **kwargs)
+        # Send message to the Rust library
+        response = call_utils_method(message)
+
+        json_response = json.loads(response)
+
+        if "type" in json_response:
+            if json_response["type"] == "error" or json_response["type"] == "panic":
+                raise UtilsError(json_response['payload'])
+
+        if "payload" in json_response:
+            return json_response['payload']
+        return response
+    return wrapper
+
+
+@_call_utils_method_routine
+def _call_method(name, data=None):
+    """Dumps json string and calls `call_client_method()`
     """
     message = {
         'name': name
     }
     if data:
         message['data'] = data
-    message_str: str = dumps(message)
-
-    # Send message to the Rust library
-    response = call_utils_method(message_str)
-
-    json_response = loads(response)
-
-    if "type" in json_response:
-        if json_response["type"] == "error":
-            raise UtilsError(json_response['payload'])
-
-    if "payload" in json_response:
-        return json_response['payload']
-    return response
+    return message
```

## iota_sdk/wallet/common.py

```diff
@@ -1,64 +1,20 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 import json
-from json import dumps, JSONEncoder
-from enum import Enum
-import humps
 from iota_sdk import call_wallet_method
+from iota_sdk.common import custom_encoder
 
 
-def _call_method_routine(func):
+def _call_wallet_method_routine(func):
     """The routine of dump json string and call call_wallet_method().
     """
     def wrapper(*args, **kwargs):
-        class MyEncoder(JSONEncoder):
-            """Custom encoder
-            """
-
-            # pylint: disable=too-many-return-statements
-            def default(self, o):
-                to_dict_method = getattr(o, "to_dict", None)
-                if callable(to_dict_method):
-                    return o.to_dict()
-                as_dict_method = getattr(o, "as_dict", None)
-                if callable(as_dict_method):
-                    return o.as_dict()
-                if isinstance(o, str):
-                    return o
-                if isinstance(o, Enum):
-                    return o.__dict__
-                if isinstance(o, dict):
-                    return o
-                if hasattr(o, "__dict__"):
-                    obj_dict = o.__dict__
-
-                    items_method = getattr(self, "items", None)
-                    if callable(items_method):
-                        for k, v in obj_dict.items():
-                            obj_dict[k] = dumps(v, cls=MyEncoder)
-                            return obj_dict
-                    return obj_dict
-                return o
-        message = func(*args, **kwargs)
-
-        for k, v in message.items():
-            if not isinstance(v, str):
-                message[k] = json.loads(dumps(v, cls=MyEncoder))
-
-        def remove_none(obj):
-            if isinstance(obj, (list, tuple, set)):
-                return type(obj)(remove_none(x) for x in obj if x is not None)
-            if isinstance(obj, dict):
-                return type(obj)((remove_none(k), remove_none(v))
-                                 for k, v in obj.items() if k is not None and v is not None)
-            return obj
-        message_null_filtered = remove_none(message)
-        message = dumps(humps.camelize(message_null_filtered))
+        message = custom_encoder(func, *args, **kwargs)
         # Send message to the Rust library
         response = call_wallet_method(args[0].handle, message)
 
         json_response = json.loads(response)
 
         if "type" in json_response:
             if json_response["type"] == "error" or json_response["type"] == "panic":
```

## iota_sdk/wallet/prepared_transaction.py

```diff
@@ -1,79 +1,151 @@
-# Copyright 2023 IOTA Stiftung
+# Copyright 2024 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from typing import TYPE_CHECKING, Dict, Union
-from dacite import from_dict
-from iota_sdk.types.transaction import Transaction
+from typing import TYPE_CHECKING
+from dataclasses import dataclass
+from iota_sdk.types.common import HexStr, json
+from iota_sdk.types.transaction_with_metadata import CreateDelegationTransaction, CreateNativeTokenTransaction, TransactionWithMetadata
 from iota_sdk.types.transaction_data import PreparedTransactionData
+
 # Required to prevent circular import
 if TYPE_CHECKING:
-    from iota_sdk.wallet.wallet import Account
+    from iota_sdk.wallet.wallet import Wallet
 
 
+@dataclass
 class PreparedTransaction:
     """A helper class for offline signing.
 
     Attributes:
-        account: An account object used to continue building this transaction.
-        prepared_transaction_data_dto: A prepared transaction data object.
+        wallet: A wallet object used to continue building this transaction.
+        prepared_transaction_data: A prepared transaction data object.
     """
+    wallet: Wallet
+    prepared_transaction_data: PreparedTransactionData
 
-    def __init__(
-        self,
-        account: Account,
-        prepared_transaction_data: Union[PreparedTransactionData, Dict]
-    ):
-        """Initialize `Self`.
-        """
-        self.account = account
-        self.prepared_transaction_data_dto = prepared_transaction_data
+    def send(self) -> TransactionWithMetadata:
+        """Send a transaction. Internally just calls `sign_and_submit_transaction`.
 
-    def prepared_transaction_data(self) -> PreparedTransactionData:
-        """Returns the prepared transaction data.
+        Returns:
+            The transaction after it has been signed and submitted.
         """
-        return self.prepared_transaction_data_dto if isinstance(
-            self.prepared_transaction_data_dto, PreparedTransactionData) else from_dict(PreparedTransactionData, self.prepared_transaction_data_dto)
+        return self.sign_and_submit_transaction()
 
-    def send(self) -> Transaction:
+    def sign(self):
+        """Sign a prepared transaction using the wallet's private key and returns
+        the signed transaction.
+        """
+        return self.wallet.sign_transaction(
+            self.prepared_transaction_data)
+
+    def sign_and_submit_transaction(self) -> TransactionWithMetadata:
+        """Sign and submit a transaction using prepared transaction data.
+
+        Returns:
+            The transaction after it has been signed and submitted.
+        """
+        return self.wallet.sign_and_submit_transaction(
+            self.prepared_transaction_data)
+
+
+@dataclass
+class PreparedCreateTokenTransaction:
+    """A helper class for offline signing a create native token transaction.
+
+    Attributes:
+        wallet: A wallet object used to continue building this transaction.
+        prepared_transaction_data: A prepared transaction data object.
+    """
+    wallet: Wallet
+    prepared_transaction_data: PreparedCreateTokenTransactionData
+
+    def send(self) -> CreateNativeTokenTransaction:
         """Send a transaction. Internally just calls `sign_and_submit_transaction`.
 
         Returns:
             The transaction after it has been signed and submitted.
         """
         return self.sign_and_submit_transaction()
 
     def sign(self):
-        """Sign a prepared transaction essence using the account's private key and returns
-        the signed transaction essence.
+        """Sign a prepared transaction using the wallet's private key and returns
+        the signed transaction.
         """
-        return self.account.sign_transaction_essence(
-            self.prepared_transaction_data())
+        return self.wallet.sign_transaction(
+            self.prepared_transaction_data.transaction)
 
-    def sign_and_submit_transaction(self) -> Transaction:
+    def sign_and_submit_transaction(self) -> CreateNativeTokenTransaction:
         """Sign and submit a transaction using prepared transaction data.
 
         Returns:
             The transaction after it has been signed and submitted.
         """
-        return self.account.sign_and_submit_transaction(
-            self.prepared_transaction_data())
+        tx = self.wallet.sign_and_submit_transaction(
+            self.prepared_transaction_data.transaction)
+        CreateNativeTokenTransaction(
+            self.prepared_transaction_data.token_id, tx)
 
 
-class PreparedCreateTokenTransaction(PreparedTransaction):
+@json
+@dataclass
+class PreparedCreateTokenTransactionData:
+    """Prepared transaction data for creating a native token.
 
-    """A prepared transaction for creating a native token.
+    Attributes:
+        token_id: The token id.
+        transaction: The transaction that will create the delegation.
+    """
+    token_id: HexStr
+    transaction: PreparedTransactionData
 
-    Returns: The token id of the PreparedCreateTokenTransaction.
+
+@dataclass
+class PreparedCreateDelegationTransaction:
+    """A helper class for offline signing to create a delegation transaction.
+
+    Attributes:
+        wallet: A wallet object used to continue building this transaction.
+        prepared_transaction_data: A prepared transaction data object.
     """
+    wallet: Wallet
+    prepared_transaction_data: PreparedCreateDelegationTransactionData
+
+    def send(self) -> CreateDelegationTransaction:
+        """Send a transaction. Internally just calls `sign_and_submit_transaction`.
+
+        Returns:
+            The transaction after it has been signed and submitted.
+        """
+        return self.sign_and_submit_transaction()
 
-    def token_id(self):
-        """Get the native token id as a string.
+    def sign(self):
+        """Sign a prepared transaction using the wallet's private key and returns
+        the signed transaction.
         """
-        return self.prepared_transaction_data_dto["tokenId"]
+        return self.wallet.sign_transaction(
+            self.prepared_transaction_data.transaction)
+
+    def sign_and_submit_transaction(self) -> CreateDelegationTransaction:
+        """Sign and submit a transaction using prepared transaction data.
 
-    def prepared_transaction_data(self):
-        """Returns the prepared transaction data.
+        Returns:
+            The transaction after it has been signed and submitted.
         """
-        return from_dict(PreparedTransactionData,
-                         self.prepared_transaction_data_dto["transaction"])
+        tx = self.wallet.sign_and_submit_transaction(
+            self.prepared_transaction_data.transaction)
+        CreateDelegationTransaction(
+            self.prepared_transaction_data.delegation_id, tx)
+
+
+@json
+@dataclass
+class PreparedCreateDelegationTransactionData:
+    """Prepared transaction data for creating a delegation.
+
+    Attributes:
+        delegation_id: The id of the delegation that will be created.
+        transaction: The transaction that will create the delegation.
+    """
+    delegation_id: HexStr
+    transaction: PreparedTransactionData
```

## iota_sdk/wallet/sync_options.py

```diff
@@ -1,137 +1,103 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from typing import List, Optional
+from typing import Optional
+from dataclasses import dataclass
+from iota_sdk.types.common import json
 
 
-class AccountSyncOptions():
-    """Sync options for addresses from the account.
+@json
+@dataclass
+class WalletSyncOptions:
+    """Specifies what outputs should be synced for the ed25519 address from the wallet.
 
     Attributes:
         basic_outputs: Whether to sync basic outputs.
+        account_outputs: whether to sync account outputs.
         nft_outputs: Whether to sync NFT outputs.
-        alias_outputs: whether to sync alias outputs.
+        delegation_outputs: Whether to sync delegation outputs.
     """
 
-    def __init__(self,
-                 basic_outputs: Optional[bool] = None,
-                 nft_outputs: Optional[bool] = None,
-                 alias_outputs: Optional[bool] = None):
-        """Initialize `Self`.
-        """
-        self.basicOutputs = basic_outputs
-        self.nftOutputs = nft_outputs
-        self.aliasOutputs = alias_outputs
+    basic_outputs: Optional[bool] = None
+    account_outputs: Optional[bool] = None
+    nft_outputs: Optional[bool] = None
+    delegation_outputs: Optional[bool] = None
 
 
-class AliasSyncOptions():
-    """Sync options for addresses from alias outputs.
+@json
+@dataclass
+class AccountSyncOptions:
+    """Specifies what outputs should be synced for the address of an account output.
 
     Attributes:
         basic_outputs: Whether to sync basic outputs.
-        nft_outputs: Whether to sync NFT outputs.
-        alias_outputs: Whether to sync alias outputs.
+        account_outputs: Whether to sync account outputs.
         foundry_outputs: Whether to sync foundry outputs.
+        nft_outputs: Whether to sync NFT outputs.
+        delegation_outputs: Whether to sync delegation outputs.
     """
 
-    def __init__(self,
-                 basic_outputs: Optional[bool] = None,
-                 nft_outputs: Optional[bool] = None,
-                 alias_outputs: Optional[bool] = None,
-                 foundry_outputs: Optional[bool] = None):
-        """Initialize `Self`.
-        """
-        self.basicOutputs = basic_outputs
-        self.nftOutputs = nft_outputs
-        self.aliasOutputs = alias_outputs
-        self.foundryOutputs = foundry_outputs
+    basic_outputs: Optional[bool] = None
+    account_outputs: Optional[bool] = None
+    foundry_outputs: Optional[bool] = None
+    nft_outputs: Optional[bool] = None
+    delegation_outputs: Optional[bool] = None
 
 
-class NftSyncOptions():
-    """Sync options for addresses from NFT outputs.
+@json
+@dataclass
+class NftSyncOptions:
+    """Specifies what outputs should be synced for the address of an nft output.
 
     Attributes:
         basic_outputs: Whether to sync basic outputs.
+        account_outputs: Whether to sync account outputs.
         nft_outputs: Whether to sync NFT outputs.
-        alias_outputs: Whether to sync alias outputs.
+        delegation_outputs: Whether to sync delegation outputs.
     """
 
-    def __init__(self,
-                 basic_outputs: Optional[bool] = None,
-                 nft_outputs: Optional[bool] = None,
-                 alias_outputs: Optional[bool] = None):
-        """Initialize `Self`.
-        """
-        self.basicOutputs = basic_outputs
-        self.nftOutputs = nft_outputs
-        self.aliasOutputs = alias_outputs
+    basic_outputs: Optional[bool] = None
+    account_outputs: Optional[bool] = None
+    nft_outputs: Optional[bool] = None
+    delegation_outputs: Optional[bool] = None
 
 
-class SyncOptions():
+@json
+@dataclass
+class SyncOptions:
     """The synchronization options.
 
     **Attributes**
-    addresses :
-        Specific Bech32 encoded addresses of the account to sync. If addresses are provided,
-        then `address_start_index` will be ignored.
-    address_start_index :
-        Address index from which to start syncing addresses. 0 by default.
-        Using a higher index will be faster because addresses with a lower index will be skipped,
-        but this could result in a wrong balance for that reason.
-    address_start_index_internal :
-        Address index from which to start syncing internal addresses. 0 by default.
-        Using a higher index will be faster because addresses with a lower index will be skipped,
-        but this could result in a wrong balance for internal addresses for that reason.
     force_syncing :
-        Usually syncing is skipped if it's called in between 200ms, because there can only be new
-        changes every milestone and calling it twice "at the same time" will not return new data.
-        When this is set to true, we will sync anyways, even if it's called 0ms after the last sync
-        finished.
+        Syncing is usually skipped if it's called repeatedly in a short amount of time as there can only be new changes every
+        slot and calling it twice "at the same time" will not return new data.
+        When this to true, we sync anyways, even if it's called 0ms after the last sync finished.
     sync_incoming_transactions :
         Try to sync transactions from incoming outputs with their inputs. Some data may not be obtained
         if it has been pruned.
     sync_pending_transactions :
-        Checks pending transactions and promotes/reattaches them if necessary.
+        Checks pending transactions.
     account :
-        Specifies what outputs should be synced for the Ed25519 addresses from the account.
-    alias :
-        Specifies what outputs should be synced for the address of an alias output.
+        Specifies what outputs should be synced for the address of an account output.
+    wallet :
+        Specifies what outputs should be synced for the address of an account output.
     nft :
         Specifies what outputs should be synced for the address of an nft output.
     sync_only_most_basic_outputs :
         Specifies if only basic outputs with just an address unlock condition should be synced.
-        This will overwrite the `account`, `alias` and `nft` options.
+        This will overwrite the `wallet`, `alias` and `nft` options.
     sync_native_token_foundries :
         Sync native token foundries, so their metadata can be returned in the balance.
+    sync_implicit_accounts :
+        Sync implicit accounts.
     """
 
-    def __init__(self,
-                 addresses: Optional[List[str]] = None,
-                 address_start_index: Optional[int] = None,
-                 address_start_index_internal: Optional[int] = None,
-                 force_syncing: Optional[bool] = None,
-                 sync_incoming_transactions: Optional[bool] = None,
-                 sync_pending_transactions: Optional[bool] = None,
-                 account: Optional[AccountSyncOptions] = None,
-                 alias: Optional[AliasSyncOptions] = None,
-                 nft: Optional[NftSyncOptions] = None,
-                 sync_only_most_basic_outputs: Optional[bool] = None,
-                 sync_native_token_foundries: Optional[bool] = None):
-        """Initialize `Self`.
-        """
-        self.addresses = addresses
-        self.addressStartIndex = address_start_index
-        self.addressStartIndexInternal = address_start_index_internal
-        self.forceSyncing = force_syncing
-        self.syncIncomingTransactions = sync_incoming_transactions
-        self.syncPendingTransactions = sync_pending_transactions
-        self.account = account
-        self.alias = alias
-        self.nft = nft
-        self.syncOnlyMostBasicOutputs = sync_only_most_basic_outputs
-        self.syncNativeTokenFoundries = sync_native_token_foundries
-
-    def as_dict(self):
-        """Converts this object to a dict.
-        """
-        return dict(self.__dict__)
+    force_syncing: Optional[bool] = None
+    sync_incoming_transactions: Optional[bool] = None
+    sync_pending_transactions: Optional[bool] = None
+    account: Optional[AccountSyncOptions] = None
+    wallet: Optional[WalletSyncOptions] = None
+    nft: Optional[NftSyncOptions] = None
+    sync_only_most_basic_outputs: Optional[bool] = None
+    sync_native_token_foundries: Optional[bool] = None
+    sync_implicit_accounts: Optional[bool] = None
```

## iota_sdk/wallet/wallet.py

```diff
@@ -1,129 +1,82 @@
-# Copyright 2023 IOTA Stiftung
+# Copyright 2024 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from json import dumps
-from typing import Any, Dict, List, Optional, Union
+from typing import List, Optional, Union
+from dataclasses import dataclass
 from iota_sdk import destroy_wallet, create_wallet, listen_wallet, get_client_from_wallet, get_secret_manager_from_wallet, Client
 from iota_sdk.secret_manager.secret_manager import LedgerNanoSecretManager, MnemonicSecretManager, StrongholdSecretManager, SeedSecretManager, SecretManager
-from iota_sdk.types.address import AccountAddress
-from iota_sdk.types.client_options import ClientOptions
-from iota_sdk.wallet.account import Account, _call_method_routine
+from iota_sdk.wallet.common import _call_wallet_method_routine
+from iota_sdk.wallet.prepared_transaction import PreparedCreateDelegationTransaction, PreparedCreateDelegationTransactionData, PreparedCreateTokenTransactionData, PreparedTransaction, PreparedCreateTokenTransaction
 from iota_sdk.wallet.sync_options import SyncOptions
+from iota_sdk.types.balance import Balance
+from iota_sdk.types.block.id import BlockId
+from iota_sdk.types.burn import Burn
+from iota_sdk.types.common import HexStr, json
+from iota_sdk.types.client_options import ClientOptions
+from iota_sdk.types.filter_options import FilterOptions
+from iota_sdk.types.native_token import NativeToken
+from iota_sdk.types.output import BasicOutput, NftOutput, Output, deserialize_output
+from iota_sdk.types.output_data import OutputData
+from iota_sdk.types.output_id import OutputId
+from iota_sdk.types.output_params import OutputParams
+from iota_sdk.types.transaction_data import PreparedTransactionData, SignedTransactionData
+from iota_sdk.types.transaction_id import TransactionId
+from iota_sdk.types.send_params import BeginStakingParams, CreateAccountOutputParams, CreateDelegationParams, CreateNativeTokenParams, MintNftParams, SendManaParams, SendNativeTokenParams, SendNftParams, SendParams
+from iota_sdk.types.signature import Bip44
+from iota_sdk.types.transaction_with_metadata import CreateDelegationTransaction, CreateNativeTokenTransaction, TransactionWithMetadata
+from iota_sdk.types.transaction_options import TransactionOptions
+from iota_sdk.types.consolidation_params import ConsolidationParams
+
+
+@json
+@dataclass
+class WalletOptions:
+    """Options for the Wallet builder."""
+    address: Optional[str] = None
+    alias: Optional[str] = None
+    bip_path: Optional[Bip44] = None
+    client_options: Optional[ClientOptions] = None
+    secret_manager: Optional[Union[LedgerNanoSecretManager,
+                                   MnemonicSecretManager, SeedSecretManager, StrongholdSecretManager]] = None
+    storage_path: Optional[str] = None
+
 
 # pylint: disable=too-many-public-methods
 
 
-class Wallet():
+class Wallet:
     """An IOTA Wallet.
 
     Attributes:
         handle: The wallet handle.
     """
 
-    def __init__(self,
-                 storage_path: Optional[str] = None,
-                 client_options: Optional[Union[Dict[str,
-                                                     Any], ClientOptions]] = None,
-                 coin_type: Optional[int] = None,
-                 secret_manager: Optional[Union[LedgerNanoSecretManager, MnemonicSecretManager, SeedSecretManager, StrongholdSecretManager]] = None):
+    def __init__(self, options: WalletOptions):
         """Initialize `self`.
         """
-
-        # Setup the options
-        options: Dict[str, Any] = {'storagePath': storage_path}
-        if client_options:
-            if isinstance(client_options, ClientOptions):
-                options['clientOptions'] = client_options.as_dict()
-            else:
-                options['clientOptions'] = client_options
-        if coin_type:
-            options['coinType'] = coin_type
-        if secret_manager:
-            options['secretManager'] = secret_manager
-
-        options_str: str = dumps(options)
-
         # Create the message handler
-        self.handle = create_wallet(options_str)
+        self.handle = create_wallet(dumps(options.to_dict()))
 
     def get_handle(self):
         """Return the wallet handle.
         """
         return self.handle
 
-    def create_account(self, alias: Optional[str] = None, bech32_hrp: Optional[str]
-                       = None, addresses: Optional[AccountAddress] = None) -> Account:
-        """Create a new account.
-
-        Args:
-            alias: The alias of the newaccount.
-            bech32_hrp: The Bech32 HRP of the new account.
-
-        Returns:
-            An account object.
-        """
-        account_data = self._call_method(
-            'createAccount', {
-                'alias': self.__return_str_or_none(alias),
-                'bech32Hrp': self.__return_str_or_none(bech32_hrp),
-                'addresses': addresses,
-            }
-        )
-        return Account(account_data, self.handle)
-
-    def get_account(self, account_id: Union[str, int]) -> Account:
-        """Get the account associated with the given account ID or index.
-        """
-        account_data = self._call_method(
-            'getAccount', {
-                'accountId': account_id,
-            }
-        )
-        return Account(account_data, self.handle)
-
-    def get_client(self):
-        """Get the client associated with the wallet.
-        """
-        return Client(client_handle=get_client_from_wallet(self.handle))
-
-    def get_secret_manager(self):
-        """Get the secret manager associated with the wallet.
-        """
-        return SecretManager(
-            secret_manager_handle=get_secret_manager_from_wallet(self.handle))
-
-    @_call_method_routine
+    @_call_wallet_method_routine
     def _call_method(self, name: str, data=None):
         message = {
             'name': name
         }
         if data:
             message['data'] = data
         return message
 
-    def get_account_data(self, account_id: Union[str, int]):
-        """Get account data associated with the given account ID or index.
-        """
-        return self._call_method(
-            'getAccount', {
-                'accountId': account_id
-            }
-        )
-
-    def get_accounts(self):
-        """Get all accounts.
-        """
-        accounts_data = self._call_method(
-            'getAccounts',
-        )
-        return [Account(account_data, self.handle)
-                for account_data in accounts_data]
-
-    def backup(self, destination: str, password: str):
+    def backup_to_stronghold_snapshot(self, destination: str, password: str):
         """Backup storage.
         """
         return self._call_method(
             'backup', {
                 'destination': destination,
                 'password': password
             }
@@ -149,69 +102,78 @@
     def is_stronghold_password_available(self) -> bool:
         """Return whether a Stronghold password is available.
         """
         return self._call_method(
             'isStrongholdPasswordAvailable'
         )
 
-    def recover_accounts(self, account_start_index: int, account_gap_limit: int,
-                         address_gap_limit: int, sync_options: Optional[SyncOptions] = None):
-        """Recover accounts.
+    def destroy(self):
+        """Destroys the wallet instance.
+        """
+        return destroy_wallet(self.handle)
+
+    def emit_test_event(self, event) -> bool:
+        """Helper function to test events.
         """
         return self._call_method(
-            'recoverAccounts', {
-                'accountStartIndex': account_start_index,
-                'accountGapLimit': account_gap_limit,
-                'addressGapLimit': address_gap_limit,
-                'syncOptions': sync_options
-            }
+            'emitTestEvent', {
+                'event': event,
+            },
         )
 
-    def remove_latest_account(self):
-        """Remove latest account.
+    def get_client(self):
+        """Get the client associated with the wallet.
+        """
+        return Client(client_handle=get_client_from_wallet(self.handle))
+
+    def get_secret_manager(self):
+        """Get the secret manager associated with the wallet.
+        """
+        return SecretManager(
+            secret_manager_handle=get_secret_manager_from_wallet(self.handle))
+
+    def listen(self, handler, events: Optional[List[int]] = None):
+        """Listen to wallet events, empty array or None will listen to all events.
+        The default value for events is None.
+        """
+        events_array = [] if events is None else events
+        listen_wallet(self.handle, events_array, handler)
+
+    def clear_listeners(self, events: Optional[List[int]] = None):
+        """Remove wallet event listeners, empty array or None will remove all listeners.
+        The default value for events is None.
         """
+        events_array = [] if events is None else events
         return self._call_method(
-            'removeLatestAccount'
+            'clearListeners', {
+                'eventTypes': events_array
+            }
         )
 
-    def restore_backup(self, source: str, password: str):
+    def restore_from_stronghold_snapshot(self, source: str, password: str):
         """Restore a backup from a Stronghold file.
-        Replaces `client_options`, `coin_type`, `secret_manager` and accounts.
-        Returns an error if accounts were already created. If Stronghold is used
+        Replaces `client_options`, `coin_type`, `secret_manager` and wallet.
+        Returns an error if the wallet was already created. If Stronghold is used
         as the secret_manager, the existing Stronghold file will be overwritten.
         Be aware that if a mnemonic was stored, it will be lost.
         """
         return self._call_method(
             'restoreBackup', {
                 'source': source,
                 'password': password
             }
         )
 
     def set_client_options(self, client_options):
-        """Update the client options for all accounts.
+        """Update the options of the wallet client.
         """
         return self._call_method(
             'setClientOptions',
             {
-                'clientOptions': client_options.as_dict()
-            }
-        )
-
-    def generate_ed25519_address(self, account_index: int, internal: bool, address_index: int,
-                                 options=None, bech32_hrp: Optional[str] = None) -> List[str]:
-        """Generate an address without storing it.
-        """
-        return self._call_method(
-            'generateEd25519Address', {
-                'accountIndex': account_index,
-                'internal': internal,
-                'addressIndex': address_index,
-                'options': options,
-                'bech32Hrp': bech32_hrp
+                'clientOptions': client_options.to_dict()
             }
         )
 
     def set_stronghold_password(self, password: str):
         """Set stronghold password.
         """
         return self._call_method(
@@ -227,64 +189,673 @@
         """
         return self._call_method(
             'setStrongholdPasswordClearInterval', {
                 'intervalInMilliseconds': interval_in_milliseconds
             }
         )
 
+    def start_background_sync(
+            self, options: Optional[SyncOptions] = None, interval_in_milliseconds: Optional[int] = None):
+        """Start background syncing.
+        """
+        return self._call_method(
+            'startBackgroundSync', {
+                'options': options,
+                'intervalInMilliseconds': interval_in_milliseconds
+            }
+        )
+
+    def stop_background_sync(self):
+        """Stop background syncing.
+        """
+        return self._call_method(
+            'stopBackgroundSync',
+        )
+
     def store_mnemonic(self, mnemonic: str):
         """Store mnemonic.
         """
         return self._call_method(
             'storeMnemonic', {
                 'mnemonic': mnemonic
             }
+        )
 
+    def update_node_auth(self, url: str, auth=None):
+        """Update the authentication for the provided node.
+        """
+        return self._call_method(
+            'updateNodeAuth', {
+                'url': url,
+                'auth': auth
+            }
         )
 
-    def start_background_sync(
-            self, options: Optional[SyncOptions] = None, interval_in_milliseconds: Optional[int] = None):
-        """Start background syncing.
+    def accounts(self) -> List[OutputData]:
+        """Returns the accounts of the wallet.
+        """
+        outputs = self._call_method(
+            'accounts'
+        )
+        return [OutputData.from_dict(o) for o in outputs]
+
+    def burn(
+            self, burn: Burn, options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """A generic function that can be used to burn native tokens, nfts, foundries and aliases.
+        """
+        return self.prepare_burn(burn, options).send()
+
+    def prepare_burn(
+            self, burn: Burn, options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """A generic `prepare_burn()` function that can be used to prepare the burn of native tokens, nfts, foundries and accounts.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareBurn', {
+                'burn': burn.to_dict(),
+                'options': options
+            },
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def prepare_burn_native_token(self,
+                                  token_id: HexStr,
+                                  burn_amount: int,
+                                  options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Burn native tokens. This doesn't require the foundry output which minted them, but will not increase
+        the foundries `melted_tokens` field, which makes it impossible to destroy the foundry output. Therefore it's
+        recommended to use melting, if the foundry output is available.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareBurn', {
+                'burn': Burn().add_native_token(NativeToken(token_id, hex(burn_amount))).to_dict(),
+                'options': options
+            },
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def prepare_burn_nft(self,
+                         nft_id: HexStr,
+                         options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Burn an nft output.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareBurn', {
+                'burn': Burn().add_nft(nft_id).to_dict(),
+                'options': options
+            },
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def claim_outputs(
+            self, output_ids_to_claim: List[OutputId], options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Claim outputs.
+        """
+        return self.prepare_claim_outputs(output_ids_to_claim, options).send()
+
+    def prepare_claim_outputs(
+            self, output_ids_to_claim: List[OutputId], options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Claim outputs.
+        """
+        return PreparedTransaction(self, PreparedTransactionData.from_dict(self._call_method(
+            'prepareClaimOutputs', {
+                'outputIdsToClaim': output_ids_to_claim,
+                'options': options
+            }
+        )))
+
+    def consolidate_outputs(
+            self, params: ConsolidationParams) -> TransactionWithMetadata:
+        """Consolidate outputs.
+        """
+        return self.prepare_consolidate_outputs(params).send()
+
+    def prepare_consolidate_outputs(
+            self, params: ConsolidationParams) -> PreparedTransaction:
+        """Consolidate outputs.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareConsolidateOutputs', {
+                'params': params
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def create_account_output(self,
+                              params: Optional[CreateAccountOutputParams] = None,
+                              options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Create an account output.
+        """
+        return self.prepare_create_account_output(params, options).send()
+
+    def prepare_create_account_output(self,
+                                      params: Optional[CreateAccountOutputParams] = None,
+                                      options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Create an account output.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareCreateAccountOutput', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def melt_native_token(self,
+                          token_id: HexStr,
+                          melt_amount: int,
+                          options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Melt native tokens. This happens with the foundry output which minted them, by increasing it's
+        `melted_tokens` field.
+        """
+        return self.prepare_melt_native_token(
+            token_id, melt_amount, options).send()
+
+    def prepare_melt_native_token(self,
+                                  token_id: HexStr,
+                                  melt_amount: int,
+                                  options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Melt native tokens. This happens with the foundry output which minted them, by increasing it's
+        `melted_tokens` field.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareMeltNativeToken', {
+                'tokenId': token_id,
+                'meltAmount': hex(melt_amount),
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def prepare_destroy_account(self,
+                                account_id: HexStr,
+                                options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Destroy an account output.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareBurn', {
+                'burn': Burn().add_account(account_id).to_dict(),
+                'options': options
+            },
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def prepare_destroy_foundry(self,
+                                foundry_id: HexStr,
+                                options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Destroy a foundry output with a circulating supply of 0.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareBurn', {
+                'burn': Burn().add_foundry(foundry_id).to_dict(),
+                'options': options
+            },
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def get_balance(self) -> Balance:
+        """Get wallet balance information.
+        """
+        return Balance.from_dict(self._call_method(
+            'getBalance'
+        ))
+
+    def get_output(self, output_id: OutputId) -> OutputData:
+        """Get output.
+        """
+        return OutputData.from_dict(self._call_method(
+            'getOutput', {
+                'outputId': output_id
+            }
+        ))
+
+    def get_foundry_output(self, token_id: HexStr):
+        """Get a `FoundryOutput` by native token ID. It will try to get the foundry from the wallet, if it isn't in the wallet it will try to get it from the node.
         """
         return self._call_method(
-            'startBackgroundSync', {
-                'options': options,
-                'intervalInMilliseconds': interval_in_milliseconds
+            'getFoundryOutput', {
+                'tokenId': token_id
             }
         )
 
-    def stop_background_sync(self):
-        """Stop background syncing.
+    def claimable_outputs(self, outputs_to_claim: List[OutputId]):
+        """Get outputs with additional unlock conditions.
         """
         return self._call_method(
-            'stopBackgroundSync',
+            'claimableOutputs', {
+                'outputsToClaim': outputs_to_claim
+            }
         )
 
-    def listen(self, handler, events: Optional[List[int]] = None):
-        """Listen to wallet events, empty array or None will listen to all events.
-        The default value for events is None.
+    def get_transaction(
+            self, transaction_id: TransactionId) -> TransactionWithMetadata:
+        """Get transaction.
         """
-        events_array = [] if events is None else events
-        listen_wallet(self.handle, events_array, handler)
+        return TransactionWithMetadata.from_dict(self._call_method(
+            'getTransaction', {
+                'transactionId': transaction_id
+            }
+        ))
 
-    def clear_listeners(self, events: Optional[List[int]] = None):
-        """Remove wallet event listeners, empty array or None will remove all listeners.
-        The default value for events is None.
+    def address(self) -> str:
+        """Get the address of the wallet.
         """
-        events_array = [] if events is None else events
         return self._call_method(
-            'clearListeners', {
-                'eventTypes': events_array
+            'getAddress'
+        )
+
+    def outputs(
+            self, filter_options: Optional[FilterOptions] = None) -> List[OutputData]:
+        """Returns all outputs of the wallet.
+        """
+        outputs = self._call_method(
+            'outputs', {
+                'filterOptions': filter_options
             }
         )
+        return [OutputData.from_dict(o) for o in outputs]
 
-    def destroy(self):
-        """Destroys the wallet instance.
+    def pending_transactions(self):
+        """Returns all pending transactions of the wallet.
         """
-        return destroy_wallet(self.handle)
+        transactions = self._call_method(
+            'pendingTransactions'
+        )
+        return [TransactionWithMetadata.from_dict(tx) for tx in transactions]
+
+    def implicit_account_creation_address(self) -> str:
+        """Returns the implicit account creation address of the wallet if it is Ed25519 based.
+        """
+        return self._call_method(
+            'implicitAccountCreationAddress'
+        )
+
+    def implicit_account_transition(
+            self, output_id: OutputId) -> TransactionWithMetadata:
+        """Transitions an implicit account to an account.
+        """
+        return self.prepare_implicit_account_transition(output_id).send()
+
+    def prepare_implicit_account_transition(
+            self, output_id: OutputId) -> PreparedTransaction:
+        """Prepares to transition an implicit account to an account.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareImplicitAccountTransition', {
+                'outputId': output_id
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def implicit_accounts(self) -> List[OutputData]:
+        """Returns the implicit accounts of the wallet.
+        """
+        outputs = self._call_method(
+            'implicitAccounts'
+        )
+        return [OutputData.from_dict(o) for o in outputs]
+
+    def incoming_transactions(self) -> List[TransactionWithMetadata]:
+        """Returns all incoming transactions of the wallet.
+        """
+        transactions = self._call_method(
+            'incomingTransactions'
+        )
+        return [TransactionWithMetadata.from_dict(tx) for tx in transactions]
+
+    def transactions(self) -> List[TransactionWithMetadata]:
+        """Returns all transaction of the wallet.
+        """
+        transactions = self._call_method(
+            'transactions'
+        )
+        return [TransactionWithMetadata.from_dict(tx) for tx in transactions]
+
+    def unspent_outputs(
+            self, filter_options: Optional[FilterOptions] = None) -> List[OutputData]:
+        """Returns all unspent outputs of the wallet.
+        """
+        outputs = self._call_method(
+            'unspentOutputs', {
+                'filterOptions': filter_options
+            }
+        )
+        return [OutputData.from_dict(o) for o in outputs]
+
+    def mint_native_token(self, token_id: HexStr, mint_amount: int,
+                          options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Mint additional native tokens.
+        """
+        return self.prepare_mint_native_token(
+            token_id, mint_amount, options).send()
+
+    def prepare_mint_native_token(self, token_id: HexStr, mint_amount: int,
+                                  options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Mint additional native tokens.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareMintNativeToken', {
+                'tokenId': token_id,
+                'mintAmount': hex(mint_amount),
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def create_native_token(self, params: CreateNativeTokenParams,
+                            options: Optional[TransactionOptions] = None) -> CreateNativeTokenTransaction:
+        """Create native token.
+        """
+        return self.prepare_create_native_token(params, options).send()
+
+    def prepare_create_native_token(self, params: CreateNativeTokenParams,
+                                    options: Optional[TransactionOptions] = None) -> PreparedCreateTokenTransaction:
+        """Create native token.
+        """
+        prepared = PreparedCreateTokenTransactionData.from_dict(self._call_method(
+            'prepareCreateNativeToken', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedCreateTokenTransaction(self, prepared)
+
+    def mint_nfts(self, params: List[MintNftParams],
+                  options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Mint NFTs.
+        """
+        return self.prepare_mint_nfts(params, options).send()
+
+    def prepare_mint_nfts(self, params: List[MintNftParams],
+                          options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Mint NFTs.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareMintNfts', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def prepare_output(self, params: OutputParams,
+                       transaction_options: Optional[TransactionOptions] = None) -> Union[BasicOutput, NftOutput]:
+        """Prepare an output for sending.
+           If the amount is below the minimum required storage deposit, by default the remaining amount will automatically
+           be added with a StorageDepositReturn UnlockCondition, when setting the ReturnStrategy to `gift`, the full
+           minimum required storage deposit will be sent to the recipient.
+           When the assets contain an nft_id, the data from the existing nft output will be used, just with the address
+           unlock conditions replaced
+        """
+        return deserialize_output(self._call_method(
+            'prepareOutput', {
+                'params': params,
+                'transactionOptions': transaction_options
+            })
+        )
+
+    def create_delegation(self, params: CreateDelegationParams,
+                          options: Optional[TransactionOptions] = None) -> CreateDelegationTransaction:
+        """Create a delegation.
+        """
+        return self.prepare_create_delegation(params, options).send()
+
+    def prepare_create_delegation(self, params: CreateDelegationParams,
+                                  options: Optional[TransactionOptions] = None) -> PreparedCreateDelegationTransaction:
+        """Prepare to create a delegation.
+        """
+        prepared = PreparedCreateDelegationTransactionData.from_dict(self._call_method(
+            'prepareCreateDelegation', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedCreateDelegationTransaction(self, prepared)
+
+    def delay_delegation_claiming(
+            self, delegation_id: HexStr, reclaim_excess: bool) -> TransactionWithMetadata:
+        """Delay a delegation's claiming.
+        """
+        return self.prepare_delay_delegation_claiming(
+            delegation_id, reclaim_excess).send()
+
+    def prepare_delay_delegation_claiming(
+            self, delegation_id: HexStr, reclaim_excess: bool) -> PreparedTransaction:
+        """Prepare to delay a delegation's claiming.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareDelayDelegationClaiming', {
+                'delegationId': delegation_id,
+                'reclaimExcess': reclaim_excess,
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def begin_staking(self, params: BeginStakingParams,
+                      options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Begin staking.
+        """
+        return self.prepare_begin_staking(params, options).send()
+
+    def prepare_begin_staking(self, params: BeginStakingParams,
+                              options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Prepare to begin staking.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareBeginStaking', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def extend_staking(self, account_id: HexStr,
+                       additional_epochs: int) -> TransactionWithMetadata:
+        """Extend staking by additional epochs.
+        """
+        return self.prepare_extend_staking(
+            account_id, additional_epochs).send()
+
+    def prepare_extend_staking(self, account_id: HexStr,
+                               additional_epochs: int) -> PreparedTransaction:
+        """Prepare to extend staking by additional epochs.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareExtendStaking', {
+                'accountId': account_id,
+                'additionalEpochs': additional_epochs
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def end_staking(self, account_id: HexStr) -> TransactionWithMetadata:
+        """End staking and claim rewards.
+        """
+        return self.prepare_end_staking(account_id).send()
+
+    def prepare_end_staking(self, account_id: HexStr) -> PreparedTransaction:
+        """Prepare to end staking and claim rewards.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareEndStaking', {
+                'accountId': account_id,
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def announce_candidacy(self, account_id: HexStr) -> BlockId:
+        """Announce a staking account's candidacy for the staking period.
+        """
+        return BlockId(self._call_method(
+            'announceCandidacy', {
+                'accountId': account_id,
+            }
+        ))
+
+    def send_outputs(
+            self, outputs: List[Output], options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Send outputs.
+        """
+        return self.prepare_send_outputs(outputs, options).send()
+
+    def prepare_send_outputs(
+            self, outputs: List[Output], options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Prepare to send outputs.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareSendOutputs', {
+                'outputs': outputs,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def wait_for_transaction_acceptance(
+            self, transaction_id: TransactionId, interval=None, max_attempts=None):
+        """Checks the transaction state for a provided transaction id until it's accepted. Interval in milliseconds.
+        """
+        return self._call_method(
+            'waitForTransactionAcceptance', {
+                'transactionId': transaction_id,
+                'interval': interval,
+                'maxAttempts': max_attempts
+            }
+        )
+
+    def send(self, amount: int, address: str,
+             options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Send base coins.
+        """
+        return self.prepare_send([SendParams(address, amount)], options).send()
+
+    def send_with_params(
+            self, params: List[SendParams], options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Send base coins to multiple addresses or with additional parameters.
+        """
+        return self.prepare_send(params, options).send()
+
+    def prepare_send(self, params: List[SendParams],
+                     options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Prepare to send with params.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareSend', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def send_native_tokens(
+            self, params: List[SendNativeTokenParams], options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Send native tokens.
+        """
+        return self.prepare_send_native_tokens(params, options).send()
+
+    def prepare_send_native_tokens(
+            self,
+            params: List[SendNativeTokenParams],
+            options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Send native tokens.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareSendNativeTokens', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def send_nft(self, params: List[SendNftParams],
+                 options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Send nft.
+        """
+        return self.prepare_send_nft(params, options).send()
+
+    def prepare_send_nft(self, params: List[SendNftParams],
+                         options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Send nft.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareSendNft', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def send_mana(
+            self, params: SendManaParams, options: Optional[TransactionOptions] = None) -> TransactionWithMetadata:
+        """Send mana.
+        """
+        return self.prepare_send_mana(params, options).send()
+
+    def prepare_send_mana(self, params: SendManaParams,
+                          options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Prepare to send mana.
+        """
+        prepared = PreparedTransactionData.from_dict(self._call_method(
+            'prepareSendMana', {
+                'params': params,
+                'options': options
+            }
+        ))
+        return PreparedTransaction(self, prepared)
+
+    def set_alias(self, alias: str):
+        """Set alias.
+        """
+        return self._call_method(
+            'setAlias', {
+                'alias': alias
+            }
+        )
+
+    def set_default_sync_options(self, options: SyncOptions):
+        """Set the fallback SyncOptions for wallet syncing.
+        If storage is enabled, will persist during restarts.
+        """
+        return self._call_method(
+            'setDefaultSyncOptions', {
+                'options': options
+            }
+        )
+
+    def sign_transaction(
+            self, prepared_transaction_data: PreparedTransactionData) -> SignedTransactionData:
+        """Sign a transaction.
+        """
+        return SignedTransactionData.from_dict(self._call_method(
+            'signTransaction', {
+                'preparedTransactionData': prepared_transaction_data
+            }
+        ))
 
-    # pylint: disable=redefined-builtin
-    @staticmethod
-    def __return_str_or_none(str):
-        if str:
-            return str
-        return None
+    def sign_and_submit_transaction(
+            self, prepared_transaction_data: PreparedTransactionData) -> TransactionWithMetadata:
+        """Validate the transaction, sign it, submit it to a node and store it in the wallet.
+        """
+        return TransactionWithMetadata.from_dict(self._call_method(
+            'signAndSubmitTransaction', {
+                'preparedTransactionData': prepared_transaction_data
+            }
+        ))
+
+    def submit_and_store_transaction(
+            self, signed_transaction_data: SignedTransactionData) -> TransactionWithMetadata:
+        """Submit and store transaction.
+        """
+        return TransactionWithMetadata.from_dict(self._call_method(
+            'submitAndStoreTransaction', {
+                'signedTransactionData': signed_transaction_data
+            }
+        ))
+
+    def sync(self, options: Optional[SyncOptions] = None) -> Balance:
+        """Sync the wallet by fetching new information from the nodes.
+        Will also reissue pending transactions and consolidate outputs if necessary.
+        A custom default can be set using set_default_sync_options.
+        """
+        return Balance.from_dict(self._call_method(
+            'sync', {
+                'options': options,
+            }
+        ))
```

## iota_sdk/__init__.py

```diff
@@ -1,42 +1,56 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from .client.client import Client, NodeIndexerAPI, ClientError
-from .client._high_level_api import GenerateAddressesOptions, GenerateAddressOptions
 from .external import *
+
+from .common import custom_encoder
+from .client.client import Client, NodeIndexerAPI
+from .client.common import ClientError
+from .client.responses import *
+from .client._high_level_api import GenerateAddressesOptions, GenerateAddressOptions
 from .utils import Utils
-from .wallet.wallet import Wallet, Account
+from .wallet.wallet import Wallet, WalletOptions
 from .wallet.common import WalletError
-from .wallet.sync_options import AccountSyncOptions, NftSyncOptions, AliasSyncOptions, SyncOptions
+from .wallet.sync_options import AccountSyncOptions, NftSyncOptions, SyncOptions, WalletSyncOptions
 from .secret_manager.secret_manager import *
 from .prefix_hex import *
 from .types.address import *
 from .types.balance import *
-from .types.block import *
+from .types.block.block import *
+from .types.block.body.basic import *
+from .types.block.body.type import *
+from .types.block.body.validation import *
+from .types.block.id import *
 from .types.block_builder_options import *
+from .types.block_issuer_key import *
 from .types.burn import *
 from .types.client_options import *
 from .types.common import *
+from .types.context_input import *
+from .types.decayed_mana import *
 from .types.event import *
 from .types.feature import *
+from .types.input import *
 from .types.irc_27 import *
 from .types.irc_30 import *
 from .types.filter_options import *
-from .types.input import *
 from .types.native_token import *
-from .types.network_info import *
 from .types.node_info import *
 from .types.output import *
 from .types.output_data import *
 from .types.output_id import *
+from .types.output_id_proof import *
+from .types.output_metadata import *
 from .types.output_params import *
 from .types.payload import *
 from .types.send_params import *
+from .types.slot import *
 from .types.token_scheme import *
-from .types.transaction import *
 from .types.transaction_data import *
+from .types.transaction_id import *
+from .types.transaction_metadata import *
 from .types.transaction_options import *
+from .types.transaction_with_metadata import *
 from .types.unlock import *
 from .types.unlock_condition import *
-from .types.utxo_changes import *
 from .types.consolidation_params import *
```

## Comparing `iota_sdk-1.1.4.dist-info/METADATA` & `iota_sdk-2.0.0a1.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: iota-sdk
-Version: 1.1.4
+Version: 2.0.0a1
 Requires-Dist: dacite >=1.8.1
 Requires-Dist: pyhumps >=3.8.0
 Summary: Python bindings for the IOTA SDK library
 Keywords: iota,client,wallet,transaction,python
 Home-Page: https://www.iota.org/
 Author: IOTA Stiftung
 License: Apache-2.0
@@ -27,15 +27,15 @@
   - [Wallet](#wallet-usage)
   - [Examples](#examples)
   - [API Reference](#api-reference)
   - [Learn More](#learn-more)
 
 ## Requirements
 
-- [Python 3.9+](https://www.python.org)
+- [Python 3.10+](https://www.python.org)
 - [pip ^21.x](https://pypi.org/project/pip)
 - `Rust` and `Cargo` to compile the binding. Install
   them [here](https://doc.rust-lang.org/cargo/getting-started/installation.html).
 
 ## Getting Started
 
 ### Install IOTA SDK via pip
@@ -105,15 +105,15 @@
 
 The following example creates a Client instance connected to the Shimmer Testnet, and retrieves the node's information by calling `Client.get_info()`, and then print the node's information.
 
 [examples/client/getting_started.py](examples/client/getting_started.py)
 
 ## Wallet Usage
 
-The following example will create a new Wallet Account  using a StrongholdSecretManager, and then print the account's information.
+The following example will create a new Wallet using a StrongholdSecretManager, and then print the wallet's information.
 
 [examples/wallet/getting_started.py](examples/wallet/getting_started.py)
 
 ## Examples
 
 You can use the provided code [examples](https://github.com/iotaledger/iota-sdk/blob/develop/bindings/python/examples) to acquainted with the IOTA SDK. You can use the following command to
 run any example:
@@ -121,15 +121,15 @@
 ```bash
 python3 example/[example file]
 ```
 
 - Where `[example file]` is the file name from the example folder. For example:
 
 ```bash
-python3 examples/client/00_get_info.py
+python3 examples/how_tos/client/get_info.py
 ```
 
 ## API Reference
 
 You can find the API reference for the Python bindings in the
 [IOTA Wiki](https://wiki.iota.org/shimmer/iota-sdk/references/python/iota_sdk/client/).
```

