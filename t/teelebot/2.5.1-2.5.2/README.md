# Comparing `tmp/teelebot-2.5.1-py3-none-any.whl.zip` & `tmp/teelebot-2.5.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,22 @@
-Zip file size: 43078 bytes, number of entries: 20
+Zip file size: 43522 bytes, number of entries: 20
 -rw-rw-rw-  2.0 fat     4279 b- defN 23-Dec-26 02:00 teelebot/__init__.py
 -rw-rw-rw-  2.0 fat      165 b- defN 23-May-08 17:02 teelebot/__main__.py
--rw-rw-rw-  2.0 fat    39084 b- defN 24-Feb-29 03:17 teelebot/bot.py
+-rw-rw-rw-  2.0 fat    43226 b- defN 24-May-07 00:52 teelebot/bot.py
 -rw-rw-rw-  2.0 fat    20714 b- defN 24-Apr-14 01:23 teelebot/buffer.py
 -rw-rw-rw-  2.0 fat     1771 b- defN 24-Feb-29 02:04 teelebot/common.py
 -rw-rw-rw-  2.0 fat    25637 b- defN 24-Feb-28 03:52 teelebot/handler.py
 -rw-rw-rw-  2.0 fat     1869 b- defN 23-Dec-25 01:59 teelebot/logger.py
 -rw-rw-rw-  2.0 fat     7236 b- defN 24-Feb-29 01:47 teelebot/metadata.py
 -rw-rw-rw-  2.0 fat      898 b- defN 23-Dec-26 02:32 teelebot/polling.py
 -rw-rw-rw-  2.0 fat     3997 b- defN 24-Feb-28 01:38 teelebot/request.py
--rw-rw-rw-  2.0 fat     4308 b- defN 24-Feb-28 03:22 teelebot/schedule.py
--rw-rw-rw-  2.0 fat      483 b- defN 24-Apr-14 01:33 teelebot/version.py
--rw-rw-rw-  2.0 fat     2796 b- defN 23-Dec-11 02:32 teelebot/webhook.py
--rw-rw-rw-  2.0 fat    35823 b- defN 24-Apr-14 01:49 teelebot-2.5.1.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     9964 b- defN 24-Apr-14 01:49 teelebot-2.5.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-14 01:49 teelebot-2.5.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       43 b- defN 24-Apr-14 01:49 teelebot-2.5.1.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat        9 b- defN 24-Apr-14 01:49 teelebot-2.5.1.dist-info/top_level.txt
--rw-rw-rw-  2.0 fat        2 b- defN 24-Apr-14 01:49 teelebot-2.5.1.dist-info/zip-safe
--rw-rw-r--  2.0 fat     1559 b- defN 24-Apr-14 01:49 teelebot-2.5.1.dist-info/RECORD
-20 files, 160729 bytes uncompressed, 40572 bytes compressed:  74.8%
+-rw-rw-rw-  2.0 fat     4408 b- defN 24-May-06 05:02 teelebot/schedule.py
+-rw-rw-rw-  2.0 fat      483 b- defN 24-May-06 09:29 teelebot/version.py
+-rw-rw-rw-  2.0 fat     2796 b- defN 24-May-06 08:42 teelebot/webhook.py
+-rw-rw-rw-  2.0 fat    35823 b- defN 24-May-07 00:59 teelebot-2.5.2.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     9964 b- defN 24-May-07 00:59 teelebot-2.5.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-07 00:59 teelebot-2.5.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       43 b- defN 24-May-07 00:59 teelebot-2.5.2.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        9 b- defN 24-May-07 00:59 teelebot-2.5.2.dist-info/top_level.txt
+-rw-rw-rw-  2.0 fat        2 b- defN 24-May-07 00:59 teelebot-2.5.2.dist-info/zip-safe
+-rw-rw-r--  2.0 fat     1559 b- defN 24-May-07 00:59 teelebot-2.5.2.dist-info/RECORD
+20 files, 164971 bytes uncompressed, 41016 bytes compressed:  75.1%
```

## zipnote {}

```diff
@@ -33,29 +33,29 @@
 
 Filename: teelebot/version.py
 Comment: 
 
 Filename: teelebot/webhook.py
 Comment: 
 
-Filename: teelebot-2.5.1.dist-info/LICENSE
+Filename: teelebot-2.5.2.dist-info/LICENSE
 Comment: 
 
-Filename: teelebot-2.5.1.dist-info/METADATA
+Filename: teelebot-2.5.2.dist-info/METADATA
 Comment: 
 
-Filename: teelebot-2.5.1.dist-info/WHEEL
+Filename: teelebot-2.5.2.dist-info/WHEEL
 Comment: 
 
-Filename: teelebot-2.5.1.dist-info/entry_points.txt
+Filename: teelebot-2.5.2.dist-info/entry_points.txt
 Comment: 
 
-Filename: teelebot-2.5.1.dist-info/top_level.txt
+Filename: teelebot-2.5.2.dist-info/top_level.txt
 Comment: 
 
-Filename: teelebot-2.5.1.dist-info/zip-safe
+Filename: teelebot-2.5.2.dist-info/zip-safe
 Comment: 
 
-Filename: teelebot-2.5.1.dist-info/RECORD
+Filename: teelebot-2.5.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## teelebot/bot.py

```diff
@@ -1,12 +1,12 @@
 # -*- coding:utf-8 -*-
 """
 @description: A Python-based Telegram Bot framework
 @creation date: 2019-08-13
-@last modification: 2024-02-29
+@last modification: 2024-05-06
 @author: Pluto (github:plutobell)
 """
 import time
 import sys
 import os
 import copy
 import types
@@ -120,47 +120,55 @@
         self.__plugin_bridge = config["plugin_bridge"]
         self.__non_plugin_list = config["non_plugin_list"]
         self.__start_time = int(time.time())
         self.__response_times = 0
         self.__response_chats = []
         self.__response_users = []
 
-        thread_pool_size = round(int(self._pool_size) * 2 / 3)
-        schedule_queue_size = int(self._pool_size) - thread_pool_size
+        thread_pool_size = int(self._pool_size)
+        if int(self._pool_size) >= 3:
+            thread_pool_size = round(int(self._pool_size) * 2 / 3)
+        schedule_queue_size = round(int(self._pool_size) - thread_pool_size)
+        if schedule_queue_size == 0: schedule_queue_size = int(self._pool_size)
+
         self.request = _Request(thread_pool_size, self._url, self._debug, self.__proxies)
         self.schedule = _Schedule(schedule_queue_size)
         self.buffer = _Buffer(int(self._buffer_size) * 1024 * 1024,
             self.__plugin_bridge.keys(), self.__plugin_dir)
         self.metadata = _Metadata(self.__plugin_dir)
 
         self.__thread_pool = ThreadPoolExecutor(
             max_workers=thread_pool_size)
         self.__timer_thread_pool = ThreadPoolExecutor(
             max_workers=int(self._pool_size) * 5)
+        plugin_init_pool_size = int(self._pool_size)
+        if int(self._pool_size) >= 3:
+            plugin_init_pool_size = round(int(self._pool_size) / 3)
         self.__plugin_init_pool = ThreadPoolExecutor(
-            max_workers=round(int(self._pool_size) / 3))
+            max_workers=plugin_init_pool_size)
 
         self.__plugin_info = config["plugin_info"]
         self.__non_plugin_info = config["non_plugin_info"]
 
         self.__method_name = ""
         self.__hide_info = config["hide_info"]
 
         self.__plugins_init_status_mutex = threading.RLock()
         self.__plugins_init_status = {}
         self.__plugin_init_furs_mutex = threading.RLock()
         self.__plugin_init_furs = {}
 
         del config
-        del thread_pool_size
         del schedule_queue_size
+        del plugin_init_pool_size
 
     def __del__(self):
         self.__thread_pool.shutdown(wait=True)
         self.__timer_thread_pool.shutdown(wait=True)
+        self.__plugin_init_pool.shutdown(wait=True)
         del self.request
         del self.schedule
         del self.buffer
         del self.metadata
         del self.__plugins_init_status
         del self.__plugin_init_furs
 
@@ -185,54 +193,61 @@
             _logger.debug(f"EXCEPTION - {str(fur.result())}")
 
     def _plugins_init(self, bot):
         """
         Execute the init func of the plugins
         """      
         for plugin, _ in self.__plugin_bridge.items():
-            with self.__plugins_init_status_mutex:
-                if plugin not in list(self.__plugins_init_status.keys()):
-                    continue
-                elif self.__plugins_init_status[plugin] == True:
-                    continue
-                elif self.__plugins_init_status[plugin] == False:
-                    with self.__plugin_init_furs_mutex:
-                        if isinstance(self.__plugin_init_furs[plugin], Future):
-                            if not self.__plugin_init_furs[plugin].done():
-                                _logger.warn(f"The plugin {plugin} is still initializing...")
+            try:
+                with self.__plugins_init_status_mutex:
+                    if plugin not in list(self.__plugins_init_status.keys()):
+                        continue
+                    elif self.__plugins_init_status[plugin] == True:
+                        continue
+                    elif self.__plugins_init_status[plugin] == False:
+                        with self.__plugin_init_furs_mutex:
+                            if isinstance(self.__plugin_init_furs[plugin], Future):
+                                if self.__plugin_init_furs[plugin].running():
+                                    _logger.warn(f"The plugin {plugin} is still initializing...")
+                                elif not self.__plugin_init_furs[plugin].done():
+                                    if not self.__hide_info:
+                                        _logger.info(f"Delay initialize {plugin} plugin: until a thread pool slot is available.")
                                 continue
 
-            module = self.__import_module(plugin)
-            pluginInitFunc = getattr(module, __plugin_init_func_name__, None)
+                module = self.__import_module(plugin)
+                pluginInitFunc = getattr(module, __plugin_init_func_name__, None)
 
-            if pluginInitFunc != None:
-                def __threadpool_exception(fur, plugin_name, status=False):
-                    if fur.exception() is not None:
-                        _logger.error(f"The plugin {plugin} initialization error.")
-                        _logger.debug(f"EXCEPTION - {str(fur.result())}")
-                    else:
-                        self.__update_plugin_init_status(plugin_name=plugin_name, status=status)
+                if pluginInitFunc != None:
+                    def __threadpool_exception(fur, plugin_name, status=False):
+                        if fur.exception() is not None:
+                            _logger.error(f"The plugin {plugin} initialization error.")
+                            _logger.debug(f"EXCEPTION - {str(fur.result())}")
+                        else:
+                            self.__update_plugin_init_status(plugin_name=plugin_name, status=status)
+                            if not self.__hide_info:
+                                _logger.info(f"The plugin {plugin_name} initialization completed.")
+
+                    if self.__plugin_init_pool._work_queue.qsize() >= self.__plugin_init_pool._max_workers:
                         if not self.__hide_info:
-                            _logger.info(f"The plugin {plugin_name} initialization completed.")
+                            _logger.info(f"Delay initialize {plugin} plugin: until a thread pool slot is available.")
 
-                try:
                     fur = self.__plugin_init_pool.submit(pluginInitFunc, bot)
                     callback_with_args = functools.partial(__threadpool_exception, plugin_name=plugin, status=True)
                     fur.add_done_callback(callback_with_args)
 
                     with self.__plugin_init_furs_mutex:
                         if plugin in list(self.__plugin_init_furs.keys()):
                             if isinstance(self.__plugin_init_furs[plugin], Future):
                                 if not self.__plugin_init_furs[plugin].done():
                                     self.__plugin_init_furs[plugin].cancel()
                             self.__plugin_init_furs[plugin] = fur
 
-                except Exception as e:
-                    _logger.error(f"Failed to initialize plugin {plugin}: {str(e)}")
-                    traceback.print_exc()
+            except Exception as e:
+                _logger.error(f"Failed to initialize plugin {plugin}: {str(e)}")
+                traceback.print_exc()
 
     def _update_plugins_init_status(self):
         """
         Update plugins init status
         """
         new_status_dict = {}
 
@@ -284,32 +299,39 @@
         return Module
 
     def __update_plugin(self, plugin_name, as_plugin=True):
         """
         Hot update plugin
         """
 
-        if as_plugin:
-            plugin_info = self.__plugin_info
-        else:
-            plugin_info = self.__non_plugin_info
+        try:
+            if as_plugin:
+                plugin_info = self.__plugin_info
+            else:
+                plugin_info = self.__non_plugin_info
 
-        plugin_uri = self.path_converter(
-            f'{self.__plugin_dir}{plugin_name}{os.sep}{plugin_name}.py')
-        now_mtime = os.stat(plugin_uri).st_mtime
-        # print(now_mtime, self.__plugin_info[plugin_name])
-        if now_mtime != plugin_info[plugin_name]:  # Plugin hot update
-            if os.path.exists(self.path_converter(f'{self.__plugin_dir}{plugin_name}{os.sep}__pycache__')):
-                shutil.rmtree(self.path_converter(f'{self.__plugin_dir}{plugin_name}{os.sep}__pycache__'))
-            plugin_info[plugin_name] = now_mtime
-            Module = self.__import_module(plugin_name)
-            importlib.reload(Module)
-            self.__update_plugin_init_status(plugin_name=plugin_name, status=False)
-            if not self.__hide_info:
-                _logger.info(f"The plugin {plugin_name} has been updated.")
+            plugin_uri = self.path_converter(
+                f'{self.__plugin_dir}{plugin_name}{os.sep}{plugin_name}.py')
+            now_mtime = os.stat(plugin_uri).st_mtime
+            # print(now_mtime, self.__plugin_info[plugin_name])
+            if now_mtime != plugin_info[plugin_name]:  # Plugin hot update
+                if os.path.exists(self.path_converter(f'{self.__plugin_dir}{plugin_name}{os.sep}__pycache__')):
+                    shutil.rmtree(self.path_converter(f'{self.__plugin_dir}{plugin_name}{os.sep}__pycache__'))
+                plugin_info[plugin_name] = now_mtime
+
+                Module = self.__import_module(plugin_name)
+                importlib.reload(Module)
+
+                self.__update_plugin_init_status(plugin_name=plugin_name, status=False)
+                if not self.__hide_info:
+                    _logger.info(f"The plugin {plugin_name} has been updated.")
+
+        except Exception as e:
+            _logger.error(f"Failed to update plugin {plugin_name}: {str(e)}")
+            traceback.print_exc()
 
     def __load_plugin(self, now_plugin_info, as_plugin=True,
         now_plugin_bridge={}, now_non_plugin_list=[]):
         """
         Dynamic loading plugin
         """
         if as_plugin:
@@ -461,15 +483,15 @@
             message_type = "caption"
         else:
             message["message_type"] = "unknown"
             message_type = "unknown"
 
         return message_type, message
 
-    def __logging_for_pluginRun(self, message, plugin):
+    def __logging_for_pluginRun(self, message, plugin, update_id):
         title = ""  # INFO Log
         user_name = ""
         from_id = ""
 
         if message["chat"]["type"] == "private":
             if "first_name" in message["chat"].keys():
                 title += message["chat"]["first_name"]
@@ -500,21 +522,23 @@
                     user_name += " " + message["from"]["last_name"]
                 else:
                     user_name += message["from"]["last_name"]
 
         if message["message_type"] == "unknown":
             if not self.__hide_info:
                 _logger.info(
+                    f"[{update_id}]" + \
                     "From:" + title + "(" + str(message["chat"]["id"]) + ") - " + \
                     "User:" + user_name + "(" + str(from_id) + ") - " + \
                     "Plugin:" + "" + " - " + \
                     "Type:" + message["message_type"])
         else:
             if not self.__hide_info:
                 _logger.info(
+                    f"[{update_id}] " + \
                     "From:" + title + "(" + str(message["chat"]["id"]) + ") - " + \
                     "User:" + user_name + "(" + str(from_id) + ") - " + \
                     "Plugin:" + str(plugin) + " - " + \
                     "Type:" + message["message_type"])
 
     def __make_token(self, len=64):
         """
@@ -568,19 +592,19 @@
             plugin_bridge = self.__control_plugin( # pluginctl control
                 self.__plugin_bridge, message["chat"]["type"], message["chat"]["id"])
 
             message_type = ""
             message_type, message = self.__mark_message_for_pluginRun(message) # Category tagging messages
 
             if message_type == "unknown":
-                self.__logging_for_pluginRun(message, "unknown")
+                self.__logging_for_pluginRun(message, "unknown", message["update_id"])
                 return
 
         except Exception as e:
-            _logger.error(f"Run plugin error: {e}")
+            _logger.error(f"[{message['update_id']}] Run plugin error: {e}")
             traceback.print_exc()
             return
 
         for plugin, command in plugin_bridge.items():
             try:
                 if message_type == "query":
                     if command in ["", " ", None]:
@@ -589,52 +613,52 @@
                 if message.get(message_type)[:len(command)] == command:
                     plugin_requires_version = ""
                     ok, data = self.metadata.read(plugin_name=plugin)
                     if ok:
                         plugin_requires_version = data.get("Requires-teelebot", {})
                         plugin_requires_version = plugin_requires_version.replace(">", "").replace("<", "").replace("=", "")
                         if plugin_requires_version in [None, "", " "]:
-                            _logger.warn(f"Skip run {plugin} plugin: failed to get the version of the plugin")
+                            _logger.warn(f"[{message['update_id']}] Skip run {plugin} plugin: failed to get the version of the plugin")
                             continue
                     else:
-                        _logger.warn(f"Skip run {plugin} plugin: failed to get information about the plugin (error: {data})")
+                        _logger.warn(f"[{message['update_id']}] Skip run {plugin} plugin: failed to get information about the plugin (error: {data})")
                         continue
                     if plugin_requires_version > self.version:
-                        _logger.warn(f"Skip run {plugin} plugin: the plugin requires teelebot version >= {plugin_requires_version}")
+                        _logger.warn(f"[{message['update_id']}] Skip run {plugin} plugin: the plugin requires teelebot version >= {plugin_requires_version}")
                         continue
 
                     no_plugin_path = f'{self.__plugin_dir}{plugin}.py'
                     if os.path.exists(no_plugin_path):
-                        _logger.warn(f"Skip run {plugin} plugin: there is a module named '{plugin}.py' under the plugin dir with the same name as plugin {plugin} ({no_plugin_path})")
+                        _logger.warn(f"[{message['update_id']}] Skip run {plugin} plugin: there is a module named '{plugin}.py' under the plugin dir with the same name as plugin {plugin} ({no_plugin_path})")
                         continue
 
-                    try:
+                    def pluginFuncWrap(bot, message, plugin):
                         module = self.__import_module(plugin)
                         pluginFunc = getattr(module, plugin)
-                        fur = self.__thread_pool.submit(pluginFunc, bot, message)
-                        fur.add_done_callback(self.__threadpool_exception)
-                    except Exception as e:
-                        _logger.error(f"Run {plugin} plugin error: {str(e)}")
-                        traceback.print_exc()
+                        self.__logging_for_pluginRun(message, plugin, message["update_id"])
+                        pluginFunc(bot, message)
+                    fur = self.__thread_pool.submit(pluginFuncWrap, bot, message, plugin)
+                    fur.add_done_callback(self.__threadpool_exception)
 
+                    if self.__thread_pool._work_queue.qsize() >= self.__thread_pool._max_workers:
+                        if not self.__hide_info:
+                            _logger.info(f"[{message['update_id']}] Delay run {plugin} plugin: until a thread pool slot is available.")
+            
                     self.__response_times += 1
 
                     if message["chat"]["type"] != "private" and \
                     message["chat"]["id"] not in self.__response_chats:
                         self.__response_chats.append(message["chat"]["id"])
                     if message["from"]["id"] not in self.__response_users:
                         if not message["from"]["is_bot"]:
                             self.__response_users.append(message["from"]["id"])
 
-                    self.__logging_for_pluginRun(message, plugin)
-
             except Exception as e:
-                _logger.error(f"Run {plugin} plugin error: {e}")
+                _logger.error(f"[{message['update_id']}] Run {plugin} plugin error: {e}")
                 traceback.print_exc()
-                continue
 
     def _washUpdates(self, results):
         """
         Cleaning the message queue,
         The results should be a list
         """
         if not results:
@@ -642,15 +666,15 @@
         elif len(results) < 1:
             return None
         update_ids = []
         messages = []
         for result in results:
             if "update_id" not in result.keys():
                 return None
-            update_ids.append(result["update_id"])
+            update_ids.append(result.get("update_id"))
             query_or_message = ""
             if result.get("inline_query"):
                 query_or_message = "inline_query"
             elif result.get("callback_query"):
                 query_or_message = "callback_query"
             elif result.get("my_chat_member"):
                 query_or_message = "my_chat_member"
@@ -658,52 +682,58 @@
                 query_or_message = "chat_member"
             elif result.get("chat_join_request"):
                 query_or_message = "chat_join_request"
             elif result.get("edited_message"):
                 query_or_message = "edited_message"
             elif result.get("message"):
                 query_or_message = "message"
-            update_ids.append(result.get("update_id"))
 
             if query_or_message == "inline_query":
                 inline_query = result.get(query_or_message)
+                inline_query["update_id"] = result["update_id"]
                 inline_query["message_id"] = result["update_id"]
                 inline_query["chat"] = inline_query.get("from")
                 inline_query["chat"].pop("language_code")
                 inline_query["chat"].pop("is_bot")
                 inline_query["chat"]["type"] = "private"
                 inline_query["text"] = ""
                 inline_query["query"] = f'{self.__inline_mode_prefix}{inline_query["query"]}' # Inline Mode Plugin Prefix
                 messages.append(inline_query)
             elif query_or_message == "callback_query":
                 callback_query = result.get(query_or_message).get("message")
+                callback_query["update_id"] = result["update_id"]
                 callback_query["click_user"] = result.get(query_or_message)[
                     "from"]
                 callback_query["callback_query_id"] = result.get(
                     query_or_message).get("id")
                 callback_query["callback_query_data"] = result.get(
                     query_or_message).get("data")
                 messages.append(callback_query)
             elif query_or_message == "my_chat_member":
                 my_chat_member = result.get(query_or_message)
+                my_chat_member["update_id"] = result["update_id"]
                 my_chat_member["message_id"] = result.get("update_id")
                 my_chat_member["my_chat_member_id"] = result.get("update_id")
                 messages.append(my_chat_member)
             elif query_or_message == "chat_member":
                 chat_member = result.get(query_or_message)
+                chat_member["update_id"] = result["update_id"]
                 chat_member["message_id"] = result.get("update_id")
                 chat_member["chat_member_id"] = result.get("update_id")
                 messages.append(chat_member)
             elif query_or_message == "chat_join_request":
                 chat_join_request = result.get(query_or_message)
+                chat_join_request["update_id"] = result["update_id"]
                 chat_join_request["message_id"] = result.get("update_id")
                 chat_join_request["chat_join_request_id"] = result.get("update_id")
                 messages.append(chat_join_request)
             else:
-                messages.append(result.get(query_or_message))
+                message_dict = result.get(query_or_message)
+                message_dict["update_id"] = result["update_id"]
+                messages.append(message_dict)
 
         if len(update_ids) >= 1:
             self._offset = max(update_ids) + 1
             return messages
         else:
             return None
     
@@ -712,44 +742,81 @@
         """
         Timed deletion of a message, time range: [0, 900], in seconds
         """
         if time_gap < 0 or time_gap > 900:
             return "time_gap_error"
         else:
             def message_deletor_func(time_gap, chat_id, message_id):
+                if not self.__hide_info:
+                    _logger.info(f"[{chat_id}:{message_id}][{time_gap}s] Message deleting...")
+
                 time.sleep(int(time_gap))
-                self.deleteMessage(chat_id=chat_id, message_id=message_id)
+                ok = self.deleteMessage(chat_id=chat_id, message_id=message_id)
+                
+                if ok:
+                    if not self.__hide_info:
+                        _logger.info(f"[{chat_id}:{message_id}][{time_gap}s] Message deleted.")
+                else:
+                    _logger.error(f"[{chat_id}:{message_id}][{time_gap}s] Message deletion error.")
 
             if time_gap == 0:
                 message_deletor_func(chat_id, message_id)
             else:
+                if self.__timer_thread_pool._work_queue.qsize() >= self.__timer_thread_pool._max_workers:
+                    if not self.__hide_info:
+                        _logger.info(f"[{chat_id}:{message_id}][{time_gap}s] Delay delete message: until a thread pool slot is available.")
+
                 fur = self.__timer_thread_pool.submit(
                     message_deletor_func, time_gap, chat_id, message_id)
                 fur.add_done_callback(self.__threadpool_exception)
 
             return "ok"
 
-    def timer(self, time_gap: int, func: Callable[..., None], args: tuple) -> str:
+    def timer(self, time_gap: int, func: Callable[..., None], *args: tuple) -> str:
         """
         Single timer, time range: [0, 900], unit seconds
         """
         if time_gap < 0 or time_gap > 900:
             return "time_gap_error"
-        elif type(args) is not tuple:
-            return "args_must_be_tuple"
         else:
-            def timer_func(time_gap, func, args):
+            def timer_func(time_gap, func, *args):
+                if not self.__hide_info:
+                    _logger.info(f"[{id(timer_func)}][{time_gap}s] Timer executing...")
+
                 time.sleep(int(time_gap))
-                func(*args)
+                try:
+                    func(*args)
+
+                    if not self.__hide_info:
+                        _logger.info(f"[{id(timer_func)}][{time_gap}s] Timer executed.")
+                except Exception as e:
+                    _logger.error(f"[{id(timer_func)}][{time_gap}s] Timer execution error: {e}")
+                    traceback.print_exc()
+
+            if len(args) == 1 and isinstance(args[0], tuple):
+                args = args[0]
 
             if time_gap == 0:
-                func(args)
+                if not self.__hide_info:
+                    _logger.info(f"[{id(timer_func)}][{time_gap}s] Timer executing...")
+                try:
+                    func(*args)
+
+                    if not self.__hide_info:
+                        _logger.info(f"[{id(timer_func)}][{time_gap}s] Timer executed.")
+                except Exception as e:
+                    _logger.error(f"[{id(timer_func)}][{time_gap}s] Timer execution error: {e}")
+                    traceback.print_exc()
             else:
+                if self.__timer_thread_pool._work_queue.qsize() >= self.__timer_thread_pool._max_workers:
+                    if not self.__hide_info:
+                        _logger.info(f"[{id(timer_func)}][{time_gap}s] Delay execution timer: until a thread pool slot is available.")
+
                 fur = self.__timer_thread_pool.submit(
-                    timer_func, time_gap, func, args)
+                    timer_func, time_gap, func, *args)
                 fur.add_done_callback(self.__threadpool_exception)
 
             return "ok"
 
     def path_converter(self, path: str) -> str:
         """
         Convert URI according to operating system
```

## teelebot/schedule.py

```diff
@@ -1,11 +1,11 @@
 # -*- coding:utf-8 -*-
 '''
 @creation date: 2019-11-15
-@last modification: 2024-02-28
+@last modification: 2024-05-06
 '''
 import threading
 import traceback
 
 from uuid import uuid4
 from typing import Tuple, Callable
 
@@ -19,30 +19,33 @@
         self.__queue_size = queue_size
         self.__queue_mutex = threading.RLock()
         self.__queue = {}
 
     def __del__(self):
         del self.__queue
 
-    def __create(self, gap, func, args):
+    def __create(self, gap, func, *args):
         class RepeatingTimer(threading.Timer):
             def run(self):
                 while not self.finished.is_set():
                     self.function(*self.args, **self.kwargs)
                     self.finished.wait(self.interval)
         try:
+            if len(args) == 1 and isinstance(args[0], tuple):
+                args = args[0]
+
             t = RepeatingTimer(gap, func, args)
             t.setDaemon(True)
             return True, t
         except Exception as e:
             _logger.error(str(e))
             traceback.print_exc()
             return False, str(e)
 
-    def add(self, gap: int, func: Callable[..., None], args: tuple) -> Tuple[bool, str]:
+    def add(self, gap: int, func: Callable[..., None], *args: tuple) -> Tuple[bool, str]:
         """
         Add schedule task
         """
         def __short_uuid():
             uuidChars = ("a", "b", "c", "d", "e", "f",
                     "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s",
                     "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5",
@@ -56,15 +59,15 @@
                 x = int(sub,16)
                 uid += uuidChars[x % 0x3E]
             return uid
 
         if len(self.__queue) == self.__queue_size:
             return False, "Full"
 
-        ok, t = self.__create(gap, func, args)
+        ok, t = self.__create(gap, func, *args)
         if ok:
             t.start()
             uid = __short_uuid()
             with self.__queue_mutex:
                 self.__queue[uid] = t
 
             return True, uid
```

## teelebot/version.py

```diff
@@ -1,16 +1,16 @@
 # -*- coding:utf-8 -*-
 """
 @description: A Python-based Telegram Bot framework
 @creation date: 2019-11-15
-@last modification: 2024-04-14
+@last modification: 2024-05-06
 @author: Pluto (github:plutobell)
 """
 
-__version__ = "2.5.1"
+__version__ = "2.5.2"
 
 __author__ = "Pluto"
 __email__ = "hi@ojoll.com"
 __blog__ = "https://ojoll.com"
 __github__ = "https://github.com/plutobell/teelebot"
 __description__ = "teelebot is a Python-based Telegram Bot framework with a plugin system that supports hot reload and hot loading."
```

## Comparing `teelebot-2.5.1.dist-info/LICENSE` & `teelebot-2.5.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `teelebot-2.5.1.dist-info/METADATA` & `teelebot-2.5.2.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: teelebot
-Version: 2.5.1
+Version: 2.5.2
 Summary: teelebot is a Python-based Telegram Bot framework with a plugin system that supports hot reload and hot loading.
 Home-page: https://ojoll.com
 Author: Pluto
 Author-email: hi@ojoll.com
 License: GPLv3
 Keywords: teelebot telegram bot telegram bot api telegram
 Classifier: Programming Language :: Python :: 3
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: teelebot Version: 2.5.1 Summary: teelebot is a
+Metadata-Version: 2.1 Name: teelebot Version: 2.5.2 Summary: teelebot is a
 Python-based Telegram Bot framework with a plugin system that supports hot
 reload and hot loading. Home-page: https://ojoll.com Author: Pluto Author-
 email: hi@ojoll.com License: GPLv3 Keywords: teelebot telegram bot telegram bot
 api telegram Classifier: Programming Language :: Python :: 3 Classifier:
 Operating System :: OS Independent Classifier: License :: OSI Approved :: GNU
 General Public License v3 (GPLv3) Requires-Python: >=3.6 Description-Content-
 Type: text/markdown License-File: LICENSE Requires-Dist: requests
```

## Comparing `teelebot-2.5.1.dist-info/RECORD` & `teelebot-2.5.2.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 teelebot/__init__.py,sha256=kAq6jlmvcxByifHdMlapLN-el_IL9h6pIkggxzvnn8c,4279
 teelebot/__main__.py,sha256=_j6f3hj0VtlcCsabcIvuS0uBI0NVbCVwmH138tqYGFo,165
-teelebot/bot.py,sha256=ZNFL1aGwRVz2PVtQXJ0EjIJP6h5nucvR4si2e3sr49U,39084
+teelebot/bot.py,sha256=-U49Apfm4YuQ7xghLxijoXXxERIscYdCYVfefS3fiJ4,43226
 teelebot/buffer.py,sha256=payjL7pxJRn1rszs5IFq7DHEpB261dny0fO16Ko86pE,20714
 teelebot/common.py,sha256=ltYHihcrxrYVtjvBLQ8rXjEpO-4pfqJ6w_oqrTXK1ys,1771
 teelebot/handler.py,sha256=jxrMraJz5lh5bZJ5jKZsBjMgSMfeEfV8Krc5quYdghQ,25637
 teelebot/logger.py,sha256=I7UJxLdxRz5HxzwEgBPf_gILZuDlPCLwZPxioIahS2A,1869
 teelebot/metadata.py,sha256=e1UR2Nz2eP9hoLByb_j-4byPd6vpNk1SIN52o04PmYM,7236
 teelebot/polling.py,sha256=p_JO9TOgyTifTbZEcGpPRYAHp4MyoFkJ3wY0-D7yC4Q,898
 teelebot/request.py,sha256=HenftV-3frTxNks1HjMVQCCYo8SeDA2Jhhe8T1xpjD4,3997
-teelebot/schedule.py,sha256=0jwTwu2iewO0y9nWW86uxKTGeP42FfSFyKIxjW25Znc,4308
-teelebot/version.py,sha256=hCsg57E8rdw2vAgHxV7TgsBa13HkGKhrw8Y160y9SLo,483
+teelebot/schedule.py,sha256=K4-PpROpldz8YnGebW8sFXILViB66KQgtopT98SseE4,4408
+teelebot/version.py,sha256=ng676aTzzHbOcMVW8OuonJUdIlVnV97FzRuqf64_8M0,483
 teelebot/webhook.py,sha256=5cd9GPAv4_LHTxDZC9s0NsKKq5eZGx_3L1i6Bl4lbig,2796
-teelebot-2.5.1.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-teelebot-2.5.1.dist-info/METADATA,sha256=ilgfCjAdaMdmoJ-JaN9SrUH2K3DK4MtCfKURfQ6exXY,9964
-teelebot-2.5.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-teelebot-2.5.1.dist-info/entry_points.txt,sha256=IZHSiwFVJ6BPPTW3j7I1i34AESCOPaTYiC1qoWfpj6k,43
-teelebot-2.5.1.dist-info/top_level.txt,sha256=vMgTMVZJd4P3KjMwVpgWfIUvNLYKqfyHO4Cul-YwuyQ,9
-teelebot-2.5.1.dist-info/zip-safe,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
-teelebot-2.5.1.dist-info/RECORD,,
+teelebot-2.5.2.dist-info/LICENSE,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+teelebot-2.5.2.dist-info/METADATA,sha256=348Zpn1uJ5Ktt-T6WILFFxqEUVLb_6NS4kbbgloVNL8,9964
+teelebot-2.5.2.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+teelebot-2.5.2.dist-info/entry_points.txt,sha256=IZHSiwFVJ6BPPTW3j7I1i34AESCOPaTYiC1qoWfpj6k,43
+teelebot-2.5.2.dist-info/top_level.txt,sha256=vMgTMVZJd4P3KjMwVpgWfIUvNLYKqfyHO4Cul-YwuyQ,9
+teelebot-2.5.2.dist-info/zip-safe,sha256=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN_XKdLCPjaYaY,2
+teelebot-2.5.2.dist-info/RECORD,,
```

