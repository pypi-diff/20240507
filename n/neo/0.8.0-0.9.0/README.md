# Comparing `tmp/neo-0.8.0.tar.gz` & `tmp/neo-0.9.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/neo-0.8.0.tar", last modified: Mon Sep 30 09:09:32 2019, max compression
+gzip compressed data, was "dist/neo-0.9.0.tar", last modified: Tue Nov 10 15:42:06 2020, max compression
```

## Comparing `neo-0.8.0.tar` & `neo-0.9.0.tar`

### file list

```diff
@@ -1,260 +1,274 @@
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:32.000000 neo-0.8.0/
--rw-r--r--   0 andrew     (503) staff       (20)     1501 2019-07-04 19:36:11.000000 neo-0.8.0/LICENSE.txt
--rw-r--r--   0 andrew     (503) staff       (20)      199 2019-07-04 19:36:11.000000 neo-0.8.0/MANIFEST.in
--rw-r--r--   0 andrew     (503) staff       (20)     5201 2019-09-30 09:09:32.000000 neo-0.8.0/PKG-INFO
--rw-r--r--   0 andrew     (503) staff       (20)     3477 2019-07-04 19:36:11.000000 neo-0.8.0/README.rst
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/doc/
--rw-r--r--   0 andrew     (503) staff       (20)     3124 2019-01-17 13:14:44.000000 neo-0.8.0/doc/Makefile
--rw-r--r--   0 andrew     (503) staff       (20)     3069 2019-01-17 13:14:44.000000 neo-0.8.0/doc/make.bat
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/doc/old_stuffs/
--rw-r--r--   0 andrew     (503) staff       (20)     4018 2019-07-04 19:36:11.000000 neo-0.8.0/doc/old_stuffs/gif2011workshop.rst
--rw-r--r--   0 andrew     (503) staff       (20)      910 2019-07-04 19:36:11.000000 neo-0.8.0/doc/old_stuffs/specific_annotations.rst
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/doc/source/
--rw-r--r--   0 andrew     (503) staff       (20)      132 2019-09-30 08:21:13.000000 neo-0.8.0/doc/source/api_reference.rst
--rw-r--r--   0 andrew     (503) staff       (20)     3247 2019-09-30 08:38:26.000000 neo-0.8.0/doc/source/authors.rst
--rw-r--r--   0 andrew     (503) staff       (20)     7023 2019-09-25 12:29:10.000000 neo-0.8.0/doc/source/conf.py
--rw-r--r--   0 andrew     (503) staff       (20)    12046 2019-09-30 08:21:13.000000 neo-0.8.0/doc/source/core.rst
--rw-r--r--   0 andrew     (503) staff       (20)    10484 2019-09-30 09:05:38.000000 neo-0.8.0/doc/source/developers_guide.rst
--rw-r--r--   0 andrew     (503) staff       (20)    10820 2019-09-30 08:31:24.000000 neo-0.8.0/doc/source/developers_guide.rst.orig
--rw-r--r--   0 andrew     (503) staff       (20)      362 2019-09-25 12:29:10.000000 neo-0.8.0/doc/source/examples.rst
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/doc/source/images/
--rw-r--r--   0 andrew     (503) staff       (20)    60651 2019-01-17 13:14:44.000000 neo-0.8.0/doc/source/images/base_schematic.png
--rw-r--r--   0 andrew     (503) staff       (20)     7754 2019-07-04 19:36:11.000000 neo-0.8.0/doc/source/images/generate_diagram.py
--rw-r--r--   0 andrew     (503) staff       (20)   147943 2019-01-17 13:14:44.000000 neo-0.8.0/doc/source/images/multi_segment_diagram.png
--rw-r--r--   0 andrew     (503) staff       (20)    69457 2019-01-17 13:14:44.000000 neo-0.8.0/doc/source/images/multi_segment_diagram_spiketrain.png
--rw-r--r--   0 andrew     (503) staff       (20)   175903 2019-01-17 13:14:44.000000 neo-0.8.0/doc/source/images/neo_UML_French_workshop.png
--rw-r--r--   0 andrew     (503) staff       (20)   411264 2019-01-17 13:14:44.000000 neo-0.8.0/doc/source/images/neologo.png
--rw-r--r--   0 andrew     (503) staff       (20)     6703 2019-01-17 13:14:44.000000 neo-0.8.0/doc/source/images/neologo_light.png
--rw-r--r--   0 andrew     (503) staff       (20)   479096 2019-08-28 15:13:05.000000 neo-0.8.0/doc/source/images/neologo_optical.png
--rw-r--r--   0 andrew     (503) staff       (20)   276776 2019-01-17 13:14:44.000000 neo-0.8.0/doc/source/images/simple_generated_diagram.png
--rw-r--r--   0 andrew     (503) staff       (20)     3199 2019-09-30 08:56:46.000000 neo-0.8.0/doc/source/index.rst
--rw-r--r--   0 andrew     (503) staff       (20)     2021 2019-09-30 08:59:00.000000 neo-0.8.0/doc/source/install.rst
--rw-r--r--   0 andrew     (503) staff       (20)    12890 2019-09-30 08:59:36.000000 neo-0.8.0/doc/source/io.rst
--rw-r--r--   0 andrew     (503) staff       (20)     6038 2019-09-30 09:01:53.000000 neo-0.8.0/doc/source/io_developers_guide.rst
--rw-r--r--   0 andrew     (503) staff       (20)     8194 2019-09-26 09:30:09.000000 neo-0.8.0/doc/source/rawio.rst
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/doc/source/releases/
--rw-r--r--   0 andrew     (503) staff       (20)     6023 2019-09-30 09:02:13.000000 neo-0.8.0/doc/source/releases/0.5.0.rst
--rw-r--r--   0 andrew     (503) staff       (20)     1197 2019-07-04 19:36:11.000000 neo-0.8.0/doc/source/releases/0.5.1.rst
--rw-r--r--   0 andrew     (503) staff       (20)      843 2019-07-04 19:36:11.000000 neo-0.8.0/doc/source/releases/0.5.2.rst
--rw-r--r--   0 andrew     (503) staff       (20)     1973 2019-09-30 09:02:31.000000 neo-0.8.0/doc/source/releases/0.6.0.rst
--rw-r--r--   0 andrew     (503) staff       (20)     1050 2019-07-04 19:36:11.000000 neo-0.8.0/doc/source/releases/0.7.0.rst
--rw-r--r--   0 andrew     (503) staff       (20)      411 2019-09-25 12:29:10.000000 neo-0.8.0/doc/source/releases/0.7.1.rst
--rw-r--r--   0 andrew     (503) staff       (20)      273 2019-09-25 12:29:10.000000 neo-0.8.0/doc/source/releases/0.7.2.rst
--rw-r--r--   0 andrew     (503) staff       (20)     4633 2019-09-30 09:07:36.000000 neo-0.8.0/doc/source/releases/0.8.0.rst
--rw-r--r--   0 andrew     (503) staff       (20)     4616 2019-09-26 12:35:09.000000 neo-0.8.0/doc/source/releases/0.8.0.rst.orig
--rw-r--r--   0 andrew     (503) staff       (20)     7657 2019-07-04 19:36:11.000000 neo-0.8.0/doc/source/usecases.rst
--rw-r--r--   0 andrew     (503) staff       (20)     2565 2019-09-30 09:03:38.000000 neo-0.8.0/doc/source/whatisnew.rst
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/examples/
--rw-r--r--   0 andrew     (503) staff       (20)     4906 2019-07-04 19:36:11.000000 neo-0.8.0/examples/generated_data.py
--rw-r--r--   0 andrew     (503) staff       (20)     1625 2019-09-18 13:09:31.000000 neo-0.8.0/examples/hbp_d571_example.py
--rw-r--r--   0 andrew     (503) staff       (20)     2024 2019-09-18 15:26:23.000000 neo-0.8.0/examples/hbp_d571_example2.py
--rw-r--r--   0 andrew     (503) staff       (20)      963 2019-09-30 08:21:13.000000 neo-0.8.0/examples/imageseq.py
--rw-r--r--   0 andrew     (503) staff       (20)     1142 2019-07-04 19:36:11.000000 neo-0.8.0/examples/read_files_neo_io.py
--rw-r--r--   0 andrew     (503) staff       (20)     3254 2019-07-23 11:15:45.000000 neo-0.8.0/examples/read_files_neo_rawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1669 2019-07-23 11:15:45.000000 neo-0.8.0/examples/read_proxy_with_lazy_load.py
--rw-r--r--   0 andrew     (503) staff       (20)     1105 2019-09-30 08:21:13.000000 neo-0.8.0/examples/roi_demo.py
--rw-r--r--   0 andrew     (503) staff       (20)     1185 2019-07-23 11:15:45.000000 neo-0.8.0/examples/simple_plot_with_matplotlib.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/neo/
--rw-r--r--   0 andrew     (503) staff       (20)      352 2019-07-04 19:36:11.000000 neo-0.8.0/neo/__init__.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/neo/core/
--rw-r--r--   0 andrew     (503) staff       (20)     1872 2019-09-30 08:21:13.000000 neo-0.8.0/neo/core/__init__.py
--rw-r--r--   0 andrew     (503) staff       (20)    21398 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/analogsignal.py
--rw-r--r--   0 andrew     (503) staff       (20)    15618 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/baseneo.py
--rw-r--r--   0 andrew     (503) staff       (20)    10992 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/basesignal.py
--rw-r--r--   0 andrew     (503) staff       (20)     5206 2019-09-30 08:21:13.000000 neo-0.8.0/neo/core/block.py
--rw-r--r--   0 andrew     (503) staff       (20)     9067 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/channelindex.py
--rw-r--r--   0 andrew     (503) staff       (20)    26403 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/container.py
--rw-r--r--   0 andrew     (503) staff       (20)    17626 2019-09-30 08:21:13.000000 neo-0.8.0/neo/core/dataobject.py
--rw-r--r--   0 andrew     (503) staff       (20)    13823 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/epoch.py
--rw-r--r--   0 andrew     (503) staff       (20)    13727 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/event.py
--rw-r--r--   0 andrew     (503) staff       (20)     8125 2019-09-30 08:21:13.000000 neo-0.8.0/neo/core/imagesequence.py
--rw-r--r--   0 andrew     (503) staff       (20)     6760 2019-09-25 13:58:52.000000 neo-0.8.0/neo/core/imagesequence_BACKUP_79699.py
--rw-------   0 andrew     (503) staff       (20)     7637 2019-09-25 13:58:52.000000 neo-0.8.0/neo/core/imagesequence_BASE_79699.py
--rw-------   0 andrew     (503) staff       (20)     5223 2019-09-25 13:58:52.000000 neo-0.8.0/neo/core/imagesequence_LOCAL_79699.py
--rw-------   0 andrew     (503) staff       (20)     8113 2019-09-25 13:58:52.000000 neo-0.8.0/neo/core/imagesequence_REMOTE_79699.py
--rw-r--r--   0 andrew     (503) staff       (20)    19517 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/irregularlysampledsignal.py
--rw-r--r--   0 andrew     (503) staff       (20)     5444 2019-09-30 08:21:13.000000 neo-0.8.0/neo/core/regionofinterest.py
--rw-r--r--   0 andrew     (503) staff       (20)    13310 2019-09-30 08:21:13.000000 neo-0.8.0/neo/core/segment.py
--rw-r--r--   0 andrew     (503) staff       (20)    33470 2019-09-30 08:33:59.000000 neo-0.8.0/neo/core/spiketrain.py
--rw-r--r--   0 andrew     (503) staff       (20)     2633 2019-06-10 20:13:26.000000 neo-0.8.0/neo/core/unit.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/neo/io/
--rw-r--r--   0 andrew     (503) staff       (20)     7496 2019-09-30 08:21:14.000000 neo-0.8.0/neo/io/__init__.py
--rw-r--r--   0 andrew     (503) staff       (20)    24611 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/alphaomegaio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3185 2019-09-30 08:21:15.000000 neo-0.8.0/neo/io/asciiimageio.py
--rw-r--r--   0 andrew     (503) staff       (20)    16333 2019-09-25 12:29:10.000000 neo-0.8.0/neo/io/asciisignalio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3629 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/asciispiketrainio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1754 2019-07-04 19:36:28.000000 neo-0.8.0/neo/io/axographio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3884 2019-09-25 12:29:10.000000 neo-0.8.0/neo/io/axonio.py
--rw-r--r--   0 andrew     (503) staff       (20)    14529 2019-09-30 08:29:39.000000 neo-0.8.0/neo/io/basefromrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     8766 2019-09-30 08:21:15.000000 neo-0.8.0/neo/io/baseio.py
--rw-r--r--   0 andrew     (503) staff       (20)      430 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/bci2000io.py
--rw-r--r--   0 andrew     (503) staff       (20)      671 2019-07-23 11:15:45.000000 neo-0.8.0/neo/io/blackrockio.py
--rw-r--r--   0 andrew     (503) staff       (20)   104898 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/blackrockio_v4.py
--rw-r--r--   0 andrew     (503) staff       (20)    13470 2019-09-30 08:21:15.000000 neo-0.8.0/neo/io/blkio.py
--rw-r--r--   0 andrew     (503) staff       (20)      428 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/brainvisionio.py
--rw-r--r--   0 andrew     (503) staff       (20)     8607 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/brainwaredamio.py
--rw-r--r--   0 andrew     (503) staff       (20)    10024 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/brainwaref32io.py
--rwxr-xr-x   0 andrew     (503) staff       (20)    58990 2019-07-23 11:15:45.000000 neo-0.8.0/neo/io/brainwaresrcio.py
--rw-r--r--   0 andrew     (503) staff       (20)      598 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/elanio.py
--rw-r--r--   0 andrew     (503) staff       (20)   156901 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/elphyio.py
--rw-r--r--   0 andrew     (503) staff       (20)      917 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/exampleio.py
--rw-r--r--   0 andrew     (503) staff       (20)    18573 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/hdf5io.py
--rw-r--r--   0 andrew     (503) staff       (20)     5618 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/igorproio.py
--rw-r--r--   0 andrew     (503) staff       (20)      378 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/intanio.py
--rw-r--r--   0 andrew     (503) staff       (20)    17296 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/klustakwikio.py
--rw-r--r--   0 andrew     (503) staff       (20)     6975 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/kwikio.py
--rw-r--r--   0 andrew     (503) staff       (20)      486 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/micromedio.py
--rw-r--r--   0 andrew     (503) staff       (20)    14603 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/neomatlabio.py
--rw-r--r--   0 andrew     (503) staff       (20)    31998 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/nestio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1061 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/neuralynxio.py
--rw-r--r--   0 andrew     (503) staff       (20)   105334 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/neuralynxio_v1.py
--rw-r--r--   0 andrew     (503) staff       (20)      434 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/neuroexplorerio.py
--rw-r--r--   0 andrew     (503) staff       (20)      473 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/neuroscopeio.py
--rw-r--r--   0 andrew     (503) staff       (20)    20024 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/neuroshareapiio.py
--rw-r--r--   0 andrew     (503) staff       (20)    17313 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/neurosharectypesio.py
--rw-r--r--   0 andrew     (503) staff       (20)    54123 2019-09-26 09:30:09.000000 neo-0.8.0/neo/io/nixio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1179 2019-09-26 09:30:09.000000 neo-0.8.0/neo/io/nixio_fr.py
--rw-r--r--   0 andrew     (503) staff       (20)    20920 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/nsdfio.py
--rw-r--r--   0 andrew     (503) staff       (20)      378 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/openephysio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1463 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/pickleio.py
--rw-r--r--   0 andrew     (503) staff       (20)      609 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/plexonio.py
--rw-r--r--   0 andrew     (503) staff       (20)    25341 2019-09-26 09:30:09.000000 neo-0.8.0/neo/io/proxyobjects.py
--rw-r--r--   0 andrew     (503) staff       (20)     3448 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/rawbinarysignalio.py
--rw-r--r--   0 andrew     (503) staff       (20)      350 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/rawmcsio.py
--rw-r--r--   0 andrew     (503) staff       (20)      368 2019-09-25 12:29:10.000000 neo-0.8.0/neo/io/spike2io.py
--rw-r--r--   0 andrew     (503) staff       (20)     5132 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/stimfitio.py
--rw-r--r--   0 andrew     (503) staff       (20)      616 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/tdtio.py
--rw-r--r--   0 andrew     (503) staff       (20)     4563 2019-09-30 08:21:15.000000 neo-0.8.0/neo/io/tiffio.py
--rw-r--r--   0 andrew     (503) staff       (20)     5011 2019-09-30 08:33:59.000000 neo-0.8.0/neo/io/tools.py
--rw-r--r--   0 andrew     (503) staff       (20)      521 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/winedrio.py
--rw-r--r--   0 andrew     (503) staff       (20)      521 2019-07-04 19:36:11.000000 neo-0.8.0/neo/io/winwcpio.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/neo/rawio/
--rw-r--r--   0 andrew     (503) staff       (20)     3928 2019-09-26 09:30:09.000000 neo-0.8.0/neo/rawio/__init__.py
--rw-r--r--   0 andrew     (503) staff       (20)    61564 2019-07-04 19:36:28.000000 neo-0.8.0/neo/rawio/axographrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    33440 2019-09-30 08:33:59.000000 neo-0.8.0/neo/rawio/axonrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    26300 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/baserawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    17181 2019-09-30 08:44:05.000000 neo-0.8.0/neo/rawio/bci2000rawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    85483 2019-09-30 08:33:59.000000 neo-0.8.0/neo/rawio/blackrockrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     7095 2019-07-23 11:15:45.000000 neo-0.8.0/neo/rawio/brainvisionrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     8588 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/elanrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    15663 2019-09-25 12:29:10.000000 neo-0.8.0/neo/rawio/examplerawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    17984 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/intanrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     8875 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/micromedrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    28472 2019-09-26 09:30:09.000000 neo-0.8.0/neo/rawio/neuralynxrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    12094 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/neuroexplorerrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     4073 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/neuroscoperawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    18556 2019-09-26 09:30:09.000000 neo-0.8.0/neo/rawio/nixrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    22916 2019-09-26 09:30:09.000000 neo-0.8.0/neo/rawio/openephysrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    18935 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/plexonrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3743 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/rawbinarysignalrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     5575 2019-09-30 08:33:59.000000 neo-0.8.0/neo/rawio/rawmcsrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    28429 2019-09-25 12:29:10.000000 neo-0.8.0/neo/rawio/spike2rawio.py
--rw-r--r--   0 andrew     (503) staff       (20)    21766 2019-09-30 08:33:59.000000 neo-0.8.0/neo/rawio/tdtrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     4209 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/winedrrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     5669 2019-07-04 19:36:11.000000 neo-0.8.0/neo/rawio/winwcprawio.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/neo/test/
--rw-r--r--   0 andrew     (503) staff       (20)      137 2019-01-17 13:14:44.000000 neo-0.8.0/neo/test/__init__.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/neo/test/coretest/
--rw-r--r--   0 andrew     (503) staff       (20)       60 2019-01-17 13:14:44.000000 neo-0.8.0/neo/test/coretest/__init__.py
--rw-r--r--   0 andrew     (503) staff       (20)    77026 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_analogsignal.py
--rw-r--r--   0 andrew     (503) staff       (20)    42137 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_base.py
--rw-r--r--   0 andrew     (503) staff       (20)    32775 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_block.py
--rw-r--r--   0 andrew     (503) staff       (20)    28592 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_channelindex.py
--rw-r--r--   0 andrew     (503) staff       (20)     6727 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_container.py
--rw-r--r--   0 andrew     (503) staff       (20)     8022 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/coretest/test_dataobject.py
--rw-r--r--   0 andrew     (503) staff       (20)    37090 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_epoch.py
--rw-r--r--   0 andrew     (503) staff       (20)    33240 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_event.py
--rw-r--r--   0 andrew     (503) staff       (20)    23096 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_generate_datasets.py
--rw-r--r--   0 andrew     (503) staff       (20)     3217 2019-09-30 08:21:15.000000 neo-0.8.0/neo/test/coretest/test_imagesequence.py
--rw-r--r--   0 andrew     (503) staff       (20)    47542 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_irregularysampledsignal.py
--rw-r--r--   0 andrew     (503) staff       (20)     1127 2019-09-30 08:21:15.000000 neo-0.8.0/neo/test/coretest/test_regionofinterest.py
--rw-r--r--   0 andrew     (503) staff       (20)    43119 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_segment.py
--rw-r--r--   0 andrew     (503) staff       (20)    97216 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_spiketrain.py
--rw-r--r--   0 andrew     (503) staff       (20)    22028 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/coretest/test_unit.py
--rw-r--r--   0 andrew     (503) staff       (20)     2006 2019-04-01 08:23:05.000000 neo-0.8.0/neo/test/coretest/tmp.py
--rw-r--r--   0 andrew     (503) staff       (20)    18079 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/generate_datasets.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:32.000000 neo-0.8.0/neo/test/iotest/
--rw-r--r--   0 andrew     (503) staff       (20)       58 2019-01-17 13:14:44.000000 neo-0.8.0/neo/test/iotest/__init__.py
--rw-r--r--   0 andrew     (503) staff       (20)    19757 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/iotest/common_io_test.py
--rw-r--r--   0 andrew     (503) staff       (20)      514 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_alphaomegaio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1357 2019-09-30 08:21:15.000000 neo-0.8.0/neo/test/iotest/test_asciiimageio.py
--rw-r--r--   0 andrew     (503) staff       (20)    14227 2019-07-23 11:15:45.000000 neo-0.8.0/neo/test/iotest/test_asciisignalio.py
--rw-r--r--   0 andrew     (503) staff       (20)      500 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_asciispiketrainio.py
--rw-r--r--   0 andrew     (503) staff       (20)     7234 2019-07-04 19:36:28.000000 neo-0.8.0/neo/test/iotest/test_axographio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1233 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_axonio.py
--rw-r--r--   0 andrew     (503) staff       (20)      795 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_baseio.py
--rw-r--r--   0 andrew     (503) staff       (20)      506 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_bci2000.py
--rw-r--r--   0 andrew     (503) staff       (20)    22793 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/iotest/test_blackrockio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1536 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_brainvisionio.py
--rw-r--r--   0 andrew     (503) staff       (20)     5680 2019-07-04 19:36:28.000000 neo-0.8.0/neo/test/iotest/test_brainwaredamio.py
--rw-r--r--   0 andrew     (503) staff       (20)     5766 2019-07-04 19:36:28.000000 neo-0.8.0/neo/test/iotest/test_brainwaref32io.py
--rw-r--r--   0 andrew     (503) staff       (20)    13580 2019-07-04 19:36:28.000000 neo-0.8.0/neo/test/iotest/test_brainwaresrcio.py
--rw-r--r--   0 andrew     (503) staff       (20)      581 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_elanio.py
--rw-r--r--   0 andrew     (503) staff       (20)      788 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_elphyio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3168 2019-07-23 11:15:45.000000 neo-0.8.0/neo/test/iotest/test_exampleio.py
--rw-r--r--   0 andrew     (503) staff       (20)     7370 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_hdf5io.py
--rw-r--r--   0 andrew     (503) staff       (20)      541 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_igorio.py
--rw-r--r--   0 andrew     (503) staff       (20)      512 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_intanio.py
--rw-r--r--   0 andrew     (503) staff       (20)    15064 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_klustakwikio.py
--rw-r--r--   0 andrew     (503) staff       (20)      695 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_kwikio.py
--rw-r--r--   0 andrew     (503) staff       (20)      473 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_micromedio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1226 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_neomatlabio.py
--rw-r--r--   0 andrew     (503) staff       (20)    34009 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_nestio.py
--rw-r--r--   0 andrew     (503) staff       (20)    17634 2019-09-26 09:30:09.000000 neo-0.8.0/neo/test/iotest/test_neuralynxio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1644 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_neuroexplorerio.py
--rw-r--r--   0 andrew     (503) staff       (20)      541 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_neuroscopeio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3563 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_neuroshareio.py
--rw-r--r--   0 andrew     (503) staff       (20)    68946 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/iotest/test_nixio.py
--rw-r--r--   0 andrew     (503) staff       (20)     6241 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/iotest/test_nixio_fr.py
--rw-r--r--   0 andrew     (503) staff       (20)     8888 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_nsdfio.py
--rw-r--r--   0 andrew     (503) staff       (20)      713 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/iotest/test_openephysio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3497 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_pickleio.py
--rw-r--r--   0 andrew     (503) staff       (20)      535 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_plexonio.py
--rw-r--r--   0 andrew     (503) staff       (20)     9170 2019-09-26 09:30:09.000000 neo-0.8.0/neo/test/iotest/test_proxyobjects.py
--rw-r--r--   0 andrew     (503) staff       (20)      757 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_rawbinarysignalio.py
--rw-r--r--   0 andrew     (503) staff       (20)      437 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_rawmcsio.py
--rw-r--r--   0 andrew     (503) staff       (20)     2721 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/iotest/test_spike2io.py
--rw-r--r--   0 andrew     (503) staff       (20)      845 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_stimfitio.py
--rw-r--r--   0 andrew     (503) staff       (20)     2486 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_tdtio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1426 2019-09-30 08:21:15.000000 neo-0.8.0/neo/test/iotest/test_tiffio.py
--rw-r--r--   0 andrew     (503) staff       (20)      558 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_winedrio.py
--rw-r--r--   0 andrew     (503) staff       (20)      459 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/test_winwcpio.py
--rw-r--r--   0 andrew     (503) staff       (20)    13395 2019-07-04 19:36:11.000000 neo-0.8.0/neo/test/iotest/tools.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:32.000000 neo-0.8.0/neo/test/rawiotest/
--rw-r--r--   0 andrew     (503) staff       (20)       24 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/__init__.py
--rw-r--r--   0 andrew     (503) staff       (20)     5316 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/common_rawio_test.py
--rw-r--r--   0 andrew     (503) staff       (20)    14318 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/rawio_compliance.py
--rw-r--r--   0 andrew     (503) staff       (20)      899 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_axographrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      903 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_axonrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      443 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_bci2000rawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     8378 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_blackrockrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1603 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_brainvisionrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      567 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_elanrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     1327 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_examplerawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      544 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_intanrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      517 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_micromedrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     2783 2019-09-26 09:30:09.000000 neo-0.8.0/neo/test/rawiotest/test_neuralynxrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      584 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_neuroexplorerrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      580 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_neuroscoperawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      354 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_nixrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     3740 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_openephysrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      571 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_plexonrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      555 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_rawbinarysignalrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      504 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_rawmcsrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      673 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_spike2rawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      827 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_tdtrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      570 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_winedrrawio.py
--rw-r--r--   0 andrew     (503) staff       (20)      496 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/test_winwcprawio.py
--rw-r--r--   0 andrew     (503) staff       (20)     2703 2019-09-25 12:29:10.000000 neo-0.8.0/neo/test/rawiotest/tools.py
--rw-r--r--   0 andrew     (503) staff       (20)    28404 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/test_utils.py
--rw-r--r--   0 andrew     (503) staff       (20)    19505 2019-09-30 08:33:59.000000 neo-0.8.0/neo/test/tools.py
--rw-r--r--   0 andrew     (503) staff       (20)    23085 2019-09-25 12:29:10.000000 neo-0.8.0/neo/utils.py
--rw-r--r--   0 andrew     (503) staff       (20)       42 2019-09-30 08:43:46.000000 neo-0.8.0/neo/version.py
-drwxr-xr-x   0 andrew     (503) staff       (20)        0 2019-09-30 09:09:31.000000 neo-0.8.0/neo.egg-info/
--rw-r--r--   0 andrew     (503) staff       (20)     5201 2019-09-30 09:09:31.000000 neo-0.8.0/neo.egg-info/PKG-INFO
--rw-r--r--   0 andrew     (503) staff       (20)     7016 2019-09-30 09:09:31.000000 neo-0.8.0/neo.egg-info/SOURCES.txt
--rw-r--r--   0 andrew     (503) staff       (20)        1 2019-09-30 09:09:31.000000 neo-0.8.0/neo.egg-info/dependency_links.txt
--rw-r--r--   0 andrew     (503) staff       (20)      176 2019-09-30 09:09:31.000000 neo-0.8.0/neo.egg-info/requires.txt
--rw-r--r--   0 andrew     (503) staff       (20)        4 2019-09-30 09:09:31.000000 neo-0.8.0/neo.egg-info/top_level.txt
--rw-r--r--   0 andrew     (503) staff       (20)       38 2019-09-30 09:09:32.000000 neo-0.8.0/setup.cfg
--rwxr-xr-x   0 andrew     (503) staff       (20)     1814 2019-09-30 08:33:59.000000 neo-0.8.0/setup.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/
+-rw-r--r--   0 andrew     (503) staff       (20)     1501 2020-11-10 15:36:33.000000 neo-0.9.0/LICENSE.txt
+-rw-r--r--   0 andrew     (503) staff       (20)      199 2019-07-04 19:36:11.000000 neo-0.9.0/MANIFEST.in
+-rw-r--r--   0 andrew     (503) staff       (20)     5778 2020-11-10 15:42:06.000000 neo-0.9.0/PKG-INFO
+-rw-r--r--   0 andrew     (503) staff       (20)     4019 2020-11-10 15:36:33.000000 neo-0.9.0/README.rst
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/doc/
+-rw-r--r--   0 andrew     (503) staff       (20)     3124 2019-01-17 13:14:44.000000 neo-0.9.0/doc/Makefile
+-rw-r--r--   0 andrew     (503) staff       (20)     3069 2019-01-17 13:14:44.000000 neo-0.9.0/doc/make.bat
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/doc/old_stuffs/
+-rw-r--r--   0 andrew     (503) staff       (20)     4018 2019-07-04 19:36:11.000000 neo-0.9.0/doc/old_stuffs/gif2011workshop.rst
+-rw-r--r--   0 andrew     (503) staff       (20)      910 2019-07-04 19:36:11.000000 neo-0.9.0/doc/old_stuffs/specific_annotations.rst
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/doc/source/
+-rw-r--r--   0 andrew     (503) staff       (20)      132 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/api_reference.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     3358 2020-11-09 17:58:24.000000 neo-0.9.0/doc/source/authors.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     6994 2020-11-10 15:36:33.000000 neo-0.9.0/doc/source/conf.py
+-rw-r--r--   0 andrew     (503) staff       (20)    11633 2020-11-10 15:36:33.000000 neo-0.9.0/doc/source/core.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     9330 2020-10-02 07:17:12.000000 neo-0.9.0/doc/source/developers_guide.rst
+-rw-r--r--   0 andrew     (503) staff       (20)    10820 2019-09-30 08:31:24.000000 neo-0.9.0/doc/source/developers_guide.rst.orig
+-rw-r--r--   0 andrew     (503) staff       (20)      362 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/examples.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     5788 2020-11-10 15:36:33.000000 neo-0.9.0/doc/source/grouping.rst
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/doc/source/images/
+-rw-r--r--   0 andrew     (503) staff       (20)     6148 2020-05-19 16:07:52.000000 neo-0.9.0/doc/source/images/.DS_Store
+-rw-r--r--   0 andrew     (503) staff       (20)    67445 2020-11-09 17:58:24.000000 neo-0.9.0/doc/source/images/base_schematic.png
+-rw-r--r--   0 andrew     (503) staff       (20)     7777 2020-11-09 17:58:24.000000 neo-0.9.0/doc/source/images/generate_diagram.py
+-rw-r--r--   0 andrew     (503) staff       (20)   147943 2019-01-17 13:14:44.000000 neo-0.9.0/doc/source/images/multi_segment_diagram.png
+-rw-r--r--   0 andrew     (503) staff       (20)    63701 2020-11-09 17:58:24.000000 neo-0.9.0/doc/source/images/multi_segment_diagram_spiketrain.png
+-rw-r--r--   0 andrew     (503) staff       (20)   175903 2019-01-17 13:14:44.000000 neo-0.9.0/doc/source/images/neo_UML_French_workshop.png
+-rw-r--r--   0 andrew     (503) staff       (20)   411264 2019-01-17 13:14:44.000000 neo-0.9.0/doc/source/images/neologo.png
+-rw-r--r--   0 andrew     (503) staff       (20)     6703 2019-01-17 13:14:44.000000 neo-0.9.0/doc/source/images/neologo_light.png
+-rw-r--r--   0 andrew     (503) staff       (20)   479096 2019-08-28 15:13:05.000000 neo-0.9.0/doc/source/images/neologo_optical.png
+-rw-r--r--   0 andrew     (503) staff       (20)   276776 2019-01-17 13:14:44.000000 neo-0.9.0/doc/source/images/simple_generated_diagram.png
+-rw-r--r--   0 andrew     (503) staff       (20)     3199 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/index.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     1855 2020-11-10 15:41:06.000000 neo-0.9.0/doc/source/install.rst
+-rw-r--r--   0 andrew     (503) staff       (20)    12890 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/io.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     6038 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/io_developers_guide.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     8194 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/rawio.rst
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/doc/source/releases/
+-rw-r--r--   0 andrew     (503) staff       (20)     6023 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/releases/0.5.0.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     1197 2019-07-04 19:36:11.000000 neo-0.9.0/doc/source/releases/0.5.1.rst
+-rw-r--r--   0 andrew     (503) staff       (20)      843 2019-07-04 19:36:11.000000 neo-0.9.0/doc/source/releases/0.5.2.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     1973 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/releases/0.6.0.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     1050 2019-07-04 19:36:11.000000 neo-0.9.0/doc/source/releases/0.7.0.rst
+-rw-r--r--   0 andrew     (503) staff       (20)      411 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/releases/0.7.1.rst
+-rw-r--r--   0 andrew     (503) staff       (20)      273 2019-11-05 16:04:40.000000 neo-0.9.0/doc/source/releases/0.7.2.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     4633 2020-09-22 10:16:16.000000 neo-0.9.0/doc/source/releases/0.8.0.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     4616 2019-09-26 12:35:09.000000 neo-0.9.0/doc/source/releases/0.8.0.rst.orig
+-rw-r--r--   0 andrew     (503) staff       (20)     4371 2020-11-10 15:36:33.000000 neo-0.9.0/doc/source/releases/0.9.0.rst
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/doc/source/scripts/
+-rw-r--r--   0 andrew     (503) staff       (20)     3633 2020-11-09 17:58:24.000000 neo-0.9.0/doc/source/scripts/multi_tetrode_example.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1269 2020-11-09 17:58:24.000000 neo-0.9.0/doc/source/scripts/spike_sorting_example.py
+-rw-r--r--   0 andrew     (503) staff       (20)     7837 2020-11-09 17:58:24.000000 neo-0.9.0/doc/source/usecases.rst
+-rw-r--r--   0 andrew     (503) staff       (20)     2587 2020-11-10 15:36:33.000000 neo-0.9.0/doc/source/whatisnew.rst
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/examples/
+-rw-r--r--   0 andrew     (503) staff       (20)     4811 2020-10-02 07:17:12.000000 neo-0.9.0/examples/generated_data.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1646 2019-09-30 10:56:27.000000 neo-0.9.0/examples/hbp_d571_example.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2024 2019-09-18 15:26:23.000000 neo-0.9.0/examples/hbp_d571_example2.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1625 2019-09-30 10:56:19.000000 neo-0.9.0/examples/hbp_d571_example_orig.py
+-rw-r--r--   0 andrew     (503) staff       (20)      963 2019-11-05 16:04:40.000000 neo-0.9.0/examples/imageseq.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1118 2020-10-02 07:17:12.000000 neo-0.9.0/examples/read_files_neo_io.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3230 2020-10-02 07:17:12.000000 neo-0.9.0/examples/read_files_neo_rawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1645 2020-10-02 07:17:12.000000 neo-0.9.0/examples/read_proxy_with_lazy_load.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1105 2019-11-05 16:04:40.000000 neo-0.9.0/examples/roi_demo.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1161 2020-10-02 07:17:12.000000 neo-0.9.0/examples/simple_plot_with_matplotlib.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/
+-rw-r--r--   0 andrew     (503) staff       (20)      328 2020-10-02 07:17:12.000000 neo-0.9.0/neo/__init__.py
+-rw-r--r--   0 andrew     (503) staff       (20)     4039 2020-11-09 17:58:24.000000 neo-0.9.0/neo/converter.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/core/
+-rw-r--r--   0 andrew     (503) staff       (20)     1909 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/__init__.py
+-rw-r--r--   0 andrew     (503) staff       (20)    32061 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/analogsignal.py
+-rw-r--r--   0 andrew     (503) staff       (20)    16457 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/baseneo.py
+-rw-r--r--   0 andrew     (503) staff       (20)    12644 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/basesignal.py
+-rw-r--r--   0 andrew     (503) staff       (20)     4982 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/block.py
+-rw-r--r--   0 andrew     (503) staff       (20)     9047 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/channelindex.py
+-rw-r--r--   0 andrew     (503) staff       (20)    26166 2020-10-02 07:17:12.000000 neo-0.9.0/neo/core/container.py
+-rw-r--r--   0 andrew     (503) staff       (20)    17216 2020-11-05 17:41:42.000000 neo-0.9.0/neo/core/dataobject.py
+-rw-r--r--   0 andrew     (503) staff       (20)    14051 2020-10-02 07:17:12.000000 neo-0.9.0/neo/core/epoch.py
+-rw-r--r--   0 andrew     (503) staff       (20)    13960 2020-10-02 07:17:12.000000 neo-0.9.0/neo/core/event.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3012 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/group.py
+-rw-r--r--   0 andrew     (503) staff       (20)    10221 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/imagesequence.py
+-rw-r--r--   0 andrew     (503) staff       (20)    24673 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/irregularlysampledsignal.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5411 2020-10-02 07:17:12.000000 neo-0.9.0/neo/core/regionofinterest.py
+-rw-r--r--   0 andrew     (503) staff       (20)    13681 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/segment.py
+-rw-r--r--   0 andrew     (503) staff       (20)    35906 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/spiketrain.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2560 2020-11-09 17:58:24.000000 neo-0.9.0/neo/core/unit.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3614 2020-11-10 15:36:33.000000 neo-0.9.0/neo/core/view.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/io/
+-rw-r--r--   0 andrew     (503) staff       (20)     7472 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/__init__.py
+-rw-r--r--   0 andrew     (503) staff       (20)    24390 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/alphaomegaio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2968 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/asciiimageio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    16309 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/asciisignalio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3604 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/asciispiketrainio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1819 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/axographio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3918 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/axonio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    13918 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/basefromrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    12451 2020-11-05 15:27:57.000000 neo-0.9.0/neo/io/basefromrawio_new.py
+-rw-r--r--   0 andrew     (503) staff       (20)    14577 2020-11-05 10:22:31.000000 neo-0.9.0/neo/io/basefromrawio_orig.py
+-rw-r--r--   0 andrew     (503) staff       (20)    13664 2020-11-05 15:27:36.000000 neo-0.9.0/neo/io/basefromrawio_sg.py
+-rw-r--r--   0 andrew     (503) staff       (20)     9288 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/baseio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      465 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/bci2000io.py
+-rw-r--r--   0 andrew     (503) staff       (20)      646 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/blackrockio.py
+-rw-r--r--   0 andrew     (503) staff       (20)   105086 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/blackrockio_v4.py
+-rw-r--r--   0 andrew     (503) staff       (20)    13527 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/blkio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      463 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/brainvisionio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     8071 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/brainwaredamio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     9444 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/brainwaref32io.py
+-rwxr-xr-x   0 andrew     (503) staff       (20)    57479 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/brainwaresrcio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      575 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/elanio.py
+-rw-r--r--   0 andrew     (503) staff       (20)   155978 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/elphyio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      893 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/exampleio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    18786 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/hdf5io.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5555 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/igorproio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      353 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/intanio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    17272 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/klustakwikio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     6843 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/kwikio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      461 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/micromedio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    15019 2020-11-05 17:41:42.000000 neo-0.9.0/neo/io/neomatlabio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    31935 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/nestio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1669 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/neuralynxio.py
+-rw-r--r--   0 andrew     (503) staff       (20)   105289 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/neuralynxio_v1.py
+-rw-r--r--   0 andrew     (503) staff       (20)      469 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/neuroexplorerio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      448 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/neuroscopeio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    19948 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/neuroshareapiio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    17177 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/neurosharectypesio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    67027 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/nixio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1169 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/nixio_fr.py
+-rw-r--r--   0 andrew     (503) staff       (20)    21353 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/nsdfio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      353 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/openephysio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1439 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/pickleio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      644 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/plexonio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    25541 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/proxyobjects.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3484 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/rawbinarysignalio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      325 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/rawmcsio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      343 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/spike2io.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5044 2020-10-02 07:17:12.000000 neo-0.9.0/neo/io/stimfitio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      652 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/tdtio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     4348 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/tiffio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5027 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/tools.py
+-rw-r--r--   0 andrew     (503) staff       (20)      556 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/winedrio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      556 2020-11-09 17:58:24.000000 neo-0.9.0/neo/io/winwcpio.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/rawio/
+-rw-r--r--   0 andrew     (503) staff       (20)     3904 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/__init__.py
+-rw-r--r--   0 andrew     (503) staff       (20)    63571 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/axographrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    33125 2020-11-05 17:41:42.000000 neo-0.9.0/neo/rawio/axonrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    26231 2020-11-09 17:58:24.000000 neo-0.9.0/neo/rawio/baserawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    17451 2020-11-05 17:41:42.000000 neo-0.9.0/neo/rawio/bci2000rawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    85131 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/blackrockrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     6975 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/brainvisionrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     8475 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/elanrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    15556 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/examplerawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    17895 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/intanrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     8998 2020-11-09 17:58:24.000000 neo-0.9.0/neo/rawio/micromedrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    36108 2020-11-09 17:58:24.000000 neo-0.9.0/neo/rawio/neuralynxrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    12005 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/neuroexplorerrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3966 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/neuroscoperawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    18491 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/nixrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    23105 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/openephysrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    18852 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/plexonrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3636 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/rawbinarysignalrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5468 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/rawmcsrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    28625 2020-11-09 17:58:24.000000 neo-0.9.0/neo/rawio/spike2rawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    21529 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/tdtrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     4102 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/winedrrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5540 2020-10-02 07:17:12.000000 neo-0.9.0/neo/rawio/winwcprawio.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/test/
+-rw-r--r--   0 andrew     (503) staff       (20)      113 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/__init__.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/test/coretest/
+-rw-r--r--   0 andrew     (503) staff       (20)       36 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/coretest/__init__.py
+-rw-r--r--   0 andrew     (503) staff       (20)    91570 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_analogsignal.py
+-rw-r--r--   0 andrew     (503) staff       (20)    51953 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_base.py
+-rw-r--r--   0 andrew     (503) staff       (20)    32775 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_block.py
+-rw-r--r--   0 andrew     (503) staff       (20)    28466 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/coretest/test_channelindex.py
+-rw-r--r--   0 andrew     (503) staff       (20)     6703 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/coretest/test_container.py
+-rw-r--r--   0 andrew     (503) staff       (20)     8022 2019-11-05 16:04:41.000000 neo-0.9.0/neo/test/coretest/test_dataobject.py
+-rw-r--r--   0 andrew     (503) staff       (20)    38570 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/coretest/test_epoch.py
+-rw-r--r--   0 andrew     (503) staff       (20)    34414 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/coretest/test_event.py
+-rw-r--r--   0 andrew     (503) staff       (20)    22974 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_generate_datasets.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3284 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_group.py
+-rw-r--r--   0 andrew     (503) staff       (20)     4121 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_imagesequence.py
+-rw-r--r--   0 andrew     (503) staff       (20)    51275 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_irregularysampledsignal.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1127 2019-11-05 16:04:41.000000 neo-0.9.0/neo/test/coretest/test_regionofinterest.py
+-rw-r--r--   0 andrew     (503) staff       (20)    45634 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_segment.py
+-rw-r--r--   0 andrew     (503) staff       (20)   105564 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_spiketrain.py
+-rw-r--r--   0 andrew     (503) staff       (20)    21902 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/coretest/test_unit.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2680 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/coretest/test_view.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2006 2019-04-01 08:23:05.000000 neo-0.9.0/neo/test/coretest/tmp.py
+-rw-r--r--   0 andrew     (503) staff       (20)    18280 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/generate_datasets.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/test/iotest/
+-rw-r--r--   0 andrew     (503) staff       (20)       34 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/__init__.py
+-rw-r--r--   0 andrew     (503) staff       (20)    19651 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/common_io_test.py
+-rw-r--r--   0 andrew     (503) staff       (20)      404 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_alphaomegaio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1357 2019-11-05 16:04:41.000000 neo-0.9.0/neo/test/iotest/test_asciiimageio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    14117 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_asciisignalio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      390 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_asciispiketrainio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    12414 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_axographio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1064 2020-11-05 17:41:42.000000 neo-0.9.0/neo/test/iotest/test_axonio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      685 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_baseio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      396 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_bci2000.py
+-rw-r--r--   0 andrew     (503) staff       (20)    22689 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_blackrockio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1426 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_brainvisionio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5333 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_brainwaredamio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5296 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_brainwaref32io.py
+-rw-r--r--   0 andrew     (503) staff       (20)    13068 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_brainwaresrcio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      459 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_elanio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3034 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_exampleio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     7525 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_hdf5io.py
+-rw-r--r--   0 andrew     (503) staff       (20)      517 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_igorio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      390 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_intanio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    14964 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_klustakwikio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      591 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_kwikio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      351 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_micromedio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1345 2020-11-05 17:41:42.000000 neo-0.9.0/neo/test/iotest/test_neomatlabio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    33900 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_nestio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    18818 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_neuralynxio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1522 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_neuroexplorerio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      431 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_neuroscopeio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3453 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_neuroshareio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    80674 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/iotest/test_nixio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     6169 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_nixio_fr.py
+-rw-r--r--   0 andrew     (503) staff       (20)     8778 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_nsdfio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      603 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_openephysio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3387 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_pickleio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      413 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_plexonio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     9146 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_proxyobjects.py
+-rw-r--r--   0 andrew     (503) staff       (20)      647 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_rawbinarysignalio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      314 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_rawmcsio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2665 2020-11-05 17:41:42.000000 neo-0.9.0/neo/test/iotest/test_spike2io.py
+-rw-r--r--   0 andrew     (503) staff       (20)      845 2019-07-04 19:36:11.000000 neo-0.9.0/neo/test/iotest/test_stimfitio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2377 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_tdtio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1425 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_tiffio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      448 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_winedrio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      349 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/test_winwcpio.py
+-rw-r--r--   0 andrew     (503) staff       (20)    13264 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/iotest/tools.py
+-rw-r--r--   0 andrew     (503) staff       (20)      272 2020-04-25 18:11:59.000000 neo-0.9.0/neo/test/issue807.py
+-rw-r--r--   0 andrew     (503) staff       (20)      301 2020-04-25 18:32:31.000000 neo-0.9.0/neo/test/issue807b.py
+-rw-r--r--   0 andrew     (503) staff       (20)      147 2020-04-25 15:12:48.000000 neo-0.9.0/neo/test/issue808.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo/test/rawiotest/
+-rw-r--r--   0 andrew     (503) staff       (20)        0 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/__init__.py
+-rw-r--r--   0 andrew     (503) staff       (20)     5164 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/common_rawio_test.py
+-rw-r--r--   0 andrew     (503) staff       (20)    15657 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/rawiotest/rawio_compliance.py
+-rw-r--r--   0 andrew     (503) staff       (20)      880 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_axographrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      796 2020-11-05 17:41:42.000000 neo-0.9.0/neo/test/rawiotest/test_axonrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      419 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_bci2000rawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     8234 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_blackrockrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1459 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_brainvisionrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      422 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_elanrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     1183 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_examplerawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      399 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_intanrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      373 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_micromedrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3699 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/rawiotest/test_neuralynxrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      439 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_neuroexplorerrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      435 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_neuroscoperawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      354 2019-11-05 16:04:41.000000 neo-0.9.0/neo/test/rawiotest/test_nixrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     3595 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_openephysrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      426 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_plexonrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      410 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_rawbinarysignalrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      359 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_rawmcsrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      582 2020-11-05 17:41:42.000000 neo-0.9.0/neo/test/rawiotest/test_spike2rawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      682 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_tdtrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      425 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_winedrrawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)      351 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/test_winwcprawio.py
+-rw-r--r--   0 andrew     (503) staff       (20)     2528 2020-10-02 07:17:12.000000 neo-0.9.0/neo/test/rawiotest/tools.py
+-rw-r--r--   0 andrew     (503) staff       (20)     4390 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/test_converter.py
+-rw-r--r--   0 andrew     (503) staff       (20)    29337 2020-11-05 17:41:42.000000 neo-0.9.0/neo/test/test_utils.py
+-rw-r--r--   0 andrew     (503) staff       (20)    19605 2020-11-09 17:58:24.000000 neo-0.9.0/neo/test/tools.py
+-rw-r--r--   0 andrew     (503) staff       (20)    22620 2020-11-05 17:41:42.000000 neo-0.9.0/neo/utils.py
+-rw-r--r--   0 andrew     (503) staff       (20)       18 2020-11-10 15:38:42.000000 neo-0.9.0/neo/version.py
+drwxr-xr-x   0 andrew     (503) staff       (20)        0 2020-11-10 15:42:06.000000 neo-0.9.0/neo.egg-info/
+-rw-r--r--   0 andrew     (503) staff       (20)     5778 2020-11-10 15:42:06.000000 neo-0.9.0/neo.egg-info/PKG-INFO
+-rw-r--r--   0 andrew     (503) staff       (20)     7325 2020-11-10 15:42:06.000000 neo-0.9.0/neo.egg-info/SOURCES.txt
+-rw-r--r--   0 andrew     (503) staff       (20)        1 2020-11-10 15:42:06.000000 neo-0.9.0/neo.egg-info/dependency_links.txt
+-rw-r--r--   0 andrew     (503) staff       (20)      186 2020-11-10 15:42:06.000000 neo-0.9.0/neo.egg-info/requires.txt
+-rw-r--r--   0 andrew     (503) staff       (20)        4 2020-11-10 15:42:06.000000 neo-0.9.0/neo.egg-info/top_level.txt
+-rw-r--r--   0 andrew     (503) staff       (20)       38 2020-11-10 15:42:06.000000 neo-0.9.0/setup.cfg
+-rwxr-xr-x   0 andrew     (503) staff       (20)     1763 2020-11-09 17:58:24.000000 neo-0.9.0/setup.py
```

### Comparing `neo-0.8.0/LICENSE.txt` & `neo-0.9.0/LICENSE.txt`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-Copyright (c) 2010-2018, Neo authors and contributors
+Copyright (c) 2010-2020, Neo authors and contributors
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 
 * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the names of the copyright holders nor the names of the contributors may be used to endorse or promote products derived from this software without specific prior written permission.
```

### Comparing `neo-0.8.0/PKG-INFO` & `neo-0.9.0/PKG-INFO`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: neo
-Version: 0.8.0
+Version: 0.9.0
 Summary: Neo is a package for representing electrophysiology data in Python, together with support for reading a wide range of neurophysiology file formats
 Home-page: https://neuralensemble.org/neo
 Author: Neo authors and contributors
 Author-email: samuel.garcia@cnrs.fr
 License: BSD-3-Clause
 Description: ===
         Neo
@@ -17,15 +17,15 @@
         
         The goal of Neo is to improve interoperability between Python tools for
         analyzing, visualizing and generating electrophysiology data by providing a common,
         shared object model. In order to be as lightweight a dependency as possible,
         Neo is deliberately limited to represention of data, with no functions for data
         analysis or visualization.
         
-        Neo is used by a number of other software tools, including 
+        Neo is used by a number of other software tools, including
         SpykeViewer_ (data analysis and visualization), Elephant_ (data analysis),
         the G-node_ suite (databasing), PyNN_ (simulations), tridesclous_ (spike sorting)
         and ephyviewer_ (data visualization).
         OpenElectrophy_ (data analysis and visualization) uses an older version of neo.
         
         Neo implements a hierarchical data model well adapted to intracellular and
         extracellular electrophysiology and EEG data with support for multi-electrodes
@@ -60,17 +60,26 @@
         - Documentation: http://neo.readthedocs.io/
         - Bug reports: https://github.com/NeuralEnsemble/python-neo/issues
         
         For installation instructions, see doc/source/install.rst
         
         To cite Neo in publications, see CITATION.txt
         
-        :copyright: Copyright 2010-2018 by the Neo team, see doc/source/authors.rst.
+        :copyright: Copyright 2010-2020 by the Neo team, see doc/source/authors.rst.
         :license: 3-Clause Revised BSD License, see LICENSE.txt for details.
         
+        Funding
+        -------
+        
+        Development of PyNN has been partially funded by the European Union Sixth Framework Program (FP6) under
+        grant agreement FETPI-015879 (FACETS), by the European Union Seventh Framework Program (FP7/2007-2013)
+        under grant agreements no. 269921 (BrainScaleS) and no. 604102 (HBP),
+        and by the European Unions Horizon 2020 Framework Programme for
+        Research and Innovation under the Specific Grant Agreements No. 720270 (Human Brain Project SGA1),
+        No. 785907 (Human Brain Project SGA2) and No. 945539 (Human Brain Project SGA3).
         
         .. _OpenElectrophy: https://github.com/OpenElectrophy/OpenElectrophy
         .. _Elephant: http://neuralensemble.org/elephant
         .. _G-node: http://www.g-node.org/
         .. _Neuroshare: http://neuroshare.org/
         .. _SpykeViewer: https://spyke-viewer.readthedocs.org/en/latest/
         .. _NiBabel: http://nipy.sourceforge.net/nibabel/
@@ -83,21 +92,21 @@
         
 Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Natural Language :: English
 Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.5
 Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Topic :: Scientific/Engineering
-Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*
-Provides-Extra: kwikio
-Provides-Extra: nixio
-Provides-Extra: neomatlabio
-Provides-Extra: stimfitio
+Requires-Python: >=3.6
 Provides-Extra: tiffio
-Provides-Extra: igorproio
 Provides-Extra: hdf5io
+Provides-Extra: neomatlabio
+Provides-Extra: kwikio
+Provides-Extra: igorproio
+Provides-Extra: stimfitio
+Provides-Extra: nixio
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `neo-0.8.0/README.rst` & `neo-0.9.0/README.rst`

 * *Files 9% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 
 The goal of Neo is to improve interoperability between Python tools for
 analyzing, visualizing and generating electrophysiology data by providing a common,
 shared object model. In order to be as lightweight a dependency as possible,
 Neo is deliberately limited to represention of data, with no functions for data
 analysis or visualization.
 
-Neo is used by a number of other software tools, including 
+Neo is used by a number of other software tools, including
 SpykeViewer_ (data analysis and visualization), Elephant_ (data analysis),
 the G-node_ suite (databasing), PyNN_ (simulations), tridesclous_ (spike sorting)
 and ephyviewer_ (data visualization).
 OpenElectrophy_ (data analysis and visualization) uses an older version of neo.
 
 Neo implements a hierarchical data model well adapted to intracellular and
 extracellular electrophysiology and EEG data with support for multi-electrodes
@@ -52,17 +52,26 @@
 - Documentation: http://neo.readthedocs.io/
 - Bug reports: https://github.com/NeuralEnsemble/python-neo/issues
 
 For installation instructions, see doc/source/install.rst
 
 To cite Neo in publications, see CITATION.txt
 
-:copyright: Copyright 2010-2018 by the Neo team, see doc/source/authors.rst.
+:copyright: Copyright 2010-2020 by the Neo team, see doc/source/authors.rst.
 :license: 3-Clause Revised BSD License, see LICENSE.txt for details.
 
+Funding
+-------
+
+Development of PyNN has been partially funded by the European Union Sixth Framework Program (FP6) under
+grant agreement FETPI-015879 (FACETS), by the European Union Seventh Framework Program (FP7/2007-2013)
+under grant agreements no. 269921 (BrainScaleS) and no. 604102 (HBP),
+and by the European Unions Horizon 2020 Framework Programme for
+Research and Innovation under the Specific Grant Agreements No. 720270 (Human Brain Project SGA1),
+No. 785907 (Human Brain Project SGA2) and No. 945539 (Human Brain Project SGA3).
 
 .. _OpenElectrophy: https://github.com/OpenElectrophy/OpenElectrophy
 .. _Elephant: http://neuralensemble.org/elephant
 .. _G-node: http://www.g-node.org/
 .. _Neuroshare: http://neuroshare.org/
 .. _SpykeViewer: https://spyke-viewer.readthedocs.org/en/latest/
 .. _NiBabel: http://nipy.sourceforge.net/nibabel/
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `neo-0.8.0/doc/Makefile` & `neo-0.9.0/doc/Makefile`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/make.bat` & `neo-0.9.0/doc/make.bat`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/old_stuffs/gif2011workshop.rst` & `neo-0.9.0/doc/old_stuffs/gif2011workshop.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/old_stuffs/specific_annotations.rst` & `neo-0.9.0/doc/old_stuffs/specific_annotations.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/authors.rst` & `neo-0.9.0/doc/source/authors.rst`

 * *Files 4% similar despite different names*

```diff
@@ -47,14 +47,16 @@
 * Scott W Harden [20]
 * Chek Yin Choi (hkchekc@github)
 * Corentin Fragnaud [21]
 * Alexander Kleinjohann
 * Christian Kothe
 * rishidhingra@github
 * Hugo van Kemenade
+* Aitor Morales-Gregorio [13]
+* Peter N Steinmetz [22]
 
 1. Centre de Recherche en Neuroscience de Lyon, CNRS UMR5292 - INSERM U1028 - Universite Claude Bernard Lyon 1
 2. Unit de Neuroscience, Information et Complexit, CNRS UPR 3293, Gif-sur-Yvette, France
 3. University of California, Berkeley
 4. Laboratoire de Neurosciences Intgratives et Adaptatives, CNRS UMR 6149 - Universit de Provence, Marseille, France
 5. G-Node, Ludwig-Maximilians-Universitt, Munich, Germany
 6. Institut de Neurosciences de la Timone, CNRS UMR 7289 - Universit d'Aix-Marseille, Marseille, France
@@ -69,14 +71,15 @@
 15. Arizona State University
 16. Ottawa Hospital Research Institute, Canada
 17. Swinburne University of Technology, Australia
 18. Case Western Reserve University (CWRU)  Department of Biology
 19. IAL Developmental Neurobiology, Kazan Federal University, Kazan, Russia
 20. Harden Technologies, LLC
 21. Institut des Neurosciences Paris-Saclay, CNRS UMR 9197 - Universit Paris-Sud, Gif-sur-Yvette, France
+22. Neurtex Brain Research Institute, Dallas, TX, USAs
 
 If we've somehow missed you off the list we're very sorry - please let us know.
 
 
 Acknowledgements
 ----------------
 
@@ -84,8 +87,8 @@
    :alt: "EU Logo"
    :height: 104px
    :width: 156px
    :align: right
 
 Neo was developed in part in the Human Brain Project,
 funded from the European Union's Horizon 2020 Framework Programme for Research and Innovation
-under Specific Grant Agreements No. 720270 and No. 785907 (Human Brain Project SGA1 and SGA2).
+under Specific Grant Agreements No. 720270 and No. 785907 (Human Brain Project SGA1 and SGA2).
```

### Comparing `neo-0.8.0/doc/source/conf.py` & `neo-0.9.0/doc/source/conf.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 #
 # neo documentation build configuration file, created by
 # sphinx-quickstart on Fri Feb 25 14:18:12 2011.
 #
 # This file is execfile()d with the current directory set to its containing
 # dir.
 #
@@ -21,15 +20,15 @@
     d = {}
     exec(fp.read(), d)
     neo_release = d['version']
 
 neo_version = '.'.join(str(e) for e in LooseVersion(neo_release).version[:2])
 
 
-AUTHORS = u'Neo authors and contributors <neuralensemble@googlegroups.com>'
+AUTHORS = 'Neo authors and contributors <neuralensemble@googlegroups.com>'
 
 # If extensions (or modules to document with autodoc) are in another directory,
 # add these directories to sys.path here. If the directory is relative to the
 # documentation root, use os.path.abspath to make it absolute, like shown here.
 # sys.path.append(os.path.abspath('.'))
 
 # -- General configuration ----------------------------------------------------
@@ -47,16 +46,16 @@
 # The encoding of source files.
 # source_encoding = 'utf-8'
 
 # The master toctree document.
 master_doc = 'index'
 
 # General information about the project.
-project = u'Neo'
-copyright = u'2010-2018, ' + AUTHORS
+project = 'Neo'
+copyright = '2010-2020, ' + AUTHORS
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
 # built documents.
 #
 # The short X.Y version.
 version = neo_version
@@ -189,15 +188,15 @@
 
 # The font size ('10pt', '11pt' or '12pt').
 # latex_font_size = '10pt'
 
 # Grouping the document tree into LaTeX files. List of tuples
 # (source start file, target name, title, author,
 #  documentclass [howto/manual]).
-latex_documents = [('index', 'neo.tex', u'Neo Documentation',
+latex_documents = [('index', 'neo.tex', 'Neo Documentation',
                     AUTHORS, 'manual')]
 
 # The name of an image file (relative to this directory) to place at the
 # top of the title page.
 # latex_logo = None
 
 # For "manual" documents, if this is true, then toplevel headings are parts,
@@ -212,9 +211,9 @@
 
 # If false, no module index is generated.
 # latex_use_modindex = True
 
 todo_include_todos = True  # set to False before releasing documentation
 
 rst_epilog = """
-.. |neo_github_url| replace:: https://github.com/NeuralEnsemble/python-neo/archive/neo-{0}.zip
+.. |neo_github_url| replace:: https://github.com/NeuralEnsemble/python-neo/archive/neo-{}.zip
 """.format(neo_release)
```

### Comparing `neo-0.8.0/doc/source/core.rst` & `neo-0.9.0/doc/source/core.rst`

 * *Files 6% similar despite different names*

```diff
@@ -34,42 +34,42 @@
   * :py:class:`Segment`: A container for heterogeneous discrete or continous data sharing a common
     clock (time basis) but not necessarily the same sampling rate, start time or end time.
     A :py:class:`Segment` can be considered as equivalent to a "trial", "episode", "run",
     "recording", etc., depending on the experimental context.
     May contain any of the data objects.
   * :py:class:`Block`: The top-level container gathering all of the data, discrete and continuous,
     for a given recording session.
-    Contains :class:`Segment`, :class:`Unit` and :class:`ChannelIndex` objects.
+    Contains :class:`Segment` and :class:`Group` objects.
 
 
 Grouping/linking objects
 ------------------------
 
 These objects express the relationships between data items, such as which signals
 were recorded on which electrodes, which spike trains were obtained from which
 membrane potential signals, etc. They contain references to data objects that
 cut across the simple container hierarchy.
 
-  * :py:class:`ChannelIndex`: A set of indices into :py:class:`AnalogSignal` objects,
-    representing logical and/or physical recording channels. This has two uses:
-
-      1. for linking :py:class:`AnalogSignal` objects recorded from the same (multi)electrode
-         across several :py:class:`Segment`\s.
-      2. for spike sorting of extracellular signals, where spikes may be recorded on more than one
-         recording channel, and the :py:class:`ChannelIndex` can be used to associate each
-         :py:class:`Unit` with the group of recording channels from which it was obtained.
-
-  * :py:class:`Unit`: links the :class:`SpikeTrain` objects within a :class:`Block`,
-    possibly across multiple Segments, that were emitted by the same cell.
-    A :class:`Unit` is linked to the :class:`ChannelIndex` object from which the spikes were detected.
+  * :py:class:`ChannelView`: A set of indices into :py:class:`AnalogSignal` objects,
+    representing logical and/or physical recording channels.
+    For spike sorting of extracellular signals, where spikes may be recorded on more than one
+    recording channel, the :py:class:`ChannelView` can be used to reference the group of recording channels
+    from which the spikes were obtained.
+
+  * :py:class:`Group`: Can contain any of the data objects, views, or other groups,
+    outside the hierarchy of the segment and block containers.
+    A common use is to link the :class:`SpikeTrain` objects within a :class:`Block`,
+    possibly across multiple Segments, that were emitted by the same neuron.
 
   * :py:class:`CircularRegionOfInterest`, :py:class:`RectangularRegionOfInterest` and :py:class:`PolygonRegionOfInterest`
     are three subclasses that link :class:`ImageSequence` objects to signals (:class:`AnalogSignal` objects)
     extracted from them.
 
+For more details, see :doc:`grouping`.
+
 
 NumPy compatibility
 ===================
 
 Neo data objects inherit from :py:class:`Quantity`, which in turn inherits from NumPy
 :py:class:`ndarray`. This means that a Neo :py:class:`AnalogSignal` is also a :py:class:`Quantity`
 and an array, giving you access to all of the methods available for those objects.
@@ -101,74 +101,76 @@
 
 In the :ref:`neo_diagram` below, these *one to many* relationships are represented by cyan arrows.
 In general, an object can access its children with an attribute *childname+s* in lower case, e.g.
 
     * :attr:`Block.segments`
     * :attr:`Segments.analogsignals`
     * :attr:`Segments.spiketrains`
-    * :attr:`Block.channel_indexes`
+    * :attr:`Block.groups`
 
 These relationships are bi-directional, i.e. a child object can access its parent:
 
     * :attr:`Segment.block`
     * :attr:`AnalogSignal.segment`
     * :attr:`SpikeTrain.segment`
-    * :attr:`ChannelIndex.block`
+    * :attr:`Group.block`
 
 Here is an example showing these relationships in use::
 
     from neo.io import AxonIO
-    import urllib
+    import urllib.request
     url = "https://web.gin.g-node.org/NeuralEnsemble/ephy_testing_data/raw/master/axon/File_axon_3.abf"
     filename = './test.abf'
-    urllib.urlretrieve(url, filename)
+    urllib.request.urlretrieve(url, filename)
 
     r = AxonIO(filename=filename)
-    bl = r.read() # read the entire file > a Block
+    blocks = r.read() # read the entire file > a list of Blocks
+    bl = blocks[0]
     print(bl)
     print(bl.segments) # child access
     for seg in bl.segments:
         print(seg)
         print(seg.block) # parent access
 
 
 In some cases, a one-to-many relationship is sufficient. Here is a simple example with tetrodes, in which each tetrode has its own group.::
 
-    from neo import Block, ChannelIndex
+    from neo import Block, Group
     bl = Block()
 
     # the four tetrodes
     for i in range(4):
-        chx = ChannelIndex(name='Tetrode %d' % i,
-                           index=[0, 1, 2, 3])
-        bl.channelindexes.append(chx)
+        group = Group(name='Tetrode %d' % i)
+        bl.groups.append(group)
 
     # now we load the data and associate it with the created channels
     # ...
 
-Now consider a more complex example: a 1x4 silicon probe, with a neuron on channels 0,1,2 and another neuron on channels 1,2,3. We create a group for each neuron to hold the :class:`Unit` object associated with this spike sorting group. Each group also contains the channels on which that neuron spiked. The relationship is many-to-many because channels 1 and 2 occur in multiple groups.::
+Now consider a more complex example: a 1x4 silicon probe, with a neuron on channels 0,1,2 and another neuron on channels 1,2,3.
+We create a group for each neuron to hold the spiketrains for each spike sorting group together with
+the channels on which that neuron spiked::
 
     bl = Block(name='probe data')
 
     # one group for each neuron
-    chx0 = ChannelIndex(name='Group 0',
-                        index=[0, 1, 2])
-    bl.channelindexes.append(chx0)
-
-    chx1 = ChannelIndex(name='Group 1',
-                        index=[1, 2, 3])
-    bl.channelindexes.append(chx1)
+    view0 = ChannelView(recorded_signals, index=[0, 1, 2])
+    unit0 = Group(view0, name='Group 0')
+    bl.groups.append(unit0)
+
+    view1 = ChannelView(recorded_signals, index=[1, 2, 3])
+    unit1 = Group(view1, name='Group 1')
+    bl.groups.append(unit1)
 
-    # now we add the spiketrain from Unit 0 to chx0
-    # and add the spiketrain from Unit 1 to chx1
+    # now we add the spiketrains from Unit 0 to unit0
+    # and add the spiketrains from Unit 1 to unit1
     # ...
 
-Note that because neurons are sorted from groups of channels in this situation, it is natural that the :py:class:`ChannelIndex` contains a reference to the :py:class:`Unit` object.
-That unit then contains references to its spiketrains. Also note that recording channels can be
-identified by names/labels as well as, or instead of, integer indices.
+
+Now each putative neuron is represented by a :class:`Group` containing the spiktrains of that neuron
+and a view of the signal selecting only those channels from which the spikes were obtained.
 
 
 See :doc:`usecases` for more examples of how the different objects may be used.
 
 .. _neo_diagram:
 
 Neo diagram
```

### Comparing `neo-0.8.0/doc/source/developers_guide.rst` & `neo-0.9.0/doc/source/developers_guide.rst`

 * *Files 11% similar despite different names*

```diff
@@ -34,27 +34,26 @@
 To keep track of changes to the code and to tickets, you can register for
 a GitHub account and then set to watch the repository at `GitHub Repository`_
 (see https://help.github.com/en/articles/watching-and-unwatching-repositories).
 
 Requirements
 ------------
 
-    * Python_ 2.7, 3.5 or later
-    * numpy_ >= 1.10.0
+    * Python_ 3.5 or later
+    * numpy_ >= 1.11.0
     * quantities_ >= 0.12.1
     * nose_ >= 1.1.2 (for running tests)
     * Sphinx_ (for building documentation)
     * (optional) coverage_ >= 2.85 (for measuring test coverage)
     * (optional) scipy >= 0.12 (for MatlabIO)
     * (optional) h5py >= 2.5 (for KwikIO, NeoHdf5IO)
     * (optional) nixio (for NixIO)
     * (optional) pillow (for TiffIO)
 
 We strongly recommend you develop within a virtual environment (from virtualenv, venv or conda).
-It is best to have at least one virtual environment with Python 2.7 and one with Python 3.x.
 
 Getting the source code
 -----------------------
 
 We use the Git version control system. The best way to contribute is through
 GitHub_. You will first need a GitHub account, and you should then fork the
 repository at `GitHub Repository`_
@@ -65,15 +64,14 @@
     $ cd /some/directory
     $ git clone git@github.com:<username>/python-neo.git
 
 Now you need to make sure that the ``neo`` package is on your PYTHONPATH.
 You can do this either by installing Neo::
 
     $ cd python-neo
-    $ python setup.py install
     $ python3 setup.py install
 
 (if you do this, you will have to re-run ``setup.py install`` any time you make
 changes to the code) *or* by creating symbolic links from somewhere on your
 PYTHONPATH, for example::
 
     $ ln -s python-neo/neo
@@ -96,31 +94,26 @@
 Running the test suite
 ----------------------
 
 Before you make any changes, run the test suite to make sure all the tests pass
 on your system::
 
     $ cd neo/test
-
-With Python 2.7 or 3.x::
-
-    $ python -m unittest discover
     $ python3 -m unittest discover
 
 If you have nose installed::
 
     $ nosetests
 
 At the end, if you see "OK", then all the tests
 passed (or were skipped because certain dependencies are not installed),
 otherwise it will report on tests that failed or produced errors.
 
 To run tests from an individual file::
 
-    $ python test_analogsignal.py
     $ python3 test_analogsignal.py
 
 
 Writing tests
 -------------
 
 You should try to write automated tests for any new code that you add. If you
@@ -196,38 +189,23 @@
 open a pull request on GitHub
 (see https://help.github.com/en/articles/about-pull-requests).
 
 
 Python version
 --------------
 
-Neo core should work with both Python 2.7 and Python 3 (version 3.5 or newer).
-Neo IO modules should ideally work with both Python 2 and 3, but certain
-modules may only work with one or the other (see :doc:`install`).
-
-So far, we have managed to write code that works with both Python 2 and 3.
-Mainly this involves avoiding the ``print`` statement (use ``logging.info``
-instead), and putting ``from __future__ import division`` at the beginning of
-any file that uses division.
-
-If in doubt, `Porting to Python 3`_ by Lennart Regebro is an excellent resource.
-
-The most important thing to remember is to run tests with at least one version
-of Python 2 and at least one version of Python 3. There is generally no problem
-in having multiple versions of Python installed on your computer at once: e.g.,
-on Ubuntu Python 2 is available as `python` and Python 3 as `python3`, while
-on Arch Linux Python 2 is `python2` and Python 3 `python`. See `PEP394`_ for
-more on this. Using virtual environments makes this very straightforward.
+Neo should work with Python 3.5 or newer. If you need support for Python 2.7,
+use Neo v0.8.0 or earlier.
 
 
 Coding standards and style
 --------------------------
 
 All code should conform as much as possible to `PEP 8`_, and should run with
-Python 2.7, and 3.5 or newer.
+Python 3.5 or newer.
 
 You can use the `pep8`_ program to check the code for PEP 8 conformity.
 You can also use `flake8`_, which combines pep8 and pyflakes.
 
 However, the pep8 and flake8 programs do not check for all PEP 8 issues.
 In particular, they do not check that the import statements are in the
 correct order.
```

### Comparing `neo-0.8.0/doc/source/developers_guide.rst.orig` & `neo-0.9.0/doc/source/developers_guide.rst.orig`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/images/generate_diagram.py` & `neo-0.9.0/doc/source/images/generate_diagram.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 """
 This generate diagram in .png and .svg from neo.core
 
 
 Author: sgarcia
 """
 
@@ -205,20 +203,21 @@
     figsize = (18, 12)
     rw = rect_width = 3.
     bf = blank_fact = 1.2
     rect_pos = {'Block': (.5 + rw * bf * 0, 4),
                 'Segment': (.5 + rw * bf * 1, .5),
                 'Event': (.5 + rw * bf * 4, 3.0),
                 'Epoch': (.5 + rw * bf * 4, 1.0),
-                'ChannelIndex': (.5 + rw * bf * 1, 7.5),
-                'Unit': (.5 + rw * bf * 2., 9.9),
+                'Group': (.5 + rw * bf * 1, 7.5),
+                'ChannelView': (.5 + rw * bf * 2., 9.9),
                 'SpikeTrain': (.5 + rw * bf * 3, 7.5),
                 'IrregularlySampledSignal': (.5 + rw * bf * 3, 0.5),
                 'AnalogSignal': (.5 + rw * bf * 3, 4.9),
                 }
+    # todo: add ImageSequence, RegionOfInterest
     generate_diagram('simple_generated_diagram.svg',
                      rect_pos, rect_width, figsize)
     generate_diagram('simple_generated_diagram.png',
                      rect_pos, rect_width, figsize)
 
 
 if __name__ == '__main__':
```

### Comparing `neo-0.8.0/doc/source/images/multi_segment_diagram.png` & `neo-0.9.0/doc/source/images/multi_segment_diagram.png`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/images/neo_UML_French_workshop.png` & `neo-0.9.0/doc/source/images/neo_UML_French_workshop.png`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/images/neologo.png` & `neo-0.9.0/doc/source/images/neologo.png`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/images/neologo_light.png` & `neo-0.9.0/doc/source/images/neologo_light.png`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/images/neologo_optical.png` & `neo-0.9.0/doc/source/images/neologo_optical.png`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/images/simple_generated_diagram.png` & `neo-0.9.0/doc/source/images/simple_generated_diagram.png`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/index.rst` & `neo-0.9.0/doc/source/index.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/io.rst` & `neo-0.9.0/doc/source/io.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/io_developers_guide.rst` & `neo-0.9.0/doc/source/io_developers_guide.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/rawio.rst` & `neo-0.9.0/doc/source/rawio.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/releases/0.5.0.rst` & `neo-0.9.0/doc/source/releases/0.5.0.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/releases/0.5.1.rst` & `neo-0.9.0/doc/source/releases/0.5.1.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/releases/0.5.2.rst` & `neo-0.9.0/doc/source/releases/0.5.2.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/releases/0.6.0.rst` & `neo-0.9.0/doc/source/releases/0.6.0.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/releases/0.7.0.rst` & `neo-0.9.0/doc/source/releases/0.7.0.rst`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/releases/0.8.0.rst` & `neo-0.9.0/doc/source/releases/0.8.0.rst`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 =======================
 Neo 0.8.0 release notes
 =======================
 
-27th September 2019
+30th September 2019
 
 Lazy loading
 ------------
 
 Neo 0.8 sees a major new feature, the ability to selectively load only parts of a data file
 (for supported file formats) into memory, for example only a subset of the signals
 in a segment, a subset of the channels in a signal, or even only a certain time slice of a given signal.
```

### Comparing `neo-0.8.0/doc/source/releases/0.8.0.rst.orig` & `neo-0.9.0/doc/source/releases/0.8.0.rst.orig`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/doc/source/usecases.rst` & `neo-0.9.0/doc/source/usecases.rst`

 * *Files 11% similar despite different names*

```diff
@@ -8,21 +8,21 @@
 In this example we suppose that we have recorded from an 8-channel probe, and
 that we have recorded three trials/episodes. We therefore have a total of
 8 x 3 = 24 signals, grouped into three :class:`AnalogSignal` objects, one per trial.
 
 Our entire dataset is contained in a :class:`Block`, which in turn contains:
 
   * 3 :class:`Segment` objects, each representing data from a single trial,
-  * 1 :class:`ChannelIndex`.
+  * 1 :class:`Group`.
 
 .. image:: images/multi_segment_diagram.png
    :width: 75%
    :align: center
 
-:class:`Segment` and :class:`ChannelIndex` objects provide two different
+:class:`Segment` and :class:`Group` objects provide two different
 ways to access the data, corresponding respectively, in this scenario, to access
 by **time** and by **space**.
 
 .. note:: Segments do not always represent trials, they can be used for many
           purposes: segments could represent parallel recordings for different
           subjects, or different steps in a current clamp protocol.
 
@@ -33,202 +33,199 @@
 to correlate the neural response with the stimulus that was delivered in each segment.
 In this example, we're averaging over the channels.
 
 .. doctest::
 
     import numpy as np
     from matplotlib import pyplot as plt
-    
+
     for seg in block.segments:
         print("Analyzing segment %d" % seg.index)
 
         avg = np.mean(seg.analogsignals[0], axis=1)
 
         plt.figure()
         plt.plot(avg)
         plt.title("Peak response in segment %d: %f" % (seg.index, avg.max()))
 
 **Spatial (by channel)**
 
-In this case you want to go through your data by channel location and average over time. 
+In this case you want to go through your data by channel location and average over time.
 Perhaps you want to see which physical location produces the strongest response, and every stimulus was the same:
-    
+
 .. doctest::
-    
-    # We assume that our block has only 1 ChannelIndex
-    chx = block.channelindexes[0]:
-    siglist = [sig[:, chx.index] for sig in chx.analogsignals]
-    avg = np.mean(siglist, axis=0)
-        
+
+    # We assume that our block has only 1 Group
+    group = block.groups[0]
+    avg = np.mean(group.analogsignals, axis=0)
+
     plt.figure()
-    for index, name in zip(chx.index, chx.channel_names):
+    for index, name in enumerate(group.annotations["channel_names"]):
         plt.plot(avg[:, index])
         plt.title("Average response on channels %s: %s' % (index, name)
 
-
-
 **Mixed example**
 
 Combining simultaneously the two approaches of descending the hierarchy
 temporally and spatially can be tricky. Here's an example.
 Let's say you saw something interesting on the 6th channel (index 5) on even numbered trials
 during the experiment and you want to follow up. What was the average response?
 
 .. doctest::
 
-    index = chx.index[5]
+    index = 5
     avg = np.mean([seg.analogsignals[0][:, index] for seg in block.segments[::2]], axis=1)
     plt.plot(avg)
 
 
 Recording spikes from multiple tetrodes
 =======================================
 
 Here is a similar example in which we have recorded with two tetrodes and
 extracted spikes from the extra-cellular signals. The spike times are contained
 in :class:`SpikeTrain` objects.
 
-Again, our data set is contained in a :class:`Block`, which contains:
-
   * 3 :class:`Segments` (one per trial).
-  * 2 :class:`ChannelIndexes` (one per tetrode), which contain:
-  
-    * 2 :class:`Unit` objects (= 2 neurons) for the first :class:`ChannelIndex`
-    * 5 :class:`Units` for the second :class:`ChannelIndex`.
+  * 7 :class:`Groups` (one per neuron), which each contain:
+
+    * 3 :class:`SpikeTrain` objects
+    * an annotation showing which tetrode the spiketrains were recorded from
 
 In total we have 3 x 7 = 21 :class:`SpikeTrains` in this :class:`Block`.
 
 .. image:: images/multi_segment_diagram_spiketrain.png
    :width: 75%
    :align: center
 
+.. note:: In this scenario we have discarded the original signals, perhaps to save
+          space, therefore we use annotations to link the spiketrains to the tetrode
+          they were recorded from. If we wished to include the original
+          extracellular signals, we would add a reference to the three :class:`AnalogSignal`
+          objects for the appropriate tetrode to the :class:`Group` for each neuron.
 
 There are three ways to access the :class:`SpikeTrain` data:
 
-  * by :class:`Segment`
-  * by :class:`RecordingChannel`
-  * by :class:`Unit`
+  * by trial (:class:`Segment`)
+  * by neuron (:class:`Group`)
+  * by tetrode
 
-**By Segment**
+**By trial**
 
 In this example, each :class:`Segment` represents data from one trial, and we
 want a PSTH for each trial from all units combined:
 
 .. doctest::
 
+    plt.figure()
     for seg in block.segments:
-        print("Analyzing segment %d" % seg.index)
+        print(f"Analyzing segment {seg.index}")
         stlist = [st - st.t_start for st in seg.spiketrains]
-        plt.figure()
+        plt.subplot(len(block.segments), 1, seg.index + 1)
         count, bins = np.histogram(stlist)
         plt.bar(bins[:-1], count, width=bins[1] - bins[0])
-        plt.title("PSTH in segment %d" % seg.index)
+        plt.title(f"PSTH in segment {seg.index}")
+    plt.show()
 
-**By Unit**
+**By neuron**
 
 Now we can calculate the PSTH averaged over trials for each unit, using the
-:attr:`block.list_units` property:
+:attr:`block.groups` property:
 
 .. doctest::
 
-    for unit in block.list_units:
-        stlist = [st - st.t_start for st in unit.spiketrains]
-        plt.figure()
+    plt.figure()
+    for i, group in enumerate(block.groups):
+        stlist = [st - st.t_start for st in group.spiketrains]
+        plt.subplot(len(block.groups), 1, i + 1)
         count, bins = np.histogram(stlist)
         plt.bar(bins[:-1], count, width=bins[1] - bins[0])
-        plt.title("PSTH of unit %s" % unit.name)
-        
+        plt.title(f"PSTH of unit {group.name}")
+    plt.show()
+
 
-**By ChannelIndex**
+**By tetrode**
 
 Here we calculate a PSTH averaged over trials by channel location,
 blending all units:
 
 .. doctest::
 
-    for chx in block.channelindexes:
+    plt.figure()
+    for i, tetrode_id in enumerate(block.annotations["tetrode_ids"]):
         stlist = []
-        for unit in chx.units:
+        for unit in block.filter(objects=Group, tetrode_id=tetrode_id):
             stlist.extend([st - st.t_start for st in unit.spiketrains])
-        plt.figure()
+        plt.subplot(2, 1, i + 1)
         count, bins = np.histogram(stlist)
         plt.bar(bins[:-1], count, width=bins[1] - bins[0])
-        plt.title("PSTH blend of tetrode  %s" % chx.name)
+        plt.title(f"PSTH blend of tetrode {tetrode_id}")
+    plt.show()
 
 
 Spike sorting
 =============
 
 Spike sorting is the process of detecting and classifying high-frequency
 deflections ("spikes") on a group of physically nearby recording channels.
 
-For example, let's say you have defined a ChannelIndex for a tetrode
+For example, let's say you have recordings from a tetrode
 containing 4 separate channels. Here is an example showing (with fake data)
 how you could iterate over the contained signals and extract spike times.
 (Of course in reality you would use a more sophisticated algorithm.)
 
 .. doctest::
 
     # generate some fake data
     seg = Segment()
     seg.analogsignals.append(
         AnalogSignal([[0.1, 0.1, 0.1, 0.1],
-                      [-2.0, -2.0, -2.0, -2.0],
-                      [0.1, 0.1, 0.1, 0.1],
-                      [-0.1, -0.1, -0.1, -0.1],
-                      [-0.1, -0.1, -0.1, -0.1],
-                      [-3.0, -3.0, -3.0, -3.0],
-                      [0.1, 0.1, 0.1, 0.1],
-                      [0.1, 0.1, 0.1, 0.1]],
-                     sampling_rate=1000*Hz, units='V'))
-    chx = ChannelIndex(channel_indexes=[0, 1, 2, 3])
-    chx.analogsignals.append(seg.analogsignals[0])
-
+                    [-2.0, -2.0, -2.0, -2.0],
+                    [0.1, 0.1, 0.1, 0.1],
+                    [-0.1, -0.1, -0.1, -0.1],
+                    [-0.1, -0.1, -0.1, -0.1],
+                    [-3.0, -3.0, -3.0, -3.0],
+                    [0.1, 0.1, 0.1, 0.1],
+                    [0.1, 0.1, 0.1, 0.1]],
+                    sampling_rate=1000*Hz, units='V'))
 
-    # extract spike trains from each channel
+    # extract spike trains from all channels
     st_list = []
-    for signal in chx.analogsignals:
+    for signal in seg.analogsignals:
         # use a simple threshhold detector
         spike_mask = np.where(np.min(signal.magnitude, axis=1) < -1.0)[0]
-        
+
         # create a spike train
         spike_times = signal.times[spike_mask]
-        st = neo.SpikeTrain(spike_times, t_start=signal.t_start, t_stop=signal.t_stop)
-        
+        st = SpikeTrain(spike_times, t_start=signal.t_start, t_stop=signal.t_stop)
+
         # remember the spike waveforms
         wf_list = []
         for spike_idx in np.nonzero(spike_mask)[0]:
             wf_list.append(signal[spike_idx-1:spike_idx+2, :])
         st.waveforms = np.array(wf_list)
-        
+
         st_list.append(st)
 
 At this point, we have a list of spiketrain objects. We could simply create
-a single Unit object, assign all spike trains to it, and then assign the
-Unit to the group on which we detected it.
+a single :class:`Group` object, assign all spiketrains to it, and then also assign the
+:class:`AnalogSignal` on which we detected them.
 
 .. doctest::
-    
-    u = Unit()
-    u.spiketrains = st_list
-    chx.units.append(u)
-
-Now the recording channel group (tetrode) contains a list of analogsignals,
-and a single Unit object containing all of the detected spiketrains from those
-signals.
+
+    unit = Group()
+    unit.spiketrains = st_list
+    unit.analogsignals.extend(seg.analogsignals)
 
 Further processing could assign each of the detected spikes to an independent
 source, a putative single neuron. (This processing is outside the scope of
 Neo. There are many open-source toolboxes to do it, for instance our sister
 project OpenElectrophy.)
 
-In that case we would create a separate Unit for each cluster, assign its
-spiketrains to it, and then store all the units in the original
-recording channel group.
+In that case we would create a separate :class:`Group` for each cluster, assign its
+spiketrains to it, and still store in each group a reference to the original
+recording.
 
 
 
 .. EEG
 
 .. Network simulations
-
-
```

### Comparing `neo-0.8.0/doc/source/whatisnew.rst` & `neo-0.9.0/doc/source/whatisnew.rst`

 * *Files 2% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 Release notes
 =============
 
 
 .. toctree::
    :maxdepth: 1
 
+   releases/0.9.0.rst
    releases/0.8.0.rst
    releases/0.7.2.rst
    releases/0.7.1.rst
    releases/0.7.0.rst
    releases/0.6.0.rst
    releases/0.5.2.rst
    releases/0.5.1.rst
```

### Comparing `neo-0.8.0/examples/generated_data.py` & `neo-0.9.0/examples/generated_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 This is an example for creating simple plots from various Neo structures.
 It includes a function that generates toy data.
 """
-from __future__ import division  # Use same division in Python 2 and 3
 
 import numpy as np
 import quantities as pq
 from matplotlib import pyplot as plt
 
 import neo
```

### Comparing `neo-0.8.0/examples/hbp_d571_example.py` & `neo-0.9.0/examples/hbp_d571_example_orig.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/examples/hbp_d571_example2.py` & `neo-0.9.0/examples/hbp_d571_example2.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/examples/imageseq.py` & `neo-0.9.0/examples/imageseq.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/examples/read_files_neo_io.py` & `neo-0.9.0/examples/read_files_neo_io.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 This is an example for reading files with neo.io
 """
 
 import urllib
 
 import neo
```

### Comparing `neo-0.8.0/examples/read_files_neo_rawio.py` & `neo-0.9.0/examples/read_files_neo_rawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 This is an example for reading files with neo.rawio
 compare with read_files_neo_io.py
 """
 
 import urllib
 from neo.rawio import PlexonRawIO
```

### Comparing `neo-0.8.0/examples/read_proxy_with_lazy_load.py` & `neo-0.9.0/examples/read_proxy_with_lazy_load.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 This is an example demonstrate the lazy load and proxy objects.
 
 """
 
 import urllib
 import neo
```

### Comparing `neo-0.8.0/examples/roi_demo.py` & `neo-0.9.0/examples/roi_demo.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/examples/simple_plot_with_matplotlib.py` & `neo-0.9.0/examples/simple_plot_with_matplotlib.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 This is an example for plotting a Neo object with matplotlib.
 """
 
 import urllib
 
 import numpy as np
```

### Comparing `neo-0.8.0/neo/core/__init__.py` & `neo-0.9.0/neo/core/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,41 +1,43 @@
-# -*- coding: utf-8 -*-
 """
 :mod:`neo.core` provides classes for storing common electrophysiological data
 types.  Some of these classes contain raw data, such as spike trains or
 analog signals, while others are containers to organize other classes
 (including both data classes and other container classes).
 
 Classes from :mod:`neo.io` return nested data structures containing one
 or more class from this module.
 
 Classes:
 
 .. autoclass:: Block
 .. autoclass:: Segment
-.. autoclass:: ChannelIndex
-.. autoclass:: Unit
+.. autoclass:: Group
 
 .. autoclass:: AnalogSignal
 .. autoclass:: IrregularlySampledSignal
 
+.. autoclass:: ChannelView
+
 .. autoclass:: Event
 .. autoclass:: Epoch
 
 .. autoclass:: SpikeTrain
 .. autoclass:: ImageSequence
 
 .. autoclass:: RectangularRegionOfInterest
 .. autoclass:: CircularRegionOfInterest
 .. autoclass:: PolygonRegionOfInterest
 
-"""
+Deprecated classes:
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
+.. autoclass:: ChannelIndex
+.. autoclass:: Unit
+
+"""
 
 from neo.core.block import Block
 from neo.core.segment import Segment
 from neo.core.channelindex import ChannelIndex
 from neo.core.unit import Unit
 
 from neo.core.analogsignal import AnalogSignal
@@ -45,16 +47,19 @@
 from neo.core.epoch import Epoch
 
 from neo.core.spiketrain import SpikeTrain
 
 from neo.core.imagesequence import ImageSequence
 from neo.core.regionofinterest import RectangularRegionOfInterest, CircularRegionOfInterest, PolygonRegionOfInterest
 
+from neo.core.view import ChannelView
+from neo.core.group import Group
+
 # Block should always be first in this list
 objectlist = [Block, Segment, ChannelIndex,
               AnalogSignal, IrregularlySampledSignal,
               Event, Epoch, Unit, SpikeTrain, ImageSequence,
               RectangularRegionOfInterest, CircularRegionOfInterest,
-              PolygonRegionOfInterest]
+              PolygonRegionOfInterest, ChannelView, Group]
 
 objectnames = [ob.__name__ for ob in objectlist]
 class_by_name = dict(zip(objectnames, objectlist))
```

### Comparing `neo-0.8.0/neo/core/analogsignal.py` & `neo-0.9.0/neo/core/analogsignal.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 This module implements :class:`AnalogSignal`, an array of analog signals.
 
 :class:`AnalogSignal` inherits from :class:`basesignal.BaseSignal` which
 derives from :class:`BaseNeo`, and from :class:`quantites.Quantity`which
 in turn inherits from :class:`numpy.array`.
 
@@ -14,25 +13,28 @@
 This is where user-specified attributes are set.
 
 * :meth:`__array_finalize__` is called for all new objects, including those
 created by slicing. This is where attributes are copied over from
 the old object.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import logging
 
+try:
+    import scipy.signal
+except ImportError as err:
+    HAVE_SCIPY = False
+else:
+    HAVE_SCIPY = True
+
 import numpy as np
 import quantities as pq
 
-from neo.core.baseneo import BaseNeo, MergeError, merge_annotations
+from neo.core.baseneo import BaseNeo, MergeError, merge_annotations, intersect_annotations
 from neo.core.dataobject import DataObject
-from neo.core.channelindex import ChannelIndex
 from copy import copy, deepcopy
 
 from neo.core.basesignal import BaseSignal
 
 logger = logging.getLogger("Neo")
 
 
@@ -135,15 +137,15 @@
             (size * :attr:`sampling_period`)
         :t_stop: (quantity scalar) Time when signal ends, read-only.
             (:attr:`t_start` + :attr:`duration`)
         :times: (quantity 1D) The time points of each sample of the signal,
             read-only.
             (:attr:`t_start` + arange(:attr:`shape`[0])/:attr:`sampling_rate`)
         :channel_index:
-            access to the channel_index attribute of the principal ChannelIndex
+            (deprecated) access to the channel_index attribute of the principal ChannelIndex
             associated with this signal.
 
     *Slicing*:
         :class:`AnalogSignal` objects can be sliced. When taking a single
         column (dimension 0, e.g. [0, :]) or a single element,
         a :class:`~quantities.Quantity` is returned.
         Otherwise an :class:`AnalogSignal` (actually a view) is
@@ -234,15 +236,15 @@
         return obj
 
     def __repr__(self):
         '''
         Returns a string representing the :class:`AnalogSignal`.
         '''
         return ('<%s(%s, [%s, %s], sampling rate: %s)>' % (self.__class__.__name__,
-                                                           super(AnalogSignal, self).__repr__(),
+                                                           super().__repr__(),
                                                            self.t_start, self.t_stop,
                                                            self.sampling_rate))
 
     def get_channel_index(self):
         """
         """
         if self.channel_index:
@@ -251,18 +253,18 @@
             return None
 
     def __getitem__(self, i):
         '''
         Get the item or slice :attr:`i`.
         '''
         if isinstance(i, (int, np.integer)):  # a single point in time across all channels
-            obj = super(AnalogSignal, self).__getitem__(i)
+            obj = super().__getitem__(i)
             obj = pq.Quantity(obj.magnitude, units=obj.units)
         elif isinstance(i, tuple):
-            obj = super(AnalogSignal, self).__getitem__(i)
+            obj = super().__getitem__(i)
             j, k = i
             if isinstance(j, (int, np.integer)):  # extract a quantity array
                 obj = pq.Quantity(obj.magnitude, units=obj.units)
             else:
                 if isinstance(j, slice):
                     if j.start:
                         obj.t_start = (self.t_start + j.start * self.sampling_period)
@@ -276,15 +278,15 @@
                     raise TypeError("%s not supported" % type(j))
                 if isinstance(k, (int, np.integer)):
                     obj = obj.reshape(-1, 1)
                 if self.channel_index:
                     obj.channel_index = self.channel_index.__getitem__(k)
                 obj.array_annotate(**deepcopy(self.array_annotations_at_index(k)))
         elif isinstance(i, slice):
-            obj = super(AnalogSignal, self).__getitem__(i)
+            obj = super().__getitem__(i)
             if i.start:
                 obj.t_start = self.t_start + i.start * self.sampling_period
             obj.array_annotations = deepcopy(self.array_annotations)
         elif isinstance(i, np.ndarray):
             # Indexing of an AnalogSignal is only consistent if the resulting number of
             # samples is the same for each trace. The time axis for these samples is not
             # guaranteed to be continuous, so returning a Quantity instead of an AnalogSignal here.
@@ -308,15 +310,15 @@
         # we need to handle the case where `i` is an integer
         if isinstance(i, int):
             i = slice(i, i + 1)
         elif isinstance(i, tuple):
             j, k = i
             if isinstance(k, int):
                 i = (j, slice(k, k + 1))
-        return super(AnalogSignal, self).__setitem__(i, value)
+        return super().__setitem__(i, value)
 
     # sampling_rate attribute is handled as a property so type checking can
     # be done
     @property
     def sampling_rate(self):
         '''
         Number of samples per unit time.
@@ -404,15 +406,15 @@
     def __eq__(self, other):
         '''
         Equality test (==)
         '''
         if (isinstance(other, AnalogSignal) and (
                 self.t_start != other.t_start or self.sampling_rate != other.sampling_rate)):
             return False
-        return super(AnalogSignal, self).__eq__(other)
+        return super().__eq__(other)
 
     def _check_consistency(self, other):
         '''
         Check if the attributes of another :class:`AnalogSignal`
         are compatible with this one.
         '''
         if isinstance(other, AnalogSignal):
@@ -436,22 +438,21 @@
             self._repr_pretty_attrs_(pp, cycle)
 
         def _pp(line):
             pp.breakable()
             with pp.group(indent=1):
                 pp.text(line)
 
-        for line in ["sampling rate: {}".format(self.sampling_rate),
-                     "time: {} to {}".format(self.t_start, self.t_stop)]:
-            _pp(line)
+        _pp("sampling rate: {}".format(self.sampling_rate))
+        _pp("time: {} to {}".format(self.t_start, self.t_stop))
 
     def time_index(self, t):
-        """Return the array index corresponding to the time `t`"""
+        """Return the array index (or indices) corresponding to the time (or times) `t`"""
         i = (t - self.t_start) * self.sampling_rate
-        i = int(np.rint(i.simplified.magnitude))
+        i = np.rint(i.simplified.magnitude).astype(np.int)
         return i
 
     def time_slice(self, t_start, t_stop):
         '''
         Creates a new AnalogSignal corresponding to the time slice of the
         original AnalogSignal between times t_start, t_stop. Note, that for
         numerical stability reasons if t_start does not fall exactly on
@@ -535,7 +536,257 @@
             new_signal.segment = None
             new_signal.channel_index = None
             new_signal[i:j, :] = signal
             return new_signal
         else:
             self[i:j, :] = signal
             return self
+
+    def downsample(self, downsampling_factor, **kwargs):
+        """
+        Downsample the data of a signal.
+        This method reduces the number of samples of the AnalogSignal to a fraction of the
+        original number of samples, defined by `downsampling_factor`.
+        This method is a wrapper of scipy.signal.decimate and accepts the same set of keyword
+        arguments, except for specifying the axis of resampling, which is fixed to the first axis
+        here.
+
+        Parameters:
+        -----------
+        downsampling_factor: integer
+            Factor used for decimation of samples. Scipy recommends to call decimate multiple times
+            for downsampling factors higher than 13 when using IIR downsampling (default).
+
+        Returns:
+        --------
+        downsampled_signal: :class:`AnalogSignal`
+            New instance of a :class:`AnalogSignal` object containing the resampled data points.
+            The original :class:`AnalogSignal` is not modified.
+
+        Note:
+        -----
+        For resampling the signal with a fixed number of samples, see `resample` method.
+        """
+
+        if not HAVE_SCIPY:
+            raise ImportError('Decimating requires availability of scipy.signal')
+
+        # Resampling is only permitted along the time axis (axis=0)
+        if 'axis' in kwargs:
+            kwargs.pop('axis')
+
+        downsampled_data = scipy.signal.decimate(self.magnitude, downsampling_factor, axis=0,
+                                                 **kwargs)
+        downsampled_signal = self.duplicate_with_new_data(downsampled_data)
+
+        # since the number of channels stays the same, we can also copy array annotations here
+        downsampled_signal.array_annotations = self.array_annotations.copy()
+        downsampled_signal.sampling_rate = self.sampling_rate / downsampling_factor
+
+        return downsampled_signal
+
+    def resample(self, sample_count, **kwargs):
+        """
+        Resample the data points of the signal.
+        This method interpolates the signal and returns a new signal with a fixed number of
+        samples defined by `sample_count`.
+        This method is a wrapper of scipy.signal.resample and accepts the same set of keyword
+        arguments, except for specifying the axis of resampling which is fixed to the first axis
+        here, and the sample positions. .
+
+        Parameters:
+        -----------
+        sample_count: integer
+            Number of desired samples. The resulting signal starts at the same sample as the
+            original and is sampled regularly.
+
+        Returns:
+        --------
+        resampled_signal: :class:`AnalogSignal`
+            New instance of a :class:`AnalogSignal` object containing the resampled data points.
+            The original :class:`AnalogSignal` is not modified.
+
+        Note:
+        -----
+        For reducing the number of samples to a fraction of the original, see `downsample` method
+        """
+
+        if not HAVE_SCIPY:
+            raise ImportError('Resampling requires availability of scipy.signal')
+
+        # Resampling is only permitted along the time axis (axis=0)
+        if 'axis' in kwargs:
+            kwargs.pop('axis')
+        if 't' in kwargs:
+            kwargs.pop('t')
+
+        resampled_data, resampled_times = scipy.signal.resample(self.magnitude, sample_count,
+                                                                t=self.times, axis=0, **kwargs)
+
+        resampled_signal = self.duplicate_with_new_data(resampled_data)
+        resampled_signal.sampling_rate = (sample_count / self.shape[0]) * self.sampling_rate
+
+        # since the number of channels stays the same, we can also copy array annotations here
+        resampled_signal.array_annotations = self.array_annotations.copy()
+
+        return resampled_signal
+
+    def rectify(self, **kwargs):
+        """
+        Rectify the signal.
+        This method rectifies the signal by taking the absolute value.
+        This method is a wrapper of numpy.absolute() and accepts the same set of keyword
+        arguments.
+
+        Returns:
+        --------
+        resampled_signal: :class:`AnalogSignal`
+            New instance of a :class:`AnalogSignal` object containing the rectified data points.
+            The original :class:`AnalogSignal` is not modified.
+
+        """
+
+        # Use numpy to get the absolute value of the signal
+        rectified_data = np.absolute(self.magnitude, **kwargs)
+
+        rectified_signal = self.duplicate_with_new_data(rectified_data)
+
+        # the sampling rate stays constant
+        rectified_signal.sampling_rate = self.sampling_rate
+
+        # since the number of channels stays the same, we can also copy array annotations here
+        rectified_signal.array_annotations = self.array_annotations.copy()
+
+        return rectified_signal
+
+    def concatenate(self, *signals, overwrite=False, padding=False):
+        """
+        Concatenate multiple neo.AnalogSignal objects across time.
+
+        Units, sampling_rate and number of signal traces must be the same
+        for all signals. Otherwise a ValueError is raised.
+        Note that timestamps of concatenated signals might shift in oder to
+        align the sampling times of all signals.
+
+        Parameters
+        ----------
+        signals: neo.AnalogSignal objects
+            AnalogSignals that will be concatenated
+        overwrite : bool
+            If True, samples of the earlier (lower index in `signals`)
+            signals are overwritten by that of later (higher index in `signals`)
+            signals.
+            If False, samples of the later are overwritten by earlier signal.
+            Default: False
+        padding : bool, scalar quantity
+            Sampling values to use as padding in case signals do not overlap.
+            If False, do not apply padding. Signals have to align or
+            overlap. If True, signals will be padded using
+            np.NaN as pad values. If a scalar quantity is provided, this
+            will be used for padding. The other signal is moved
+            forward in time by maximum one sampling period to
+            align the sampling times of both signals.
+            Default: False
+
+        Returns
+        -------
+        signal: neo.AnalogSignal
+            concatenated output signal
+        """
+
+        # Sanity of inputs
+        if not hasattr(signals, '__iter__'):
+            raise TypeError('signals must be iterable')
+        if not all([isinstance(a, AnalogSignal) for a in signals]):
+            raise TypeError('Entries of anasiglist have to be of type neo.AnalogSignal')
+        if len(signals) == 0:
+            return self
+
+        signals = [self] + list(signals)
+
+        # Check required common attributes: units, sampling_rate and shape[-1]
+        shared_attributes = ['units', 'sampling_rate']
+        attribute_values = [tuple((getattr(anasig, attr) for attr in shared_attributes))
+                            for anasig in signals]
+        # add shape dimensions that do not relate to time
+        attribute_values = [(attribute_values[i] + (signals[i].shape[1:],))
+                            for i in range(len(signals))]
+        if not all([attrs == attribute_values[0] for attrs in attribute_values]):
+            raise MergeError(
+                f'AnalogSignals have to share {shared_attributes} attributes to be concatenated.')
+        units, sr, shape = attribute_values[0]
+
+        # find gaps between Analogsignals
+        combined_time_ranges = self._concatenate_time_ranges(
+            [(s.t_start, s.t_stop) for s in signals])
+        missing_time_ranges = self._invert_time_ranges(combined_time_ranges)
+        if len(missing_time_ranges):
+            diffs = np.diff(np.asarray(missing_time_ranges), axis=1)
+        else:
+            diffs = []
+
+        if padding is False and any(diffs > signals[0].sampling_period):
+            raise MergeError(f'Signals are not continuous. Can not concatenate signals with gaps. '
+                             f'Please provide a padding value.')
+        if padding is not False:
+            logger.warning('Signals will be padded using {}.'.format(padding))
+            if padding is True:
+                padding = np.NaN * units
+            if isinstance(padding, pq.Quantity):
+                padding = padding.rescale(units).magnitude
+            else:
+                raise MergeError('Invalid type of padding value. Please provide a bool value '
+                                 'or a quantities object.')
+
+        t_start = min([a.t_start for a in signals])
+        t_stop = max([a.t_stop for a in signals])
+        n_samples = int(np.rint(((t_stop - t_start) * sr).rescale('dimensionless').magnitude))
+        shape = (n_samples,) + shape
+
+        # Collect attributes and annotations across all concatenated signals
+        kwargs = {}
+        common_annotations = signals[0].annotations
+        common_array_annotations = signals[0].array_annotations
+        for anasig in signals[1:]:
+            common_annotations = intersect_annotations(common_annotations, anasig.annotations)
+            common_array_annotations = intersect_annotations(common_array_annotations,
+                                                             anasig.array_annotations)
+
+        kwargs['annotations'] = common_annotations
+        kwargs['array_annotations'] = common_array_annotations
+
+        for name in ("name", "description", "file_origin"):
+            attr = [getattr(s, name) for s in signals]
+            if all([a == attr[0] for a in attr]):
+                kwargs[name] = attr[0]
+            else:
+                kwargs[name] = f'concatenation ({attr})'
+
+        conc_signal = AnalogSignal(np.full(shape=shape, fill_value=padding, dtype=signals[0].dtype),
+                                   sampling_rate=sr, t_start=t_start, units=units, **kwargs)
+
+        if not overwrite:
+            signals = signals[::-1]
+        while len(signals) > 0:
+            conc_signal.splice(signals.pop(0), copy=False)
+
+        return conc_signal
+
+    def _concatenate_time_ranges(self, time_ranges):
+        time_ranges = sorted(time_ranges)
+        new_ranges = time_ranges[:1]
+        for t_start, t_stop in time_ranges[1:]:
+            # time range are non continuous -> define new range
+            if t_start > new_ranges[-1][1]:
+                new_ranges.append((t_start, t_stop))
+            # time range is continuous -> extend time range
+            elif t_stop > new_ranges[-1][1]:
+                new_ranges[-1] = (new_ranges[-1][0], t_stop)
+        return new_ranges
+
+    def _invert_time_ranges(self, time_ranges):
+        i = 0
+        new_ranges = []
+        while i < len(time_ranges) - 1:
+            new_ranges.append((time_ranges[i][1], time_ranges[i + 1][0]))
+            i += 1
+        return new_ranges
```

### Comparing `neo-0.8.0/neo/core/baseneo.py` & `neo-0.9.0/neo/core/baseneo.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,13 @@
-# -*- coding: utf-8 -*-
 """
 This module defines :class:`BaseNeo`, the abstract base class
 used by all :module:`neo.core` classes.
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
+from copy import deepcopy
 from datetime import datetime, date, time, timedelta
 from decimal import Decimal
 import logging
 from numbers import Number
 
 import numpy as np
 
@@ -23,19 +20,14 @@
 
 # handle both Python 2 and Python 3
 try:
     ALLOWED_ANNOTATION_TYPES += (long, unicode)
 except NameError:
     pass
 
-try:
-    basestring
-except NameError:
-    basestring = str
-
 logger = logging.getLogger("Neo")
 
 
 class MergeError(Exception):
     pass
 
 
@@ -76,54 +68,83 @@
                                                                b, type(b))
     if isinstance(a, dict):
         return merge_annotations(a, b)
     elif isinstance(a, np.ndarray):  # concatenate b to a
         return np.append(a, b)
     elif isinstance(a, list):  # concatenate b to a
         return a + b
-    elif isinstance(a, basestring):
+    elif isinstance(a, str):
         if a == b:
             return a
         else:
             return a + ";" + b
     else:
         assert a == b, '{} != {}'.format(a, b)
         return a
 
 
-def merge_annotations(A, B):
+def merge_annotations(A, *Bs):
     """
     Merge two sets of annotations.
 
     Merging follows these rules:
     All keys that are in A or B, but not both, are kept.
     For keys that are present in both:
         For arrays or lists: concatenate
         For dicts: merge recursively
         For strings: concatenate with ';'
         Otherwise: warn if the annotations are not equal
     """
-    merged = {}
-    for name in A:
-        if name in B:
-            try:
-                merged[name] = merge_annotation(A[name], B[name])
-            except BaseException as exc:
-                # exc.args += ('key %s' % name,)
-                # raise
-                merged[name] = "MERGE CONFLICT"  # temporary hack
-        else:
-            merged[name] = A[name]
-    for name in B:
-        if name not in merged:
-            merged[name] = B[name]
-    logger.debug("Merging annotations: A=%s B=%s merged=%s", A, B, merged)
+    merged = A.copy()
+    for B in Bs:
+        for name in B:
+            if name not in merged:
+                merged[name] = B[name]
+            else:
+                try:
+                    merged[name] = merge_annotation(merged[name], B[name])
+                except BaseException as exc:
+                    # exc.args += ('key %s' % name,)
+                    # raise
+                    merged[name] = "MERGE CONFLICT"  # temporary hack
+    logger.debug("Merging annotations: A=%s Bs=%s merged=%s", A, Bs, merged)
     return merged
 
 
+def intersect_annotations(A, B):
+    """
+    Identify common entries in dictionaries A and B
+    and return these in a separate dictionary.
+
+    Entries have to share key as well as value to be
+    considered common.
+
+    Parameters
+    ----------
+    A, B : dict
+        Dictionaries to merge.
+    """
+
+    result = {}
+
+    for key in set(A.keys()) & set(B.keys()):
+        v1, v2 = A[key], B[key]
+        assert type(v1) == type(v2), 'type({}) {} != type({}) {}'.format(v1, type(v1),
+                                                                         v2, type(v2))
+        if isinstance(v1, dict) and v1 == v2:
+            result[key] = deepcopy(v1)
+        elif isinstance(v1, str) and v1 == v2:
+            result[key] = A[key]
+        elif isinstance(v1, list) and v1 == v2:
+            result[key] = deepcopy(v1)
+        elif isinstance(v1, np.ndarray) and all(v1 == v2):
+            result[key] = deepcopy(v1)
+    return result
+
+
 def _reference_name(class_name):
     """
     Given the name of a class, return an attribute name to be used for
     references to instances of that class.
 
     For example, a Segment object has a parent Block object, referenced by
     `segment.block`. The attribute name `block` is obtained by calling
@@ -146,15 +167,15 @@
     """
     name_map = {
         "ChannelIndex": "channel_indexes"
     }
     return name_map.get(class_name, _reference_name(class_name) + 's')
 
 
-class BaseNeo(object):
+class BaseNeo:
     """
     This is the base class from which all Neo objects inherit.
 
     This class implements support for universally recommended arguments,
     and also sets up the :attr:`annotations` dict for additional arguments.
 
     Each class can define one or more of the following class attributes:
@@ -245,15 +266,15 @@
     # Parent objects whose children can have a single parent
     _single_parent_objects = ()
     # Attribute names corresponding to _single_parent_objects
     _single_parent_attrs = ()
     # Parent objects whose children can have multiple parents
     _multi_parent_objects = ()
 
-    # Attributes that an instance is requires to have defined
+    # Attributes that an instance is required to have defined
     _necessary_attrs = ()
     # Attributes that an instance may or may have defined
     _recommended_attrs = (('name', str),
                           ('description', str),
                           ('file_origin', str))
     # Attributes that are used for pretty-printing
     _repr_pretty_attrs_keys_ = ("name", "description", "annotations")
@@ -365,37 +386,38 @@
     def _all_attrs(self):
         """
         Returns a combination of all required and recommended
         attributes.
         """
         return self._necessary_attrs + self._recommended_attrs
 
-    def merge_annotations(self, other):
+    def merge_annotations(self, *others):
         """
         Merge annotations from the other object into this one.
 
         Merging follows these rules:
         All keys that are in the either object, but not both, are kept.
         For keys that are present in both objects:
             For arrays or lists: concatenate the two arrays
             For dicts: merge recursively
             For strings: concatenate with ';'
             Otherwise: fail if the annotations are not equal
         """
+        other_annotations = [other.annotations for other in others]
         merged_annotations = merge_annotations(self.annotations,
-                                               other.annotations)
+                                               *other_annotations)
         self.annotations.update(merged_annotations)
 
-    def merge(self, other):
+    def merge(self, *others):
         """
         Merge the contents of another object into this one.
 
         See :meth:`merge_annotations` for details of the merge operation.
         """
-        self.merge_annotations(other)
+        self.merge_annotations(*others)
 
     def set_parent(self, obj):
         """
         Set the appropriate "parent" attribute of this object
         according to the type of "obj"
         """
         if obj.__class__.__name__ not in self._single_parent_objects:
```

### Comparing `neo-0.8.0/neo/core/basesignal.py` & `neo-0.9.0/neo/core/basesignal.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 This module implements :class:`BaseSignal`, an array of signals.
 This is a parent class from which all signal objects inherit:
     :class:`AnalogSignal` and :class:`IrregularlySampledSignal`
 
 :class:`BaseSignal` inherits from :class:`quantities.Quantity`, which
 inherits from :class:`numpy.array`.
@@ -11,25 +10,22 @@
 
 In brief:
 * Constructor :meth:`__new__` for :class:`BaseSignal` doesn't exist.
 Only child objects :class:`AnalogSignal` and :class:`IrregularlySampledSignal`
 can be created.
 '''
 
-# needed for Python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import copy
 import logging
 from copy import deepcopy
 
 import numpy as np
 import quantities as pq
 
-from neo.core.baseneo import BaseNeo, MergeError, merge_annotations
+from neo.core.baseneo import MergeError, merge_annotations
 from neo.core.dataobject import DataObject, ArrayDict
 from neo.core.channelindex import ChannelIndex
 
 logger = logging.getLogger("Neo")
 
 
 class BaseSignal(DataObject):
@@ -62,15 +58,15 @@
         User-specified values are only relevant for construction from
         constructor, and these are set in __new__ in the child object.
         Then they are just copied over here. Default values for the
         specific attributes for subclasses (:class:`AnalogSignal`
         and :class:`IrregularlySampledSignal`) are set in
         :meth:`_array_finalize_spec`
         '''
-        super(BaseSignal, self).__array_finalize__(obj)
+        super().__array_finalize__(obj)
         self._array_finalize_spec(obj)
 
         # The additional arguments
         self.annotations = getattr(obj, 'annotations', {})
         # Add empty array annotations, because they cannot always be copied,
         # but do not overwrite existing ones from slicing etc.
         # This ensures the attribute exists
@@ -101,15 +97,15 @@
             # This test always returns True, i.e. rescaling is always executed if one of the units
             # is a pq.CompoundUnit. This is fine because rescaling is correct anyway.
             if pq.quantity.validate_dimensionality(units) != signal.dimensionality:
                 signal = signal.rescale(units)
         return signal
 
     def rescale(self, units):
-        obj = super(BaseSignal, self).rescale(units)
+        obj = super().rescale(units)
         obj.channel_index = self.channel_index
         return obj
 
     def __getslice__(self, i, j):
         '''
         Get a slice from :attr:`i` to :attr:`j`.attr[0]
 
@@ -125,30 +121,34 @@
 
     def _apply_operator(self, other, op, *args):
         '''
         Handle copying metadata to the new signal
         after a mathematical operation.
         '''
         self._check_consistency(other)
-        f = getattr(super(BaseSignal, self), op)
+        f = getattr(super(), op)
         new_signal = f(other, *args)
         new_signal._copy_data_complement(self)
         # _copy_data_complement can't always copy array annotations,
         # so this needs to be done locally
         new_signal.array_annotations = copy.deepcopy(self.array_annotations)
         return new_signal
 
     def _get_required_attributes(self, signal, units):
         '''
         Return a list of the required attributes for a signal as a dictionary
         '''
         required_attributes = {}
         for attr in self._necessary_attrs:
-            if 'signal' == attr[0]:
-                required_attributes[str(attr[0])] = signal
+            if attr[0] == "signal":
+                required_attributes["signal"] = signal
+            elif attr[0] == "image_data":
+                required_attributes["image_data"] = signal
+            elif attr[0] == "t_start":
+                required_attributes["t_start"] = getattr(self, "t_start", 0.0 * pq.ms)
             else:
                 required_attributes[str(attr[0])] = getattr(self, attr[0], None)
         required_attributes['units'] = units
         return required_attributes
 
     def duplicate_with_new_data(self, signal, units=None):
         '''
@@ -176,15 +176,17 @@
         Copy the metadata from another signal.
         Required and recommended attributes of the signal are used.
         Note: Array annotations can not be copied here because length of data can change
         '''
         all_attr = {self._recommended_attrs, self._necessary_attrs}
         for sub_at in all_attr:
             for attr in sub_at:
-                if attr[0] != 'signal':
+                if attr[0] == "t_start":
+                    setattr(self, attr[0], deepcopy(getattr(other, attr[0], 0.0 * pq.ms)))
+                elif attr[0] != 'signal':
                     setattr(self, attr[0], deepcopy(getattr(other, attr[0], None)))
         setattr(self, 'annotations', deepcopy(getattr(other, 'annotations', None)))
 
         # Note: Array annotations cannot be copied because length of data can be changed  # here
         #  which would cause inconsistencies
 
     def __rsub__(self, other, *args):
@@ -276,15 +278,56 @@
 
         if hasattr(self, "lazy_shape"):
             signal.lazy_shape = merged_lazy_shape
 
         # merge channel_index (move to ChannelIndex.merge()?)
         if self.channel_index and other.channel_index:
             signal.channel_index = ChannelIndex(index=np.arange(signal.shape[1]),
-                channel_ids=np.hstack(
-                    [self.channel_index.channel_ids, other.channel_index.channel_ids]),
-                channel_names=np.hstack(
-                    [self.channel_index.channel_names, other.channel_index.channel_names]))
+                                                channel_ids=np.hstack(
+                                                    [self.channel_index.channel_ids,
+                                                     other.channel_index.channel_ids]),
+                                                channel_names=np.hstack(
+                                                    [self.channel_index.channel_names,
+                                                     other.channel_index.channel_names]))
         else:
             signal.channel_index = ChannelIndex(index=np.arange(signal.shape[1]))
 
         return signal
+
+    def time_slice(self, t_start, t_stop):
+        '''
+        Creates a new AnalogSignal corresponding to the time slice of the
+        original Signal between times t_start, t_stop.
+        '''
+        NotImplementedError('Needs to be implemented for subclasses.')
+
+    def concatenate(self, *signals):
+        '''
+        Concatenate multiple signals across time.
+
+        The signal objects are concatenated vertically
+        (row-wise, :func:`np.vstack`). Concatenation can be
+        used to combine signals across segments.
+        Note: Only (array) annotations common to
+        both signals are attached to the concatenated signal.
+
+        If the attributes of the signals are not
+        compatible, an Exception is raised.
+
+        Parameters
+        ----------
+        signals : multiple neo.BaseSignal objects
+            The objects that is concatenated with this one.
+
+        Returns
+        -------
+        signal : neo.BaseSignal
+            Signal containing all non-overlapping samples of
+            the source signals.
+
+        Raises
+        ------
+        MergeError
+            If `other` object has incompatible attributes.
+        '''
+
+        NotImplementedError('Patching need to be implemented in sublcasses')
```

### Comparing `neo-0.8.0/neo/core/block.py` & `neo-0.9.0/neo/core/block.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,85 +1,80 @@
-# -*- coding: utf-8 -*-
 '''
 This module defines :class:`Block`, the main container gathering all the data,
 whether discrete or continous, for a given recording session. base class
 used by all :module:`neo.core` classes.
 
 :class:`Block` derives from :class:`Container`,
 from :module:`neo.core.container`.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 from datetime import datetime
 
 from neo.core.container import Container, unique_objs
 
 
 class Block(Container):
     '''
     Main container gathering all the data, whether discrete or continous, for a
     given recording session.
 
     A block is not necessarily temporally homogeneous, in contrast to :class:`Segment`.
 
     *Usage*::
 
-        >>> from neo.core import (Block, Segment, ChannelIndex,
-        ...                       AnalogSignal)
+        >>> from neo.core import Block, Segment, Group, AnalogSignal
         >>> from quantities import nA, kHz
         >>> import numpy as np
         >>>
-        >>> # create a Block with 3 Segment and 2 ChannelIndex objects
+        >>> # create a Block with 3 Segment and 2 Group objects
         ,,, blk = Block()
         >>> for ind in range(3):
         ...     seg = Segment(name='segment %d' % ind, index=ind)
         ...     blk.segments.append(seg)
         ...
         >>> for ind in range(2):
-        ...     chx = ChannelIndex(name='Array probe %d' % ind,
-        ...                        index=np.arange(64))
-        ...     blk.channel_indexes.append(chx)
+        ...     group = Group(name='Array probe %d' % ind)
+        ...     blk.groups.append(group)
         ...
         >>> # Populate the Block with AnalogSignal objects
         ... for seg in blk.segments:
-        ...     for chx in blk.channel_indexes:
+        ...     for group in blk.groups:
         ...         a = AnalogSignal(np.random.randn(10000, 64)*nA,
         ...                          sampling_rate=10*kHz)
-        ...         chx.analogsignals.append(a)
+        ...         group.analogsignals.append(a)
         ...         seg.analogsignals.append(a)
 
     *Required attributes/properties*:
         None
 
     *Recommended attributes/properties*:
         :name: (str) A label for the dataset.
         :description: (str) Text description.
         :file_origin: (str) Filesystem path or URL of the original data file.
         :file_datetime: (datetime) The creation date and time of the original
             data file.
         :rec_datetime: (datetime) The date and time of the original recording.
 
     *Properties available on this object*:
-        :list_units: descends through hierarchy and returns a list of
+        :list_units: (deprecated) descends through hierarchy and returns a list of
             :class:`Unit` objects existing in the block. This shortcut exists
             because a common analysis case is analyzing all neurons that
             you recorded in a session.
 
     Note: Any other additional arguments are assumed to be user-specific
     metadata and stored in :attr:`annotations`.
 
     *Container of*:
         :class:`Segment`
-        :class:`ChannelIndex`
+        :class:`Group`
+        :class:`ChannelIndex` (deprecated)
 
     '''
 
-    _container_child_objects = ('Segment', 'ChannelIndex')
+    _container_child_objects = ('Segment', 'ChannelIndex', 'Group')
     _child_properties = ('Unit',)
     _recommended_attrs = ((('file_datetime', datetime),
                            ('rec_datetime', datetime),
                            ('index', int)) +
                           Container._recommended_attrs)
     _repr_pretty_attrs_keys_ = (Container._repr_pretty_attrs_keys_ +
                                 ('file_origin', 'file_datetime',
@@ -88,15 +83,15 @@
 
     def __init__(self, name=None, description=None, file_origin=None,
                  file_datetime=None, rec_datetime=None, index=None,
                  **annotations):
         '''
         Initalize a new :class:`Block` instance.
         '''
-        super(Block, self).__init__(name=name, description=description,
+        super().__init__(name=name, description=description,
                                     file_origin=file_origin, **annotations)
 
         self.file_datetime = file_datetime
         self.rec_datetime = rec_datetime
         self.index = index
         self.regionsofinterest = []   # temporary workaround.
         # the goal is to store all sub-classes of RegionOfInterest in a single list
@@ -108,28 +103,28 @@
         All data child objects stored in the current object,
         obtained recursively.
         '''
         # subclassing this to remove duplicate objects such as SpikeTrain
         # objects in both Segment and Unit
         # Only Block can have duplicate items right now, so implement
         # this here for performance reasons.
-        return tuple(unique_objs(super(Block, self).data_children_recur))
+        return tuple(unique_objs(super().data_children_recur))
 
     def list_children_by_class(self, cls):
         '''
         List all children of a particular class recursively.
 
         You can either provide a class object, a class name,
         or the name of the container storing the class.
         '''
         # subclassing this to remove duplicate objects such as SpikeTrain
         # objects in both Segment and Unit
         # Only Block can have duplicate items right now, so implement
         # this here for performance reasons.
-        return unique_objs(super(Block, self).list_children_by_class(cls))
+        return unique_objs(super().list_children_by_class(cls))
 
     @property
     def list_units(self):
         '''
         Return a list of all :class:`Unit` objects in the :class:`Block`.
         '''
         return self.list_children_by_class('unit')
```

### Comparing `neo-0.8.0/neo/core/channelindex.py` & `neo-0.9.0/neo/core/channelindex.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-# -*- coding: utf-8 -*-
 '''
 This module defines :class:`ChannelIndex`, a container for multiple
 data channels.
 
 :class:`ChannelIndex` derives from :class:`Container`,
 from :module:`neo.core.container`.
 '''
 
-# needed for Python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import numpy as np
 import quantities as pq
 
 from neo.core.container import Container
 
 
 class ChannelIndex(Container):
     '''
     A container for indexing/grouping data channels.
 
+    Use of :class:`ChannelIndex` is deprecated. Its various uses can be replaced
+    by the :class:`Group` and :class:`ChannelView` classes, or by use of
+    array annotations.
+
     This container has several purposes:
 
       * Grouping all :class:`AnalogSignal`\\s and
         :class:`IrregularlySampledSignal`\\s inside a :class:`Block` across
         :class:`Segment`\\s;
       * Indexing a subset of the channels within an :class:`AnalogSignal` and
         :class:`IrregularlySampledSignal`\\s;
@@ -152,36 +152,36 @@
 
     '''
 
     _container_child_objects = ('Unit',)
     _data_child_objects = ('AnalogSignal', 'IrregularlySampledSignal')
     _single_parent_objects = ('Block',)
     _necessary_attrs = (('index', np.ndarray, 1, np.dtype('i')),)
-    _recommended_attrs = ((('channel_names', np.ndarray, 1, np.dtype('S')),
+    _recommended_attrs = ((('channel_names', np.ndarray, 1, np.dtype('U')),
                            ('channel_ids', np.ndarray, 1, np.dtype('i')),
                            ('coordinates', pq.Quantity, 2)) +
                           Container._recommended_attrs)
 
     def __init__(self, index, channel_names=None, channel_ids=None,
                  name=None, description=None, file_origin=None,
                  coordinates=None, **annotations):
         '''
         Initialize a new :class:`ChannelIndex` instance.
         '''
         # Inherited initialization
         # Sets universally recommended attributes, and places all others
         # in annotations
-        super(ChannelIndex, self).__init__(name=name,
-                                           description=description,
-                                           file_origin=file_origin,
-                                           **annotations)
+        super().__init__(name=name,
+                         description=description,
+                         file_origin=file_origin,
+                         **annotations)
 
         # Defaults
         if channel_names is None:
-            channel_names = np.array([], dtype='S')
+            channel_names = np.array([], dtype='U')
         if channel_ids is None:
             channel_ids = np.array([], dtype='i')
 
         # Store recommended attributes
         self.channel_names = np.array(channel_names)
         self.channel_ids = np.array(channel_ids)
         self.index = np.array(index)
```

### Comparing `neo-0.8.0/neo/core/container.py` & `neo-0.9.0/neo/core/container.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,22 +1,14 @@
-# -*- coding: utf-8 -*-
 """
 This module implements generic container base class that all neo container
 object inherit from.  It provides shared methods for all container types.
 
 :class:`Container` is derived from :class:`BaseNeo`
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-try:
-    basestring
-except NameError:
-    basestring = str
-
 from copy import deepcopy
 from neo.core.baseneo import BaseNeo, _reference_name, _container_name
 
 
 def unique_objs(objs):
     """
     Return a list of objects in the list objs where all objects are unique
@@ -228,16 +220,16 @@
     _repr_pretty_containers = ()
 
     def __init__(self, name=None, description=None, file_origin=None,
                  **annotations):
         """
         Initalize a new :class:`Container` instance.
         """
-        super(Container, self).__init__(name=name, description=description,
-                                        file_origin=file_origin, **annotations)
+        super().__init__(name=name, description=description,
+                         file_origin=file_origin, **annotations)
 
         # initialize containers
         for container in self._child_containers:
             setattr(self, container, [])
 
     @property
     def _single_child_objects(self):
@@ -406,15 +398,15 @@
         Examples::
 
             >>> obj.filter(name="Vm")
             >>> obj.filter(objects=neo.SpikeTrain)
             >>> obj.filter(targdict={'myannotation':3})
         """
 
-        if isinstance(targdict, basestring):
+        if isinstance(targdict, str):
             raise TypeError("filtering is based on key-value pairs."
                             " Only a single string was provided.")
 
         # if objects are specified, get the classes
         if objects:
             data = True
             container = True
@@ -600,15 +592,15 @@
                 else:
                     lookup[obj.name] = obj
                     ids.append(id(obj))
                     getattr(self, container).append(obj)
                 obj.set_parent(self)
 
         # use the BaseNeo merge as well
-        super(Container, self).merge(other)
+        super().merge(other)
 
     def _repr_pretty_(self, pp, cycle):
         """
         Handle pretty-printing.
         """
         pp.text(self.__class__.__name__)
         pp.text(" with ")
```

### Comparing `neo-0.8.0/neo/core/dataobject.py` & `neo-0.9.0/neo/core/dataobject.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 This module defines :class:`DataObject`, the abstract base class
 used by all :module:`neo.core` classes that can contain data (i.e. are not container classes).
 It contains basic functionality that is shared among all those data objects.
 
 """
 from copy import deepcopy
@@ -291,15 +290,15 @@
     # Needed to implement this so array annotations are copied as well, ONLY WHEN copying 1:1
     def copy(self, **kwargs):
         '''
         Returns a shallow copy of the object
         :return: Copy of self
         '''
 
-        obj = super(DataObject, self).copy(**kwargs)
+        obj = super().copy(**kwargs)
         obj.array_annotations = self.array_annotations
         return obj
 
     def as_array(self, units=None):
         """
         Return the object's data as a plain NumPy array.
 
@@ -328,20 +327,14 @@
             length = self.shape[-1]
         # Note: This is because __getitem__[int] returns a scalar Epoch/Event/SpikeTrain
         # To be removed if __getitem__[int] is changed
         except IndexError:
             length = 1
         return length
 
-    def duplicate_with_new_array(self, signal, units=None):
-        warnings.warn("Use of the `duplicate_with_new_array function is deprecated. "
-                      "Please use `duplicate_with_new_data` instead.",
-                      DeprecationWarning)
-        return self.duplicate_with_new_data(signal, units=units)
-
     def __deepcopy__(self, memo):
         """
             Create a deep copy of the data object.
             All attributes and annotations are also deep copied.
             References to parent objects are not kept, they are set to None.
 
 
@@ -381,32 +374,32 @@
        When setting `obj.array_annotations[key]=value`, checks for consistency
        should not be bypassed.
        This class overrides __setitem__ from dict to perform these checks every time.
        The method used for these checks is given as an argument for __init__.
     """
 
     def __init__(self, length, check_function=_normalize_array_annotations, *args, **kwargs):
-        super(ArrayDict, self).__init__(*args, **kwargs)
+        super().__init__(*args, **kwargs)
         self.check_function = check_function
         self.length = length
 
     def __setitem__(self, key, value):
         # Directly call the defined function
         # Need to wrap key and value in a dict in order to make sure
         # that nested dicts are detected
         value = self.check_function({key: value}, self.length)[key]
-        super(ArrayDict, self).__setitem__(key, value)
+        super().__setitem__(key, value)
 
     # Updating the dict also needs to perform checks, so rerouting this to __setitem__
     def update(self, *args, **kwargs):
         if args:
             if len(args) > 1:
                 raise TypeError("update expected at most 1 arguments, "
                                 "got %d" % len(args))
             other = dict(args[0])
             for key in other:
                 self[key] = other[key]
         for key in kwargs:
             self[key] = kwargs[key]
 
     def __reduce__(self):
-        return super(ArrayDict, self).__reduce__()
+        return super().__reduce__()
```

### Comparing `neo-0.8.0/neo/core/epoch.py` & `neo-0.9.0/neo/core/epoch.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,29 +1,22 @@
-# -*- coding: utf-8 -*-
 '''
 This module defines :class:`Epoch`, an array of epochs.
 
 :class:`Epoch` derives from :class:`BaseNeo`, from
 :module:`neo.core.baseneo`.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
-import sys
 from copy import deepcopy, copy
 
 import numpy as np
 import quantities as pq
 
 from neo.core.baseneo import BaseNeo, merge_annotations
 from neo.core.dataobject import DataObject, ArrayDict
 
-PY_VER = sys.version_info[0]
-
 
 def _new_epoch(cls, times=None, durations=None, labels=None, units=None, name=None,
                description=None, file_origin=None, array_annotations=None, annotations=None,
                segment=None):
     '''
     A function to map epoch.__new__ to function that
     does not do the unit checking. This is needed for pickle to work.
@@ -43,31 +36,31 @@
 
         >>> from neo.core import Epoch
         >>> from quantities import s, ms
         >>> import numpy as np
         >>>
         >>> epc = Epoch(times=np.arange(0, 30, 10)*s,
         ...             durations=[10, 5, 7]*ms,
-        ...             labels=np.array(['btn0', 'btn1', 'btn2'], dtype='S'))
+        ...             labels=np.array(['btn0', 'btn1', 'btn2'], dtype='U'))
         >>>
         >>> epc.times
         array([  0.,  10.,  20.]) * s
         >>> epc.durations
         array([ 10.,   5.,   7.]) * ms
         >>> epc.labels
         array(['btn0', 'btn1', 'btn2'],
-              dtype='|S4')
+              dtype='<U4')
 
     *Required attributes/properties*:
         :times: (quantity array 1D, numpy array 1D or list) The start times
            of each time period.
         :durations: (quantity array 1D, numpy array 1D, list, or quantity scalar)
            The length(s) of each time period.
            If a scalar, the same value is used for all time periods.
-        :labels: (numpy.array 1D dtype='S' or list) Names or labels for the time periods.
+        :labels: (numpy.array 1D dtype='U' or list) Names or labels for the time periods.
 
     *Recommended attributes/properties*:
         :name: (str) A label for the dataset,
         :description: (str) Text description,
         :file_origin: (str) Filesystem path or URL of the original data file.
 
     *Optional attributes/properties*:
@@ -79,33 +72,35 @@
 
     '''
 
     _single_parent_objects = ('Segment',)
     _single_parent_attrs = ('segment',)
     _quantity_attr = 'times'
     _necessary_attrs = (('times', pq.Quantity, 1), ('durations', pq.Quantity, 1),
-                        ('labels', np.ndarray, 1, np.dtype('S')))
+                        ('labels', np.ndarray, 1, np.dtype('U')))
 
     def __new__(cls, times=None, durations=None, labels=None, units=None, name=None,
                 description=None, file_origin=None, array_annotations=None, **annotations):
         if times is None:
             times = np.array([]) * pq.s
         elif isinstance(times, (list, tuple)):
             times = np.array(times)
+        if len(times.shape) > 1:
+            raise ValueError("Times array has more than 1 dimension")
         if isinstance(durations, (list, tuple)):
             durations = np.array(durations)
         if durations is None:
             durations = np.array([]) * pq.s
         elif durations.size != times.size:
             if durations.size == 1:
                 durations = durations * np.ones_like(times.magnitude)
             else:
                 raise ValueError("Durations array has different length to times")
         if labels is None:
-            labels = np.array([], dtype='S')
+            labels = np.array([], dtype='U')
         else:
             labels = np.array(labels)
             if labels.size != times.size and labels.size:
                 raise ValueError("Labels array has different length to times")
         if units is None:
             # No keyword units, so get from `times`
             try:
@@ -147,15 +142,15 @@
         works
         '''
         return _new_epoch, (self.__class__, self.times, self.durations, self.labels, self.units,
                             self.name, self.file_origin, self.description, self.array_annotations,
                             self.annotations, self.segment)
 
     def __array_finalize__(self, obj):
-        super(Epoch, self).__array_finalize__(obj)
+        super().__array_finalize__(obj)
         self._durations = getattr(obj, 'durations', None)
         self._labels = getattr(obj, 'labels', None)
         self.annotations = getattr(obj, 'annotations', None)
         self.name = getattr(obj, 'name', None)
         self.file_origin = getattr(obj, 'file_origin', None)
         self.description = getattr(obj, 'description', None)
         self.segment = getattr(obj, 'segment', None)
@@ -165,43 +160,50 @@
         if not hasattr(self, 'array_annotations'):
             self.array_annotations = ArrayDict(self._get_arr_ann_length())
 
     def __repr__(self):
         '''
         Returns a string representing the :class:`Epoch`.
         '''
-        # need to convert labels to unicode for python 3 or repr is messed up
-        if PY_VER == 3:
-            labels = self.labels.astype('U')
-        else:
-            labels = self.labels
 
-        objs = ['%s@%s for %s' % (label, time, dur) for label, time, dur in
-                zip(labels, self.times, self.durations)]
+        objs = ['%s@%s for %s' % (label, str(time), str(dur)) for label, time, dur in
+                zip(self.labels, self.times, self.durations)]
         return '<Epoch: %s>' % ', '.join(objs)
 
     def _repr_pretty_(self, pp, cycle):
-        super(Epoch, self)._repr_pretty_(pp, cycle)
+        super()._repr_pretty_(pp, cycle)
 
     def rescale(self, units):
         '''
         Return a copy of the :class:`Epoch` converted to the specified
         units
+        :return: Copy of self with specified units
         '''
-
-        obj = super(Epoch, self).rescale(units)
-        obj._durations = obj.durations.rescale(units)
-        obj.segment = self.segment  # not sure we should do this
+        # Use simpler functionality, if nothing will be changed
+        dim = pq.quantity.validate_dimensionality(units)
+        if self.dimensionality == dim:
+            return self.copy()
+
+        # Rescale the object into a new object
+        obj = self.duplicate_with_new_data(
+            times=self.view(pq.Quantity).rescale(dim),
+            durations=self.durations.rescale(dim),
+            labels=self.labels,
+            units=units)
+
+        # Expected behavior is deepcopy, so deepcopying array_annotations
+        obj.array_annotations = deepcopy(self.array_annotations)
+        obj.segment = self.segment
         return obj
 
     def __getitem__(self, i):
         '''
         Get the item or slice :attr:`i`.
         '''
-        obj = super(Epoch, self).__getitem__(i)
+        obj = super().__getitem__(i)
         obj._durations = self.durations[i]
         if self._labels is not None and self._labels.size > 0:
             obj._labels = self.labels[i]
         else:
             obj._labels = self.labels
         try:
             # Array annotations need to be sliced accordingly
```

### Comparing `neo-0.8.0/neo/core/event.py` & `neo-0.9.0/neo/core/event.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,30 +1,23 @@
-# -*- coding: utf-8 -*-
 '''
 This module defines :class:`Event`, an array of events.
 
 :class:`Event` derives from :class:`BaseNeo`, from
 :module:`neo.core.baseneo`.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
-import sys
 from copy import deepcopy, copy
 
 import numpy as np
 import quantities as pq
 
 from neo.core.baseneo import merge_annotations
 from neo.core.dataobject import DataObject, ArrayDict
 from neo.core.epoch import Epoch
 
-PY_VER = sys.version_info[0]
-
 
 def _new_event(cls, times=None, labels=None, units=None, name=None, file_origin=None,
                description=None, array_annotations=None, annotations=None, segment=None):
     '''
     A function to map Event.__new__ to function that
     does not do the unit checking. This is needed for pickle to work.
     '''
@@ -42,25 +35,25 @@
 
         >>> from neo.core import Event
         >>> from quantities import s
         >>> import numpy as np
         >>>
         >>> evt = Event(np.arange(0, 30, 10)*s,
         ...             labels=np.array(['trig0', 'trig1', 'trig2'],
-        ...                             dtype='S'))
+        ...                             dtype='U'))
         >>>
         >>> evt.times
         array([  0.,  10.,  20.]) * s
         >>> evt.labels
         array(['trig0', 'trig1', 'trig2'],
-              dtype='|S5')
+              dtype='<U5')
 
     *Required attributes/properties*:
-        :times: (quantity array 1D, numpy array 1D or list) The times of the events.
-        :labels: (numpy.array 1D dtype='S' or list) Names or labels for the events.
+        :times: (quantity array 1D) The time of the events.
+        :labels: (numpy.array 1D dtype='U' or list) Names or labels for the events.
 
     *Recommended attributes/properties*:
         :name: (str) A label for the dataset.
         :description: (str) Text description.
         :file_origin: (str) Filesystem path or URL of the original data file.
 
     *Optional attributes/properties*:
@@ -71,24 +64,26 @@
     metadata and stored in :attr:`annotations`.
 
     '''
 
     _single_parent_objects = ('Segment',)
     _single_parent_attrs = ('segment',)
     _quantity_attr = 'times'
-    _necessary_attrs = (('times', pq.Quantity, 1), ('labels', np.ndarray, 1, np.dtype('S')))
+    _necessary_attrs = (('times', pq.Quantity, 1), ('labels', np.ndarray, 1, np.dtype('U')))
 
     def __new__(cls, times=None, labels=None, units=None, name=None, description=None,
                 file_origin=None, array_annotations=None, **annotations):
         if times is None:
             times = np.array([]) * pq.s
         elif isinstance(times, (list, tuple)):
             times = np.array(times)
+        if len(times.shape) > 1:
+            raise ValueError("Times array has more than 1 dimension")
         if labels is None:
-            labels = np.array([], dtype='S')
+            labels = np.array([], dtype='U')
         else:
             labels = np.array(labels)
             if labels.size != times.size and labels.size:
                 raise ValueError("Labels array has different length to times")
         if units is None:
             # No keyword units, so get from `times`
             try:
@@ -127,15 +122,15 @@
         works
         '''
         return _new_event, (self.__class__, np.array(self), self.labels, self.units, self.name,
                             self.file_origin, self.description, self.array_annotations,
                             self.annotations, self.segment)
 
     def __array_finalize__(self, obj):
-        super(Event, self).__array_finalize__(obj)
+        super().__array_finalize__(obj)
         self._labels = getattr(obj, 'labels', None)
         self.annotations = getattr(obj, 'annotations', None)
         self.name = getattr(obj, 'name', None)
         self.file_origin = getattr(obj, 'file_origin', None)
         self.description = getattr(obj, 'description', None)
         self.segment = getattr(obj, 'segment', None)
         # Add empty array annotations, because they cannot always be copied,
@@ -144,31 +139,40 @@
         if not hasattr(self, 'array_annotations'):
             self.array_annotations = ArrayDict(self._get_arr_ann_length())
 
     def __repr__(self):
         '''
         Returns a string representing the :class:`Event`.
         '''
-        # need to convert labels to unicode for python 3 or repr is messed up
-        if PY_VER == 3:
-            labels = self.labels.astype('U')
-        else:
-            labels = self.labels
-        objs = ['%s@%s' % (label, time) for label, time in zip(labels, self.times)]
+
+        objs = ['%s@%s' % (label, str(time)) for label, time in zip(self.labels, self.times)]
         return '<Event: %s>' % ', '.join(objs)
 
     def _repr_pretty_(self, pp, cycle):
-        super(Event, self)._repr_pretty_(pp, cycle)
+        super()._repr_pretty_(pp, cycle)
 
     def rescale(self, units):
         '''
         Return a copy of the :class:`Event` converted to the specified
         units
+        :return: Copy of self with specified units
         '''
-        obj = super(Event, self).rescale(units)
+        # Use simpler functionality, if nothing will be changed
+        dim = pq.quantity.validate_dimensionality(units)
+        if self.dimensionality == dim:
+            return self.copy()
+
+        # Rescale the object into a new object
+        obj = self.duplicate_with_new_data(
+            times=self.view(pq.Quantity).rescale(dim),
+            labels=self.labels,
+            units=units)
+
+        # Expected behavior is deepcopy, so deepcopying array_annotations
+        obj.array_annotations = deepcopy(self.array_annotations)
         obj.segment = self.segment
         return obj
 
     @property
     def times(self):
         return pq.Quantity(self)
 
@@ -214,15 +218,15 @@
         # because they are linked to their respective timestamps and length of data can be changed
         # here which would cause inconsistencies
         for attr in ("name", "file_origin", "description",
                      "annotations"):
             setattr(self, attr, deepcopy(getattr(other, attr, None)))
 
     def __getitem__(self, i):
-        obj = super(Event, self).__getitem__(i)
+        obj = super().__getitem__(i)
         if self._labels is not None and self._labels.size > 0:
             obj.labels = self._labels[i]
         else:
             obj.labels = self._labels
         try:
             obj.array_annotate(**deepcopy(self.array_annotations_at_index(i)))
             obj._copy_data_complement(self)
```

### Comparing `neo-0.8.0/neo/core/imagesequence.py` & `neo-0.9.0/neo/core/imagesequence.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 This module implements :class:`ImageSequence`, a 3D array.
 
 :class:`ImageSequence` inherits from :class:`basesignal.BaseSignal` which
 derives from :class:`BaseNeo`, and from :class:`quantites.Quantity`which
 in turn inherits from :class:`numpy.array`.
 
@@ -38,32 +37,34 @@
 
         >>> from neo.core import ImageSequence
         >>> import quantities as pq
         >>>
         >>> img_sequence_array = [[[column for column in range(20)]for row in range(20)]
         ...                         for frame in range(10)]
         >>> image_sequence = ImageSequence(img_sequence_array, units='V',
-        ...                                sampling_rate=1*pq.Hz, spatial_scale=1*pq.micrometer)
+        ...                                sampling_rate=1 * pq.Hz,
+        ...                                spatial_scale=1 * pq.micrometer)
         >>> image_sequence
-        ImageSequence 10 frame with 20 px of height and 20  px of width; units V; datatype int64
+        ImageSequence 10 frames with width 20 px and height 20 px; units V; datatype int64
         sampling rate: 1.0
         spatial_scale: 1.0
         >>> image_sequence.spatial_scale
         array(1.) * um
 
     *Required attributes/properties*:
         :image_data: (3D NumPy array, or a list of 2D arrays)
             The data itself
         :units: (quantity units)
-        :sampling_rate: *or* **sampling_period** (quantity scalar) Number of
+        :sampling_rate: *or* **frame_duration** (quantity scalar) Number of
                                                 samples per unit time or
-                                                interval beween to samples.
+                                                duration of a single image frame.
                                                 If both are specified, they are
                                                 checked for consistency.
         :spatial_scale: (quantity scalar) size for a pixel.
+        :t_start: (quantity scalar) Time when sequence begins. Default 0.
 
     *Recommended attributes/properties*:
         :name: (str) A label for the dataset.
         :description: (str) Text description.
         :file_origin: (str) Filesystem path or URL of the original data file.
 
     *Optional attributes/properties*:
@@ -71,126 +72,214 @@
         :copy: (bool) True by default.
 
     Note: Any other additional arguments are assumed to be user-specific
     metadata and stored in :attr:`annotations`.
 
     *Properties available on this object*:
         :sampling_rate: (quantity scalar) Number of samples per unit time.
-            (1/:attr:`sampling_period`)
-        :sampling_period: (quantity scalar) Interval between two samples.
-            (1/:attr:`quantity scalar`)
-        :spatial_scale: size of a pixel
+            (1/:attr:`frame_duration`)
+        :frame_duration: (quantity scalar) Duration of each image frame.
+            (1/:attr:`sampling_rate`)
+        :spatial_scale: Size of a pixel
+        :duration: (Quantity) Sequence duration, read-only.
+            (size * :attr:`frame_duration`)
+        :t_stop: (quantity scalar) Time when sequence ends, read-only.
+            (:attr:`t_start` + :attr:`duration`)
      """
-    _single_parent_objects = ('Segment',)
-    _single_parent_attrs = ('segment',)
-    _quantity_attr = 'image_data'
-    _necessary_attrs = (('image_data', pq.Quantity, 3),
-                        ('sampling_rate', pq.Quantity, 0),
-                        ('spatial_scale', pq.Quantity, 0))
+
+    _single_parent_objects = ("Segment",)
+    _single_parent_attrs = ("segment",)
+    _quantity_attr = "image_data"
+    _necessary_attrs = (
+        ("image_data", pq.Quantity, 3),
+        ("sampling_rate", pq.Quantity, 0),
+        ("spatial_scale", pq.Quantity, 0),
+        ("t_start", pq.Quantity, 0),
+    )
     _recommended_attrs = BaseNeo._recommended_attrs
 
-    def __new__(cls, image_data, units=None, dtype=None, copy=True, spatial_scale=None, sampling_period=None,
+    def __new__(cls, image_data, units=None, dtype=None, copy=True, t_start=0 * pq.s,
+                spatial_scale=None, frame_duration=None,
                 sampling_rate=None, name=None, description=None, file_origin=None,
                 **annotations):
         """
         Constructs new :class:`ImageSequence` from data.
 
         This is called whenever a new class:`ImageSequence` is created from
         the constructor, but not when slicing.
 
         __array_finalize__ is called on the new object.
         """
         if spatial_scale is None:
-            raise ValueError('spatial_scale is required')
+            raise ValueError("spatial_scale is required")
 
         image_data = np.stack(image_data)
         if len(image_data.shape) != 3:
-            raise ValueError('list doesn\'t have the good number of dimension')
+            raise ValueError("list doesn't have the correct number of dimensions")
 
         obj = pq.Quantity(image_data, units=units, dtype=dtype, copy=copy).view(cls)
         obj.segment = None
         # function from analogsignal.py in neo/core directory
-        obj.sampling_rate = _get_sampling_rate(sampling_rate, sampling_period)
+        obj.sampling_rate = _get_sampling_rate(sampling_rate, frame_duration)
         obj.spatial_scale = spatial_scale
+        if t_start is None:
+            raise ValueError("t_start cannot be None")
+        obj._t_start = t_start
 
         return obj
 
-    def __init__(self, image_data, units=None, dtype=None, copy=True, spatial_scale=None, sampling_period=None,
+    def __init__(self, image_data, units=None, dtype=None, copy=True, t_start=0 * pq.s,
+                 spatial_scale=None, frame_duration=None,
                  sampling_rate=None, name=None, description=None, file_origin=None,
                  **annotations):
-        '''
-               Initializes a newly constructed :class:`ImageSequence` instance.
-        '''
-        DataObject.__init__(self, name=name, file_origin=file_origin, description=description,
-                            **annotations)
+        """
+        Initializes a newly constructed :class:`ImageSequence` instance.
+        """
+        DataObject.__init__(
+            self, name=name, file_origin=file_origin, description=description, **annotations
+        )
 
     def __array_finalize__spec(self, obj):
 
-        self.sampling_rate = getattr(obj, 'sampling_rate', None)
-        self.spatial_scale = getattr(obj, 'spatial_scale', None)
-        self.units = getattr(obj, 'units', None)
+        self.sampling_rate = getattr(obj, "sampling_rate", None)
+        self.spatial_scale = getattr(obj, "spatial_scale", None)
+        self.units = getattr(obj, "units", None)
+        self._t_start = getattr(obj, "_t_start", 0 * pq.s)
 
         return obj
 
     def signal_from_region(self, *region):
         """
-            Method that takes 1 or multiple regionofinterest, use the method of each region
-            of interest to get the list of pixel to average.
-            return a list of :class:`AnalogSignal` for each regionofinterest
+        Method that takes 1 or multiple regionofinterest, uses the method of each region
+        of interest to get the list of pixels to average.
+        Return a list of :class:`AnalogSignal` for each regionofinterest
         """
 
         if len(region) == 0:
-            raise ValueError('no region of interest have been given')
+            raise ValueError("no regions of interest have been given")
 
         region_pixel = []
         for i, b in enumerate(region):
             r = region[i].pixels_in_region()
             if not r:
-                raise ValueError('region '+str(i)+'is empty')
+                raise ValueError("region " + str(i) + "is empty")
             else:
                 region_pixel.append(r)
         analogsignal_list = []
         for i in region_pixel:
             data = []
             for frame in range(len(self)):
                 picture_data = []
                 for v in i:
                     picture_data.append(self.view(pq.Quantity)[frame][v[0]][v[1]])
                 average = picture_data[0]
                 for b in range(1, len(picture_data)):
                     average += picture_data[b]
                 data.append((average * 1.0) / len(i))
-            analogsignal_list.append(AnalogSignal(data, units=self.units,
-                                                  sampling_rate=self.sampling_rate))
+            analogsignal_list.append(
+                AnalogSignal(
+                    data, units=self.units, t_start=self.t_start, sampling_rate=self.sampling_rate
+                )
+            )
 
         return analogsignal_list
 
     def _repr_pretty_(self, pp, cycle):
-        '''
-               Handle pretty-printing the :class:`ImageSequence`.
-        '''
-        pp.text("{cls} {frame} frame with {width} px of width and {height} px of height; "
-                "units {units}; datatype {dtype} ".format(cls=self.__class__.__name__,
-                                                          frame=self.shape[0],
-                                                          height=self.shape[1],
-                                                          width=self.shape[2],
-                                                          units=self.units.dimensionality.string,
-                                                          dtype=self.dtype))
+        """
+        Handle pretty-printing the :class:`ImageSequence`.
+        """
+        pp.text(
+            "{cls} {nframe} frames with width {width} px and height {height} px; "
+            "units {units}; datatype {dtype} ".format(
+                cls=self.__class__.__name__,
+                nframe=self.shape[0],
+                height=self.shape[1],
+                width=self.shape[2],
+                units=self.units.dimensionality.string,
+                dtype=self.dtype,
+            )
+        )
 
         def _pp(line):
             pp.breakable()
             with pp.group(indent=1):
                 pp.text(line)
 
-        for line in ["sampling rate: {0}".format(self.sampling_rate),
-                     "spatial_scale: {0}".format(self.spatial_scale)]:
+        for line in [
+            "sampling rate: {!s}".format(self.sampling_rate),
+            "spatial_scale: {!s}".format(self.spatial_scale),
+        ]:
             _pp(line)
 
     def _check_consistency(self, other):
-        '''
+        """
         Check if the attributes of another :class:`ImageSequence`
         are compatible with this one.
-        '''
+        """
         if isinstance(other, ImageSequence):
-            for attr in ("sampling_rate", "spatial_scale"):
+            for attr in ("sampling_rate", "spatial_scale", "t_start"):
                 if getattr(self, attr) != getattr(other, attr):
                     raise ValueError("Inconsistent values of %s" % attr)
+
+    # t_start attribute is handled as a property so type checking can be done
+    @property
+    def t_start(self):
+        """
+        Time when sequence begins.
+        """
+        return self._t_start
+
+    @t_start.setter
+    def t_start(self, start):
+        """
+        Setter for :attr:`t_start`
+        """
+        if start is None:
+            raise ValueError("t_start cannot be None")
+        self._t_start = start
+
+    @property
+    def duration(self):
+        """
+        Sequence duration
+
+        (:attr:`size` * :attr:`frame_duration`)
+        """
+        return self.shape[0] / self.sampling_rate
+
+    @property
+    def t_stop(self):
+        """
+        Time when Sequence ends.
+
+        (:attr:`t_start` + :attr:`duration`)
+        """
+        return self.t_start + self.duration
+
+    @property
+    def times(self):
+        """
+        The time points of each frame in the sequence
+
+        (:attr:`t_start` + arange(:attr:`shape`)/:attr:`sampling_rate`)
+        """
+        return self.t_start + np.arange(self.shape[0]) / self.sampling_rate
+
+    @property
+    def frame_duration(self):
+        """
+        Duration of a single image frame in the sequence.
+
+        (1/:attr:`sampling_rate`)
+        """
+        return 1.0 / self.sampling_rate
+
+    @frame_duration.setter
+    def frame_duration(self, duration):
+        """
+        Setter for :attr:`frame_duration`
+        """
+        if duration is None:
+            raise ValueError("frame_duration cannot be None")
+        elif not hasattr(duration, "units"):
+            raise ValueError("frame_duration must have units")
+        self.sampling_rate = 1.0 / duration
```

### Comparing `neo-0.8.0/neo/core/irregularlysampledsignal.py` & `neo-0.9.0/neo/core/irregularlysampledsignal.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 This module implements :class:`IrregularlySampledSignal`, an array of analog
 signals with samples taken at arbitrary time points.
 
 :class:`IrregularlySampledSignal` inherits from :class:`basesignal.BaseSignal`
 which derives from :class:`BaseNeo`, from :module:`neo.core.baseneo`,
 and from :class:`quantities.Quantity`, which in turn inherits from
@@ -16,23 +15,29 @@
 This is where user-specified attributes are set.
 
 * :meth:`__array_finalize__` is called for all new objects, including those
 created by slicing. This is where attributes are copied over from
 the old object.
 '''
 
-# needed for Python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 from copy import deepcopy, copy
+
+try:
+    import scipy.signal
+except ImportError as err:
+    HAVE_SCIPY = False
+else:
+    HAVE_SCIPY = True
+
 import numpy as np
 import quantities as pq
 
-from neo.core.baseneo import BaseNeo, MergeError, merge_annotations
+from neo.core.baseneo import MergeError, merge_annotations, intersect_annotations
 from neo.core.basesignal import BaseSignal
+from neo.core.analogsignal import AnalogSignal
 from neo.core.channelindex import ChannelIndex
 from neo.core.dataobject import DataObject
 
 
 def _new_IrregularlySampledSignal(cls, times, signal, units=None, time_units=None, dtype=None,
                                   copy=True, name=None, file_origin=None, description=None,
                                   array_annotations=None, annotations=None, segment=None,
@@ -188,40 +193,40 @@
         return obj
 
     def __repr__(self):
         '''
         Returns a string representing the :class:`IrregularlySampledSignal`.
         '''
         return '<{}({} at times {})>'.format(
-            self.__class__.__name__, super(IrregularlySampledSignal, self).__repr__(), self.times)
+            self.__class__.__name__, super().__repr__(), self.times)
 
     def __getitem__(self, i):
         '''
         Get the item or slice :attr:`i`.
         '''
         if isinstance(i, (int, np.integer)):  # a single point in time across all channels
-            obj = super(IrregularlySampledSignal, self).__getitem__(i)
+            obj = super().__getitem__(i)
             obj = pq.Quantity(obj.magnitude, units=obj.units)
         elif isinstance(i, tuple):
-            obj = super(IrregularlySampledSignal, self).__getitem__(i)
+            obj = super().__getitem__(i)
             j, k = i
             if isinstance(j, (int, np.integer)):  # a single point in time across some channels
                 obj = pq.Quantity(obj.magnitude, units=obj.units)
             else:
                 if isinstance(j, slice):
                     obj.times = self.times.__getitem__(j)
                 elif isinstance(j, np.ndarray):
                     raise NotImplementedError("Arrays not yet supported")
                 else:
                     raise TypeError("%s not supported" % type(j))
                 if isinstance(k, (int, np.integer)):
                     obj = obj.reshape(-1, 1)  # add if channel_index
                 obj.array_annotations = deepcopy(self.array_annotations_at_index(k))
         elif isinstance(i, slice):
-            obj = super(IrregularlySampledSignal, self).__getitem__(i)
+            obj = super().__getitem__(i)
             obj.times = self.times.__getitem__(i)
             obj.array_annotations = deepcopy(self.array_annotations)
         elif isinstance(i, np.ndarray):
             # Indexing of an IrregularlySampledSignal is only consistent if the resulting
             # number of samples is the same for each trace. The time axis for these samples is not
             # guaranteed to be continuous, so returning a Quantity instead of an
             # IrregularlySampledSignal here.
@@ -266,15 +271,15 @@
 
     def __eq__(self, other):
         '''
         Equality test (==)
         '''
         if (isinstance(other, IrregularlySampledSignal) and not (self.times == other.times).all()):
             return False
-        return super(IrregularlySampledSignal, self).__eq__(other)
+        return super().__eq__(other)
 
     def _check_consistency(self, other):
         '''
         Check if the attributes of another :class:`IrregularlySampledSignal`
         are compatible with this one.
         '''
         # if not an array, then allow the calculation
@@ -342,29 +347,59 @@
         stepwise at sampling times.
         '''
         if interpolation is None:
             return (self[:-1] * self.sampling_intervals.reshape(-1, 1)).sum() / self.duration
         else:
             raise NotImplementedError
 
-    def resample(self, at=None, interpolation=None):
-        '''
-        Resample the signal, returning either an :class:`AnalogSignal` object
-        or another :class:`IrregularlySampledSignal` object.
+    def resample(self, sample_count, **kwargs):
+        """
+        Resample the data points of the signal.
+        This method interpolates the signal and returns a new signal with a fixed number of
+        samples defined by `sample_count`.
+        This function is a wrapper of scipy.signal.resample and accepts the same set of keyword
+        arguments, except for specifying the axis of resampling which is fixed to the first axis
+        here, and the sample positions. .
 
-        Arguments:
-            :at: either a :class:`Quantity` array containing the times at
-                 which samples should be created (times must be within the
-                 signal duration, there is no extrapolation), a sampling rate
-                 with dimensions (1/Time) or a sampling interval
-                 with dimensions (Time).
-            :interpolation: one of: None, 'linear'
-        '''
-        # further interpolation methods could be added
-        raise NotImplementedError
+        Parameters:
+        -----------
+        sample_count: integer
+            Number of desired samples. The resulting signal starts at the same sample as the
+            original and is sampled regularly.
+
+        Returns:
+        --------
+        resampled_signal: :class:`AnalogSignal`
+            New instance of a :class:`AnalogSignal` object containing the resampled data points.
+            The original :class:`AnalogSignal` is not modified.
+        """
+
+        if not HAVE_SCIPY:
+            raise ImportError('Resampling requires availability of scipy.signal')
+
+        # Resampling is only permitted along the time axis (axis=0)
+        if 'axis' in kwargs:
+            kwargs.pop('axis')
+        if 't' in kwargs:
+            kwargs.pop('t')
+
+        resampled_data, resampled_times = scipy.signal.resample(self.magnitude, sample_count,
+                                                                t=self.times.magnitude,
+                                                                axis=0, **kwargs)
+
+        new_sampling_rate = (sample_count - 1) / self.duration
+        resampled_signal = AnalogSignal(resampled_data, units=self.units, dtype=self.dtype,
+                                        t_start=self.t_start,
+                                        sampling_rate=new_sampling_rate,
+                                        array_annotations=self.array_annotations.copy(),
+                                        **self.annotations.copy())
+
+        # since the number of channels stays the same, we can also copy array annotations here
+        resampled_signal.array_annotations = self.array_annotations.copy()
+        return resampled_signal
 
     def time_slice(self, t_start, t_stop):
         '''
         Creates a new :class:`IrregularlySampledSignal` corresponding to the time slice of
         the original :class:`IrregularlySampledSignal` between times
         `t_start` and `t_stop`. Either parameter can also be None
         to use infinite endpoints for the time interval.
@@ -475,7 +510,98 @@
                                                 channel_names=np.hstack(
                                                     [self.channel_index.channel_names,
                                                      other.channel_index.channel_names]))
         else:
             signal.channel_index = ChannelIndex(index=np.arange(signal.shape[1]))
 
         return signal
+
+    def concatenate(self, other, allow_overlap=False):
+        '''
+        Combine this and another signal along the time axis.
+
+        The signal objects are concatenated vertically
+        (row-wise, :func:`np.vstack`). Patching can be
+        used to combine signals across segments.
+        Note: Only array annotations common to
+        both signals are attached to the concatenated signal.
+
+        If the attributes of the two signal are not
+        compatible, an Exception is raised.
+
+        Required attributes of the signal are used.
+
+        Parameters
+        ----------
+        other : neo.BaseSignal
+            The object that is merged into this one.
+        allow_overlap : bool
+            If false, overlapping samples between the two
+            signals are not permitted and an ValueError is raised.
+            If true, no check for overlapping samples is
+            performed and all samples are combined.
+
+        Returns
+        -------
+        signal : neo.IrregularlySampledSignal
+            Signal containing all non-overlapping samples of
+            both source signals.
+
+        Raises
+        ------
+        MergeError
+            If `other` object has incompatible attributes.
+        '''
+
+        for attr in self._necessary_attrs:
+            if not (attr[0] in ['signal', 'times', 't_start', 't_stop', 'times']):
+                if getattr(self, attr[0], None) != getattr(other, attr[0], None):
+                    raise MergeError(
+                        "Cannot concatenate these two signals as the %s differ." % attr[0])
+
+        if hasattr(self, "lazy_shape"):
+            if hasattr(other, "lazy_shape"):
+                if self.lazy_shape[-1] != other.lazy_shape[-1]:
+                    raise MergeError("Cannot concatenate signals as they contain"
+                                     " different numbers of traces.")
+                merged_lazy_shape = (self.lazy_shape[0] + other.lazy_shape[0], self.lazy_shape[-1])
+            else:
+                raise MergeError("Cannot concatenate a lazy object with a real object.")
+        if other.units != self.units:
+            other = other.rescale(self.units)
+
+        new_times = np.hstack((self.times, other.times))
+        sorting = np.argsort(new_times)
+        new_samples = np.vstack((self.magnitude, other.magnitude))
+
+        kwargs = {}
+        for name in ("name", "description", "file_origin"):
+            attr_self = getattr(self, name)
+            attr_other = getattr(other, name)
+            if attr_self == attr_other:
+                kwargs[name] = attr_self
+            else:
+                kwargs[name] = "merge({}, {})".format(attr_self, attr_other)
+        merged_annotations = merge_annotations(self.annotations, other.annotations)
+        kwargs.update(merged_annotations)
+
+        kwargs['array_annotations'] = intersect_annotations(self.array_annotations,
+                                                            other.array_annotations)
+
+        if not allow_overlap:
+            if max(self.t_start, other.t_start) <= min(self.t_stop, other.t_stop):
+                raise ValueError('Can not combine signals that overlap in time. Allow for '
+                                 'overlapping samples using the "no_overlap" parameter.')
+
+        t_start = min(self.t_start, other.t_start)
+        t_stop = max(self.t_start, other.t_start)
+
+        signal = IrregularlySampledSignal(signal=new_samples[sorting], times=new_times[sorting],
+                                          units=self.units, dtype=self.dtype, copy=False,
+                                          t_start=t_start, t_stop=t_stop, **kwargs)
+        signal.segment = None
+        signal.channel_index = None
+
+        if hasattr(self, "lazy_shape"):
+            signal.lazy_shape = merged_lazy_shape
+
+        return signal
```

### Comparing `neo-0.8.0/neo/core/regionofinterest.py` & `neo-0.9.0/neo/core/regionofinterest.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,11 @@
-# -*- coding: utf-8 -*-
-
 from math import floor, ceil
 
 
-class RegionOfInterest(object):
+class RegionOfInterest:
     """Abstract base class"""
     pass
 
 
 class CircularRegionOfInterest(RegionOfInterest):
     """Representation of a circular ROI
```

### Comparing `neo-0.8.0/neo/core/segment.py` & `neo-0.9.0/neo/core/segment.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,15 @@
-# -*- coding: utf-8 -*-
 '''
 This module defines :class:`Segment`, a container for data sharing a common
 time basis.
 
 :class:`Segment` derives from :class:`Container`,
 from :module:`neo.core.container`.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 from datetime import datetime
 
 import numpy as np
 
 from copy import deepcopy
 
 from neo.core.container import Container
@@ -88,30 +84,35 @@
 
     def __init__(self, name=None, description=None, file_origin=None,
                  file_datetime=None, rec_datetime=None, index=None,
                  **annotations):
         '''
         Initialize a new :class:`Segment` instance.
         '''
-        super(Segment, self).__init__(name=name, description=description,
+        super().__init__(name=name, description=description,
                                       file_origin=file_origin, **annotations)
 
         self.file_datetime = file_datetime
         self.rec_datetime = rec_datetime
         self.index = index
 
     # t_start attribute is handled as a property so type checking can be done
     @property
     def t_start(self):
         '''
         Time when first signal begins.
         '''
         t_starts = [sig.t_start for sig in self.analogsignals +
                     self.spiketrains + self.irregularlysampledsignals]
-        t_starts += [e.times[0] for e in self.epochs + self.events if len(e.times) > 0]
+
+        for e in self.epochs + self.events:
+            if hasattr(e, 't_start'):  # in case of proxy objects
+                t_starts += [e.t_start]
+            elif len(e) > 0:
+                t_starts += [e.times[0]]
 
         # t_start is not defined if no children are present
         if len(t_starts) == 0:
             return None
 
         t_start = min(t_starts)
         return t_start
@@ -120,15 +121,20 @@
     @property
     def t_stop(self):
         '''
         Time when last signal ends.
         '''
         t_stops = [sig.t_stop for sig in self.analogsignals +
                    self.spiketrains + self.irregularlysampledsignals]
-        t_stops += [e.times[-1] for e in self.epochs + self.events if len(e.times) > 0]
+
+        for e in self.epochs + self.events:
+            if hasattr(e, 't_stop'):  # in case of proxy objects
+                t_stops += [e.t_stop]
+            elif len(e) > 0:
+                t_stops += [e.times[-1]]
 
         # t_stop is not defined if no children are present
         if len(t_stops) == 0:
             return None
 
         t_stop = max(t_stops)
         return t_stop
@@ -243,14 +249,16 @@
             >>> seg1 = seg0.construct_subsegment_by_unit(chx.units[:2])
             >>> len(seg0.spiketrains)
             5
             >>> len(seg1.spiketrains)
             2
 
         '''
+        # todo: provide equivalent method using Group/ChannelView
+        #       add deprecation message (use decorator)?
         seg = Segment()
         seg.spiketrains = self.take_spiketrains_by_unit(unit_list)
         seg.analogsignals = \
             self.take_slice_of_analogsignalarray_by_unit(unit_list)
         # TODO copy others attributes
         return seg
 
@@ -285,14 +293,19 @@
 
         for attr in ['file_datetime', 'rec_datetime', 'index',
                      'name', 'description', 'file_origin']:
             setattr(subseg, attr, getattr(self, attr))
 
         subseg.annotations = deepcopy(self.annotations)
 
+        if t_start is None:
+            t_start = self.t_start
+        if t_stop is None:
+            t_stop = self.t_stop
+
         t_shift = - t_start
 
         # cut analogsignals and analogsignalarrays
         for ana_id in range(len(self.analogsignals)):
             if hasattr(self.analogsignals[ana_id], '_rawio'):
                 ana_time_slice = self.analogsignals[ana_id].load(time_slice=(t_start, t_stop))
             else:
```

### Comparing `neo-0.8.0/neo/core/spiketrain.py` & `neo-0.9.0/neo/core/spiketrain.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 This module implements :class:`SpikeTrain`, an array of spike times.
 
 :class:`SpikeTrain` derives from :class:`BaseNeo`, from
 :module:`neo.core.baseneo`, and from :class:`quantites.Quantity`, which
 inherits from :class:`numpy.array`.
 
@@ -14,16 +13,15 @@
 This is where user-specified attributes are set.
 
 * :meth:`__array_finalize__` is called for all new objects, including those
 created by slicing. This is where attributes are copied over from
 the old object.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
+import neo
 import sys
 
 from copy import deepcopy, copy
 import warnings
 
 import numpy as np
 import quantities as pq
@@ -34,18 +32,21 @@
 def check_has_dimensions_time(*values):
     '''
     Verify that all arguments have a dimensionality that is compatible
     with time.
     '''
     errmsgs = []
     for value in values:
-        dim = value.dimensionality
-        if (len(dim) != 1 or list(dim.values())[0] != 1 or not isinstance(list(dim.keys())[0],
-                                                                          pq.UnitTime)):
-            errmsgs.append("value {} has dimensions {}, not [time]".format(value, dim.simplified))
+        dim = value.dimensionality.simplified
+        if (len(dim) != 1 or
+                list(dim.values())[0] != 1 or not
+                isinstance(list(dim.keys())[0], pq.UnitTime)):
+            errmsgs.append(
+                "value {} has dimensions {}, not [time]".format(
+                    value, dim))
     if errmsgs:
         raise ValueError("\n".join(errmsgs))
 
 
 def _check_time_in_range(value, t_start, t_stop, view=False):
     '''
     Verify that all times in :attr:`value` are between :attr:`t_start`
@@ -269,14 +270,18 @@
         if (len(dim) != 1 or list(dim.values())[0] != 1 or not isinstance(list(dim.keys())[0],
                                                                           pq.UnitTime)):
             ValueError("Unit has dimensions %s, not [time]" % dim.simplified)
 
         # Construct Quantity from data
         obj = pq.Quantity(times, units=units, dtype=dtype, copy=copy).view(cls)
 
+        # spiketrain times always need to be 1-dimensional
+        if len(obj.shape) > 1:
+            raise ValueError("Spiketrain times array has more than 1 dimension")
+
         # if the dtype and units match, just copy the values here instead
         # of doing the much more expensive creation of a new Quantity
         # using items() is orders of magnitude faster
         if (hasattr(t_start, 'dtype')
                 and t_start.dtype == obj.dtype
                 and hasattr(t_start, 'dimensionality')
                 and t_start.dimensionality.items() == dim.items()):
@@ -319,22 +324,22 @@
 
         # Calls parent __init__, which grabs universally recommended
         # attributes and sets up self.annotations
         DataObject.__init__(self, name=name, file_origin=file_origin, description=description,
                             array_annotations=array_annotations, **annotations)
 
     def _repr_pretty_(self, pp, cycle):
-        super(SpikeTrain, self)._repr_pretty_(pp, cycle)
+        super()._repr_pretty_(pp, cycle)
 
     def rescale(self, units):
         '''
         Return a copy of the :class:`SpikeTrain` converted to the specified
         units
         '''
-        obj = super(SpikeTrain, self).rescale(units)
+        obj = super().rescale(units)
         obj.t_start = self.t_start.rescale(units)
         obj.t_stop = self.t_stop.rescale(units)
         obj.unit = self.unit
         return obj
 
     def __reduce__(self):
         '''
@@ -360,15 +365,15 @@
         copied over here.
 
         Note that the :attr:`waveforms` attibute is not sliced here. Nor is
         :attr:`t_start` or :attr:`t_stop` modified.
         '''
         # This calls Quantity.__array_finalize__ which deals with
         # dimensionality
-        super(SpikeTrain, self).__array_finalize__(obj)
+        super().__array_finalize__(obj)
 
         # Supposedly, during initialization from constructor, obj is supposed
         # to be None, but this never happens. It must be something to do
         # with inheritance from Quantity.
         if obj is None:
             return
 
@@ -403,15 +408,15 @@
             self.lazy_shape = obj.lazy_shape
 
     def __repr__(self):
         '''
         Returns a string representing the :class:`SpikeTrain`.
         '''
         return '<SpikeTrain(%s, [%s, %s])>' % (
-            super(SpikeTrain, self).__repr__(), self.t_start, self.t_stop)
+            super().__repr__(), self.t_start, self.t_stop)
 
     def sort(self):
         '''
         Sorts the :class:`SpikeTrain` and its :attr:`waveforms`, if any,
         by time.
         '''
         # sort the waveforms by the times
@@ -419,15 +424,15 @@
         if self.waveforms is not None and self.waveforms.any():
             self.waveforms = self.waveforms[sort_indices]
         self.array_annotate(**deepcopy(self.array_annotations_at_index(sort_indices)))
 
         # now sort the times
         # We have sorted twice, but `self = self[sort_indices]` introduces
         # a dependency on the slicing functionality of SpikeTrain.
-        super(SpikeTrain, self).sort()
+        super().sort()
 
     def __getslice__(self, i, j):
         '''
         Get a slice from :attr:`i` to :attr:`j`.
 
         Doesn't get called in Python 3, :meth:`__getitem__` is called instead
         '''
@@ -502,15 +507,15 @@
                               array_annotations=deepcopy(self.array_annotations),
                               **self.annotations)
 
     def __getitem__(self, i):
         '''
         Get the item or slice :attr:`i`.
         '''
-        obj = super(SpikeTrain, self).__getitem__(i)
+        obj = super().__getitem__(i)
         if hasattr(obj, 'waveforms') and obj.waveforms is not None:
             obj.waveforms = obj.waveforms.__getitem__(i)
         try:
             obj.array_annotate(**deepcopy(self.array_annotations_at_index(i)))
         except AttributeError:  # If Quantity was returned, not SpikeTrain
             pass
         return obj
@@ -521,21 +526,21 @@
         '''
         if not hasattr(value, "units"):
             value = pq.Quantity(value,
                                 units=self.units)  # or should we be strict: raise ValueError(
             # "Setting a value  # requires a quantity")?
         # check for values outside t_start, t_stop
         _check_time_in_range(value, self.t_start, self.t_stop)
-        super(SpikeTrain, self).__setitem__(i, value)
+        super().__setitem__(i, value)
 
     def __setslice__(self, i, j, value):
         if not hasattr(value, "units"):
             value = pq.Quantity(value, units=self.units)
         _check_time_in_range(value, self.t_start, self.t_stop)
-        super(SpikeTrain, self).__setslice__(i, j, value)
+        super().__setslice__(i, j, value)
 
     def _copy_data_complement(self, other, deep_copy=False):
         '''
         Copy the metadata from another :class:`SpikeTrain`.
         Note: Array annotations can not be copied here because length of data can change
         '''
         # Note: Array annotations cannot be copied because length of data can be changed
@@ -590,14 +595,21 @@
         '''
         _t_start = t_start
         _t_stop = t_stop
         if t_start is None:
             _t_start = -np.inf
         if t_stop is None:
             _t_stop = np.inf
+
+        if _t_start > self.t_stop or _t_stop < self.t_start:
+            # the alternative to raising an exception would be to return
+            # a zero-duration spike train set at self.t_stop or self.t_start
+            raise ValueError("A time slice completely outside the "
+                             "boundaries of the spike train is not defined.")
+
         indices = (self >= _t_start) & (self <= _t_stop)
 
         # Time slicing should create a deep copy of the object
         new_st = deepcopy(self[indices])
 
         new_st.t_start = max(_t_start, self.t_start)
         new_st.t_stop = min(_t_stop, self.t_stop)
@@ -628,85 +640,127 @@
 
         # Here we can safely copy the array annotations since we know that
         # the length of the SpikeTrain does not change.
         new_st.array_annotate(**self.array_annotations)
 
         return new_st
 
-    def merge(self, other):
+    def merge(self, *others):
         '''
-        Merge another :class:`SpikeTrain` into this one.
+        Merge other :class:`SpikeTrain` objects into this one.
 
         The times of the :class:`SpikeTrain` objects combined in one array
         and sorted.
 
-        If the attributes of the two :class:`SpikeTrain` are not
+        If the attributes of the :class:`SpikeTrain` objects are not
         compatible, an Exception is raised.
         '''
-        if self.sampling_rate != other.sampling_rate:
-            raise MergeError("Cannot merge, different sampling rates")
-        if self.t_start != other.t_start:
-            raise MergeError("Cannot merge, different t_start")
-        if self.t_stop != other.t_stop:
-            raise MemoryError("Cannot merge, different t_stop")
-        if self.left_sweep != other.left_sweep:
-            raise MemoryError("Cannot merge, different left_sweep")
-        if self.segment != other.segment:
-            raise MergeError("Cannot merge these two signals as they belong to"
-                             " different segments.")
-        if hasattr(self, "lazy_shape"):
-            if hasattr(other, "lazy_shape"):
-                merged_lazy_shape = (self.lazy_shape[0] + other.lazy_shape[0])
-            else:
-                raise MergeError("Cannot merge a lazy object with a real"
-                                 " object.")
-        if other.units != self.units:
-            other = other.rescale(self.units)
-        wfs = [self.waveforms is not None, other.waveforms is not None]
+        for other in others:
+            if isinstance(other, neo.io.proxyobjects.SpikeTrainProxy):
+                raise MergeError("Cannot merge, SpikeTrainProxy objects cannot be merged"
+                                 "into regular SpikeTrain objects, please load them first.")
+            elif not isinstance(other, SpikeTrain):
+                raise MergeError("Cannot merge, only SpikeTrain"
+                                 "can be merged into a SpikeTrain.")
+            if self.sampling_rate != other.sampling_rate:
+                raise MergeError("Cannot merge, different sampling rates")
+            if self.t_start != other.t_start:
+                raise MergeError("Cannot merge, different t_start")
+            if self.t_stop != other.t_stop:
+                raise MergeError("Cannot merge, different t_stop")
+            if self.left_sweep != other.left_sweep:
+                raise MergeError("Cannot merge, different left_sweep")
+            if self.segment != other.segment:
+                raise MergeError("Cannot merge these signals as they belong to"
+                                 " different segments.")
+
+        all_spiketrains = [self]
+        all_spiketrains.extend([st.rescale(self.units) for st in others])
+
+        wfs = [st.waveforms is not None for st in all_spiketrains]
         if any(wfs) and not all(wfs):
             raise MergeError("Cannot merge signal with waveform and signal "
                              "without waveform.")
-        stack = np.concatenate((np.asarray(self), np.asarray(other)))
+        stack = np.concatenate([np.asarray(st) for st in all_spiketrains])
         sorting = np.argsort(stack)
         stack = stack[sorting]
+
         kwargs = {}
 
-        kwargs['array_annotations'] = self._merge_array_annotations(other, sorting=sorting)
+        kwargs['array_annotations'] = self._merge_array_annotations(others, sorting=sorting)
 
         for name in ("name", "description", "file_origin"):
-            attr_self = getattr(self, name)
-            attr_other = getattr(other, name)
-            if attr_self == attr_other:
-                kwargs[name] = attr_self
-            else:
-                kwargs[name] = "merge({}, {})".format(attr_self, attr_other)
-        merged_annotations = merge_annotations(self.annotations, other.annotations)
+            attr = getattr(self, name)
+
+            # check if self is already a merged spiketrain
+            # if it is, get rid of the bracket at the end to append more attributes
+            if attr is not None:
+                if attr.startswith('merge(') and attr.endswith(')'):
+                    attr = attr[:-1]
+
+            for other in others:
+                attr_other = getattr(other, name)
+
+                # both attributes are None --> nothing to do
+                if attr is None and attr_other is None:
+                    continue
+
+                # one of the attributes is None --> convert to string in order to merge them
+                elif attr is None or attr_other is None:
+                    attr = str(attr)
+                    attr_other = str(attr_other)
+
+                # check if the other spiketrain is already a merged spiketrain
+                # if it is, append all of its merged attributes that aren't already in attr
+                if attr_other.startswith('merge(') and attr_other.endswith(')'):
+                    for subattr in attr_other[6:-1].split('; '):
+                        if subattr not in attr:
+                            attr += '; ' + subattr
+                            if not attr.startswith('merge('):
+                                attr = 'merge(' + attr
+
+                # if the other attribute is not in the list --> append
+                # if attr doesn't already start with merge add merge( in the beginning
+                elif attr_other not in attr:
+                    attr += '; ' + attr_other
+                    if not attr.startswith('merge('):
+                        attr = 'merge(' + attr
+
+            # close the bracket of merge(...) if necessary
+            if attr is not None:
+                if attr.startswith('merge('):
+                    attr += ')'
+
+            # write attr into kwargs dict
+            kwargs[name] = attr
+
+        merged_annotations = merge_annotations(*(st.annotations for st in
+                                                 all_spiketrains))
         kwargs.update(merged_annotations)
 
         train = SpikeTrain(stack, units=self.units, dtype=self.dtype, copy=False,
                            t_start=self.t_start, t_stop=self.t_stop,
                            sampling_rate=self.sampling_rate, left_sweep=self.left_sweep, **kwargs)
         if all(wfs):
-            wfs_stack = np.vstack((self.waveforms, other.waveforms))
-            wfs_stack = wfs_stack[sorting]
+            wfs_stack = np.vstack([st.waveforms.rescale(self.waveforms.units)
+                                   for st in all_spiketrains])
+            wfs_stack = wfs_stack[sorting] * self.waveforms.units
             train.waveforms = wfs_stack
         train.segment = self.segment
         if train.segment is not None:
             self.segment.spiketrains.append(train)
 
-        if hasattr(self, "lazy_shape"):
-            train.lazy_shape = merged_lazy_shape
         return train
 
-    def _merge_array_annotations(self, other, sorting=None):
+    def _merge_array_annotations(self, others, sorting=None):
         '''
-        Merges array annotations of 2 different objects.
+        Merges array annotations of multiple different objects.
         The merge happens in such a way that the result fits the merged data
-        In general this means concatenating the arrays from the 2 objects.
-        If an annotation is only present in one of the objects, it will be omitted.
+        In general this means concatenating the arrays from the objects.
+        If an annotation is not present in one of the objects, it will be omitted.
         Apart from that the array_annotations need to be sorted according to the sorting of
         the spikes.
         :return Merged array_annotations
         '''
 
         assert sorting is not None, "The order of the merged spikes must be known"
 
@@ -714,34 +768,36 @@
 
         omitted_keys_self = []
 
         keys = self.array_annotations.keys()
         for key in keys:
             try:
                 self_ann = deepcopy(self.array_annotations[key])
-                other_ann = deepcopy(other.array_annotations[key])
+                other_ann = np.concatenate([deepcopy(other.array_annotations[key])
+                                            for other in others])
                 if isinstance(self_ann, pq.Quantity):
                     other_ann.rescale(self_ann.units)
                     arr_ann = np.concatenate([self_ann, other_ann]) * self_ann.units
                 else:
                     arr_ann = np.concatenate([self_ann, other_ann])
                 merged_array_annotations[key] = arr_ann[sorting]
             # Annotation only available in 'self', must be skipped
             # Ignore annotations present only in one of the SpikeTrains
             except KeyError:
                 omitted_keys_self.append(key)
                 continue
 
-        omitted_keys_other = [key for key in other.array_annotations if
-                              key not in self.array_annotations]
+        omitted_keys_other = [key for key in np.unique([key for other in others
+                                                        for key in other.array_annotations])
+                              if key not in self.array_annotations]
 
         if omitted_keys_self or omitted_keys_other:
             warnings.warn("The following array annotations were omitted, because they were only "
                           "present in one of the merged objects: {} from the one that was merged "
-                          "into and {} from the one that was merged into the other"
+                          "into and {} from the ones that were merged into it."
                           "".format(omitted_keys_self, omitted_keys_other), UserWarning)
 
         return merged_array_annotations
 
     @property
     def times(self):
         '''
```

### Comparing `neo-0.8.0/neo/core/unit.py` & `neo-0.9.0/neo/core/unit.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,28 +1,24 @@
-# -*- coding: utf-8 -*-
 '''
 This module defines :class:`Unit`, a container of :class:`SpikeTrain` objects
 from a unit.
 
 :class:`Unit` derives from :class:`Container`,
 from :module:`neo.core.container`.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
-import numpy as np
-
 from neo.core.container import Container
 
 
 class Unit(Container):
     '''
     A container of :class:`SpikeTrain` objects from a unit.
 
+    Use of :class:`Unit` is deprecated. It can be replaced by the :class:`Group`.
+
     A :class:`Unit` regroups all the :class:`SpikeTrain`
     objects that were emitted by a single spike source during a :class:`Block`.
     A spike source is often a single neuron but doesn't have to be.  The spikes
     may come from different :class:`Segment` objects within the :class:`Block`,
     so this object is not contained in the usual :class:`Block`/
     :class:`Segment`/:class:`SpikeTrain` hierarchy.
 
@@ -64,15 +60,15 @@
     _recommended_attrs = Container._recommended_attrs
 
     def __init__(self, name=None, description=None, file_origin=None,
                  **annotations):
         '''
         Initialize a new :clas:`Unit` instance (spike source)
         '''
-        super(Unit, self).__init__(name=name, description=description,
+        super().__init__(name=name, description=description,
                                    file_origin=file_origin, **annotations)
         self.channel_index = None
 
     def get_channel_indexes(self):
         """
         """
         if self.channel_index:
```

### Comparing `neo-0.8.0/neo/io/__init__.py` & `neo-0.9.0/neo/io/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 :mod:`neo.io` provides classes for reading and/or writing
 electrophysiological data files.
 
 Note that if the package dependency is not satisfied for one io, it does not
 raise an error but a warning.
```

### Comparing `neo-0.8.0/neo/io/alphaomegaio.py` & `neo-0.9.0/neo/io/alphaomegaio.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 
 Class for reading data from Alpha Omega .map files.
 
 This class is an experimental reader with important limitations.
 See the source code for details of the limitations.
 The code of this reader is of alpha quality and received very limited testing.
@@ -59,29 +58,19 @@
 #   available when writing this code).
 # - Lack of knowledge of the Alphamap software and the associated data models.
 # - Lack of time (especially as the specifications are incomplete, a lot of
 #   reverse engineering and testing is required, which makes the development of
 #   this IO very painful and long).
 
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 # specific imports
 import datetime
 import os
 import struct
 
-# file no longer exists in Python3
-try:
-    file
-except NameError:
-    import io
-
-    file = io.BufferedReader
 
 # note neo.core need only numpy and quantities
 import numpy as np
 import quantities as pq
 
 from neo.io.baseio import BaseIO
 from neo.core import Block, Segment, AnalogSignal
```

### Comparing `neo-0.8.0/neo/io/asciiimageio.py` & `neo-0.9.0/neo/io/asciiimageio.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-# -*- coding: utf-8 -*-
-
-
 from .baseio import BaseIO
 from neo.core import ImageSequence, Segment, Block
 import numpy as np
 
 
 class AsciiImageIO(BaseIO):
     """
@@ -55,19 +52,14 @@
         self.nb_frame = nb_frame
         self.nb_row = nb_row
         self.nb_column = nb_column
         self.units = units
         self.sampling_rate = sampling_rate
         self.spatial_scale = spatial_scale
 
-    def read(self, lazy=False, **kwargs):
-        if lazy:
-            raise ValueError('This IO module does not support lazy loading')
-        return [self.read_block(lazy=lazy, **kwargs)]
-
     def read_block(self, lazy=False, **kwargs):
 
         file = open(self.filename, 'r')
         data = file.read()
         print("read block")
         liste_value = []
         record = []
```

### Comparing `neo-0.8.0/neo/io/asciisignalio.py` & `neo-0.9.0/neo/io/asciisignalio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading/writing analog signals in a text file.
 Each column represents an AnalogSignal. All AnalogSignals have the same sampling rate.
 Covers many cases when parts of a file can be viewed as a CSV format.
 
 Supported : Read/Write
```

### Comparing `neo-0.8.0/neo/io/asciispiketrainio.py` & `neo-0.9.0/neo/io/asciispiketrainio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 """
 Classe for reading/writing SpikeTrains in a text file.
 It is the simple case where different spiketrains are written line by line.
 
 Supported : Read/Write
 
 Author: sgarcia
```

### Comparing `neo-0.8.0/neo/io/axographio.py` & `neo-0.9.0/neo/io/axographio.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 AxographIO
 ==========
 
 IO class for reading AxoGraph files (.axgd, .axgx)
 """
 
@@ -21,15 +20,15 @@
             Episodic files are normally read as multi-Segment Neo objects. This
             parameter can force AxographIO to put all signals into a single
             Segment. Default: False.
 
     Example:
         >>> import neo
         >>> r = neo.io.AxographIO(filename=filename)
-        >>> blk = r.read_block()
+        >>> blk = r.read_block(signal_group_mode='split-all')
         >>> display(blk)
 
         >>> # get signals
         >>> seg_index = 0  # episode number
         >>> sigs = [sig for sig in blk.segments[seg_index].analogsignals
         ...         if sig.name in channel_names]
         >>> display(sigs)
@@ -45,12 +44,13 @@
         >>> # get notes
         >>> print(blk.annotations['notes'])
     """
 
     name = 'AxographIO'
     description = 'This IO reads .axgd/.axgx files created with AxoGraph'
 
-    _prefered_signal_group_mode = 'split-all'
+    _prefered_signal_group_mode = 'group-by-same-units'
+    _default_group_mode_have_change_in_0_9 = True
 
     def __init__(self, filename='', force_single_segment=False):
         AxographRawIO.__init__(self, filename, force_single_segment)
         BaseFromRaw.__init__(self, filename)
```

### Comparing `neo-0.8.0/neo/io/axonio.py` & `neo-0.9.0/neo/io/axonio.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 from neo.io.basefromrawio import BaseFromRaw
 from neo.rawio.axonrawio import AxonRawIO
 
 from neo.core import Block, Segment, AnalogSignal, Event
 import quantities as pq
 
 
@@ -34,15 +32,16 @@
     for different types of Epochs offered by Clampex/pClamp other than discrete steps (such as ramp, pulse train, etc and
     encoded by `nEpochType` in the EpochInfoPerDAC section). I'm currently parsing a superset of the properties used 
     by read_protocol() in my analysis scripts, but that code still doesn't parse the full information and isn't in a state
     where it could be committed and I can't currently prioritize putting together all the code that would parse the full
     set of data. The `AxonIO._axon_info['EpochInfo']` section doesn't currently exist.
 
     """
-    _prefered_signal_group_mode = 'split-all'
+    _prefered_signal_group_mode = 'group-by-same-units'
+    _default_group_mode_have_change_in_0_9 = True
 
     def __init__(self, filename):
         AxonRawIO.__init__(self, filename=filename)
         BaseFromRaw.__init__(self, filename)
 
     def read_protocol(self):
         """
```

### Comparing `neo-0.8.0/neo/io/basefromrawio.py` & `neo-0.9.0/neo/io/basefromrawio_orig.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 BaseFromRaw
 ======
 
 BaseFromRaw implement a bridge between the new neo.rawio API
 and the neo.io legacy that give neo.core object.
 The neo.rawio API is more restricted and limited and do not cover tricky
@@ -10,21 +9,16 @@
 But if a format is done in neo.rawio the neo.io is done for free
 by inheritance of this class.
 Furthermore, IOs that inherits this BaseFromRaw also have the ability
 of the lazy load with proxy objects.
 
 
 """
-# needed for python 3 compatibility
-from __future__ import print_function, division, absolute_import
-# from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
-
-import warnings
 import collections
-import logging
+import warnings
 import numpy as np
 
 from neo import logging_handler
 from neo.core import (AnalogSignal, Block,
                       Epoch, Event,
                       IrregularlySampledSignal,
                       ChannelIndex,
@@ -69,16 +63,17 @@
 
     name = 'BaseIO'
     description = ''
     extentions = []
 
     mode = 'file'
 
-    _prefered_signal_group_mode = 'split-all'  # 'group-by-same-units'
-    _prefered_units_group_mode = 'split-all'  # 'all-in-one'
+    _prefered_signal_group_mode = 'group-by-same-units'  # 'split-all'
+    _prefered_units_group_mode = 'all-in-one'  # 'split-all'
+    _default_group_mode_have_change_in_0_9 = False
 
     def __init__(self, *args, **kargs):
         BaseIO.__init__(self, *args, **kargs)
         self.parse_header()
 
     def read_block(self, block_index=0, lazy=False, signal_group_mode=None,
                    units_group_mode=None, load_waveforms=False):
@@ -103,17 +98,17 @@
 
         :param load_waveforms: False by default. Control SpikeTrains.waveforms is None or not.
 
         """
 
         if signal_group_mode is None:
             signal_group_mode = self._prefered_signal_group_mode
-            if self._prefered_signal_group_mode == 'split-all':
-                self.logger.warning("the default signal_group_mode will change from "\
-                                "'split-all' to 'group-by-same-units' in next release")
+            if self._default_group_mode_have_change_in_0_9:
+                warnings.warn('default "signal_group_mode" have change in version 0.9:'
+                        'now all channels are group together in AnalogSignal')
 
         if units_group_mode is None:
             units_group_mode = self._prefered_units_group_mode
 
         # annotations
         bl_annotations = dict(self.raw_annotations['blocks'][block_index])
         bl_annotations.pop('segments')
@@ -142,20 +137,21 @@
                         for key in keys:
                             v = self.raw_annotations['signal_channels'][j].get(key, None)
                             chidx_annotations[key].append(v)
                 if 'name' in list(chidx_annotations.keys()):
                     chidx_annotations.pop('name')
                 chidx_annotations = check_annotations(chidx_annotations)
                 # this should be done with array_annotation soon:
-                ch_names = all_channels[ind_abs]['name'].astype('S')
+                ch_names = all_channels[ind_abs]['name'].astype('U')
                 neo_channel_index = ChannelIndex(index=ind_within,
                                                  channel_names=ch_names,
                                                  channel_ids=all_channels[ind_abs]['id'],
                                                  name='Channel group {}'.format(i),
-                                                 **chidx_annotations)
+                                                 )
+                neo_channel_index.annotations.update(chidx_annotations)
 
                 bl.channel_indexes.append(neo_channel_index)
 
         # ChannelIndex and Unit
         # 2 case are possible in neo defifferent IO have choosen one or other:
         #  * All units are grouped in the same ChannelIndex and indexes are all channels:
         #    'all-in-one'
@@ -230,15 +226,19 @@
 
         :param strict_slicing: True by default.
              Control if an error is raised or not when t_start or t_stop
              is outside the real time range of the segment.
         """
 
         if lazy:
-            assert time_slice is None, 'For lazy=true you must specify time_slice when loading'
+            assert time_slice is None,\
+                'For lazy=True you must specify time_slice when LazyObject.load(time_slice=...)'
+
+            assert not load_waveforms,\
+                'For lazy=True you must specify load_waveforms when SpikeTrain.load(load_waveforms=...)'
 
         if signal_group_mode is None:
             signal_group_mode = self._prefered_signal_group_mode
 
         # annotations
         seg_annotations = dict(self.raw_annotations['blocks'][block_index]['segments'][seg_index])
         for k in ('signals', 'units', 'events'):
```

### Comparing `neo-0.8.0/neo/io/baseio.py` & `neo-0.9.0/neo/io/baseio.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 baseio
 ======
 
 Classes
 -------
 
@@ -16,26 +15,26 @@
     from collections.abc import Sequence
 except ImportError:
     from collections import Sequence
 import logging
 
 from neo import logging_handler
 from neo.core import (AnalogSignal, Block,
-                      Epoch, Event,
+                      Epoch, Event, Group,
                       IrregularlySampledSignal,
-                      ChannelIndex,
+                      ChannelIndex, ChannelView,
                       Segment, SpikeTrain, Unit, ImageSequence,
                       RectangularRegionOfInterest, CircularRegionOfInterest,
                       PolygonRegionOfInterest)
 
 read_error = "This type is not supported by this file format for reading"
 write_error = "This type is not supported by this file format for writing"
 
 
-class BaseIO(object):
+class BaseIO:
     """
     Generic class to handle all the file read/write methods for the key objects
     of the core class. This template is file-reading/writing oriented but it
     can also handle data read from/written to a database such as TDT sytem
     tanks or SQLite files.
 
     This is an abstract class that will be subclassed for each format
@@ -109,16 +108,19 @@
         corelogger = logging.getLogger(corename)
         rootlogger = logging.getLogger()
         if not corelogger.handlers and not rootlogger.handlers:
             corelogger.addHandler(logging_handler)
 
     ######## General read/write methods #######################
     def read(self, lazy=False, **kargs):
-        if lazy:
-            assert self.support_lazy, 'This IO do not support lazy loading'
+        """
+        Return all data from the file as a list of Blocks
+        """
+        if lazy and not self.support_lazy:
+            raise ValueError("This IO module does not support lazy loading")
         if Block in self.readable_objects:
             if (hasattr(self, 'read_all_blocks') and
                     callable(getattr(self, 'read_all_blocks'))):
                 return self.read_all_blocks(lazy=lazy, **kargs)
             return [self.read_block(lazy=lazy, **kargs)]
         elif Segment in self.readable_objects:
             bl = Block(name='One segment only')
@@ -176,20 +178,26 @@
 
     def read_irregularlysampledsignal(self, **kargs):
         assert (IrregularlySampledSignal in self.readable_objects), read_error
 
     def read_channelindex(self, **kargs):
         assert (ChannelIndex in self.readable_objects), read_error
 
+    def read_channelview(self, **kargs):
+        assert (ChannelView in self.readable_objects), read_error
+
     def read_event(self, **kargs):
         assert (Event in self.readable_objects), read_error
 
     def read_epoch(self, **kargs):
         assert (Epoch in self.readable_objects), read_error
 
+    def read_group(self, **kargs):
+        assert (Group in self.readable_objects), read_error
+
     ######## All individual write methods #######################
     def write_block(self, bl, **kargs):
         assert (Block in self.writeable_objects), write_error
 
     def write_segment(self, seg, **kargs):
         assert (Segment in self.writeable_objects), write_error
 
@@ -216,12 +224,18 @@
 
     def write_irregularlysampledsignal(self, irsig, **kargs):
         assert (IrregularlySampledSignal in self.writeable_objects), write_error
 
     def write_channelindex(self, chx, **kargs):
         assert (ChannelIndex in self.writeable_objects), write_error
 
+    def write_channelview(self, chv, **kargs):
+        assert (ChannelView in self.writeable_objects), write_error
+
     def write_event(self, ev, **kargs):
         assert (Event in self.writeable_objects), write_error
 
     def write_epoch(self, ep, **kargs):
         assert (Epoch in self.writeable_objects), write_error
+
+    def write_group(self, group, **kargs):
+        assert (Group in self.writeable_objects), write_error
```

### Comparing `neo-0.8.0/neo/io/blackrockio.py` & `neo-0.9.0/neo/io/blackrockio.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 from neo.io.basefromrawio import BaseFromRaw
 from neo.rawio.blackrockrawio import BlackrockRawIO
 
 
 class BlackrockIO(BlackrockRawIO, BaseFromRaw):
     """
     Supplementary class for reading BlackRock data using only a single nsx file.
```

### Comparing `neo-0.8.0/neo/io/blackrockio_v4.py` & `neo-0.9.0/neo/io/blackrockio_v4.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Module for reading data from files in the Blackrock format.
 
 This module is an older implementation  with old neo.io API.
 A new class Blackrock compunded by BlackrockRawIO and BaseFromIO
 superseed this one.
 
@@ -44,23 +43,23 @@
     (file spec 2.1 and 2.2)
   * read sif file information
   * read ccf file information
   * fix reading of periodic sampling events (non-neural event type)
     (file spec 2.1 and 2.2)
 """
 
-from __future__ import division
 import datetime
 import os
 import re
+import warnings
 
 import numpy as np
 import quantities as pq
 
-import neo
+import neo.io.blackrockio
 from neo.io.baseio import BaseIO
 from neo.core import (Block, Segment, SpikeTrain, Unit, Event,
                       ChannelIndex, AnalogSignal)
 
 if __name__ == '__main__':
     pass
 
@@ -140,15 +139,15 @@
     readable_objects = [Block, Segment]
     writeable_objects = []
 
     has_header = False
     is_streameable = False
 
     read_params = {
-        neo.Block: [
+        Block: [
             ('nsx_to_load', {
                 'value': 'none',
                 'label': "List of nsx files (ids, int) to read."}),
             ('n_starts', {
                 'value': None,
                 'label': "List of n_start points (Quantity) to create "
                          "segments from."}),
@@ -166,15 +165,15 @@
             ('load_waveforms', {
                 'value': False,
                 'label': "States if waveforms should be loaded and attached "
                          "to spiketrain"}),
             ('load_events', {
                 'value': False,
                 'label': "States if events should be loaded."})],
-        neo.Segment: [
+        Segment: [
             ('n_start', {
                 'label': "Start time point (Quantity) for segment"}),
             ('n_stop', {
                 'label': "Stop time point (Quantity) for segment"}),
             ('nsx_to_load', {
                 'value': 'none',
                 'label': "List of nsx files (ids, int) to read."}),
@@ -214,14 +213,18 @@
     mode = 'file'
 
     def __init__(self, filename, nsx_override=None, nev_override=None,
                  sif_override=None, ccf_override=None, verbose=False):
         """
         Initialize the BlackrockIO class.
         """
+
+        warnings.warn('{} is deprecated and will be removed in neo version 0.10. Use {} instead.'
+                      ''.format(self.__class__, neo.io.blackrockio.BlackrockIO), FutureWarning)
+
         BaseIO.__init__(self)
 
         # Used to avoid unnecessary repetition of verbose messages
         self.__verbose_messages = []
 
         # remove extension from base _filenames
         for ext in self.extensions:
@@ -1980,15 +1983,15 @@
         flt_type = {0: 'None', 1: 'Butterworth'}
 
         chidx = ChannelIndex(
             np.array([channel_id]),
             file_origin=self.filename)
 
         if index is not None:
-            chidx.index = index
+            chidx.index = np.array(index, np.dtype('i'))
             chidx.name = "ChannelIndex {}".format(chidx.index)
         else:
             chidx.name = "ChannelIndex"
 
         if self._avail_files['nev']:
             channel_labels = self.__nev_params('channel_labels')
             if channel_labels is not None:
```

### Comparing `neo-0.8.0/neo/io/blkio.py` & `neo-0.9.0/neo/io/blkio.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 from .baseio import BaseIO
 from neo.core import ImageSequence, Segment, Block
 import numpy as np
 import struct
 import os
 import math
 import quantities as pq
@@ -59,16 +57,19 @@
     def __init__(self, file_name=None, units=None, sampling_rate=None, spatial_scale=None, **kwargs):
         BaseIO.__init__(self, file_name, **kwargs)
         self.units = units
         self.sampling_rate = sampling_rate
         self.spatial_scale = spatial_scale
 
     def read(self, lazy=False, **kwargs):
+        """
+        Return all data from the file as a list of Blocks
+        """
         if lazy:
-            raise ValueError('This IO module does not support lazy loadign')
+            raise ValueError('This IO module does not support lazy loading')
         return [self.read_block(lazy=lazy, units=self.units, sampling_rate=self.sampling_rate,
                                 spatial_scale=self.spatial_scale, **kwargs)]
 
     def read_block(self, lazy=False, **kargs):
 
         def read(name, type, nb, dictionary, file):
```

### Comparing `neo-0.8.0/neo/io/brainwaredamio.py` & `neo-0.9.0/neo/io/brainwaredamio.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 Class for reading from Brainware DAM files
 
 DAM files are binary files for holding raw data.  They are broken up into
 sequence of Segments, each containing a single raw trace and parameters.
 
 The DAM file does NOT contain a sampling rate, nor can it be reliably
@@ -22,28 +21,25 @@
 development of this code
 
 The code is implemented with the permission of Dr. Jan Schnupp
 
 Author: Todd Jennings
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 # import needed core python modules
 import os
 import os.path
 
 # numpy and quantities are already required by neo
 import numpy as np
 import quantities as pq
 
 # needed core neo modules
 from neo.core import (AnalogSignal, Block,
-                      ChannelIndex, Segment)
+                      Group, Segment)
 
 # need to subclass BaseIO
 from neo.io.baseio import BaseIO
 
 
 class BrainwareDamIO(BaseIO):
     """
@@ -75,15 +71,15 @@
     """
 
     is_readable = True  # This class can only read data
     is_writable = False  # write is not supported
 
     # This class is able to directly or indirectly handle the following objects
     # You can notice that this greatly simplifies the full Neo object hierarchy
-    supported_objects = [Block, ChannelIndex,
+    supported_objects = [Block, Group,
                          Segment, AnalogSignal]
 
     readable_objects = [Block]
     writeable_objects = []
 
     has_header = False
     is_streameable = False
@@ -110,21 +106,14 @@
             filename: the filename
         '''
         BaseIO.__init__(self)
         self._path = filename
         self._filename = os.path.basename(filename)
         self._fsrc = None
 
-    def read(self, lazy=False, **kargs):
-        '''
-        Reads raw data file "fname" generated with BrainWare
-        '''
-        assert not lazy, 'Do not support lazy'
-        return self.read_block(lazy=lazy)
-
     def read_block(self, lazy=False, **kargs):
         '''
         Reads a block from the raw data file "fname" generated
         with BrainWare
         '''
         assert not lazy, 'Do not support lazy'
 
@@ -135,34 +124,31 @@
             raise NotImplementedError('This method does not have any '
                                       'arguments implemented yet')
         self._fsrc = None
 
         block = Block(file_origin=self._filename)
 
         # create the objects to store other objects
-        chx = ChannelIndex(file_origin=self._filename,
-                           channel_ids=np.array([1]),
-                           index=np.array([0]),
-                           channel_names=np.array(['Chan1'], dtype='S'))
-
+        gr = Group(file_origin=self._filename)
+        
         # load objects into their containers
-        block.channel_indexes.append(chx)
+        block.groups.append(gr)
 
         # open the file
         with open(self._path, 'rb') as fobject:
             # while the file is not done keep reading segments
             while True:
                 seg = self._read_segment(fobject)
                 # if there are no more Segments, stop
                 if not seg:
                     break
 
                 # store the segment and signals
-                seg.analogsignals[0].channel_index = chx
                 block.segments.append(seg)
+                gr.analogsignals.append(seg.analogsignals[0])
 
         # remove the file object
         self._fsrc = None
 
         block.create_many_to_one_relationship()
         return block
```

### Comparing `neo-0.8.0/neo/io/brainwaref32io.py` & `neo-0.9.0/neo/io/brainwaref32io.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 Class for reading from Brainware F32 files
 
 F32 files are simplified binary files for holding spike data.  Unlike SRC
 files, F32 files carry little metadata.  This also means, however, that the
 file format does not change, unlike SRC files whose format changes periodically
 (although ideally SRC files are backwards-compatible).
@@ -21,26 +20,23 @@
 development of this code
 
 The code is implemented with the permission of Dr. Jan Schnupp
 
 Author: Todd Jennings
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 # import needed core python modules
 from os import path
 
 # numpy and quantities are already required by neo
 import numpy as np
 import quantities as pq
 
 # needed core neo modules
-from neo.core import Block, ChannelIndex, Segment, SpikeTrain, Unit
+from neo.core import Block, Group, Segment, SpikeTrain, Unit
 
 # need to subclass BaseIO
 from neo.io.baseio import BaseIO
 
 
 class BrainwareF32IO(BaseIO):
     '''
@@ -59,16 +55,15 @@
     Call the close method to close the file and reset this method
     back to the first Block.
 
     The isopen property tells whether the file is currently open and
     reading or closed.
 
     Note 1:
-        There is always only one ChannelIndex.  BrainWare stores the
-        equivalent of ChannelIndexes in separate files.
+        There is always only one Group.
 
     Usage:
         >>> from neo.io.brainwaref32io import BrainwareF32IO
         >>> f32file = BrainwareF32IO(filename='multi_500ms_mulitrep_ch1.f32')
         >>> blk1 = f32file.read()
         >>> blk2 = f32file.read_block()
         >>> print blk1.segments
@@ -80,15 +75,15 @@
     '''
 
     is_readable = True  # This class can only read data
     is_writable = False  # write is not supported
 
     # This class is able to directly or indirectly handle the following objects
     # You can notice that this greatly simplifies the full Neo object hierarchy
-    supported_objects = [Block, ChannelIndex,
+    supported_objects = [Block, Group,
                          Segment, SpikeTrain, Unit]
 
     readable_objects = [Block]
     writeable_objects = []
 
     has_header = False
     is_streameable = False
@@ -117,27 +112,21 @@
         BaseIO.__init__(self)
         self._path = filename
         self._filename = path.basename(filename)
 
         self._fsrc = None
 
         self._blk = None
-        self.__unit = None
+        self.__unit_group = None
 
         self.__t_stop = None
         self.__params = None
         self.__seg = None
         self.__spiketimes = None
 
-    def read(self, lazy=False, **kargs):
-        '''
-        Reads simple spike data file "fname" generated with BrainWare
-        '''
-        return self.read_block(lazy=lazy, )
-
     def read_block(self, lazy=False, **kargs):
         '''
         Reads a block from the simple spike data file "fname" generated
         with BrainWare
         '''
         assert not lazy, 'Do not support lazy'
 
@@ -149,21 +138,16 @@
                                       'argument implemented yet')
         self._fsrc = None
 
         self._blk = Block(file_origin=self._filename)
         block = self._blk
 
         # create the objects to store other objects
-        chx = ChannelIndex(file_origin=self._filename,
-                           index=np.array([], dtype=np.int))
-        self.__unit = Unit(file_origin=self._filename)
-
-        # load objects into their containers
-        block.channel_indexes.append(chx)
-        chx.units.append(self.__unit)
+        self.__unit_group =  Group(file_origin=self._filename)
+        block.groups.append(self.__unit_group)
 
         # initialize values
         self.__t_stop = None
         self.__params = None
         self.__seg = None
         self.__spiketimes = None
 
@@ -282,15 +266,15 @@
         times = pq.Quantity(self.__spiketimes, dtype=np.float32,
                             units=pq.ms)
         train = SpikeTrain(times,
                            t_start=0 * pq.ms, t_stop=self.__t_stop * pq.ms,
                            file_origin=self._filename)
 
         self.__seg.spiketrains = [train]
-        self.__unit.spiketrains.append(train)
+        self.__unit_group.spiketrains.append(train)
         self._blk.segments.append(self.__seg)
 
         # set an empty segment
         # from now on, we need to set __seg to False rather than None so
         # that if there is a condition with no SpikeTrains we know
         # to create an empty Segment
         self.__seg = False
```

### Comparing `neo-0.8.0/neo/io/brainwaresrcio.py` & `neo-0.9.0/neo/io/brainwaresrcio.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading from Brainware SRC files
 
 SRC files are binary files for holding spike data.  They are broken up into
 nested data sequences of different types, with each type of sequence identified
 by a unique ID number.  This allows new versions of sequences to be included
 without breaking backwards compatibility, since new versions can just be given
@@ -24,42 +23,41 @@
 http://www.tdt.com/downloads.htm
 
 Neither Dr. Jan Schnupp nor Tucker Davis Technologies, Inc. had any part in the
 development of this code
 
 The code is implemented with the permission of Dr. Jan Schnupp
 
+Note when porting ChannelIndex/Unit to Group  (Samuel Garcia).
+The ChannelIndex was used as group of units.
+To avoid now a "group of group" each units is directly a "Group"'.
+
+
 Author: Todd Jennings
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 # import needed core python modules
 from datetime import datetime, timedelta
 from itertools import chain
 import logging
 import os.path
-import sys
 
 # numpy and quantities are already required by neo
 import numpy as np
 import quantities as pq
 
 # needed core neo modules
 from neo.core import (Block, Event,
-                      ChannelIndex, Segment, SpikeTrain, Unit)
+                      Group, Segment, SpikeTrain, Unit)
 
 # need to subclass BaseIO
 from neo.io.baseio import BaseIO
 
 LOGHANDLER = logging.StreamHandler()
 
-PY_VER = sys.version_info[0]
-
 
 class BrainwareSrcIO(BaseIO):
     """
     Class for reading Brainware Spike ReCord files with the extension '.src'
 
     The read_block method returns the first Block of the file.  It will
     automatically close the file after reading.
@@ -74,53 +72,52 @@
     Call the close method to close the file and reset this method
     back to the first Block.
 
     The _isopen property tells whether the file is currently open and
     reading or closed.
 
     Note 1:
-        The first Unit in each ChannelIndex is always
+        The first Unit in each Group is always
         UnassignedSpikes, which has a SpikeTrain for each Segment containing
         all the spikes not assigned to any Unit in that Segment.
 
     Note 2:
         The first Segment in each Block is always Comments, which stores all
         comments as an Event object.
 
     Note 3:
         The parameters from the BrainWare table for each condition are stored
         in the Segment annotations.  If there are multiple repetitions of
         a condition, each repetition is stored as a separate Segment.
 
     Note 4:
-        There is always only one ChannelIndex.  BrainWare stores the
-        equivalent of ChannelIndexes in separate files.
+        There is always only one Group.
 
     Usage:
         >>> from neo.io.brainwaresrcio import BrainwareSrcIO
         >>> srcfile = BrainwareSrcIO(filename='multi_500ms_mulitrep_ch1.src')
         >>> blk1 = srcfile.read()
         >>> blk2 = srcfile.read_block()
         >>> blks = srcfile.read_all_blocks()
         >>> print blk1.segments
         >>> print blk1.segments[0].spiketrains
-        >>> print blk1.units
-        >>> print blk1.units[0].name
+        >>> print blk1.groups
+        >>> print blk1.groups[0].name
         >>> print blk2
         >>> print blk2[0].segments
         >>> print blks
         >>> print blks[0].segments
     """
 
     is_readable = True  # This class can only read data
     is_writable = False  # write is not supported
 
     # This class is able to directly or indirectly handle the following objects
-    supported_objects = [Block, ChannelIndex,
-                         Segment, SpikeTrain, Event, Unit]
+    supported_objects = [Block, Group,
+                         Segment, SpikeTrain, Event]
 
     readable_objects = [Block]
     writeable_objects = []
 
     has_header = False
     is_streameable = False
 
@@ -159,23 +156,19 @@
 
         # This stores the file object for the current file
         self._fsrc = None
 
         # This stores the current Block
         self._blk = None
 
-        # This stores the current ChannelIndex for easy access
-        # It is equivalent to self._blk.channel_indexes[0]
-        self._chx = None
-
         # This stores the current Segment for easy access
         # It is equivalent to self._blk.segments[-1]
         self._seg0 = None
 
-        # this stores a dictionary of the Block's Units by name,
+        # this stores a dictionary of the Block's Group (Units) by name,
         # making it easier and faster to retrieve Units by name later
         # UnassignedSpikes and Units accessed by index are not stored here
         self._unitdict = {}
 
         # this stores the current Unit
         self._unit0 = None
 
@@ -218,23 +211,14 @@
         self._damaged = False
         self._fsrc = None
         self._seg0 = None
         self._file_origin = None
         self._lazy = False
         self._default_spiketrain = None
 
-    def read(self, lazy=False, **kargs):
-        """
-        Reads the first Block from the Spike ReCording file "filename"
-        generated with BrainWare.
-
-        If you wish to read more than one Block, please use read_all_blocks.
-        """
-        return self.read_block(lazy=lazy, **kargs)
-
     def read_block(self, lazy=False, **kargs):
         """
         Reads the first Block from the Spike ReCording file "filename"
         generated with BrainWare.
 
         If you wish to read more than one Block, please use read_all_blocks.
         """
@@ -274,23 +258,19 @@
         # create _default_spiketrain here for performance reasons
         self._default_spiketrain = self._init_default_spiketrain.copy()
         self._default_spiketrain.file_origin = self._file_origin
 
         # create the Block and the contents all Blocks of from IO share
         self._blk = Block(file_origin=self._file_origin)
 
-        self._chx = ChannelIndex(file_origin=self._file_origin,
-                                 index=np.array([], dtype=np.int))
         self._seg0 = Segment(name='Comments', file_origin=self._file_origin)
-        self._unit0 = Unit(name='UnassignedSpikes',
-                           file_origin=self._file_origin,
+        self._unit0 = Group(name='UnassignedSpikes',
                            elliptic=[], boundaries=[],
                            timestamp=[], max_valid=[])
-        self._blk.channel_indexes.append(self._chx)
-        self._chx.units.append(self._unit0)
+        self._blk.groups.append(self._unit0)
         self._blk.segments.append(self._seg0)
 
         # this actually reads the contents of the Block
         result = []
         while hasattr(result, '__iter__'):
             try:
                 result = self._read_by_id()
@@ -302,15 +282,14 @@
         self._blk.create_many_to_one_relationship()
 
         # put the Block in a local object so it can be gargabe collected
         blockobj = self._blk
 
         # reset the per-Block attributes
         self._blk = None
-        self._chx = None
         self._unitdict = {}
 
         # combine the comments into one big event
         self._combine_segment_events(self._seg0)
 
         # result is None iff the end of the file is reached, so we can
         # close the file
@@ -402,16 +381,15 @@
         The rest of the private methods can only safely be called by this
         method or by other private methods, since they depend on the
         current position in the file.
         """
 
         try:
             # uint16 -- the ID code of the next sequence
-            seqid = np.asscalar(np.fromfile(self._fsrc,
-                                            dtype=np.uint16, count=1))
+            seqid = np.fromfile(self._fsrc, dtype=np.uint16, count=1).item()
         except ValueError:
             # return a None if at EOF.  Other methods use None to recognize
             # an EOF
             return None
 
         # using the seqid, get the reader function from the reader dict
         readfunc = self._ID_DICT.get(seqid)
@@ -451,17 +429,17 @@
 
     def _assign_sequence(self, data_obj):
         """
         _assign_sequence(data_obj) - Try to guess where an unknown sequence
         should go based on its class.  Warning are issued if this method is
         used since manual reorganization may be needed.
         """
-        if isinstance(data_obj, Unit):
-            self.logger.warning('Unknown Unit found, adding to Units list')
-            self._chx.units.append(data_obj)
+        if isinstance(data_obj, Group):
+            self.logger.warning('Unknown Group found, adding to Group list')
+            self._blk.groups.append(data_obj)
             if data_obj.name:
                 self._unitdict[data_obj.name] = data_obj
         elif isinstance(data_obj, Segment):
             self.logger.warning('Unknown Segment found, '
                                 'adding to Segments list')
             self._blk.segments.append(data_obj)
         elif isinstance(data_obj, Event):
@@ -503,15 +481,15 @@
     def _combine_events(self, events):
         """
         _combine_events(events) - combine a list of Events
         with single events into one long Event
         """
         if not events:
             event = Event(times=pq.Quantity([], units=pq.s),
-                          labels=np.array([], dtype='S'),
+                          labels=np.array([], dtype='U'),
                           senders=np.array([], dtype='S'),
                           t_start=0)
             return event
 
         times = []
         labels = []
         senders = []
@@ -525,15 +503,15 @@
                                      format(event.labels.shape))
             senders.append(event.annotations['sender'])
 
         times = np.array(times, dtype=np.float32)
         t_start = times.min()
         times = pq.Quantity(times - t_start, units=pq.d).rescale(pq.s)
 
-        labels = np.array(labels)
+        labels = np.array(labels, dtype='U')
         senders = np.array(senders)
 
         event = Event(times=times, labels=labels,
                       t_start=t_start.tolist(), senders=senders)
 
         return event
 
@@ -645,22 +623,17 @@
     #   an exception or not.
     # -------------------------------------------------------------------------
     # -------------------------------------------------------------------------
 
     def __read_str(self, numchars=1, utf=None):
         """
         Read a string of a specific length.
-
-        This is compatible with python 2 and python 3.
         """
-        rawstr = np.asscalar(np.fromfile(self._fsrc,
-                                         dtype='S%s' % numchars, count=1))
-        if utf or (utf is None and PY_VER == 3):
-            return rawstr.decode('utf-8')
-        return rawstr
+        rawstr = np.fromfile(self._fsrc, dtype='S%s' % numchars, count=1).item()
+        return rawstr.decode('utf-8')
 
     def __read_annotations(self):
         """
         Read the stimulus grid properties.
 
         -------------------------------------------------------------------
         Returns a dictionary containing the parameter names as keys and the
@@ -679,16 +652,15 @@
         # [data sequence] * numelements -- parameter names
         names = []
         for i in range(numelements):
             # {skip} = byte (char) -- skip one byte
             self._fsrc.seek(1, 1)
 
             # uint8 -- length of next string
-            numchars = np.asscalar(np.fromfile(self._fsrc,
-                                               dtype=np.uint8, count=1))
+            numchars = np.fromfile(self._fsrc, dtype=np.uint8, count=1).item()
 
             # if there is no name, make one up
             if not numchars:
                 name = 'param%s' % i
             else:
                 # char * numchars -- parameter name string
                 name = self.__read_str(numchars)
@@ -751,23 +723,21 @@
         No ID number: always called from another method
         """
 
         # float64 -- timestamp (number of days since dec 30th 1899)
         time = np.fromfile(self._fsrc, dtype=np.double, count=1)[0]
 
         # int16 -- length of next string
-        numchars1 = np.asscalar(np.fromfile(self._fsrc,
-                                            dtype=np.int16, count=1))
+        numchars1 = np.fromfile(self._fsrc, dtype=np.int16, count=1).item()
 
         # char * numchars -- the one who sent the comment
         sender = self.__read_str(numchars1)
 
         # int16 -- length of next string
-        numchars2 = np.asscalar(np.fromfile(self._fsrc,
-                                            dtype=np.int16, count=1))
+        numchars2 = np.fromfile(self._fsrc, dtype=np.int16, count=1).item()
 
         # char * numchars -- comment text
         text = self.__read_str(numchars2, utf=False)
 
         comment = Event(times=pq.Quantity(time, units=pq.d), labels=[text],
                         sender=sender, file_origin=self._file_origin)
 
@@ -955,19 +925,14 @@
         numelements = np.fromfile(self._fsrc, dtype=np.int16, count=1)[0]
 
         # comment_obj * numelements -- comments about the Segments
         # we don't know which Segment specifically, though
         for _ in range(numelements):
             self.__read_comment()
 
-        # create a channel_index for the numchannels
-        self._chx.index = np.arange(numchannels)
-        self._chx.channel_names = np.array(['Chan{}'.format(i)
-                                            for i in range(numchannels)], dtype='S')
-
         # store what side of the head we are dealing with
         for segment in segments:
             for spiketrain in segment.spiketrains:
                 spiketrain.annotations['side'] = side
 
         return segments
 
@@ -1273,15 +1238,14 @@
         # this is used to figure out which Units to return
         maxunit = 1
 
         # int16 -- number of time slices
         numelements = np.fromfile(self._fsrc, dtype=np.int16, count=1)[0]
 
         # {sequence} * numelements1 -- the number of lists of Units to read
-        self._chx.annotations['max_valid'] = []
         for i in range(numelements):
 
             # {skip} = byte * 2 (int16) -- skip 2 bytes
             self._fsrc.seek(2, 1)
 
             # double
             max_valid = np.fromfile(self._fsrc, dtype=np.double, count=1)[0]
@@ -1290,27 +1254,27 @@
             numunits = np.fromfile(self._fsrc, dtype=np.int16, count=1)[0]
 
             # update tha maximum Unit so far
             maxunit = max(maxunit, numunits + 1)
 
             # if there aren't enough Units, create them
             # remember we need to skip the UnassignedSpikes Unit
-            if numunits > len(self._chx.units) + 1:
-                for ind1 in range(len(self._chx.units), numunits + 1):
-                    unit = Unit(name='unit%s' % ind1,
+            if numunits > len(self._blk.groups) + 1:
+                for ind1 in range(len(self._blk.groups), numunits + 1):
+                    unit = Group(name='unit%s' % ind1,
                                 file_origin=self._file_origin,
                                 elliptic=[], boundaries=[],
                                 timestamp=[], max_valid=[])
-                    self._chx.units.append(unit)
+                    self._blk.groups.append(unit)
 
             # {Block} * numelements -- Units
             for ind1 in range(numunits):
                 # get the Unit with the given index
                 # remember we need to skip the UnassignedSpikes Unit
-                unit = self._chx.units[ind1 + 1]
+                unit = self._blk.groups[ind1 + 1]
 
                 # {skip} = byte * 2 (int16) -- skip 2 bytes
                 self._fsrc.seek(2, 1)
 
                 # int16 -- a multiplier for the elliptic and boundaries
                 #          properties
                 numelements3 = np.fromfile(self._fsrc, dtype=np.int16,
@@ -1325,15 +1289,15 @@
                 boundaries = np.fromfile(self._fsrc, dtype=np.float32,
                                          count=20 * numelements3)
 
                 unit.annotations['elliptic'].append(elliptic)
                 unit.annotations['boundaries'].append(boundaries)
                 unit.annotations['max_valid'].append(max_valid)
 
-        return self._chx.units[1:maxunit]
+        return self._blk.groups[1:maxunit]
 
     def __read_unit_list_timestamped(self):
         """
         A list of a list of Units.
 
         This is the same as __read_unit_list, except that it also has a
         timestamp.  This is added ad an annotation to all Units.
@@ -1415,16 +1379,15 @@
         ID: 29084
         """
 
         # {skip} = bytes * 2 (uint16) -- skip two bytes
         self._fsrc.seek(2, 1)
 
         # uint16 -- number of characters in next string
-        numchars = np.asscalar(np.fromfile(self._fsrc,
-                                           dtype=np.uint16, count=1))
+        numchars = np.fromfile(self._fsrc, dtype=np.uint16, count=1).item()
 
         # char * numchars -- ID string of Unit
         name = self.__read_str(numchars)
 
         # int32 -- SpikeTrain length in ms
         # int32 * 4 -- response and spon period boundaries
         parts = np.fromfile(self._fsrc, dtype=np.int32, count=5)
@@ -1435,17 +1398,17 @@
         # (data_obj) -- list of SpikeTrains
         spikeslists = self._read_by_id()
 
         # use the Unit if it already exists, otherwise create it
         if name in self._unitdict:
             unit = self._unitdict[name]
         else:
-            unit = Unit(name=name, file_origin=self._file_origin,
+            unit = Group(name=name, file_origin=self._file_origin,
                         elliptic=[], boundaries=[], timestamp=[], max_valid=[])
-            self._chx.units.append(unit)
+            self._blk.groups.append(unit)
             self._unitdict[name] = unit
 
         # convert the individual spikes to SpikeTrains and add them to the Unit
         trains = [self._combine_spiketrains(spikes) for spikes in spikeslists]
         unit.spiketrains.extend(trains)
         for train in trains:
             train.t_stop = t_stop.copy()
```

### Comparing `neo-0.8.0/neo/io/elanio.py` & `neo-0.9.0/neo/io/elanio.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,22 +1,20 @@
-# -*- coding: utf-8 -*-
-
 from neo.io.basefromrawio import BaseFromRaw
 from neo.rawio.elanrawio import ElanRawIO
 
 
 class ElanIO(ElanRawIO, BaseFromRaw):
     """
     Class for reading data from Elan.
 
     Elan is software for studying time-frequency maps of EEG data.
 
     Elan is developed in Lyon, France, at INSERM U821
 
     https://elan.lyon.inserm.fr
     """
-    _prefered_signal_group_mode = 'split-all'
-    # _prefered_signal_group_mode = 'group-by-same-units'
+    _prefered_signal_group_mode = 'group-by-same-units'
+    _default_group_mode_have_change_in_0_9 = True
 
     def __init__(self, filename):
         ElanRawIO.__init__(self, filename=filename)
         BaseFromRaw.__init__(self, filename)
```

### Comparing `neo-0.8.0/neo/io/elphyio.py` & `neo-0.9.0/neo/io/elphyio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 README
 =====================================================================================
 This is the implementation of the NEO IO for Elphy files.
 
 IO dependencies:
 - NEO
@@ -68,17 +67,14 @@
 >>> r.write_block( bl )
 
 
 Author: Thierry Brizzi
         Domenico Guarino
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 # python commons:
 from datetime import datetime
 from fractions import gcd
 from os import path
 import re
 import struct
 from time import time
@@ -95,15 +91,15 @@
                       AnalogSignal, Event, SpikeTrain)
 
 
 # --------------------------------------------------------
 # OBJECTS
 
 
-class ElphyScaleFactor(object):
+class ElphyScaleFactor:
     """
     Useful to retrieve real values from integer
     ones that are stored in an Elphy file :
 
     ``scale`` : compute the actual value of a sample
     with this following formula :
 
@@ -115,15 +111,15 @@
         self.delta = delta
         self.offset = offset
 
     def scale(self, value):
         return value * self.delta + self.offset
 
 
-class BaseSignal(object):
+class BaseSignal:
     """
     A descriptor storing main signal properties :
 
     ``layout`` : the :class:``ElphyLayout` object
     that extracts data from a file.
 
     ``episode`` : the episode in which the signal
@@ -177,15 +173,15 @@
     ``y_unit`` : a property to access the y-coordinates unit.
     ``data`` : a property that delegate data extraction to the
                 ``get_signal_data`` function of the ```layout`` object.
     """
 
     def __init__(self, layout, episode, channel, x_unit, y_unit, sampling_frequency, start, stop,
                  name=None):
-        super(ElphySignal, self).__init__(layout, episode, sampling_frequency, start, stop, name)
+        super().__init__(layout, episode, sampling_frequency, start, stop, name)
         self.channel = channel
         self.units = [x_unit, y_unit]
 
     def __str__(self):
         return "{} ep_{} ch_{} [{}, {}]".format(
             self.layout.file.name, self.episode, self.channel, self.x_unit, self.y_unit)
 
@@ -218,15 +214,15 @@
     ``number`` : the identifier of the tag channel.
     ``x_unit`` : the unit of the x-coordinate.
 
     """
 
     def __init__(self, layout, episode, number, x_unit, sampling_frequency, start, stop,
                  name=None):
-        super(ElphyTag, self).__init__(layout, episode, sampling_frequency, start, stop, name)
+        super().__init__(layout, episode, sampling_frequency, start, stop, name)
         self.number = number
         self.units = [x_unit, None]
 
     def __str__(self):
         return "{} : ep_{} tag_ch_{} [{}]".format(
             self.layout.file.name, self.episode, self.number, self.x_unit)
 
@@ -245,15 +241,15 @@
         return self.layout.get_tag_data(self.episode, self.number)
 
     @property
     def channel(self):
         return self.number
 
 
-class ElphyEvent(object):
+class ElphyEvent:
     """
     A descriptor that store a set of events properties :
 
     ``layout`` : the :class:``ElphyLayout` object
     that extracts data from a file.
 
     ``episode`` : the episode in which the signal
@@ -319,15 +315,15 @@
     ``times`` : a property triggering event times extraction.
 
     ``waveforms`` : a property triggering waveforms extraction.
     """
 
     def __init__(self, layout, episode, number, x_unit, n_events, wf_sampling_frequency,
                  wf_samples, unit_x_wf, unit_y_wf, t_start, name=None):
-        super(ElphySpikeTrain, self).__init__(layout, episode, number, x_unit, n_events, name)
+        super().__init__(layout, episode, number, x_unit, n_events, name)
         self.wf_samples = wf_samples
         self.wf_sampling_frequency = wf_sampling_frequency
         assert wf_sampling_frequency, "bad sampling frequency"
         self.wf_sampling_period = 1.0 / wf_sampling_frequency
         self.wf_units = [unit_x_wf, unit_y_wf]
         self.t_start = t_start
 
@@ -355,15 +351,15 @@
             else None
 
 
 # --------------------------------------------------------
 # BLOCKS
 
 
-class BaseBlock(object):
+class BaseBlock:
     """
     Represent a chunk of file storing metadata or
     raw data. A convenient class to break down the
     structure of an Elphy file to several building
     blocks :
 
     ``layout`` : the layout containing the block.
@@ -409,15 +405,15 @@
 
     ``sub_blocks`` : the sub-blocks contained by the block.
 
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="i",
                  parent_block=None):
-        super(ElphyBlock, self).__init__(layout, identifier, start, size)
+        super().__init__(layout, identifier, start, size)
         # a block may be a sub-block of another block
         self.parent_block = parent_block
         # pascal language store strings in 2 different ways
         # ... first, if in the program the size of the string is
         # specified (fixed) then the file stores the length
         # of the string and allocate a number of bytes equal
         # to the specified size
@@ -463,17 +459,17 @@
     commands to extract metadata relative to a protocol.
     Consequently managing a new protocol implies to refactor
     the file info extraction.
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="i",
                  parent_block=None):
-        super(FileInfoBlock, self).__init__(layout, identifier, start,
-                                            size, fixed_length, size_format,
-                                            parent_block=parent_block)
+        super().__init__(layout, identifier, start,
+                         size, fixed_length, size_format,
+                         parent_block=parent_block)
         self.header = None
         self.file = self.layout.file
 
     def get_protocol_and_version(self):
         """
         Return a tuple useful to identify the
         kind of protocol that has generated a
@@ -834,15 +830,15 @@
 
     NB : Subclassing this class is a convenient
     way to set the properties of the header using
     polymorphism rather than a conditional structure.
     """
 
     def __init__(self, layout, identifier, size, fixed_length=None, size_format="i"):
-        super(Header, self).__init__(layout, identifier, 0, size, fixed_length, size_format)
+        super().__init__(layout, identifier, 0, size, fixed_length, size_format)
 
 
 class Acquis1Header(Header):
     """
     A subclass of :class:`Header` used to
     identify the 'ACQUIS1/GS/1991' format.
     Whereas more recent format, the header
@@ -891,15 +887,15 @@
 
     See file 'FicDefAc1.pas' to identify
     the parsed parameters.
     """
 
     def __init__(self, layout):
         fileobj = layout.file
-        super(Acquis1Header, self).__init__(layout, "ACQUIS1/GS/1991", 1024, 15, "h")
+        super().__init__(layout, "ACQUIS1/GS/1991", 1024, 15, "h")
 
         # parse the header to store interesting data about episodes and channels
         fileobj.seek(18)
 
         # extract episode properties
         n_channels = read_from_char(fileobj, 'B')
         assert not ((n_channels < 1) or (n_channels > 16)), "bad number of channels"
@@ -1062,30 +1058,30 @@
     NB : the size is fixed to 20 bytes,
     the identifier is a string containing
     15 characters and the size is encoded
     as integer.
     """
 
     def __init__(self, layout):
-        super(DAC2GSHeader, self).__init__(layout, "DAC2/GS/2000", 20, 15, "i")
+        super().__init__(layout, "DAC2/GS/2000", 20, 15, "i")
 
 
 class DAC2Header(Header):
     """
     A subclass of :class:`Header` used to
     identify the 'DAC2 objects' format.
 
     NB : the size is fixed to 18 bytes,
     the identifier is a string containing
     15 characters and the size is encoded
     as small integer.
     """
 
     def __init__(self, layout):
-        super(DAC2Header, self).__init__(layout, "DAC2 objects", 18, 15, "h")
+        super().__init__(layout, "DAC2 objects", 18, 15, "h")
 
 
 class DAC2GSMainBlock(ElphyBlock):
     """
     Subclass of :class:`Block` useful to store data corresponding to
     the 'Main' block stored in the DAC2/GS/2000 format :
 
@@ -1127,15 +1123,15 @@
 
     ``n_episodes`` : the number of recording sequences store in the file.
 
     NB : see file 'FdefDac2.pas' to identify the other parsed parameters.
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="i"):
-        super(DAC2GSMainBlock, self).__init__(
+        super().__init__(
             layout, identifier, start, size, fixed_length, size_format)
         # parse the file to retrieve episodes and channels properties
         n_channels, nbpt, tpData = struct.unpack('<BiB', layout.file.read(6))
         l_xu, xu, dX, X0 = struct.unpack('<B10sdd', layout.file.read(27))
         y_units = list()
         dY_ar = list()
         Y0_ar = list()
@@ -1228,15 +1224,15 @@
         Y0_ar = list()
         for _ in range(0, 16):
             l_yu, yu, dY, Y0 = struct.unpack('<B10sdd', layout.file.read(27))
             y_units.append(yu[0:l_yu])
             dY_ar.append(dY)
             Y0_ar.append(Y0)
 
-        super(DAC2GSEpisodeBlock, self).__init__(layout, identifier,
+        super().__init__(layout, identifier,
                                                  start, layout.main_block.ep_size, fixed_length,
                                                  size_format)
 
         self.n_channels = main.n_channels
         self.nbpt = main.nbpt
         self.tpData = main.tpData
         if not main.continuous:
@@ -1269,15 +1265,15 @@
     ``ks_block`` : a shortcut the the 'KSamp' sub-block.
 
     ``kt_block`` : a shortcut the the 'Ktype' sub-block.
 
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l"):
-        super(DAC2EpisodeBlock, self).__init__(
+        super().__init__(
             layout, identifier, start, size, fixed_length, size_format)
         self.ep_block = None
         self.ch_block = None
         self.ks_block = None
         self.kt_block = None
 
     def set_episode_block(self):
@@ -1315,15 +1311,15 @@
 
     NB : This kind of block is preceeded by a structure which size is encoded
     as a 2 bytes unsigned short. Consequently, data start at data_offset plus
     the size.
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l"):
-        super(DAC2RDataBlock, self).__init__(
+        super().__init__(
             layout, identifier, start, size, fixed_length, size_format)
         self.data_start = self.data_offset + read_from_char(layout.file, 'H')
 
 
 class DAC2CyberTagBlock(ElphyBlock):
     """
     Subclass of :class:`Block` useful to store data corresponding to
@@ -1333,15 +1329,15 @@
 
     NB : This kind of block is preceeded by a structure which size is encoded
     as a 2 bytes unsigned short. Consequently, data start at data_offset plus
     the size.
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l"):
-        super(DAC2CyberTagBlock, self).__init__(
+        super().__init__(
             layout, identifier, start, size, fixed_length, size_format)
         self.data_start = self.data_offset + read_from_char(layout.file, 'H')
 
 
 class DAC2EventBlock(ElphyBlock):
     """
     Subclass of :class:`Block` useful to store
@@ -1353,15 +1349,15 @@
     ``n_evt_channels`` : the number of channels used to acquire events.
 
     ``n_events`` : an array containing the number of events for each event channel.
 
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l"):
-        super(DAC2EventBlock, self).__init__(
+        super().__init__(
             layout, identifier, start, size, fixed_length, size_format)
         fileobj = self.layout.file
         jump = self.data_offset + read_from_char(fileobj, 'H')
         fileobj.seek(jump)
 
         # extract the number of event channel
         self.n_evt_channels = read_from_char(fileobj, 'i')
@@ -1381,15 +1377,15 @@
     Subclass of :class:`DAC2EventBlock` useful
     to identify 'RSPK' and make the distinction
     with 'REVT' blocks stored in the last version
     of Elphy format.
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l"):
-        super(DAC2SpikeBlock, self).__init__(
+        super().__init__(
             layout, identifier, start, size, fixed_length, size_format)
         fileobj = self.layout.file
         jump = self.data_offset
         fileobj.seek(jump)  # go to SpikeBlock
         jump = self.data_offset + read_from_char(fileobj, 'h')
         fileobj.seek(jump)
         # extract the number of event channel
@@ -1417,15 +1413,15 @@
     ``pre_trigger`` : the number of samples of a waveform arriving before a spike.
 
     ``wavelength`` : the number of samples in a waveform.
 
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l"):
-        super(DAC2WaveFormBlock, self).__init__(
+        super().__init__(
             layout, identifier, start, size, fixed_length, size_format)
         fileobj = self.layout.file
         jump = self.data_offset + read_from_char(fileobj, 'H')
         fileobj.seek(jump)
         self.wavelength = read_from_char(fileobj, 'i')
         self.pre_trigger = read_from_char(fileobj, 'i')
         self.n_spk_channels = read_from_char(fileobj, 'i')
@@ -1468,17 +1464,17 @@
 
     ``x_unit_wf`` and ``y_unit_wf``: the unit of x and y coordinates for all waveforms in an
     episode.
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l",
                  parent_block=None):
-        super(DAC2EpSubBlock, self).__init__(layout, identifier, start,
-                                             size, fixed_length, size_format,
-                                             parent_block=parent_block)
+        super().__init__(layout, identifier, start,
+                         size, fixed_length, size_format,
+                         parent_block=parent_block)
         fileobj = self.layout.file
         n_channels, nbpt, tpData, l_xu, x_unit, dX, X0 = struct.unpack(
             '<BiBB10sdd', fileobj.read(33))
         continuous, tag_mode, tag_shift = struct.unpack('<?BB', fileobj.read(3))
         DxuSpk, X0uSpk, nbSpk, DyuSpk, Y0uSpk, l_xuspk, unitXSpk, l_yuspk, unitYSpk = \
             struct.unpack('<ddiddB10sB10s', fileobj.read(58))
         cyber_time, pc_time = struct.unpack('<dI', fileobj.read(12))
@@ -1518,17 +1514,17 @@
     ``dY_ar`` and ``Y0_ar`` : arrays containing scaling factors  for each
     channel useful to compute the actual value of a signal sample.
 
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l",
                  parent_block=None):
-        super(DAC2AdcSubBlock, self).__init__(layout, identifier, start,
-                                              size, fixed_length, size_format,
-                                              parent_block=parent_block)
+        super().__init__(layout, identifier, start,
+                         size, fixed_length, size_format,
+                         parent_block=parent_block)
         fileobj = self.layout.file
         # fileobj.seek(start + len(identifier) + 1)
         ep_block, = [k for k in self.parent_block.sub_blocks if k.identifier.startswith('Ep')]
         n_channels = ep_block.n_channels
         self.y_units = list()
         self.dY_ar = list()
         self.Y0_ar = list()
@@ -1548,17 +1544,17 @@
     corresponding to each acquired channel. If a factor is equal to
     zero, then the channel has been converted into an event channel.
 
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l",
                  parent_block=None):
-        super(DAC2KSampSubBlock, self).__init__(layout, identifier, start,
-                                                size, fixed_length, size_format,
-                                                parent_block=parent_block)
+        super().__init__(layout, identifier, start,
+                         size, fixed_length, size_format,
+                         parent_block=parent_block)
         fileobj = self.layout.file
         ep_block, = [k for k in self.parent_block.sub_blocks if k.identifier.startswith('Ep')]
         n_channels = ep_block.n_channels
         k_sampling = list()
         for _ in range(0, n_channels):
             k_sampling.append(read_from_char(fileobj, "H"))
         self.k_sampling = k_sampling
@@ -1571,17 +1567,17 @@
 
     ``k_types`` : an array containing all data formats identifier used
     to compute sample size.
     """
 
     def __init__(self, layout, identifier, start, size, fixed_length=None, size_format="l",
                  parent_block=None):
-        super(DAC2KTypeSubBlock, self).__init__(layout, identifier, start,
-                                                size, fixed_length, size_format,
-                                                parent_block=parent_block)
+        super().__init__(layout, identifier, start,
+                         size, fixed_length, size_format,
+                         parent_block=parent_block)
         fileobj = self.layout.file
         ep_block, = [k for k in self.parent_block.sub_blocks if k.identifier.startswith('Ep')]
         n_channels = ep_block.n_channels
         k_types = list()
         for _ in range(0, n_channels):
             k_types.append(read_from_char(fileobj, "B"))
         self.k_types = k_types
@@ -1694,15 +1690,15 @@
 # LAYOUT
 
 
 b_float = 'f8'
 b_int = 'i2'
 
 
-class ElphyLayout(object):
+class ElphyLayout:
     """
     A convenient class to know how data
     are organised into an Elphy file :
 
     ``elphy_file`` : a :class:`ElphyFile`
     asking file introspection.
 
@@ -2094,15 +2090,15 @@
 
     ``data_offset`` : an offset to jump directly
     to the raw data.
 
     """
 
     def __init__(self, fileobj, data_offset):
-        super(Acquis1Layout, self).__init__(fileobj)
+        super().__init__(fileobj)
         self.data_offset = data_offset
         self.data_blocks = None
 
     def get_blocks_end(self):
         return self.data_offset
 
     def is_continuous(self):
@@ -2215,15 +2211,15 @@
     ``main_block```: a shortcut to access 'MAIN' block.
 
     ``episode_blocks`` : a shortcut to access blocks
     corresponding to episodes.
     """
 
     def __init__(self, fileobj, data_offset):
-        super(DAC2GSLayout, self).__init__(fileobj)
+        super().__init__(fileobj)
         self.data_offset = data_offset
         self.main_block = None
         self.episode_blocks = None
 
     def get_blocks_end(self):
         return self.file_size  # data_offset
 
@@ -2277,15 +2273,15 @@
     def get_channel_for_tags(self, ep):
         return 1
 
     def sample_type(self, ep, ch):
         return self.main_block.tpData
 
     def sample_size(self, ep, ch):
-        size = super(DAC2GSLayout, self).sample_size(ep, ch)
+        size = super().sample_size(ep, ch)
         assert size == 2, "sample size is always 2 bytes for DAC2/GS/2000 format"
         return size
 
     def sampling_period(self, ep, ch):
         block = self.episode_block(ep)
         return block.dX
 
@@ -2401,15 +2397,15 @@
     them over multiple blocks :
 
     ``episode_blocks`` : a shortcut to access blocks
     corresponding to episodes.
     """
 
     def __init__(self, fileobj):
-        super(DAC2Layout, self).__init__(fileobj)
+        super().__init__(fileobj)
         self.episode_blocks = None
 
     def get_blocks_end(self):
         return self.file_size
 
     def is_continuous(self):
         ep_blocks = [k for k in self.blocks if k.identifier.startswith('B_Ep')]
@@ -2693,15 +2689,15 @@
         return mask_ar
 
     def get_signal(self, episode, channel):
         block = self.episode_block(episode)
         k_sampling = np.array(block.ks_block.k_sampling)
         evt_channels = np.where(k_sampling == 0)[0]
         if channel not in evt_channels:
-            return super(DAC2Layout, self).get_signal(episode, channel)
+            return super().get_signal(episode, channel)
         else:
             k_sampling[channel - 1] = -1
             return self.get_event(episode, channel, k_sampling)
 
     def get_tag(self, episode, tag_channel):
         """
         Return a :class:`ElphyTag` which is a
@@ -2974,15 +2970,15 @@
         return self.load_bytes(evt_blocks, dtype='<i4', start=start, end=end,
                                expected_size=expected_size)
 
 
 # ---------------------------------------------------------
 # factories.py
 
-class LayoutFactory(object):
+class LayoutFactory:
     """
     Generate base elements composing the layout of a file.
     """
 
     def __init__(self, elphy_file):
         self.elphy_file = elphy_file
         self.pattern = r"\d{4}(\d+|\D)\D"
@@ -3081,15 +3077,15 @@
     """
     Subclass of :class:`LayoutFactory` useful to
     generate base elements composing the layout
     of Acquis1 file format.
     """
 
     def __init__(self, elphy_file):
-        super(Acquis1Factory, self).__init__(elphy_file)
+        super().__init__(elphy_file)
         self.file.seek(16)
         self.data_offset = read_from_char(self.file, 'h')
         self.file.seek(0)
 
         # the set of interesting blocks useful
         # to retrieve data stored in a file
         self.block_subclasses = {
@@ -3117,15 +3113,15 @@
     """
     Subclass of :class:`LayoutFactory` useful to
     generate base elements composing the layout
     of DAC2/GS/2000 file format.
     """
 
     def __init__(self, elphy_file):
-        super(DAC2GSFactory, self).__init__(elphy_file)
+        super().__init__(elphy_file)
         self.file.seek(16)
         self.data_offset = read_from_char(self.file, 'i')
         self.file.seek(0)
 
         # the set of interesting blocks useful
         # to retrieve data stored in a file
         self.block_subclasses = {
@@ -3162,15 +3158,15 @@
     """
     Subclass of :class:`LayoutFactory` useful to
     generate base elements composing the layout
     of DAC2 objects file format.
     """
 
     def __init__(self, elphy_file):
-        super(DAC2Factory, self).__init__(elphy_file)
+        super().__init__(elphy_file)
 
         # the set of interesting blocks useful
         # to retrieve data stored in a file
         self.block_subclasses = {
             "B_Ep": DAC2EpisodeBlock,
             "RDATA": DAC2RDataBlock,
             "RCyberTag": DAC2CyberTagBlock,
@@ -3228,15 +3224,15 @@
 :class:`ElphyFile`, It iterates through :class:`BaseBlock` objects to retrieve
 asked data.
 
 NB : The reader is not able to read Acquis1 and DAC2/GS/2000 event channels.
 """
 
 
-class ElphyFile(object):
+class ElphyFile:
     """
     A convenient class useful to read Elphy files.
     It acts like a file reader that wraps up a python
     file opened in 'rb' mode in order to retrieve
     directly from an Elphy file raw data and metadata
     relative to protocols.
```

### Comparing `neo-0.8.0/neo/io/exampleio.py` & `neo-0.9.0/neo/io/exampleio.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 neo.io have been split in 2 level API:
   * neo.io: this API give neo object
   * neo.rawio: this API give raw data as they are in files.
 
 Developper are encourage to use neo.rawio.
```

### Comparing `neo-0.8.0/neo/io/hdf5io.py` & `neo-0.9.0/neo/io/hdf5io.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,17 @@
-# -*- coding: utf-8 -*-
 """
 
 
 """
 
-from __future__ import absolute_import
 
-import sys
 import logging
+from distutils.version import LooseVersion
 import pickle
+from warnings import warn
 import numpy as np
 import quantities as pq
 
 try:
     import h5py
 except ImportError as err:
     HAVE_H5PY = False
@@ -22,15 +21,15 @@
 from neo.core import (objectlist, Block, Segment, AnalogSignal, SpikeTrain,
                       Epoch, Event, IrregularlySampledSignal, ChannelIndex,
                       Unit)
 from neo.io.baseio import BaseIO
 from neo.core.baseneo import MergeError
 
 logger = logging.getLogger('Neo')
-
+min_h5py_version = LooseVersion('2.6.0')
 
 def disjoint_groups(groups):
     """`groups` should be a list of sets"""
     groups = groups[:]  # copy, so as not to change original
     for group1 in groups:
         for group2 in groups:
             if group1 != group2:
@@ -52,16 +51,26 @@
     name = 'NeoHdf5 IO'
     extensions = ['h5']
     mode = 'file'
     is_readable = True
     is_writable = False
 
     def __init__(self, filename):
+        warning_msg = (
+            "NeoHdf5IO will be removed in the next release of Neo. "
+            "If you still have data in this format, we recommend saving it using NixIO "
+            "which is also based on HDF5."
+        )
+        warn(warning_msg, FutureWarning)
         if not HAVE_H5PY:
             raise ImportError("h5py is not available")
+        if HAVE_H5PY:
+            if LooseVersion(h5py.__version__) < min_h5py_version:
+                raise ImportError('h5py version {} is too old. Minimal required version is {}'
+                                  ''.format(h5py.__version__, min_h5py_version))
         BaseIO.__init__(self, filename=filename)
         self._data = h5py.File(filename, 'r')
         self.object_refs = {}
 
     def read_all_blocks(self, lazy=False, merge_singles=True, **kargs):
         """
         Loads all blocks in the file that are attached to the root (which
@@ -212,38 +221,38 @@
         self.object_refs[node.attrs["object_ref"]] = spiketrain
         return spiketrain
 
     def _read_epocharray(self, node, parent):
         attributes = self._get_standard_attributes(node)
         times = self._get_quantity(node["times"])
         durations = self._get_quantity(node["durations"])
-        labels = node["labels"].value
+        labels = node["labels"][()].astype('U')
         epoch = Epoch(times=times, durations=durations, labels=labels, **attributes)
         epoch.segment = parent
         return epoch
 
     def _read_epoch(self, node, parent):
         return self._read_epocharray(node, parent)
 
     def _read_eventarray(self, node, parent):
         attributes = self._get_standard_attributes(node)
         times = self._get_quantity(node["times"])
-        labels = node["labels"].value
+        labels = node["labels"][()].astype('U')
         event = Event(times=times, labels=labels, **attributes)
         event.segment = parent
         return event
 
     def _read_event(self, node, parent):
         return self._read_eventarray(node, parent)
 
     def _read_recordingchannelgroup(self, node, parent):
         # todo: handle Units
         attributes = self._get_standard_attributes(node)
-        channel_indexes = node["channel_indexes"].value
-        channel_names = node["channel_names"].value
+        channel_indexes = node["channel_indexes"][()]
+        channel_names = node["channel_names"][()]
 
         if channel_indexes.size:
             if len(node['recordingchannels']):
                 raise MergeError("Cannot handle a RecordingChannelGroup which both has a "
                                  "'channel_indexes' attribute and contains "
                                  "RecordingChannel objects")
             raise NotImplementedError("todo")  # need to handle node['analogsignalarrays']
@@ -307,45 +316,38 @@
             for obj in merged_objects:
                 self.object_refs[obj.annotations['object_ref']] = obj
             return merged_objects
         else:
             return objects
 
     def _get_quantity(self, node):
-        value = node.value
+        value = node[()]
         unit_str = [x for x in node.attrs.keys() if "unit" in x][0].split("__")[1]
         units = getattr(pq, unit_str)
         return value * units
 
     def _get_standard_attributes(self, node):
         """Retrieve attributes"""
         attributes = {}
         for name in ('name', 'description', 'index', 'file_origin', 'object_ref'):
             if name in node.attrs:
                 attributes[name] = node.attrs[name]
         for name in ('rec_datetime', 'file_datetime'):
             if name in node.attrs:
-                if sys.version_info.major > 2:
-                    attributes[name] = pickle.loads(node.attrs[name], encoding='bytes')
-                else:  # Python 2 doesn't have the encoding argument
-                    attributes[name] = pickle.loads(node.attrs[name])
-        if sys.version_info.major > 2:
-            annotations = pickle.loads(node.attrs['annotations'], encoding='bytes')
-        else:
-            annotations = pickle.loads(node.attrs['annotations'])
+                attributes[name] = pickle.loads(node.attrs[name], encoding='bytes')
+        annotations = pickle.loads(node.attrs['annotations'], encoding='bytes')
         attributes.update(annotations)
         # avoid "dictionary changed size during iteration" error
         attribute_names = list(attributes.keys())
-        if sys.version_info.major > 2:
-            for name in attribute_names:
-                if isinstance(attributes[name], (bytes, np.bytes_)):
-                    attributes[name] = attributes[name].decode('utf-8')
-                if isinstance(name, bytes):
-                    attributes[name.decode('utf-8')] = attributes[name]
-                    attributes.pop(name)
+        for name in attribute_names:
+            if isinstance(attributes[name], (bytes, np.bytes_)):
+                attributes[name] = attributes[name].decode('utf-8')
+            if isinstance(name, bytes):
+                attributes[name.decode('utf-8')] = attributes[name]
+                attributes.pop(name)
         return attributes
 
     def _resolve_channel_indexes(self, block):
 
         def disjoint_channel_indexes(channel_indexes):
             channel_indexes = channel_indexes[:]
             for ci1 in channel_indexes:
```

### Comparing `neo-0.8.0/neo/io/igorproio.py` & `neo-0.9.0/neo/io/igorproio.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,20 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data created by IGOR Pro
 (WaveMetrics, Inc., Portland, OR, USA)
 
 Depends on: igor (https://pypi.python.org/pypi/igor/)
 
 Supported: Read
 
 Author: Andrew Davison
 Also contributing: Rick Gerkin
 
 """
 
-from __future__ import absolute_import
 from warnings import warn
 import numpy as np
 import quantities as pq
 from neo.io.baseio import BaseIO
 from neo.core import Block, Segment, AnalogSignal
 
 try:
```

### Comparing `neo-0.8.0/neo/io/klustakwikio.py` & `neo-0.9.0/neo/io/klustakwikio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Reading and writing from KlustaKwik-format files.
 Ref: http://klusters.sourceforge.net/UserManual/data-files.html
 
 Supported : Read, Write
 
 Author : Chris Rodgers
```

### Comparing `neo-0.8.0/neo/io/kwikio.py` & `neo-0.9.0/neo/io/kwikio.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,25 +1,20 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from a .kwik dataset
 
 Depends on: scipy
             phy
 
 Supported: Read
 
 Author: Mikkel E. Lepperd @CINPLA
 
 """
 # TODO: writing to file
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-from __future__ import division
-
 import numpy as np
 import quantities as pq
 import os
 
 try:
     from scipy import stats
 except ImportError as err:
```

### Comparing `neo-0.8.0/neo/io/neomatlabio.py` & `neo-0.9.0/neo/io/neomatlabio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Module for reading/writing Neo objects in MATLAB format (.mat) versions
 5 to 7.2.
 
 This module is a bridge for MATLAB users who want to adopt the Neo object
 representation. The nomenclature is the same but using Matlab structs and cell
 arrays. With this module MATLAB users can use neo.io to read a format and
@@ -273,23 +272,28 @@
         for childname in getattr(ob, '_single_child_containers', []):
             supported_containers = [subob.__name__.lower() + 's' for subob in
                                     self.supported_objects]
             if childname in supported_containers:
                 struct[childname] = []
 
         # attributes
-        for i, attr in enumerate(ob._all_attrs):
+        all_attrs = list(ob._all_attrs)
+        if hasattr(ob, 'annotations'):
+            all_attrs.append(('annotations', type(ob.annotations)))
+
+        for i, attr in enumerate(all_attrs):
             attrname, attrtype = attr[0], attr[1]
 
             # ~ if attrname =='':
             # ~ struct['array'] = ob.magnitude
             # ~ struct['units'] = ob.dimensionality.string
             # ~ continue
 
-            if (hasattr(ob, '_quantity_attr') and ob._quantity_attr == attrname):
+            if (hasattr(ob, '_quantity_attr') and
+                    ob._quantity_attr == attrname):
                 struct[attrname] = ob.magnitude
                 struct[attrname + '_units'] = ob.dimensionality.string
                 continue
 
             if not (attrname in ob.annotations or hasattr(ob, attrname)):
                 continue
             if getattr(ob, attrname) is None:
@@ -305,15 +309,15 @@
             else:
                 struct[attrname] = getattr(ob, attrname)
 
         return struct
 
     def create_ob_from_struct(self, struct, classname):
         cl = class_by_name[classname]
-        # check if hinerits Quantity
+        # check if inherits Quantity
         # ~ is_quantity = False
         # ~ for attr in cl._necessary_attrs:
         # ~ if attr[0] == '' and attr[1] == pq.Quantity:
         # ~ is_quantity = True
         # ~ break
         # ~ is_quantiy = hasattr(cl, '_quantity_attr')
 
@@ -369,21 +373,24 @@
                         getattr(ob, attrname.lower()).append(child)
                 continue
 
             # attributes
             if attrname.endswith('_units') or attrname == 'units':
                 # linked with another field
                 continue
-            if (hasattr(cl, '_quantity_attr') and cl._quantity_attr == attrname):
+
+            if hasattr(cl, '_quantity_attr') and cl._quantity_attr == attrname:
                 continue
 
             item = getattr(struct, attrname)
 
-            attributes = cl._necessary_attrs + cl._recommended_attrs
-            dict_attributes = {a[0]: a[1:] for a in attributes}
+            attributes = cl._necessary_attrs + cl._recommended_attrs \
+                                             + (('annotations', dict),)
+            dict_attributes = dict([(a[0], a[1:]) for a in attributes])
+
             if attrname in dict_attributes:
                 attrtype = dict_attributes[attrname][0]
                 if attrtype == datetime:
                     m = r'(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+).(\d+)'
                     r = re.findall(m, str(item))
                     if len(r) == 1:
                         item = datetime(*[int(e) for e in r[0]])
@@ -395,13 +402,16 @@
                 elif attrtype == pq.Quantity:
                     ndim = dict_attributes[attrname][1]
                     units = str(getattr(struct, attrname + '_units'))
                     if ndim == 0:
                         item = pq.Quantity(item, units)
                     else:
                         item = pq.Quantity(item, units)
+                elif attrtype == dict:
+                    # FIXME: works but doesn't convert nested struct to dict
+                    item = {fn: getattr(item, fn) for fn in item._fieldnames}
                 else:
                     item = attrtype(item)
 
             setattr(ob, attrname, item)
 
         return ob
```

### Comparing `neo-0.8.0/neo/io/nestio.py` & `neo-0.9.0/neo/io/nestio.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,23 +1,21 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading output files from NEST simulations
 ( http://www.nest-simulator.org/ ).
 Tested with NEST2.10.0
 
 Depends on: numpy, quantities
 
 Supported: Read
 
 Authors: Julia Sprenger, Maximilian Schmidt, Johanna Senk
 
 """
 
 # needed for Python3 compatibility
-from __future__ import absolute_import
 
 import os.path
 import warnings
 from datetime import datetime
 import numpy as np
 import quantities as pq
```

### Comparing `neo-0.8.0/neo/io/neuralynxio_v1.py` & `neo-0.9.0/neo/io/neuralynxio_v1.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,6584 +1,6581 @@
-00000000: 2320 2d2a 2d20 636f 6469 6e67 3a20 7574  # -*- coding: ut
-00000010: 662d 3820 2d2a 2d0a 2222 220a 436c 6173  f-8 -*-.""".Clas
-00000020: 7320 666f 7220 7265 6164 696e 6720 6461  s for reading da
-00000030: 7461 2066 726f 6d20 4e65 7572 616c 796e  ta from Neuralyn
-00000040: 7820 6669 6c65 732e 0a54 6869 7320 494f  x files..This IO
-00000050: 2073 7570 706f 7274 7320 4e43 532c 204e   supports NCS, N
-00000060: 4556 2061 6e64 204e 5345 2066 696c 6520  EV and NSE file 
-00000070: 666f 726d 6174 732e 0a0a 5468 6973 206d  formats...This m
-00000080: 6f64 756c 6520 6973 2061 6e20 6f6c 6465  odule is an olde
-00000090: 7220 696d 706c 656d 656e 7461 7469 6f6e  r implementation
-000000a0: 2020 7769 7468 206f 6c64 206e 656f 2e69    with old neo.i
-000000b0: 6f20 4150 492e 0a41 206e 6577 2063 6c61  o API..A new cla
-000000c0: 7373 204e 6575 7261 6c79 6e78 494f 2063  ss NeuralynxIO c
-000000d0: 6f6d 7075 6e64 6564 2062 7920 4e65 7572  ompunded by Neur
-000000e0: 616c 796e 7852 6177 494f 2061 6e64 2042  alynxRawIO and B
-000000f0: 6173 6546 726f 6d49 4f0a 7375 7065 7273  aseFromIO.supers
-00000100: 6565 6420 7468 6973 206f 6e65 2e0a 0a44  eed this one...D
-00000110: 6570 656e 6473 206f 6e3a 206e 756d 7079  epends on: numpy
-00000120: 0a0a 5375 7070 6f72 7465 643a 2052 6561  ..Supported: Rea
-00000130: 640a 0a41 7574 686f 723a 204a 756c 6961  d..Author: Julia
-00000140: 2053 7072 656e 6765 722c 2043 6172 6c6f   Sprenger, Carlo
-00000150: 7320 4361 6e6f 7661 0a41 6461 7074 6564  s Canova.Adapted
-00000160: 2066 726f 6d20 7468 6520 6578 616d 706c   from the exampl
-00000170: 6549 4f20 6f66 2070 7974 686f 6e2d 6e65  eIO of python-ne
-00000180: 6f0a 2222 220a 0a23 206e 6565 6465 6420  o."""..# needed 
-00000190: 666f 7220 7079 7468 6f6e 2033 2063 6f6d  for python 3 com
-000001a0: 7061 7469 6269 6c69 7479 0a66 726f 6d20  patibility.from 
-000001b0: 5f5f 6675 7475 7265 5f5f 2069 6d70 6f72  __future__ impor
-000001c0: 7420 6162 736f 6c75 7465 5f69 6d70 6f72  t absolute_impor
-000001d0: 742c 2064 6976 6973 696f 6e0a 0a69 6d70  t, division..imp
-000001e0: 6f72 7420 7379 730a 696d 706f 7274 206f  ort sys.import o
-000001f0: 730a 696d 706f 7274 2077 6172 6e69 6e67  s.import warning
-00000200: 730a 696d 706f 7274 2063 6f64 6563 730a  s.import codecs.
-00000210: 696d 706f 7274 2063 6f70 790a 696d 706f  import copy.impo
-00000220: 7274 2072 650a 696d 706f 7274 2064 6174  rt re.import dat
-00000230: 6574 696d 650a 696d 706f 7274 2070 6b67  etime.import pkg
-00000240: 5f72 6573 6f75 7263 6573 0a0a 696d 706f  _resources..impo
-00000250: 7274 206e 756d 7079 2061 7320 6e70 0a0a  rt numpy as np..
-00000260: 696d 706f 7274 2071 7561 6e74 6974 6965  import quantitie
-00000270: 7320 6173 2070 710a 0a66 726f 6d20 6e65  s as pq..from ne
-00000280: 6f2e 696f 2e62 6173 6569 6f20 696d 706f  o.io.baseio impo
-00000290: 7274 2042 6173 6549 4f0a 6672 6f6d 206e  rt BaseIO.from n
-000002a0: 656f 2e63 6f72 6520 696d 706f 7274 2028  eo.core import (
-000002b0: 426c 6f63 6b2c 2053 6567 6d65 6e74 2c20  Block, Segment, 
-000002c0: 4368 616e 6e65 6c49 6e64 6578 2c20 416e  ChannelIndex, An
-000002d0: 616c 6f67 5369 676e 616c 2c20 5370 696b  alogSignal, Spik
-000002e0: 6554 7261 696e 2c0a 2020 2020 2020 2020  eTrain,.        
-000002f0: 2020 2020 2020 2020 2020 2020 2020 4576                Ev
-00000300: 656e 742c 2055 6e69 7429 0a66 726f 6d20  ent, Unit).from 
-00000310: 6f73 2069 6d70 6f72 7420 6c69 7374 6469  os import listdi
-00000320: 722c 2073 6570 0a66 726f 6d20 6f73 2e70  r, sep.from os.p
-00000330: 6174 6820 696d 706f 7274 2069 7366 696c  ath import isfil
-00000340: 652c 2067 6574 7369 7a65 0a0a 696d 706f  e, getsize..impo
-00000350: 7274 2068 6173 686c 6962 0a69 6d70 6f72  rt hashlib.impor
-00000360: 7420 7069 636b 6c65 0a0a 6966 2068 6173  t pickle..if has
-00000370: 6174 7472 2870 6b67 5f72 6573 6f75 7263  attr(pkg_resourc
-00000380: 6573 2c20 2770 6b67 5f72 6573 6f75 7263  es, 'pkg_resourc
-00000390: 6573 2729 3a0a 2020 2020 7061 7273 655f  es'):.    parse_
-000003a0: 7665 7273 696f 6e20 3d20 706b 675f 7265  version = pkg_re
-000003b0: 736f 7572 6365 732e 706b 675f 7265 736f  sources.pkg_reso
-000003c0: 7572 6365 732e 7061 7273 655f 7665 7273  urces.parse_vers
-000003d0: 696f 6e0a 656c 7365 3a0a 2020 2020 7061  ion.else:.    pa
-000003e0: 7273 655f 7665 7273 696f 6e20 3d20 706b  rse_version = pk
-000003f0: 675f 7265 736f 7572 6365 732e 7061 7273  g_resources.pars
-00000400: 655f 7665 7273 696f 6e0a 0a0a 636c 6173  e_version...clas
-00000410: 7320 4e65 7572 616c 796e 7849 4f28 4261  s NeuralynxIO(Ba
-00000420: 7365 494f 293a 0a20 2020 2022 2222 0a20  seIO):.    """. 
-00000430: 2020 2043 6c61 7373 2066 6f72 2072 6561     Class for rea
-00000440: 6469 6e67 204e 6575 7261 6c79 6e78 2066  ding Neuralynx f
-00000450: 696c 6573 2e0a 0a20 2020 2049 7420 656e  iles...    It en
-00000460: 6162 6c65 7320 7265 6164 696e 673a 0a20  ables reading:. 
-00000470: 2020 202d 203a 636c 6173 733a 2742 6c6f     - :class:'Blo
-00000480: 636b 270a 2020 2020 2d20 3a63 6c61 7373  ck'.    - :class
-00000490: 3a27 5365 676d 656e 7427 0a20 2020 202d  :'Segment'.    -
-000004a0: 203a 636c 6173 733a 2741 6e61 6c6f 6753   :class:'AnalogS
-000004b0: 6967 6e61 6c27 0a20 2020 202d 203a 636c  ignal'.    - :cl
-000004c0: 6173 733a 2753 7069 6b65 5472 6169 6e27  ass:'SpikeTrain'
-000004d0: 0a0a 2020 2020 5573 6167 653a 0a20 2020  ..    Usage:.   
-000004e0: 2020 2020 2066 726f 6d20 6e65 6f20 696d       from neo im
-000004f0: 706f 7274 2069 6f0a 2020 2020 2020 2020  port io.        
-00000500: 696d 706f 7274 2071 7561 6e74 6974 6965  import quantitie
-00000510: 7320 6173 2070 710a 2020 2020 2020 2020  s as pq.        
-00000520: 696d 706f 7274 206d 6174 706c 6f74 6c69  import matplotli
-00000530: 622e 7079 706c 6f74 2061 7320 706c 740a  b.pyplot as plt.
-00000540: 0a20 2020 2020 2020 2073 6573 7369 6f6e  .        session
-00000550: 5f66 6f6c 6465 7220 3d20 272e 2e2f 4461  _folder = '../Da
-00000560: 7461 2f32 3031 342d 3037 2d32 345f 3130  ta/2014-07-24_10
-00000570: 2d33 312d 3032 270a 2020 2020 2020 2020  -31-02'.        
-00000580: 4e49 4f20 3d20 696f 2e4e 6575 7261 6c79  NIO = io.Neuraly
-00000590: 6e78 494f 2873 6573 7369 6f6e 5f66 6f6c  nxIO(session_fol
-000005a0: 6465 722c 7072 696e 745f 6469 6167 6e6f  der,print_diagno
-000005b0: 7374 6963 203d 2054 7275 6529 0a20 2020  stic = True).   
-000005c0: 2020 2020 2062 6c6f 636b 203d 204e 494f       block = NIO
-000005d0: 2e72 6561 645f 626c 6f63 6b28 745f 7374  .read_block(t_st
-000005e0: 6172 7473 203d 2030 2e31 2a70 712e 732c  arts = 0.1*pq.s,
-000005f0: 2074 5f73 746f 7073 203d 2030 2e32 2a70   t_stops = 0.2*p
-00000600: 712e 732c 0a20 2020 2020 2020 2065 7665  q.s,.        eve
-00000610: 6e74 733d 5472 7565 290a 2020 2020 2020  nts=True).      
-00000620: 2020 7365 6720 3d20 626c 6f63 6b2e 7365    seg = block.se
-00000630: 676d 656e 7473 5b30 5d0a 2020 2020 2020  gments[0].      
-00000640: 2020 616e 616c 6f67 7369 676e 616c 203d    analogsignal =
-00000650: 2073 6567 2e61 6e61 6c6f 6773 6967 6e61   seg.analogsigna
-00000660: 6c73 5b30 5d0a 2020 2020 2020 2020 706c  ls[0].        pl
-00000670: 742e 706c 6f74 2861 6e61 6c6f 6773 6967  t.plot(analogsig
-00000680: 6e61 6c2e 7469 6d65 732e 7265 7363 616c  nal.times.rescal
-00000690: 6528 7071 2e6d 7329 2c20 616e 616c 6f67  e(pq.ms), analog
-000006a0: 7369 676e 616c 2e6d 6167 6e69 7475 6465  signal.magnitude
-000006b0: 290a 2020 2020 2020 2020 706c 742e 7368  ).        plt.sh
-000006c0: 6f77 2829 0a0a 2020 2020 2222 220a 0a20  ow()..    """.. 
-000006d0: 2020 2069 735f 7265 6164 6162 6c65 203d     is_readable =
-000006e0: 2054 7275 6520 2023 2054 6869 7320 636c   True  # This cl
-000006f0: 6173 7320 6361 6e20 6f6e 6c79 2072 6561  ass can only rea
-00000700: 6420 6461 7461 0a20 2020 2069 735f 7772  d data.    is_wr
-00000710: 6974 6162 6c65 203d 2046 616c 7365 2020  itable = False  
-00000720: 2320 7772 6974 6520 6973 206e 6f74 2073  # write is not s
-00000730: 7570 706f 7274 6564 0a0a 2020 2020 2320  upported..    # 
-00000740: 5468 6973 2063 6c61 7373 2069 7320 6162  This class is ab
-00000750: 6c65 2074 6f20 6469 7265 6374 6c79 206f  le to directly o
-00000760: 7220 696e 6469 7265 6374 6c79 2068 616e  r indirectly han
-00000770: 646c 6520 7468 6520 666f 6c6c 6f77 696e  dle the followin
-00000780: 6720 6f62 6a65 6374 730a 2020 2020 2320  g objects.    # 
-00000790: 596f 7520 6361 6e20 6e6f 7469 6365 2074  You can notice t
-000007a0: 6861 7420 7468 6973 2067 7265 6174 6c79  hat this greatly
-000007b0: 2073 696d 706c 6966 6965 7320 7468 6520   simplifies the 
-000007c0: 6675 6c6c 204e 656f 206f 626a 6563 7420  full Neo object 
-000007d0: 6869 6572 6172 6368 790a 2020 2020 7375  hierarchy.    su
-000007e0: 7070 6f72 7465 645f 6f62 6a65 6374 7320  pported_objects 
-000007f0: 3d20 5b53 6567 6d65 6e74 2c20 416e 616c  = [Segment, Anal
-00000800: 6f67 5369 676e 616c 2c20 5370 696b 6554  ogSignal, SpikeT
-00000810: 7261 696e 2c20 4576 656e 745d 0a0a 2020  rain, Event]..  
-00000820: 2020 2320 5468 6973 2063 6c61 7373 2063    # This class c
-00000830: 616e 2072 6574 7572 6e20 6569 7468 6572  an return either
-00000840: 2061 2042 6c6f 636b 206f 7220 6120 5365   a Block or a Se
-00000850: 676d 656e 740a 2020 2020 2320 5468 6520  gment.    # The 
-00000860: 6669 7273 7420 6f6e 6520 6973 2074 6865  first one is the
-00000870: 2064 6566 6175 6c74 2028 2073 656c 662e   default ( self.
-00000880: 7265 6164 2029 0a20 2020 2023 2054 6865  read ).    # The
-00000890: 7365 206c 6973 7473 2073 686f 756c 6420  se lists should 
-000008a0: 676f 2066 726f 6d20 6869 6768 6573 7420  go from highest 
-000008b0: 6f62 6a65 6374 2074 6f20 6c6f 7765 7374  object to lowest
-000008c0: 206f 626a 6563 7420 6265 6361 7573 650a   object because.
-000008d0: 2020 2020 2320 636f 6d6d 6f6e 5f69 6f5f      # common_io_
-000008e0: 7465 7374 2061 7373 756d 6573 2069 742e  test assumes it.
-000008f0: 0a20 2020 2072 6561 6461 626c 655f 6f62  .    readable_ob
-00000900: 6a65 6374 7320 3d20 5b53 6567 6d65 6e74  jects = [Segment
-00000910: 2c20 416e 616c 6f67 5369 676e 616c 2c20  , AnalogSignal, 
-00000920: 5370 696b 6554 7261 696e 5d0a 2020 2020  SpikeTrain].    
-00000930: 2320 5468 6973 2063 6c61 7373 2069 7320  # This class is 
-00000940: 6e6f 7420 6162 6c65 2074 6f20 7772 6974  not able to writ
-00000950: 6520 6f62 6a65 6374 730a 2020 2020 7772  e objects.    wr
-00000960: 6974 6561 626c 655f 6f62 6a65 6374 7320  iteable_objects 
-00000970: 3d20 5b5d 0a0a 2020 2020 6861 735f 6865  = []..    has_he
-00000980: 6164 6572 203d 2046 616c 7365 0a20 2020  ader = False.   
-00000990: 2069 735f 7374 7265 616d 6561 626c 6520   is_streameable 
-000009a0: 3d20 4661 6c73 650a 0a20 2020 2023 2054  = False..    # T
-000009b0: 6869 7320 6973 2066 6f72 2047 5549 2073  his is for GUI s
-000009c0: 7475 6666 203a 2061 2064 6566 696e 6974  tuff : a definit
-000009d0: 696f 6e20 666f 7220 7061 7261 6d65 7465  ion for paramete
-000009e0: 7273 2077 6865 6e20 7265 6164 696e 672e  rs when reading.
-000009f0: 0a20 2020 2023 2054 6869 7320 6469 6374  .    # This dict
-00000a00: 2073 686f 756c 6420 6265 206b 6579 6564   should be keyed
-00000a10: 2062 7920 6f62 6a65 6374 2028 6042 6c6f   by object (`Blo
-00000a20: 636b 6029 2e20 4561 6368 2065 6e74 7279  ck`). Each entry
-00000a30: 2069 7320 6120 6c69 7374 0a20 2020 2023   is a list.    #
-00000a40: 206f 6620 7475 706c 652e 2054 6865 2066   of tuple. The f
-00000a50: 6972 7374 2065 6e74 7279 2069 6e20 6561  irst entry in ea
-00000a60: 6368 2074 7570 6c65 2069 7320 7468 6520  ch tuple is the 
-00000a70: 7061 7261 6d65 7465 7220 6e61 6d65 2e20  parameter name. 
-00000a80: 5468 650a 2020 2020 2320 7365 636f 6e64  The.    # second
-00000a90: 2065 6e74 7279 2069 7320 6120 6469 6374   entry is a dict
-00000aa0: 2077 6974 6820 6b65 7973 2027 7661 6c75   with keys 'valu
-00000ab0: 6527 2028 666f 7220 6465 6661 756c 7420  e' (for default 
-00000ac0: 7661 6c75 6529 2c0a 2020 2020 2320 616e  value),.    # an
-00000ad0: 6420 276c 6162 656c 2720 2866 6f72 2061  d 'label' (for a
-00000ae0: 2064 6573 6372 6970 7469 7665 206e 616d   descriptive nam
-00000af0: 6529 2e0a 2020 2020 2320 4e6f 7465 2074  e)..    # Note t
-00000b00: 6861 7420 6966 2074 6865 2068 6967 6865  hat if the highe
-00000b10: 7374 2d6c 6576 656c 206f 626a 6563 7420  st-level object 
-00000b20: 7265 7175 6972 6573 2070 6172 616d 6574  requires paramet
-00000b30: 6572 732c 0a20 2020 2023 2063 6f6d 6d6f  ers,.    # commo
-00000b40: 6e5f 696f 5f74 6573 7420 7769 6c6c 2062  n_io_test will b
-00000b50: 6520 736b 6970 7065 642e 0a20 2020 2072  e skipped..    r
-00000b60: 6561 645f 7061 7261 6d73 203d 207b 0a20  ead_params = {. 
-00000b70: 2020 2020 2020 2053 6567 6d65 6e74 3a20         Segment: 
-00000b80: 5b28 2777 6176 6566 6f72 6d73 272c 207b  [('waveforms', {
-00000b90: 2776 616c 7565 273a 2054 7275 657d 295d  'value': True})]
-00000ba0: 2c0a 2020 2020 2020 2020 426c 6f63 6b3a  ,.        Block:
-00000bb0: 205b 2827 7761 7665 666f 726d 7327 2c20   [('waveforms', 
-00000bc0: 7b27 7661 6c75 6527 3a20 4661 6c73 657d  {'value': False}
-00000bd0: 295d 0a20 2020 207d 0a0a 2020 2020 2320  )].    }..    # 
-00000be0: 646f 206e 6f74 2073 7570 706f 7274 6564  do not supported
-00000bf0: 2077 7269 7465 2073 6f20 6e6f 2047 5549   write so no GUI
-00000c00: 2073 7475 6666 0a20 2020 2077 7269 7465   stuff.    write
-00000c10: 5f70 6172 616d 7320 3d20 4e6f 6e65 0a0a  _params = None..
-00000c20: 2020 2020 6e61 6d65 203d 2027 4e65 7572      name = 'Neur
-00000c30: 616c 796e 7827 0a20 2020 2064 6573 6372  alynx'.    descr
-00000c40: 6970 7469 6f6e 203d 2027 5468 6973 2049  iption = 'This I
-00000c50: 4f20 7265 6164 7320 2e6e 7365 2f2e 6e63  O reads .nse/.nc
-00000c60: 732f 2e6e 6576 2066 696c 6573 206f 6620  s/.nev files of 
-00000c70: 7468 6520 4e65 7572 616c 796e 7820 2827  the Neuralynx ('
-00000c80: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-00000c90: 2020 2020 2027 4368 6565 7461 6829 2072       'Cheetah) r
-00000ca0: 6563 6f72 6469 6e67 7320 7379 7374 656d  ecordings system
-00000cb0: 2028 7465 7472 6f64 6573 292e 270a 0a20   (tetrodes).'.. 
-00000cc0: 2020 2065 7874 656e 7369 6f6e 7320 3d20     extensions = 
-00000cd0: 5b27 6e73 6527 2c20 276e 6373 272c 2027  ['nse', 'ncs', '
-00000ce0: 6e65 7627 2c20 276e 7474 275d 0a0a 2020  nev', 'ntt']..  
-00000cf0: 2020 2320 6d6f 6465 2063 616e 2062 6520    # mode can be 
-00000d00: 2766 696c 6527 206f 7220 2764 6972 2720  'file' or 'dir' 
-00000d10: 6f72 2027 6661 6b65 2720 6f72 2027 6461  or 'fake' or 'da
-00000d20: 7461 6261 7365 270a 2020 2020 2320 7468  tabase'.    # th
-00000d30: 6520 6d61 696e 2063 6173 6520 6973 2027  e main case is '
-00000d40: 6669 6c65 2720 6275 7420 736f 6d65 2072  file' but some r
-00000d50: 6561 6465 7220 6172 6520 6261 7365 206f  eader are base o
-00000d60: 6e20 6120 6469 7265 6374 6f72 7920 6f72  n a directory or
-00000d70: 0a20 2020 2023 2061 2064 6174 6162 6173  .    # a databas
-00000d80: 6520 7468 6973 2069 6e66 6f20 6973 2066  e this info is f
-00000d90: 6f72 2047 5549 2073 7475 6666 2061 6c73  or GUI stuff als
-00000da0: 6f0a 2020 2020 6d6f 6465 203d 2027 6469  o.    mode = 'di
-00000db0: 7227 0a0a 2020 2020 2320 6861 7264 636f  r'..    # hardco
-00000dc0: 6465 6420 7061 7261 6d65 7465 7273 2066  ded parameters f
-00000dd0: 726f 6d20 6d61 6e75 616c 2c20 7768 6963  rom manual, whic
-00000de0: 6820 6172 6520 6e6f 7420 7072 6573 656e  h are not presen
-00000df0: 7420 696e 204e 6575 7261 6c79 6e78 0a20  t in Neuralynx. 
-00000e00: 2020 2023 2064 6174 6120 6669 6c65 730a     # data files.
-00000e10: 2020 2020 2320 756e 6974 206f 6620 7469      # unit of ti
-00000e20: 6d65 7374 616d 7073 2069 6e20 6469 6666  mestamps in diff
-00000e30: 6572 656e 7420 6669 6c65 730a 2020 2020  erent files.    
-00000e40: 6e65 765f 7469 6d65 5f75 6e69 7420 3d20  nev_time_unit = 
-00000e50: 7071 2e6d 6963 726f 7365 636f 6e64 0a20  pq.microsecond. 
-00000e60: 2020 206e 6373 5f74 696d 655f 756e 6974     ncs_time_unit
-00000e70: 203d 2070 712e 6d69 6372 6f73 6563 6f6e   = pq.microsecon
-00000e80: 640a 2020 2020 6e73 655f 7469 6d65 5f75  d.    nse_time_u
-00000e90: 6e69 7420 3d20 7071 2e6d 6963 726f 7365  nit = pq.microse
-00000ea0: 636f 6e64 0a20 2020 206e 7474 5f74 696d  cond.    ntt_tim
-00000eb0: 655f 756e 6974 203d 2070 712e 6d69 6372  e_unit = pq.micr
-00000ec0: 6f73 6563 6f6e 640a 2020 2020 2320 756e  osecond.    # un
-00000ed0: 6974 206f 6620 7361 6d70 6c69 6e67 2072  it of sampling r
-00000ee0: 6174 6520 696e 2064 6966 6665 7265 6e74  ate in different
-00000ef0: 2066 696c 6573 0a20 2020 206e 6373 5f73   files.    ncs_s
-00000f00: 725f 756e 6974 203d 2070 712e 487a 0a20  r_unit = pq.Hz. 
-00000f10: 2020 206e 7365 5f73 725f 756e 6974 203d     nse_sr_unit =
-00000f20: 2070 712e 487a 0a20 2020 206e 7474 5f73   pq.Hz.    ntt_s
-00000f30: 725f 756e 6974 203d 2070 712e 487a 0a0a  r_unit = pq.Hz..
-00000f40: 2020 2020 6465 6620 5f5f 696e 6974 5f5f      def __init__
-00000f50: 2873 656c 662c 2073 6573 7369 6f6e 6469  (self, sessiondi
-00000f60: 723d 4e6f 6e65 2c20 6361 6368 6564 6972  r=None, cachedir
-00000f70: 3d4e 6f6e 652c 2075 7365 5f63 6163 6865  =None, use_cache
-00000f80: 3d27 6861 7368 272c 0a20 2020 2020 2020  ='hash',.       
-00000f90: 2020 2020 2020 2020 2020 7072 696e 745f            print_
-00000fa0: 6469 6167 6e6f 7374 6963 3d46 616c 7365  diagnostic=False
-00000fb0: 2c20 6669 6c65 6e61 6d65 3d4e 6f6e 6529  , filename=None)
-00000fc0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-00000fd0: 2020 2020 2020 4172 6775 6d65 6e74 733a        Arguments:
-00000fe0: 0a20 2020 2020 2020 2020 2020 2073 6573  .            ses
-00000ff0: 7369 6f6e 6469 723a 2074 6865 2064 6972  siondir: the dir
-00001000: 6563 746f 7279 2074 6865 2066 696c 6573  ectory the files
-00001010: 206f 6620 7468 6520 7265 636f 7264 696e   of the recordin
-00001020: 6720 7365 7373 696f 6e20 6172 650a 2020  g session are.  
-00001030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001040: 2020 2020 2020 2020 2020 636f 6c6c 6563            collec
-00001050: 7465 642e 2044 6566 6175 6c74 2027 4e6f  ted. Default 'No
-00001060: 6e65 272e 0a20 2020 2020 2020 2020 2020  ne'..           
-00001070: 2070 7269 6e74 5f64 6961 676e 6f73 7469   print_diagnosti
-00001080: 633a 2069 6e64 6963 6174 6573 2c20 7768  c: indicates, wh
-00001090: 6574 6865 7220 696e 666f 726d 6174 696f  ether informatio
-000010a0: 6e20 6162 6f75 7420 7468 650a 2020 2020  n about the.    
-000010b0: 2020 2020 2020 2020 6c6f 6164 696e 6720          loading 
-000010c0: 6f66 0a20 2020 2020 2020 2020 2020 2020  of.             
-000010d0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000010e0: 6174 6120 6973 2070 7269 6e74 6564 2069  ata is printed i
-000010f0: 6e20 7465 726d 696e 616c 206f 7220 6e6f  n terminal or no
-00001100: 742e 2044 6566 6175 6c74 2027 4661 6c73  t. Default 'Fals
-00001110: 6527 2e0a 2020 2020 2020 2020 2020 2020  e'..            
-00001120: 6361 6368 6564 6972 3a20 7468 6520 6469  cachedir: the di
-00001130: 7265 6374 6f72 7920 7768 6572 6520 6d65  rectory where me
-00001140: 7461 6461 7461 2061 626f 7574 2074 6865  tadata about the
-00001150: 2072 6563 6f72 6469 6e67 0a20 2020 2020   recording.     
-00001160: 2020 2020 2020 2073 6573 7369 6f6e 2069         session i
-00001170: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
-00001180: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00001190: 6164 2066 726f 6d20 616e 6420 7772 6974  ad from and writ
-000011a0: 7465 6e20 746f 2e0a 2020 2020 2020 2020  ten to..        
-000011b0: 2020 2020 7573 655f 6361 6368 653a 206d      use_cache: m
-000011c0: 6574 686f 6420 7573 6564 2066 6f72 2063  ethod used for c
-000011d0: 6163 6865 2069 6465 6e74 6966 6963 6174  ache identificat
-000011e0: 696f 6e2e 2050 6f73 7369 626c 6520 7661  ion. Possible va
-000011f0: 6c75 6573 3a0a 2020 2020 2020 2020 2020  lues:.          
-00001200: 2020 2768 6173 6827 2f0a 2020 2020 2020    'hash'/.      
-00001210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001220: 2020 2020 2020 2761 6c77 6179 7327 2f27        'always'/'
-00001230: 6461 7465 7369 7a65 272f 276e 6576 6572  datesize'/'never
-00001240: 272e 2044 6566 6175 6c74 2027 6861 7368  '. Default 'hash
-00001250: 270a 2020 2020 2020 2020 2020 2020 6669  '.            fi
-00001260: 6c65 6e61 6d65 3a20 7468 6973 2061 7267  lename: this arg
-00001270: 756d 656e 7420 6973 2068 616e 646c 6573  ument is handles
-00001280: 2074 6865 2073 616d 6520 6173 2073 6573   the same as ses
-00001290: 7369 6f6e 6469 7220 616e 6420 6973 0a20  siondir and is. 
-000012a0: 2020 2020 2020 2020 2020 206f 6e6c 790a             only.
+00000000: 2222 220a 436c 6173 7320 666f 7220 7265  """.Class for re
+00000010: 6164 696e 6720 6461 7461 2066 726f 6d20  ading data from 
+00000020: 4e65 7572 616c 796e 7820 6669 6c65 732e  Neuralynx files.
+00000030: 0a54 6869 7320 494f 2073 7570 706f 7274  .This IO support
+00000040: 7320 4e43 532c 204e 4556 2061 6e64 204e  s NCS, NEV and N
+00000050: 5345 2066 696c 6520 666f 726d 6174 732e  SE file formats.
+00000060: 0a0a 5468 6973 206d 6f64 756c 6520 6973  ..This module is
+00000070: 2061 6e20 6f6c 6465 7220 696d 706c 656d   an older implem
+00000080: 656e 7461 7469 6f6e 2020 7769 7468 206f  entation  with o
+00000090: 6c64 206e 656f 2e69 6f20 4150 492e 0a41  ld neo.io API..A
+000000a0: 206e 6577 2063 6c61 7373 204e 6575 7261   new class Neura
+000000b0: 6c79 6e78 494f 2063 6f6d 7075 6e64 6564  lynxIO compunded
+000000c0: 2062 7920 4e65 7572 616c 796e 7852 6177   by NeuralynxRaw
+000000d0: 494f 2061 6e64 2042 6173 6546 726f 6d49  IO and BaseFromI
+000000e0: 4f0a 7375 7065 7273 6565 6420 7468 6973  O.superseed this
+000000f0: 206f 6e65 2e0a 0a44 6570 656e 6473 206f   one...Depends o
+00000100: 6e3a 206e 756d 7079 0a0a 5375 7070 6f72  n: numpy..Suppor
+00000110: 7465 643a 2052 6561 640a 0a41 7574 686f  ted: Read..Autho
+00000120: 723a 204a 756c 6961 2053 7072 656e 6765  r: Julia Sprenge
+00000130: 722c 2043 6172 6c6f 7320 4361 6e6f 7661  r, Carlos Canova
+00000140: 0a41 6461 7074 6564 2066 726f 6d20 7468  .Adapted from th
+00000150: 6520 6578 616d 706c 6549 4f20 6f66 2070  e exampleIO of p
+00000160: 7974 686f 6e2d 6e65 6f0a 2222 220a 0a69  ython-neo."""..i
+00000170: 6d70 6f72 7420 7379 730a 696d 706f 7274  mport sys.import
+00000180: 206f 730a 696d 706f 7274 2077 6172 6e69   os.import warni
+00000190: 6e67 730a 696d 706f 7274 2063 6f64 6563  ngs.import codec
+000001a0: 730a 696d 706f 7274 2063 6f70 790a 696d  s.import copy.im
+000001b0: 706f 7274 2072 650a 696d 706f 7274 2064  port re.import d
+000001c0: 6174 6574 696d 650a 696d 706f 7274 2070  atetime.import p
+000001d0: 6b67 5f72 6573 6f75 7263 6573 0a0a 696d  kg_resources..im
+000001e0: 706f 7274 206e 756d 7079 2061 7320 6e70  port numpy as np
+000001f0: 0a0a 696d 706f 7274 2071 7561 6e74 6974  ..import quantit
+00000200: 6965 7320 6173 2070 710a 0a66 726f 6d20  ies as pq..from 
+00000210: 6e65 6f2e 696f 2e62 6173 6569 6f20 696d  neo.io.baseio im
+00000220: 706f 7274 2042 6173 6549 4f0a 696d 706f  port BaseIO.impo
+00000230: 7274 206e 656f 2e69 6f2e 6e65 7572 616c  rt neo.io.neural
+00000240: 796e 7869 6f0a 6672 6f6d 206e 656f 2e63  ynxio.from neo.c
+00000250: 6f72 6520 696d 706f 7274 2028 426c 6f63  ore import (Bloc
+00000260: 6b2c 2053 6567 6d65 6e74 2c20 4368 616e  k, Segment, Chan
+00000270: 6e65 6c49 6e64 6578 2c20 416e 616c 6f67  nelIndex, Analog
+00000280: 5369 676e 616c 2c20 5370 696b 6554 7261  Signal, SpikeTra
+00000290: 696e 2c0a 2020 2020 2020 2020 2020 2020  in,.            
+000002a0: 2020 2020 2020 2020 2020 4576 656e 742c            Event,
+000002b0: 2055 6e69 7429 0a66 726f 6d20 6f73 2069   Unit).from os i
+000002c0: 6d70 6f72 7420 6c69 7374 6469 722c 2073  mport listdir, s
+000002d0: 6570 0a66 726f 6d20 6f73 2e70 6174 6820  ep.from os.path 
+000002e0: 696d 706f 7274 2069 7366 696c 652c 2067  import isfile, g
+000002f0: 6574 7369 7a65 0a0a 696d 706f 7274 2068  etsize..import h
+00000300: 6173 686c 6962 0a69 6d70 6f72 7420 7069  ashlib.import pi
+00000310: 636b 6c65 0a0a 6966 2068 6173 6174 7472  ckle..if hasattr
+00000320: 2870 6b67 5f72 6573 6f75 7263 6573 2c20  (pkg_resources, 
+00000330: 2770 6b67 5f72 6573 6f75 7263 6573 2729  'pkg_resources')
+00000340: 3a0a 2020 2020 7061 7273 655f 7665 7273  :.    parse_vers
+00000350: 696f 6e20 3d20 706b 675f 7265 736f 7572  ion = pkg_resour
+00000360: 6365 732e 706b 675f 7265 736f 7572 6365  ces.pkg_resource
+00000370: 732e 7061 7273 655f 7665 7273 696f 6e0a  s.parse_version.
+00000380: 656c 7365 3a0a 2020 2020 7061 7273 655f  else:.    parse_
+00000390: 7665 7273 696f 6e20 3d20 706b 675f 7265  version = pkg_re
+000003a0: 736f 7572 6365 732e 7061 7273 655f 7665  sources.parse_ve
+000003b0: 7273 696f 6e0a 0a0a 636c 6173 7320 4e65  rsion...class Ne
+000003c0: 7572 616c 796e 7849 4f28 4261 7365 494f  uralynxIO(BaseIO
+000003d0: 293a 0a20 2020 2022 2222 0a20 2020 2043  ):.    """.    C
+000003e0: 6c61 7373 2066 6f72 2072 6561 6469 6e67  lass for reading
+000003f0: 204e 6575 7261 6c79 6e78 2066 696c 6573   Neuralynx files
+00000400: 2e0a 0a20 2020 2049 7420 656e 6162 6c65  ...    It enable
+00000410: 7320 7265 6164 696e 673a 0a20 2020 202d  s reading:.    -
+00000420: 203a 636c 6173 733a 2742 6c6f 636b 270a   :class:'Block'.
+00000430: 2020 2020 2d20 3a63 6c61 7373 3a27 5365      - :class:'Se
+00000440: 676d 656e 7427 0a20 2020 202d 203a 636c  gment'.    - :cl
+00000450: 6173 733a 2741 6e61 6c6f 6753 6967 6e61  ass:'AnalogSigna
+00000460: 6c27 0a20 2020 202d 203a 636c 6173 733a  l'.    - :class:
+00000470: 2753 7069 6b65 5472 6169 6e27 0a0a 2020  'SpikeTrain'..  
+00000480: 2020 5573 6167 653a 0a20 2020 2020 2020    Usage:.       
+00000490: 2066 726f 6d20 6e65 6f20 696d 706f 7274   from neo import
+000004a0: 2069 6f0a 2020 2020 2020 2020 696d 706f   io.        impo
+000004b0: 7274 2071 7561 6e74 6974 6965 7320 6173  rt quantities as
+000004c0: 2070 710a 2020 2020 2020 2020 696d 706f   pq.        impo
+000004d0: 7274 206d 6174 706c 6f74 6c69 622e 7079  rt matplotlib.py
+000004e0: 706c 6f74 2061 7320 706c 740a 0a20 2020  plot as plt..   
+000004f0: 2020 2020 2073 6573 7369 6f6e 5f66 6f6c       session_fol
+00000500: 6465 7220 3d20 272e 2e2f 4461 7461 2f32  der = '../Data/2
+00000510: 3031 342d 3037 2d32 345f 3130 2d33 312d  014-07-24_10-31-
+00000520: 3032 270a 2020 2020 2020 2020 4e49 4f20  02'.        NIO 
+00000530: 3d20 696f 2e4e 6575 7261 6c79 6e78 494f  = io.NeuralynxIO
+00000540: 2873 6573 7369 6f6e 5f66 6f6c 6465 722c  (session_folder,
+00000550: 7072 696e 745f 6469 6167 6e6f 7374 6963  print_diagnostic
+00000560: 203d 2054 7275 6529 0a20 2020 2020 2020   = True).       
+00000570: 2062 6c6f 636b 203d 204e 494f 2e72 6561   block = NIO.rea
+00000580: 645f 626c 6f63 6b28 745f 7374 6172 7473  d_block(t_starts
+00000590: 203d 2030 2e31 2a70 712e 732c 2074 5f73   = 0.1*pq.s, t_s
+000005a0: 746f 7073 203d 2030 2e32 2a70 712e 732c  tops = 0.2*pq.s,
+000005b0: 0a20 2020 2020 2020 2065 7665 6e74 733d  .        events=
+000005c0: 5472 7565 290a 2020 2020 2020 2020 7365  True).        se
+000005d0: 6720 3d20 626c 6f63 6b2e 7365 676d 656e  g = block.segmen
+000005e0: 7473 5b30 5d0a 2020 2020 2020 2020 616e  ts[0].        an
+000005f0: 616c 6f67 7369 676e 616c 203d 2073 6567  alogsignal = seg
+00000600: 2e61 6e61 6c6f 6773 6967 6e61 6c73 5b30  .analogsignals[0
+00000610: 5d0a 2020 2020 2020 2020 706c 742e 706c  ].        plt.pl
+00000620: 6f74 2861 6e61 6c6f 6773 6967 6e61 6c2e  ot(analogsignal.
+00000630: 7469 6d65 732e 7265 7363 616c 6528 7071  times.rescale(pq
+00000640: 2e6d 7329 2c20 616e 616c 6f67 7369 676e  .ms), analogsign
+00000650: 616c 2e6d 6167 6e69 7475 6465 290a 2020  al.magnitude).  
+00000660: 2020 2020 2020 706c 742e 7368 6f77 2829        plt.show()
+00000670: 0a0a 2020 2020 2222 220a 0a20 2020 2069  ..    """..    i
+00000680: 735f 7265 6164 6162 6c65 203d 2054 7275  s_readable = Tru
+00000690: 6520 2023 2054 6869 7320 636c 6173 7320  e  # This class 
+000006a0: 6361 6e20 6f6e 6c79 2072 6561 6420 6461  can only read da
+000006b0: 7461 0a20 2020 2069 735f 7772 6974 6162  ta.    is_writab
+000006c0: 6c65 203d 2046 616c 7365 2020 2320 7772  le = False  # wr
+000006d0: 6974 6520 6973 206e 6f74 2073 7570 706f  ite is not suppo
+000006e0: 7274 6564 0a0a 2020 2020 2320 5468 6973  rted..    # This
+000006f0: 2063 6c61 7373 2069 7320 6162 6c65 2074   class is able t
+00000700: 6f20 6469 7265 6374 6c79 206f 7220 696e  o directly or in
+00000710: 6469 7265 6374 6c79 2068 616e 646c 6520  directly handle 
+00000720: 7468 6520 666f 6c6c 6f77 696e 6720 6f62  the following ob
+00000730: 6a65 6374 730a 2020 2020 2320 596f 7520  jects.    # You 
+00000740: 6361 6e20 6e6f 7469 6365 2074 6861 7420  can notice that 
+00000750: 7468 6973 2067 7265 6174 6c79 2073 696d  this greatly sim
+00000760: 706c 6966 6965 7320 7468 6520 6675 6c6c  plifies the full
+00000770: 204e 656f 206f 626a 6563 7420 6869 6572   Neo object hier
+00000780: 6172 6368 790a 2020 2020 7375 7070 6f72  archy.    suppor
+00000790: 7465 645f 6f62 6a65 6374 7320 3d20 5b53  ted_objects = [S
+000007a0: 6567 6d65 6e74 2c20 416e 616c 6f67 5369  egment, AnalogSi
+000007b0: 676e 616c 2c20 5370 696b 6554 7261 696e  gnal, SpikeTrain
+000007c0: 2c20 4576 656e 745d 0a0a 2020 2020 2320  , Event]..    # 
+000007d0: 5468 6973 2063 6c61 7373 2063 616e 2072  This class can r
+000007e0: 6574 7572 6e20 6569 7468 6572 2061 2042  eturn either a B
+000007f0: 6c6f 636b 206f 7220 6120 5365 676d 656e  lock or a Segmen
+00000800: 740a 2020 2020 2320 5468 6520 6669 7273  t.    # The firs
+00000810: 7420 6f6e 6520 6973 2074 6865 2064 6566  t one is the def
+00000820: 6175 6c74 2028 2073 656c 662e 7265 6164  ault ( self.read
+00000830: 2029 0a20 2020 2023 2054 6865 7365 206c   ).    # These l
+00000840: 6973 7473 2073 686f 756c 6420 676f 2066  ists should go f
+00000850: 726f 6d20 6869 6768 6573 7420 6f62 6a65  rom highest obje
+00000860: 6374 2074 6f20 6c6f 7765 7374 206f 626a  ct to lowest obj
+00000870: 6563 7420 6265 6361 7573 650a 2020 2020  ect because.    
+00000880: 2320 636f 6d6d 6f6e 5f69 6f5f 7465 7374  # common_io_test
+00000890: 2061 7373 756d 6573 2069 742e 0a20 2020   assumes it..   
+000008a0: 2072 6561 6461 626c 655f 6f62 6a65 6374   readable_object
+000008b0: 7320 3d20 5b53 6567 6d65 6e74 2c20 416e  s = [Segment, An
+000008c0: 616c 6f67 5369 676e 616c 2c20 5370 696b  alogSignal, Spik
+000008d0: 6554 7261 696e 5d0a 2020 2020 2320 5468  eTrain].    # Th
+000008e0: 6973 2063 6c61 7373 2069 7320 6e6f 7420  is class is not 
+000008f0: 6162 6c65 2074 6f20 7772 6974 6520 6f62  able to write ob
+00000900: 6a65 6374 730a 2020 2020 7772 6974 6561  jects.    writea
+00000910: 626c 655f 6f62 6a65 6374 7320 3d20 5b5d  ble_objects = []
+00000920: 0a0a 2020 2020 6861 735f 6865 6164 6572  ..    has_header
+00000930: 203d 2046 616c 7365 0a20 2020 2069 735f   = False.    is_
+00000940: 7374 7265 616d 6561 626c 6520 3d20 4661  streameable = Fa
+00000950: 6c73 650a 0a20 2020 2023 2054 6869 7320  lse..    # This 
+00000960: 6973 2066 6f72 2047 5549 2073 7475 6666  is for GUI stuff
+00000970: 203a 2061 2064 6566 696e 6974 696f 6e20   : a definition 
+00000980: 666f 7220 7061 7261 6d65 7465 7273 2077  for parameters w
+00000990: 6865 6e20 7265 6164 696e 672e 0a20 2020  hen reading..   
+000009a0: 2023 2054 6869 7320 6469 6374 2073 686f   # This dict sho
+000009b0: 756c 6420 6265 206b 6579 6564 2062 7920  uld be keyed by 
+000009c0: 6f62 6a65 6374 2028 6042 6c6f 636b 6029  object (`Block`)
+000009d0: 2e20 4561 6368 2065 6e74 7279 2069 7320  . Each entry is 
+000009e0: 6120 6c69 7374 0a20 2020 2023 206f 6620  a list.    # of 
+000009f0: 7475 706c 652e 2054 6865 2066 6972 7374  tuple. The first
+00000a00: 2065 6e74 7279 2069 6e20 6561 6368 2074   entry in each t
+00000a10: 7570 6c65 2069 7320 7468 6520 7061 7261  uple is the para
+00000a20: 6d65 7465 7220 6e61 6d65 2e20 5468 650a  meter name. The.
+00000a30: 2020 2020 2320 7365 636f 6e64 2065 6e74      # second ent
+00000a40: 7279 2069 7320 6120 6469 6374 2077 6974  ry is a dict wit
+00000a50: 6820 6b65 7973 2027 7661 6c75 6527 2028  h keys 'value' (
+00000a60: 666f 7220 6465 6661 756c 7420 7661 6c75  for default valu
+00000a70: 6529 2c0a 2020 2020 2320 616e 6420 276c  e),.    # and 'l
+00000a80: 6162 656c 2720 2866 6f72 2061 2064 6573  abel' (for a des
+00000a90: 6372 6970 7469 7665 206e 616d 6529 2e0a  criptive name)..
+00000aa0: 2020 2020 2320 4e6f 7465 2074 6861 7420      # Note that 
+00000ab0: 6966 2074 6865 2068 6967 6865 7374 2d6c  if the highest-l
+00000ac0: 6576 656c 206f 626a 6563 7420 7265 7175  evel object requ
+00000ad0: 6972 6573 2070 6172 616d 6574 6572 732c  ires parameters,
+00000ae0: 0a20 2020 2023 2063 6f6d 6d6f 6e5f 696f  .    # common_io
+00000af0: 5f74 6573 7420 7769 6c6c 2062 6520 736b  _test will be sk
+00000b00: 6970 7065 642e 0a20 2020 2072 6561 645f  ipped..    read_
+00000b10: 7061 7261 6d73 203d 207b 0a20 2020 2020  params = {.     
+00000b20: 2020 2053 6567 6d65 6e74 3a20 5b28 2777     Segment: [('w
+00000b30: 6176 6566 6f72 6d73 272c 207b 2776 616c  aveforms', {'val
+00000b40: 7565 273a 2054 7275 657d 295d 2c0a 2020  ue': True})],.  
+00000b50: 2020 2020 2020 426c 6f63 6b3a 205b 2827        Block: [('
+00000b60: 7761 7665 666f 726d 7327 2c20 7b27 7661  waveforms', {'va
+00000b70: 6c75 6527 3a20 4661 6c73 657d 295d 0a20  lue': False})]. 
+00000b80: 2020 207d 0a0a 2020 2020 2320 646f 206e     }..    # do n
+00000b90: 6f74 2073 7570 706f 7274 6564 2077 7269  ot supported wri
+00000ba0: 7465 2073 6f20 6e6f 2047 5549 2073 7475  te so no GUI stu
+00000bb0: 6666 0a20 2020 2077 7269 7465 5f70 6172  ff.    write_par
+00000bc0: 616d 7320 3d20 4e6f 6e65 0a0a 2020 2020  ams = None..    
+00000bd0: 6e61 6d65 203d 2027 4e65 7572 616c 796e  name = 'Neuralyn
+00000be0: 7827 0a20 2020 2064 6573 6372 6970 7469  x'.    descripti
+00000bf0: 6f6e 203d 2027 5468 6973 2049 4f20 7265  on = 'This IO re
+00000c00: 6164 7320 2e6e 7365 2f2e 6e63 732f 2e6e  ads .nse/.ncs/.n
+00000c10: 6576 2066 696c 6573 206f 6620 7468 6520  ev files of the 
+00000c20: 4e65 7572 616c 796e 7820 2827 205c 0a20  Neuralynx (' \. 
+00000c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000c40: 2027 4368 6565 7461 6829 2072 6563 6f72   'Cheetah) recor
+00000c50: 6469 6e67 7320 7379 7374 656d 2028 7465  dings system (te
+00000c60: 7472 6f64 6573 292e 270a 0a20 2020 2065  trodes).'..    e
+00000c70: 7874 656e 7369 6f6e 7320 3d20 5b27 6e73  xtensions = ['ns
+00000c80: 6527 2c20 276e 6373 272c 2027 6e65 7627  e', 'ncs', 'nev'
+00000c90: 2c20 276e 7474 275d 0a0a 2020 2020 2320  , 'ntt']..    # 
+00000ca0: 6d6f 6465 2063 616e 2062 6520 2766 696c  mode can be 'fil
+00000cb0: 6527 206f 7220 2764 6972 2720 6f72 2027  e' or 'dir' or '
+00000cc0: 6661 6b65 2720 6f72 2027 6461 7461 6261  fake' or 'databa
+00000cd0: 7365 270a 2020 2020 2320 7468 6520 6d61  se'.    # the ma
+00000ce0: 696e 2063 6173 6520 6973 2027 6669 6c65  in case is 'file
+00000cf0: 2720 6275 7420 736f 6d65 2072 6561 6465  ' but some reade
+00000d00: 7220 6172 6520 6261 7365 206f 6e20 6120  r are base on a 
+00000d10: 6469 7265 6374 6f72 7920 6f72 0a20 2020  directory or.   
+00000d20: 2023 2061 2064 6174 6162 6173 6520 7468   # a database th
+00000d30: 6973 2069 6e66 6f20 6973 2066 6f72 2047  is info is for G
+00000d40: 5549 2073 7475 6666 2061 6c73 6f0a 2020  UI stuff also.  
+00000d50: 2020 6d6f 6465 203d 2027 6469 7227 0a0a    mode = 'dir'..
+00000d60: 2020 2020 2320 6861 7264 636f 6465 6420      # hardcoded 
+00000d70: 7061 7261 6d65 7465 7273 2066 726f 6d20  parameters from 
+00000d80: 6d61 6e75 616c 2c20 7768 6963 6820 6172  manual, which ar
+00000d90: 6520 6e6f 7420 7072 6573 656e 7420 696e  e not present in
+00000da0: 204e 6575 7261 6c79 6e78 0a20 2020 2023   Neuralynx.    #
+00000db0: 2064 6174 6120 6669 6c65 730a 2020 2020   data files.    
+00000dc0: 2320 756e 6974 206f 6620 7469 6d65 7374  # unit of timest
+00000dd0: 616d 7073 2069 6e20 6469 6666 6572 656e  amps in differen
+00000de0: 7420 6669 6c65 730a 2020 2020 6e65 765f  t files.    nev_
+00000df0: 7469 6d65 5f75 6e69 7420 3d20 7071 2e6d  time_unit = pq.m
+00000e00: 6963 726f 7365 636f 6e64 0a20 2020 206e  icrosecond.    n
+00000e10: 6373 5f74 696d 655f 756e 6974 203d 2070  cs_time_unit = p
+00000e20: 712e 6d69 6372 6f73 6563 6f6e 640a 2020  q.microsecond.  
+00000e30: 2020 6e73 655f 7469 6d65 5f75 6e69 7420    nse_time_unit 
+00000e40: 3d20 7071 2e6d 6963 726f 7365 636f 6e64  = pq.microsecond
+00000e50: 0a20 2020 206e 7474 5f74 696d 655f 756e  .    ntt_time_un
+00000e60: 6974 203d 2070 712e 6d69 6372 6f73 6563  it = pq.microsec
+00000e70: 6f6e 640a 2020 2020 2320 756e 6974 206f  ond.    # unit o
+00000e80: 6620 7361 6d70 6c69 6e67 2072 6174 6520  f sampling rate 
+00000e90: 696e 2064 6966 6665 7265 6e74 2066 696c  in different fil
+00000ea0: 6573 0a20 2020 206e 6373 5f73 725f 756e  es.    ncs_sr_un
+00000eb0: 6974 203d 2070 712e 487a 0a20 2020 206e  it = pq.Hz.    n
+00000ec0: 7365 5f73 725f 756e 6974 203d 2070 712e  se_sr_unit = pq.
+00000ed0: 487a 0a20 2020 206e 7474 5f73 725f 756e  Hz.    ntt_sr_un
+00000ee0: 6974 203d 2070 712e 487a 0a0a 2020 2020  it = pq.Hz..    
+00000ef0: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+00000f00: 662c 2073 6573 7369 6f6e 6469 723d 4e6f  f, sessiondir=No
+00000f10: 6e65 2c20 6361 6368 6564 6972 3d4e 6f6e  ne, cachedir=Non
+00000f20: 652c 2075 7365 5f63 6163 6865 3d27 6861  e, use_cache='ha
+00000f30: 7368 272c 0a20 2020 2020 2020 2020 2020  sh',.           
+00000f40: 2020 2020 2020 7072 696e 745f 6469 6167        print_diag
+00000f50: 6e6f 7374 6963 3d46 616c 7365 2c20 6669  nostic=False, fi
+00000f60: 6c65 6e61 6d65 3d4e 6f6e 6529 3a0a 2020  lename=None):.  
+00000f70: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00000f80: 2020 4172 6775 6d65 6e74 733a 0a20 2020    Arguments:.   
+00000f90: 2020 2020 2020 2020 2073 6573 7369 6f6e           session
+00000fa0: 6469 723a 2074 6865 2064 6972 6563 746f  dir: the directo
+00000fb0: 7279 2074 6865 2066 696c 6573 206f 6620  ry the files of 
+00000fc0: 7468 6520 7265 636f 7264 696e 6720 7365  the recording se
+00000fd0: 7373 696f 6e20 6172 650a 2020 2020 2020  ssion are.      
+00000fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000ff0: 2020 2020 2020 636f 6c6c 6563 7465 642e        collected.
+00001000: 2044 6566 6175 6c74 2027 4e6f 6e65 272e   Default 'None'.
+00001010: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
+00001020: 6e74 5f64 6961 676e 6f73 7469 633a 2069  nt_diagnostic: i
+00001030: 6e64 6963 6174 6573 2c20 7768 6574 6865  ndicates, whethe
+00001040: 7220 696e 666f 726d 6174 696f 6e20 6162  r information ab
+00001050: 6f75 7420 7468 650a 2020 2020 2020 2020  out the.        
+00001060: 2020 2020 6c6f 6164 696e 6720 6f66 0a20      loading of. 
+00001070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001080: 2020 2020 2020 2020 2020 2064 6174 6120             data 
+00001090: 6973 2070 7269 6e74 6564 2069 6e20 7465  is printed in te
+000010a0: 726d 696e 616c 206f 7220 6e6f 742e 2044  rminal or not. D
+000010b0: 6566 6175 6c74 2027 4661 6c73 6527 2e0a  efault 'False'..
+000010c0: 2020 2020 2020 2020 2020 2020 6361 6368              cach
+000010d0: 6564 6972 3a20 7468 6520 6469 7265 6374  edir: the direct
+000010e0: 6f72 7920 7768 6572 6520 6d65 7461 6461  ory where metada
+000010f0: 7461 2061 626f 7574 2074 6865 2072 6563  ta about the rec
+00001100: 6f72 6469 6e67 0a20 2020 2020 2020 2020  ording.         
+00001110: 2020 2073 6573 7369 6f6e 2069 730a 2020     session is.  
+00001120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001130: 2020 2020 2020 2020 2020 7265 6164 2066            read f
+00001140: 726f 6d20 616e 6420 7772 6974 7465 6e20  rom and written 
+00001150: 746f 2e0a 2020 2020 2020 2020 2020 2020  to..            
+00001160: 7573 655f 6361 6368 653a 206d 6574 686f  use_cache: metho
+00001170: 6420 7573 6564 2066 6f72 2063 6163 6865  d used for cache
+00001180: 2069 6465 6e74 6966 6963 6174 696f 6e2e   identification.
+00001190: 2050 6f73 7369 626c 6520 7661 6c75 6573   Possible values
+000011a0: 3a0a 2020 2020 2020 2020 2020 2020 2768  :.            'h
+000011b0: 6173 6827 2f0a 2020 2020 2020 2020 2020  ash'/.          
+000011c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000011d0: 2020 2761 6c77 6179 7327 2f27 6461 7465    'always'/'date
+000011e0: 7369 7a65 272f 276e 6576 6572 272e 2044  size'/'never'. D
+000011f0: 6566 6175 6c74 2027 6861 7368 270a 2020  efault 'hash'.  
+00001200: 2020 2020 2020 2020 2020 6669 6c65 6e61            filena
+00001210: 6d65 3a20 7468 6973 2061 7267 756d 656e  me: this argumen
+00001220: 7420 6973 2068 616e 646c 6573 2074 6865  t is handles the
+00001230: 2073 616d 6520 6173 2073 6573 7369 6f6e   same as session
+00001240: 6469 7220 616e 6420 6973 0a20 2020 2020  dir and is.     
+00001250: 2020 2020 2020 206f 6e6c 790a 2020 2020         only.    
+00001260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001270: 2020 2020 2020 2020 6164 6465 6420 666f          added fo
+00001280: 7220 6578 7465 726e 616c 2049 4f20 696e  r external IO in
+00001290: 7465 7266 6163 6573 2e20 5468 6520 7661  terfaces. The va
+000012a0: 6c75 6520 6f66 0a20 2020 2020 2020 2020  lue of.         
 000012b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000012c0: 2020 2020 2020 2020 2020 2020 6164 6465              adde
-000012d0: 6420 666f 7220 6578 7465 726e 616c 2049  d for external I
-000012e0: 4f20 696e 7465 7266 6163 6573 2e20 5468  O interfaces. Th
-000012f0: 6520 7661 6c75 6520 6f66 0a20 2020 2020  e value of.     
-00001300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001310: 2020 2020 2020 2073 6573 7369 6f6e 6469         sessiondi
-00001320: 720a 2020 2020 2020 2020 2020 2020 2020  r.              
-00001330: 2020 2020 2020 2020 2020 2020 2020 6861                ha
-00001340: 7320 7072 696f 7269 7479 206f 7665 7220  s priority over 
-00001350: 6669 6c65 6e61 6d65 2e0a 2020 2020 2020  filename..      
-00001360: 2020 2222 220a 0a20 2020 2020 2020 2042    """..        B
-00001370: 6173 6549 4f2e 5f5f 696e 6974 5f5f 2873  aseIO.__init__(s
-00001380: 656c 6629 0a0a 2020 2020 2020 2020 2320  elf)..        # 
-00001390: 706f 7373 6962 6c69 7479 2074 6f20 7072  possiblity to pr
-000013a0: 6f76 6964 6520 6669 6c65 6e61 6d65 2069  ovide filename i
-000013b0: 6e73 7465 6164 206f 6620 7365 7373 696f  nstead of sessio
-000013c0: 6e64 6972 2066 6f72 2049 4f0a 2020 2020  ndir for IO.    
-000013d0: 2020 2020 2320 636f 6d70 6174 6962 696c      # compatibil
-000013e0: 6974 790a 2020 2020 2020 2020 6966 2066  ity.        if f
-000013f0: 696c 656e 616d 6520 6973 206e 6f74 204e  ilename is not N
-00001400: 6f6e 6520 616e 6420 7365 7373 696f 6e64  one and sessiond
-00001410: 6972 2069 7320 4e6f 6e65 3a0a 2020 2020  ir is None:.    
-00001420: 2020 2020 2020 2020 7365 7373 696f 6e64          sessiond
-00001430: 6972 203d 2066 696c 656e 616d 650a 0a20  ir = filename.. 
-00001440: 2020 2020 2020 2069 6620 7365 7373 696f         if sessio
-00001450: 6e64 6972 2069 7320 4e6f 6e65 3a0a 2020  ndir is None:.  
-00001460: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00001470: 5661 6c75 6545 7272 6f72 2827 4d75 7374  ValueError('Must
-00001480: 2070 726f 7669 6465 2061 2064 6972 6563   provide a direc
-00001490: 746f 7279 2063 6f6e 7461 696e 696e 6720  tory containing 
-000014a0: 6461 7461 2066 696c 6573 206f 6627 0a20  data files of'. 
-000014b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000014c0: 2020 2020 2020 2020 2020 2020 2720 6f66              ' of
-000014d0: 206f 6e65 2072 6563 6f72 6469 6e67 2073   one recording s
-000014e0: 6573 7369 6f6e 2e27 290a 0a20 2020 2020  ession.')..     
-000014f0: 2020 2023 2072 656d 6f76 6520 6669 6c65     # remove file
-00001500: 6e61 6d65 2069 6620 7370 6563 6966 6963  name if specific
-00001510: 2066 696c 6520 7761 7320 7061 7373 6564   file was passed
-00001520: 0a20 2020 2020 2020 2069 6620 616e 7928  .        if any(
-00001530: 5b73 6573 7369 6f6e 6469 722e 656e 6473  [sessiondir.ends
-00001540: 7769 7468 2827 2e25 7327 2025 2065 7874  with('.%s' % ext
-00001550: 2920 666f 7220 6578 7420 696e 2073 656c  ) for ext in sel
-00001560: 662e 6578 7465 6e73 696f 6e73 5d29 3a0a  f.extensions]):.
-00001570: 2020 2020 2020 2020 2020 2020 7365 7373              sess
-00001580: 696f 6e64 6972 203d 2073 6573 7369 6f6e  iondir = session
-00001590: 6469 725b 3a73 6573 7369 6f6e 6469 722e  dir[:sessiondir.
-000015a0: 7266 696e 6428 7365 7029 5d0a 0a20 2020  rfind(sep)]..   
-000015b0: 2020 2020 2023 2072 656d 6f76 6520 2f20       # remove / 
-000015c0: 666f 7220 636f 6e73 6973 7465 6e74 2064  for consistent d
-000015d0: 6972 6563 746f 7279 2068 616e 646c 696e  irectory handlin
-000015e0: 670a 2020 2020 2020 2020 6966 2073 6573  g.        if ses
-000015f0: 7369 6f6e 6469 722e 656e 6473 7769 7468  siondir.endswith
-00001600: 2873 6570 293a 0a20 2020 2020 2020 2020  (sep):.         
-00001610: 2020 2073 6573 7369 6f6e 6469 7220 3d20     sessiondir = 
-00001620: 7365 7373 696f 6e64 6972 2e72 7374 7269  sessiondir.rstri
-00001630: 7028 7365 7029 0a0a 2020 2020 2020 2020  p(sep)..        
-00001640: 2320 7365 7420 6765 6e65 7261 6c20 7061  # set general pa
-00001650: 7261 6d65 7465 7273 206f 6620 7468 6973  rameters of this
-00001660: 2049 4f0a 2020 2020 2020 2020 7365 6c66   IO.        self
-00001670: 2e73 6573 7369 6f6e 6469 7220 3d20 7365  .sessiondir = se
-00001680: 7373 696f 6e64 6972 0a20 2020 2020 2020  ssiondir.       
-00001690: 2073 656c 662e 6669 6c65 6e61 6d65 203d   self.filename =
-000016a0: 2073 6573 7369 6f6e 6469 722e 7370 6c69   sessiondir.spli
-000016b0: 7428 7365 7029 5b2d 315d 0a20 2020 2020  t(sep)[-1].     
-000016c0: 2020 2073 656c 662e 5f70 7269 6e74 5f64     self._print_d
-000016d0: 6961 676e 6f73 7469 6320 3d20 7072 696e  iagnostic = prin
-000016e0: 745f 6469 6167 6e6f 7374 6963 0a20 2020  t_diagnostic.   
-000016f0: 2020 2020 2073 656c 662e 6173 736f 6369       self.associ
-00001700: 6174 6564 203d 2046 616c 7365 0a20 2020  ated = False.   
-00001710: 2020 2020 2073 656c 662e 5f61 7373 6f63       self._assoc
-00001720: 6961 7465 2863 6163 6865 6469 723d 6361  iate(cachedir=ca
-00001730: 6368 6564 6972 2c20 7573 6563 6163 6865  chedir, usecache
-00001740: 3d75 7365 5f63 6163 6865 290a 0a20 2020  =use_cache)..   
-00001750: 2020 2020 2073 656c 662e 5f64 6961 676e       self._diagn
-00001760: 6f73 7469 635f 7072 696e 7428 0a20 2020  ostic_print(.   
-00001770: 2020 2020 2020 2020 2027 496e 6974 6961           'Initia
-00001780: 6c69 7a65 6420 494f 2066 6f72 2073 6573  lized IO for ses
-00001790: 7369 6f6e 2025 7327 2025 2073 656c 662e  sion %s' % self.
-000017a0: 7365 7373 696f 6e64 6972 290a 0a20 2020  sessiondir)..   
-000017b0: 2064 6566 2072 6561 645f 626c 6f63 6b28   def read_block(
-000017c0: 7365 6c66 2c20 6c61 7a79 3d46 616c 7365  self, lazy=False
-000017d0: 2c20 6361 7363 6164 653d 5472 7565 2c20  , cascade=True, 
-000017e0: 745f 7374 6172 7473 3d4e 6f6e 652c 0a20  t_starts=None,. 
-000017f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001800: 2020 745f 7374 6f70 733d 4e6f 6e65 2c0a    t_stops=None,.
-00001810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001820: 2020 2065 6c65 6374 726f 6465 5f6c 6973     electrode_lis
-00001830: 743d 4e6f 6e65 2c20 756e 6974 5f6c 6973  t=None, unit_lis
-00001840: 743d 4e6f 6e65 2c20 616e 616c 6f67 7369  t=None, analogsi
-00001850: 676e 616c 733d 5472 7565 2c0a 2020 2020  gnals=True,.    
-00001860: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00001870: 7665 6e74 733d 4661 6c73 652c 0a20 2020  vents=False,.   
+000012c0: 2020 2073 6573 7369 6f6e 6469 720a 2020     sessiondir.  
+000012d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000012e0: 2020 2020 2020 2020 2020 6861 7320 7072            has pr
+000012f0: 696f 7269 7479 206f 7665 7220 6669 6c65  iority over file
+00001300: 6e61 6d65 2e0a 2020 2020 2020 2020 2222  name..        ""
+00001310: 220a 0a20 2020 2020 2020 2077 6172 6e69  "..        warni
+00001320: 6e67 732e 7761 726e 2827 7b7d 2069 7320  ngs.warn('{} is 
+00001330: 6465 7072 6563 6174 6564 2061 6e64 2077  deprecated and w
+00001340: 696c 6c20 6265 2072 656d 6f76 6564 2069  ill be removed i
+00001350: 6e20 6e65 6f20 7665 7273 696f 6e20 302e  n neo version 0.
+00001360: 3130 2e20 5573 6520 7b7d 2069 6e73 7465  10. Use {} inste
+00001370: 6164 2e27 0a20 2020 2020 2020 2020 2020  ad.'.           
+00001380: 2020 2020 2020 2020 2020 2027 272e 666f             ''.fo
+00001390: 726d 6174 2873 656c 662e 5f5f 636c 6173  rmat(self.__clas
+000013a0: 735f 5f2c 206e 656f 2e69 6f2e 6e65 7572  s__, neo.io.neur
+000013b0: 616c 796e 7869 6f2e 4e65 7572 616c 796e  alynxio.Neuralyn
+000013c0: 7849 4f29 2c20 4675 7475 7265 5761 726e  xIO), FutureWarn
+000013d0: 696e 6729 0a0a 2020 2020 2020 2020 4261  ing)..        Ba
+000013e0: 7365 494f 2e5f 5f69 6e69 745f 5f28 7365  seIO.__init__(se
+000013f0: 6c66 290a 0a20 2020 2020 2020 2023 2070  lf)..        # p
+00001400: 6f73 7369 626c 6974 7920 746f 2070 726f  ossiblity to pro
+00001410: 7669 6465 2066 696c 656e 616d 6520 696e  vide filename in
+00001420: 7374 6561 6420 6f66 2073 6573 7369 6f6e  stead of session
+00001430: 6469 7220 666f 7220 494f 0a20 2020 2020  dir for IO.     
+00001440: 2020 2023 2063 6f6d 7061 7469 6269 6c69     # compatibili
+00001450: 7479 0a20 2020 2020 2020 2069 6620 6669  ty.        if fi
+00001460: 6c65 6e61 6d65 2069 7320 6e6f 7420 4e6f  lename is not No
+00001470: 6e65 2061 6e64 2073 6573 7369 6f6e 6469  ne and sessiondi
+00001480: 7220 6973 204e 6f6e 653a 0a20 2020 2020  r is None:.     
+00001490: 2020 2020 2020 2073 6573 7369 6f6e 6469         sessiondi
+000014a0: 7220 3d20 6669 6c65 6e61 6d65 0a0a 2020  r = filename..  
+000014b0: 2020 2020 2020 6966 2073 6573 7369 6f6e        if session
+000014c0: 6469 7220 6973 204e 6f6e 653a 0a20 2020  dir is None:.   
+000014d0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+000014e0: 616c 7565 4572 726f 7228 274d 7573 7420  alueError('Must 
+000014f0: 7072 6f76 6964 6520 6120 6469 7265 6374  provide a direct
+00001500: 6f72 7920 636f 6e74 6169 6e69 6e67 2064  ory containing d
+00001510: 6174 6120 6669 6c65 7320 6f66 270a 2020  ata files of'.  
+00001520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001530: 2020 2020 2020 2020 2020 2027 206f 6620             ' of 
+00001540: 6f6e 6520 7265 636f 7264 696e 6720 7365  one recording se
+00001550: 7373 696f 6e2e 2729 0a0a 2020 2020 2020  ssion.')..      
+00001560: 2020 2320 7265 6d6f 7665 2066 696c 656e    # remove filen
+00001570: 616d 6520 6966 2073 7065 6369 6669 6320  ame if specific 
+00001580: 6669 6c65 2077 6173 2070 6173 7365 640a  file was passed.
+00001590: 2020 2020 2020 2020 6966 2061 6e79 285b          if any([
+000015a0: 7365 7373 696f 6e64 6972 2e65 6e64 7377  sessiondir.endsw
+000015b0: 6974 6828 272e 2573 2720 2520 6578 7429  ith('.%s' % ext)
+000015c0: 2066 6f72 2065 7874 2069 6e20 7365 6c66   for ext in self
+000015d0: 2e65 7874 656e 7369 6f6e 735d 293a 0a20  .extensions]):. 
+000015e0: 2020 2020 2020 2020 2020 2073 6573 7369             sessi
+000015f0: 6f6e 6469 7220 3d20 7365 7373 696f 6e64  ondir = sessiond
+00001600: 6972 5b3a 7365 7373 696f 6e64 6972 2e72  ir[:sessiondir.r
+00001610: 6669 6e64 2873 6570 295d 0a0a 2020 2020  find(sep)]..    
+00001620: 2020 2020 2320 7265 6d6f 7665 202f 2066      # remove / f
+00001630: 6f72 2063 6f6e 7369 7374 656e 7420 6469  or consistent di
+00001640: 7265 6374 6f72 7920 6861 6e64 6c69 6e67  rectory handling
+00001650: 0a20 2020 2020 2020 2069 6620 7365 7373  .        if sess
+00001660: 696f 6e64 6972 2e65 6e64 7377 6974 6828  iondir.endswith(
+00001670: 7365 7029 3a0a 2020 2020 2020 2020 2020  sep):.          
+00001680: 2020 7365 7373 696f 6e64 6972 203d 2073    sessiondir = s
+00001690: 6573 7369 6f6e 6469 722e 7273 7472 6970  essiondir.rstrip
+000016a0: 2873 6570 290a 0a20 2020 2020 2020 2023  (sep)..        #
+000016b0: 2073 6574 2067 656e 6572 616c 2070 6172   set general par
+000016c0: 616d 6574 6572 7320 6f66 2074 6869 7320  ameters of this 
+000016d0: 494f 0a20 2020 2020 2020 2073 656c 662e  IO.        self.
+000016e0: 7365 7373 696f 6e64 6972 203d 2073 6573  sessiondir = ses
+000016f0: 7369 6f6e 6469 720a 2020 2020 2020 2020  siondir.        
+00001700: 7365 6c66 2e66 696c 656e 616d 6520 3d20  self.filename = 
+00001710: 7365 7373 696f 6e64 6972 2e73 706c 6974  sessiondir.split
+00001720: 2873 6570 295b 2d31 5d0a 2020 2020 2020  (sep)[-1].      
+00001730: 2020 7365 6c66 2e5f 7072 696e 745f 6469    self._print_di
+00001740: 6167 6e6f 7374 6963 203d 2070 7269 6e74  agnostic = print
+00001750: 5f64 6961 676e 6f73 7469 630a 2020 2020  _diagnostic.    
+00001760: 2020 2020 7365 6c66 2e61 7373 6f63 6961      self.associa
+00001770: 7465 6420 3d20 4661 6c73 650a 2020 2020  ted = False.    
+00001780: 2020 2020 7365 6c66 2e5f 6173 736f 6369      self._associ
+00001790: 6174 6528 6361 6368 6564 6972 3d63 6163  ate(cachedir=cac
+000017a0: 6865 6469 722c 2075 7365 6361 6368 653d  hedir, usecache=
+000017b0: 7573 655f 6361 6368 6529 0a0a 2020 2020  use_cache)..    
+000017c0: 2020 2020 7365 6c66 2e5f 6469 6167 6e6f      self._diagno
+000017d0: 7374 6963 5f70 7269 6e74 280a 2020 2020  stic_print(.    
+000017e0: 2020 2020 2020 2020 2749 6e69 7469 616c          'Initial
+000017f0: 697a 6564 2049 4f20 666f 7220 7365 7373  ized IO for sess
+00001800: 696f 6e20 2573 2720 2520 7365 6c66 2e73  ion %s' % self.s
+00001810: 6573 7369 6f6e 6469 7229 0a0a 2020 2020  essiondir)..    
+00001820: 6465 6620 7265 6164 5f62 6c6f 636b 2873  def read_block(s
+00001830: 656c 662c 206c 617a 793d 4661 6c73 652c  elf, lazy=False,
+00001840: 2063 6173 6361 6465 3d54 7275 652c 2074   cascade=True, t
+00001850: 5f73 7461 7274 733d 4e6f 6e65 2c0a 2020  _starts=None,.  
+00001860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001870: 2074 5f73 746f 7073 3d4e 6f6e 652c 0a20   t_stops=None,. 
 00001880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001890: 7761 7665 666f 726d 733d 4661 6c73 6529  waveforms=False)
-000018a0: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
-000018b0: 2020 2020 2020 5265 6164 7320 6461 7461        Reads data
-000018c0: 2069 6e20 6120 7265 7175 6573 7465 6420   in a requested 
-000018d0: 7469 6d65 2077 696e 646f 7720 616e 6420  time window and 
-000018e0: 7265 7475 726e 7320 626c 6f63 6b20 7769  returns block wi
-000018f0: 7468 2061 7320 6d61 6e79 0a20 2020 2020  th as many.     
-00001900: 2020 2073 6567 6d65 6e74 730a 2020 2020     segments.    
-00001910: 2020 2020 6573 206e 6563 6573 7361 7279      es necessary
-00001920: 2063 6f6e 7461 696e 696e 6720 7468 6573   containing thes
-00001930: 6520 6461 7461 2e0a 0a20 2020 2020 2020  e data...       
-00001940: 2041 7267 756d 656e 7473 3a0a 2020 2020   Arguments:.    
-00001950: 2020 2020 2020 2020 6c61 7a79 203a 2050          lazy : P
-00001960: 6f73 7470 6f6e 6520 6163 7475 616c 2072  ostpone actual r
-00001970: 6561 6469 6e67 206f 6620 7468 6520 6461  eading of the da
-00001980: 7461 2066 696c 6573 2e20 4465 6661 756c  ta files. Defaul
-00001990: 7420 2746 616c 7365 272e 0a20 2020 2020  t 'False'..     
-000019a0: 2020 2020 2020 2063 6173 6361 6465 203a         cascade :
-000019b0: 2044 6f20 6e6f 7420 706f 7374 706f 6e65   Do not postpone
-000019c0: 2072 6561 6469 6e67 2073 7562 7365 7175   reading subsequ
-000019d0: 656e 7420 6e65 6f20 7479 7065 7320 2873  ent neo types (s
-000019e0: 6567 6d65 6e74 7329 2e0a 2020 2020 2020  egments)..      
-000019f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001a00: 2020 2020 2020 4465 6661 756c 7420 2754        Default 'T
-00001a10: 7275 6527 2e0a 2020 2020 2020 2020 2020  rue'..          
-00001a20: 2020 745f 7374 6172 7473 203a 206c 6973    t_starts : lis
-00001a30: 7420 6f66 2071 7561 6e74 6974 6965 7320  t of quantities 
-00001a40: 6f72 2071 7561 6e74 6974 7920 6465 7363  or quantity desc
-00001a50: 7269 6269 6e67 2074 6865 2073 7461 7274  ribing the start
-00001a60: 206f 660a 2020 2020 2020 2020 2020 2020   of.            
-00001a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001a80: 7468 6520 7265 7175 6573 7465 6420 7469  the requested ti
-00001a90: 6d65 2077 696e 646f 7720 746f 206c 6f61  me window to loa
-00001aa0: 642e 2049 6620 4e6f 6e65 206f 7220 5b4e  d. If None or [N
-00001ab0: 6f6e 655d 0a20 2020 2020 2020 2020 2020  one].           
-00001ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001ad0: 2074 6865 2063 6f6d 706c 6574 6520 7365   the complete se
-00001ae0: 7373 696f 6e20 6973 206c 6f61 6465 642e  ssion is loaded.
-00001af0: 2044 6566 6175 6c74 2027 4e6f 6e65 272e   Default 'None'.
-00001b00: 0a20 2020 2020 2020 2020 2020 2074 5f73  .            t_s
-00001b10: 746f 7073 203a 206c 6973 7420 6f66 2071  tops : list of q
-00001b20: 7561 6e74 6974 6965 7320 6f72 2071 7561  uantities or qua
-00001b30: 6e74 6974 7920 6465 7363 7269 6269 6e67  ntity describing
-00001b40: 2074 6865 2065 6e64 206f 6620 7468 650a   the end of the.
-00001b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001b60: 2020 2020 2020 2020 2020 2020 7265 7175              requ
-00001b70: 6573 7465 6420 7469 6d65 2077 696e 646f  ested time windo
-00001b80: 7720 746f 206c 6f61 642e 2048 6173 2074  w to load. Has t
-00001b90: 6f20 636f 6e74 6169 6e20 7468 650a 2020  o contain the.  
-00001ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001bb0: 2020 2020 2020 2020 2020 7361 6d65 206e            same n
-00001bc0: 756d 6265 7220 6f66 2076 616c 7565 7320  umber of values 
-00001bd0: 6173 2074 5f73 7461 7274 732e 2049 6620  as t_starts. If 
-00001be0: 4e6f 6e65 206f 7220 5b4e 6f6e 655d 0a20  None or [None]. 
-00001bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001c00: 2020 2020 2020 2020 2020 2074 6865 2063             the c
-00001c10: 6f6d 706c 6574 6520 7365 7373 696f 6e20  omplete session 
-00001c20: 6973 206c 6f61 6465 642e 2044 6566 6175  is loaded. Defau
-00001c30: 6c74 2027 4e6f 6e65 272e 0a20 2020 2020  lt 'None'..     
-00001c40: 2020 2020 2020 2065 6c65 6374 726f 6465         electrode
-00001c50: 5f6c 6973 7420 3a20 6c69 7374 206f 6620  _list : list of 
-00001c60: 696e 7465 6765 7273 2063 6f6e 7461 696e  integers contain
-00001c70: 696e 6720 7468 6520 4944 7320 6f66 2074  ing the IDs of t
-00001c80: 6865 0a20 2020 2020 2020 2020 2020 2020  he.             
-00001c90: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00001ca0: 6571 7565 7374 6564 2074 6f20 6c6f 6164  equested to load
-00001cb0: 2e20 4966 205b 5d20 6f72 204e 6f6e 6520  . If [] or None 
-00001cc0: 616c 6c20 6176 6169 6c61 626c 650a 2020  all available.  
-00001cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001ce0: 2020 2020 2020 2020 2020 6368 616e 6e65            channe
-00001cf0: 6c73 2077 696c 6c20 6265 206c 6f61 6465  ls will be loade
-00001d00: 642e 0a20 2020 2020 2020 2020 2020 2020  d..             
-00001d10: 2020 2020 2020 2020 2020 2020 2020 2044                 D
-00001d20: 6566 6175 6c74 3a20 4e6f 6e65 2e0a 2020  efault: None..  
-00001d30: 2020 2020 2020 2020 2020 756e 6974 5f6c            unit_l
-00001d40: 6973 7420 3a20 6c69 7374 206f 6620 696e  ist : list of in
-00001d50: 7465 6765 7273 2063 6f6e 7461 696e 696e  tegers containin
-00001d60: 6720 7468 6520 4944 7320 6f66 2074 6865  g the IDs of the
-00001d70: 2072 6571 7565 7374 6564 0a20 2020 2020   requested.     
-00001d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001d90: 2020 2020 2020 2075 6e69 7473 2074 6f20         units to 
-00001da0: 6c6f 6164 2e20 4966 205b 5d20 6f72 204e  load. If [] or N
-00001db0: 6f6e 6520 616c 6c20 6176 6169 6c61 626c  one all availabl
-00001dc0: 6520 756e 6974 730a 2020 2020 2020 2020  e units.        
-00001dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001de0: 2020 2020 7769 6c6c 2062 6520 6c6f 6164      will be load
-00001df0: 6564 2e0a 2020 2020 2020 2020 2020 2020  ed..            
-00001e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001e10: 4465 6661 756c 743a 204e 6f6e 652e 0a20  Default: None.. 
-00001e20: 2020 2020 2020 2020 2020 2061 6e61 6c6f             analo
-00001e30: 6773 6967 6e61 6c73 203a 2062 6f6f 6c65  gsignals : boole
-00001e40: 616e 2c20 696e 6469 6361 7469 6f6e 2077  an, indication w
-00001e50: 6865 7468 6572 2061 6e61 6c6f 6773 6967  hether analogsig
-00001e60: 6e61 6c73 2073 686f 756c 6420 6265 0a20  nals should be. 
-00001e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001e80: 2020 2020 2020 2020 2020 2072 6561 642e             read.
-00001e90: 2044 6566 6175 6c74 3a20 5472 7565 2e0a   Default: True..
-00001ea0: 2020 2020 2020 2020 2020 2020 6576 656e              even
-00001eb0: 7473 203a 204c 6f61 6469 6e67 2065 7665  ts : Loading eve
-00001ec0: 6e74 732e 2049 6620 5472 7565 2061 6c6c  nts. If True all
-00001ed0: 2061 7661 696c 6162 6c65 2065 7665 6e74   available event
-00001ee0: 7320 696e 2074 6865 2067 6976 656e 0a20  s in the given. 
-00001ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f00: 2020 2020 2020 2020 2020 2074 696d 6520             time 
-00001f10: 7769 6e64 6f77 2077 696c 6c20 6265 2072  window will be r
-00001f20: 6561 642e 2044 6566 6175 6c74 3a20 4661  ead. Default: Fa
-00001f30: 6c73 652e 0a20 2020 2020 2020 2020 2020  lse..           
-00001f40: 2077 6176 6566 6f72 6d73 203a 204c 6f61   waveforms : Loa
-00001f50: 6420 7761 7665 666f 726d 2066 6f72 2073  d waveform for s
-00001f60: 7069 6b65 7320 696e 2074 6865 2072 6571  pikes in the req
-00001f70: 7565 7374 6564 2074 696d 650a 2020 2020  uested time.    
-00001f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001f90: 2020 2020 2020 2020 7769 6e64 6f77 2e20          window. 
-00001fa0: 4465 6661 756c 743a 2046 616c 7365 2e0a  Default: False..
-00001fb0: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
-00001fc0: 3a20 426c 6f63 6b20 6f62 6a65 6374 2063  : Block object c
-00001fd0: 6f6e 7461 696e 696e 6720 7468 6520 7265  ontaining the re
-00001fe0: 7175 6573 7465 6420 6461 7461 2069 6e20  quested data in 
-00001ff0: 6e65 6f20 7374 7275 6374 7572 6573 2e0a  neo structures..
-00002000: 0a20 2020 2020 2020 2055 7361 6765 3a0a  .        Usage:.
-00002010: 2020 2020 2020 2020 2020 2020 6672 6f6d              from
-00002020: 206e 656f 2069 6d70 6f72 7420 696f 0a20   neo import io. 
-00002030: 2020 2020 2020 2020 2020 2069 6d70 6f72             impor
-00002040: 7420 7175 616e 7469 7469 6573 2061 7320  t quantities as 
-00002050: 7071 0a20 2020 2020 2020 2020 2020 2069  pq.            i
-00002060: 6d70 6f72 7420 6d61 7470 6c6f 746c 6962  mport matplotlib
-00002070: 2e70 7970 6c6f 7420 6173 2070 6c74 0a0a  .pyplot as plt..
-00002080: 2020 2020 2020 2020 2020 2020 7365 7373              sess
-00002090: 696f 6e5f 666f 6c64 6572 203d 2027 2e2e  ion_folder = '..
-000020a0: 2f44 6174 612f 3230 3134 2d30 372d 3234  /Data/2014-07-24
-000020b0: 5f31 302d 3331 2d30 3227 0a20 2020 2020  _10-31-02'.     
-000020c0: 2020 2020 2020 204e 494f 203d 2069 6f2e         NIO = io.
-000020d0: 4e65 7572 616c 796e 7849 4f28 7365 7373  NeuralynxIO(sess
-000020e0: 696f 6e5f 666f 6c64 6572 2c70 7269 6e74  ion_folder,print
-000020f0: 5f64 6961 676e 6f73 7469 6320 3d20 5472  _diagnostic = Tr
-00002100: 7565 290a 2020 2020 2020 2020 2020 2020  ue).            
-00002110: 626c 6f63 6b20 3d20 4e49 4f2e 7265 6164  block = NIO.read
-00002120: 5f62 6c6f 636b 286c 617a 7920 3d20 4661  _block(lazy = Fa
-00002130: 6c73 652c 2063 6173 6361 6465 203d 2054  lse, cascade = T
-00002140: 7275 652c 0a20 2020 2020 2020 2020 2020  rue,.           
-00002150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002160: 2020 2020 2020 2020 745f 7374 6172 7473          t_starts
-00002170: 203d 2030 2e31 2a70 712e 732c 2074 5f73   = 0.1*pq.s, t_s
-00002180: 746f 7073 203d 2030 2e32 2a70 712e 732c  tops = 0.2*pq.s,
-00002190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000021a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000021b0: 2020 2020 656c 6563 7472 6f64 655f 6c69      electrode_li
-000021c0: 7374 203d 205b 312c 352c 3130 5d2c 0a20  st = [1,5,10],. 
-000021d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000021e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000021f0: 2020 756e 6974 5f6c 6973 7420 3d20 5b31    unit_list = [1
-00002200: 2c32 2c33 5d2c 0a20 2020 2020 2020 2020  ,2,3],.         
+00001890: 2020 656c 6563 7472 6f64 655f 6c69 7374    electrode_list
+000018a0: 3d4e 6f6e 652c 2075 6e69 745f 6c69 7374  =None, unit_list
+000018b0: 3d4e 6f6e 652c 2061 6e61 6c6f 6773 6967  =None, analogsig
+000018c0: 6e61 6c73 3d54 7275 652c 0a20 2020 2020  nals=True,.     
+000018d0: 2020 2020 2020 2020 2020 2020 2020 6576                ev
+000018e0: 656e 7473 3d46 616c 7365 2c0a 2020 2020  ents=False,.    
+000018f0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
+00001900: 6176 6566 6f72 6d73 3d46 616c 7365 293a  aveforms=False):
+00001910: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00001920: 2020 2020 2052 6561 6473 2064 6174 6120       Reads data 
+00001930: 696e 2061 2072 6571 7565 7374 6564 2074  in a requested t
+00001940: 696d 6520 7769 6e64 6f77 2061 6e64 2072  ime window and r
+00001950: 6574 7572 6e73 2062 6c6f 636b 2077 6974  eturns block wit
+00001960: 6820 6173 206d 616e 790a 2020 2020 2020  h as many.      
+00001970: 2020 7365 676d 656e 7473 0a20 2020 2020    segments.     
+00001980: 2020 2065 7320 6e65 6365 7373 6172 7920     es necessary 
+00001990: 636f 6e74 6169 6e69 6e67 2074 6865 7365  containing these
+000019a0: 2064 6174 612e 0a0a 2020 2020 2020 2020   data...        
+000019b0: 4172 6775 6d65 6e74 733a 0a20 2020 2020  Arguments:.     
+000019c0: 2020 2020 2020 206c 617a 7920 3a20 506f         lazy : Po
+000019d0: 7374 706f 6e65 2061 6374 7561 6c20 7265  stpone actual re
+000019e0: 6164 696e 6720 6f66 2074 6865 2064 6174  ading of the dat
+000019f0: 6120 6669 6c65 732e 2044 6566 6175 6c74  a files. Default
+00001a00: 2027 4661 6c73 6527 2e0a 2020 2020 2020   'False'..      
+00001a10: 2020 2020 2020 6361 7363 6164 6520 3a20        cascade : 
+00001a20: 446f 206e 6f74 2070 6f73 7470 6f6e 6520  Do not postpone 
+00001a30: 7265 6164 696e 6720 7375 6273 6571 7565  reading subseque
+00001a40: 6e74 206e 656f 2074 7970 6573 2028 7365  nt neo types (se
+00001a50: 676d 656e 7473 292e 0a20 2020 2020 2020  gments)..       
+00001a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001a70: 2020 2020 2044 6566 6175 6c74 2027 5472       Default 'Tr
+00001a80: 7565 272e 0a20 2020 2020 2020 2020 2020  ue'..           
+00001a90: 2074 5f73 7461 7274 7320 3a20 6c69 7374   t_starts : list
+00001aa0: 206f 6620 7175 616e 7469 7469 6573 206f   of quantities o
+00001ab0: 7220 7175 616e 7469 7479 2064 6573 6372  r quantity descr
+00001ac0: 6962 696e 6720 7468 6520 7374 6172 7420  ibing the start 
+00001ad0: 6f66 0a20 2020 2020 2020 2020 2020 2020  of.             
+00001ae0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+00001af0: 6865 2072 6571 7565 7374 6564 2074 696d  he requested tim
+00001b00: 6520 7769 6e64 6f77 2074 6f20 6c6f 6164  e window to load
+00001b10: 2e20 4966 204e 6f6e 6520 6f72 205b 4e6f  . If None or [No
+00001b20: 6e65 5d0a 2020 2020 2020 2020 2020 2020  ne].            
+00001b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001b40: 7468 6520 636f 6d70 6c65 7465 2073 6573  the complete ses
+00001b50: 7369 6f6e 2069 7320 6c6f 6164 6564 2e20  sion is loaded. 
+00001b60: 4465 6661 756c 7420 274e 6f6e 6527 2e0a  Default 'None'..
+00001b70: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
+00001b80: 6f70 7320 3a20 6c69 7374 206f 6620 7175  ops : list of qu
+00001b90: 616e 7469 7469 6573 206f 7220 7175 616e  antities or quan
+00001ba0: 7469 7479 2064 6573 6372 6962 696e 6720  tity describing 
+00001bb0: 7468 6520 656e 6420 6f66 2074 6865 0a20  the end of the. 
+00001bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001bd0: 2020 2020 2020 2020 2020 2072 6571 7565             reque
+00001be0: 7374 6564 2074 696d 6520 7769 6e64 6f77  sted time window
+00001bf0: 2074 6f20 6c6f 6164 2e20 4861 7320 746f   to load. Has to
+00001c00: 2063 6f6e 7461 696e 2074 6865 0a20 2020   contain the.   
+00001c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001c20: 2020 2020 2020 2020 2073 616d 6520 6e75           same nu
+00001c30: 6d62 6572 206f 6620 7661 6c75 6573 2061  mber of values a
+00001c40: 7320 745f 7374 6172 7473 2e20 4966 204e  s t_starts. If N
+00001c50: 6f6e 6520 6f72 205b 4e6f 6e65 5d0a 2020  one or [None].  
+00001c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001c70: 2020 2020 2020 2020 2020 7468 6520 636f            the co
+00001c80: 6d70 6c65 7465 2073 6573 7369 6f6e 2069  mplete session i
+00001c90: 7320 6c6f 6164 6564 2e20 4465 6661 756c  s loaded. Defaul
+00001ca0: 7420 274e 6f6e 6527 2e0a 2020 2020 2020  t 'None'..      
+00001cb0: 2020 2020 2020 656c 6563 7472 6f64 655f        electrode_
+00001cc0: 6c69 7374 203a 206c 6973 7420 6f66 2069  list : list of i
+00001cd0: 6e74 6567 6572 7320 636f 6e74 6169 6e69  ntegers containi
+00001ce0: 6e67 2074 6865 2049 4473 206f 6620 7468  ng the IDs of th
+00001cf0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00001d00: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00001d10: 7175 6573 7465 6420 746f 206c 6f61 642e  quested to load.
+00001d20: 2049 6620 5b5d 206f 7220 4e6f 6e65 2061   If [] or None a
+00001d30: 6c6c 2061 7661 696c 6162 6c65 0a20 2020  ll available.   
+00001d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001d50: 2020 2020 2020 2020 2063 6861 6e6e 656c           channel
+00001d60: 7320 7769 6c6c 2062 6520 6c6f 6164 6564  s will be loaded
+00001d70: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00001d80: 2020 2020 2020 2020 2020 2020 2020 4465                De
+00001d90: 6661 756c 743a 204e 6f6e 652e 0a20 2020  fault: None..   
+00001da0: 2020 2020 2020 2020 2075 6e69 745f 6c69           unit_li
+00001db0: 7374 203a 206c 6973 7420 6f66 2069 6e74  st : list of int
+00001dc0: 6567 6572 7320 636f 6e74 6169 6e69 6e67  egers containing
+00001dd0: 2074 6865 2049 4473 206f 6620 7468 6520   the IDs of the 
+00001de0: 7265 7175 6573 7465 640a 2020 2020 2020  requested.      
+00001df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e00: 2020 2020 2020 756e 6974 7320 746f 206c        units to l
+00001e10: 6f61 642e 2049 6620 5b5d 206f 7220 4e6f  oad. If [] or No
+00001e20: 6e65 2061 6c6c 2061 7661 696c 6162 6c65  ne all available
+00001e30: 2075 6e69 7473 0a20 2020 2020 2020 2020   units.         
+00001e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001e50: 2020 2077 696c 6c20 6265 206c 6f61 6465     will be loade
+00001e60: 642e 0a20 2020 2020 2020 2020 2020 2020  d..             
+00001e70: 2020 2020 2020 2020 2020 2020 2020 2044                 D
+00001e80: 6566 6175 6c74 3a20 4e6f 6e65 2e0a 2020  efault: None..  
+00001e90: 2020 2020 2020 2020 2020 616e 616c 6f67            analog
+00001ea0: 7369 676e 616c 7320 3a20 626f 6f6c 6561  signals : boolea
+00001eb0: 6e2c 2069 6e64 6963 6174 696f 6e20 7768  n, indication wh
+00001ec0: 6574 6865 7220 616e 616c 6f67 7369 676e  ether analogsign
+00001ed0: 616c 7320 7368 6f75 6c64 2062 650a 2020  als should be.  
+00001ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001ef0: 2020 2020 2020 2020 2020 7265 6164 2e20            read. 
+00001f00: 4465 6661 756c 743a 2054 7275 652e 0a20  Default: True.. 
+00001f10: 2020 2020 2020 2020 2020 2065 7665 6e74             event
+00001f20: 7320 3a20 4c6f 6164 696e 6720 6576 656e  s : Loading even
+00001f30: 7473 2e20 4966 2054 7275 6520 616c 6c20  ts. If True all 
+00001f40: 6176 6169 6c61 626c 6520 6576 656e 7473  available events
+00001f50: 2069 6e20 7468 6520 6769 7665 6e0a 2020   in the given.  
+00001f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001f70: 2020 2020 2020 2020 2020 7469 6d65 2077            time w
+00001f80: 696e 646f 7720 7769 6c6c 2062 6520 7265  indow will be re
+00001f90: 6164 2e20 4465 6661 756c 743a 2046 616c  ad. Default: Fal
+00001fa0: 7365 2e0a 2020 2020 2020 2020 2020 2020  se..            
+00001fb0: 7761 7665 666f 726d 7320 3a20 4c6f 6164  waveforms : Load
+00001fc0: 2077 6176 6566 6f72 6d20 666f 7220 7370   waveform for sp
+00001fd0: 696b 6573 2069 6e20 7468 6520 7265 7175  ikes in the requ
+00001fe0: 6573 7465 6420 7469 6d65 0a20 2020 2020  ested time.     
+00001ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002000: 2020 2020 2020 2077 696e 646f 772e 2044         window. D
+00002010: 6566 6175 6c74 3a20 4661 6c73 652e 0a0a  efault: False...
+00002020: 2020 2020 2020 2020 5265 7475 726e 733a          Returns:
+00002030: 2042 6c6f 636b 206f 626a 6563 7420 636f   Block object co
+00002040: 6e74 6169 6e69 6e67 2074 6865 2072 6571  ntaining the req
+00002050: 7565 7374 6564 2064 6174 6120 696e 206e  uested data in n
+00002060: 656f 2073 7472 7563 7475 7265 732e 0a0a  eo structures...
+00002070: 2020 2020 2020 2020 5573 6167 653a 0a20          Usage:. 
+00002080: 2020 2020 2020 2020 2020 2066 726f 6d20             from 
+00002090: 6e65 6f20 696d 706f 7274 2069 6f0a 2020  neo import io.  
+000020a0: 2020 2020 2020 2020 2020 696d 706f 7274            import
+000020b0: 2071 7561 6e74 6974 6965 7320 6173 2070   quantities as p
+000020c0: 710a 2020 2020 2020 2020 2020 2020 696d  q.            im
+000020d0: 706f 7274 206d 6174 706c 6f74 6c69 622e  port matplotlib.
+000020e0: 7079 706c 6f74 2061 7320 706c 740a 0a20  pyplot as plt.. 
+000020f0: 2020 2020 2020 2020 2020 2073 6573 7369             sessi
+00002100: 6f6e 5f66 6f6c 6465 7220 3d20 272e 2e2f  on_folder = '../
+00002110: 4461 7461 2f32 3031 342d 3037 2d32 345f  Data/2014-07-24_
+00002120: 3130 2d33 312d 3032 270a 2020 2020 2020  10-31-02'.      
+00002130: 2020 2020 2020 4e49 4f20 3d20 696f 2e4e        NIO = io.N
+00002140: 6575 7261 6c79 6e78 494f 2873 6573 7369  euralynxIO(sessi
+00002150: 6f6e 5f66 6f6c 6465 722c 7072 696e 745f  on_folder,print_
+00002160: 6469 6167 6e6f 7374 6963 203d 2054 7275  diagnostic = Tru
+00002170: 6529 0a20 2020 2020 2020 2020 2020 2062  e).            b
+00002180: 6c6f 636b 203d 204e 494f 2e72 6561 645f  lock = NIO.read_
+00002190: 626c 6f63 6b28 6c61 7a79 203d 2046 616c  block(lazy = Fal
+000021a0: 7365 2c20 6361 7363 6164 6520 3d20 5472  se, cascade = Tr
+000021b0: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
+000021c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000021d0: 2020 2020 2020 2074 5f73 7461 7274 7320         t_starts 
+000021e0: 3d20 302e 312a 7071 2e73 2c20 745f 7374  = 0.1*pq.s, t_st
+000021f0: 6f70 7320 3d20 302e 322a 7071 2e73 2c0a  ops = 0.2*pq.s,.
+00002200: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00002210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002220: 2020 2020 2020 2020 2020 6576 656e 7473            events
-00002230: 203d 2054 7275 652c 2077 6176 6566 6f72   = True, wavefor
-00002240: 6d73 203d 2054 7275 6529 0a20 2020 2020  ms = True).     
-00002250: 2020 2020 2020 2070 6c74 2e70 6c6f 7428         plt.plot(
-00002260: 626c 6f63 6b2e 7365 676d 656e 7473 5b30  block.segments[0
-00002270: 5d2e 616e 616c 6f67 7369 676e 616c 735b  ].analogsignals[
-00002280: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
-00002290: 706c 742e 7368 6f77 2829 0a20 2020 2020  plt.show().     
-000022a0: 2020 2022 2222 0a20 2020 2020 2020 2023     """.        #
-000022b0: 2043 7265 6174 6520 626c 6f63 6b0a 2020   Create block.  
-000022c0: 2020 2020 2020 626c 203d 2042 6c6f 636b        bl = Block
-000022d0: 2866 696c 655f 6f72 6967 696e 3d73 656c  (file_origin=sel
-000022e0: 662e 7365 7373 696f 6e64 6972 290a 2020  f.sessiondir).  
-000022f0: 2020 2020 2020 626c 2e6e 616d 6520 3d20        bl.name = 
-00002300: 7365 6c66 2e66 696c 656e 616d 650a 2020  self.filename.  
-00002310: 2020 2020 2020 6966 206e 6f74 2063 6173        if not cas
-00002320: 6361 6465 3a0a 2020 2020 2020 2020 2020  cade:.          
-00002330: 2020 7265 7475 726e 2062 6c0a 0a20 2020    return bl..   
-00002340: 2020 2020 2023 2043 6865 636b 696e 6720       # Checking 
-00002350: 696e 7075 7420 6f66 2074 5f73 7461 7274  input of t_start
-00002360: 2061 6e64 2074 5f73 746f 700a 2020 2020   and t_stop.    
-00002370: 2020 2020 2320 466f 7220 6c61 7a79 2075      # For lazy u
-00002380: 7365 7273 2074 6861 7420 7370 6563 6966  sers that specif
-00002390: 7920 782c 7820 696e 7374 6561 6420 6f66  y x,x instead of
-000023a0: 205b 785d 2c5b 785d 2066 6f72 2074 5f73   [x],[x] for t_s
-000023b0: 7461 7274 732c 0a20 2020 2020 2020 2023  tarts,.        #
-000023c0: 2074 5f73 746f 7073 0a20 2020 2020 2020   t_stops.       
-000023d0: 2069 6620 745f 7374 6172 7473 2069 7320   if t_starts is 
-000023e0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-000023f0: 2020 745f 7374 6172 7473 203d 205b 4e6f    t_starts = [No
-00002400: 6e65 5d0a 2020 2020 2020 2020 656c 6966  ne].        elif
-00002410: 2074 7970 6528 745f 7374 6172 7473 2920   type(t_starts) 
-00002420: 3d3d 2070 712e 5175 616e 7469 7479 3a0a  == pq.Quantity:.
-00002430: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
-00002440: 6172 7473 203d 205b 745f 7374 6172 7473  arts = [t_starts
-00002450: 5d0a 2020 2020 2020 2020 656c 6966 2074  ].        elif t
-00002460: 7970 6528 745f 7374 6172 7473 2920 213d  ype(t_starts) !=
-00002470: 206c 6973 7420 6f72 2061 6e79 280a 2020   list or any(.  
-00002480: 2020 2020 2020 2020 2020 2020 2020 5b28                [(
-00002490: 7479 7065 2869 2920 213d 2070 712e 5175  type(i) != pq.Qu
-000024a0: 616e 7469 7479 2061 6e64 2069 2069 7320  antity and i is 
-000024b0: 6e6f 7420 4e6f 6e65 2920 666f 7220 6920  not None) for i 
-000024c0: 696e 2074 5f73 7461 7274 735d 293a 0a20  in t_starts]):. 
-000024d0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
-000024e0: 2056 616c 7565 4572 726f 7228 2749 6e76   ValueError('Inv
-000024f0: 616c 6964 2073 7065 6369 6669 6361 7469  alid specificati
-00002500: 6f6e 206f 6620 745f 7374 6172 7473 2e27  on of t_starts.'
-00002510: 290a 2020 2020 2020 2020 6966 2074 5f73  ).        if t_s
-00002520: 746f 7073 2069 7320 4e6f 6e65 3a0a 2020  tops is None:.  
-00002530: 2020 2020 2020 2020 2020 745f 7374 6f70            t_stop
-00002540: 7320 3d20 5b4e 6f6e 655d 0a20 2020 2020  s = [None].     
-00002550: 2020 2065 6c69 6620 7479 7065 2874 5f73     elif type(t_s
-00002560: 746f 7073 2920 3d3d 2070 712e 5175 616e  tops) == pq.Quan
-00002570: 7469 7479 3a0a 2020 2020 2020 2020 2020  tity:.          
-00002580: 2020 745f 7374 6f70 7320 3d20 5b74 5f73    t_stops = [t_s
-00002590: 746f 7073 5d0a 2020 2020 2020 2020 656c  tops].        el
-000025a0: 6966 2074 7970 6528 745f 7374 6f70 7329  if type(t_stops)
-000025b0: 2021 3d20 6c69 7374 206f 7220 616e 7928   != list or any(
-000025c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000025d0: 205b 2874 7970 6528 6929 2021 3d20 7071   [(type(i) != pq
-000025e0: 2e51 7561 6e74 6974 7920 616e 6420 6920  .Quantity and i 
-000025f0: 6973 206e 6f74 204e 6f6e 6529 2066 6f72  is not None) for
-00002600: 2069 2069 6e20 745f 7374 6f70 735d 293a   i in t_stops]):
-00002610: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-00002620: 7365 2056 616c 7565 4572 726f 7228 2749  se ValueError('I
-00002630: 6e76 616c 6964 2073 7065 6369 6669 6361  nvalid specifica
-00002640: 7469 6f6e 206f 6620 745f 7374 6f70 732e  tion of t_stops.
-00002650: 2729 0a0a 2020 2020 2020 2020 2320 6164  ')..        # ad
-00002660: 6170 7469 6e67 2074 5f73 7461 7274 7320  apting t_starts 
-00002670: 616e 6420 745f 7374 6f70 7320 746f 206b  and t_stops to k
-00002680: 6e6f 776e 2067 6170 2074 696d 6573 2028  nown gap times (
-00002690: 6578 7472 6163 7465 6420 696e 0a20 2020  extracted in.   
-000026a0: 2020 2020 2023 2061 7373 6f63 6961 7469       # associati
-000026b0: 6f6e 2070 726f 6365 7373 202f 2069 6e69  on process / ini
-000026c0: 7469 616c 697a 6174 696f 6e29 0a20 2020  tialization).   
-000026d0: 2020 2020 2066 6f72 2067 6170 2069 6e20       for gap in 
-000026e0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-000026f0: 676c 6f62 616c 5b27 6761 7073 275d 3a0a  global['gaps']:.
-00002700: 2020 2020 2020 2020 2020 2020 2320 6761              # ga
-00002710: 703d 6761 705f 6c69 7374 5b30 5d0a 2020  p=gap_list[0].  
-00002720: 2020 2020 2020 2020 2020 666f 7220 6520            for e 
-00002730: 696e 2072 616e 6765 286c 656e 2874 5f73  in range(len(t_s
-00002740: 7461 7274 7329 293a 0a20 2020 2020 2020  tarts)):.       
-00002750: 2020 2020 2020 2020 2074 312c 2074 3220           t1, t2 
-00002760: 3d20 745f 7374 6172 7473 5b65 5d2c 2074  = t_starts[e], t
-00002770: 5f73 746f 7073 5b65 5d0a 2020 2020 2020  _stops[e].      
-00002780: 2020 2020 2020 2020 2020 6761 705f 7374            gap_st
-00002790: 6172 7420 3d20 6761 705b 315d 202a 2073  art = gap[1] * s
-000027a0: 656c 662e 6e63 735f 7469 6d65 5f75 6e69  elf.ncs_time_uni
-000027b0: 7420 2d20 5c0a 2020 2020 2020 2020 2020  t - \.          
-000027c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000027d0: 2020 7365 6c66 2e70 6172 616d 6574 6572    self.parameter
-000027e0: 735f 676c 6f62 616c 5b27 745f 7374 6172  s_global['t_star
-000027f0: 7427 5d0a 2020 2020 2020 2020 2020 2020  t'].            
-00002800: 2020 2020 6761 705f 7374 6f70 203d 2067      gap_stop = g
-00002810: 6170 5b32 5d20 2a20 7365 6c66 2e6e 6373  ap[2] * self.ncs
-00002820: 5f74 696d 655f 756e 6974 202d 2073 656c  _time_unit - sel
-00002830: 662e 7061 7261 6d65 7465 7273 5f67 6c6f  f.parameters_glo
-00002840: 6261 6c5b 0a20 2020 2020 2020 2020 2020  bal[.           
-00002850: 2020 2020 2020 2020 2027 745f 7374 6172           't_star
-00002860: 7427 5d0a 2020 2020 2020 2020 2020 2020  t'].            
-00002870: 2020 2020 6966 2028 2874 3120 6973 204e      if ((t1 is N
-00002880: 6f6e 6520 616e 6420 7432 2069 7320 4e6f  one and t2 is No
-00002890: 6e65 290a 2020 2020 2020 2020 2020 2020  ne).            
-000028a0: 2020 2020 2020 2020 6f72 2028 7431 2069          or (t1 i
-000028b0: 7320 4e6f 6e65 2061 6e64 2074 3220 6973  s None and t2 is
-000028c0: 206e 6f74 204e 6f6e 6520 616e 6420 7432   not None and t2
-000028d0: 2e72 6573 6361 6c65 280a 2020 2020 2020  .rescale(.      
-000028e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028f0: 2020 7365 6c66 2e6e 6373 5f74 696d 655f    self.ncs_time_
-00002900: 756e 6974 2920 3e20 6761 705f 7374 6f70  unit) > gap_stop
-00002910: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00002920: 2020 2020 2020 6f72 2028 7432 2069 7320        or (t2 is 
-00002930: 4e6f 6e65 2061 6e64 2074 3120 6973 206e  None and t1 is n
-00002940: 6f74 204e 6f6e 6520 616e 6420 7431 2e72  ot None and t1.r
-00002950: 6573 6361 6c65 280a 2020 2020 2020 2020  escale(.        
-00002960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002970: 7365 6c66 2e6e 6373 5f74 696d 655f 756e  self.ncs_time_un
-00002980: 6974 2920 3c20 6761 705f 7374 6f70 290a  it) < gap_stop).
-00002990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029a0: 2020 2020 6f72 2028 7431 2069 7320 6e6f      or (t1 is no
-000029b0: 7420 4e6f 6e65 2061 6e64 2074 3220 6973  t None and t2 is
-000029c0: 206e 6f74 204e 6f6e 6520 616e 6420 7431   not None and t1
-000029d0: 2e72 6573 6361 6c65 280a 2020 2020 2020  .rescale(.      
-000029e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029f0: 2020 7365 6c66 2e6e 6373 5f74 696d 655f    self.ncs_time_
-00002a00: 756e 6974 2920 3c20 6761 705f 7374 6172  unit) < gap_star
-00002a10: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-00002a20: 2020 2020 2020 2020 2020 616e 6420 7432            and t2
-00002a30: 2e72 6573 6361 6c65 2873 656c 662e 6e63  .rescale(self.nc
-00002a40: 735f 7469 6d65 5f75 6e69 7429 203e 2067  s_time_unit) > g
-00002a50: 6170 5f73 746f 7029 293a 0a20 2020 2020  ap_stop)):.     
-00002a60: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00002a70: 2061 6461 7074 696e 6720 6669 7273 7420   adapting first 
-00002a80: 7469 6d65 2073 6567 6d65 6e74 0a20 2020  time segment.   
-00002a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002aa0: 2074 5f73 746f 7073 5b65 5d20 3d20 6761   t_stops[e] = ga
-00002ab0: 705f 7374 6172 740a 2020 2020 2020 2020  p_start.        
-00002ac0: 2020 2020 2020 2020 2020 2020 2320 696e              # in
-00002ad0: 7365 7274 696e 6720 7365 636f 6e64 2074  serting second t
-00002ae0: 696d 6520 7365 676d 656e 740a 2020 2020  ime segment.    
-00002af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b00: 745f 7374 6172 7473 2e69 6e73 6572 7428  t_starts.insert(
-00002b10: 6520 2b20 312c 2067 6170 5f73 746f 7029  e + 1, gap_stop)
-00002b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002b30: 2020 2020 2074 5f73 746f 7073 2e69 6e73       t_stops.ins
-00002b40: 6572 7428 6520 2b20 312c 2074 3229 0a20  ert(e + 1, t2). 
-00002b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002b60: 2020 2077 6172 6e69 6e67 732e 7761 726e     warnings.warn
-00002b70: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00002b80: 2020 2020 2020 2020 2020 2753 7562 7374            'Subst
-00002b90: 6974 7574 6564 2074 5f73 7461 7274 7320  ituted t_starts 
-00002ba0: 616e 6420 745f 7374 6f70 7320 696e 206f  and t_stops in o
-00002bb0: 7264 6572 2074 6f20 736b 6970 2027 0a20  rder to skip '. 
+00002220: 2020 2065 6c65 6374 726f 6465 5f6c 6973     electrode_lis
+00002230: 7420 3d20 5b31 2c35 2c31 305d 2c0a 2020  t = [1,5,10],.  
+00002240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002260: 2075 6e69 745f 6c69 7374 203d 205b 312c   unit_list = [1,
+00002270: 322c 335d 2c0a 2020 2020 2020 2020 2020  2,3],.          
+00002280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002290: 2020 2020 2020 2020 2065 7665 6e74 7320           events 
+000022a0: 3d20 5472 7565 2c20 7761 7665 666f 726d  = True, waveform
+000022b0: 7320 3d20 5472 7565 290a 2020 2020 2020  s = True).      
+000022c0: 2020 2020 2020 706c 742e 706c 6f74 2862        plt.plot(b
+000022d0: 6c6f 636b 2e73 6567 6d65 6e74 735b 305d  lock.segments[0]
+000022e0: 2e61 6e61 6c6f 6773 6967 6e61 6c73 5b30  .analogsignals[0
+000022f0: 5d29 0a20 2020 2020 2020 2020 2020 2070  ]).            p
+00002300: 6c74 2e73 686f 7728 290a 2020 2020 2020  lt.show().      
+00002310: 2020 2222 220a 2020 2020 2020 2020 2320    """.        # 
+00002320: 4372 6561 7465 2062 6c6f 636b 0a20 2020  Create block.   
+00002330: 2020 2020 2062 6c20 3d20 426c 6f63 6b28       bl = Block(
+00002340: 6669 6c65 5f6f 7269 6769 6e3d 7365 6c66  file_origin=self
+00002350: 2e73 6573 7369 6f6e 6469 7229 0a20 2020  .sessiondir).   
+00002360: 2020 2020 2062 6c2e 6e61 6d65 203d 2073       bl.name = s
+00002370: 656c 662e 6669 6c65 6e61 6d65 0a20 2020  elf.filename.   
+00002380: 2020 2020 2069 6620 6e6f 7420 6361 7363       if not casc
+00002390: 6164 653a 0a20 2020 2020 2020 2020 2020  ade:.           
+000023a0: 2072 6574 7572 6e20 626c 0a0a 2020 2020   return bl..    
+000023b0: 2020 2020 2320 4368 6563 6b69 6e67 2069      # Checking i
+000023c0: 6e70 7574 206f 6620 745f 7374 6172 7420  nput of t_start 
+000023d0: 616e 6420 745f 7374 6f70 0a20 2020 2020  and t_stop.     
+000023e0: 2020 2023 2046 6f72 206c 617a 7920 7573     # For lazy us
+000023f0: 6572 7320 7468 6174 2073 7065 6369 6679  ers that specify
+00002400: 2078 2c78 2069 6e73 7465 6164 206f 6620   x,x instead of 
+00002410: 5b78 5d2c 5b78 5d20 666f 7220 745f 7374  [x],[x] for t_st
+00002420: 6172 7473 2c0a 2020 2020 2020 2020 2320  arts,.        # 
+00002430: 745f 7374 6f70 730a 2020 2020 2020 2020  t_stops.        
+00002440: 6966 2074 5f73 7461 7274 7320 6973 204e  if t_starts is N
+00002450: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00002460: 2074 5f73 7461 7274 7320 3d20 5b4e 6f6e   t_starts = [Non
+00002470: 655d 0a20 2020 2020 2020 2065 6c69 6620  e].        elif 
+00002480: 7479 7065 2874 5f73 7461 7274 7329 203d  type(t_starts) =
+00002490: 3d20 7071 2e51 7561 6e74 6974 793a 0a20  = pq.Quantity:. 
+000024a0: 2020 2020 2020 2020 2020 2074 5f73 7461             t_sta
+000024b0: 7274 7320 3d20 5b74 5f73 7461 7274 735d  rts = [t_starts]
+000024c0: 0a20 2020 2020 2020 2065 6c69 6620 7479  .        elif ty
+000024d0: 7065 2874 5f73 7461 7274 7329 2021 3d20  pe(t_starts) != 
+000024e0: 6c69 7374 206f 7220 616e 7928 0a20 2020  list or any(.   
+000024f0: 2020 2020 2020 2020 2020 2020 205b 2874               [(t
+00002500: 7970 6528 6929 2021 3d20 7071 2e51 7561  ype(i) != pq.Qua
+00002510: 6e74 6974 7920 616e 6420 6920 6973 206e  ntity and i is n
+00002520: 6f74 204e 6f6e 6529 2066 6f72 2069 2069  ot None) for i i
+00002530: 6e20 745f 7374 6172 7473 5d29 3a0a 2020  n t_starts]):.  
+00002540: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+00002550: 5661 6c75 6545 7272 6f72 2827 496e 7661  ValueError('Inva
+00002560: 6c69 6420 7370 6563 6966 6963 6174 696f  lid specificatio
+00002570: 6e20 6f66 2074 5f73 7461 7274 732e 2729  n of t_starts.')
+00002580: 0a20 2020 2020 2020 2069 6620 745f 7374  .        if t_st
+00002590: 6f70 7320 6973 204e 6f6e 653a 0a20 2020  ops is None:.   
+000025a0: 2020 2020 2020 2020 2074 5f73 746f 7073           t_stops
+000025b0: 203d 205b 4e6f 6e65 5d0a 2020 2020 2020   = [None].      
+000025c0: 2020 656c 6966 2074 7970 6528 745f 7374    elif type(t_st
+000025d0: 6f70 7329 203d 3d20 7071 2e51 7561 6e74  ops) == pq.Quant
+000025e0: 6974 793a 0a20 2020 2020 2020 2020 2020  ity:.           
+000025f0: 2074 5f73 746f 7073 203d 205b 745f 7374   t_stops = [t_st
+00002600: 6f70 735d 0a20 2020 2020 2020 2065 6c69  ops].        eli
+00002610: 6620 7479 7065 2874 5f73 746f 7073 2920  f type(t_stops) 
+00002620: 213d 206c 6973 7420 6f72 2061 6e79 280a  != list or any(.
+00002630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002640: 5b28 7479 7065 2869 2920 213d 2070 712e  [(type(i) != pq.
+00002650: 5175 616e 7469 7479 2061 6e64 2069 2069  Quantity and i i
+00002660: 7320 6e6f 7420 4e6f 6e65 2920 666f 7220  s not None) for 
+00002670: 6920 696e 2074 5f73 746f 7073 5d29 3a0a  i in t_stops]):.
+00002680: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00002690: 6520 5661 6c75 6545 7272 6f72 2827 496e  e ValueError('In
+000026a0: 7661 6c69 6420 7370 6563 6966 6963 6174  valid specificat
+000026b0: 696f 6e20 6f66 2074 5f73 746f 7073 2e27  ion of t_stops.'
+000026c0: 290a 0a20 2020 2020 2020 2023 2061 6461  )..        # ada
+000026d0: 7074 696e 6720 745f 7374 6172 7473 2061  pting t_starts a
+000026e0: 6e64 2074 5f73 746f 7073 2074 6f20 6b6e  nd t_stops to kn
+000026f0: 6f77 6e20 6761 7020 7469 6d65 7320 2865  own gap times (e
+00002700: 7874 7261 6374 6564 2069 6e0a 2020 2020  xtracted in.    
+00002710: 2020 2020 2320 6173 736f 6369 6174 696f      # associatio
+00002720: 6e20 7072 6f63 6573 7320 2f20 696e 6974  n process / init
+00002730: 6961 6c69 7a61 7469 6f6e 290a 2020 2020  ialization).    
+00002740: 2020 2020 666f 7220 6761 7020 696e 2073      for gap in s
+00002750: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
+00002760: 6c6f 6261 6c5b 2767 6170 7327 5d3a 0a20  lobal['gaps']:. 
+00002770: 2020 2020 2020 2020 2020 2023 2067 6170             # gap
+00002780: 3d67 6170 5f6c 6973 745b 305d 0a20 2020  =gap_list[0].   
+00002790: 2020 2020 2020 2020 2066 6f72 2065 2069           for e i
+000027a0: 6e20 7261 6e67 6528 6c65 6e28 745f 7374  n range(len(t_st
+000027b0: 6172 7473 2929 3a0a 2020 2020 2020 2020  arts)):.        
+000027c0: 2020 2020 2020 2020 7431 2c20 7432 203d          t1, t2 =
+000027d0: 2074 5f73 7461 7274 735b 655d 2c20 745f   t_starts[e], t_
+000027e0: 7374 6f70 735b 655d 0a20 2020 2020 2020  stops[e].       
+000027f0: 2020 2020 2020 2020 2067 6170 5f73 7461           gap_sta
+00002800: 7274 203d 2067 6170 5b31 5d20 2a20 7365  rt = gap[1] * se
+00002810: 6c66 2e6e 6373 5f74 696d 655f 756e 6974  lf.ncs_time_unit
+00002820: 202d 205c 0a20 2020 2020 2020 2020 2020   - \.           
+00002830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002840: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
+00002850: 5f67 6c6f 6261 6c5b 2774 5f73 7461 7274  _global['t_start
+00002860: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
+00002870: 2020 2067 6170 5f73 746f 7020 3d20 6761     gap_stop = ga
+00002880: 705b 325d 202a 2073 656c 662e 6e63 735f  p[2] * self.ncs_
+00002890: 7469 6d65 5f75 6e69 7420 2d20 7365 6c66  time_unit - self
+000028a0: 2e70 6172 616d 6574 6572 735f 676c 6f62  .parameters_glob
+000028b0: 616c 5b0a 2020 2020 2020 2020 2020 2020  al[.            
+000028c0: 2020 2020 2020 2020 2774 5f73 7461 7274          't_start
+000028d0: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
+000028e0: 2020 2069 6620 2828 7431 2069 7320 4e6f     if ((t1 is No
+000028f0: 6e65 2061 6e64 2074 3220 6973 204e 6f6e  ne and t2 is Non
+00002900: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+00002910: 2020 2020 2020 206f 7220 2874 3120 6973         or (t1 is
+00002920: 204e 6f6e 6520 616e 6420 7432 2069 7320   None and t2 is 
+00002930: 6e6f 7420 4e6f 6e65 2061 6e64 2074 322e  not None and t2.
+00002940: 7265 7363 616c 6528 0a20 2020 2020 2020  rescale(.       
+00002950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002960: 2073 656c 662e 6e63 735f 7469 6d65 5f75   self.ncs_time_u
+00002970: 6e69 7429 203e 2067 6170 5f73 746f 7029  nit) > gap_stop)
+00002980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002990: 2020 2020 206f 7220 2874 3220 6973 204e       or (t2 is N
+000029a0: 6f6e 6520 616e 6420 7431 2069 7320 6e6f  one and t1 is no
+000029b0: 7420 4e6f 6e65 2061 6e64 2074 312e 7265  t None and t1.re
+000029c0: 7363 616c 6528 0a20 2020 2020 2020 2020  scale(.         
+000029d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000029e0: 656c 662e 6e63 735f 7469 6d65 5f75 6e69  elf.ncs_time_uni
+000029f0: 7429 203c 2067 6170 5f73 746f 7029 0a20  t) < gap_stop). 
+00002a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a10: 2020 206f 7220 2874 3120 6973 206e 6f74     or (t1 is not
+00002a20: 204e 6f6e 6520 616e 6420 7432 2069 7320   None and t2 is 
+00002a30: 6e6f 7420 4e6f 6e65 2061 6e64 2074 312e  not None and t1.
+00002a40: 7265 7363 616c 6528 0a20 2020 2020 2020  rescale(.       
+00002a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a60: 2073 656c 662e 6e63 735f 7469 6d65 5f75   self.ncs_time_u
+00002a70: 6e69 7429 203c 2067 6170 5f73 7461 7274  nit) < gap_start
+00002a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002a90: 2020 2020 2020 2020 2061 6e64 2074 322e           and t2.
+00002aa0: 7265 7363 616c 6528 7365 6c66 2e6e 6373  rescale(self.ncs
+00002ab0: 5f74 696d 655f 756e 6974 2920 3e20 6761  _time_unit) > ga
+00002ac0: 705f 7374 6f70 2929 3a0a 2020 2020 2020  p_stop)):.      
+00002ad0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00002ae0: 6164 6170 7469 6e67 2066 6972 7374 2074  adapting first t
+00002af0: 696d 6520 7365 676d 656e 740a 2020 2020  ime segment.    
+00002b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002b10: 745f 7374 6f70 735b 655d 203d 2067 6170  t_stops[e] = gap
+00002b20: 5f73 7461 7274 0a20 2020 2020 2020 2020  _start.         
+00002b30: 2020 2020 2020 2020 2020 2023 2069 6e73             # ins
+00002b40: 6572 7469 6e67 2073 6563 6f6e 6420 7469  erting second ti
+00002b50: 6d65 2073 6567 6d65 6e74 0a20 2020 2020  me segment.     
+00002b60: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+00002b70: 5f73 7461 7274 732e 696e 7365 7274 2865  _starts.insert(e
+00002b80: 202b 2031 2c20 6761 705f 7374 6f70 290a   + 1, gap_stop).
+00002b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ba0: 2020 2020 745f 7374 6f70 732e 696e 7365      t_stops.inse
+00002bb0: 7274 2865 202b 2031 2c20 7432 290a 2020  rt(e + 1, t2).  
 00002bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002bd0: 2020 2020 2020 2027 6761 7020 696e 2072         'gap in r
-00002be0: 6563 6f72 6469 6e67 2073 6573 7369 6f6e  ecording session
-00002bf0: 2e27 290a 0a20 2020 2020 2020 2023 206c  .')..        # l
-00002c00: 6f61 6469 6e67 2061 6c6c 2063 6861 6e6e  oading all chann
-00002c10: 656c 7320 6966 2065 6d70 7479 2065 6c65  els if empty ele
-00002c20: 6374 726f 6465 5f6c 6973 740a 2020 2020  ctrode_list.    
-00002c30: 2020 2020 6966 2065 6c65 6374 726f 6465      if electrode
-00002c40: 5f6c 6973 7420 3d3d 205b 5d20 6f72 2065  _list == [] or e
-00002c50: 6c65 6374 726f 6465 5f6c 6973 7420 6973  lectrode_list is
-00002c60: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-00002c70: 2020 2065 6c65 6374 726f 6465 5f6c 6973     electrode_lis
-00002c80: 7420 3d20 7365 6c66 2e70 6172 616d 6574  t = self.paramet
-00002c90: 6572 735f 6e63 732e 6b65 7973 2829 0a0a  ers_ncs.keys()..
-00002ca0: 2020 2020 2020 2020 2320 6164 6469 6e67          # adding
-00002cb0: 2061 2073 6567 6d65 6e74 2066 6f72 2065   a segment for e
-00002cc0: 6163 6820 745f 7374 6172 742c 2074 5f73  ach t_start, t_s
-00002cd0: 746f 7020 7061 6972 0a20 2020 2020 2020  top pair.       
-00002ce0: 2066 6f72 2074 5f73 7461 7274 2c20 745f   for t_start, t_
-00002cf0: 7374 6f70 2069 6e20 7a69 7028 745f 7374  stop in zip(t_st
-00002d00: 6172 7473 2c20 745f 7374 6f70 7329 3a0a  arts, t_stops):.
-00002d10: 2020 2020 2020 2020 2020 2020 7365 6720              seg 
-00002d20: 3d20 7365 6c66 2e72 6561 645f 7365 676d  = self.read_segm
-00002d30: 656e 7428 6c61 7a79 3d6c 617a 792c 2063  ent(lazy=lazy, c
-00002d40: 6173 6361 6465 3d63 6173 6361 6465 2c0a  ascade=cascade,.
-00002d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d70: 2020 2020 745f 7374 6172 743d 745f 7374      t_start=t_st
-00002d80: 6172 742c 2074 5f73 746f 703d 745f 7374  art, t_stop=t_st
-00002d90: 6f70 2c0a 2020 2020 2020 2020 2020 2020  op,.            
-00002da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002db0: 2020 2020 2020 2020 656c 6563 7472 6f64          electrod
-00002dc0: 655f 6c69 7374 3d65 6c65 6374 726f 6465  e_list=electrode
-00002dd0: 5f6c 6973 742c 0a20 2020 2020 2020 2020  _list,.         
-00002de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002df0: 2020 2020 2020 2020 2020 2075 6e69 745f             unit_
-00002e00: 6c69 7374 3d75 6e69 745f 6c69 7374 2c0a  list=unit_list,.
+00002bd0: 2020 7761 726e 696e 6773 2e77 6172 6e28    warnings.warn(
+00002be0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002bf0: 2020 2020 2020 2020 2027 5375 6273 7469           'Substi
+00002c00: 7475 7465 6420 745f 7374 6172 7473 2061  tuted t_starts a
+00002c10: 6e64 2074 5f73 746f 7073 2069 6e20 6f72  nd t_stops in or
+00002c20: 6465 7220 746f 2073 6b69 7020 270a 2020  der to skip '.  
+00002c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002c40: 2020 2020 2020 2767 6170 2069 6e20 7265        'gap in re
+00002c50: 636f 7264 696e 6720 7365 7373 696f 6e2e  cording session.
+00002c60: 2729 0a0a 2020 2020 2020 2020 2320 6c6f  ')..        # lo
+00002c70: 6164 696e 6720 616c 6c20 6368 616e 6e65  ading all channe
+00002c80: 6c73 2069 6620 656d 7074 7920 656c 6563  ls if empty elec
+00002c90: 7472 6f64 655f 6c69 7374 0a20 2020 2020  trode_list.     
+00002ca0: 2020 2069 6620 656c 6563 7472 6f64 655f     if electrode_
+00002cb0: 6c69 7374 203d 3d20 5b5d 206f 7220 656c  list == [] or el
+00002cc0: 6563 7472 6f64 655f 6c69 7374 2069 7320  ectrode_list is 
+00002cd0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00002ce0: 2020 656c 6563 7472 6f64 655f 6c69 7374    electrode_list
+00002cf0: 203d 2073 656c 662e 7061 7261 6d65 7465   = self.paramete
+00002d00: 7273 5f6e 6373 2e6b 6579 7328 290a 0a20  rs_ncs.keys().. 
+00002d10: 2020 2020 2020 2023 2061 6464 696e 6720         # adding 
+00002d20: 6120 7365 676d 656e 7420 666f 7220 6561  a segment for ea
+00002d30: 6368 2074 5f73 7461 7274 2c20 745f 7374  ch t_start, t_st
+00002d40: 6f70 2070 6169 720a 2020 2020 2020 2020  op pair.        
+00002d50: 666f 7220 745f 7374 6172 742c 2074 5f73  for t_start, t_s
+00002d60: 746f 7020 696e 207a 6970 2874 5f73 7461  top in zip(t_sta
+00002d70: 7274 732c 2074 5f73 746f 7073 293a 0a20  rts, t_stops):. 
+00002d80: 2020 2020 2020 2020 2020 2073 6567 203d             seg =
+00002d90: 2073 656c 662e 7265 6164 5f73 6567 6d65   self.read_segme
+00002da0: 6e74 286c 617a 793d 6c61 7a79 2c20 6361  nt(lazy=lazy, ca
+00002db0: 7363 6164 653d 6361 7363 6164 652c 0a20  scade=cascade,. 
+00002dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002de0: 2020 2074 5f73 7461 7274 3d74 5f73 7461     t_start=t_sta
+00002df0: 7274 2c20 745f 7374 6f70 3d74 5f73 746f  rt, t_stop=t_sto
+00002e00: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
 00002e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e30: 2020 2020 616e 616c 6f67 7369 676e 616c      analogsignal
-00002e40: 733d 616e 616c 6f67 7369 676e 616c 732c  s=analogsignals,
-00002e50: 2065 7665 6e74 733d 6576 656e 7473 2c0a   events=events,.
-00002e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e80: 2020 2020 7761 7665 666f 726d 733d 7761      waveforms=wa
-00002e90: 7665 666f 726d 7329 0a20 2020 2020 2020  veforms).       
-00002ea0: 2020 2020 2062 6c2e 7365 676d 656e 7473       bl.segments
-00002eb0: 2e61 7070 656e 6428 7365 6729 0a0a 2020  .append(seg)..  
-00002ec0: 2020 2020 2020 2320 6765 6e65 7261 7465        # generate
-00002ed0: 2075 6e69 7473 0a20 2020 2020 2020 2075   units.        u
-00002ee0: 6e69 7473 203d 205b 5d0a 2020 2020 2020  nits = [].      
-00002ef0: 2020 6368 616e 6e65 6c5f 756e 6974 5f63    channel_unit_c
-00002f00: 6f6c 6c65 6374 696f 6e20 3d20 7b7d 0a20  ollection = {}. 
-00002f10: 2020 2020 2020 2066 6f72 2073 7420 696e         for st in
-00002f20: 205b 7320 666f 7220 7365 6720 696e 2062   [s for seg in b
-00002f30: 6c2e 7365 676d 656e 7473 2066 6f72 2073  l.segments for s
-00002f40: 2069 6e20 7365 672e 7370 696b 6574 7261   in seg.spiketra
-00002f50: 696e 735d 3a0a 2020 2020 2020 2020 2020  ins]:.          
-00002f60: 2020 2320 636f 6c6c 6563 7469 6e67 2073    # collecting s
-00002f70: 7069 6b65 7472 6169 6e73 206f 6620 7361  piketrains of sa
-00002f80: 6d65 2063 6861 6e6e 656c 2061 6e64 2075  me channel and u
-00002f90: 6e69 7420 6964 2074 6f20 6765 6e65 7261  nit id to genera
-00002fa0: 7465 0a20 2020 2020 2020 2020 2020 2023  te.            #
-00002fb0: 2063 6f6d 6d6f 6e20 756e 6974 0a20 2020   common unit.   
-00002fc0: 2020 2020 2020 2020 2063 6875 6964 203d           chuid =
-00002fd0: 2028 7374 2e61 6e6e 6f74 6174 696f 6e73   (st.annotations
-00002fe0: 5b27 6368 616e 6e65 6c5f 696e 6465 7827  ['channel_index'
-00002ff0: 5d2c 2073 742e 616e 6e6f 7461 7469 6f6e  ], st.annotation
-00003000: 735b 2775 6e69 745f 6964 275d 290a 2020  s['unit_id']).  
-00003010: 2020 2020 2020 2020 2020 6966 2063 6875            if chu
-00003020: 6964 2069 6e20 6368 616e 6e65 6c5f 756e  id in channel_un
-00003030: 6974 5f63 6f6c 6c65 6374 696f 6e3a 0a20  it_collection:. 
-00003040: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00003050: 6861 6e6e 656c 5f75 6e69 745f 636f 6c6c  hannel_unit_coll
-00003060: 6563 7469 6f6e 5b63 6875 6964 5d2e 6170  ection[chuid].ap
-00003070: 7065 6e64 2873 7429 0a20 2020 2020 2020  pend(st).       
-00003080: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00003090: 2020 2020 2020 2020 2020 2063 6861 6e6e             chann
-000030a0: 656c 5f75 6e69 745f 636f 6c6c 6563 7469  el_unit_collecti
-000030b0: 6f6e 5b63 6875 6964 5d20 3d20 5b73 745d  on[chuid] = [st]
-000030c0: 0a20 2020 2020 2020 2066 6f72 2063 6875  .        for chu
-000030d0: 6964 2069 6e20 6368 616e 6e65 6c5f 756e  id in channel_un
-000030e0: 6974 5f63 6f6c 6c65 6374 696f 6e3a 0a20  it_collection:. 
-000030f0: 2020 2020 2020 2020 2020 2073 7473 203d             sts =
-00003100: 2063 6861 6e6e 656c 5f75 6e69 745f 636f   channel_unit_co
-00003110: 6c6c 6563 7469 6f6e 5b63 6875 6964 5d0a  llection[chuid].
-00003120: 2020 2020 2020 2020 2020 2020 756e 6974              unit
-00003130: 203d 2055 6e69 7428 6e61 6d65 3d27 4368   = Unit(name='Ch
-00003140: 616e 6e65 6c20 2569 2c20 556e 6974 2025  annel %i, Unit %
-00003150: 6927 2025 2063 6875 6964 290a 2020 2020  i' % chuid).    
-00003160: 2020 2020 2020 2020 756e 6974 2e73 7069          unit.spi
-00003170: 6b65 7472 6169 6e73 2e65 7874 656e 6428  ketrains.extend(
-00003180: 7374 7329 0a20 2020 2020 2020 2020 2020  sts).           
-00003190: 2075 6e69 7473 2e61 7070 656e 6428 756e   units.append(un
-000031a0: 6974 290a 0a20 2020 2020 2020 2023 2067  it)..        # g
-000031b0: 656e 6572 6174 6520 6f6e 6520 6368 616e  enerate one chan
-000031c0: 6e65 6c20 696e 6465 7865 7320 666f 7220  nel indexes for 
-000031d0: 6561 6368 2061 6e61 6c6f 6773 6967 6e61  each analogsigna
-000031e0: 6c0a 2020 2020 2020 2020 666f 7220 616e  l.        for an
-000031f0: 6173 6967 2069 6e20 5b61 2066 6f72 2073  asig in [a for s
-00003200: 6567 2069 6e20 626c 2e73 6567 6d65 6e74  eg in bl.segment
-00003210: 7320 666f 7220 6120 696e 2073 6567 2e61  s for a in seg.a
-00003220: 6e61 6c6f 6773 6967 6e61 6c73 5d3a 0a20  nalogsignals]:. 
-00003230: 2020 2020 2020 2020 2020 2063 6861 6e6e             chann
-00003240: 656c 6964 7320 3d20 616e 6173 6967 2e61  elids = anasig.a
-00003250: 6e6e 6f74 6174 696f 6e73 5b27 6368 616e  nnotations['chan
-00003260: 6e65 6c5f 696e 6465 7827 5d0a 2020 2020  nel_index'].    
-00003270: 2020 2020 2020 2020 6368 616e 6e65 6c5f          channel_
-00003280: 6e61 6d65 7320 3d20 5b27 6368 616e 6e65  names = ['channe
-00003290: 6c20 2569 2720 2520 6920 666f 7220 6920  l %i' % i for i 
-000032a0: 696e 2063 6861 6e6e 656c 6964 735d 0a20  in channelids]. 
-000032b0: 2020 2020 2020 2020 2020 2063 6861 6e6e             chann
-000032c0: 656c 6964 7820 3d20 4368 616e 6e65 6c49  elidx = ChannelI
-000032d0: 6e64 6578 2869 6e64 6578 3d72 616e 6765  ndex(index=range
-000032e0: 286c 656e 2863 6861 6e6e 656c 6964 7329  (len(channelids)
-000032f0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00003300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003310: 2020 2020 2020 2020 2063 6861 6e6e 656c           channel
-00003320: 5f6e 616d 6573 3d63 6861 6e6e 656c 5f6e  _names=channel_n
-00003330: 616d 6573 2c0a 2020 2020 2020 2020 2020  ames,.          
-00003340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003350: 2020 2020 2020 2020 2020 2020 6e61 6d65              name
-00003360: 3d27 6368 616e 6e65 6c20 6964 7320 666f  ='channel ids fo
-00003370: 7220 616c 6c20 616e 616c 6f67 7369 676e  r all analogsign
-00003380: 616c 2027 0a20 2020 2020 2020 2020 2020  al '.           
-00003390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000033a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000033b0: 2722 2573 2227 2025 2061 6e61 7369 672e  '"%s"' % anasig.
-000033c0: 6e61 6d65 2c0a 2020 2020 2020 2020 2020  name,.          
-000033d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000033e0: 2020 2020 2020 2020 2020 2020 6368 616e              chan
-000033f0: 6e65 6c5f 6964 733d 6368 616e 6e65 6c69  nel_ids=channeli
-00003400: 6473 290a 2020 2020 2020 2020 2020 2020  ds).            
-00003410: 6368 616e 6e65 6c69 6478 2e61 6e61 6c6f  channelidx.analo
-00003420: 6773 6967 6e61 6c73 2e61 7070 656e 6428  gsignals.append(
-00003430: 616e 6173 6967 290a 2020 2020 2020 2020  anasig).        
-00003440: 2020 2020 626c 2e63 6861 6e6e 656c 5f69      bl.channel_i
-00003450: 6e64 6578 6573 2e61 7070 656e 6428 6368  ndexes.append(ch
-00003460: 616e 6e65 6c69 6478 290a 0a20 2020 2020  annelidx)..     
-00003470: 2020 2023 2067 656e 6572 6174 6520 6368     # generate ch
-00003480: 616e 6e65 6c20 696e 6465 7865 7320 666f  annel indexes fo
-00003490: 7220 756e 6974 730a 2020 2020 2020 2020  r units.        
-000034a0: 6368 616e 6e65 6c69 6473 203d 205b 756e  channelids = [un
-000034b0: 6974 2e73 7069 6b65 7472 6169 6e73 5b30  it.spiketrains[0
-000034c0: 5d2e 616e 6e6f 7461 7469 6f6e 735b 2763  ].annotations['c
-000034d0: 6861 6e6e 656c 5f69 6e64 6578 275d 0a20  hannel_index']. 
-000034e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000034f0: 2020 2020 2066 6f72 2075 6e69 7420 696e       for unit in
-00003500: 2075 6e69 7473 5d0a 2020 2020 2020 2020   units].        
-00003510: 6368 616e 6e65 6c5f 6e61 6d65 7320 3d20  channel_names = 
-00003520: 5b27 6368 616e 6e65 6c20 2569 2720 2520  ['channel %i' % 
-00003530: 6920 666f 7220 6920 696e 2063 6861 6e6e  i for i in chann
-00003540: 656c 6964 735d 0a20 2020 2020 2020 2063  elids].        c
-00003550: 6861 6e6e 656c 6964 7820 3d20 4368 616e  hannelidx = Chan
-00003560: 6e65 6c49 6e64 6578 2869 6e64 6578 3d72  nelIndex(index=r
-00003570: 616e 6765 286c 656e 2863 6861 6e6e 656c  ange(len(channel
-00003580: 6964 7329 292c 0a20 2020 2020 2020 2020  ids)),.         
-00003590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000035a0: 2020 2020 2020 2020 2063 6861 6e6e 656c           channel
-000035b0: 5f6e 616d 6573 3d63 6861 6e6e 656c 5f6e  _names=channel_n
-000035c0: 616d 6573 2c0a 2020 2020 2020 2020 2020  ames,.          
-000035d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000035e0: 2020 2020 2020 2020 6e61 6d65 3d27 6368          name='ch
-000035f0: 616e 6e65 6c20 6964 7320 666f 7220 616c  annel ids for al
-00003600: 6c20 7370 696b 6574 7261 696e 7327 2c0a  l spiketrains',.
-00003610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003630: 2020 6368 616e 6e65 6c5f 6964 733d 6368    channel_ids=ch
-00003640: 616e 6e65 6c69 6473 290a 2020 2020 2020  annelids).      
-00003650: 2020 6368 616e 6e65 6c69 6478 2e75 6e69    channelidx.uni
-00003660: 7473 2e65 7874 656e 6428 756e 6974 7329  ts.extend(units)
-00003670: 0a20 2020 2020 2020 2062 6c2e 6368 616e  .        bl.chan
-00003680: 6e65 6c5f 696e 6465 7865 732e 6170 7065  nel_indexes.appe
-00003690: 6e64 2863 6861 6e6e 656c 6964 7829 0a20  nd(channelidx). 
-000036a0: 2020 2020 2020 2062 6c2e 6372 6561 7465         bl.create
-000036b0: 5f6d 616e 795f 746f 5f6f 6e65 5f72 656c  _many_to_one_rel
-000036c0: 6174 696f 6e73 6869 7028 290a 0a20 2020  ationship()..   
-000036d0: 2020 2020 2023 2041 6464 696e 6720 676c       # Adding gl
-000036e0: 6f62 616c 2070 6172 616d 6574 6572 7320  obal parameters 
-000036f0: 746f 2062 6c6f 636b 2061 6e6e 6f74 6174  to block annotat
-00003700: 696f 6e0a 2020 2020 2020 2020 626c 2e61  ion.        bl.a
-00003710: 6e6e 6f74 6174 696f 6e73 2e75 7064 6174  nnotations.updat
-00003720: 6528 7365 6c66 2e70 6172 616d 6574 6572  e(self.parameter
-00003730: 735f 676c 6f62 616c 290a 0a20 2020 2020  s_global)..     
-00003740: 2020 2072 6574 7572 6e20 626c 0a0a 2020     return bl..  
-00003750: 2020 6465 6620 7265 6164 5f73 6567 6d65    def read_segme
-00003760: 6e74 2873 656c 662c 206c 617a 793d 4661  nt(self, lazy=Fa
-00003770: 6c73 652c 2063 6173 6361 6465 3d54 7275  lse, cascade=Tru
-00003780: 652c 2074 5f73 7461 7274 3d4e 6f6e 652c  e, t_start=None,
-00003790: 2074 5f73 746f 703d 4e6f 6e65 2c0a 2020   t_stop=None,.  
-000037a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000037b0: 2020 2065 6c65 6374 726f 6465 5f6c 6973     electrode_lis
-000037c0: 743d 4e6f 6e65 2c20 756e 6974 5f6c 6973  t=None, unit_lis
-000037d0: 743d 4e6f 6e65 2c20 616e 616c 6f67 7369  t=None, analogsi
-000037e0: 676e 616c 733d 5472 7565 2c0a 2020 2020  gnals=True,.    
-000037f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003800: 2065 7665 6e74 733d 4661 6c73 652c 2077   events=False, w
-00003810: 6176 6566 6f72 6d73 3d46 616c 7365 293a  aveforms=False):
-00003820: 0a20 2020 2020 2020 2022 2222 5265 6164  .        """Read
-00003830: 7320 6f6e 6520 5365 676d 656e 742e 0a0a  s one Segment...
-00003840: 2020 2020 2020 2020 5468 6520 5365 676d          The Segm
-00003850: 656e 7420 7769 6c6c 2063 6f6e 7461 696e  ent will contain
-00003860: 206f 6e65 2041 6e61 6c6f 6753 6967 6e61   one AnalogSigna
-00003870: 6c20 666f 7220 6561 6368 2063 6861 6e6e  l for each chann
-00003880: 656c 0a20 2020 2020 2020 2061 6e64 2077  el.        and w
-00003890: 696c 6c20 676f 2066 726f 6d20 745f 7374  ill go from t_st
-000038a0: 6172 7420 746f 2074 5f73 746f 702e 0a0a  art to t_stop...
-000038b0: 2020 2020 2020 2020 4172 6775 6d65 6e74          Argument
-000038c0: 733a 0a0a 0a20 2020 2020 2020 2020 2020  s:...           
-000038d0: 206c 617a 7920 3a20 506f 7374 706f 6e65   lazy : Postpone
-000038e0: 2061 6374 7561 6c20 7265 6164 696e 6720   actual reading 
-000038f0: 6f66 2074 6865 2064 6174 6120 6669 6c65  of the data file
-00003900: 732e 2044 6566 6175 6c74 2027 4661 6c73  s. Default 'Fals
-00003910: 6527 2e0a 2020 2020 2020 2020 2020 2020  e'..            
-00003920: 6361 7363 6164 6520 3a20 446f 206e 6f74  cascade : Do not
-00003930: 2070 6f73 7470 6f6e 6520 7265 6164 696e   postpone readin
-00003940: 6720 7375 6273 6571 7565 6e74 206e 656f  g subsequent neo
-00003950: 2074 7970 6573 2028 5370 696b 6554 7261   types (SpikeTra
-00003960: 696e 732c 0a20 2020 2020 2020 2020 2020  ins,.           
-00003970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003980: 2041 6e61 6c6f 6753 6967 6e61 6c73 2c20   AnalogSignals, 
-00003990: 4576 656e 7473 292e 0a20 2020 2020 2020  Events)..       
-000039a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000039b0: 2020 2020 2044 6566 6175 6c74 2027 5472       Default 'Tr
-000039c0: 7565 272e 0a20 2020 2020 2020 2020 2020  ue'..           
-000039d0: 2074 5f73 7461 7274 203a 2074 696d 6520   t_start : time 
-000039e0: 2871 7561 6e74 6974 7929 2074 6861 7420  (quantity) that 
-000039f0: 7468 6520 5365 676d 656e 7420 6265 6769  the Segment begi
-00003a00: 6e73 2e20 4465 6661 756c 7420 4e6f 6e65  ns. Default None
-00003a10: 2e0a 2020 2020 2020 2020 2020 2020 745f  ..            t_
-00003a20: 7374 6f70 203a 2074 696d 6520 2871 7561  stop : time (qua
-00003a30: 6e74 6974 7929 2074 6861 7420 7468 6520  ntity) that the 
-00003a40: 5365 676d 656e 7420 656e 6473 2e20 4465  Segment ends. De
-00003a50: 6661 756c 7420 4e6f 6e65 2e0a 2020 2020  fault None..    
-00003a60: 2020 2020 2020 2020 656c 6563 7472 6f64          electrod
-00003a70: 655f 6c69 7374 203a 206c 6973 7420 6f66  e_list : list of
-00003a80: 2069 6e74 6567 6572 7320 636f 6e74 6169   integers contai
-00003a90: 6e69 6e67 2074 6865 2049 4473 206f 6620  ning the IDs of 
-00003aa0: 7468 650a 2020 2020 2020 2020 2020 2020  the.            
-00003ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003ac0: 7265 7175 6573 7465 6420 746f 206c 6f61  requested to loa
-00003ad0: 642e 2049 6620 5b5d 206f 7220 4e6f 6e65  d. If [] or None
-00003ae0: 2061 6c6c 2061 7661 696c 6162 6c65 0a20   all available. 
-00003af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003b00: 2020 2020 2020 2020 2020 2063 6861 6e6e             chann
-00003b10: 656c 7320 7769 6c6c 2062 6520 6c6f 6164  els will be load
-00003b20: 6564 2e0a 2020 2020 2020 2020 2020 2020  ed..            
-00003b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003b40: 4465 6661 756c 743a 204e 6f6e 652e 0a20  Default: None.. 
-00003b50: 2020 2020 2020 2020 2020 2075 6e69 745f             unit_
-00003b60: 6c69 7374 203a 206c 6973 7420 6f66 2069  list : list of i
-00003b70: 6e74 6567 6572 7320 636f 6e74 6169 6e69  ntegers containi
-00003b80: 6e67 2074 6865 2049 4473 206f 6620 7468  ng the IDs of th
-00003b90: 6520 7265 7175 6573 7465 640a 2020 2020  e requested.    
-00003ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003bb0: 2020 2020 2020 2020 756e 6974 7320 746f          units to
-00003bc0: 206c 6f61 642e 2049 6620 5b5d 206f 7220   load. If [] or 
-00003bd0: 4e6f 6e65 2061 6c6c 2061 7661 696c 6162  None all availab
-00003be0: 6c65 2075 6e69 7473 0a20 2020 2020 2020  le units.       
-00003bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003c00: 2020 2020 2077 696c 6c20 6265 206c 6f61       will be loa
-00003c10: 6465 642e 2049 6620 4661 6c73 652c 206e  ded. If False, n
-00003c20: 6f20 756e 6974 2077 696c 6c20 6265 206c  o unit will be l
-00003c30: 6f61 6465 642e 0a20 2020 2020 2020 2020  oaded..         
-00003c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003c50: 2020 2044 6566 6175 6c74 3a20 4e6f 6e65     Default: None
-00003c60: 2e0a 2020 2020 2020 2020 2020 2020 616e  ..            an
-00003c70: 616c 6f67 7369 676e 616c 7320 3a20 626f  alogsignals : bo
-00003c80: 6f6c 6561 6e2c 2069 6e64 6963 6174 696f  olean, indicatio
-00003c90: 6e20 7768 6574 6865 7220 616e 616c 6f67  n whether analog
-00003ca0: 7369 676e 616c 7320 7368 6f75 6c64 2062  signals should b
-00003cb0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00003cc0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00003cd0: 6164 2e20 4465 6661 756c 743a 2054 7275  ad. Default: Tru
-00003ce0: 652e 0a20 2020 2020 2020 2020 2020 2065  e..            e
-00003cf0: 7665 6e74 7320 3a20 4c6f 6164 696e 6720  vents : Loading 
-00003d00: 6576 656e 7473 2e20 4966 2054 7275 6520  events. If True 
-00003d10: 616c 6c20 6176 6169 6c61 626c 6520 6576  all available ev
-00003d20: 656e 7473 2069 6e20 7468 6520 6769 7665  ents in the give
-00003d30: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
-00003d40: 2020 2020 2020 2020 2020 2020 2020 7469                ti
-00003d50: 6d65 2077 696e 646f 7720 7769 6c6c 2062  me window will b
-00003d60: 6520 7265 6164 2e20 4465 6661 756c 743a  e read. Default:
-00003d70: 2046 616c 7365 2e0a 2020 2020 2020 2020   False..        
-00003d80: 2020 2020 7761 7665 666f 726d 7320 3a20      waveforms : 
-00003d90: 4c6f 6164 2077 6176 6566 6f72 6d20 666f  Load waveform fo
-00003da0: 7220 7370 696b 6573 2069 6e20 7468 6520  r spikes in the 
-00003db0: 7265 7175 6573 7465 6420 7469 6d65 0a20  requested time. 
-00003dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003dd0: 2020 2020 2020 2020 2020 2077 696e 646f             windo
-00003de0: 772e 2044 6566 6175 6c74 3a20 4661 6c73  w. Default: Fals
-00003df0: 652e 0a0a 0a20 2020 2020 2020 2052 6574  e....        Ret
-00003e00: 7572 6e73 3a0a 2020 2020 2020 2020 2020  urns:.          
-00003e10: 2020 5365 676d 656e 7420 6f62 6a65 6374    Segment object
-00003e20: 2063 6f6e 7461 696e 696e 6720 6e65 6f20   containing neo 
-00003e30: 6f62 6a65 6374 732c 2077 6869 6368 2063  objects, which c
-00003e40: 6f6e 7461 696e 2074 6865 2064 6174 612e  ontain the data.
-00003e50: 0a20 2020 2020 2020 2022 2222 0a0a 2020  .        """..  
-00003e60: 2020 2020 2020 2320 696e 7075 7420 6368        # input ch
-00003e70: 6563 6b0a 2020 2020 2020 2020 2320 6c6f  eck.        # lo
-00003e80: 6164 696e 6720 616c 6c20 6368 616e 6e65  ading all channe
-00003e90: 6c73 2069 6620 656d 7074 7920 656c 6563  ls if empty elec
-00003ea0: 7472 6f64 655f 6c69 7374 0a20 2020 2020  trode_list.     
-00003eb0: 2020 2069 6620 656c 6563 7472 6f64 655f     if electrode_
-00003ec0: 6c69 7374 203d 3d20 5b5d 206f 7220 656c  list == [] or el
-00003ed0: 6563 7472 6f64 655f 6c69 7374 2069 7320  ectrode_list is 
-00003ee0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-00003ef0: 2020 656c 6563 7472 6f64 655f 6c69 7374    electrode_list
-00003f00: 203d 2073 656c 662e 7061 7261 6d65 7465   = self.paramete
-00003f10: 7273 5f6e 6373 2e6b 6579 7328 290a 2020  rs_ncs.keys().  
-00003f20: 2020 2020 2020 656c 6966 2065 6c65 6374        elif elect
-00003f30: 726f 6465 5f6c 6973 7420 6973 204e 6f6e  rode_list is Non
-00003f40: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-00003f50: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00003f60: 2745 6c65 6374 726f 6465 5f6c 6973 7420  'Electrode_list 
-00003f70: 6361 6e20 6e6f 7420 6265 204e 6f6e 652e  can not be None.
-00003f80: 2729 0a20 2020 2020 2020 2065 6c69 6620  ').        elif 
-00003f90: 5b76 2066 6f72 2076 2069 6e20 656c 6563  [v for v in elec
-00003fa0: 7472 6f64 655f 6c69 7374 2069 660a 2020  trode_list if.  
-00003fb0: 2020 2020 2020 2020 2020 2020 7620 696e              v in
-00003fc0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-00003fd0: 5f6e 6373 2e6b 6579 7328 295d 203d 3d20  _ncs.keys()] == 
-00003fe0: 5b5d 3a0a 2020 2020 2020 2020 2020 2020  []:.            
-00003ff0: 2320 7761 726e 2069 6620 6e6f 6e20 6f66  # warn if non of
-00004000: 2074 6865 2072 6571 7565 7374 6564 2063   the requested c
-00004010: 6861 6e6e 656c 7320 6172 6520 7072 6573  hannels are pres
-00004020: 656e 7420 696e 2074 6869 7320 7365 7373  ent in this sess
-00004030: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-00004040: 7761 726e 696e 6773 2e77 6172 6e28 2752  warnings.warn('R
-00004050: 6571 7565 7374 6564 2063 6861 6e6e 656c  equested channel
-00004060: 7320 2573 2061 7265 206e 6f74 2070 7265  s %s are not pre
-00004070: 7365 6e74 2069 6e20 7365 7373 696f 6e20  sent in session 
-00004080: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
-00004090: 2020 2020 2020 2020 2020 2020 2728 636f              '(co
-000040a0: 6e74 6169 6e73 206f 6e6c 7920 2573 2927  ntains only %s)'
-000040b0: 2025 2028 0a20 2020 2020 2020 2020 2020   % (.           
-000040c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000040d0: 2020 2065 6c65 6374 726f 6465 5f6c 6973     electrode_lis
-000040e0: 742c 2073 656c 662e 7061 7261 6d65 7465  t, self.paramete
-000040f0: 7273 5f6e 6373 2e6b 6579 7328 2929 290a  rs_ncs.keys())).
-00004100: 2020 2020 2020 2020 2020 2020 656c 6563              elec
-00004110: 7472 6f64 655f 6c69 7374 203d 205b 5d0a  trode_list = [].
-00004120: 0a20 2020 2020 2020 2073 6567 203d 2053  .        seg = S
-00004130: 6567 6d65 6e74 2866 696c 655f 6f72 6967  egment(file_orig
-00004140: 696e 3d73 656c 662e 6669 6c65 6e61 6d65  in=self.filename
-00004150: 290a 2020 2020 2020 2020 6966 206e 6f74  ).        if not
-00004160: 2063 6173 6361 6465 3a0a 2020 2020 2020   cascade:.      
-00004170: 2020 2020 2020 7265 7475 726e 2073 6567        return seg
-00004180: 0a0a 2020 2020 2020 2020 2320 6765 6e65  ..        # gene
-00004190: 7261 7465 2065 6d70 7479 2073 6567 6d65  rate empty segme
-000041a0: 6e74 2066 6f72 2061 6e61 6c6f 6773 6967  nt for analogsig
-000041b0: 6e61 6c20 636f 6c6c 6563 7469 6f6e 0a20  nal collection. 
-000041c0: 2020 2020 2020 2065 6d70 7479 5f73 6567         empty_seg
-000041d0: 203d 2053 6567 6d65 6e74 2866 696c 655f   = Segment(file_
-000041e0: 6f72 6967 696e 3d73 656c 662e 6669 6c65  origin=self.file
-000041f0: 6e61 6d65 290a 0a20 2020 2020 2020 2023  name)..        #
-00004200: 2052 6561 6469 6e67 204e 4353 2046 696c   Reading NCS Fil
-00004210: 6573 2023 0a20 2020 2020 2020 2023 2073  es #.        # s
-00004220: 656c 6563 7469 6e67 206e 6373 2066 696c  electing ncs fil
-00004230: 6573 2074 6f20 6c6f 6164 2062 6173 6564  es to load based
-00004240: 206f 6e20 656c 6563 7472 6f64 655f 6c69   on electrode_li
-00004250: 7374 2072 6571 7565 7374 6564 0a20 2020  st requested.   
-00004260: 2020 2020 2069 6620 616e 616c 6f67 7369       if analogsi
-00004270: 676e 616c 733a 0a20 2020 2020 2020 2020  gnals:.         
-00004280: 2020 2066 6f72 2063 6869 6420 696e 2065     for chid in e
-00004290: 6c65 6374 726f 6465 5f6c 6973 743a 0a20  lectrode_list:. 
-000042a0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000042b0: 6620 6368 6964 2069 6e20 7365 6c66 2e70  f chid in self.p
-000042c0: 6172 616d 6574 6572 735f 6e63 733a 0a20  arameters_ncs:. 
-000042d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000042e0: 2020 2066 696c 655f 6e63 7320 3d20 7365     file_ncs = se
-000042f0: 6c66 2e70 6172 616d 6574 6572 735f 6e63  lf.parameters_nc
-00004300: 735b 6368 6964 5d5b 2766 696c 656e 616d  s[chid]['filenam
-00004310: 6527 5d0a 2020 2020 2020 2020 2020 2020  e'].            
-00004320: 2020 2020 2020 2020 7365 6c66 2e72 6561          self.rea
-00004330: 645f 6e63 7328 6669 6c65 5f6e 6373 2c20  d_ncs(file_ncs, 
-00004340: 656d 7074 795f 7365 672c 206c 617a 792c  empty_seg, lazy,
-00004350: 2063 6173 6361 6465 2c0a 2020 2020 2020   cascade,.      
-00004360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004370: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
-00004380: 6172 743d 745f 7374 6172 742c 2074 5f73  art=t_start, t_s
-00004390: 746f 703d 745f 7374 6f70 290a 2020 2020  top=t_stop).    
-000043a0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-000043b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000043c0: 2020 2020 2020 7365 6c66 2e5f 6469 6167        self._diag
-000043d0: 6e6f 7374 6963 5f70 7269 6e74 2827 4361  nostic_print('Ca
-000043e0: 6e20 6e6f 7420 6c6f 6164 206e 6373 206f  n not load ncs o
-000043f0: 6620 6368 616e 6e65 6c20 2569 2e20 270a  f channel %i. '.
-00004400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004420: 2020 2020 2020 2020 2020 2027 4e6f 2063             'No c
-00004430: 6f72 7265 7370 6f6e 6469 6e67 206e 6373  orresponding ncs
-00004440: 2066 696c 6520 270a 2020 2020 2020 2020   file '.        
-00004450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004470: 2020 2027 7072 6573 656e 742e 2720 2520     'present.' % 
-00004480: 2863 6869 6429 290a 0a20 2020 2020 2020  (chid))..       
-00004490: 2020 2020 2023 2073 7570 706c 656d 656e       # supplemen
-000044a0: 746f 7279 206d 6572 6765 2066 756e 6374  tory merge funct
-000044b0: 696f 6e2c 2073 686f 756c 6420 6265 2072  ion, should be r
-000044c0: 6570 6c61 6365 6420 6279 206e 656f 2075  eplaced by neo u
-000044d0: 7469 6c69 7479 0a20 2020 2020 2020 2020  tility.         
-000044e0: 2020 2023 2020 6675 6e63 7469 6f6e 0a20     #  function. 
-000044f0: 2020 2020 2020 2020 2020 2064 6566 206d             def m
-00004500: 6572 6765 5f61 6e61 6c6f 6773 6967 6e61  erge_analogsigna
-00004510: 6c73 2861 6e61 7369 675f 6c69 7374 293a  ls(anasig_list):
-00004520: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004530: 2066 6f72 2061 6964 2c20 616e 6173 6967   for aid, anasig
-00004540: 2069 6e20 656e 756d 6572 6174 6528 616e   in enumerate(an
-00004550: 6173 6967 5f6c 6973 7429 3a0a 2020 2020  asig_list):.    
-00004560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004570: 616e 6173 6967 2e63 6861 6e6e 656c 5f69  anasig.channel_i
-00004580: 6e64 6578 203d 204e 6f6e 650a 2020 2020  ndex = None.    
+00002e20: 2020 2020 2020 2065 6c65 6374 726f 6465         electrode
+00002e30: 5f6c 6973 743d 656c 6563 7472 6f64 655f  _list=electrode_
+00002e40: 6c69 7374 2c0a 2020 2020 2020 2020 2020  list,.          
+00002e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002e60: 2020 2020 2020 2020 2020 756e 6974 5f6c            unit_l
+00002e70: 6973 743d 756e 6974 5f6c 6973 742c 0a20  ist=unit_list,. 
+00002e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ea0: 2020 2061 6e61 6c6f 6773 6967 6e61 6c73     analogsignals
+00002eb0: 3d61 6e61 6c6f 6773 6967 6e61 6c73 2c20  =analogsignals, 
+00002ec0: 6576 656e 7473 3d65 7665 6e74 732c 0a20  events=events,. 
+00002ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ef0: 2020 2077 6176 6566 6f72 6d73 3d77 6176     waveforms=wav
+00002f00: 6566 6f72 6d73 290a 2020 2020 2020 2020  eforms).        
+00002f10: 2020 2020 626c 2e73 6567 6d65 6e74 732e      bl.segments.
+00002f20: 6170 7065 6e64 2873 6567 290a 0a20 2020  append(seg)..   
+00002f30: 2020 2020 2023 2067 656e 6572 6174 6520       # generate 
+00002f40: 756e 6974 730a 2020 2020 2020 2020 756e  units.        un
+00002f50: 6974 7320 3d20 5b5d 0a20 2020 2020 2020  its = [].       
+00002f60: 2063 6861 6e6e 656c 5f75 6e69 745f 636f   channel_unit_co
+00002f70: 6c6c 6563 7469 6f6e 203d 207b 7d0a 2020  llection = {}.  
+00002f80: 2020 2020 2020 666f 7220 7374 2069 6e20        for st in 
+00002f90: 5b73 2066 6f72 2073 6567 2069 6e20 626c  [s for seg in bl
+00002fa0: 2e73 6567 6d65 6e74 7320 666f 7220 7320  .segments for s 
+00002fb0: 696e 2073 6567 2e73 7069 6b65 7472 6169  in seg.spiketrai
+00002fc0: 6e73 5d3a 0a20 2020 2020 2020 2020 2020  ns]:.           
+00002fd0: 2023 2063 6f6c 6c65 6374 696e 6720 7370   # collecting sp
+00002fe0: 696b 6574 7261 696e 7320 6f66 2073 616d  iketrains of sam
+00002ff0: 6520 6368 616e 6e65 6c20 616e 6420 756e  e channel and un
+00003000: 6974 2069 6420 746f 2067 656e 6572 6174  it id to generat
+00003010: 650a 2020 2020 2020 2020 2020 2020 2320  e.            # 
+00003020: 636f 6d6d 6f6e 2075 6e69 740a 2020 2020  common unit.    
+00003030: 2020 2020 2020 2020 6368 7569 6420 3d20          chuid = 
+00003040: 2873 742e 616e 6e6f 7461 7469 6f6e 735b  (st.annotations[
+00003050: 2763 6861 6e6e 656c 5f69 6e64 6578 275d  'channel_index']
+00003060: 2c20 7374 2e61 6e6e 6f74 6174 696f 6e73  , st.annotations
+00003070: 5b27 756e 6974 5f69 6427 5d29 0a20 2020  ['unit_id']).   
+00003080: 2020 2020 2020 2020 2069 6620 6368 7569           if chui
+00003090: 6420 696e 2063 6861 6e6e 656c 5f75 6e69  d in channel_uni
+000030a0: 745f 636f 6c6c 6563 7469 6f6e 3a0a 2020  t_collection:.  
+000030b0: 2020 2020 2020 2020 2020 2020 2020 6368                ch
+000030c0: 616e 6e65 6c5f 756e 6974 5f63 6f6c 6c65  annel_unit_colle
+000030d0: 6374 696f 6e5b 6368 7569 645d 2e61 7070  ction[chuid].app
+000030e0: 656e 6428 7374 290a 2020 2020 2020 2020  end(st).        
+000030f0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00003100: 2020 2020 2020 2020 2020 6368 616e 6e65            channe
+00003110: 6c5f 756e 6974 5f63 6f6c 6c65 6374 696f  l_unit_collectio
+00003120: 6e5b 6368 7569 645d 203d 205b 7374 5d0a  n[chuid] = [st].
+00003130: 2020 2020 2020 2020 666f 7220 6368 7569          for chui
+00003140: 6420 696e 2063 6861 6e6e 656c 5f75 6e69  d in channel_uni
+00003150: 745f 636f 6c6c 6563 7469 6f6e 3a0a 2020  t_collection:.  
+00003160: 2020 2020 2020 2020 2020 7374 7320 3d20            sts = 
+00003170: 6368 616e 6e65 6c5f 756e 6974 5f63 6f6c  channel_unit_col
+00003180: 6c65 6374 696f 6e5b 6368 7569 645d 0a20  lection[chuid]. 
+00003190: 2020 2020 2020 2020 2020 2075 6e69 7420             unit 
+000031a0: 3d20 556e 6974 286e 616d 653d 2743 6861  = Unit(name='Cha
+000031b0: 6e6e 656c 2025 692c 2055 6e69 7420 2569  nnel %i, Unit %i
+000031c0: 2720 2520 6368 7569 6429 0a20 2020 2020  ' % chuid).     
+000031d0: 2020 2020 2020 2075 6e69 742e 7370 696b         unit.spik
+000031e0: 6574 7261 696e 732e 6578 7465 6e64 2873  etrains.extend(s
+000031f0: 7473 290a 2020 2020 2020 2020 2020 2020  ts).            
+00003200: 756e 6974 732e 6170 7065 6e64 2875 6e69  units.append(uni
+00003210: 7429 0a0a 2020 2020 2020 2020 2320 6765  t)..        # ge
+00003220: 6e65 7261 7465 206f 6e65 2063 6861 6e6e  nerate one chann
+00003230: 656c 2069 6e64 6578 6573 2066 6f72 2065  el indexes for e
+00003240: 6163 6820 616e 616c 6f67 7369 676e 616c  ach analogsignal
+00003250: 0a20 2020 2020 2020 2066 6f72 2061 6e61  .        for ana
+00003260: 7369 6720 696e 205b 6120 666f 7220 7365  sig in [a for se
+00003270: 6720 696e 2062 6c2e 7365 676d 656e 7473  g in bl.segments
+00003280: 2066 6f72 2061 2069 6e20 7365 672e 616e   for a in seg.an
+00003290: 616c 6f67 7369 676e 616c 735d 3a0a 2020  alogsignals]:.  
+000032a0: 2020 2020 2020 2020 2020 6368 616e 6e65            channe
+000032b0: 6c69 6473 203d 2061 6e61 7369 672e 616e  lids = anasig.an
+000032c0: 6e6f 7461 7469 6f6e 735b 2763 6861 6e6e  notations['chann
+000032d0: 656c 5f69 6e64 6578 275d 0a20 2020 2020  el_index'].     
+000032e0: 2020 2020 2020 2063 6861 6e6e 656c 5f6e         channel_n
+000032f0: 616d 6573 203d 205b 2763 6861 6e6e 656c  ames = ['channel
+00003300: 2025 6927 2025 2069 2066 6f72 2069 2069   %i' % i for i i
+00003310: 6e20 6368 616e 6e65 6c69 6473 5d0a 2020  n channelids].  
+00003320: 2020 2020 2020 2020 2020 6368 616e 6e65            channe
+00003330: 6c69 6478 203d 2043 6861 6e6e 656c 496e  lidx = ChannelIn
+00003340: 6465 7828 696e 6465 783d 7261 6e67 6528  dex(index=range(
+00003350: 6c65 6e28 6368 616e 6e65 6c69 6473 2929  len(channelids))
+00003360: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00003370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003380: 2020 2020 2020 2020 6368 616e 6e65 6c5f          channel_
+00003390: 6e61 6d65 733d 6368 616e 6e65 6c5f 6e61  names=channel_na
+000033a0: 6d65 732c 0a20 2020 2020 2020 2020 2020  mes,.           
+000033b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000033c0: 2020 2020 2020 2020 2020 206e 616d 653d             name=
+000033d0: 2763 6861 6e6e 656c 2069 6473 2066 6f72  'channel ids for
+000033e0: 2061 6c6c 2061 6e61 6c6f 6773 6967 6e61   all analogsigna
+000033f0: 6c20 270a 2020 2020 2020 2020 2020 2020  l '.            
+00003400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003410: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00003420: 2225 7322 2720 2520 616e 6173 6967 2e6e  "%s"' % anasig.n
+00003430: 616d 652c 0a20 2020 2020 2020 2020 2020  ame,.           
+00003440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003450: 2020 2020 2020 2020 2020 2063 6861 6e6e             chann
+00003460: 656c 5f69 6473 3d63 6861 6e6e 656c 6964  el_ids=channelid
+00003470: 7329 0a20 2020 2020 2020 2020 2020 2063  s).            c
+00003480: 6861 6e6e 656c 6964 782e 616e 616c 6f67  hannelidx.analog
+00003490: 7369 676e 616c 732e 6170 7065 6e64 2861  signals.append(a
+000034a0: 6e61 7369 6729 0a20 2020 2020 2020 2020  nasig).         
+000034b0: 2020 2062 6c2e 6368 616e 6e65 6c5f 696e     bl.channel_in
+000034c0: 6465 7865 732e 6170 7065 6e64 2863 6861  dexes.append(cha
+000034d0: 6e6e 656c 6964 7829 0a0a 2020 2020 2020  nnelidx)..      
+000034e0: 2020 2320 6765 6e65 7261 7465 2063 6861    # generate cha
+000034f0: 6e6e 656c 2069 6e64 6578 6573 2066 6f72  nnel indexes for
+00003500: 2075 6e69 7473 0a20 2020 2020 2020 2063   units.        c
+00003510: 6861 6e6e 656c 6964 7320 3d20 5b75 6e69  hannelids = [uni
+00003520: 742e 7370 696b 6574 7261 696e 735b 305d  t.spiketrains[0]
+00003530: 2e61 6e6e 6f74 6174 696f 6e73 5b27 6368  .annotations['ch
+00003540: 616e 6e65 6c5f 696e 6465 7827 5d0a 2020  annel_index'].  
+00003550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003560: 2020 2020 666f 7220 756e 6974 2069 6e20      for unit in 
+00003570: 756e 6974 735d 0a20 2020 2020 2020 2063  units].        c
+00003580: 6861 6e6e 656c 5f6e 616d 6573 203d 205b  hannel_names = [
+00003590: 2763 6861 6e6e 656c 2025 6927 2025 2069  'channel %i' % i
+000035a0: 2066 6f72 2069 2069 6e20 6368 616e 6e65   for i in channe
+000035b0: 6c69 6473 5d0a 2020 2020 2020 2020 6368  lids].        ch
+000035c0: 616e 6e65 6c69 6478 203d 2043 6861 6e6e  annelidx = Chann
+000035d0: 656c 496e 6465 7828 696e 6465 783d 7261  elIndex(index=ra
+000035e0: 6e67 6528 6c65 6e28 6368 616e 6e65 6c69  nge(len(channeli
+000035f0: 6473 2929 2c0a 2020 2020 2020 2020 2020  ds)),.          
+00003600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003610: 2020 2020 2020 2020 6368 616e 6e65 6c5f          channel_
+00003620: 6e61 6d65 733d 6368 616e 6e65 6c5f 6e61  names=channel_na
+00003630: 6d65 732c 0a20 2020 2020 2020 2020 2020  mes,.           
+00003640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003650: 2020 2020 2020 206e 616d 653d 2763 6861         name='cha
+00003660: 6e6e 656c 2069 6473 2066 6f72 2061 6c6c  nnel ids for all
+00003670: 2073 7069 6b65 7472 6169 6e73 272c 0a20   spiketrains',. 
+00003680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000036a0: 2063 6861 6e6e 656c 5f69 6473 3d63 6861   channel_ids=cha
+000036b0: 6e6e 656c 6964 7329 0a20 2020 2020 2020  nnelids).       
+000036c0: 2063 6861 6e6e 656c 6964 782e 756e 6974   channelidx.unit
+000036d0: 732e 6578 7465 6e64 2875 6e69 7473 290a  s.extend(units).
+000036e0: 2020 2020 2020 2020 626c 2e63 6861 6e6e          bl.chann
+000036f0: 656c 5f69 6e64 6578 6573 2e61 7070 656e  el_indexes.appen
+00003700: 6428 6368 616e 6e65 6c69 6478 290a 2020  d(channelidx).  
+00003710: 2020 2020 2020 626c 2e63 7265 6174 655f        bl.create_
+00003720: 6d61 6e79 5f74 6f5f 6f6e 655f 7265 6c61  many_to_one_rela
+00003730: 7469 6f6e 7368 6970 2829 0a0a 2020 2020  tionship()..    
+00003740: 2020 2020 2320 4164 6469 6e67 2067 6c6f      # Adding glo
+00003750: 6261 6c20 7061 7261 6d65 7465 7273 2074  bal parameters t
+00003760: 6f20 626c 6f63 6b20 616e 6e6f 7461 7469  o block annotati
+00003770: 6f6e 0a20 2020 2020 2020 2062 6c2e 616e  on.        bl.an
+00003780: 6e6f 7461 7469 6f6e 732e 7570 6461 7465  notations.update
+00003790: 2873 656c 662e 7061 7261 6d65 7465 7273  (self.parameters
+000037a0: 5f67 6c6f 6261 6c29 0a0a 2020 2020 2020  _global)..      
+000037b0: 2020 7265 7475 726e 2062 6c0a 0a20 2020    return bl..   
+000037c0: 2064 6566 2072 6561 645f 7365 676d 656e   def read_segmen
+000037d0: 7428 7365 6c66 2c20 6c61 7a79 3d46 616c  t(self, lazy=Fal
+000037e0: 7365 2c20 6361 7363 6164 653d 5472 7565  se, cascade=True
+000037f0: 2c20 745f 7374 6172 743d 4e6f 6e65 2c20  , t_start=None, 
+00003800: 745f 7374 6f70 3d4e 6f6e 652c 0a20 2020  t_stop=None,.   
+00003810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003820: 2020 656c 6563 7472 6f64 655f 6c69 7374    electrode_list
+00003830: 3d4e 6f6e 652c 2075 6e69 745f 6c69 7374  =None, unit_list
+00003840: 3d4e 6f6e 652c 2061 6e61 6c6f 6773 6967  =None, analogsig
+00003850: 6e61 6c73 3d54 7275 652c 0a20 2020 2020  nals=True,.     
+00003860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003870: 6576 656e 7473 3d46 616c 7365 2c20 7761  events=False, wa
+00003880: 7665 666f 726d 733d 4661 6c73 6529 3a0a  veforms=False):.
+00003890: 2020 2020 2020 2020 2222 2252 6561 6473          """Reads
+000038a0: 206f 6e65 2053 6567 6d65 6e74 2e0a 0a20   one Segment... 
+000038b0: 2020 2020 2020 2054 6865 2053 6567 6d65         The Segme
+000038c0: 6e74 2077 696c 6c20 636f 6e74 6169 6e20  nt will contain 
+000038d0: 6f6e 6520 416e 616c 6f67 5369 676e 616c  one AnalogSignal
+000038e0: 2066 6f72 2065 6163 6820 6368 616e 6e65   for each channe
+000038f0: 6c0a 2020 2020 2020 2020 616e 6420 7769  l.        and wi
+00003900: 6c6c 2067 6f20 6672 6f6d 2074 5f73 7461  ll go from t_sta
+00003910: 7274 2074 6f20 745f 7374 6f70 2e0a 0a20  rt to t_stop... 
+00003920: 2020 2020 2020 2041 7267 756d 656e 7473         Arguments
+00003930: 3a0a 0a0a 2020 2020 2020 2020 2020 2020  :...            
+00003940: 6c61 7a79 203a 2050 6f73 7470 6f6e 6520  lazy : Postpone 
+00003950: 6163 7475 616c 2072 6561 6469 6e67 206f  actual reading o
+00003960: 6620 7468 6520 6461 7461 2066 696c 6573  f the data files
+00003970: 2e20 4465 6661 756c 7420 2746 616c 7365  . Default 'False
+00003980: 272e 0a20 2020 2020 2020 2020 2020 2063  '..            c
+00003990: 6173 6361 6465 203a 2044 6f20 6e6f 7420  ascade : Do not 
+000039a0: 706f 7374 706f 6e65 2072 6561 6469 6e67  postpone reading
+000039b0: 2073 7562 7365 7175 656e 7420 6e65 6f20   subsequent neo 
+000039c0: 7479 7065 7320 2853 7069 6b65 5472 6169  types (SpikeTrai
+000039d0: 6e73 2c0a 2020 2020 2020 2020 2020 2020  ns,.            
+000039e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000039f0: 416e 616c 6f67 5369 676e 616c 732c 2045  AnalogSignals, E
+00003a00: 7665 6e74 7329 2e0a 2020 2020 2020 2020  vents)..        
+00003a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003a20: 2020 2020 4465 6661 756c 7420 2754 7275      Default 'Tru
+00003a30: 6527 2e0a 2020 2020 2020 2020 2020 2020  e'..            
+00003a40: 745f 7374 6172 7420 3a20 7469 6d65 2028  t_start : time (
+00003a50: 7175 616e 7469 7479 2920 7468 6174 2074  quantity) that t
+00003a60: 6865 2053 6567 6d65 6e74 2062 6567 696e  he Segment begin
+00003a70: 732e 2044 6566 6175 6c74 204e 6f6e 652e  s. Default None.
+00003a80: 0a20 2020 2020 2020 2020 2020 2074 5f73  .            t_s
+00003a90: 746f 7020 3a20 7469 6d65 2028 7175 616e  top : time (quan
+00003aa0: 7469 7479 2920 7468 6174 2074 6865 2053  tity) that the S
+00003ab0: 6567 6d65 6e74 2065 6e64 732e 2044 6566  egment ends. Def
+00003ac0: 6175 6c74 204e 6f6e 652e 0a20 2020 2020  ault None..     
+00003ad0: 2020 2020 2020 2065 6c65 6374 726f 6465         electrode
+00003ae0: 5f6c 6973 7420 3a20 6c69 7374 206f 6620  _list : list of 
+00003af0: 696e 7465 6765 7273 2063 6f6e 7461 696e  integers contain
+00003b00: 696e 6720 7468 6520 4944 7320 6f66 2074  ing the IDs of t
+00003b10: 6865 0a20 2020 2020 2020 2020 2020 2020  he.             
+00003b20: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00003b30: 6571 7565 7374 6564 2074 6f20 6c6f 6164  equested to load
+00003b40: 2e20 4966 205b 5d20 6f72 204e 6f6e 6520  . If [] or None 
+00003b50: 616c 6c20 6176 6169 6c61 626c 650a 2020  all available.  
+00003b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003b70: 2020 2020 2020 2020 2020 6368 616e 6e65            channe
+00003b80: 6c73 2077 696c 6c20 6265 206c 6f61 6465  ls will be loade
+00003b90: 642e 0a20 2020 2020 2020 2020 2020 2020  d..             
+00003ba0: 2020 2020 2020 2020 2020 2020 2020 2044                 D
+00003bb0: 6566 6175 6c74 3a20 4e6f 6e65 2e0a 2020  efault: None..  
+00003bc0: 2020 2020 2020 2020 2020 756e 6974 5f6c            unit_l
+00003bd0: 6973 7420 3a20 6c69 7374 206f 6620 696e  ist : list of in
+00003be0: 7465 6765 7273 2063 6f6e 7461 696e 696e  tegers containin
+00003bf0: 6720 7468 6520 4944 7320 6f66 2074 6865  g the IDs of the
+00003c00: 2072 6571 7565 7374 6564 0a20 2020 2020   requested.     
+00003c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003c20: 2020 2020 2020 2075 6e69 7473 2074 6f20         units to 
+00003c30: 6c6f 6164 2e20 4966 205b 5d20 6f72 204e  load. If [] or N
+00003c40: 6f6e 6520 616c 6c20 6176 6169 6c61 626c  one all availabl
+00003c50: 6520 756e 6974 730a 2020 2020 2020 2020  e units.        
+00003c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003c70: 2020 2020 7769 6c6c 2062 6520 6c6f 6164      will be load
+00003c80: 6564 2e20 4966 2046 616c 7365 2c20 6e6f  ed. If False, no
+00003c90: 2075 6e69 7420 7769 6c6c 2062 6520 6c6f   unit will be lo
+00003ca0: 6164 6564 2e0a 2020 2020 2020 2020 2020  aded..          
+00003cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003cc0: 2020 4465 6661 756c 743a 204e 6f6e 652e    Default: None.
+00003cd0: 0a20 2020 2020 2020 2020 2020 2061 6e61  .            ana
+00003ce0: 6c6f 6773 6967 6e61 6c73 203a 2062 6f6f  logsignals : boo
+00003cf0: 6c65 616e 2c20 696e 6469 6361 7469 6f6e  lean, indication
+00003d00: 2077 6865 7468 6572 2061 6e61 6c6f 6773   whether analogs
+00003d10: 6967 6e61 6c73 2073 686f 756c 6420 6265  ignals should be
+00003d20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003d30: 2020 2020 2020 2020 2020 2020 2072 6561               rea
+00003d40: 642e 2044 6566 6175 6c74 3a20 5472 7565  d. Default: True
+00003d50: 2e0a 2020 2020 2020 2020 2020 2020 6576  ..            ev
+00003d60: 656e 7473 203a 204c 6f61 6469 6e67 2065  ents : Loading e
+00003d70: 7665 6e74 732e 2049 6620 5472 7565 2061  vents. If True a
+00003d80: 6c6c 2061 7661 696c 6162 6c65 2065 7665  ll available eve
+00003d90: 6e74 7320 696e 2074 6865 2067 6976 656e  nts in the given
+00003da0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003db0: 2020 2020 2020 2020 2020 2020 2074 696d               tim
+00003dc0: 6520 7769 6e64 6f77 2077 696c 6c20 6265  e window will be
+00003dd0: 2072 6561 642e 2044 6566 6175 6c74 3a20   read. Default: 
+00003de0: 4661 6c73 652e 0a20 2020 2020 2020 2020  False..         
+00003df0: 2020 2077 6176 6566 6f72 6d73 203a 204c     waveforms : L
+00003e00: 6f61 6420 7761 7665 666f 726d 2066 6f72  oad waveform for
+00003e10: 2073 7069 6b65 7320 696e 2074 6865 2072   spikes in the r
+00003e20: 6571 7565 7374 6564 2074 696d 650a 2020  equested time.  
+00003e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003e40: 2020 2020 2020 2020 2020 7769 6e64 6f77            window
+00003e50: 2e20 4465 6661 756c 743a 2046 616c 7365  . Default: False
+00003e60: 2e0a 0a0a 2020 2020 2020 2020 5265 7475  ....        Retu
+00003e70: 726e 733a 0a20 2020 2020 2020 2020 2020  rns:.           
+00003e80: 2053 6567 6d65 6e74 206f 626a 6563 7420   Segment object 
+00003e90: 636f 6e74 6169 6e69 6e67 206e 656f 206f  containing neo o
+00003ea0: 626a 6563 7473 2c20 7768 6963 6820 636f  bjects, which co
+00003eb0: 6e74 6169 6e20 7468 6520 6461 7461 2e0a  ntain the data..
+00003ec0: 2020 2020 2020 2020 2222 220a 0a20 2020          """..   
+00003ed0: 2020 2020 2023 2069 6e70 7574 2063 6865       # input che
+00003ee0: 636b 0a20 2020 2020 2020 2023 206c 6f61  ck.        # loa
+00003ef0: 6469 6e67 2061 6c6c 2063 6861 6e6e 656c  ding all channel
+00003f00: 7320 6966 2065 6d70 7479 2065 6c65 6374  s if empty elect
+00003f10: 726f 6465 5f6c 6973 740a 2020 2020 2020  rode_list.      
+00003f20: 2020 6966 2065 6c65 6374 726f 6465 5f6c    if electrode_l
+00003f30: 6973 7420 3d3d 205b 5d20 6f72 2065 6c65  ist == [] or ele
+00003f40: 6374 726f 6465 5f6c 6973 7420 6973 204e  ctrode_list is N
+00003f50: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00003f60: 2065 6c65 6374 726f 6465 5f6c 6973 7420   electrode_list 
+00003f70: 3d20 7365 6c66 2e70 6172 616d 6574 6572  = self.parameter
+00003f80: 735f 6e63 732e 6b65 7973 2829 0a20 2020  s_ncs.keys().   
+00003f90: 2020 2020 2065 6c69 6620 656c 6563 7472       elif electr
+00003fa0: 6f64 655f 6c69 7374 2069 7320 4e6f 6e65  ode_list is None
+00003fb0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+00003fc0: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
+00003fd0: 456c 6563 7472 6f64 655f 6c69 7374 2063  Electrode_list c
+00003fe0: 616e 206e 6f74 2062 6520 4e6f 6e65 2e27  an not be None.'
+00003ff0: 290a 2020 2020 2020 2020 656c 6966 205b  ).        elif [
+00004000: 7620 666f 7220 7620 696e 2065 6c65 6374  v for v in elect
+00004010: 726f 6465 5f6c 6973 7420 6966 0a20 2020  rode_list if.   
+00004020: 2020 2020 2020 2020 2020 2076 2069 6e20             v in 
+00004030: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00004040: 6e63 732e 6b65 7973 2829 5d20 3d3d 205b  ncs.keys()] == [
+00004050: 5d3a 0a20 2020 2020 2020 2020 2020 2023  ]:.            #
+00004060: 2077 6172 6e20 6966 206e 6f6e 206f 6620   warn if non of 
+00004070: 7468 6520 7265 7175 6573 7465 6420 6368  the requested ch
+00004080: 616e 6e65 6c73 2061 7265 2070 7265 7365  annels are prese
+00004090: 6e74 2069 6e20 7468 6973 2073 6573 7369  nt in this sessi
+000040a0: 6f6e 0a20 2020 2020 2020 2020 2020 2077  on.            w
+000040b0: 6172 6e69 6e67 732e 7761 726e 2827 5265  arnings.warn('Re
+000040c0: 7175 6573 7465 6420 6368 616e 6e65 6c73  quested channels
+000040d0: 2025 7320 6172 6520 6e6f 7420 7072 6573   %s are not pres
+000040e0: 656e 7420 696e 2073 6573 7369 6f6e 2027  ent in session '
+000040f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004100: 2020 2020 2020 2020 2020 2027 2863 6f6e             '(con
+00004110: 7461 696e 7320 6f6e 6c79 2025 7329 2720  tains only %s)' 
+00004120: 2520 280a 2020 2020 2020 2020 2020 2020  % (.            
+00004130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004140: 2020 656c 6563 7472 6f64 655f 6c69 7374    electrode_list
+00004150: 2c20 7365 6c66 2e70 6172 616d 6574 6572  , self.parameter
+00004160: 735f 6e63 732e 6b65 7973 2829 2929 0a20  s_ncs.keys())). 
+00004170: 2020 2020 2020 2020 2020 2065 6c65 6374             elect
+00004180: 726f 6465 5f6c 6973 7420 3d20 5b5d 0a0a  rode_list = []..
+00004190: 2020 2020 2020 2020 7365 6720 3d20 5365          seg = Se
+000041a0: 676d 656e 7428 6669 6c65 5f6f 7269 6769  gment(file_origi
+000041b0: 6e3d 7365 6c66 2e66 696c 656e 616d 6529  n=self.filename)
+000041c0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
+000041d0: 6361 7363 6164 653a 0a20 2020 2020 2020  cascade:.       
+000041e0: 2020 2020 2072 6574 7572 6e20 7365 670a       return seg.
+000041f0: 0a20 2020 2020 2020 2023 2067 656e 6572  .        # gener
+00004200: 6174 6520 656d 7074 7920 7365 676d 656e  ate empty segmen
+00004210: 7420 666f 7220 616e 616c 6f67 7369 676e  t for analogsign
+00004220: 616c 2063 6f6c 6c65 6374 696f 6e0a 2020  al collection.  
+00004230: 2020 2020 2020 656d 7074 795f 7365 6720        empty_seg 
+00004240: 3d20 5365 676d 656e 7428 6669 6c65 5f6f  = Segment(file_o
+00004250: 7269 6769 6e3d 7365 6c66 2e66 696c 656e  rigin=self.filen
+00004260: 616d 6529 0a0a 2020 2020 2020 2020 2320  ame)..        # 
+00004270: 5265 6164 696e 6720 4e43 5320 4669 6c65  Reading NCS File
+00004280: 7320 230a 2020 2020 2020 2020 2320 7365  s #.        # se
+00004290: 6c65 6374 696e 6720 6e63 7320 6669 6c65  lecting ncs file
+000042a0: 7320 746f 206c 6f61 6420 6261 7365 6420  s to load based 
+000042b0: 6f6e 2065 6c65 6374 726f 6465 5f6c 6973  on electrode_lis
+000042c0: 7420 7265 7175 6573 7465 640a 2020 2020  t requested.    
+000042d0: 2020 2020 6966 2061 6e61 6c6f 6773 6967      if analogsig
+000042e0: 6e61 6c73 3a0a 2020 2020 2020 2020 2020  nals:.          
+000042f0: 2020 666f 7220 6368 6964 2069 6e20 656c    for chid in el
+00004300: 6563 7472 6f64 655f 6c69 7374 3a0a 2020  ectrode_list:.  
+00004310: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00004320: 2063 6869 6420 696e 2073 656c 662e 7061   chid in self.pa
+00004330: 7261 6d65 7465 7273 5f6e 6373 3a0a 2020  rameters_ncs:.  
+00004340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004350: 2020 6669 6c65 5f6e 6373 203d 2073 656c    file_ncs = sel
+00004360: 662e 7061 7261 6d65 7465 7273 5f6e 6373  f.parameters_ncs
+00004370: 5b63 6869 645d 5b27 6669 6c65 6e61 6d65  [chid]['filename
+00004380: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
+00004390: 2020 2020 2020 2073 656c 662e 7265 6164         self.read
+000043a0: 5f6e 6373 2866 696c 655f 6e63 732c 2065  _ncs(file_ncs, e
+000043b0: 6d70 7479 5f73 6567 2c20 6c61 7a79 2c20  mpty_seg, lazy, 
+000043c0: 6361 7363 6164 652c 0a20 2020 2020 2020  cascade,.       
+000043d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000043e0: 2020 2020 2020 2020 2020 2074 5f73 7461             t_sta
+000043f0: 7274 3d74 5f73 7461 7274 2c20 745f 7374  rt=t_start, t_st
+00004400: 6f70 3d74 5f73 746f 7029 0a20 2020 2020  op=t_stop).     
+00004410: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00004420: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004430: 2020 2020 2073 656c 662e 5f64 6961 676e       self._diagn
+00004440: 6f73 7469 635f 7072 696e 7428 2743 616e  ostic_print('Can
+00004450: 206e 6f74 206c 6f61 6420 6e63 7320 6f66   not load ncs of
+00004460: 2063 6861 6e6e 656c 2025 692e 2027 0a20   channel %i. '. 
+00004470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004490: 2020 2020 2020 2020 2020 274e 6f20 636f            'No co
+000044a0: 7272 6573 706f 6e64 696e 6720 6e63 7320  rresponding ncs 
+000044b0: 6669 6c65 2027 0a20 2020 2020 2020 2020  file '.         
+000044c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000044d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000044e0: 2020 2770 7265 7365 6e74 2e27 2025 2028    'present.' % (
+000044f0: 6368 6964 2929 0a0a 2020 2020 2020 2020  chid))..        
+00004500: 2020 2020 2320 7375 7070 6c65 6d65 6e74      # supplement
+00004510: 6f72 7920 6d65 7267 6520 6675 6e63 7469  ory merge functi
+00004520: 6f6e 2c20 7368 6f75 6c64 2062 6520 7265  on, should be re
+00004530: 706c 6163 6564 2062 7920 6e65 6f20 7574  placed by neo ut
+00004540: 696c 6974 790a 2020 2020 2020 2020 2020  ility.          
+00004550: 2020 2320 2066 756e 6374 696f 6e0a 2020    #  function.  
+00004560: 2020 2020 2020 2020 2020 6465 6620 6d65            def me
+00004570: 7267 655f 616e 616c 6f67 7369 676e 616c  rge_analogsignal
+00004580: 7328 616e 6173 6967 5f6c 6973 7429 3a0a  s(anasig_list):.
 00004590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000045a0: 6966 2061 6964 203d 3d20 303a 0a20 2020  if aid == 0:.   
-000045b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000045c0: 2020 2020 2066 756c 6c5f 616e 616c 6f67       full_analog
-000045d0: 7369 676e 616c 203d 2061 6e61 7369 670a  signal = anasig.
-000045e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000045f0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00004600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004610: 2020 6675 6c6c 5f61 6e61 6c6f 6773 6967    full_analogsig
-00004620: 6e61 6c20 3d20 6675 6c6c 5f61 6e61 6c6f  nal = full_analo
-00004630: 6773 6967 6e61 6c2e 6d65 7267 6528 616e  gsignal.merge(an
-00004640: 6173 6967 290a 0a20 2020 2020 2020 2020  asig)..         
-00004650: 2020 2020 2020 2066 6f72 206b 6579 2069         for key i
-00004660: 6e20 616e 6173 6967 5f6c 6973 745b 305d  n anasig_list[0]
-00004670: 2e61 6e6e 6f74 6174 696f 6e73 2e6b 6579  .annotations.key
-00004680: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
-00004690: 2020 2020 2020 2020 206c 6973 7469 6669           listifi
-000046a0: 6564 5f76 616c 7565 7320 3d20 5b61 2e61  ed_values = [a.a
-000046b0: 6e6e 6f74 6174 696f 6e73 5b6b 6579 5d20  nnotations[key] 
-000046c0: 666f 7220 6120 696e 2061 6e61 7369 675f  for a in anasig_
-000046d0: 6c69 7374 5d0a 2020 2020 2020 2020 2020  list].          
-000046e0: 2020 2020 2020 2020 2020 6675 6c6c 5f61            full_a
-000046f0: 6e61 6c6f 6773 6967 6e61 6c2e 616e 6e6f  nalogsignal.anno
-00004700: 7461 7469 6f6e 735b 6b65 795d 203d 206c  tations[key] = l
-00004710: 6973 7469 6669 6564 5f76 616c 7565 730a  istified_values.
-00004720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004730: 7265 7475 726e 2066 756c 6c5f 616e 616c  return full_anal
-00004740: 6f67 7369 676e 616c 0a0a 2020 2020 2020  ogsignal..      
-00004750: 2020 2020 2020 616e 616c 6f67 7369 676e        analogsign
-00004760: 616c 203d 206d 6572 6765 5f61 6e61 6c6f  al = merge_analo
-00004770: 6773 6967 6e61 6c73 2865 6d70 7479 5f73  gsignals(empty_s
-00004780: 6567 2e61 6e61 6c6f 6773 6967 6e61 6c73  eg.analogsignals
-00004790: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
-000047a0: 672e 616e 616c 6f67 7369 676e 616c 732e  g.analogsignals.
-000047b0: 6170 7065 6e64 2861 6e61 6c6f 6773 6967  append(analogsig
-000047c0: 6e61 6c29 0a20 2020 2020 2020 2020 2020  nal).           
-000047d0: 2061 6e61 6c6f 6773 6967 6e61 6c2e 7365   analogsignal.se
-000047e0: 676d 656e 7420 3d20 7365 670a 0a20 2020  gment = seg..   
-000047f0: 2020 2020 2023 2052 6561 6469 6e67 204e       # Reading N
-00004800: 4556 2046 696c 6573 2028 4576 656e 7473  EV Files (Events
-00004810: 2923 0a20 2020 2020 2020 2023 2072 6561  )#.        # rea
-00004820: 6469 6e67 2061 6c6c 2066 696c 6573 2061  ding all files a
-00004830: 7661 696c 6162 6c65 0a20 2020 2020 2020  vailable.       
-00004840: 2069 6620 6576 656e 7473 3a0a 2020 2020   if events:.    
-00004850: 2020 2020 2020 2020 666f 7220 6669 6c65          for file
-00004860: 6e61 6d65 5f6e 6576 2069 6e20 7365 6c66  name_nev in self
-00004870: 2e6e 6576 5f61 7373 6f3a 0a20 2020 2020  .nev_asso:.     
-00004880: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00004890: 7265 6164 5f6e 6576 2866 696c 656e 616d  read_nev(filenam
-000048a0: 655f 6e65 762c 2073 6567 2c20 6c61 7a79  e_nev, seg, lazy
-000048b0: 2c20 6361 7363 6164 652c 2074 5f73 7461  , cascade, t_sta
-000048c0: 7274 3d74 5f73 7461 7274 2c0a 2020 2020  rt=t_start,.    
-000048d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000048e0: 2020 2020 2020 2020 2020 745f 7374 6f70            t_stop
-000048f0: 3d74 5f73 746f 7029 0a0a 2020 2020 2020  =t_stop)..      
-00004900: 2020 2320 5265 6164 696e 6720 5370 696b    # Reading Spik
-00004910: 6520 4461 7461 206f 6e6c 7920 6966 2072  e Data only if r
-00004920: 6571 7565 7374 6564 0a20 2020 2020 2020  equested.       
-00004930: 2069 6620 756e 6974 5f6c 6973 7420 6973   if unit_list is
-00004940: 206e 6f74 2046 616c 7365 3a0a 2020 2020   not False:.    
-00004950: 2020 2020 2020 2020 2320 5265 6164 696e          # Readin
-00004960: 6720 4e53 4520 4669 6c65 7320 2853 7069  g NSE Files (Spi
-00004970: 6b65 7329 230a 2020 2020 2020 2020 2020  kes)#.          
-00004980: 2020 2320 7365 6c65 6374 696e 6720 6e73    # selecting ns
-00004990: 6520 6669 6c65 7320 746f 206c 6f61 6420  e files to load 
-000049a0: 6261 7365 6420 6f6e 2065 6c65 6374 726f  based on electro
-000049b0: 6465 5f6c 6973 7420 7265 7175 6573 7465  de_list requeste
-000049c0: 640a 2020 2020 2020 2020 2020 2020 666f  d.            fo
-000049d0: 7220 6368 6964 2069 6e20 656c 6563 7472  r chid in electr
-000049e0: 6f64 655f 6c69 7374 3a0a 2020 2020 2020  ode_list:.      
-000049f0: 2020 2020 2020 2020 2020 6966 2063 6869            if chi
-00004a00: 6420 696e 2073 656c 662e 7061 7261 6d65  d in self.parame
-00004a10: 7465 7273 5f6e 7365 3a0a 2020 2020 2020  ters_nse:.      
-00004a20: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-00004a30: 6c65 6e61 6d65 5f6e 7365 203d 2073 656c  lename_nse = sel
-00004a40: 662e 7061 7261 6d65 7465 7273 5f6e 7365  f.parameters_nse
-00004a50: 5b63 6869 645d 5b27 6669 6c65 6e61 6d65  [chid]['filename
-00004a60: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
-00004a70: 2020 2020 2020 2073 656c 662e 7265 6164         self.read
-00004a80: 5f6e 7365 2866 696c 656e 616d 655f 6e73  _nse(filename_ns
-00004a90: 652c 2073 6567 2c20 6c61 7a79 2c20 6361  e, seg, lazy, ca
-00004aa0: 7363 6164 652c 0a20 2020 2020 2020 2020  scade,.         
-00004ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ac0: 2020 2020 2020 2020 2074 5f73 7461 7274           t_start
-00004ad0: 3d74 5f73 7461 7274 2c20 745f 7374 6f70  =t_start, t_stop
-00004ae0: 3d74 5f73 746f 702c 0a20 2020 2020 2020  =t_stop,.       
-00004af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b00: 2020 2020 2020 2020 2020 2077 6176 6566             wavef
-00004b10: 6f72 6d73 3d77 6176 6566 6f72 6d73 290a  orms=waveforms).
+000045a0: 666f 7220 6169 642c 2061 6e61 7369 6720  for aid, anasig 
+000045b0: 696e 2065 6e75 6d65 7261 7465 2861 6e61  in enumerate(ana
+000045c0: 7369 675f 6c69 7374 293a 0a20 2020 2020  sig_list):.     
+000045d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+000045e0: 6e61 7369 672e 6368 616e 6e65 6c5f 696e  nasig.channel_in
+000045f0: 6465 7820 3d20 4e6f 6e65 0a20 2020 2020  dex = None.     
+00004600: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00004610: 6620 6169 6420 3d3d 2030 3a0a 2020 2020  f aid == 0:.    
+00004620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004630: 2020 2020 6675 6c6c 5f61 6e61 6c6f 6773      full_analogs
+00004640: 6967 6e61 6c20 3d20 616e 6173 6967 0a20  ignal = anasig. 
+00004650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004660: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00004670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004680: 2066 756c 6c5f 616e 616c 6f67 7369 676e   full_analogsign
+00004690: 616c 203d 2066 756c 6c5f 616e 616c 6f67  al = full_analog
+000046a0: 7369 676e 616c 2e6d 6572 6765 2861 6e61  signal.merge(ana
+000046b0: 7369 6729 0a0a 2020 2020 2020 2020 2020  sig)..          
+000046c0: 2020 2020 2020 666f 7220 6b65 7920 696e        for key in
+000046d0: 2061 6e61 7369 675f 6c69 7374 5b30 5d2e   anasig_list[0].
+000046e0: 616e 6e6f 7461 7469 6f6e 732e 6b65 7973  annotations.keys
+000046f0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00004700: 2020 2020 2020 2020 6c69 7374 6966 6965          listifie
+00004710: 645f 7661 6c75 6573 203d 205b 612e 616e  d_values = [a.an
+00004720: 6e6f 7461 7469 6f6e 735b 6b65 795d 2066  notations[key] f
+00004730: 6f72 2061 2069 6e20 616e 6173 6967 5f6c  or a in anasig_l
+00004740: 6973 745d 0a20 2020 2020 2020 2020 2020  ist].           
+00004750: 2020 2020 2020 2020 2066 756c 6c5f 616e           full_an
+00004760: 616c 6f67 7369 676e 616c 2e61 6e6e 6f74  alogsignal.annot
+00004770: 6174 696f 6e73 5b6b 6579 5d20 3d20 6c69  ations[key] = li
+00004780: 7374 6966 6965 645f 7661 6c75 6573 0a20  stified_values. 
+00004790: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+000047a0: 6574 7572 6e20 6675 6c6c 5f61 6e61 6c6f  eturn full_analo
+000047b0: 6773 6967 6e61 6c0a 0a20 2020 2020 2020  gsignal..       
+000047c0: 2020 2020 2061 6e61 6c6f 6773 6967 6e61       analogsigna
+000047d0: 6c20 3d20 6d65 7267 655f 616e 616c 6f67  l = merge_analog
+000047e0: 7369 676e 616c 7328 656d 7074 795f 7365  signals(empty_se
+000047f0: 672e 616e 616c 6f67 7369 676e 616c 7329  g.analogsignals)
+00004800: 0a20 2020 2020 2020 2020 2020 2073 6567  .            seg
+00004810: 2e61 6e61 6c6f 6773 6967 6e61 6c73 2e61  .analogsignals.a
+00004820: 7070 656e 6428 616e 616c 6f67 7369 676e  ppend(analogsign
+00004830: 616c 290a 2020 2020 2020 2020 2020 2020  al).            
+00004840: 616e 616c 6f67 7369 676e 616c 2e73 6567  analogsignal.seg
+00004850: 6d65 6e74 203d 2073 6567 0a0a 2020 2020  ment = seg..    
+00004860: 2020 2020 2320 5265 6164 696e 6720 4e45      # Reading NE
+00004870: 5620 4669 6c65 7320 2845 7665 6e74 7329  V Files (Events)
+00004880: 230a 2020 2020 2020 2020 2320 7265 6164  #.        # read
+00004890: 696e 6720 616c 6c20 6669 6c65 7320 6176  ing all files av
+000048a0: 6169 6c61 626c 650a 2020 2020 2020 2020  ailable.        
+000048b0: 6966 2065 7665 6e74 733a 0a20 2020 2020  if events:.     
+000048c0: 2020 2020 2020 2066 6f72 2066 696c 656e         for filen
+000048d0: 616d 655f 6e65 7620 696e 2073 656c 662e  ame_nev in self.
+000048e0: 6e65 765f 6173 736f 3a0a 2020 2020 2020  nev_asso:.      
+000048f0: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
+00004900: 6561 645f 6e65 7628 6669 6c65 6e61 6d65  ead_nev(filename
+00004910: 5f6e 6576 2c20 7365 672c 206c 617a 792c  _nev, seg, lazy,
+00004920: 2063 6173 6361 6465 2c20 745f 7374 6172   cascade, t_star
+00004930: 743d 745f 7374 6172 742c 0a20 2020 2020  t=t_start,.     
+00004940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004950: 2020 2020 2020 2020 2074 5f73 746f 703d           t_stop=
+00004960: 745f 7374 6f70 290a 0a20 2020 2020 2020  t_stop)..       
+00004970: 2023 2052 6561 6469 6e67 2053 7069 6b65   # Reading Spike
+00004980: 2044 6174 6120 6f6e 6c79 2069 6620 7265   Data only if re
+00004990: 7175 6573 7465 640a 2020 2020 2020 2020  quested.        
+000049a0: 6966 2075 6e69 745f 6c69 7374 2069 7320  if unit_list is 
+000049b0: 6e6f 7420 4661 6c73 653a 0a20 2020 2020  not False:.     
+000049c0: 2020 2020 2020 2023 2052 6561 6469 6e67         # Reading
+000049d0: 204e 5345 2046 696c 6573 2028 5370 696b   NSE Files (Spik
+000049e0: 6573 2923 0a20 2020 2020 2020 2020 2020  es)#.           
+000049f0: 2023 2073 656c 6563 7469 6e67 206e 7365   # selecting nse
+00004a00: 2066 696c 6573 2074 6f20 6c6f 6164 2062   files to load b
+00004a10: 6173 6564 206f 6e20 656c 6563 7472 6f64  ased on electrod
+00004a20: 655f 6c69 7374 2072 6571 7565 7374 6564  e_list requested
+00004a30: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00004a40: 2063 6869 6420 696e 2065 6c65 6374 726f   chid in electro
+00004a50: 6465 5f6c 6973 743a 0a20 2020 2020 2020  de_list:.       
+00004a60: 2020 2020 2020 2020 2069 6620 6368 6964           if chid
+00004a70: 2069 6e20 7365 6c66 2e70 6172 616d 6574   in self.paramet
+00004a80: 6572 735f 6e73 653a 0a20 2020 2020 2020  ers_nse:.       
+00004a90: 2020 2020 2020 2020 2020 2020 2066 696c               fil
+00004aa0: 656e 616d 655f 6e73 6520 3d20 7365 6c66  ename_nse = self
+00004ab0: 2e70 6172 616d 6574 6572 735f 6e73 655b  .parameters_nse[
+00004ac0: 6368 6964 5d5b 2766 696c 656e 616d 6527  chid]['filename'
+00004ad0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00004ae0: 2020 2020 2020 7365 6c66 2e72 6561 645f        self.read_
+00004af0: 6e73 6528 6669 6c65 6e61 6d65 5f6e 7365  nse(filename_nse
+00004b00: 2c20 7365 672c 206c 617a 792c 2063 6173  , seg, lazy, cas
+00004b10: 6361 6465 2c0a 2020 2020 2020 2020 2020  cade,.          
 00004b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b30: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00004b40: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-00004b50: 6469 6167 6e6f 7374 6963 5f70 7269 6e74  diagnostic_print
-00004b60: 2827 4361 6e20 6e6f 7420 6c6f 6164 206e  ('Can not load n
-00004b70: 7365 206f 6620 6368 616e 6e65 6c20 2569  se of channel %i
-00004b80: 2e20 270a 2020 2020 2020 2020 2020 2020  . '.            
-00004b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ba0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00004bb0: 4e6f 2063 6f72 7265 7370 6f6e 6469 6e67  No corresponding
-00004bc0: 206e 7365 2066 696c 6520 270a 2020 2020   nse file '.    
-00004bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004bf0: 2020 2020 2020 2027 7072 6573 656e 742e         'present.
-00004c00: 2720 2520 2863 6869 6429 290a 0a20 2020  ' % (chid))..   
-00004c10: 2020 2020 2020 2020 2023 2052 6561 6469           # Readi
-00004c20: 6e67 206e 7474 2046 696c 6573 2028 5370  ng ntt Files (Sp
-00004c30: 696b 6573 2923 0a20 2020 2020 2020 2020  ikes)#.         
-00004c40: 2020 2023 2073 656c 6563 7469 6e67 206e     # selecting n
-00004c50: 7474 2066 696c 6573 2074 6f20 6c6f 6164  tt files to load
-00004c60: 2062 6173 6564 206f 6e20 656c 6563 7472   based on electr
-00004c70: 6f64 655f 6c69 7374 2072 6571 7565 7374  ode_list request
-00004c80: 6564 0a20 2020 2020 2020 2020 2020 2066  ed.            f
-00004c90: 6f72 2063 6869 6420 696e 2065 6c65 6374  or chid in elect
-00004ca0: 726f 6465 5f6c 6973 743a 0a20 2020 2020  rode_list:.     
-00004cb0: 2020 2020 2020 2020 2020 2069 6620 6368             if ch
-00004cc0: 6964 2069 6e20 7365 6c66 2e70 6172 616d  id in self.param
-00004cd0: 6574 6572 735f 6e74 743a 0a20 2020 2020  eters_ntt:.     
-00004ce0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00004cf0: 696c 656e 616d 655f 6e74 7420 3d20 7365  ilename_ntt = se
-00004d00: 6c66 2e70 6172 616d 6574 6572 735f 6e74  lf.parameters_nt
-00004d10: 745b 6368 6964 5d5b 2766 696c 656e 616d  t[chid]['filenam
-00004d20: 6527 5d0a 2020 2020 2020 2020 2020 2020  e'].            
-00004d30: 2020 2020 2020 2020 7365 6c66 2e72 6561          self.rea
-00004d40: 645f 6e74 7428 6669 6c65 6e61 6d65 5f6e  d_ntt(filename_n
-00004d50: 7474 2c20 7365 672c 206c 617a 792c 2063  tt, seg, lazy, c
-00004d60: 6173 6361 6465 2c0a 2020 2020 2020 2020  ascade,.        
-00004d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004d80: 2020 2020 2020 2020 2020 745f 7374 6172            t_star
-00004d90: 743d 745f 7374 6172 742c 2074 5f73 746f  t=t_start, t_sto
-00004da0: 703d 745f 7374 6f70 2c0a 2020 2020 2020  p=t_stop,.      
-00004db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004dc0: 2020 2020 2020 2020 2020 2020 7761 7665              wave
-00004dd0: 666f 726d 733d 7761 7665 666f 726d 7329  forms=waveforms)
-00004de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004df0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00004e00: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00004e10: 5f64 6961 676e 6f73 7469 635f 7072 696e  _diagnostic_prin
-00004e20: 7428 2743 616e 206e 6f74 206c 6f61 6420  t('Can not load 
-00004e30: 6e74 7420 6f66 2063 6861 6e6e 656c 2025  ntt of channel %
-00004e40: 692e 2027 0a20 2020 2020 2020 2020 2020  i. '.           
+00004b30: 2020 2020 2020 2020 745f 7374 6172 743d          t_start=
+00004b40: 745f 7374 6172 742c 2074 5f73 746f 703d  t_start, t_stop=
+00004b50: 745f 7374 6f70 2c0a 2020 2020 2020 2020  t_stop,.        
+00004b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b70: 2020 2020 2020 2020 2020 7761 7665 666f            wavefo
+00004b80: 726d 733d 7761 7665 666f 726d 7329 0a20  rms=waveforms). 
+00004b90: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00004ba0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00004bb0: 2020 2020 2020 2020 2073 656c 662e 5f64           self._d
+00004bc0: 6961 676e 6f73 7469 635f 7072 696e 7428  iagnostic_print(
+00004bd0: 2743 616e 206e 6f74 206c 6f61 6420 6e73  'Can not load ns
+00004be0: 6520 6f66 2063 6861 6e6e 656c 2025 692e  e of channel %i.
+00004bf0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00004c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c10: 2020 2020 2020 2020 2020 2020 2020 274e                'N
+00004c20: 6f20 636f 7272 6573 706f 6e64 696e 6720  o corresponding 
+00004c30: 6e73 6520 6669 6c65 2027 0a20 2020 2020  nse file '.     
+00004c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004c60: 2020 2020 2020 2770 7265 7365 6e74 2e27        'present.'
+00004c70: 2025 2028 6368 6964 2929 0a0a 2020 2020   % (chid))..    
+00004c80: 2020 2020 2020 2020 2320 5265 6164 696e          # Readin
+00004c90: 6720 6e74 7420 4669 6c65 7320 2853 7069  g ntt Files (Spi
+00004ca0: 6b65 7329 230a 2020 2020 2020 2020 2020  kes)#.          
+00004cb0: 2020 2320 7365 6c65 6374 696e 6720 6e74    # selecting nt
+00004cc0: 7420 6669 6c65 7320 746f 206c 6f61 6420  t files to load 
+00004cd0: 6261 7365 6420 6f6e 2065 6c65 6374 726f  based on electro
+00004ce0: 6465 5f6c 6973 7420 7265 7175 6573 7465  de_list requeste
+00004cf0: 640a 2020 2020 2020 2020 2020 2020 666f  d.            fo
+00004d00: 7220 6368 6964 2069 6e20 656c 6563 7472  r chid in electr
+00004d10: 6f64 655f 6c69 7374 3a0a 2020 2020 2020  ode_list:.      
+00004d20: 2020 2020 2020 2020 2020 6966 2063 6869            if chi
+00004d30: 6420 696e 2073 656c 662e 7061 7261 6d65  d in self.parame
+00004d40: 7465 7273 5f6e 7474 3a0a 2020 2020 2020  ters_ntt:.      
+00004d50: 2020 2020 2020 2020 2020 2020 2020 6669                fi
+00004d60: 6c65 6e61 6d65 5f6e 7474 203d 2073 656c  lename_ntt = sel
+00004d70: 662e 7061 7261 6d65 7465 7273 5f6e 7474  f.parameters_ntt
+00004d80: 5b63 6869 645d 5b27 6669 6c65 6e61 6d65  [chid]['filename
+00004d90: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
+00004da0: 2020 2020 2020 2073 656c 662e 7265 6164         self.read
+00004db0: 5f6e 7474 2866 696c 656e 616d 655f 6e74  _ntt(filename_nt
+00004dc0: 742c 2073 6567 2c20 6c61 7a79 2c20 6361  t, seg, lazy, ca
+00004dd0: 7363 6164 652c 0a20 2020 2020 2020 2020  scade,.         
+00004de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004df0: 2020 2020 2020 2020 2074 5f73 7461 7274           t_start
+00004e00: 3d74 5f73 7461 7274 2c20 745f 7374 6f70  =t_start, t_stop
+00004e10: 3d74 5f73 746f 702c 0a20 2020 2020 2020  =t_stop,.       
+00004e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e30: 2020 2020 2020 2020 2020 2077 6176 6566             wavef
+00004e40: 6f72 6d73 3d77 6176 6566 6f72 6d73 290a  orms=waveforms).
 00004e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004e70: 274e 6f20 636f 7272 6573 706f 6e64 696e  'No correspondin
-00004e80: 6720 6e74 7420 6669 6c65 2027 0a20 2020  g ntt file '.   
-00004e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004eb0: 2020 2020 2020 2020 2770 7265 7365 6e74          'present
-00004ec0: 2e27 2025 2028 6368 6964 2929 0a0a 2020  .' % (chid))..  
-00004ed0: 2020 2020 2020 7265 7475 726e 2073 6567        return seg
-00004ee0: 0a0a 2020 2020 6465 6620 7265 6164 5f6e  ..    def read_n
-00004ef0: 6373 2873 656c 662c 2066 696c 656e 616d  cs(self, filenam
-00004f00: 655f 6e63 732c 2073 6567 2c20 6c61 7a79  e_ncs, seg, lazy
-00004f10: 3d46 616c 7365 2c20 6361 7363 6164 653d  =False, cascade=
-00004f20: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
-00004f30: 2020 2020 2020 2074 5f73 7461 7274 3d4e         t_start=N
-00004f40: 6f6e 652c 2074 5f73 746f 703d 4e6f 6e65  one, t_stop=None
-00004f50: 293a 0a20 2020 2020 2020 2027 2727 0a20  ):.        '''. 
-00004f60: 2020 2020 2020 2052 6561 6469 6e67 2061         Reading a
-00004f70: 2073 696e 676c 6520 2e6e 6373 2066 696c   single .ncs fil
-00004f80: 6520 6672 6f6d 2074 6865 2061 7373 6f63  e from the assoc
-00004f90: 6961 7465 6420 4e65 7572 616c 796e 7820  iated Neuralynx 
-00004fa0: 7265 636f 7264 696e 670a 2020 2020 2020  recording.      
-00004fb0: 2020 7365 7373 696f 6e2e 0a20 2020 2020    session..     
-00004fc0: 2020 2049 6e20 6361 7365 206f 6620 6120     In case of a 
-00004fd0: 7265 636f 7264 696e 6720 6761 7020 6265  recording gap be
-00004fe0: 7477 6565 6e20 745f 7374 6172 7420 616e  tween t_start an
-00004ff0: 6420 745f 7374 6f70 2c20 6461 7461 2061  d t_stop, data a
-00005000: 7265 206f 6e6c 790a 2020 2020 2020 2020  re only.        
-00005010: 6c6f 6164 6564 2075 6e74 696c 2067 6170  loaded until gap
-00005020: 2073 7461 7274 2e0a 2020 2020 2020 2020   start..        
-00005030: 466f 7220 6c6f 6164 696e 6720 6461 7461  For loading data
-00005040: 2061 6372 6f73 7320 7265 636f 7264 696e   across recordin
-00005050: 6720 6761 7073 2075 7365 2072 6561 645f  g gaps use read_
-00005060: 626c 6f63 6b28 2e2e 2e29 2e0a 0a20 2020  block(...)...   
-00005070: 2020 2020 2041 7267 756d 656e 7473 3a0a       Arguments:.
-00005080: 2020 2020 2020 2020 2020 2020 6669 6c65              file
-00005090: 6e61 6d65 5f6e 6373 203a 204e 616d 6520  name_ncs : Name 
-000050a0: 6f66 2074 6865 202e 6e63 7320 6669 6c65  of the .ncs file
-000050b0: 2074 6f20 6265 206c 6f61 6465 642e 0a20   to be loaded.. 
-000050c0: 2020 2020 2020 2020 2020 2073 6567 203a             seg :
-000050d0: 204e 656f 2053 6567 6d65 6e74 2c20 746f   Neo Segment, to
-000050e0: 2077 6869 6368 2074 6865 2041 6e61 6c6f   which the Analo
-000050f0: 6753 6967 6e61 6c20 636f 6e74 6169 6e69  gSignal containi
-00005100: 6e67 2074 6865 2064 6174 610a 2020 2020  ng the data.    
-00005110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005120: 2020 2020 2020 2020 7769 6c6c 2062 6520          will be 
-00005130: 6174 7461 6368 6564 2e0a 2020 2020 2020  attached..      
-00005140: 2020 2020 2020 6c61 7a79 203a 2050 6f73        lazy : Pos
-00005150: 7470 6f6e 6520 6163 7475 616c 2072 6561  tpone actual rea
-00005160: 6469 6e67 206f 6620 7468 6520 6461 7461  ding of the data
-00005170: 2e20 496e 7374 6561 6420 7072 6f76 6964  . Instead provid
-00005180: 6520 6120 6475 6d6d 790a 2020 2020 2020  e a dummy.      
-00005190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000051a0: 2020 2020 2020 416e 616c 6f67 5369 676e        AnalogSign
-000051b0: 616c 2e20 4465 6661 756c 7420 2746 616c  al. Default 'Fal
-000051c0: 7365 272e 0a20 2020 2020 2020 2020 2020  se'..           
-000051d0: 2063 6173 6361 6465 203a 204e 6f74 2075   cascade : Not u
-000051e0: 7365 6420 696e 2074 6869 7320 636f 6e74  sed in this cont
-000051f0: 6578 742e 2044 6566 6175 6c74 3a20 2754  ext. Default: 'T
-00005200: 7275 6527 2e0a 2020 2020 2020 2020 2020  rue'..          
-00005210: 2020 745f 7374 6172 7420 3a20 7469 6d65    t_start : time
-00005220: 206f 7220 7361 6d70 6c65 2028 7175 616e   or sample (quan
-00005230: 7469 7479 206f 7220 696e 7465 6765 7229  tity or integer)
-00005240: 2074 6861 7420 7468 650a 2020 2020 2020   that the.      
-00005250: 2020 2020 2020 416e 616c 6f67 5369 676e        AnalogSign
-00005260: 616c 2062 6567 696e 732e 0a20 2020 2020  al begins..     
-00005270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005280: 2020 2020 2020 2044 6566 6175 6c74 204e         Default N
-00005290: 6f6e 652e 0a20 2020 2020 2020 2020 2020  one..           
-000052a0: 2074 5f73 746f 7020 3a20 7469 6d65 206f   t_stop : time o
-000052b0: 7220 7361 6d70 6c65 2028 7175 616e 7469  r sample (quanti
-000052c0: 7479 206f 7220 696e 7465 6765 7229 2074  ty or integer) t
-000052d0: 6861 7420 7468 650a 2020 2020 2020 2020  hat the.        
-000052e0: 2020 2020 416e 616c 6f67 5369 676e 616c      AnalogSignal
-000052f0: 2065 6e64 732e 0a20 2020 2020 2020 2020   ends..         
-00005300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005310: 2020 2044 6566 6175 6c74 204e 6f6e 652e     Default None.
-00005320: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
-00005330: 733a 0a20 2020 2020 2020 2020 2020 204e  s:.            N
-00005340: 6f6e 650a 2020 2020 2020 2020 2727 270a  one.        '''.
-00005350: 0a20 2020 2020 2020 2023 2063 6865 636b  .        # check
-00005360: 696e 6720 666f 726d 6174 206f 6620 6669  ing format of fi
-00005370: 6c65 6e61 6d65 2061 6e64 2063 6f72 7265  lename and corre
-00005380: 6374 696e 6720 6966 206e 6563 6573 7361  cting if necessa
-00005390: 7279 0a20 2020 2020 2020 2069 6620 6669  ry.        if fi
-000053a0: 6c65 6e61 6d65 5f6e 6373 5b2d 343a 5d20  lename_ncs[-4:] 
-000053b0: 213d 2027 2e6e 6373 273a 0a20 2020 2020  != '.ncs':.     
-000053c0: 2020 2020 2020 2066 696c 656e 616d 655f         filename_
-000053d0: 6e63 7320 3d20 6669 6c65 6e61 6d65 5f6e  ncs = filename_n
-000053e0: 6373 202b 2027 2e6e 6373 270a 2020 2020  cs + '.ncs'.    
-000053f0: 2020 2020 6966 2073 6570 2069 6e20 6669      if sep in fi
-00005400: 6c65 6e61 6d65 5f6e 6373 3a0a 2020 2020  lename_ncs:.    
-00005410: 2020 2020 2020 2020 6669 6c65 6e61 6d65          filename
-00005420: 5f6e 6373 203d 2066 696c 656e 616d 655f  _ncs = filename_
-00005430: 6e63 732e 7370 6c69 7428 7365 7029 5b2d  ncs.split(sep)[-
-00005440: 315d 0a0a 2020 2020 2020 2020 2320 4578  1]..        # Ex
-00005450: 7472 6163 7469 6e67 2074 6865 2063 6861  tracting the cha
-00005460: 6e6e 656c 2069 6420 6672 6f6d 2070 7265  nnel id from pre
-00005470: 7363 616e 2028 6173 736f 6369 6174 696f  scan (associatio
-00005480: 6e29 206f 6620 6e63 7320 6669 6c65 7320  n) of ncs files 
-00005490: 7769 7468 0a20 2020 2020 2020 2023 2074  with.        # t
-000054a0: 6869 7320 7265 636f 7264 696e 6720 7365  his recording se
-000054b0: 7373 696f 6e0a 2020 2020 2020 2020 6368  ssion.        ch
-000054c0: 6964 203d 2073 656c 662e 6765 745f 6368  id = self.get_ch
-000054d0: 616e 6e65 6c5f 6964 5f62 795f 6669 6c65  annel_id_by_file
-000054e0: 5f6e 616d 6528 6669 6c65 6e61 6d65 5f6e  _name(filename_n
-000054f0: 6373 290a 2020 2020 2020 2020 6966 2063  cs).        if c
-00005500: 6869 6420 6973 204e 6f6e 653a 0a20 2020  hid is None:.   
-00005510: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-00005520: 616c 7565 4572 726f 7228 274e 6575 7261  alueError('Neura
-00005530: 6c79 6e78 494f 2069 7320 6174 7465 6d70  lynxIO is attemp
-00005540: 7469 6e67 2074 6f20 7265 6164 2061 2066  ting to read a f
-00005550: 696c 6520 270a 2020 2020 2020 2020 2020  ile '.          
-00005560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005570: 2020 2027 6e6f 7420 6173 736f 6369 6174     'not associat
-00005580: 6564 2074 6f20 7468 6973 2073 6573 7369  ed to this sessi
-00005590: 6f6e 2028 2573 292e 2720 2520 280a 2020  on (%s).' % (.  
-000055a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000055b0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-000055c0: 696c 656e 616d 655f 6e63 7329 290a 0a20  ilename_ncs)).. 
-000055d0: 2020 2020 2020 2069 6620 6e6f 7420 6361         if not ca
-000055e0: 7363 6164 653a 0a20 2020 2020 2020 2020  scade:.         
-000055f0: 2020 2072 6574 7572 6e0a 0a20 2020 2020     return..     
-00005600: 2020 2023 2072 6561 6420 6461 7461 0a20     # read data. 
-00005610: 2020 2020 2020 2068 6561 6465 725f 7469         header_ti
-00005620: 6d65 5f64 6174 6120 3d20 7365 6c66 2e5f  me_data = self._
-00005630: 5f6d 6d61 705f 6e63 735f 7061 636b 6574  _mmap_ncs_packet
-00005640: 5f74 696d 6573 7461 6d70 7328 6669 6c65  _timestamps(file
-00005650: 6e61 6d65 5f6e 6373 290a 0a20 2020 2020  name_ncs)..     
-00005660: 2020 2064 6174 6120 3d20 7365 6c66 2e5f     data = self._
-00005670: 5f6d 6d61 705f 6e63 735f 6461 7461 2866  _mmap_ncs_data(f
-00005680: 696c 656e 616d 655f 6e63 7329 0a0a 2020  ilename_ncs)..  
-00005690: 2020 2020 2020 2320 656e 7375 7265 206d        # ensure m
-000056a0: 6561 6e69 6e67 6675 6c20 7661 6c75 6573  eaningful values
-000056b0: 2066 6f72 2072 6571 7565 7374 6564 2073   for requested s
-000056c0: 7461 7274 2061 6e64 2073 746f 7020 7469  tart and stop ti
-000056d0: 6d65 730a 2020 2020 2020 2020 2320 696e  mes.        # in
-000056e0: 2063 6173 6520 7469 6d65 2069 7320 7072   case time is pr
-000056f0: 6f76 6964 6564 2069 6e20 7361 6d70 6c65  ovided in sample
-00005700: 733a 2074 7261 6e73 666f 726d 2074 6f20  s: transform to 
-00005710: 6162 736f 6c75 7465 2074 696d 6520 756e  absolute time un
-00005720: 6974 730a 2020 2020 2020 2020 6966 2069  its.        if i
-00005730: 7369 6e73 7461 6e63 6528 745f 7374 6172  sinstance(t_star
-00005740: 742c 2069 6e74 293a 0a20 2020 2020 2020  t, int):.       
-00005750: 2020 2020 2074 5f73 7461 7274 203d 2074       t_start = t
-00005760: 5f73 7461 7274 202f 2073 656c 662e 7061  _start / self.pa
-00005770: 7261 6d65 7465 7273 5f6e 6373 5b63 6869  rameters_ncs[chi
-00005780: 645d 5b27 7361 6d70 6c69 6e67 5f72 6174  d]['sampling_rat
-00005790: 6527 5d0a 2020 2020 2020 2020 6966 2069  e'].        if i
-000057a0: 7369 6e73 7461 6e63 6528 745f 7374 6f70  sinstance(t_stop
+00004e60: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00004e70: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+00004e80: 6469 6167 6e6f 7374 6963 5f70 7269 6e74  diagnostic_print
+00004e90: 2827 4361 6e20 6e6f 7420 6c6f 6164 206e  ('Can not load n
+00004ea0: 7474 206f 6620 6368 616e 6e65 6c20 2569  tt of channel %i
+00004eb0: 2e20 270a 2020 2020 2020 2020 2020 2020  . '.            
+00004ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004ed0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00004ee0: 4e6f 2063 6f72 7265 7370 6f6e 6469 6e67  No corresponding
+00004ef0: 206e 7474 2066 696c 6520 270a 2020 2020   ntt file '.    
+00004f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004f20: 2020 2020 2020 2027 7072 6573 656e 742e         'present.
+00004f30: 2720 2520 2863 6869 6429 290a 0a20 2020  ' % (chid))..   
+00004f40: 2020 2020 2072 6574 7572 6e20 7365 670a       return seg.
+00004f50: 0a20 2020 2064 6566 2072 6561 645f 6e63  .    def read_nc
+00004f60: 7328 7365 6c66 2c20 6669 6c65 6e61 6d65  s(self, filename
+00004f70: 5f6e 6373 2c20 7365 672c 206c 617a 793d  _ncs, seg, lazy=
+00004f80: 4661 6c73 652c 2063 6173 6361 6465 3d54  False, cascade=T
+00004f90: 7275 652c 0a20 2020 2020 2020 2020 2020  rue,.           
+00004fa0: 2020 2020 2020 745f 7374 6172 743d 4e6f        t_start=No
+00004fb0: 6e65 2c20 745f 7374 6f70 3d4e 6f6e 6529  ne, t_stop=None)
+00004fc0: 3a0a 2020 2020 2020 2020 2727 270a 2020  :.        '''.  
+00004fd0: 2020 2020 2020 5265 6164 696e 6720 6120        Reading a 
+00004fe0: 7369 6e67 6c65 202e 6e63 7320 6669 6c65  single .ncs file
+00004ff0: 2066 726f 6d20 7468 6520 6173 736f 6369   from the associ
+00005000: 6174 6564 204e 6575 7261 6c79 6e78 2072  ated Neuralynx r
+00005010: 6563 6f72 6469 6e67 0a20 2020 2020 2020  ecording.       
+00005020: 2073 6573 7369 6f6e 2e0a 2020 2020 2020   session..      
+00005030: 2020 496e 2063 6173 6520 6f66 2061 2072    In case of a r
+00005040: 6563 6f72 6469 6e67 2067 6170 2062 6574  ecording gap bet
+00005050: 7765 656e 2074 5f73 7461 7274 2061 6e64  ween t_start and
+00005060: 2074 5f73 746f 702c 2064 6174 6120 6172   t_stop, data ar
+00005070: 6520 6f6e 6c79 0a20 2020 2020 2020 206c  e only.        l
+00005080: 6f61 6465 6420 756e 7469 6c20 6761 7020  oaded until gap 
+00005090: 7374 6172 742e 0a20 2020 2020 2020 2046  start..        F
+000050a0: 6f72 206c 6f61 6469 6e67 2064 6174 6120  or loading data 
+000050b0: 6163 726f 7373 2072 6563 6f72 6469 6e67  across recording
+000050c0: 2067 6170 7320 7573 6520 7265 6164 5f62   gaps use read_b
+000050d0: 6c6f 636b 282e 2e2e 292e 0a0a 2020 2020  lock(...)...    
+000050e0: 2020 2020 4172 6775 6d65 6e74 733a 0a20      Arguments:. 
+000050f0: 2020 2020 2020 2020 2020 2066 696c 656e             filen
+00005100: 616d 655f 6e63 7320 3a20 4e61 6d65 206f  ame_ncs : Name o
+00005110: 6620 7468 6520 2e6e 6373 2066 696c 6520  f the .ncs file 
+00005120: 746f 2062 6520 6c6f 6164 6564 2e0a 2020  to be loaded..  
+00005130: 2020 2020 2020 2020 2020 7365 6720 3a20            seg : 
+00005140: 4e65 6f20 5365 676d 656e 742c 2074 6f20  Neo Segment, to 
+00005150: 7768 6963 6820 7468 6520 416e 616c 6f67  which the Analog
+00005160: 5369 676e 616c 2063 6f6e 7461 696e 696e  Signal containin
+00005170: 6720 7468 6520 6461 7461 0a20 2020 2020  g the data.     
+00005180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005190: 2020 2020 2020 2077 696c 6c20 6265 2061         will be a
+000051a0: 7474 6163 6865 642e 0a20 2020 2020 2020  ttached..       
+000051b0: 2020 2020 206c 617a 7920 3a20 506f 7374       lazy : Post
+000051c0: 706f 6e65 2061 6374 7561 6c20 7265 6164  pone actual read
+000051d0: 696e 6720 6f66 2074 6865 2064 6174 612e  ing of the data.
+000051e0: 2049 6e73 7465 6164 2070 726f 7669 6465   Instead provide
+000051f0: 2061 2064 756d 6d79 0a20 2020 2020 2020   a dummy.       
+00005200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005210: 2020 2020 2041 6e61 6c6f 6753 6967 6e61       AnalogSigna
+00005220: 6c2e 2044 6566 6175 6c74 2027 4661 6c73  l. Default 'Fals
+00005230: 6527 2e0a 2020 2020 2020 2020 2020 2020  e'..            
+00005240: 6361 7363 6164 6520 3a20 4e6f 7420 7573  cascade : Not us
+00005250: 6564 2069 6e20 7468 6973 2063 6f6e 7465  ed in this conte
+00005260: 7874 2e20 4465 6661 756c 743a 2027 5472  xt. Default: 'Tr
+00005270: 7565 272e 0a20 2020 2020 2020 2020 2020  ue'..           
+00005280: 2074 5f73 7461 7274 203a 2074 696d 6520   t_start : time 
+00005290: 6f72 2073 616d 706c 6520 2871 7561 6e74  or sample (quant
+000052a0: 6974 7920 6f72 2069 6e74 6567 6572 2920  ity or integer) 
+000052b0: 7468 6174 2074 6865 0a20 2020 2020 2020  that the.       
+000052c0: 2020 2020 2041 6e61 6c6f 6753 6967 6e61       AnalogSigna
+000052d0: 6c20 6265 6769 6e73 2e0a 2020 2020 2020  l begins..      
+000052e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000052f0: 2020 2020 2020 4465 6661 756c 7420 4e6f        Default No
+00005300: 6e65 2e0a 2020 2020 2020 2020 2020 2020  ne..            
+00005310: 745f 7374 6f70 203a 2074 696d 6520 6f72  t_stop : time or
+00005320: 2073 616d 706c 6520 2871 7561 6e74 6974   sample (quantit
+00005330: 7920 6f72 2069 6e74 6567 6572 2920 7468  y or integer) th
+00005340: 6174 2074 6865 0a20 2020 2020 2020 2020  at the.         
+00005350: 2020 2041 6e61 6c6f 6753 6967 6e61 6c20     AnalogSignal 
+00005360: 656e 6473 2e0a 2020 2020 2020 2020 2020  ends..          
+00005370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005380: 2020 4465 6661 756c 7420 4e6f 6e65 2e0a    Default None..
+00005390: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
+000053a0: 3a0a 2020 2020 2020 2020 2020 2020 4e6f  :.            No
+000053b0: 6e65 0a20 2020 2020 2020 2027 2727 0a0a  ne.        '''..
+000053c0: 2020 2020 2020 2020 2320 6368 6563 6b69          # checki
+000053d0: 6e67 2066 6f72 6d61 7420 6f66 2066 696c  ng format of fil
+000053e0: 656e 616d 6520 616e 6420 636f 7272 6563  ename and correc
+000053f0: 7469 6e67 2069 6620 6e65 6365 7373 6172  ting if necessar
+00005400: 790a 2020 2020 2020 2020 6966 2066 696c  y.        if fil
+00005410: 656e 616d 655f 6e63 735b 2d34 3a5d 2021  ename_ncs[-4:] !
+00005420: 3d20 272e 6e63 7327 3a0a 2020 2020 2020  = '.ncs':.      
+00005430: 2020 2020 2020 6669 6c65 6e61 6d65 5f6e        filename_n
+00005440: 6373 203d 2066 696c 656e 616d 655f 6e63  cs = filename_nc
+00005450: 7320 2b20 272e 6e63 7327 0a20 2020 2020  s + '.ncs'.     
+00005460: 2020 2069 6620 7365 7020 696e 2066 696c     if sep in fil
+00005470: 656e 616d 655f 6e63 733a 0a20 2020 2020  ename_ncs:.     
+00005480: 2020 2020 2020 2066 696c 656e 616d 655f         filename_
+00005490: 6e63 7320 3d20 6669 6c65 6e61 6d65 5f6e  ncs = filename_n
+000054a0: 6373 2e73 706c 6974 2873 6570 295b 2d31  cs.split(sep)[-1
+000054b0: 5d0a 0a20 2020 2020 2020 2023 2045 7874  ]..        # Ext
+000054c0: 7261 6374 696e 6720 7468 6520 6368 616e  racting the chan
+000054d0: 6e65 6c20 6964 2066 726f 6d20 7072 6573  nel id from pres
+000054e0: 6361 6e20 2861 7373 6f63 6961 7469 6f6e  can (association
+000054f0: 2920 6f66 206e 6373 2066 696c 6573 2077  ) of ncs files w
+00005500: 6974 680a 2020 2020 2020 2020 2320 7468  ith.        # th
+00005510: 6973 2072 6563 6f72 6469 6e67 2073 6573  is recording ses
+00005520: 7369 6f6e 0a20 2020 2020 2020 2063 6869  sion.        chi
+00005530: 6420 3d20 7365 6c66 2e67 6574 5f63 6861  d = self.get_cha
+00005540: 6e6e 656c 5f69 645f 6279 5f66 696c 655f  nnel_id_by_file_
+00005550: 6e61 6d65 2866 696c 656e 616d 655f 6e63  name(filename_nc
+00005560: 7329 0a20 2020 2020 2020 2069 6620 6368  s).        if ch
+00005570: 6964 2069 7320 4e6f 6e65 3a0a 2020 2020  id is None:.    
+00005580: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00005590: 6c75 6545 7272 6f72 2827 4e65 7572 616c  lueError('Neural
+000055a0: 796e 7849 4f20 6973 2061 7474 656d 7074  ynxIO is attempt
+000055b0: 696e 6720 746f 2072 6561 6420 6120 6669  ing to read a fi
+000055c0: 6c65 2027 0a20 2020 2020 2020 2020 2020  le '.           
+000055d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000055e0: 2020 276e 6f74 2061 7373 6f63 6961 7465    'not associate
+000055f0: 6420 746f 2074 6869 7320 7365 7373 696f  d to this sessio
+00005600: 6e20 2825 7329 2e27 2025 2028 0a20 2020  n (%s).' % (.   
+00005610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005620: 2020 2020 2020 2020 2020 2020 2020 6669                fi
+00005630: 6c65 6e61 6d65 5f6e 6373 2929 0a0a 2020  lename_ncs))..  
+00005640: 2020 2020 2020 6966 206e 6f74 2063 6173        if not cas
+00005650: 6361 6465 3a0a 2020 2020 2020 2020 2020  cade:.          
+00005660: 2020 7265 7475 726e 0a0a 2020 2020 2020    return..      
+00005670: 2020 2320 7265 6164 2064 6174 610a 2020    # read data.  
+00005680: 2020 2020 2020 6865 6164 6572 5f74 696d        header_tim
+00005690: 655f 6461 7461 203d 2073 656c 662e 5f5f  e_data = self.__
+000056a0: 6d6d 6170 5f6e 6373 5f70 6163 6b65 745f  mmap_ncs_packet_
+000056b0: 7469 6d65 7374 616d 7073 2866 696c 656e  timestamps(filen
+000056c0: 616d 655f 6e63 7329 0a0a 2020 2020 2020  ame_ncs)..      
+000056d0: 2020 6461 7461 203d 2073 656c 662e 5f5f    data = self.__
+000056e0: 6d6d 6170 5f6e 6373 5f64 6174 6128 6669  mmap_ncs_data(fi
+000056f0: 6c65 6e61 6d65 5f6e 6373 290a 0a20 2020  lename_ncs)..   
+00005700: 2020 2020 2023 2065 6e73 7572 6520 6d65       # ensure me
+00005710: 616e 696e 6766 756c 2076 616c 7565 7320  aningful values 
+00005720: 666f 7220 7265 7175 6573 7465 6420 7374  for requested st
+00005730: 6172 7420 616e 6420 7374 6f70 2074 696d  art and stop tim
+00005740: 6573 0a20 2020 2020 2020 2023 2069 6e20  es.        # in 
+00005750: 6361 7365 2074 696d 6520 6973 2070 726f  case time is pro
+00005760: 7669 6465 6420 696e 2073 616d 706c 6573  vided in samples
+00005770: 3a20 7472 616e 7366 6f72 6d20 746f 2061  : transform to a
+00005780: 6273 6f6c 7574 6520 7469 6d65 2075 6e69  bsolute time uni
+00005790: 7473 0a20 2020 2020 2020 2069 6620 6973  ts.        if is
+000057a0: 696e 7374 616e 6365 2874 5f73 7461 7274  instance(t_start
 000057b0: 2c20 696e 7429 3a0a 2020 2020 2020 2020  , int):.        
-000057c0: 2020 2020 745f 7374 6f70 203d 2074 5f73      t_stop = t_s
-000057d0: 746f 7020 2f20 7365 6c66 2e70 6172 616d  top / self.param
-000057e0: 6574 6572 735f 6e63 735b 6368 6964 5d5b  eters_ncs[chid][
-000057f0: 2773 616d 706c 696e 675f 7261 7465 275d  'sampling_rate']
-00005800: 0a0a 2020 2020 2020 2020 2320 7265 7363  ..        # resc
-00005810: 616c 696e 6720 746f 2067 6c6f 6261 6c20  aling to global 
-00005820: 7374 6172 7420 7469 6d65 206f 6620 7265  start time of re
-00005830: 636f 7264 696e 6720 2874 696d 6520 6f66  cording (time of
-00005840: 2066 6972 7374 2073 616d 706c 650a 2020   first sample.  
-00005850: 2020 2020 2020 2320 696e 2061 6e79 2066        # in any f
-00005860: 696c 6520 7479 7065 290a 2020 2020 2020  ile type).      
-00005870: 2020 6966 2074 5f73 7461 7274 2069 7320    if t_start is 
-00005880: 4e6f 6e65 206f 7220 745f 7374 6172 7420  None or t_start 
-00005890: 3c20 280a 2020 2020 2020 2020 2020 2020  < (.            
-000058a0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-000058b0: 6e63 735b 6368 6964 5d5b 2774 5f73 7461  ncs[chid]['t_sta
-000058c0: 7274 275d 0a20 2020 2020 2020 2020 2020  rt'].           
-000058d0: 202d 2073 656c 662e 7061 7261 6d65 7465   - self.paramete
-000058e0: 7273 5f67 6c6f 6261 6c5b 0a20 2020 2020  rs_global[.     
-000058f0: 2020 2020 2020 2020 2020 2027 745f 7374             't_st
-00005900: 6172 7427 5d29 3a0a 2020 2020 2020 2020  art']):.        
-00005910: 2020 2020 745f 7374 6172 7420 3d20 280a      t_start = (.
-00005920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005930: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00005940: 6e63 735b 6368 6964 5d5b 2774 5f73 7461  ncs[chid]['t_sta
-00005950: 7274 275d 202d 2073 656c 662e 7061 7261  rt'] - self.para
-00005960: 6d65 7465 7273 5f67 6c6f 6261 6c5b 0a20  meters_global[. 
-00005970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005980: 2020 2027 745f 7374 6172 7427 5d29 0a0a     't_start'])..
-00005990: 2020 2020 2020 2020 6966 2074 5f73 7461          if t_sta
-000059a0: 7274 203e 2028 0a20 2020 2020 2020 2020  rt > (.         
-000059b0: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
-000059c0: 7273 5f6e 6373 5b63 6869 645d 5b27 745f  rs_ncs[chid]['t_
-000059d0: 7374 6f70 275d 0a20 2020 2020 2020 2020  stop'].         
-000059e0: 2020 202d 2073 656c 662e 7061 7261 6d65     - self.parame
-000059f0: 7465 7273 5f67 6c6f 6261 6c5b 0a20 2020  ters_global[.   
-00005a00: 2020 2020 2020 2020 2020 2020 2027 745f               't_
-00005a10: 7374 6172 7427 5d29 3a0a 2020 2020 2020  start']):.      
-00005a20: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00005a30: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
-00005a40: 2020 2020 2020 2020 2752 6571 7565 7374          'Request
-00005a50: 6564 2074 696d 6573 2077 696e 646f 7720  ed times window 
-00005a60: 2825 7320 746f 2025 7329 2069 7320 6c61  (%s to %s) is la
-00005a70: 7465 7220 7468 616e 2064 6174 6120 6172  ter than data ar
-00005a80: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
-00005a90: 2020 2020 2772 6563 6f72 6465 6420 2874      'recorded (t
-00005aa0: 5f73 746f 7020 3d20 2573 2920 270a 2020  _stop = %s) '.  
-00005ab0: 2020 2020 2020 2020 2020 2020 2020 2766                'f
-00005ac0: 6f72 2066 696c 6520 2573 2e27 2025 2028  or file %s.' % (
-00005ad0: 745f 7374 6172 742c 2074 5f73 746f 702c  t_start, t_stop,
-00005ae0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005b00: 2020 2028 7365 6c66 2e70 6172 616d 6574     (self.paramet
-00005b10: 6572 735f 6e63 735b 6368 6964 5d5b 2774  ers_ncs[chid]['t
-00005b20: 5f73 746f 7027 5d0a 2020 2020 2020 2020  _stop'].        
-00005b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005b40: 2020 2020 2020 2020 2020 202d 2073 656c             - sel
-00005b50: 662e 7061 7261 6d65 7465 7273 5f67 6c6f  f.parameters_glo
-00005b60: 6261 6c5b 2774 5f73 7461 7274 275d 292c  bal['t_start']),
-00005b70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005b90: 2020 2066 696c 656e 616d 655f 6e63 7329     filename_ncs)
-00005ba0: 290a 0a20 2020 2020 2020 2069 6620 745f  )..        if t_
-00005bb0: 7374 6f70 2069 7320 4e6f 6e65 206f 7220  stop is None or 
-00005bc0: 745f 7374 6f70 203e 2028 0a20 2020 2020  t_stop > (.     
-00005bd0: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
-00005be0: 6d65 7465 7273 5f6e 6373 5b63 6869 645d  meters_ncs[chid]
-00005bf0: 5b27 745f 7374 6f70 275d 0a20 2020 2020  ['t_stop'].     
-00005c00: 2020 2020 2020 202d 2073 656c 662e 7061         - self.pa
-00005c10: 7261 6d65 7465 7273 5f67 6c6f 6261 6c5b  rameters_global[
-00005c20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005c30: 2027 745f 7374 6172 7427 5d29 3a0a 2020   't_start']):.  
-00005c40: 2020 2020 2020 2020 2020 745f 7374 6f70            t_stop
-00005c50: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-00005c60: 2020 2020 2073 656c 662e 7061 7261 6d65       self.parame
-00005c70: 7465 7273 5f6e 6373 5b63 6869 645d 5b27  ters_ncs[chid]['
-00005c80: 745f 7374 6f70 275d 202d 2073 656c 662e  t_stop'] - self.
-00005c90: 7061 7261 6d65 7465 7273 5f67 6c6f 6261  parameters_globa
-00005ca0: 6c5b 0a20 2020 2020 2020 2020 2020 2020  l[.             
-00005cb0: 2020 2020 2020 2027 745f 7374 6172 7427         't_start'
-00005cc0: 5d29 0a0a 2020 2020 2020 2020 6966 2074  ])..        if t
-00005cd0: 5f73 746f 7020 3c20 280a 2020 2020 2020  _stop < (.      
-00005ce0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
-00005cf0: 6172 616d 6574 6572 735f 6e63 735b 6368  arameters_ncs[ch
-00005d00: 6964 5d5b 2774 5f73 7461 7274 275d 0a20  id]['t_start']. 
-00005d10: 2020 2020 2020 2020 2020 2020 2020 202d                 -
-00005d20: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-00005d30: 5f67 6c6f 6261 6c5b 2774 5f73 7461 7274  _global['t_start
-00005d40: 275d 293a 0a20 2020 2020 2020 2020 2020  ']):.           
-00005d50: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00005d60: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-00005d70: 2020 2027 5265 7175 6573 7465 6420 7469     'Requested ti
-00005d80: 6d65 7320 7769 6e64 6f77 2028 2573 2074  mes window (%s t
-00005d90: 6f20 2573 2920 6973 2065 6172 6c69 6572  o %s) is earlier
-00005da0: 2074 6861 6e20 6461 7461 2027 0a20 2020   than data '.   
-00005db0: 2020 2020 2020 2020 2020 2020 2027 6172               'ar
-00005dc0: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
-00005dd0: 2020 2020 2772 6563 6f72 6465 6420 2874      'recorded (t
-00005de0: 5f73 7461 7274 203d 2025 7329 2027 0a20  _start = %s) '. 
-00005df0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00005e00: 666f 7220 6669 6c65 2025 732e 2720 2520  for file %s.' % 
-00005e10: 2874 5f73 7461 7274 2c20 745f 7374 6f70  (t_start, t_stop
-00005e20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00005e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005e40: 2020 2020 2873 656c 662e 7061 7261 6d65      (self.parame
-00005e50: 7465 7273 5f6e 6373 5b63 6869 645d 5b27  ters_ncs[chid]['
-00005e60: 745f 7374 6172 7427 5d0a 2020 2020 2020  t_start'].      
-00005e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005e80: 2020 2020 2020 2020 2020 2020 202d 2073               - s
-00005e90: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
-00005ea0: 6c6f 6261 6c5b 2774 5f73 7461 7274 275d  lobal['t_start']
-00005eb0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00005ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005ed0: 2020 2020 2066 696c 656e 616d 655f 6e63       filename_nc
-00005ee0: 7329 290a 2020 2020 2020 2020 6966 2074  s)).        if t
-00005ef0: 5f73 7461 7274 203e 3d20 745f 7374 6f70  _start >= t_stop
-00005f00: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-00005f10: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
-00005f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005f30: 2752 6571 7565 7374 6564 2073 7461 7274  'Requested start
-00005f40: 2074 696d 6520 2825 7329 2069 7320 6c61   time (%s) is la
-00005f50: 7465 7220 7468 616e 202f 2065 7175 616c  ter than / equal
-00005f60: 2074 6f20 7374 6f70 2027 0a20 2020 2020   to stop '.     
-00005f70: 2020 2020 2020 2020 2020 2027 7469 6d65             'time
-00005f80: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-00005f90: 2020 2027 2825 7329 2027 0a20 2020 2020     '(%s) '.     
-00005fa0: 2020 2020 2020 2020 2020 2027 666f 7220             'for 
-00005fb0: 6669 6c65 2025 732e 2720 2520 2874 5f73  file %s.' % (t_s
-00005fc0: 7461 7274 2c20 745f 7374 6f70 2c20 6669  tart, t_stop, fi
-00005fd0: 6c65 6e61 6d65 5f6e 6373 2929 0a0a 2020  lename_ncs))..  
-00005fe0: 2020 2020 2020 2320 4578 7472 6163 7469        # Extracti
-00005ff0: 6e67 2064 6174 6120 7369 676e 616c 2069  ng data signal i
-00006000: 6e20 7265 7175 6573 7465 6420 7469 6d65  n requested time
-00006010: 2077 696e 646f 770a 2020 2020 2020 2020   window.        
-00006020: 756e 6974 203d 2070 712e 6469 6d65 6e73  unit = pq.dimens
-00006030: 696f 6e6c 6573 7320 2023 2064 6566 6175  ionless  # defau
-00006040: 6c74 2076 616c 7565 0a20 2020 2020 2020  lt value.       
-00006050: 2069 6620 6c61 7a79 3a0a 2020 2020 2020   if lazy:.      
-00006060: 2020 2020 2020 7369 6720 3d20 5b5d 0a20        sig = []. 
-00006070: 2020 2020 2020 2020 2020 2070 5f69 645f             p_id_
-00006080: 7374 6172 7420 3d20 300a 2020 2020 2020  start = 0.      
-00006090: 2020 656c 7365 3a0a 0a20 2020 2020 2020    else:..       
-000060a0: 2020 2020 2074 7374 616d 7073 203d 2068       tstamps = h
-000060b0: 6561 6465 725f 7469 6d65 5f64 6174 6120  eader_time_data 
-000060c0: 2a20 7365 6c66 2e6e 6373 5f74 696d 655f  * self.ncs_time_
-000060d0: 756e 6974 202d 205c 0a20 2020 2020 2020  unit - \.       
-000060e0: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
-000060f0: 7261 6d65 7465 7273 5f67 6c6f 6261 6c5b  rameters_global[
-00006100: 2774 5f73 7461 7274 275d 0a0a 2020 2020  't_start']..    
-00006110: 2020 2020 2020 2020 2320 6669 6e64 2064          # find d
-00006120: 6174 6120 7061 636b 6574 2074 6f20 7374  ata packet to st
-00006130: 6172 7420 7769 7468 2073 6967 6e61 6c20  art with signal 
-00006140: 636f 6e73 7472 7563 7469 6f6e 0a20 2020  construction.   
-00006150: 2020 2020 2020 2020 2073 7461 7274 7320           starts 
-00006160: 3d20 6e70 2e77 6865 7265 2874 7374 616d  = np.where(tstam
-00006170: 7073 203c 3d20 745f 7374 6172 7429 5b30  ps <= t_start)[0
-00006180: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
-00006190: 206c 656e 2873 7461 7274 7329 203d 3d20   len(starts) == 
-000061a0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-000061b0: 2020 2073 656c 662e 5f64 6961 676e 6f73     self._diagnos
-000061c0: 7469 635f 7072 696e 7428 0a20 2020 2020  tic_print(.     
-000061d0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-000061e0: 5265 7175 6573 7465 6420 416e 616c 6f67  Requested Analog
-000061f0: 5369 676e 616c 206e 6f74 2070 7265 7365  Signal not prese
-00006200: 6e74 2069 6e20 7468 6973 2074 696d 6520  nt in this time 
-00006210: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
-00006220: 2020 2020 2020 2769 6e74 6572 7661 6c2e        'interval.
-00006230: 2729 0a20 2020 2020 2020 2020 2020 2020  ').             
-00006240: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
-00006250: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00006260: 2020 2020 2020 2020 2020 2020 2320 6669              # fi
-00006270: 7273 7420 7061 636b 6574 2074 6f20 6265  rst packet to be
-00006280: 2069 6e63 6c75 6465 6420 696e 746f 2073   included into s
-00006290: 6967 6e61 6c0a 2020 2020 2020 2020 2020  ignal.          
-000062a0: 2020 2020 2020 705f 6964 5f73 7461 7274        p_id_start
-000062b0: 203d 2073 7461 7274 735b 2d31 5d0a 2020   = starts[-1].  
-000062c0: 2020 2020 2020 2020 2020 2320 6669 6e64            # find
-000062d0: 2064 6174 6120 7061 636b 6574 2077 6865   data packet whe
-000062e0: 7265 2073 6967 6e61 6c20 656e 6473 2028  re signal ends (
-000062f0: 6475 6520 746f 2067 6170 206f 7220 745f  due to gap or t_
-00006300: 7374 6f70 290a 2020 2020 2020 2020 2020  stop).          
-00006310: 2020 7374 6f70 7320 3d20 6e70 2e77 6865    stops = np.whe
-00006320: 7265 2874 7374 616d 7073 203e 3d20 745f  re(tstamps >= t_
-00006330: 7374 6f70 295b 305d 0a20 2020 2020 2020  stop)[0].       
-00006340: 2020 2020 2069 6620 6c65 6e28 7374 6f70       if len(stop
-00006350: 7329 2021 3d20 303a 0a20 2020 2020 2020  s) != 0:.       
-00006360: 2020 2020 2020 2020 2066 6972 7374 5f73           first_s
-00006370: 746f 7020 3d20 5b73 746f 7073 5b30 5d5d  top = [stops[0]]
-00006380: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00006390: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-000063a0: 2020 2066 6972 7374 5f73 746f 7020 3d20     first_stop = 
-000063b0: 5b5d 0a0a 2020 2020 2020 2020 2020 2020  []..            
-000063c0: 2320 6c61 7374 2070 6163 6b65 7420 746f  # last packet to
-000063d0: 2062 6520 696e 636c 7564 6564 2069 6e20   be included in 
-000063e0: 7369 676e 616c 0a20 2020 2020 2020 2020  signal.         
-000063f0: 2020 2070 5f69 645f 7374 6f70 203d 206d     p_id_stop = m
-00006400: 696e 2866 6972 7374 5f73 746f 7020 2b20  in(first_stop + 
-00006410: 5b6c 656e 2864 6174 6129 5d29 0a0a 2020  [len(data)])..  
-00006420: 2020 2020 2020 2020 2020 2320 7365 6172            # sear
-00006430: 6368 2067 6170 7320 696e 2072 6563 6f72  ch gaps in recor
-00006440: 6469 6e67 2069 6e20 7469 6d65 2072 616e  ding in time ran
-00006450: 6765 2074 6f20 6c6f 6164 0a20 2020 2020  ge to load.     
-00006460: 2020 2020 2020 2067 6170 5f70 6163 6b65         gap_packe
-00006470: 7473 203d 205b 6761 705f 6964 5b30 5d20  ts = [gap_id[0] 
-00006480: 666f 7220 6761 705f 6964 2069 6e0a 2020  for gap_id in.  
-00006490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000064a0: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
-000064b0: 7261 6d65 7465 7273 5f6e 6373 5b63 6869  rameters_ncs[chi
-000064c0: 645d 5b27 6761 7073 275d 2069 660a 2020  d]['gaps'] if.  
-000064d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000064e0: 2020 2020 2020 2020 2067 6170 5f69 645b           gap_id[
-000064f0: 305d 203e 2070 5f69 645f 7374 6172 745d  0] > p_id_start]
-00006500: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00006510: 6c65 6e28 6761 705f 7061 636b 6574 7329  len(gap_packets)
-00006520: 203e 2030 2061 6e64 206d 696e 2867 6170   > 0 and min(gap
-00006530: 5f70 6163 6b65 7473 2920 3c20 705f 6964  _packets) < p_id
-00006540: 5f73 746f 703a 0a20 2020 2020 2020 2020  _stop:.         
-00006550: 2020 2020 2020 2070 5f69 645f 7374 6f70         p_id_stop
-00006560: 203d 206d 696e 2867 6170 5f70 6163 6b65   = min(gap_packe
-00006570: 7473 290a 2020 2020 2020 2020 2020 2020  ts).            
-00006580: 2020 2020 7761 726e 696e 6773 2e77 6172      warnings.war
-00006590: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
-000065a0: 2020 2020 2020 2027 416e 616c 6f67 7369         'Analogsi
-000065b0: 676e 616c 6172 7261 7920 7761 7320 7368  gnalarray was sh
-000065c0: 6f72 7465 6e65 6420 6475 6520 746f 2067  ortened due to g
-000065d0: 6170 2069 6e20 270a 2020 2020 2020 2020  ap in '.        
-000065e0: 2020 2020 2020 2020 2020 2020 2772 6563              'rec
-000065f0: 6f72 6465 6420 270a 2020 2020 2020 2020  orded '.        
-00006600: 2020 2020 2020 2020 2020 2020 2764 6174              'dat
-00006610: 6120 270a 2020 2020 2020 2020 2020 2020  a '.            
-00006620: 2020 2020 2020 2020 2720 6f66 2066 696c          ' of fil
-00006630: 6520 2573 2061 7420 7061 636b 6574 2069  e %s at packet i
-00006640: 6420 2569 2720 2520 280a 2020 2020 2020  d %i' % (.      
-00006650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006660: 2020 6669 6c65 6e61 6d65 5f6e 6373 2c20    filename_ncs, 
-00006670: 6d69 6e28 6761 705f 7061 636b 6574 7329  min(gap_packets)
-00006680: 2929 0a0a 2020 2020 2020 2020 2020 2020  ))..            
-00006690: 2320 7365 6172 6368 2062 726f 6b65 6e20  # search broken 
-000066a0: 7061 636b 6574 7320 696e 2074 696d 6520  packets in time 
-000066b0: 7261 6e67 6520 746f 206c 6f61 640a 2020  range to load.  
-000066c0: 2020 2020 2020 2020 2020 6272 6f6b 656e            broken
-000066d0: 5f70 6163 6b65 7473 203d 205b 5d0a 2020  _packets = [].  
-000066e0: 2020 2020 2020 2020 2020 6966 2027 6272            if 'br
-000066f0: 6f6b 656e 5f70 6163 6b65 7427 2069 6e20  oken_packet' in 
-00006700: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00006710: 6e63 735b 6368 6964 5d3a 0a20 2020 2020  ncs[chid]:.     
-00006720: 2020 2020 2020 2020 2020 2062 726f 6b65             broke
-00006730: 6e5f 7061 636b 6574 7320 3d20 5b70 6163  n_packets = [pac
-00006740: 6b65 745b 305d 2066 6f72 2070 6163 6b65  ket[0] for packe
-00006750: 7420 696e 0a20 2020 2020 2020 2020 2020  t in.           
-00006760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006770: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
-00006780: 6d65 7465 7273 5f6e 6373 5b63 6869 645d  meters_ncs[chid]
-00006790: 5b27 6272 6f6b 656e 5f70 6163 6b65 7427  ['broken_packet'
-000067a0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-000067b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067c0: 2020 2020 6966 2070 6163 6b65 745b 305d      if packet[0]
-000067d0: 203e 2070 5f69 645f 7374 6172 745d 0a20   > p_id_start]. 
-000067e0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-000067f0: 6e28 6272 6f6b 656e 5f70 6163 6b65 7473  n(broken_packets
-00006800: 2920 3e20 3020 616e 6420 6d69 6e28 6272  ) > 0 and min(br
-00006810: 6f6b 656e 5f70 6163 6b65 7473 2920 3c20  oken_packets) < 
-00006820: 705f 6964 5f73 746f 703a 0a20 2020 2020  p_id_stop:.     
-00006830: 2020 2020 2020 2020 2020 2070 5f69 645f             p_id_
-00006840: 7374 6f70 203d 206d 696e 2862 726f 6b65  stop = min(broke
-00006850: 6e5f 7061 636b 6574 7329 0a20 2020 2020  n_packets).     
-00006860: 2020 2020 2020 2020 2020 2077 6172 6e69             warni
-00006870: 6e67 732e 7761 726e 280a 2020 2020 2020  ngs.warn(.      
-00006880: 2020 2020 2020 2020 2020 2020 2020 2741                'A
-00006890: 6e61 6c6f 6773 6967 6e61 6c61 7272 6179  nalogsignalarray
-000068a0: 2077 6173 2073 686f 7274 656e 6564 2064   was shortened d
-000068b0: 7565 2074 6f20 6272 6f6b 656e 2064 6174  ue to broken dat
-000068c0: 6120 270a 2020 2020 2020 2020 2020 2020  a '.            
-000068d0: 2020 2020 2020 2020 2770 6163 6b65 7420          'packet 
-000068e0: 696e 2072 6563 6f72 6465 6420 6461 7461  in recorded data
-000068f0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-00006900: 2020 2020 2020 2027 206f 6620 6669 6c65         ' of file
-00006910: 2025 7320 6174 2070 6163 6b65 7420 6964   %s at packet id
-00006920: 2025 6927 2025 2028 0a20 2020 2020 2020   %i' % (.       
-00006930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006940: 2066 696c 656e 616d 655f 6e63 732c 206d   filename_ncs, m
-00006950: 696e 2862 726f 6b65 6e5f 7061 636b 6574  in(broken_packet
-00006960: 7329 2929 0a0a 2020 2020 2020 2020 2020  s)))..          
-00006970: 2020 2320 636f 6e73 7472 7563 7420 7369    # construct si
-00006980: 676e 616c 2069 6e20 7661 6c69 6420 7061  gnal in valid pa
-00006990: 636b 6574 2072 616e 6765 0a20 2020 2020  cket range.     
-000069a0: 2020 2020 2020 2073 6967 203d 206e 702e         sig = np.
-000069b0: 6172 7261 7928 6461 7461 5b70 5f69 645f  array(data[p_id_
-000069c0: 7374 6172 743a 705f 6964 5f73 746f 7020  start:p_id_stop 
-000069d0: 2b20 315d 2c20 6474 7970 653d 666c 6f61  + 1], dtype=floa
-000069e0: 7429 0a20 2020 2020 2020 2020 2020 2073  t).            s
-000069f0: 6967 203d 2073 6967 2e72 6573 6861 7065  ig = sig.reshape
-00006a00: 286c 656e 2873 6967 2920 2a20 6c65 6e28  (len(sig) * len(
-00006a10: 7369 675b 305d 2929 0a0a 2020 2020 2020  sig[0]))..      
-00006a20: 2020 2020 2020 2320 4144 4269 7456 6f6c        # ADBitVol
-00006a30: 7473 2069 7320 6e6f 7420 6775 6172 616e  ts is not guaran
-00006a40: 7465 6564 2074 6f20 6265 2070 7265 7365  teed to be prese
-00006a50: 6e74 2069 6e20 7468 6520 6865 6164 6572  nt in the header
-00006a60: 210a 2020 2020 2020 2020 2020 2020 6966  !.            if
-00006a70: 2027 4144 4269 7456 6f6c 7473 2720 696e   'ADBitVolts' in
-00006a80: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-00006a90: 5f6e 6373 5b63 6869 645d 3a0a 2020 2020  _ncs[chid]:.    
-00006aa0: 2020 2020 2020 2020 2020 2020 7369 6720              sig 
-00006ab0: 2a3d 2073 656c 662e 7061 7261 6d65 7465  *= self.paramete
-00006ac0: 7273 5f6e 6373 5b63 6869 645d 5b27 4144  rs_ncs[chid]['AD
-00006ad0: 4269 7456 6f6c 7473 275d 0a20 2020 2020  BitVolts'].     
-00006ae0: 2020 2020 2020 2020 2020 2075 6e69 7420             unit 
-00006af0: 3d20 7071 2e56 0a20 2020 2020 2020 2020  = pq.V.         
-00006b00: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00006b10: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
-00006b20: 732e 7761 726e 280a 2020 2020 2020 2020  s.warn(.        
-00006b30: 2020 2020 2020 2020 2020 2020 2743 6f75              'Cou
-00006b40: 6c64 206e 6f74 2074 7261 6e73 666f 726d  ld not transform
-00006b50: 2064 6174 6120 6672 6f6d 2066 696c 6520   data from file 
-00006b60: 2573 2069 6e74 6f20 7068 7973 6963 616c  %s into physical
-00006b70: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-00006b80: 2020 2020 2020 2027 7369 676e 616c 2e20         'signal. 
-00006b90: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
-00006ba0: 2020 2020 2020 274d 6973 7369 6e67 2022        'Missing "
-00006bb0: 4144 4269 7456 6f6c 7473 2220 7661 6c75  ADBitVolts" valu
-00006bc0: 6520 696e 2074 6578 7420 6865 6164 6572  e in text header
-00006bd0: 2e27 290a 0a20 2020 2020 2020 2023 2064  .')..        # d
-00006be0: 6566 696e 696e 6720 7361 6d70 6c69 6e67  efining sampling
-00006bf0: 2072 6174 6520 666f 7220 7265 7363 616c   rate for rescal
-00006c00: 696e 6720 7075 7270 6f73 6573 0a20 2020  ing purposes.   
-00006c10: 2020 2020 2073 616d 706c 696e 675f 7261       sampling_ra
-00006c20: 7465 203d 2073 656c 662e 7061 7261 6d65  te = self.parame
-00006c30: 7465 7273 5f6e 6373 5b63 6869 645d 5b27  ters_ncs[chid]['
-00006c40: 7361 6d70 6c69 6e67 5f75 6e69 7427 5d5b  sampling_unit'][
-00006c50: 305d 0a20 2020 2020 2020 2023 2063 7265  0].        # cre
-00006c60: 6174 696e 6720 6e65 6f20 416e 616c 6f67  ating neo Analog
-00006c70: 5369 676e 616c 2063 6f6e 7461 696e 696e  Signal containin
-00006c80: 6720 6461 7461 0a20 2020 2020 2020 2061  g data.        a
-00006c90: 6e61 7369 6720 3d20 416e 616c 6f67 5369  nasig = AnalogSi
-00006ca0: 676e 616c 2873 6967 6e61 6c3d 7071 2e51  gnal(signal=pq.Q
-00006cb0: 7561 6e74 6974 7928 7369 672c 2075 6e69  uantity(sig, uni
-00006cc0: 742c 2063 6f70 793d 4661 6c73 6529 2c0a  t, copy=False),.
-00006cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006ce0: 2020 2020 2020 2020 2020 2020 2020 7361                sa
-00006cf0: 6d70 6c69 6e67 5f72 6174 653d 3120 2a20  mpling_rate=1 * 
-00006d00: 7361 6d70 6c69 6e67 5f72 6174 652c 0a20  sampling_rate,. 
-00006d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006d20: 2020 2020 2020 2020 2020 2020 2023 2072               # r
-00006d30: 6573 6361 6c69 6e67 2074 5f73 7461 7274  escaling t_start
-00006d40: 2074 6f20 7361 6d70 6c69 6e67 2074 696d   to sampling tim
-00006d50: 6520 756e 6974 730a 2020 2020 2020 2020  e units.        
-00006d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006d70: 2020 2020 2020 745f 7374 6172 743d 2868        t_start=(h
-00006d80: 6561 6465 725f 7469 6d65 5f64 6174 615b  eader_time_data[
-00006d90: 705f 6964 5f73 7461 7274 5d20 2a20 7365  p_id_start] * se
-00006da0: 6c66 2e6e 6373 5f74 696d 655f 756e 6974  lf.ncs_time_unit
-00006db0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006dd0: 2020 202d 2073 656c 662e 7061 7261 6d65     - self.parame
-00006de0: 7465 7273 5f67 6c6f 6261 6c5b 2774 5f73  ters_global['t_s
-00006df0: 7461 7274 275d 292e 7265 7363 616c 6528  tart']).rescale(
-00006e00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006e20: 2020 2020 2020 2031 202f 2073 616d 706c         1 / sampl
-00006e30: 696e 675f 7261 7465 292c 0a20 2020 2020  ing_rate),.     
-00006e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006e50: 2020 2020 2020 2020 206e 616d 653d 2763           name='c
-00006e60: 6861 6e6e 656c 5f25 6927 2025 2028 6368  hannel_%i' % (ch
-00006e70: 6964 292c 0a20 2020 2020 2020 2020 2020  id),.           
+000057c0: 2020 2020 745f 7374 6172 7420 3d20 745f      t_start = t_
+000057d0: 7374 6172 7420 2f20 7365 6c66 2e70 6172  start / self.par
+000057e0: 616d 6574 6572 735f 6e63 735b 6368 6964  ameters_ncs[chid
+000057f0: 5d5b 2773 616d 706c 696e 675f 7261 7465  ]['sampling_rate
+00005800: 275d 0a20 2020 2020 2020 2069 6620 6973  '].        if is
+00005810: 696e 7374 616e 6365 2874 5f73 746f 702c  instance(t_stop,
+00005820: 2069 6e74 293a 0a20 2020 2020 2020 2020   int):.         
+00005830: 2020 2074 5f73 746f 7020 3d20 745f 7374     t_stop = t_st
+00005840: 6f70 202f 2073 656c 662e 7061 7261 6d65  op / self.parame
+00005850: 7465 7273 5f6e 6373 5b63 6869 645d 5b27  ters_ncs[chid]['
+00005860: 7361 6d70 6c69 6e67 5f72 6174 6527 5d0a  sampling_rate'].
+00005870: 0a20 2020 2020 2020 2023 2072 6573 6361  .        # resca
+00005880: 6c69 6e67 2074 6f20 676c 6f62 616c 2073  ling to global s
+00005890: 7461 7274 2074 696d 6520 6f66 2072 6563  tart time of rec
+000058a0: 6f72 6469 6e67 2028 7469 6d65 206f 6620  ording (time of 
+000058b0: 6669 7273 7420 7361 6d70 6c65 0a20 2020  first sample.   
+000058c0: 2020 2020 2023 2069 6e20 616e 7920 6669       # in any fi
+000058d0: 6c65 2074 7970 6529 0a20 2020 2020 2020  le type).       
+000058e0: 2069 6620 745f 7374 6172 7420 6973 204e   if t_start is N
+000058f0: 6f6e 6520 6f72 2074 5f73 7461 7274 203c  one or t_start <
+00005900: 2028 0a20 2020 2020 2020 2020 2020 2073   (.            s
+00005910: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+00005920: 6373 5b63 6869 645d 5b27 745f 7374 6172  cs[chid]['t_star
+00005930: 7427 5d0a 2020 2020 2020 2020 2020 2020  t'].            
+00005940: 2d20 7365 6c66 2e70 6172 616d 6574 6572  - self.parameter
+00005950: 735f 676c 6f62 616c 5b0a 2020 2020 2020  s_global[.      
+00005960: 2020 2020 2020 2020 2020 2774 5f73 7461            't_sta
+00005970: 7274 275d 293a 0a20 2020 2020 2020 2020  rt']):.         
+00005980: 2020 2074 5f73 7461 7274 203d 2028 0a20     t_start = (. 
+00005990: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000059a0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+000059b0: 6373 5b63 6869 645d 5b27 745f 7374 6172  cs[chid]['t_star
+000059c0: 7427 5d20 2d20 7365 6c66 2e70 6172 616d  t'] - self.param
+000059d0: 6574 6572 735f 676c 6f62 616c 5b0a 2020  eters_global[.  
+000059e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000059f0: 2020 2774 5f73 7461 7274 275d 290a 0a20    't_start']).. 
+00005a00: 2020 2020 2020 2069 6620 745f 7374 6172         if t_star
+00005a10: 7420 3e20 280a 2020 2020 2020 2020 2020  t > (.          
+00005a20: 2020 7365 6c66 2e70 6172 616d 6574 6572    self.parameter
+00005a30: 735f 6e63 735b 6368 6964 5d5b 2774 5f73  s_ncs[chid]['t_s
+00005a40: 746f 7027 5d0a 2020 2020 2020 2020 2020  top'].          
+00005a50: 2020 2d20 7365 6c66 2e70 6172 616d 6574    - self.paramet
+00005a60: 6572 735f 676c 6f62 616c 5b0a 2020 2020  ers_global[.    
+00005a70: 2020 2020 2020 2020 2020 2020 2774 5f73              't_s
+00005a80: 7461 7274 275d 293a 0a20 2020 2020 2020  tart']):.       
+00005a90: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00005aa0: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
+00005ab0: 2020 2020 2020 2027 5265 7175 6573 7465         'Requeste
+00005ac0: 6420 7469 6d65 7320 7769 6e64 6f77 2028  d times window (
+00005ad0: 2573 2074 6f20 2573 2920 6973 206c 6174  %s to %s) is lat
+00005ae0: 6572 2074 6861 6e20 6461 7461 2061 7265  er than data are
+00005af0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00005b00: 2020 2027 7265 636f 7264 6564 2028 745f     'recorded (t_
+00005b10: 7374 6f70 203d 2025 7329 2027 0a20 2020  stop = %s) '.   
+00005b20: 2020 2020 2020 2020 2020 2020 2027 666f               'fo
+00005b30: 7220 6669 6c65 2025 732e 2720 2520 2874  r file %s.' % (t
+00005b40: 5f73 7461 7274 2c20 745f 7374 6f70 2c0a  _start, t_stop,.
+00005b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005b70: 2020 2873 656c 662e 7061 7261 6d65 7465    (self.paramete
+00005b80: 7273 5f6e 6373 5b63 6869 645d 5b27 745f  rs_ncs[chid]['t_
+00005b90: 7374 6f70 275d 0a20 2020 2020 2020 2020  stop'].         
+00005ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005bb0: 2020 2020 2020 2020 2020 2d20 7365 6c66            - self
+00005bc0: 2e70 6172 616d 6574 6572 735f 676c 6f62  .parameters_glob
+00005bd0: 616c 5b27 745f 7374 6172 7427 5d29 2c0a  al['t_start']),.
+00005be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005c00: 2020 6669 6c65 6e61 6d65 5f6e 6373 2929    filename_ncs))
+00005c10: 0a0a 2020 2020 2020 2020 6966 2074 5f73  ..        if t_s
+00005c20: 746f 7020 6973 204e 6f6e 6520 6f72 2074  top is None or t
+00005c30: 5f73 746f 7020 3e20 280a 2020 2020 2020  _stop > (.      
+00005c40: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
+00005c50: 6574 6572 735f 6e63 735b 6368 6964 5d5b  eters_ncs[chid][
+00005c60: 2774 5f73 746f 7027 5d0a 2020 2020 2020  't_stop'].      
+00005c70: 2020 2020 2020 2d20 7365 6c66 2e70 6172        - self.par
+00005c80: 616d 6574 6572 735f 676c 6f62 616c 5b0a  ameters_global[.
+00005c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005ca0: 2774 5f73 7461 7274 275d 293a 0a20 2020  't_start']):.   
+00005cb0: 2020 2020 2020 2020 2074 5f73 746f 7020           t_stop 
+00005cc0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+00005cd0: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
+00005ce0: 6572 735f 6e63 735b 6368 6964 5d5b 2774  ers_ncs[chid]['t
+00005cf0: 5f73 746f 7027 5d20 2d20 7365 6c66 2e70  _stop'] - self.p
+00005d00: 6172 616d 6574 6572 735f 676c 6f62 616c  arameters_global
+00005d10: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+00005d20: 2020 2020 2020 2774 5f73 7461 7274 275d        't_start']
+00005d30: 290a 0a20 2020 2020 2020 2069 6620 745f  )..        if t_
+00005d40: 7374 6f70 203c 2028 0a20 2020 2020 2020  stop < (.       
+00005d50: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
+00005d60: 7261 6d65 7465 7273 5f6e 6373 5b63 6869  rameters_ncs[chi
+00005d70: 645d 5b27 745f 7374 6172 7427 5d0a 2020  d]['t_start'].  
+00005d80: 2020 2020 2020 2020 2020 2020 2020 2d20                - 
+00005d90: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00005da0: 676c 6f62 616c 5b27 745f 7374 6172 7427  global['t_start'
+00005db0: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+00005dc0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00005dd0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00005de0: 2020 2752 6571 7565 7374 6564 2074 696d    'Requested tim
+00005df0: 6573 2077 696e 646f 7720 2825 7320 746f  es window (%s to
+00005e00: 2025 7329 2069 7320 6561 726c 6965 7220   %s) is earlier 
+00005e10: 7468 616e 2064 6174 6120 270a 2020 2020  than data '.    
+00005e20: 2020 2020 2020 2020 2020 2020 2761 7265              'are
+00005e30: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00005e40: 2020 2027 7265 636f 7264 6564 2028 745f     'recorded (t_
+00005e50: 7374 6172 7420 3d20 2573 2920 270a 2020  start = %s) '.  
+00005e60: 2020 2020 2020 2020 2020 2020 2020 2766                'f
+00005e70: 6f72 2066 696c 6520 2573 2e27 2025 2028  or file %s.' % (
+00005e80: 745f 7374 6172 742c 2074 5f73 746f 702c  t_start, t_stop,
+00005e90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005eb0: 2020 2028 7365 6c66 2e70 6172 616d 6574     (self.paramet
+00005ec0: 6572 735f 6e63 735b 6368 6964 5d5b 2774  ers_ncs[chid]['t
+00005ed0: 5f73 7461 7274 275d 0a20 2020 2020 2020  _start'].       
+00005ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005ef0: 2020 2020 2020 2020 2020 2020 2d20 7365              - se
+00005f00: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
+00005f10: 6f62 616c 5b27 745f 7374 6172 7427 5d29  obal['t_start'])
+00005f20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00005f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005f40: 2020 2020 6669 6c65 6e61 6d65 5f6e 6373      filename_ncs
+00005f50: 2929 0a20 2020 2020 2020 2069 6620 745f  )).        if t_
+00005f60: 7374 6172 7420 3e3d 2074 5f73 746f 703a  start >= t_stop:
+00005f70: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00005f80: 7365 2056 616c 7565 4572 726f 7228 0a20  se ValueError(. 
+00005f90: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00005fa0: 5265 7175 6573 7465 6420 7374 6172 7420  Requested start 
+00005fb0: 7469 6d65 2028 2573 2920 6973 206c 6174  time (%s) is lat
+00005fc0: 6572 2074 6861 6e20 2f20 6571 7561 6c20  er than / equal 
+00005fd0: 746f 2073 746f 7020 270a 2020 2020 2020  to stop '.      
+00005fe0: 2020 2020 2020 2020 2020 2774 696d 6520            'time 
+00005ff0: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+00006000: 2020 2728 2573 2920 270a 2020 2020 2020    '(%s) '.      
+00006010: 2020 2020 2020 2020 2020 2766 6f72 2066            'for f
+00006020: 696c 6520 2573 2e27 2025 2028 745f 7374  ile %s.' % (t_st
+00006030: 6172 742c 2074 5f73 746f 702c 2066 696c  art, t_stop, fil
+00006040: 656e 616d 655f 6e63 7329 290a 0a20 2020  ename_ncs))..   
+00006050: 2020 2020 2023 2045 7874 7261 6374 696e       # Extractin
+00006060: 6720 6461 7461 2073 6967 6e61 6c20 696e  g data signal in
+00006070: 2072 6571 7565 7374 6564 2074 696d 6520   requested time 
+00006080: 7769 6e64 6f77 0a20 2020 2020 2020 2075  window.        u
+00006090: 6e69 7420 3d20 7071 2e64 696d 656e 7369  nit = pq.dimensi
+000060a0: 6f6e 6c65 7373 2020 2320 6465 6661 756c  onless  # defaul
+000060b0: 7420 7661 6c75 650a 2020 2020 2020 2020  t value.        
+000060c0: 6966 206c 617a 793a 0a20 2020 2020 2020  if lazy:.       
+000060d0: 2020 2020 2073 6967 203d 205b 5d0a 2020       sig = [].  
+000060e0: 2020 2020 2020 2020 2020 705f 6964 5f73            p_id_s
+000060f0: 7461 7274 203d 2030 0a20 2020 2020 2020  tart = 0.       
+00006100: 2065 6c73 653a 0a0a 2020 2020 2020 2020   else:..        
+00006110: 2020 2020 7473 7461 6d70 7320 3d20 6865      tstamps = he
+00006120: 6164 6572 5f74 696d 655f 6461 7461 202a  ader_time_data *
+00006130: 2073 656c 662e 6e63 735f 7469 6d65 5f75   self.ncs_time_u
+00006140: 6e69 7420 2d20 5c0a 2020 2020 2020 2020  nit - \.        
+00006150: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00006160: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
+00006170: 745f 7374 6172 7427 5d0a 0a20 2020 2020  t_start']..     
+00006180: 2020 2020 2020 2023 2066 696e 6420 6461         # find da
+00006190: 7461 2070 6163 6b65 7420 746f 2073 7461  ta packet to sta
+000061a0: 7274 2077 6974 6820 7369 676e 616c 2063  rt with signal c
+000061b0: 6f6e 7374 7275 6374 696f 6e0a 2020 2020  onstruction.    
+000061c0: 2020 2020 2020 2020 7374 6172 7473 203d          starts =
+000061d0: 206e 702e 7768 6572 6528 7473 7461 6d70   np.where(tstamp
+000061e0: 7320 3c3d 2074 5f73 7461 7274 295b 305d  s <= t_start)[0]
+000061f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00006200: 6c65 6e28 7374 6172 7473 2920 3d3d 2030  len(starts) == 0
+00006210: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00006220: 2020 7365 6c66 2e5f 6469 6167 6e6f 7374    self._diagnost
+00006230: 6963 5f70 7269 6e74 280a 2020 2020 2020  ic_print(.      
+00006240: 2020 2020 2020 2020 2020 2020 2020 2752                'R
+00006250: 6571 7565 7374 6564 2041 6e61 6c6f 6753  equested AnalogS
+00006260: 6967 6e61 6c20 6e6f 7420 7072 6573 656e  ignal not presen
+00006270: 7420 696e 2074 6869 7320 7469 6d65 2027  t in this time '
+00006280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006290: 2020 2020 2027 696e 7465 7276 616c 2e27       'interval.'
+000062a0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000062b0: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
+000062c0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000062d0: 2020 2020 2020 2020 2020 2023 2066 6972             # fir
+000062e0: 7374 2070 6163 6b65 7420 746f 2062 6520  st packet to be 
+000062f0: 696e 636c 7564 6564 2069 6e74 6f20 7369  included into si
+00006300: 676e 616c 0a20 2020 2020 2020 2020 2020  gnal.           
+00006310: 2020 2020 2070 5f69 645f 7374 6172 7420       p_id_start 
+00006320: 3d20 7374 6172 7473 5b2d 315d 0a20 2020  = starts[-1].   
+00006330: 2020 2020 2020 2020 2023 2066 696e 6420           # find 
+00006340: 6461 7461 2070 6163 6b65 7420 7768 6572  data packet wher
+00006350: 6520 7369 676e 616c 2065 6e64 7320 2864  e signal ends (d
+00006360: 7565 2074 6f20 6761 7020 6f72 2074 5f73  ue to gap or t_s
+00006370: 746f 7029 0a20 2020 2020 2020 2020 2020  top).           
+00006380: 2073 746f 7073 203d 206e 702e 7768 6572   stops = np.wher
+00006390: 6528 7473 7461 6d70 7320 3e3d 2074 5f73  e(tstamps >= t_s
+000063a0: 746f 7029 5b30 5d0a 2020 2020 2020 2020  top)[0].        
+000063b0: 2020 2020 6966 206c 656e 2873 746f 7073      if len(stops
+000063c0: 2920 213d 2030 3a0a 2020 2020 2020 2020  ) != 0:.        
+000063d0: 2020 2020 2020 2020 6669 7273 745f 7374          first_st
+000063e0: 6f70 203d 205b 7374 6f70 735b 305d 5d0a  op = [stops[0]].
+000063f0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00006400: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00006410: 2020 6669 7273 745f 7374 6f70 203d 205b    first_stop = [
+00006420: 5d0a 0a20 2020 2020 2020 2020 2020 2023  ]..            #
+00006430: 206c 6173 7420 7061 636b 6574 2074 6f20   last packet to 
+00006440: 6265 2069 6e63 6c75 6465 6420 696e 2073  be included in s
+00006450: 6967 6e61 6c0a 2020 2020 2020 2020 2020  ignal.          
+00006460: 2020 705f 6964 5f73 746f 7020 3d20 6d69    p_id_stop = mi
+00006470: 6e28 6669 7273 745f 7374 6f70 202b 205b  n(first_stop + [
+00006480: 6c65 6e28 6461 7461 295d 290a 0a20 2020  len(data)])..   
+00006490: 2020 2020 2020 2020 2023 2073 6561 7263           # searc
+000064a0: 6820 6761 7073 2069 6e20 7265 636f 7264  h gaps in record
+000064b0: 696e 6720 696e 2074 696d 6520 7261 6e67  ing in time rang
+000064c0: 6520 746f 206c 6f61 640a 2020 2020 2020  e to load.      
+000064d0: 2020 2020 2020 6761 705f 7061 636b 6574        gap_packet
+000064e0: 7320 3d20 5b67 6170 5f69 645b 305d 2066  s = [gap_id[0] f
+000064f0: 6f72 2067 6170 5f69 6420 696e 0a20 2020  or gap_id in.   
+00006500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006510: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00006520: 616d 6574 6572 735f 6e63 735b 6368 6964  ameters_ncs[chid
+00006530: 5d5b 2767 6170 7327 5d20 6966 0a20 2020  ]['gaps'] if.   
+00006540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006550: 2020 2020 2020 2020 6761 705f 6964 5b30          gap_id[0
+00006560: 5d20 3e20 705f 6964 5f73 7461 7274 5d0a  ] > p_id_start].
+00006570: 2020 2020 2020 2020 2020 2020 6966 206c              if l
+00006580: 656e 2867 6170 5f70 6163 6b65 7473 2920  en(gap_packets) 
+00006590: 3e20 3020 616e 6420 6d69 6e28 6761 705f  > 0 and min(gap_
+000065a0: 7061 636b 6574 7329 203c 2070 5f69 645f  packets) < p_id_
+000065b0: 7374 6f70 3a0a 2020 2020 2020 2020 2020  stop:.          
+000065c0: 2020 2020 2020 705f 6964 5f73 746f 7020        p_id_stop 
+000065d0: 3d20 6d69 6e28 6761 705f 7061 636b 6574  = min(gap_packet
+000065e0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+000065f0: 2020 2077 6172 6e69 6e67 732e 7761 726e     warnings.warn
+00006600: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00006610: 2020 2020 2020 2741 6e61 6c6f 6773 6967        'Analogsig
+00006620: 6e61 6c61 7272 6179 2077 6173 2073 686f  nalarray was sho
+00006630: 7274 656e 6564 2064 7565 2074 6f20 6761  rtened due to ga
+00006640: 7020 696e 2027 0a20 2020 2020 2020 2020  p in '.         
+00006650: 2020 2020 2020 2020 2020 2027 7265 636f             'reco
+00006660: 7264 6564 2027 0a20 2020 2020 2020 2020  rded '.         
+00006670: 2020 2020 2020 2020 2020 2027 6461 7461             'data
+00006680: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00006690: 2020 2020 2020 2027 206f 6620 6669 6c65         ' of file
+000066a0: 2025 7320 6174 2070 6163 6b65 7420 6964   %s at packet id
+000066b0: 2025 6927 2025 2028 0a20 2020 2020 2020   %i' % (.       
+000066c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000066d0: 2066 696c 656e 616d 655f 6e63 732c 206d   filename_ncs, m
+000066e0: 696e 2867 6170 5f70 6163 6b65 7473 2929  in(gap_packets))
+000066f0: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
+00006700: 2073 6561 7263 6820 6272 6f6b 656e 2070   search broken p
+00006710: 6163 6b65 7473 2069 6e20 7469 6d65 2072  ackets in time r
+00006720: 616e 6765 2074 6f20 6c6f 6164 0a20 2020  ange to load.   
+00006730: 2020 2020 2020 2020 2062 726f 6b65 6e5f           broken_
+00006740: 7061 636b 6574 7320 3d20 5b5d 0a20 2020  packets = [].   
+00006750: 2020 2020 2020 2020 2069 6620 2762 726f           if 'bro
+00006760: 6b65 6e5f 7061 636b 6574 2720 696e 2073  ken_packet' in s
+00006770: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+00006780: 6373 5b63 6869 645d 3a0a 2020 2020 2020  cs[chid]:.      
+00006790: 2020 2020 2020 2020 2020 6272 6f6b 656e            broken
+000067a0: 5f70 6163 6b65 7473 203d 205b 7061 636b  _packets = [pack
+000067b0: 6574 5b30 5d20 666f 7220 7061 636b 6574  et[0] for packet
+000067c0: 2069 6e0a 2020 2020 2020 2020 2020 2020   in.            
+000067d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000067e0: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
+000067f0: 6574 6572 735f 6e63 735b 6368 6964 5d5b  eters_ncs[chid][
+00006800: 2762 726f 6b65 6e5f 7061 636b 6574 275d  'broken_packet']
+00006810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006830: 2020 2069 6620 7061 636b 6574 5b30 5d20     if packet[0] 
+00006840: 3e20 705f 6964 5f73 7461 7274 5d0a 2020  > p_id_start].  
+00006850: 2020 2020 2020 2020 2020 6966 206c 656e            if len
+00006860: 2862 726f 6b65 6e5f 7061 636b 6574 7329  (broken_packets)
+00006870: 203e 2030 2061 6e64 206d 696e 2862 726f   > 0 and min(bro
+00006880: 6b65 6e5f 7061 636b 6574 7329 203c 2070  ken_packets) < p
+00006890: 5f69 645f 7374 6f70 3a0a 2020 2020 2020  _id_stop:.      
+000068a0: 2020 2020 2020 2020 2020 705f 6964 5f73            p_id_s
+000068b0: 746f 7020 3d20 6d69 6e28 6272 6f6b 656e  top = min(broken
+000068c0: 5f70 6163 6b65 7473 290a 2020 2020 2020  _packets).      
+000068d0: 2020 2020 2020 2020 2020 7761 726e 696e            warnin
+000068e0: 6773 2e77 6172 6e28 0a20 2020 2020 2020  gs.warn(.       
+000068f0: 2020 2020 2020 2020 2020 2020 2027 416e               'An
+00006900: 616c 6f67 7369 676e 616c 6172 7261 7920  alogsignalarray 
+00006910: 7761 7320 7368 6f72 7465 6e65 6420 6475  was shortened du
+00006920: 6520 746f 2062 726f 6b65 6e20 6461 7461  e to broken data
+00006930: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00006940: 2020 2020 2020 2027 7061 636b 6574 2069         'packet i
+00006950: 6e20 7265 636f 7264 6564 2064 6174 6120  n recorded data 
+00006960: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+00006970: 2020 2020 2020 2720 6f66 2066 696c 6520        ' of file 
+00006980: 2573 2061 7420 7061 636b 6574 2069 6420  %s at packet id 
+00006990: 2569 2720 2520 280a 2020 2020 2020 2020  %i' % (.        
+000069a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000069b0: 6669 6c65 6e61 6d65 5f6e 6373 2c20 6d69  filename_ncs, mi
+000069c0: 6e28 6272 6f6b 656e 5f70 6163 6b65 7473  n(broken_packets
+000069d0: 2929 290a 0a20 2020 2020 2020 2020 2020  )))..           
+000069e0: 2023 2063 6f6e 7374 7275 6374 2073 6967   # construct sig
+000069f0: 6e61 6c20 696e 2076 616c 6964 2070 6163  nal in valid pac
+00006a00: 6b65 7420 7261 6e67 650a 2020 2020 2020  ket range.      
+00006a10: 2020 2020 2020 7369 6720 3d20 6e70 2e61        sig = np.a
+00006a20: 7272 6179 2864 6174 615b 705f 6964 5f73  rray(data[p_id_s
+00006a30: 7461 7274 3a70 5f69 645f 7374 6f70 202b  tart:p_id_stop +
+00006a40: 2031 5d2c 2064 7479 7065 3d66 6c6f 6174   1], dtype=float
+00006a50: 290a 2020 2020 2020 2020 2020 2020 7369  ).            si
+00006a60: 6720 3d20 7369 672e 7265 7368 6170 6528  g = sig.reshape(
+00006a70: 6c65 6e28 7369 6729 202a 206c 656e 2873  len(sig) * len(s
+00006a80: 6967 5b30 5d29 290a 0a20 2020 2020 2020  ig[0]))..       
+00006a90: 2020 2020 2023 2041 4442 6974 566f 6c74       # ADBitVolt
+00006aa0: 7320 6973 206e 6f74 2067 7561 7261 6e74  s is not guarant
+00006ab0: 6565 6420 746f 2062 6520 7072 6573 656e  eed to be presen
+00006ac0: 7420 696e 2074 6865 2068 6561 6465 7221  t in the header!
+00006ad0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00006ae0: 2741 4442 6974 566f 6c74 7327 2069 6e20  'ADBitVolts' in 
+00006af0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00006b00: 6e63 735b 6368 6964 5d3a 0a20 2020 2020  ncs[chid]:.     
+00006b10: 2020 2020 2020 2020 2020 2073 6967 202a             sig *
+00006b20: 3d20 7365 6c66 2e70 6172 616d 6574 6572  = self.parameter
+00006b30: 735f 6e63 735b 6368 6964 5d5b 2741 4442  s_ncs[chid]['ADB
+00006b40: 6974 566f 6c74 7327 5d0a 2020 2020 2020  itVolts'].      
+00006b50: 2020 2020 2020 2020 2020 756e 6974 203d            unit =
+00006b60: 2070 712e 560a 2020 2020 2020 2020 2020   pq.V.          
+00006b70: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00006b80: 2020 2020 2020 2020 7761 726e 696e 6773          warnings
+00006b90: 2e77 6172 6e28 0a20 2020 2020 2020 2020  .warn(.         
+00006ba0: 2020 2020 2020 2020 2020 2027 436f 756c             'Coul
+00006bb0: 6420 6e6f 7420 7472 616e 7366 6f72 6d20  d not transform 
+00006bc0: 6461 7461 2066 726f 6d20 6669 6c65 2025  data from file %
+00006bd0: 7320 696e 746f 2070 6879 7369 6361 6c20  s into physical 
+00006be0: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+00006bf0: 2020 2020 2020 2773 6967 6e61 6c2e 2027        'signal. '
+00006c00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006c10: 2020 2020 2027 4d69 7373 696e 6720 2241       'Missing "A
+00006c20: 4442 6974 566f 6c74 7322 2076 616c 7565  DBitVolts" value
+00006c30: 2069 6e20 7465 7874 2068 6561 6465 722e   in text header.
+00006c40: 2729 0a0a 2020 2020 2020 2020 2320 6465  ')..        # de
+00006c50: 6669 6e69 6e67 2073 616d 706c 696e 6720  fining sampling 
+00006c60: 7261 7465 2066 6f72 2072 6573 6361 6c69  rate for rescali
+00006c70: 6e67 2070 7572 706f 7365 730a 2020 2020  ng purposes.    
+00006c80: 2020 2020 7361 6d70 6c69 6e67 5f72 6174      sampling_rat
+00006c90: 6520 3d20 7365 6c66 2e70 6172 616d 6574  e = self.paramet
+00006ca0: 6572 735f 6e63 735b 6368 6964 5d5b 2773  ers_ncs[chid]['s
+00006cb0: 616d 706c 696e 675f 756e 6974 275d 5b30  ampling_unit'][0
+00006cc0: 5d0a 2020 2020 2020 2020 2320 6372 6561  ].        # crea
+00006cd0: 7469 6e67 206e 656f 2041 6e61 6c6f 6753  ting neo AnalogS
+00006ce0: 6967 6e61 6c20 636f 6e74 6169 6e69 6e67  ignal containing
+00006cf0: 2064 6174 610a 2020 2020 2020 2020 616e   data.        an
+00006d00: 6173 6967 203d 2041 6e61 6c6f 6753 6967  asig = AnalogSig
+00006d10: 6e61 6c28 7369 676e 616c 3d70 712e 5175  nal(signal=pq.Qu
+00006d20: 616e 7469 7479 2873 6967 2c20 756e 6974  antity(sig, unit
+00006d30: 2c20 636f 7079 3d46 616c 7365 292c 0a20  , copy=False),. 
+00006d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006d50: 2020 2020 2020 2020 2020 2020 2073 616d               sam
+00006d60: 706c 696e 675f 7261 7465 3d31 202a 2073  pling_rate=1 * s
+00006d70: 616d 706c 696e 675f 7261 7465 2c0a 2020  ampling_rate,.  
+00006d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006d90: 2020 2020 2020 2020 2020 2020 2320 7265              # re
+00006da0: 7363 616c 696e 6720 745f 7374 6172 7420  scaling t_start 
+00006db0: 746f 2073 616d 706c 696e 6720 7469 6d65  to sampling time
+00006dc0: 2075 6e69 7473 0a20 2020 2020 2020 2020   units.         
+00006dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006de0: 2020 2020 2074 5f73 7461 7274 3d28 6865       t_start=(he
+00006df0: 6164 6572 5f74 696d 655f 6461 7461 5b70  ader_time_data[p
+00006e00: 5f69 645f 7374 6172 745d 202a 2073 656c  _id_start] * sel
+00006e10: 662e 6e63 735f 7469 6d65 5f75 6e69 740a  f.ncs_time_unit.
+00006e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006e40: 2020 2d20 7365 6c66 2e70 6172 616d 6574    - self.paramet
+00006e50: 6572 735f 676c 6f62 616c 5b27 745f 7374  ers_global['t_st
+00006e60: 6172 7427 5d29 2e72 6573 6361 6c65 280a  art']).rescale(.
+00006e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00006e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006e90: 2020 2063 6861 6e6e 656c 5f69 6e64 6578     channel_index
-00006ea0: 3d63 6869 6429 0a0a 2020 2020 2020 2020  =chid)..        
-00006eb0: 2320 7265 6d6f 7669 6e67 2070 726f 7472  # removing protr
-00006ec0: 7564 696e 6720 7061 7274 7320 6f66 2066  uding parts of f
-00006ed0: 6972 7374 2061 6e64 206c 6173 7420 6461  irst and last da
-00006ee0: 7461 2070 6163 6b65 740a 2020 2020 2020  ta packet.      
-00006ef0: 2020 6966 2061 6e61 7369 672e 745f 7374    if anasig.t_st
-00006f00: 6172 7420 3c20 745f 7374 6172 742e 7265  art < t_start.re
-00006f10: 7363 616c 6528 616e 6173 6967 2e74 5f73  scale(anasig.t_s
-00006f20: 7461 7274 2e75 6e69 7473 293a 0a20 2020  tart.units):.   
-00006f30: 2020 2020 2020 2020 2061 6e61 7369 6720           anasig 
-00006f40: 3d20 616e 6173 6967 2e74 696d 655f 736c  = anasig.time_sl
-00006f50: 6963 6528 745f 7374 6172 742e 7265 7363  ice(t_start.resc
-00006f60: 616c 6528 616e 6173 6967 2e74 5f73 7461  ale(anasig.t_sta
-00006f70: 7274 2e75 6e69 7473 292c 0a20 2020 2020  rt.units),.     
-00006f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006fa0: 2020 4e6f 6e65 290a 2020 2020 2020 2020    None).        
-00006fb0: 6966 2061 6e61 7369 672e 745f 7374 6f70  if anasig.t_stop
-00006fc0: 203e 2074 5f73 746f 702e 7265 7363 616c   > t_stop.rescal
-00006fd0: 6528 616e 6173 6967 2e74 5f73 7461 7274  e(anasig.t_start
-00006fe0: 2e75 6e69 7473 293a 0a20 2020 2020 2020  .units):.       
-00006ff0: 2020 2020 2061 6e61 7369 6720 3d20 616e       anasig = an
-00007000: 6173 6967 2e74 696d 655f 736c 6963 6528  asig.time_slice(
-00007010: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
-00007020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007030: 2020 2020 2020 2020 2020 2020 2074 5f73               t_s
-00007040: 746f 702e 7265 7363 616c 6528 616e 6173  top.rescale(anas
-00007050: 6967 2e74 5f73 7461 7274 2e75 6e69 7473  ig.t_start.units
-00007060: 2929 0a0a 2020 2020 2020 2020 616e 6e6f  ))..        anno
-00007070: 7461 7469 6f6e 7320 3d20 636f 7079 2e64  tations = copy.d
-00007080: 6565 7063 6f70 7928 7365 6c66 2e70 6172  eepcopy(self.par
-00007090: 616d 6574 6572 735f 6e63 735b 6368 6964  ameters_ncs[chid
-000070a0: 5d29 0a20 2020 2020 2020 2066 6f72 2070  ]).        for p
-000070b0: 6f70 5f6b 6579 2069 6e20 5b27 7361 6d70  op_key in ['samp
-000070c0: 6c69 6e67 5f72 6174 6527 2c20 2774 5f73  ling_rate', 't_s
-000070d0: 7461 7274 275d 3a0a 2020 2020 2020 2020  tart']:.        
-000070e0: 2020 2020 6966 2070 6f70 5f6b 6579 2069      if pop_key i
-000070f0: 6e20 616e 6e6f 7461 7469 6f6e 733a 0a20  n annotations:. 
-00007100: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-00007110: 6e6e 6f74 6174 696f 6e73 2e70 6f70 2870  nnotations.pop(p
-00007120: 6f70 5f6b 6579 290a 2020 2020 2020 2020  op_key).        
-00007130: 616e 6173 6967 2e61 6e6e 6f74 6174 696f  anasig.annotatio
-00007140: 6e73 2e75 7064 6174 6528 616e 6e6f 7461  ns.update(annota
-00007150: 7469 6f6e 7329 0a20 2020 2020 2020 2061  tions).        a
-00007160: 6e61 7369 672e 616e 6e6f 7461 7469 6f6e  nasig.annotation
-00007170: 735b 2765 6c65 6374 726f 6465 5f69 6427  s['electrode_id'
-00007180: 5d20 3d20 6368 6964 0a20 2020 2020 2020  ] = chid.       
-00007190: 2023 2074 6869 7320 616e 6e6f 7461 7469   # this annotati
-000071a0: 6f6e 2069 7320 6e65 6365 7361 7279 2066  on is necesary f
-000071b0: 6f72 2061 7574 6f6d 6174 6963 2067 656e  or automatic gen
-000071c0: 6572 6561 7469 6f6e 206f 660a 2020 2020  ereation of.    
-000071d0: 2020 2020 2320 7265 636f 7264 696e 6763      # recordingc
-000071e0: 6861 6e6e 656c 730a 2020 2020 2020 2020  hannels.        
-000071f0: 616e 6173 6967 2e61 6e6e 6f74 6174 696f  anasig.annotatio
-00007200: 6e73 5b27 6368 616e 6e65 6c5f 696e 6465  ns['channel_inde
-00007210: 7827 5d20 3d20 6368 6964 0a20 2020 2020  x'] = chid.     
-00007220: 2020 2061 6e61 7369 672e 7365 676d 656e     anasig.segmen
-00007230: 7420 3d20 7365 6720 2023 206e 6565 6465  t = seg  # neede
-00007240: 6420 666f 7220 6d65 7267 6520 6675 6e63  d for merge func
-00007250: 7469 6f6e 206f 6620 616e 616c 6f67 7369  tion of analogsi
-00007260: 676e 616c 730a 0a20 2020 2020 2020 2073  gnals..        s
-00007270: 6567 2e61 6e61 6c6f 6773 6967 6e61 6c73  eg.analogsignals
-00007280: 2e61 7070 656e 6428 616e 6173 6967 290a  .append(anasig).
-00007290: 0a20 2020 2064 6566 2072 6561 645f 6e65  .    def read_ne
-000072a0: 7628 7365 6c66 2c20 6669 6c65 6e61 6d65  v(self, filename
-000072b0: 5f6e 6576 2c20 7365 672c 206c 617a 793d  _nev, seg, lazy=
-000072c0: 4661 6c73 652c 2063 6173 6361 6465 3d54  False, cascade=T
-000072d0: 7275 652c 0a20 2020 2020 2020 2020 2020  rue,.           
-000072e0: 2020 2020 2020 745f 7374 6172 743d 4e6f        t_start=No
-000072f0: 6e65 2c20 745f 7374 6f70 3d4e 6f6e 6529  ne, t_stop=None)
-00007300: 3a0a 2020 2020 2020 2020 2727 270a 2020  :.        '''.  
-00007310: 2020 2020 2020 5265 6164 7320 6173 736f        Reads asso
-00007320: 6369 6174 6564 206e 6576 2066 696c 6520  ciated nev file 
-00007330: 616e 6420 6174 7461 6368 6573 2069 7473  and attaches its
-00007340: 2063 6f6e 7465 6e74 2061 7320 6576 656e   content as even
-00007350: 7461 7272 6179 2074 6f0a 2020 2020 2020  tarray to.      
-00007360: 2020 7072 6f76 6964 6564 206e 656f 2073    provided neo s
-00007370: 6567 6d65 6e74 2e20 496e 2063 6f6e 7374  egment. In const
-00007380: 7261 7374 2074 6f20 7265 6164 5f6e 6373  rast to read_ncs
-00007390: 2074 696d 6573 2063 616e 206e 6f74 2062   times can not b
-000073a0: 6520 7072 6f76 6964 6564 0a20 2020 2020  e provided.     
-000073b0: 2020 2069 6e20 6e75 6d62 6572 206f 6620     in number of 
-000073c0: 7361 6d70 6c65 7320 6173 2061 206e 6576  samples as a nev
-000073d0: 2066 696c 6520 6861 7320 6e6f 2069 6e68   file has no inh
-000073e0: 6572 656e 7420 7361 6d70 6c69 6e67 2072  erent sampling r
-000073f0: 6174 652e 0a0a 2020 2020 2020 2020 4172  ate...        Ar
-00007400: 6775 6d65 6e74 733a 0a20 2020 2020 2020  guments:.       
-00007410: 2020 2020 2066 696c 656e 616d 655f 6e65       filename_ne
-00007420: 7620 3a20 4e61 6d65 206f 6620 7468 6520  v : Name of the 
-00007430: 2e6e 6576 2066 696c 6520 746f 2062 6520  .nev file to be 
-00007440: 6c6f 6164 6564 2e0a 2020 2020 2020 2020  loaded..        
-00007450: 2020 2020 7365 6720 3a20 4e65 6f20 5365      seg : Neo Se
-00007460: 676d 656e 742c 2074 6f20 7768 6963 6820  gment, to which 
-00007470: 7468 6520 4576 656e 7420 636f 6e74 6169  the Event contai
-00007480: 6e69 6e67 2074 6865 2064 6174 610a 2020  ning the data.  
-00007490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074a0: 2020 2020 2020 2020 2020 7769 6c6c 2062            will b
-000074b0: 6520 6174 7461 6368 6564 2e0a 2020 2020  e attached..    
-000074c0: 2020 2020 2020 2020 6c61 7a79 203a 2050          lazy : P
-000074d0: 6f73 7470 6f6e 6520 6163 7475 616c 2072  ostpone actual r
-000074e0: 6561 6469 6e67 206f 6620 7468 6520 6461  eading of the da
-000074f0: 7461 2e20 496e 7374 6561 6420 7072 6f76  ta. Instead prov
-00007500: 6964 6520 6120 6475 6d6d 790a 2020 2020  ide a dummy.    
-00007510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007520: 2020 2020 2020 2020 4576 656e 742e 2044          Event. D
-00007530: 6566 6175 6c74 2027 4661 6c73 6527 2e0a  efault 'False'..
-00007540: 2020 2020 2020 2020 2020 2020 6361 7363              casc
-00007550: 6164 6520 3a20 4e6f 7420 7573 6564 2069  ade : Not used i
-00007560: 6e20 7468 6973 2063 6f6e 7465 7874 2e20  n this context. 
-00007570: 4465 6661 756c 743a 2027 5472 7565 272e  Default: 'True'.
-00007580: 0a20 2020 2020 2020 2020 2020 2074 5f73  .            t_s
-00007590: 7461 7274 203a 2074 696d 6520 2871 7561  tart : time (qua
-000075a0: 6e74 6974 7929 2074 6861 7420 7468 6520  ntity) that the 
-000075b0: 4576 656e 7473 2062 6567 696e 2e0a 2020  Events begin..  
-000075c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000075d0: 2020 2020 2020 2020 2020 4465 6661 756c            Defaul
-000075e0: 7420 4e6f 6e65 2e0a 2020 2020 2020 2020  t None..        
-000075f0: 2020 2020 745f 7374 6f70 203a 2074 696d      t_stop : tim
-00007600: 6520 2871 7561 6e74 6974 7929 2074 6861  e (quantity) tha
-00007610: 7420 7468 6520 4576 656e 7420 656e 642e  t the Event end.
-00007620: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007630: 2020 2020 2020 2020 2020 2020 2044 6566               Def
-00007640: 6175 6c74 204e 6f6e 652e 0a0a 2020 2020  ault None...    
-00007650: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
-00007660: 2020 2020 2020 2020 204e 6f6e 650a 2020           None.  
-00007670: 2020 2020 2020 2727 270a 0a20 2020 2020        '''..     
-00007680: 2020 2069 6620 6669 6c65 6e61 6d65 5f6e     if filename_n
-00007690: 6576 5b2d 343a 5d20 213d 2027 2e6e 6576  ev[-4:] != '.nev
-000076a0: 273a 0a20 2020 2020 2020 2020 2020 2066  ':.            f
-000076b0: 696c 656e 616d 655f 6e65 7620 2b3d 2027  ilename_nev += '
-000076c0: 2e6e 6576 270a 2020 2020 2020 2020 6966  .nev'.        if
-000076d0: 2073 6570 2069 6e20 6669 6c65 6e61 6d65   sep in filename
-000076e0: 5f6e 6576 3a0a 2020 2020 2020 2020 2020  _nev:.          
-000076f0: 2020 6669 6c65 6e61 6d65 5f6e 6576 203d    filename_nev =
-00007700: 2066 696c 656e 616d 655f 6e65 762e 7370   filename_nev.sp
-00007710: 6c69 7428 7365 7029 5b2d 315d 0a0a 2020  lit(sep)[-1]..  
-00007720: 2020 2020 2020 6966 2066 696c 656e 616d        if filenam
-00007730: 655f 6e65 7620 6e6f 7420 696e 2073 656c  e_nev not in sel
-00007740: 662e 6e65 765f 6173 736f 3a0a 2020 2020  f.nev_asso:.    
-00007750: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-00007760: 6c75 6545 7272 6f72 2827 4e65 7572 616c  lueError('Neural
-00007770: 796e 7849 4f20 6973 2061 7474 656d 7074  ynxIO is attempt
-00007780: 696e 6720 746f 2072 6561 6420 6120 6669  ing to read a fi
-00007790: 6c65 2027 0a20 2020 2020 2020 2020 2020  le '.           
-000077a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000077b0: 2020 276e 6f74 2061 7373 6f63 6961 7465    'not associate
-000077c0: 6420 746f 2074 6869 7320 7365 7373 696f  d to this sessio
-000077d0: 6e20 2825 7329 2e27 2025 2028 0a20 2020  n (%s).' % (.   
-000077e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000077f0: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-00007800: 6c65 6e61 6d65 5f6e 6576 2929 0a0a 2020  lename_nev))..  
-00007810: 2020 2020 2020 2320 2320 656e 7375 7265        # # ensure
-00007820: 206d 6561 6e69 6e67 6675 6c20 7661 6c75   meaningful valu
-00007830: 6573 2066 6f72 2072 6571 7565 7374 6564  es for requested
-00007840: 2073 7461 7274 2061 6e64 2073 746f 7020   start and stop 
-00007850: 7469 6d65 730a 2020 2020 2020 2020 2320  times.        # 
-00007860: 2320 7072 6f76 6964 696e 6720 7469 6d65  # providing time
-00007870: 2069 7320 7361 6d70 6c65 7320 666f 7220   is samples for 
-00007880: 6e65 7620 6669 6c65 2064 6f65 7320 6e6f  nev file does no
-00007890: 7420 6d61 6b65 2073 656e 7365 2061 7320  t make sense as 
-000078a0: 7765 0a20 2020 2020 2020 2023 2064 6f6e  we.        # don
-000078b0: 2774 206b 6e6f 7720 7468 6520 756e 6465  't know the unde
-000078c0: 726c 7969 6e67 2073 616d 706c 696e 6720  rlying sampling 
-000078d0: 7261 7465 0a20 2020 2020 2020 2069 6620  rate.        if 
-000078e0: 6973 696e 7374 616e 6365 2874 5f73 7461  isinstance(t_sta
-000078f0: 7274 2c20 696e 7429 3a0a 2020 2020 2020  rt, int):.      
-00007900: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00007910: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
-00007920: 2020 2020 2020 2020 2752 6571 7565 7374          'Request
-00007930: 696e 6720 6576 656e 7420 696e 666f 726d  ing event inform
-00007940: 6174 696f 6e20 6672 6f6d 206e 6576 2066  ation from nev f
-00007950: 696c 6520 696e 2073 616d 706c 6573 2027  ile in samples '
-00007960: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007970: 2027 646f 6573 2027 0a20 2020 2020 2020   'does '.       
-00007980: 2020 2020 2020 2020 2027 6e6f 7420 6d61           'not ma
-00007990: 6b65 2073 656e 7365 2e20 270a 2020 2020  ke sense. '.    
-000079a0: 2020 2020 2020 2020 2020 2020 2752 6571              'Req
-000079b0: 7565 7374 6564 2074 5f73 7461 7274 2025  uested t_start %
-000079c0: 7327 2025 2074 5f73 7461 7274 290a 2020  s' % t_start).  
-000079d0: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-000079e0: 6e63 6528 745f 7374 6f70 2c20 696e 7429  nce(t_stop, int)
-000079f0: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-00007a00: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
-00007a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007a20: 2752 6571 7565 7374 696e 6720 6576 656e  'Requesting even
-00007a30: 7420 696e 666f 726d 6174 696f 6e20 6672  t information fr
-00007a40: 6f6d 206e 6576 2066 696c 6520 696e 2073  om nev file in s
-00007a50: 616d 706c 6573 2027 0a20 2020 2020 2020  amples '.       
-00007a60: 2020 2020 2020 2020 2027 646f 6573 2027           'does '
-00007a70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007a80: 2027 6e6f 7420 6d61 6b65 2073 656e 7365   'not make sense
-00007a90: 2e20 270a 2020 2020 2020 2020 2020 2020  . '.            
-00007aa0: 2020 2020 2752 6571 7565 7374 6564 2074      'Requested t
-00007ab0: 5f73 746f 7020 2573 2720 2520 745f 7374  _stop %s' % t_st
-00007ac0: 6f70 290a 0a20 2020 2020 2020 2023 2065  op)..        # e
-00007ad0: 6e73 7572 6520 6d65 616e 696e 6766 756c  nsure meaningful
-00007ae0: 2076 616c 7565 7320 666f 7220 7265 7175   values for requ
-00007af0: 6573 7465 6420 7374 6172 7420 616e 6420  ested start and 
-00007b00: 7374 6f70 2074 696d 6573 0a20 2020 2020  stop times.     
-00007b10: 2020 2069 6620 745f 7374 6172 7420 6973     if t_start is
-00007b20: 204e 6f6e 6520 6f72 2074 5f73 7461 7274   None or t_start
-00007b30: 203c 2028 0a20 2020 2020 2020 2020 2020   < (.           
-00007b40: 2020 2020 2073 656c 662e 7061 7261 6d65       self.parame
-00007b50: 7465 7273 5f6e 6576 5b66 696c 656e 616d  ters_nev[filenam
-00007b60: 655f 6e65 765d 5b27 745f 7374 6172 7427  e_nev]['t_start'
-00007b70: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00007b80: 2020 2d20 7365 6c66 2e70 6172 616d 6574    - self.paramet
-00007b90: 6572 735f 676c 6f62 616c 5b27 745f 7374  ers_global['t_st
-00007ba0: 6172 7427 5d29 3a0a 2020 2020 2020 2020  art']):.        
-00007bb0: 2020 2020 745f 7374 6172 7420 3d20 2873      t_start = (s
-00007bc0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-00007bd0: 6576 5b66 696c 656e 616d 655f 6e65 765d  ev[filename_nev]
-00007be0: 5b27 745f 7374 6172 7427 5d0a 2020 2020  ['t_start'].    
-00007bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007c00: 2020 202d 2073 656c 662e 7061 7261 6d65     - self.parame
-00007c10: 7465 7273 5f67 6c6f 6261 6c5b 2774 5f73  ters_global['t_s
-00007c20: 7461 7274 275d 290a 0a20 2020 2020 2020  tart'])..       
-00007c30: 2069 6620 745f 7374 6172 7420 3e20 2873   if t_start > (s
-00007c40: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-00007c50: 6576 5b66 696c 656e 616d 655f 6e65 765d  ev[filename_nev]
-00007c60: 5b27 745f 7374 6f70 275d 0a20 2020 2020  ['t_stop'].     
-00007c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007c80: 2020 2020 202d 2073 656c 662e 7061 7261       - self.para
-00007c90: 6d65 7465 7273 5f67 6c6f 6261 6c5b 2774  meters_global['t
-00007ca0: 5f73 7461 7274 275d 293a 0a20 2020 2020  _start']):.     
-00007cb0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-00007cc0: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
-00007cd0: 2020 2020 2020 2020 2027 5265 7175 6573           'Reques
-00007ce0: 7465 6420 7469 6d65 7320 7769 6e64 6f77  ted times window
-00007cf0: 2028 2573 2074 6f20 2573 2920 6973 206c   (%s to %s) is l
-00007d00: 6174 6572 2074 6861 6e20 6461 7461 2061  ater than data a
-00007d10: 7265 2027 0a20 2020 2020 2020 2020 2020  re '.           
-00007d20: 2020 2020 2027 7265 636f 7264 6564 2028       'recorded (
-00007d30: 745f 7374 6f70 203d 2025 7329 2027 0a20  t_stop = %s) '. 
-00007d40: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00007d50: 666f 7220 6669 6c65 2025 732e 2720 2520  for file %s.' % 
-00007d60: 2874 5f73 7461 7274 2c20 745f 7374 6f70  (t_start, t_stop
-00007d70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00007d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007d90: 2020 2020 2873 656c 662e 7061 7261 6d65      (self.parame
-00007da0: 7465 7273 5f6e 6576 5b66 696c 656e 616d  ters_nev[filenam
-00007db0: 655f 6e65 765d 5b27 745f 7374 6f70 275d  e_nev]['t_stop']
-00007dc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007de0: 2020 2020 2d20 7365 6c66 2e70 6172 616d      - self.param
-00007df0: 6574 6572 735f 676c 6f62 616c 5b27 745f  eters_global['t_
-00007e00: 7374 6172 7427 5d29 2c0a 2020 2020 2020  start']),.      
-00007e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007e20: 2020 2020 2020 2020 2020 2020 6669 6c65              file
-00007e30: 6e61 6d65 5f6e 6576 2929 0a0a 2020 2020  name_nev))..    
-00007e40: 2020 2020 6966 2074 5f73 746f 7020 6973      if t_stop is
-00007e50: 204e 6f6e 6520 6f72 2074 5f73 746f 7020   None or t_stop 
-00007e60: 3e20 280a 2020 2020 2020 2020 2020 2020  > (.            
-00007e70: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
-00007e80: 6572 735f 6e65 765b 6669 6c65 6e61 6d65  ers_nev[filename
-00007e90: 5f6e 6576 5d5b 2774 5f73 746f 7027 5d0a  _nev]['t_stop'].
-00007ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007eb0: 2d20 7365 6c66 2e70 6172 616d 6574 6572  - self.parameter
-00007ec0: 735f 676c 6f62 616c 5b27 745f 7374 6172  s_global['t_star
-00007ed0: 7427 5d29 3a0a 2020 2020 2020 2020 2020  t']):.          
-00007ee0: 2020 745f 7374 6f70 203d 2028 7365 6c66    t_stop = (self
-00007ef0: 2e70 6172 616d 6574 6572 735f 6e65 765b  .parameters_nev[
-00007f00: 6669 6c65 6e61 6d65 5f6e 6576 5d5b 2774  filename_nev]['t
-00007f10: 5f73 746f 7027 5d0a 2020 2020 2020 2020  _stop'].        
-00007f20: 2020 2020 2020 2020 2020 2020 2020 2d20                - 
-00007f30: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00007f40: 676c 6f62 616c 5b27 745f 7374 6172 7427  global['t_start'
-00007f50: 5d29 0a0a 2020 2020 2020 2020 6966 2074  ])..        if t
-00007f60: 5f73 746f 7020 3c20 2873 656c 662e 7061  _stop < (self.pa
-00007f70: 7261 6d65 7465 7273 5f6e 6576 5b66 696c  rameters_nev[fil
-00007f80: 656e 616d 655f 6e65 765d 5b27 745f 7374  ename_nev]['t_st
-00007f90: 6172 7427 5d0a 2020 2020 2020 2020 2020  art'].          
-00007fa0: 2020 2020 2020 2020 2020 2020 2020 202d                 -
-00007fb0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-00007fc0: 5f67 6c6f 6261 6c5b 2774 5f73 7461 7274  _global['t_start
-00007fd0: 275d 293a 0a20 2020 2020 2020 2020 2020  ']):.           
-00007fe0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00007ff0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-00008000: 2020 2027 5265 7175 6573 7465 6420 7469     'Requested ti
-00008010: 6d65 7320 7769 6e64 6f77 2028 2573 2074  mes window (%s t
-00008020: 6f20 2573 2920 6973 2065 6172 6c69 6572  o %s) is earlier
-00008030: 2074 6861 6e20 6461 7461 2027 0a20 2020   than data '.   
-00008040: 2020 2020 2020 2020 2020 2020 2027 6172               'ar
-00008050: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
-00008060: 2020 2020 2772 6563 6f72 6465 6420 2874      'recorded (t
-00008070: 5f73 7461 7274 203d 2025 7329 2027 0a20  _start = %s) '. 
-00008080: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00008090: 666f 7220 6669 6c65 2025 732e 2720 2520  for file %s.' % 
-000080a0: 2874 5f73 7461 7274 2c20 745f 7374 6f70  (t_start, t_stop
-000080b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000080c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000080d0: 2020 2020 280a 2020 2020 2020 2020 2020      (.          
-000080e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000080f0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00008100: 2e70 6172 616d 6574 6572 735f 6e65 765b  .parameters_nev[
-00008110: 6669 6c65 6e61 6d65 5f6e 6576 5d5b 0a20  filename_nev][. 
-00008120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006e90: 2020 2020 2020 3120 2f20 7361 6d70 6c69        1 / sampli
+00006ea0: 6e67 5f72 6174 6529 2c0a 2020 2020 2020  ng_rate),.      
+00006eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006ec0: 2020 2020 2020 2020 6e61 6d65 3d27 6368          name='ch
+00006ed0: 616e 6e65 6c5f 2569 2720 2520 2863 6869  annel_%i' % (chi
+00006ee0: 6429 2c0a 2020 2020 2020 2020 2020 2020  d),.            
+00006ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006f00: 2020 6368 616e 6e65 6c5f 696e 6465 783d    channel_index=
+00006f10: 6368 6964 290a 0a20 2020 2020 2020 2023  chid)..        #
+00006f20: 2072 656d 6f76 696e 6720 7072 6f74 7275   removing protru
+00006f30: 6469 6e67 2070 6172 7473 206f 6620 6669  ding parts of fi
+00006f40: 7273 7420 616e 6420 6c61 7374 2064 6174  rst and last dat
+00006f50: 6120 7061 636b 6574 0a20 2020 2020 2020  a packet.       
+00006f60: 2069 6620 616e 6173 6967 2e74 5f73 7461   if anasig.t_sta
+00006f70: 7274 203c 2074 5f73 7461 7274 2e72 6573  rt < t_start.res
+00006f80: 6361 6c65 2861 6e61 7369 672e 745f 7374  cale(anasig.t_st
+00006f90: 6172 742e 756e 6974 7329 3a0a 2020 2020  art.units):.    
+00006fa0: 2020 2020 2020 2020 616e 6173 6967 203d          anasig =
+00006fb0: 2061 6e61 7369 672e 7469 6d65 5f73 6c69   anasig.time_sli
+00006fc0: 6365 2874 5f73 7461 7274 2e72 6573 6361  ce(t_start.resca
+00006fd0: 6c65 2861 6e61 7369 672e 745f 7374 6172  le(anasig.t_star
+00006fe0: 742e 756e 6974 7329 2c0a 2020 2020 2020  t.units),.      
+00006ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007010: 204e 6f6e 6529 0a20 2020 2020 2020 2069   None).        i
+00007020: 6620 616e 6173 6967 2e74 5f73 746f 7020  f anasig.t_stop 
+00007030: 3e20 745f 7374 6f70 2e72 6573 6361 6c65  > t_stop.rescale
+00007040: 2861 6e61 7369 672e 745f 7374 6172 742e  (anasig.t_start.
+00007050: 756e 6974 7329 3a0a 2020 2020 2020 2020  units):.        
+00007060: 2020 2020 616e 6173 6967 203d 2061 6e61      anasig = ana
+00007070: 7369 672e 7469 6d65 5f73 6c69 6365 284e  sig.time_slice(N
+00007080: 6f6e 652c 0a20 2020 2020 2020 2020 2020  one,.           
+00007090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000070a0: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
+000070b0: 6f70 2e72 6573 6361 6c65 2861 6e61 7369  op.rescale(anasi
+000070c0: 672e 745f 7374 6172 742e 756e 6974 7329  g.t_start.units)
+000070d0: 290a 0a20 2020 2020 2020 2061 6e6e 6f74  )..        annot
+000070e0: 6174 696f 6e73 203d 2063 6f70 792e 6465  ations = copy.de
+000070f0: 6570 636f 7079 2873 656c 662e 7061 7261  epcopy(self.para
+00007100: 6d65 7465 7273 5f6e 6373 5b63 6869 645d  meters_ncs[chid]
+00007110: 290a 2020 2020 2020 2020 666f 7220 706f  ).        for po
+00007120: 705f 6b65 7920 696e 205b 2773 616d 706c  p_key in ['sampl
+00007130: 696e 675f 7261 7465 272c 2027 745f 7374  ing_rate', 't_st
+00007140: 6172 7427 5d3a 0a20 2020 2020 2020 2020  art']:.         
+00007150: 2020 2069 6620 706f 705f 6b65 7920 696e     if pop_key in
+00007160: 2061 6e6e 6f74 6174 696f 6e73 3a0a 2020   annotations:.  
+00007170: 2020 2020 2020 2020 2020 2020 2020 616e                an
+00007180: 6e6f 7461 7469 6f6e 732e 706f 7028 706f  notations.pop(po
+00007190: 705f 6b65 7929 0a20 2020 2020 2020 2061  p_key).        a
+000071a0: 6e61 7369 672e 616e 6e6f 7461 7469 6f6e  nasig.annotation
+000071b0: 732e 7570 6461 7465 2861 6e6e 6f74 6174  s.update(annotat
+000071c0: 696f 6e73 290a 2020 2020 2020 2020 616e  ions).        an
+000071d0: 6173 6967 2e61 6e6e 6f74 6174 696f 6e73  asig.annotations
+000071e0: 5b27 656c 6563 7472 6f64 655f 6964 275d  ['electrode_id']
+000071f0: 203d 2063 6869 640a 2020 2020 2020 2020   = chid.        
+00007200: 2320 7468 6973 2061 6e6e 6f74 6174 696f  # this annotatio
+00007210: 6e20 6973 206e 6563 6573 6172 7920 666f  n is necesary fo
+00007220: 7220 6175 746f 6d61 7469 6320 6765 6e65  r automatic gene
+00007230: 7265 6174 696f 6e20 6f66 0a20 2020 2020  reation of.     
+00007240: 2020 2023 2072 6563 6f72 6469 6e67 6368     # recordingch
+00007250: 616e 6e65 6c73 0a20 2020 2020 2020 2061  annels.        a
+00007260: 6e61 7369 672e 616e 6e6f 7461 7469 6f6e  nasig.annotation
+00007270: 735b 2763 6861 6e6e 656c 5f69 6e64 6578  s['channel_index
+00007280: 275d 203d 2063 6869 640a 2020 2020 2020  '] = chid.      
+00007290: 2020 616e 6173 6967 2e73 6567 6d65 6e74    anasig.segment
+000072a0: 203d 2073 6567 2020 2320 6e65 6564 6564   = seg  # needed
+000072b0: 2066 6f72 206d 6572 6765 2066 756e 6374   for merge funct
+000072c0: 696f 6e20 6f66 2061 6e61 6c6f 6773 6967  ion of analogsig
+000072d0: 6e61 6c73 0a0a 2020 2020 2020 2020 7365  nals..        se
+000072e0: 672e 616e 616c 6f67 7369 676e 616c 732e  g.analogsignals.
+000072f0: 6170 7065 6e64 2861 6e61 7369 6729 0a0a  append(anasig)..
+00007300: 2020 2020 6465 6620 7265 6164 5f6e 6576      def read_nev
+00007310: 2873 656c 662c 2066 696c 656e 616d 655f  (self, filename_
+00007320: 6e65 762c 2073 6567 2c20 6c61 7a79 3d46  nev, seg, lazy=F
+00007330: 616c 7365 2c20 6361 7363 6164 653d 5472  alse, cascade=Tr
+00007340: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
+00007350: 2020 2020 2074 5f73 7461 7274 3d4e 6f6e       t_start=Non
+00007360: 652c 2074 5f73 746f 703d 4e6f 6e65 293a  e, t_stop=None):
+00007370: 0a20 2020 2020 2020 2027 2727 0a20 2020  .        '''.   
+00007380: 2020 2020 2052 6561 6473 2061 7373 6f63       Reads assoc
+00007390: 6961 7465 6420 6e65 7620 6669 6c65 2061  iated nev file a
+000073a0: 6e64 2061 7474 6163 6865 7320 6974 7320  nd attaches its 
+000073b0: 636f 6e74 656e 7420 6173 2065 7665 6e74  content as event
+000073c0: 6172 7261 7920 746f 0a20 2020 2020 2020  array to.       
+000073d0: 2070 726f 7669 6465 6420 6e65 6f20 7365   provided neo se
+000073e0: 676d 656e 742e 2049 6e20 636f 6e73 7472  gment. In constr
+000073f0: 6173 7420 746f 2072 6561 645f 6e63 7320  ast to read_ncs 
+00007400: 7469 6d65 7320 6361 6e20 6e6f 7420 6265  times can not be
+00007410: 2070 726f 7669 6465 640a 2020 2020 2020   provided.      
+00007420: 2020 696e 206e 756d 6265 7220 6f66 2073    in number of s
+00007430: 616d 706c 6573 2061 7320 6120 6e65 7620  amples as a nev 
+00007440: 6669 6c65 2068 6173 206e 6f20 696e 6865  file has no inhe
+00007450: 7265 6e74 2073 616d 706c 696e 6720 7261  rent sampling ra
+00007460: 7465 2e0a 0a20 2020 2020 2020 2041 7267  te...        Arg
+00007470: 756d 656e 7473 3a0a 2020 2020 2020 2020  uments:.        
+00007480: 2020 2020 6669 6c65 6e61 6d65 5f6e 6576      filename_nev
+00007490: 203a 204e 616d 6520 6f66 2074 6865 202e   : Name of the .
+000074a0: 6e65 7620 6669 6c65 2074 6f20 6265 206c  nev file to be l
+000074b0: 6f61 6465 642e 0a20 2020 2020 2020 2020  oaded..         
+000074c0: 2020 2073 6567 203a 204e 656f 2053 6567     seg : Neo Seg
+000074d0: 6d65 6e74 2c20 746f 2077 6869 6368 2074  ment, to which t
+000074e0: 6865 2045 7665 6e74 2063 6f6e 7461 696e  he Event contain
+000074f0: 696e 6720 7468 6520 6461 7461 0a20 2020  ing the data.   
+00007500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007510: 2020 2020 2020 2020 2077 696c 6c20 6265           will be
+00007520: 2061 7474 6163 6865 642e 0a20 2020 2020   attached..     
+00007530: 2020 2020 2020 206c 617a 7920 3a20 506f         lazy : Po
+00007540: 7374 706f 6e65 2061 6374 7561 6c20 7265  stpone actual re
+00007550: 6164 696e 6720 6f66 2074 6865 2064 6174  ading of the dat
+00007560: 612e 2049 6e73 7465 6164 2070 726f 7669  a. Instead provi
+00007570: 6465 2061 2064 756d 6d79 0a20 2020 2020  de a dummy.     
+00007580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007590: 2020 2020 2020 2045 7665 6e74 2e20 4465         Event. De
+000075a0: 6661 756c 7420 2746 616c 7365 272e 0a20  fault 'False'.. 
+000075b0: 2020 2020 2020 2020 2020 2063 6173 6361             casca
+000075c0: 6465 203a 204e 6f74 2075 7365 6420 696e  de : Not used in
+000075d0: 2074 6869 7320 636f 6e74 6578 742e 2044   this context. D
+000075e0: 6566 6175 6c74 3a20 2754 7275 6527 2e0a  efault: 'True'..
+000075f0: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
+00007600: 6172 7420 3a20 7469 6d65 2028 7175 616e  art : time (quan
+00007610: 7469 7479 2920 7468 6174 2074 6865 2045  tity) that the E
+00007620: 7665 6e74 7320 6265 6769 6e2e 0a20 2020  vents begin..   
+00007630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007640: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
+00007650: 204e 6f6e 652e 0a20 2020 2020 2020 2020   None..         
+00007660: 2020 2074 5f73 746f 7020 3a20 7469 6d65     t_stop : time
+00007670: 2028 7175 616e 7469 7479 2920 7468 6174   (quantity) that
+00007680: 2074 6865 2045 7665 6e74 2065 6e64 2e0a   the Event end..
+00007690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000076a0: 2020 2020 2020 2020 2020 2020 4465 6661              Defa
+000076b0: 756c 7420 4e6f 6e65 2e0a 0a20 2020 2020  ult None...     
+000076c0: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
+000076d0: 2020 2020 2020 2020 4e6f 6e65 0a20 2020          None.   
+000076e0: 2020 2020 2027 2727 0a0a 2020 2020 2020       '''..      
+000076f0: 2020 6966 2066 696c 656e 616d 655f 6e65    if filename_ne
+00007700: 765b 2d34 3a5d 2021 3d20 272e 6e65 7627  v[-4:] != '.nev'
+00007710: 3a0a 2020 2020 2020 2020 2020 2020 6669  :.            fi
+00007720: 6c65 6e61 6d65 5f6e 6576 202b 3d20 272e  lename_nev += '.
+00007730: 6e65 7627 0a20 2020 2020 2020 2069 6620  nev'.        if 
+00007740: 7365 7020 696e 2066 696c 656e 616d 655f  sep in filename_
+00007750: 6e65 763a 0a20 2020 2020 2020 2020 2020  nev:.           
+00007760: 2066 696c 656e 616d 655f 6e65 7620 3d20   filename_nev = 
+00007770: 6669 6c65 6e61 6d65 5f6e 6576 2e73 706c  filename_nev.spl
+00007780: 6974 2873 6570 295b 2d31 5d0a 0a20 2020  it(sep)[-1]..   
+00007790: 2020 2020 2069 6620 6669 6c65 6e61 6d65       if filename
+000077a0: 5f6e 6576 206e 6f74 2069 6e20 7365 6c66  _nev not in self
+000077b0: 2e6e 6576 5f61 7373 6f3a 0a20 2020 2020  .nev_asso:.     
+000077c0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+000077d0: 7565 4572 726f 7228 274e 6575 7261 6c79  ueError('Neuraly
+000077e0: 6e78 494f 2069 7320 6174 7465 6d70 7469  nxIO is attempti
+000077f0: 6e67 2074 6f20 7265 6164 2061 2066 696c  ng to read a fil
+00007800: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
+00007810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007820: 2027 6e6f 7420 6173 736f 6369 6174 6564   'not associated
+00007830: 2074 6f20 7468 6973 2073 6573 7369 6f6e   to this session
+00007840: 2028 2573 292e 2720 2520 280a 2020 2020   (%s).' % (.    
+00007850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007860: 2020 2020 2020 2020 2020 2020 2066 696c               fil
+00007870: 656e 616d 655f 6e65 7629 290a 0a20 2020  ename_nev))..   
+00007880: 2020 2020 2023 2023 2065 6e73 7572 6520       # # ensure 
+00007890: 6d65 616e 696e 6766 756c 2076 616c 7565  meaningful value
+000078a0: 7320 666f 7220 7265 7175 6573 7465 6420  s for requested 
+000078b0: 7374 6172 7420 616e 6420 7374 6f70 2074  start and stop t
+000078c0: 696d 6573 0a20 2020 2020 2020 2023 2023  imes.        # #
+000078d0: 2070 726f 7669 6469 6e67 2074 696d 6520   providing time 
+000078e0: 6973 2073 616d 706c 6573 2066 6f72 206e  is samples for n
+000078f0: 6576 2066 696c 6520 646f 6573 206e 6f74  ev file does not
+00007900: 206d 616b 6520 7365 6e73 6520 6173 2077   make sense as w
+00007910: 650a 2020 2020 2020 2020 2320 646f 6e27  e.        # don'
+00007920: 7420 6b6e 6f77 2074 6865 2075 6e64 6572  t know the under
+00007930: 6c79 696e 6720 7361 6d70 6c69 6e67 2072  lying sampling r
+00007940: 6174 650a 2020 2020 2020 2020 6966 2069  ate.        if i
+00007950: 7369 6e73 7461 6e63 6528 745f 7374 6172  sinstance(t_star
+00007960: 742c 2069 6e74 293a 0a20 2020 2020 2020  t, int):.       
+00007970: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00007980: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
+00007990: 2020 2020 2020 2027 5265 7175 6573 7469         'Requesti
+000079a0: 6e67 2065 7665 6e74 2069 6e66 6f72 6d61  ng event informa
+000079b0: 7469 6f6e 2066 726f 6d20 6e65 7620 6669  tion from nev fi
+000079c0: 6c65 2069 6e20 7361 6d70 6c65 7320 270a  le in samples '.
+000079d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000079e0: 2764 6f65 7320 270a 2020 2020 2020 2020  'does '.        
+000079f0: 2020 2020 2020 2020 276e 6f74 206d 616b          'not mak
+00007a00: 6520 7365 6e73 652e 2027 0a20 2020 2020  e sense. '.     
+00007a10: 2020 2020 2020 2020 2020 2027 5265 7175             'Requ
+00007a20: 6573 7465 6420 745f 7374 6172 7420 2573  ested t_start %s
+00007a30: 2720 2520 745f 7374 6172 7429 0a20 2020  ' % t_start).   
+00007a40: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
+00007a50: 6365 2874 5f73 746f 702c 2069 6e74 293a  ce(t_stop, int):
+00007a60: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00007a70: 7365 2056 616c 7565 4572 726f 7228 0a20  se ValueError(. 
+00007a80: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00007a90: 5265 7175 6573 7469 6e67 2065 7665 6e74  Requesting event
+00007aa0: 2069 6e66 6f72 6d61 7469 6f6e 2066 726f   information fro
+00007ab0: 6d20 6e65 7620 6669 6c65 2069 6e20 7361  m nev file in sa
+00007ac0: 6d70 6c65 7320 270a 2020 2020 2020 2020  mples '.        
+00007ad0: 2020 2020 2020 2020 2764 6f65 7320 270a          'does '.
+00007ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007af0: 276e 6f74 206d 616b 6520 7365 6e73 652e  'not make sense.
+00007b00: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00007b10: 2020 2027 5265 7175 6573 7465 6420 745f     'Requested t_
+00007b20: 7374 6f70 2025 7327 2025 2074 5f73 746f  stop %s' % t_sto
+00007b30: 7029 0a0a 2020 2020 2020 2020 2320 656e  p)..        # en
+00007b40: 7375 7265 206d 6561 6e69 6e67 6675 6c20  sure meaningful 
+00007b50: 7661 6c75 6573 2066 6f72 2072 6571 7565  values for reque
+00007b60: 7374 6564 2073 7461 7274 2061 6e64 2073  sted start and s
+00007b70: 746f 7020 7469 6d65 730a 2020 2020 2020  top times.      
+00007b80: 2020 6966 2074 5f73 7461 7274 2069 7320    if t_start is 
+00007b90: 4e6f 6e65 206f 7220 745f 7374 6172 7420  None or t_start 
+00007ba0: 3c20 280a 2020 2020 2020 2020 2020 2020  < (.            
+00007bb0: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
+00007bc0: 6572 735f 6e65 765b 6669 6c65 6e61 6d65  ers_nev[filename
+00007bd0: 5f6e 6576 5d5b 2774 5f73 7461 7274 275d  _nev]['t_start']
+00007be0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007bf0: 202d 2073 656c 662e 7061 7261 6d65 7465   - self.paramete
+00007c00: 7273 5f67 6c6f 6261 6c5b 2774 5f73 7461  rs_global['t_sta
+00007c10: 7274 275d 293a 0a20 2020 2020 2020 2020  rt']):.         
+00007c20: 2020 2074 5f73 7461 7274 203d 2028 7365     t_start = (se
+00007c30: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
+00007c40: 765b 6669 6c65 6e61 6d65 5f6e 6576 5d5b  v[filename_nev][
+00007c50: 2774 5f73 7461 7274 275d 0a20 2020 2020  't_start'].     
+00007c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007c70: 2020 2d20 7365 6c66 2e70 6172 616d 6574    - self.paramet
+00007c80: 6572 735f 676c 6f62 616c 5b27 745f 7374  ers_global['t_st
+00007c90: 6172 7427 5d29 0a0a 2020 2020 2020 2020  art'])..        
+00007ca0: 6966 2074 5f73 7461 7274 203e 2028 7365  if t_start > (se
+00007cb0: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
+00007cc0: 765b 6669 6c65 6e61 6d65 5f6e 6576 5d5b  v[filename_nev][
+00007cd0: 2774 5f73 746f 7027 5d0a 2020 2020 2020  't_stop'].      
+00007ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007cf0: 2020 2020 2d20 7365 6c66 2e70 6172 616d      - self.param
+00007d00: 6574 6572 735f 676c 6f62 616c 5b27 745f  eters_global['t_
+00007d10: 7374 6172 7427 5d29 3a0a 2020 2020 2020  start']):.      
+00007d20: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00007d30: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
+00007d40: 2020 2020 2020 2020 2752 6571 7565 7374          'Request
+00007d50: 6564 2074 696d 6573 2077 696e 646f 7720  ed times window 
+00007d60: 2825 7320 746f 2025 7329 2069 7320 6c61  (%s to %s) is la
+00007d70: 7465 7220 7468 616e 2064 6174 6120 6172  ter than data ar
+00007d80: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
+00007d90: 2020 2020 2772 6563 6f72 6465 6420 2874      'recorded (t
+00007da0: 5f73 746f 7020 3d20 2573 2920 270a 2020  _stop = %s) '.  
+00007db0: 2020 2020 2020 2020 2020 2020 2020 2766                'f
+00007dc0: 6f72 2066 696c 6520 2573 2e27 2025 2028  or file %s.' % (
+00007dd0: 745f 7374 6172 742c 2074 5f73 746f 702c  t_start, t_stop,
+00007de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007e00: 2020 2028 7365 6c66 2e70 6172 616d 6574     (self.paramet
+00007e10: 6572 735f 6e65 765b 6669 6c65 6e61 6d65  ers_nev[filename
+00007e20: 5f6e 6576 5d5b 2774 5f73 746f 7027 5d0a  _nev]['t_stop'].
+00007e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007e50: 2020 202d 2073 656c 662e 7061 7261 6d65     - self.parame
+00007e60: 7465 7273 5f67 6c6f 6261 6c5b 2774 5f73  ters_global['t_s
+00007e70: 7461 7274 275d 292c 0a20 2020 2020 2020  tart']),.       
+00007e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007e90: 2020 2020 2020 2020 2020 2066 696c 656e             filen
+00007ea0: 616d 655f 6e65 7629 290a 0a20 2020 2020  ame_nev))..     
+00007eb0: 2020 2069 6620 745f 7374 6f70 2069 7320     if t_stop is 
+00007ec0: 4e6f 6e65 206f 7220 745f 7374 6f70 203e  None or t_stop >
+00007ed0: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+00007ee0: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
+00007ef0: 7273 5f6e 6576 5b66 696c 656e 616d 655f  rs_nev[filename_
+00007f00: 6e65 765d 5b27 745f 7374 6f70 275d 0a20  nev]['t_stop']. 
+00007f10: 2020 2020 2020 2020 2020 2020 2020 202d                 -
+00007f20: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
+00007f30: 5f67 6c6f 6261 6c5b 2774 5f73 7461 7274  _global['t_start
+00007f40: 275d 293a 0a20 2020 2020 2020 2020 2020  ']):.           
+00007f50: 2074 5f73 746f 7020 3d20 2873 656c 662e   t_stop = (self.
+00007f60: 7061 7261 6d65 7465 7273 5f6e 6576 5b66  parameters_nev[f
+00007f70: 696c 656e 616d 655f 6e65 765d 5b27 745f  ilename_nev]['t_
+00007f80: 7374 6f70 275d 0a20 2020 2020 2020 2020  stop'].         
+00007f90: 2020 2020 2020 2020 2020 2020 202d 2073               - s
+00007fa0: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
+00007fb0: 6c6f 6261 6c5b 2774 5f73 7461 7274 275d  lobal['t_start']
+00007fc0: 290a 0a20 2020 2020 2020 2069 6620 745f  )..        if t_
+00007fd0: 7374 6f70 203c 2028 7365 6c66 2e70 6172  stop < (self.par
+00007fe0: 616d 6574 6572 735f 6e65 765b 6669 6c65  ameters_nev[file
+00007ff0: 6e61 6d65 5f6e 6576 5d5b 2774 5f73 7461  name_nev]['t_sta
+00008000: 7274 275d 0a20 2020 2020 2020 2020 2020  rt'].           
+00008010: 2020 2020 2020 2020 2020 2020 2020 2d20                - 
+00008020: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00008030: 676c 6f62 616c 5b27 745f 7374 6172 7427  global['t_start'
+00008040: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+00008050: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00008060: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00008070: 2020 2752 6571 7565 7374 6564 2074 696d    'Requested tim
+00008080: 6573 2077 696e 646f 7720 2825 7320 746f  es window (%s to
+00008090: 2025 7329 2069 7320 6561 726c 6965 7220   %s) is earlier 
+000080a0: 7468 616e 2064 6174 6120 270a 2020 2020  than data '.    
+000080b0: 2020 2020 2020 2020 2020 2020 2761 7265              'are
+000080c0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+000080d0: 2020 2027 7265 636f 7264 6564 2028 745f     'recorded (t_
+000080e0: 7374 6172 7420 3d20 2573 2920 270a 2020  start = %s) '.  
+000080f0: 2020 2020 2020 2020 2020 2020 2020 2766                'f
+00008100: 6f72 2066 696c 6520 2573 2e27 2025 2028  or file %s.' % (
+00008110: 745f 7374 6172 742c 2074 5f73 746f 702c  t_start, t_stop,
+00008120: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00008130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008140: 2020 2020 2020 2020 2027 745f 7374 6172           't_star
-00008150: 7427 5d0a 2020 2020 2020 2020 2020 2020  t'].            
-00008160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008170: 2020 2020 2020 2020 2020 2d20 7365 6c66            - self
-00008180: 2e70 6172 616d 6574 6572 735f 676c 6f62  .parameters_glob
-00008190: 616c 5b27 745f 7374 6172 7427 5d29 2c0a  al['t_start']),.
+00008140: 2020 2028 0a20 2020 2020 2020 2020 2020     (.           
+00008150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008160: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00008170: 7061 7261 6d65 7465 7273 5f6e 6576 5b66  parameters_nev[f
+00008180: 696c 656e 616d 655f 6e65 765d 5b0a 2020  ilename_nev][.  
+00008190: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000081a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000081b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000081c0: 2020 6669 6c65 6e61 6d65 5f6e 6576 2929    filename_nev))
-000081d0: 0a0a 2020 2020 2020 2020 6966 2074 5f73  ..        if t_s
-000081e0: 7461 7274 203e 3d20 745f 7374 6f70 3a0a  tart >= t_stop:.
-000081f0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00008200: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
-00008210: 2020 2020 2020 2020 2020 2020 2020 2752                'R
-00008220: 6571 7565 7374 6564 2073 7461 7274 2074  equested start t
-00008230: 696d 6520 2825 7329 2069 7320 6c61 7465  ime (%s) is late
-00008240: 7220 7468 616e 202f 2065 7175 616c 2074  r than / equal t
-00008250: 6f20 7374 6f70 2027 0a20 2020 2020 2020  o stop '.       
-00008260: 2020 2020 2020 2020 2027 7469 6d65 2027           'time '
-00008270: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008280: 2027 2825 7329 2027 0a20 2020 2020 2020   '(%s) '.       
-00008290: 2020 2020 2020 2020 2027 666f 7220 6669           'for fi
-000082a0: 6c65 2025 732e 2720 2520 2874 5f73 7461  le %s.' % (t_sta
-000082b0: 7274 2c20 745f 7374 6f70 2c20 6669 6c65  rt, t_stop, file
-000082c0: 6e61 6d65 5f6e 6576 2929 0a0a 2020 2020  name_nev))..    
-000082d0: 2020 2020 6461 7461 203d 2073 656c 662e      data = self.
-000082e0: 5f5f 6d6d 6170 5f6e 6576 5f66 696c 6528  __mmap_nev_file(
-000082f0: 6669 6c65 6e61 6d65 5f6e 6576 290a 2020  filename_nev).  
-00008300: 2020 2020 2020 2320 4578 7472 6163 7469        # Extracti
-00008310: 6e67 2061 6c6c 2065 7665 6e74 7320 666f  ng all events fo
-00008320: 7220 6f6e 6520 6576 656e 7420 7479 7065  r one event type
-00008330: 2061 6e64 2070 7574 2069 7420 696e 746f   and put it into
-00008340: 2061 6e20 6576 656e 740a 2020 2020 2020   an event.      
-00008350: 2020 2320 6172 7261 790a 2020 2020 2020    # array.      
-00008360: 2020 2320 544f 444f 3a20 4368 6563 6b20    # TODO: Check 
-00008370: 6966 2074 6869 7320 6973 2074 6865 2063  if this is the c
-00008380: 6f72 7265 6374 2077 6179 206f 6620 6576  orrect way of ev
-00008390: 656e 7420 6372 6561 7469 6f6e 2e0a 2020  ent creation..  
-000083a0: 2020 2020 2020 666f 7220 6576 656e 745f        for event_
-000083b0: 7479 7065 2069 6e20 7365 6c66 2e70 6172  type in self.par
-000083c0: 616d 6574 6572 735f 6e65 765b 6669 6c65  ameters_nev[file
-000083d0: 6e61 6d65 5f6e 6576 5d5b 2765 7665 6e74  name_nev]['event
-000083e0: 5f74 7970 6573 275d 3a0a 2020 2020 2020  _types']:.      
-000083f0: 2020 2020 2020 2320 4578 7472 6163 7420        # Extract 
-00008400: 616c 6c20 7469 6d65 2073 7461 6d70 7320  all time stamps 
-00008410: 6f66 2064 6967 6974 616c 206d 6172 6b65  of digital marke
-00008420: 7273 2061 6e64 2072 6573 6361 6c69 6e67  rs and rescaling
-00008430: 2074 696d 650a 2020 2020 2020 2020 2020   time.          
-00008440: 2020 7479 7065 5f6d 6173 6b20 3d20 5b69    type_mask = [i
-00008450: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
-00008460: 6c65 6e28 6461 7461 2929 2069 660a 2020  len(data)) if.  
-00008470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008480: 2020 2020 2020 2028 6461 7461 5b69 5d5b         (data[i][
-00008490: 345d 203d 3d20 6576 656e 745f 7479 7065  4] == event_type
-000084a0: 5b27 6576 656e 745f 6964 275d 0a20 2020  ['event_id'].   
-000084b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000084c0: 2020 2020 2020 2061 6e64 2064 6174 615b         and data[
-000084d0: 695d 5b35 5d20 3d3d 2065 7665 6e74 5f74  i][5] == event_t
-000084e0: 7970 655b 276e 7474 6c27 5d0a 2020 2020  ype['nttl'].    
-000084f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008500: 2020 2020 2020 616e 6420 6461 7461 5b69        and data[i
-00008510: 5d5b 3130 5d2e 6465 636f 6465 2827 6c61  ][10].decode('la
-00008520: 7469 6e2d 3127 2920 3d3d 2065 7665 6e74  tin-1') == event
-00008530: 5f74 7970 655b 0a20 2020 2020 2020 2020  _type[.         
-00008540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008550: 2020 2020 2027 6e61 6d65 275d 295d 0a20       'name'])]. 
-00008560: 2020 2020 2020 2020 2020 206d 6172 6b65             marke
-00008570: 725f 7469 6d65 7320 3d20 5b74 5b33 5d20  r_times = [t[3] 
-00008580: 666f 7220 7420 696e 0a20 2020 2020 2020  for t in.       
-00008590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085a0: 2020 2020 2064 6174 615b 7479 7065 5f6d       data[type_m
-000085b0: 6173 6b5d 5d20 2a20 7365 6c66 2e6e 6576  ask]] * self.nev
-000085c0: 5f74 696d 655f 756e 6974 202d 205c 0a20  _time_unit - \. 
-000085d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000085e0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
-000085f0: 6172 616d 6574 6572 735f 676c 6f62 616c  arameters_global
-00008600: 5b27 745f 7374 6172 7427 5d0a 0a20 2020  ['t_start']..   
-00008610: 2020 2020 2020 2020 2023 206f 6e6c 7920           # only 
-00008620: 636f 6e73 6964 6572 2045 7665 6e74 7320  consider Events 
-00008630: 696e 2074 6865 2072 6571 7565 7374 6564  in the requested
-00008640: 2074 696d 6520 7769 6e64 6f77 205b 745f   time window [t_
-00008650: 7374 6172 742c 0a20 2020 2020 2020 2020  start,.         
-00008660: 2020 2023 2074 5f73 746f 705d 0a20 2020     # t_stop].   
-00008670: 2020 2020 2020 2020 2074 696d 655f 6d61           time_ma
-00008680: 736b 203d 205b 6920 666f 7220 6920 696e  sk = [i for i in
-00008690: 2072 616e 6765 286c 656e 286d 6172 6b65   range(len(marke
-000086a0: 725f 7469 6d65 7329 2920 6966 2028 0a20  r_times)) if (. 
-000086b0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-000086c0: 6172 6b65 725f 7469 6d65 735b 695d 203e  arker_times[i] >
-000086d0: 3d20 745f 7374 6172 7420 616e 6420 6d61  = t_start and ma
-000086e0: 726b 6572 5f74 696d 6573 5b69 5d20 3c3d  rker_times[i] <=
-000086f0: 2074 5f73 746f 7029 5d0a 2020 2020 2020   t_stop)].      
-00008700: 2020 2020 2020 6d61 726b 6572 5f74 696d        marker_tim
-00008710: 6573 203d 206d 6172 6b65 725f 7469 6d65  es = marker_time
-00008720: 735b 7469 6d65 5f6d 6173 6b5d 0a0a 2020  s[time_mask]..  
-00008730: 2020 2020 2020 2020 2020 2320 446f 206e            # Do n
-00008740: 6f74 2063 7265 6174 6520 616e 2065 7665  ot create an eve
-00008750: 6e74 6172 7261 7920 6966 2074 6865 7265  ntarray if there
-00008760: 2061 7265 206e 6f20 6576 656e 7473 206f   are no events o
-00008770: 6620 7468 6973 2074 7970 650a 2020 2020  f this type.    
-00008780: 2020 2020 2020 2020 2320 2069 6e20 7468          #  in th
-00008790: 6520 7265 7175 6573 7465 6420 7469 6d65  e requested time
-000087a0: 2072 616e 6765 0a20 2020 2020 2020 2020   range.         
-000087b0: 2020 2069 6620 6c65 6e28 6d61 726b 6572     if len(marker
-000087c0: 5f74 696d 6573 2920 3d3d 2030 3a0a 2020  _times) == 0:.  
-000087d0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-000087e0: 6e74 696e 7565 0a0a 2020 2020 2020 2020  ntinue..        
-000087f0: 2020 2020 6576 203d 2045 7665 6e74 2874      ev = Event(t
-00008800: 696d 6573 3d70 712e 5175 616e 7469 7479  imes=pq.Quantity
-00008810: 286d 6172 6b65 725f 7469 6d65 732c 2075  (marker_times, u
-00008820: 6e69 7473 3d73 656c 662e 6e65 765f 7469  nits=self.nev_ti
-00008830: 6d65 5f75 6e69 742c 0a20 2020 2020 2020  me_unit,.       
-00008840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008860: 2020 6474 7970 653d 2269 6e74 2229 2c0a    dtype="int"),.
-00008870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008880: 2020 2020 2020 206c 6162 656c 733d 6576         labels=ev
-00008890: 656e 745f 7479 7065 5b27 6e61 6d65 275d  ent_type['name']
-000088a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000088b0: 2020 2020 2020 2020 206e 616d 653d 2244           name="D
-000088c0: 6967 6974 616c 204d 6172 6b65 7220 2220  igital Marker " 
-000088d0: 2b20 7374 7228 6576 656e 745f 7479 7065  + str(event_type
-000088e0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-000088f0: 2020 2020 2020 2020 2020 6669 6c65 5f6f            file_o
-00008900: 7269 6769 6e3d 6669 6c65 6e61 6d65 5f6e  rigin=filename_n
-00008910: 6576 2c0a 2020 2020 2020 2020 2020 2020  ev,.            
-00008920: 2020 2020 2020 2020 2020 206d 6172 6b65             marke
-00008930: 725f 6964 3d65 7665 6e74 5f74 7970 655b  r_id=event_type[
-00008940: 2765 7665 6e74 5f69 6427 5d2c 0a20 2020  'event_id'],.   
-00008950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008960: 2020 2020 6469 6769 7461 6c5f 6d61 726b      digital_mark
-00008970: 6572 3d54 7275 652c 0a20 2020 2020 2020  er=True,.       
-00008980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008990: 616e 616c 6f67 5f6d 6172 6b65 723d 4661  analog_marker=Fa
-000089a0: 6c73 652c 0a20 2020 2020 2020 2020 2020  lse,.           
-000089b0: 2020 2020 2020 2020 2020 2020 6e74 746c              nttl
-000089c0: 3d65 7665 6e74 5f74 7970 655b 276e 7474  =event_type['ntt
-000089d0: 6c27 5d29 0a0a 2020 2020 2020 2020 2020  l'])..          
-000089e0: 2020 7365 672e 6576 656e 7473 2e61 7070    seg.events.app
-000089f0: 656e 6428 6576 290a 0a20 2020 2064 6566  end(ev)..    def
-00008a00: 2072 6561 645f 6e73 6528 7365 6c66 2c20   read_nse(self, 
-00008a10: 6669 6c65 6e61 6d65 5f6e 7365 2c20 7365  filename_nse, se
-00008a20: 672c 206c 617a 793d 4661 6c73 652c 2063  g, lazy=False, c
-00008a30: 6173 6361 6465 3d54 7275 652c 0a20 2020  ascade=True,.   
-00008a40: 2020 2020 2020 2020 2020 2020 2020 745f                t_
-00008a50: 7374 6172 743d 4e6f 6e65 2c20 745f 7374  start=None, t_st
-00008a60: 6f70 3d4e 6f6e 652c 2075 6e69 745f 6c69  op=None, unit_li
-00008a70: 7374 3d4e 6f6e 652c 0a20 2020 2020 2020  st=None,.       
-00008a80: 2020 2020 2020 2020 2020 7761 7665 666f            wavefo
-00008a90: 726d 733d 4661 6c73 6529 3a0a 2020 2020  rms=False):.    
-00008aa0: 2020 2020 2727 270a 2020 2020 2020 2020      '''.        
-00008ab0: 5265 6164 7320 6e73 6520 6669 6c65 2061  Reads nse file a
-00008ac0: 6e64 2061 7474 6163 6865 7320 636f 6e74  nd attaches cont
-00008ad0: 656e 7420 6173 2073 7069 6b65 2074 7261  ent as spike tra
-00008ae0: 696e 2074 6f20 7072 6f76 6964 6564 206e  in to provided n
-00008af0: 656f 0a20 2020 2020 2020 2073 6567 6d65  eo.        segme
-00008b00: 6e74 2e20 5469 6d65 7320 6361 6e20 6265  nt. Times can be
-00008b10: 2070 726f 7669 6465 6420 696e 2073 616d   provided in sam
-00008b20: 706c 6573 2028 696e 7465 6765 7220 7661  ples (integer va
-00008b30: 6c75 6573 292e 2049 6620 7468 650a 2020  lues). If the.  
-00008b40: 2020 2020 2020 6e73 6520 6669 6c65 2064        nse file d
-00008b50: 6f65 7320 6e6f 7420 636f 6e74 6169 6e20  oes not contain 
-00008b60: 6120 7361 6d70 6c69 6e67 2072 6174 6520  a sampling rate 
-00008b70: 7661 6c75 652c 2074 6865 206e 6373 2073  value, the ncs s
-00008b80: 616d 706c 696e 670a 2020 2020 2020 2020  ampling.        
-00008b90: 7261 7465 206f 6e20 7468 6520 7361 6d65  rate on the same
-00008ba0: 2065 6c65 6374 726f 6465 2069 7320 7573   electrode is us
-00008bb0: 6564 2e0a 0a20 2020 2020 2020 2041 7267  ed...        Arg
-00008bc0: 756d 656e 7473 3a0a 2020 2020 2020 2020  uments:.        
-00008bd0: 2020 2020 6669 6c65 6e61 6d65 5f6e 7365      filename_nse
-00008be0: 203a 204e 616d 6520 6f66 2074 6865 202e   : Name of the .
-00008bf0: 6e73 6520 6669 6c65 2074 6f20 6265 206c  nse file to be l
-00008c00: 6f61 6465 642e 0a20 2020 2020 2020 2020  oaded..         
-00008c10: 2020 2073 6567 203a 204e 656f 2053 6567     seg : Neo Seg
-00008c20: 6d65 6e74 2c20 746f 2077 6869 6368 2074  ment, to which t
-00008c30: 6865 2053 7069 6b65 7472 6169 6e20 636f  he Spiketrain co
-00008c40: 6e74 6169 6e69 6e67 2074 6865 2064 6174  ntaining the dat
-00008c50: 610a 2020 2020 2020 2020 2020 2020 2020  a.              
-00008c60: 2020 2020 2020 2020 2020 2020 2020 7769                wi
-00008c70: 6c6c 2062 6520 6174 7461 6368 6564 2e0a  ll be attached..
-00008c80: 2020 2020 2020 2020 2020 2020 6c61 7a79              lazy
-00008c90: 203a 2050 6f73 7470 6f6e 6520 6163 7475   : Postpone actu
-00008ca0: 616c 2072 6561 6469 6e67 206f 6620 7468  al reading of th
-00008cb0: 6520 6461 7461 2e20 496e 7374 6561 6420  e data. Instead 
-00008cc0: 7072 6f76 6964 6520 6120 6475 6d6d 790a  provide a dummy.
-00008cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ce0: 2020 2020 2020 2020 2020 2020 5370 696b              Spik
-00008cf0: 6554 7261 696e 2e20 4465 6661 756c 7420  eTrain. Default 
-00008d00: 2746 616c 7365 272e 0a20 2020 2020 2020  'False'..       
-00008d10: 2020 2020 2063 6173 6361 6465 203a 204e       cascade : N
-00008d20: 6f74 2075 7365 6420 696e 2074 6869 7320  ot used in this 
-00008d30: 636f 6e74 6578 742e 2044 6566 6175 6c74  context. Default
-00008d40: 3a20 2754 7275 6527 2e0a 2020 2020 2020  : 'True'..      
-00008d50: 2020 2020 2020 745f 7374 6172 7420 3a20        t_start : 
-00008d60: 7469 6d65 206f 7220 7361 6d70 6c65 2028  time or sample (
-00008d70: 7175 616e 7469 7479 206f 7220 696e 7465  quantity or inte
-00008d80: 6765 7229 2074 6861 7420 7468 650a 2020  ger) that the.  
-00008d90: 2020 2020 2020 2020 2020 5370 696b 6554            SpikeT
-00008da0: 7261 696e 2062 6567 696e 732e 0a20 2020  rain begins..   
-00008db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008dc0: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
-00008dd0: 204e 6f6e 652e 0a20 2020 2020 2020 2020   None..         
-00008de0: 2020 2074 5f73 746f 7020 3a20 7469 6d65     t_stop : time
-00008df0: 206f 7220 7361 6d70 6c65 2028 7175 616e   or sample (quan
-00008e00: 7469 7479 206f 7220 696e 7465 6765 7229  tity or integer)
-00008e10: 2074 6861 7420 7468 6520 5370 696b 6554   that the SpikeT
-00008e20: 7261 696e 0a20 2020 2020 2020 2020 2020  rain.           
-00008e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008e40: 2065 6e64 732e 0a20 2020 2020 2020 2020   ends..         
-00008e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008e60: 2020 2044 6566 6175 6c74 204e 6f6e 652e     Default None.
-00008e70: 0a20 2020 2020 2020 2020 2020 2075 6e69  .            uni
-00008e80: 745f 6c69 7374 203a 2075 6e69 7420 6964  t_list : unit id
-00008e90: 7320 746f 2062 6520 6c6f 6164 6564 2e20  s to be loaded. 
-00008ea0: 4966 205b 5d2c 2061 6c6c 2075 6e69 7473  If [], all units
-00008eb0: 2061 7265 206c 6f61 6465 642e 0a20 2020   are loaded..   
+000081b0: 2020 2020 2020 2020 2774 5f73 7461 7274          't_start
+000081c0: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
+000081d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000081e0: 2020 2020 2020 2020 202d 2073 656c 662e           - self.
+000081f0: 7061 7261 6d65 7465 7273 5f67 6c6f 6261  parameters_globa
+00008200: 6c5b 2774 5f73 7461 7274 275d 292c 0a20  l['t_start']),. 
+00008210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008230: 2066 696c 656e 616d 655f 6e65 7629 290a   filename_nev)).
+00008240: 0a20 2020 2020 2020 2069 6620 745f 7374  .        if t_st
+00008250: 6172 7420 3e3d 2074 5f73 746f 703a 0a20  art >= t_stop:. 
+00008260: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00008270: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+00008280: 2020 2020 2020 2020 2020 2020 2027 5265               'Re
+00008290: 7175 6573 7465 6420 7374 6172 7420 7469  quested start ti
+000082a0: 6d65 2028 2573 2920 6973 206c 6174 6572  me (%s) is later
+000082b0: 2074 6861 6e20 2f20 6571 7561 6c20 746f   than / equal to
+000082c0: 2073 746f 7020 270a 2020 2020 2020 2020   stop '.        
+000082d0: 2020 2020 2020 2020 2774 696d 6520 270a          'time '.
+000082e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000082f0: 2728 2573 2920 270a 2020 2020 2020 2020  '(%s) '.        
+00008300: 2020 2020 2020 2020 2766 6f72 2066 696c          'for fil
+00008310: 6520 2573 2e27 2025 2028 745f 7374 6172  e %s.' % (t_star
+00008320: 742c 2074 5f73 746f 702c 2066 696c 656e  t, t_stop, filen
+00008330: 616d 655f 6e65 7629 290a 0a20 2020 2020  ame_nev))..     
+00008340: 2020 2064 6174 6120 3d20 7365 6c66 2e5f     data = self._
+00008350: 5f6d 6d61 705f 6e65 765f 6669 6c65 2866  _mmap_nev_file(f
+00008360: 696c 656e 616d 655f 6e65 7629 0a20 2020  ilename_nev).   
+00008370: 2020 2020 2023 2045 7874 7261 6374 696e       # Extractin
+00008380: 6720 616c 6c20 6576 656e 7473 2066 6f72  g all events for
+00008390: 206f 6e65 2065 7665 6e74 2074 7970 6520   one event type 
+000083a0: 616e 6420 7075 7420 6974 2069 6e74 6f20  and put it into 
+000083b0: 616e 2065 7665 6e74 0a20 2020 2020 2020  an event.       
+000083c0: 2023 2061 7272 6179 0a20 2020 2020 2020   # array.       
+000083d0: 2023 2054 4f44 4f3a 2043 6865 636b 2069   # TODO: Check i
+000083e0: 6620 7468 6973 2069 7320 7468 6520 636f  f this is the co
+000083f0: 7272 6563 7420 7761 7920 6f66 2065 7665  rrect way of eve
+00008400: 6e74 2063 7265 6174 696f 6e2e 0a20 2020  nt creation..   
+00008410: 2020 2020 2066 6f72 2065 7665 6e74 5f74       for event_t
+00008420: 7970 6520 696e 2073 656c 662e 7061 7261  ype in self.para
+00008430: 6d65 7465 7273 5f6e 6576 5b66 696c 656e  meters_nev[filen
+00008440: 616d 655f 6e65 765d 5b27 6576 656e 745f  ame_nev]['event_
+00008450: 7479 7065 7327 5d3a 0a20 2020 2020 2020  types']:.       
+00008460: 2020 2020 2023 2045 7874 7261 6374 2061       # Extract a
+00008470: 6c6c 2074 696d 6520 7374 616d 7073 206f  ll time stamps o
+00008480: 6620 6469 6769 7461 6c20 6d61 726b 6572  f digital marker
+00008490: 7320 616e 6420 7265 7363 616c 696e 6720  s and rescaling 
+000084a0: 7469 6d65 0a20 2020 2020 2020 2020 2020  time.           
+000084b0: 2074 7970 655f 6d61 736b 203d 205b 6920   type_mask = [i 
+000084c0: 666f 7220 6920 696e 2072 616e 6765 286c  for i in range(l
+000084d0: 656e 2864 6174 6129 2920 6966 0a20 2020  en(data)) if.   
+000084e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000084f0: 2020 2020 2020 2864 6174 615b 695d 5b34        (data[i][4
+00008500: 5d20 3d3d 2065 7665 6e74 5f74 7970 655b  ] == event_type[
+00008510: 2765 7665 6e74 5f69 6427 5d0a 2020 2020  'event_id'].    
+00008520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008530: 2020 2020 2020 616e 6420 6461 7461 5b69        and data[i
+00008540: 5d5b 355d 203d 3d20 6576 656e 745f 7479  ][5] == event_ty
+00008550: 7065 5b27 6e74 746c 275d 0a20 2020 2020  pe['nttl'].     
+00008560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008570: 2020 2020 2061 6e64 2064 6174 615b 695d       and data[i]
+00008580: 5b31 305d 2e64 6563 6f64 6528 276c 6174  [10].decode('lat
+00008590: 696e 2d31 2729 203d 3d20 6576 656e 745f  in-1') == event_
+000085a0: 7479 7065 5b0a 2020 2020 2020 2020 2020  type[.          
+000085b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000085c0: 2020 2020 276e 616d 6527 5d29 5d0a 2020      'name'])].  
+000085d0: 2020 2020 2020 2020 2020 6d61 726b 6572            marker
+000085e0: 5f74 696d 6573 203d 205b 745b 335d 2066  _times = [t[3] f
+000085f0: 6f72 2074 2069 6e0a 2020 2020 2020 2020  or t in.        
+00008600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008610: 2020 2020 6461 7461 5b74 7970 655f 6d61      data[type_ma
+00008620: 736b 5d5d 202a 2073 656c 662e 6e65 765f  sk]] * self.nev_
+00008630: 7469 6d65 5f75 6e69 7420 2d20 5c0a 2020  time_unit - \.  
+00008640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008650: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
+00008660: 7261 6d65 7465 7273 5f67 6c6f 6261 6c5b  rameters_global[
+00008670: 2774 5f73 7461 7274 275d 0a0a 2020 2020  't_start']..    
+00008680: 2020 2020 2020 2020 2320 6f6e 6c79 2063          # only c
+00008690: 6f6e 7369 6465 7220 4576 656e 7473 2069  onsider Events i
+000086a0: 6e20 7468 6520 7265 7175 6573 7465 6420  n the requested 
+000086b0: 7469 6d65 2077 696e 646f 7720 5b74 5f73  time window [t_s
+000086c0: 7461 7274 2c0a 2020 2020 2020 2020 2020  tart,.          
+000086d0: 2020 2320 745f 7374 6f70 5d0a 2020 2020    # t_stop].    
+000086e0: 2020 2020 2020 2020 7469 6d65 5f6d 6173          time_mas
+000086f0: 6b20 3d20 5b69 2066 6f72 2069 2069 6e20  k = [i for i in 
+00008700: 7261 6e67 6528 6c65 6e28 6d61 726b 6572  range(len(marker
+00008710: 5f74 696d 6573 2929 2069 6620 280a 2020  _times)) if (.  
+00008720: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
+00008730: 726b 6572 5f74 696d 6573 5b69 5d20 3e3d  rker_times[i] >=
+00008740: 2074 5f73 7461 7274 2061 6e64 206d 6172   t_start and mar
+00008750: 6b65 725f 7469 6d65 735b 695d 203c 3d20  ker_times[i] <= 
+00008760: 745f 7374 6f70 295d 0a20 2020 2020 2020  t_stop)].       
+00008770: 2020 2020 206d 6172 6b65 725f 7469 6d65       marker_time
+00008780: 7320 3d20 6d61 726b 6572 5f74 696d 6573  s = marker_times
+00008790: 5b74 696d 655f 6d61 736b 5d0a 0a20 2020  [time_mask]..   
+000087a0: 2020 2020 2020 2020 2023 2044 6f20 6e6f           # Do no
+000087b0: 7420 6372 6561 7465 2061 6e20 6576 656e  t create an even
+000087c0: 7461 7272 6179 2069 6620 7468 6572 6520  tarray if there 
+000087d0: 6172 6520 6e6f 2065 7665 6e74 7320 6f66  are no events of
+000087e0: 2074 6869 7320 7479 7065 0a20 2020 2020   this type.     
+000087f0: 2020 2020 2020 2023 2020 696e 2074 6865         #  in the
+00008800: 2072 6571 7565 7374 6564 2074 696d 6520   requested time 
+00008810: 7261 6e67 650a 2020 2020 2020 2020 2020  range.          
+00008820: 2020 6966 206c 656e 286d 6172 6b65 725f    if len(marker_
+00008830: 7469 6d65 7329 203d 3d20 303a 0a20 2020  times) == 0:.   
+00008840: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+00008850: 7469 6e75 650a 0a20 2020 2020 2020 2020  tinue..         
+00008860: 2020 2065 7620 3d20 4576 656e 7428 7469     ev = Event(ti
+00008870: 6d65 733d 7071 2e51 7561 6e74 6974 7928  mes=pq.Quantity(
+00008880: 6d61 726b 6572 5f74 696d 6573 2c20 756e  marker_times, un
+00008890: 6974 733d 7365 6c66 2e6e 6576 5f74 696d  its=self.nev_tim
+000088a0: 655f 756e 6974 2c0a 2020 2020 2020 2020  e_unit,.        
+000088b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000088c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000088d0: 2064 7479 7065 3d22 696e 7422 292c 0a20   dtype="int"),. 
+000088e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000088f0: 2020 2020 2020 6c61 6265 6c73 3d65 7665        labels=eve
+00008900: 6e74 5f74 7970 655b 276e 616d 6527 5d2c  nt_type['name'],
+00008910: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008920: 2020 2020 2020 2020 6e61 6d65 3d22 4469          name="Di
+00008930: 6769 7461 6c20 4d61 726b 6572 2022 202b  gital Marker " +
+00008940: 2073 7472 2865 7665 6e74 5f74 7970 6529   str(event_type)
+00008950: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00008960: 2020 2020 2020 2020 2066 696c 655f 6f72           file_or
+00008970: 6967 696e 3d66 696c 656e 616d 655f 6e65  igin=filename_ne
+00008980: 762c 0a20 2020 2020 2020 2020 2020 2020  v,.             
+00008990: 2020 2020 2020 2020 2020 6d61 726b 6572            marker
+000089a0: 5f69 643d 6576 656e 745f 7479 7065 5b27  _id=event_type['
+000089b0: 6576 656e 745f 6964 275d 2c0a 2020 2020  event_id'],.    
+000089c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000089d0: 2020 2064 6967 6974 616c 5f6d 6172 6b65     digital_marke
+000089e0: 723d 5472 7565 2c0a 2020 2020 2020 2020  r=True,.        
+000089f0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+00008a00: 6e61 6c6f 675f 6d61 726b 6572 3d46 616c  nalog_marker=Fal
+00008a10: 7365 2c0a 2020 2020 2020 2020 2020 2020  se,.            
+00008a20: 2020 2020 2020 2020 2020 206e 7474 6c3d             nttl=
+00008a30: 6576 656e 745f 7479 7065 5b27 6e74 746c  event_type['nttl
+00008a40: 275d 290a 0a20 2020 2020 2020 2020 2020  '])..           
+00008a50: 2073 6567 2e65 7665 6e74 732e 6170 7065   seg.events.appe
+00008a60: 6e64 2865 7629 0a0a 2020 2020 6465 6620  nd(ev)..    def 
+00008a70: 7265 6164 5f6e 7365 2873 656c 662c 2066  read_nse(self, f
+00008a80: 696c 656e 616d 655f 6e73 652c 2073 6567  ilename_nse, seg
+00008a90: 2c20 6c61 7a79 3d46 616c 7365 2c20 6361  , lazy=False, ca
+00008aa0: 7363 6164 653d 5472 7565 2c0a 2020 2020  scade=True,.    
+00008ab0: 2020 2020 2020 2020 2020 2020 2074 5f73               t_s
+00008ac0: 7461 7274 3d4e 6f6e 652c 2074 5f73 746f  tart=None, t_sto
+00008ad0: 703d 4e6f 6e65 2c20 756e 6974 5f6c 6973  p=None, unit_lis
+00008ae0: 743d 4e6f 6e65 2c0a 2020 2020 2020 2020  t=None,.        
+00008af0: 2020 2020 2020 2020 2077 6176 6566 6f72           wavefor
+00008b00: 6d73 3d46 616c 7365 293a 0a20 2020 2020  ms=False):.     
+00008b10: 2020 2027 2727 0a20 2020 2020 2020 2052     '''.        R
+00008b20: 6561 6473 206e 7365 2066 696c 6520 616e  eads nse file an
+00008b30: 6420 6174 7461 6368 6573 2063 6f6e 7465  d attaches conte
+00008b40: 6e74 2061 7320 7370 696b 6520 7472 6169  nt as spike trai
+00008b50: 6e20 746f 2070 726f 7669 6465 6420 6e65  n to provided ne
+00008b60: 6f0a 2020 2020 2020 2020 7365 676d 656e  o.        segmen
+00008b70: 742e 2054 696d 6573 2063 616e 2062 6520  t. Times can be 
+00008b80: 7072 6f76 6964 6564 2069 6e20 7361 6d70  provided in samp
+00008b90: 6c65 7320 2869 6e74 6567 6572 2076 616c  les (integer val
+00008ba0: 7565 7329 2e20 4966 2074 6865 0a20 2020  ues). If the.   
+00008bb0: 2020 2020 206e 7365 2066 696c 6520 646f       nse file do
+00008bc0: 6573 206e 6f74 2063 6f6e 7461 696e 2061  es not contain a
+00008bd0: 2073 616d 706c 696e 6720 7261 7465 2076   sampling rate v
+00008be0: 616c 7565 2c20 7468 6520 6e63 7320 7361  alue, the ncs sa
+00008bf0: 6d70 6c69 6e67 0a20 2020 2020 2020 2072  mpling.        r
+00008c00: 6174 6520 6f6e 2074 6865 2073 616d 6520  ate on the same 
+00008c10: 656c 6563 7472 6f64 6520 6973 2075 7365  electrode is use
+00008c20: 642e 0a0a 2020 2020 2020 2020 4172 6775  d...        Argu
+00008c30: 6d65 6e74 733a 0a20 2020 2020 2020 2020  ments:.         
+00008c40: 2020 2066 696c 656e 616d 655f 6e73 6520     filename_nse 
+00008c50: 3a20 4e61 6d65 206f 6620 7468 6520 2e6e  : Name of the .n
+00008c60: 7365 2066 696c 6520 746f 2062 6520 6c6f  se file to be lo
+00008c70: 6164 6564 2e0a 2020 2020 2020 2020 2020  aded..          
+00008c80: 2020 7365 6720 3a20 4e65 6f20 5365 676d    seg : Neo Segm
+00008c90: 656e 742c 2074 6f20 7768 6963 6820 7468  ent, to which th
+00008ca0: 6520 5370 696b 6574 7261 696e 2063 6f6e  e Spiketrain con
+00008cb0: 7461 696e 696e 6720 7468 6520 6461 7461  taining the data
+00008cc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008cd0: 2020 2020 2020 2020 2020 2020 2077 696c               wil
+00008ce0: 6c20 6265 2061 7474 6163 6865 642e 0a20  l be attached.. 
+00008cf0: 2020 2020 2020 2020 2020 206c 617a 7920             lazy 
+00008d00: 3a20 506f 7374 706f 6e65 2061 6374 7561  : Postpone actua
+00008d10: 6c20 7265 6164 696e 6720 6f66 2074 6865  l reading of the
+00008d20: 2064 6174 612e 2049 6e73 7465 6164 2070   data. Instead p
+00008d30: 726f 7669 6465 2061 2064 756d 6d79 0a20  rovide a dummy. 
+00008d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008d50: 2020 2020 2020 2020 2020 2053 7069 6b65             Spike
+00008d60: 5472 6169 6e2e 2044 6566 6175 6c74 2027  Train. Default '
+00008d70: 4661 6c73 6527 2e0a 2020 2020 2020 2020  False'..        
+00008d80: 2020 2020 6361 7363 6164 6520 3a20 4e6f      cascade : No
+00008d90: 7420 7573 6564 2069 6e20 7468 6973 2063  t used in this c
+00008da0: 6f6e 7465 7874 2e20 4465 6661 756c 743a  ontext. Default:
+00008db0: 2027 5472 7565 272e 0a20 2020 2020 2020   'True'..       
+00008dc0: 2020 2020 2074 5f73 7461 7274 203a 2074       t_start : t
+00008dd0: 696d 6520 6f72 2073 616d 706c 6520 2871  ime or sample (q
+00008de0: 7561 6e74 6974 7920 6f72 2069 6e74 6567  uantity or integ
+00008df0: 6572 2920 7468 6174 2074 6865 0a20 2020  er) that the.   
+00008e00: 2020 2020 2020 2020 2053 7069 6b65 5472           SpikeTr
+00008e10: 6169 6e20 6265 6769 6e73 2e0a 2020 2020  ain begins..    
+00008e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008e30: 2020 2020 2020 2020 4465 6661 756c 7420          Default 
+00008e40: 4e6f 6e65 2e0a 2020 2020 2020 2020 2020  None..          
+00008e50: 2020 745f 7374 6f70 203a 2074 696d 6520    t_stop : time 
+00008e60: 6f72 2073 616d 706c 6520 2871 7561 6e74  or sample (quant
+00008e70: 6974 7920 6f72 2069 6e74 6567 6572 2920  ity or integer) 
+00008e80: 7468 6174 2074 6865 2053 7069 6b65 5472  that the SpikeTr
+00008e90: 6169 6e0a 2020 2020 2020 2020 2020 2020  ain.            
+00008ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008eb0: 656e 6473 2e0a 2020 2020 2020 2020 2020  ends..          
 00008ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008ed0: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
-00008ee0: 204e 6f6e 652e 0a20 2020 2020 2020 2020   None..         
-00008ef0: 2020 2077 6176 6566 6f72 6d73 203a 204c     waveforms : L
-00008f00: 6f61 6420 7468 6520 7761 7665 666f 726d  oad the waveform
-00008f10: 2028 7570 2074 6f20 3332 2064 6174 6120   (up to 32 data 
-00008f20: 706f 696e 7473 2920 666f 7220 6561 6368  points) for each
-00008f30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008f40: 2020 2020 2020 2020 2020 2020 2073 7069               spi
-00008f50: 6b65 2074 696d 652e 2044 6566 6175 6c74  ke time. Default
-00008f60: 3a20 4661 6c73 650a 0a20 2020 2020 2020  : False..       
-00008f70: 2052 6574 7572 6e73 3a0a 2020 2020 2020   Returns:.      
-00008f80: 2020 2020 2020 4e6f 6e65 0a20 2020 2020        None.     
-00008f90: 2020 2027 2727 0a0a 2020 2020 2020 2020     '''..        
-00008fa0: 6966 2066 696c 656e 616d 655f 6e73 655b  if filename_nse[
-00008fb0: 2d34 3a5d 2021 3d20 272e 6e73 6527 3a0a  -4:] != '.nse':.
-00008fc0: 2020 2020 2020 2020 2020 2020 6669 6c65              file
-00008fd0: 6e61 6d65 5f6e 7365 202b 3d20 272e 6e73  name_nse += '.ns
-00008fe0: 6527 0a20 2020 2020 2020 2069 6620 7365  e'.        if se
-00008ff0: 7020 696e 2066 696c 656e 616d 655f 6e73  p in filename_ns
-00009000: 653a 0a20 2020 2020 2020 2020 2020 2066  e:.            f
-00009010: 696c 656e 616d 655f 6e73 6520 3d20 6669  ilename_nse = fi
-00009020: 6c65 6e61 6d65 5f6e 7365 2e73 706c 6974  lename_nse.split
-00009030: 2873 6570 295b 2d31 5d0a 0a20 2020 2020  (sep)[-1]..     
-00009040: 2020 2023 2065 7874 7261 6374 696e 6720     # extracting 
-00009050: 6368 616e 6e65 6c20 6964 206f 6620 7265  channel id of re
-00009060: 7175 6573 7465 6420 6669 6c65 0a20 2020  quested file.   
-00009070: 2020 2020 2063 6861 6e6e 656c 5f69 6420       channel_id 
-00009080: 3d20 7365 6c66 2e67 6574 5f63 6861 6e6e  = self.get_chann
-00009090: 656c 5f69 645f 6279 5f66 696c 655f 6e61  el_id_by_file_na
-000090a0: 6d65 2866 696c 656e 616d 655f 6e73 6529  me(filename_nse)
-000090b0: 0a20 2020 2020 2020 2069 6620 6368 616e  .        if chan
-000090c0: 6e65 6c5f 6964 2069 7320 6e6f 7420 4e6f  nel_id is not No
-000090d0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-000090e0: 6368 6964 203d 2063 6861 6e6e 656c 5f69  chid = channel_i
-000090f0: 640a 2020 2020 2020 2020 656c 7365 3a0a  d.        else:.
-00009100: 2020 2020 2020 2020 2020 2020 2320 6966              # if
-00009110: 206e 7365 2066 696c 6520 6973 2065 6d70   nse file is emp
-00009120: 7479 2069 7420 6973 206e 6f74 206c 6973  ty it is not lis
-00009130: 7465 6420 696e 2073 656c 662e 7061 7261  ted in self.para
-00009140: 6d65 7465 7273 5f6e 7365 2c20 6275 740a  meters_nse, but.
-00009150: 2020 2020 2020 2020 2020 2020 2320 696e              # in
-00009160: 2073 656c 662e 6e73 655f 6176 6169 6c0a   self.nse_avail.
-00009170: 2020 2020 2020 2020 2020 2020 6966 2066              if f
-00009180: 696c 656e 616d 655f 6e73 6520 696e 2073  ilename_nse in s
-00009190: 656c 662e 6e73 655f 6176 6169 6c3a 0a20  elf.nse_avail:. 
-000091a0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-000091b0: 6172 6e69 6e67 732e 7761 726e 2827 4e65  arnings.warn('Ne
-000091c0: 7572 616c 796e 7849 4f20 6973 2061 7474  uralynxIO is att
-000091d0: 656d 7074 696e 6720 746f 2072 6561 6420  empting to read 
-000091e0: 616e 2065 6d70 7479 2027 0a20 2020 2020  an empty '.     
-000091f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009200: 2020 2020 2020 2020 2027 286e 6f74 2061           '(not a
-00009210: 7373 6f63 6961 7465 6429 206e 7365 2066  ssociated) nse f
-00009220: 696c 6520 2825 7329 2e20 270a 2020 2020  ile (%s). '.    
-00009230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009240: 2020 2020 2020 2020 2020 274e 6f74 206c            'Not l
-00009250: 6f61 6469 6e67 206e 7365 2066 696c 652e  oading nse file.
-00009260: 2720 2520 2866 696c 656e 616d 655f 6e73  ' % (filename_ns
-00009270: 6529 290a 2020 2020 2020 2020 2020 2020  e)).            
-00009280: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
-00009290: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-000092a0: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-000092b0: 7365 2056 616c 7565 4572 726f 7228 274e  se ValueError('N
-000092c0: 6575 7261 6c79 6e78 494f 2069 7320 6174  euralynxIO is at
-000092d0: 7465 6d70 7469 6e67 2074 6f20 7265 6164  tempting to read
-000092e0: 2061 2066 696c 6520 270a 2020 2020 2020   a file '.      
-000092f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009300: 2020 2020 2020 2020 2020 2027 6e6f 7420             'not 
-00009310: 6173 736f 6369 6174 6564 2074 6f20 7468  associated to th
-00009320: 6973 2073 6573 7369 6f6e 2028 2573 292e  is session (%s).
-00009330: 2720 2520 280a 2020 2020 2020 2020 2020  ' % (.          
-00009340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009350: 2020 2020 2020 2020 2020 2066 696c 656e             filen
-00009360: 616d 655f 6e73 6529 290a 0a20 2020 2020  ame_nse))..     
-00009370: 2020 2023 2065 6e73 7572 6520 6d65 616e     # ensure mean
-00009380: 696e 6766 756c 2076 616c 7565 7320 666f  ingful values fo
-00009390: 7220 7265 7175 6573 7465 6420 7374 6172  r requested star
-000093a0: 7420 616e 6420 7374 6f70 2074 696d 6573  t and stop times
-000093b0: 0a20 2020 2020 2020 2023 2069 6e20 6361  .        # in ca
-000093c0: 7365 2074 696d 6520 6973 2070 726f 7669  se time is provi
-000093d0: 6465 6420 696e 2073 616d 706c 6573 3a20  ded in samples: 
-000093e0: 7472 616e 7366 6f72 6d20 746f 2061 6273  transform to abs
-000093f0: 6f6c 7574 6520 7469 6d65 2075 6e69 7473  olute time units
-00009400: 0a20 2020 2020 2020 2023 206e 6373 2073  .        # ncs s
-00009410: 616d 706c 696e 6720 7261 7465 2069 7320  ampling rate is 
-00009420: 6265 7374 2067 7565 7373 2069 6620 7468  best guess if th
-00009430: 6572 6520 6973 206e 6f20 6578 706c 6963  ere is no explic
-00009440: 6974 2073 616d 706c 696e 670a 2020 2020  it sampling.    
-00009450: 2020 2020 2320 7261 7465 2067 6976 656e      # rate given
-00009460: 2066 6f72 206e 7365 2076 616c 7565 732e   for nse values.
-00009470: 0a20 2020 2020 2020 2069 6620 2773 616d  .        if 'sam
-00009480: 706c 696e 675f 7261 7465 2720 696e 2073  pling_rate' in s
-00009490: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-000094a0: 7365 5b63 6869 645d 3a0a 2020 2020 2020  se[chid]:.      
-000094b0: 2020 2020 2020 7372 203d 2073 656c 662e        sr = self.
-000094c0: 7061 7261 6d65 7465 7273 5f6e 7365 5b63  parameters_nse[c
-000094d0: 6869 645d 5b27 7361 6d70 6c69 6e67 5f72  hid]['sampling_r
-000094e0: 6174 6527 5d0a 2020 2020 2020 2020 656c  ate'].        el
-000094f0: 6966 2063 6869 6420 696e 2073 656c 662e  if chid in self.
-00009500: 7061 7261 6d65 7465 7273 5f6e 6373 2061  parameters_ncs a
-00009510: 6e64 2027 7361 6d70 6c69 6e67 5f72 6174  nd 'sampling_rat
-00009520: 6527 2069 6e20 5c0a 2020 2020 2020 2020  e' in \.        
-00009530: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-00009540: 616d 6574 6572 735f 6e63 735b 6368 6964  ameters_ncs[chid
-00009550: 5d3a 0a20 2020 2020 2020 2020 2020 2073  ]:.            s
-00009560: 7220 3d20 7365 6c66 2e70 6172 616d 6574  r = self.paramet
-00009570: 6572 735f 6e63 735b 6368 6964 5d5b 2773  ers_ncs[chid]['s
-00009580: 616d 706c 696e 675f 7261 7465 275d 0a20  ampling_rate']. 
-00009590: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-000095a0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-000095b0: 616c 7565 4572 726f 7228 0a20 2020 2020  alueError(.     
-000095c0: 2020 2020 2020 2020 2020 2027 4e6f 2073             'No s
-000095d0: 616d 706c 696e 6720 7261 7465 2070 7265  ampling rate pre
-000095e0: 7365 6e74 2066 6f72 2063 6861 6e6e 656c  sent for channel
-000095f0: 2069 6420 2569 2069 6e20 6e73 6520 6669   id %i in nse fi
-00009600: 6c65 2027 0a20 2020 2020 2020 2020 2020  le '.           
-00009610: 2020 2020 2027 2573 2e20 270a 2020 2020       '%s. '.    
-00009620: 2020 2020 2020 2020 2020 2020 2743 6f75              'Cou
-00009630: 6c64 2061 6c73 6f20 6e6f 7420 6669 6e64  ld also not find
-00009640: 2074 6865 2073 616d 706c 696e 6720 7261   the sampling ra
-00009650: 7465 206f 6620 7468 6520 7265 7370 6563  te of the respec
-00009660: 7469 7665 2027 0a20 2020 2020 2020 2020  tive '.         
-00009670: 2020 2020 2020 2027 6e63 7320 270a 2020         'ncs '.  
-00009680: 2020 2020 2020 2020 2020 2020 2020 2766                'f
-00009690: 696c 652e 2720 2520 280a 2020 2020 2020  ile.' % (.      
-000096a0: 2020 2020 2020 2020 2020 2020 2020 6368                ch
-000096b0: 6964 2c20 6669 6c65 6e61 6d65 5f6e 7365  id, filename_nse
-000096c0: 2929 0a0a 2020 2020 2020 2020 6966 2069  ))..        if i
-000096d0: 7369 6e73 7461 6e63 6528 745f 7374 6172  sinstance(t_star
-000096e0: 742c 2069 6e74 293a 0a20 2020 2020 2020  t, int):.       
-000096f0: 2020 2020 2074 5f73 7461 7274 203d 2074       t_start = t
-00009700: 5f73 7461 7274 202f 2073 720a 2020 2020  _start / sr.    
-00009710: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-00009720: 6528 745f 7374 6f70 2c20 696e 7429 3a0a  e(t_stop, int):.
-00009730: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
-00009740: 6f70 203d 2074 5f73 746f 7020 2f20 7372  op = t_stop / sr
-00009750: 0a0a 2020 2020 2020 2020 2320 2b20 7265  ..        # + re
-00009760: 7363 616c 696e 6720 676c 6f62 616c 2072  scaling global r
-00009770: 6563 6f72 6469 6e67 2073 7461 7274 2028  ecording start (
-00009780: 6669 7273 7420 7361 6d70 6c65 2069 6e20  first sample in 
-00009790: 616e 7920 6669 6c65 2074 7970 6529 0a0a  any file type)..
-000097a0: 2020 2020 2020 2020 2320 5468 6973 2069          # This i
-000097b0: 7320 6e6f 7420 6f70 7469 6d61 6c2c 2061  s not optimal, a
-000097c0: 7320 7468 6572 6520 6973 206e 6f20 7761  s there is no wa
-000097d0: 7920 746f 206b 6e6f 7720 686f 7720 6c6f  y to know how lo
-000097e0: 6e67 2074 6865 0a20 2020 2020 2020 2023  ng the.        #
-000097f0: 2072 6563 6f72 6469 6e67 206c 6173 7465   recording laste
-00009800: 6420 6166 7465 7220 6c61 7374 2073 7069  d after last spi
-00009810: 6b65 0a20 2020 2020 2020 2069 6620 745f  ke.        if t_
-00009820: 7374 6172 7420 6973 204e 6f6e 6520 6f72  start is None or
-00009830: 2074 5f73 7461 7274 203c 2028 0a20 2020   t_start < (.   
-00009840: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
-00009850: 7261 6d65 7465 7273 5f6e 7365 5b63 6869  rameters_nse[chi
-00009860: 645d 5b27 745f 6669 7273 7427 5d0a 2020  d]['t_first'].  
-00009870: 2020 2020 2020 2020 2020 2d20 7365 6c66            - self
-00009880: 2e70 6172 616d 6574 6572 735f 676c 6f62  .parameters_glob
-00009890: 616c 5b0a 2020 2020 2020 2020 2020 2020  al[.            
-000098a0: 2020 2020 2774 5f73 7461 7274 275d 293a      't_start']):
-000098b0: 0a20 2020 2020 2020 2020 2020 2074 5f73  .            t_s
-000098c0: 7461 7274 203d 2028 0a20 2020 2020 2020  tart = (.       
-000098d0: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
-000098e0: 7261 6d65 7465 7273 5f6e 7365 5b63 6869  rameters_nse[chi
-000098f0: 645d 5b27 745f 6669 7273 7427 5d20 2d20  d]['t_first'] - 
-00009900: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00009910: 676c 6f62 616c 5b0a 2020 2020 2020 2020  global[.        
-00009920: 2020 2020 2020 2020 2020 2020 2774 5f73              't_s
-00009930: 7461 7274 275d 290a 0a20 2020 2020 2020  tart'])..       
-00009940: 2069 6620 745f 7374 6172 7420 3e20 280a   if t_start > (.
-00009950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009960: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00009970: 6e73 655b 6368 6964 5d5b 2774 5f6c 6173  nse[chid]['t_las
-00009980: 7427 5d0a 2020 2020 2020 2020 2020 2020  t'].            
-00009990: 2020 2020 2d20 7365 6c66 2e70 6172 616d      - self.param
-000099a0: 6574 6572 735f 676c 6f62 616c 5b27 745f  eters_global['t_
-000099b0: 7374 6172 7427 5d29 3a0a 2020 2020 2020  start']):.      
-000099c0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-000099d0: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
-000099e0: 2020 2020 2020 2020 2752 6571 7565 7374          'Request
-000099f0: 6564 2074 696d 6573 2077 696e 646f 7720  ed times window 
-00009a00: 2825 7320 746f 2025 7329 2069 7320 6c61  (%s to %s) is la
-00009a10: 7465 7220 7468 616e 2064 6174 6120 6172  ter than data ar
-00009a20: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
-00009a30: 2020 2020 2772 6563 6f72 6465 6420 2874      'recorded (t
-00009a40: 5f73 746f 7020 3d20 2573 2920 270a 2020  _stop = %s) '.  
-00009a50: 2020 2020 2020 2020 2020 2020 2020 2766                'f
-00009a60: 6f72 2066 696c 6520 2573 2e27 2025 2028  or file %s.' % (
-00009a70: 745f 7374 6172 742c 2074 5f73 746f 702c  t_start, t_stop,
-00009a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009aa0: 2020 2028 7365 6c66 2e70 6172 616d 6574     (self.paramet
-00009ab0: 6572 735f 6e73 655b 6368 6964 5d5b 2774  ers_nse[chid]['t
-00009ac0: 5f6c 6173 7427 5d0a 2020 2020 2020 2020  _last'].        
-00009ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ae0: 2020 2020 2020 2020 2020 202d 2073 656c             - sel
-00009af0: 662e 7061 7261 6d65 7465 7273 5f67 6c6f  f.parameters_glo
-00009b00: 6261 6c5b 2774 5f73 7461 7274 275d 292c  bal['t_start']),
-00009b10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b30: 2020 2066 696c 656e 616d 655f 6e73 6529     filename_nse)
-00009b40: 290a 0a20 2020 2020 2020 2069 6620 745f  )..        if t_
-00009b50: 7374 6f70 2069 7320 4e6f 6e65 3a0a 2020  stop is None:.  
-00009b60: 2020 2020 2020 2020 2020 745f 7374 6f70            t_stop
-00009b70: 203d 2028 7379 732e 6d61 7873 697a 6529   = (sys.maxsize)
-00009b80: 202a 2073 656c 662e 6e73 655f 7469 6d65   * self.nse_time
-00009b90: 5f75 6e69 740a 2020 2020 2020 2020 6966  _unit.        if
-00009ba0: 2074 5f73 746f 7020 6973 204e 6f6e 6520   t_stop is None 
-00009bb0: 6f72 2074 5f73 746f 7020 3e20 280a 2020  or t_stop > (.  
-00009bc0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
-00009bd0: 6172 616d 6574 6572 735f 6e73 655b 6368  arameters_nse[ch
-00009be0: 6964 5d5b 2774 5f6c 6173 7427 5d0a 2020  id]['t_last'].  
-00009bf0: 2020 2020 2020 2020 2020 2d20 7365 6c66            - self
-00009c00: 2e70 6172 616d 6574 6572 735f 676c 6f62  .parameters_glob
-00009c10: 616c 5b0a 2020 2020 2020 2020 2020 2020  al[.            
-00009c20: 2020 2020 2774 5f73 7461 7274 275d 293a      't_start']):
-00009c30: 0a20 2020 2020 2020 2020 2020 2074 5f73  .            t_s
-00009c40: 746f 7020 3d20 280a 2020 2020 2020 2020  top = (.        
-00009c50: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-00009c60: 616d 6574 6572 735f 6e73 655b 6368 6964  ameters_nse[chid
-00009c70: 5d5b 2774 5f6c 6173 7427 5d20 2d20 7365  ]['t_last'] - se
-00009c80: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
-00009c90: 6f62 616c 5b0a 2020 2020 2020 2020 2020  obal[.          
-00009ca0: 2020 2020 2020 2020 2020 2774 5f73 7461            't_sta
-00009cb0: 7274 275d 290a 0a20 2020 2020 2020 2069  rt'])..        i
-00009cc0: 6620 745f 7374 6f70 203c 2028 0a20 2020  f t_stop < (.   
-00009cd0: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
-00009ce0: 7261 6d65 7465 7273 5f6e 7365 5b63 6869  rameters_nse[chi
-00009cf0: 645d 5b27 745f 6669 7273 7427 5d0a 2020  d]['t_first'].  
-00009d00: 2020 2020 2020 2020 2020 2d20 7365 6c66            - self
-00009d10: 2e70 6172 616d 6574 6572 735f 676c 6f62  .parameters_glob
-00009d20: 616c 5b0a 2020 2020 2020 2020 2020 2020  al[.            
-00009d30: 2020 2020 2774 5f73 7461 7274 275d 293a      't_start']):
-00009d40: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-00009d50: 7365 2056 616c 7565 4572 726f 7228 0a20  se ValueError(. 
-00009d60: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00009d70: 5265 7175 6573 7465 6420 7469 6d65 7320  Requested times 
-00009d80: 7769 6e64 6f77 2028 2573 2074 6f20 2573  window (%s to %s
-00009d90: 2920 6973 2065 6172 6c69 6572 2074 6861  ) is earlier tha
-00009da0: 6e20 6461 7461 2027 0a20 2020 2020 2020  n data '.       
-00009db0: 2020 2020 2020 2020 2027 6172 6520 7265           'are re
-00009dc0: 636f 7264 6564 2028 745f 7374 6172 7420  corded (t_start 
-00009dd0: 3d20 2573 2920 270a 2020 2020 2020 2020  = %s) '.        
-00009de0: 2020 2020 2020 2020 2766 6f72 2066 696c          'for fil
-00009df0: 6520 2573 2e27 2025 2028 745f 7374 6172  e %s.' % (t_star
-00009e00: 742c 2074 5f73 746f 702c 0a20 2020 2020  t, t_stop,.     
-00009e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e20: 2020 2020 2020 2020 2020 2020 2028 7365               (se
-00009e30: 6c66 2e70 6172 616d 6574 6572 735f 6e73  lf.parameters_ns
-00009e40: 655b 6368 6964 5d5b 2774 5f66 6972 7374  e[chid]['t_first
-00009e50: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
-00009e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e70: 2020 2020 2020 2d20 7365 6c66 2e70 6172        - self.par
-00009e80: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
-00009e90: 745f 7374 6172 7427 5d29 2c0a 2020 2020  t_start']),.    
-00009ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009eb0: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-00009ec0: 6c65 6e61 6d65 5f6e 7365 2929 0a0a 2020  lename_nse))..  
-00009ed0: 2020 2020 2020 6966 2074 5f73 7461 7274        if t_start
-00009ee0: 203e 3d20 745f 7374 6f70 3a0a 2020 2020   >= t_stop:.    
-00009ef0: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-00009f00: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
-00009f10: 2020 2020 2020 2020 2020 2752 6571 7565            'Reque
-00009f20: 7374 6564 2073 7461 7274 2074 696d 6520  sted start time 
-00009f30: 2825 7329 2069 7320 6c61 7465 7220 7468  (%s) is later th
-00009f40: 616e 202f 2065 7175 616c 2074 6f20 7374  an / equal to st
-00009f50: 6f70 2027 0a20 2020 2020 2020 2020 2020  op '.           
-00009f60: 2020 2020 2027 7469 6d65 2027 0a20 2020       'time '.   
-00009f70: 2020 2020 2020 2020 2020 2020 2027 2825               '(%
-00009f80: 7329 2066 6f72 2066 696c 6520 2573 2e27  s) for file %s.'
-00009f90: 2025 2028 745f 7374 6172 742c 2074 5f73   % (t_start, t_s
-00009fa0: 746f 702c 2066 696c 656e 616d 655f 6e73  top, filename_ns
-00009fb0: 6529 290a 0a20 2020 2020 2020 2023 2072  e))..        # r
-00009fc0: 6561 6469 6e67 2064 6174 610a 2020 2020  eading data.    
-00009fd0: 2020 2020 5b74 696d 6573 7461 6d70 732c      [timestamps,
-00009fe0: 2063 6861 6e6e 656c 5f69 6473 2c20 6365   channel_ids, ce
-00009ff0: 6c6c 5f6e 756d 6265 7273 2c20 6665 6174  ll_numbers, feat
-0000a000: 7572 6573 2c0a 2020 2020 2020 2020 2064  ures,.         d
-0000a010: 6174 615f 706f 696e 7473 5d20 3d20 7365  ata_points] = se
-0000a020: 6c66 2e5f 5f6d 6d61 705f 6e73 655f 7061  lf.__mmap_nse_pa
-0000a030: 636b 6574 7328 6669 6c65 6e61 6d65 5f6e  ckets(filename_n
-0000a040: 7365 290a 0a20 2020 2020 2020 2023 206c  se)..        # l
-0000a050: 6f61 6420 616c 6c20 756e 6974 7320 6176  oad all units av
-0000a060: 6169 6c61 626c 6520 6966 2075 6e69 745f  ailable if unit_
-0000a070: 6c69 7374 3d3d 5b5d 206f 7220 4e6f 6e65  list==[] or None
-0000a080: 0a20 2020 2020 2020 2069 6620 756e 6974  .        if unit
-0000a090: 5f6c 6973 7420 3d3d 205b 5d20 6f72 2075  _list == [] or u
-0000a0a0: 6e69 745f 6c69 7374 2069 7320 4e6f 6e65  nit_list is None
-0000a0b0: 3a0a 2020 2020 2020 2020 2020 2020 756e  :.            un
-0000a0c0: 6974 5f6c 6973 7420 3d20 6e70 2e75 6e69  it_list = np.uni
-0000a0d0: 7175 6528 6365 6c6c 5f6e 756d 6265 7273  que(cell_numbers
-0000a0e0: 290a 2020 2020 2020 2020 656c 6966 206e  ).        elif n
-0000a0f0: 6f74 2061 6e79 285b 7520 696e 2063 656c  ot any([u in cel
-0000a100: 6c5f 6e75 6d62 6572 7320 666f 7220 7520  l_numbers for u 
-0000a110: 696e 2075 6e69 745f 6c69 7374 5d29 3a0a  in unit_list]):.
-0000a120: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000a130: 2e5f 6469 6167 6e6f 7374 6963 5f70 7269  ._diagnostic_pri
-0000a140: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
-0000a150: 2020 2020 274e 6f6e 6520 6f66 2074 6865      'None of the
-0000a160: 2072 6571 7565 7374 6564 2075 6e69 7420   requested unit 
-0000a170: 6964 7320 2825 7329 2070 7265 7365 6e74  ids (%s) present
-0000a180: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-0000a190: 2020 2027 696e 206e 7365 2066 696c 6520     'in nse file 
-0000a1a0: 2573 2028 636f 6e74 6169 6e73 2075 6e69  %s (contains uni
-0000a1b0: 745f 6c69 7374 2025 7329 2720 2520 280a  t_list %s)' % (.
-0000a1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1d0: 2020 2020 756e 6974 5f6c 6973 742c 2066      unit_list, f
-0000a1e0: 696c 656e 616d 655f 6e73 652c 206e 702e  ilename_nse, np.
-0000a1f0: 756e 6971 7565 2863 656c 6c5f 6e75 6d62  unique(cell_numb
-0000a200: 6572 7329 2929 0a0a 2020 2020 2020 2020  ers)))..        
-0000a210: 2320 6578 7472 6163 7469 6e67 2073 7069  # extracting spi
-0000a220: 6b65 7320 756e 6974 2d77 6973 6520 616e  kes unit-wise an
-0000a230: 6420 6765 6e65 7261 7465 2073 7069 6b65  d generate spike
-0000a240: 7472 6169 6e73 0a20 2020 2020 2020 2066  trains.        f
-0000a250: 6f72 2075 6e69 745f 6920 696e 2075 6e69  or unit_i in uni
-0000a260: 745f 6c69 7374 3a0a 2020 2020 2020 2020  t_list:.        
-0000a270: 2020 2020 6966 206e 6f74 206c 617a 793a      if not lazy:
-0000a280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a290: 2023 2045 7874 7261 6374 2061 6c6c 2074   # Extract all t
-0000a2a0: 696d 6520 7374 616d 7073 206f 6620 7468  ime stamps of th
-0000a2b0: 6174 206e 6575 726f 6e20 6f6e 2074 6861  at neuron on tha
-0000a2c0: 7420 656c 6563 7472 6f64 650a 2020 2020  t electrode.    
-0000a2d0: 2020 2020 2020 2020 2020 2020 756e 6974              unit
-0000a2e0: 5f6d 6173 6b20 3d20 6e70 2e77 6865 7265  _mask = np.where
-0000a2f0: 2863 656c 6c5f 6e75 6d62 6572 7320 3d3d  (cell_numbers ==
-0000a300: 2075 6e69 745f 6929 5b30 5d0a 2020 2020   unit_i)[0].    
-0000a310: 2020 2020 2020 2020 2020 2020 7370 696b              spik
-0000a320: 655f 7469 6d65 7320 3d20 7469 6d65 7374  e_times = timest
-0000a330: 616d 7073 5b75 6e69 745f 6d61 736b 5d20  amps[unit_mask] 
-0000a340: 2a20 7365 6c66 2e6e 7365 5f74 696d 655f  * self.nse_time_
-0000a350: 756e 6974 0a20 2020 2020 2020 2020 2020  unit.           
-0000a360: 2020 2020 2073 7069 6b65 5f74 696d 6573       spike_times
-0000a370: 203d 2073 7069 6b65 5f74 696d 6573 202d   = spike_times -
-0000a380: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-0000a390: 5f67 6c6f 6261 6c5b 2774 5f73 7461 7274  _global['t_start
-0000a3a0: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
-0000a3b0: 2020 2074 696d 655f 6d61 736b 203d 206e     time_mask = n
-0000a3c0: 702e 7768 6572 6528 6e70 2e6c 6f67 6963  p.where(np.logic
-0000a3d0: 616c 5f61 6e64 2873 7069 6b65 5f74 696d  al_and(spike_tim
-0000a3e0: 6573 203e 3d20 745f 7374 6172 742c 0a20  es >= t_start,. 
-0000a3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a420: 2020 2073 7069 6b65 5f74 696d 6573 203c     spike_times <
-0000a430: 2074 5f73 746f 7029 290a 2020 2020 2020   t_stop)).      
-0000a440: 2020 2020 2020 2020 2020 7370 696b 655f            spike_
-0000a450: 7469 6d65 7320 3d20 7370 696b 655f 7469  times = spike_ti
-0000a460: 6d65 735b 7469 6d65 5f6d 6173 6b5d 0a20  mes[time_mask]. 
-0000a470: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000a480: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a490: 2073 7069 6b65 5f74 696d 6573 203d 2070   spike_times = p
-0000a4a0: 712e 5175 616e 7469 7479 285b 5d2c 2075  q.Quantity([], u
-0000a4b0: 6e69 7473 3d73 656c 662e 6e73 655f 7469  nits=self.nse_ti
-0000a4c0: 6d65 5f75 6e69 7429 0a0a 2020 2020 2020  me_unit)..      
-0000a4d0: 2020 2020 2020 2320 4372 6561 7465 2053        # Create S
-0000a4e0: 7069 6b65 5472 6169 6e20 6f62 6a65 6374  pikeTrain object
-0000a4f0: 0a20 2020 2020 2020 2020 2020 2073 7420  .            st 
-0000a500: 3d20 5370 696b 6554 7261 696e 2874 696d  = SpikeTrain(tim
-0000a510: 6573 3d73 7069 6b65 5f74 696d 6573 2c0a  es=spike_times,.
-0000a520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a530: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
-0000a540: 6172 743d 745f 7374 6172 742c 0a20 2020  art=t_start,.   
-0000a550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a560: 2020 2020 2020 2020 2074 5f73 746f 703d           t_stop=
-0000a570: 745f 7374 6f70 2c0a 2020 2020 2020 2020  t_stop,.        
-0000a580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a590: 2020 2020 7361 6d70 6c69 6e67 5f72 6174      sampling_rat
-0000a5a0: 653d 7365 6c66 2e70 6172 616d 6574 6572  e=self.parameter
-0000a5b0: 735f 6e63 735b 6368 6964 5d5b 0a20 2020  s_ncs[chid][.   
+00008ed0: 2020 4465 6661 756c 7420 4e6f 6e65 2e0a    Default None..
+00008ee0: 2020 2020 2020 2020 2020 2020 756e 6974              unit
+00008ef0: 5f6c 6973 7420 3a20 756e 6974 2069 6473  _list : unit ids
+00008f00: 2074 6f20 6265 206c 6f61 6465 642e 2049   to be loaded. I
+00008f10: 6620 5b5d 2c20 616c 6c20 756e 6974 7320  f [], all units 
+00008f20: 6172 6520 6c6f 6164 6564 2e0a 2020 2020  are loaded..    
+00008f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008f40: 2020 2020 2020 2020 4465 6661 756c 7420          Default 
+00008f50: 4e6f 6e65 2e0a 2020 2020 2020 2020 2020  None..          
+00008f60: 2020 7761 7665 666f 726d 7320 3a20 4c6f    waveforms : Lo
+00008f70: 6164 2074 6865 2077 6176 6566 6f72 6d20  ad the waveform 
+00008f80: 2875 7020 746f 2033 3220 6461 7461 2070  (up to 32 data p
+00008f90: 6f69 6e74 7329 2066 6f72 2065 6163 680a  oints) for each.
+00008fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008fb0: 2020 2020 2020 2020 2020 2020 7370 696b              spik
+00008fc0: 6520 7469 6d65 2e20 4465 6661 756c 743a  e time. Default:
+00008fd0: 2046 616c 7365 0a0a 2020 2020 2020 2020   False..        
+00008fe0: 5265 7475 726e 733a 0a20 2020 2020 2020  Returns:.       
+00008ff0: 2020 2020 204e 6f6e 650a 2020 2020 2020       None.      
+00009000: 2020 2727 270a 0a20 2020 2020 2020 2069    '''..        i
+00009010: 6620 6669 6c65 6e61 6d65 5f6e 7365 5b2d  f filename_nse[-
+00009020: 343a 5d20 213d 2027 2e6e 7365 273a 0a20  4:] != '.nse':. 
+00009030: 2020 2020 2020 2020 2020 2066 696c 656e             filen
+00009040: 616d 655f 6e73 6520 2b3d 2027 2e6e 7365  ame_nse += '.nse
+00009050: 270a 2020 2020 2020 2020 6966 2073 6570  '.        if sep
+00009060: 2069 6e20 6669 6c65 6e61 6d65 5f6e 7365   in filename_nse
+00009070: 3a0a 2020 2020 2020 2020 2020 2020 6669  :.            fi
+00009080: 6c65 6e61 6d65 5f6e 7365 203d 2066 696c  lename_nse = fil
+00009090: 656e 616d 655f 6e73 652e 7370 6c69 7428  ename_nse.split(
+000090a0: 7365 7029 5b2d 315d 0a0a 2020 2020 2020  sep)[-1]..      
+000090b0: 2020 2320 6578 7472 6163 7469 6e67 2063    # extracting c
+000090c0: 6861 6e6e 656c 2069 6420 6f66 2072 6571  hannel id of req
+000090d0: 7565 7374 6564 2066 696c 650a 2020 2020  uested file.    
+000090e0: 2020 2020 6368 616e 6e65 6c5f 6964 203d      channel_id =
+000090f0: 2073 656c 662e 6765 745f 6368 616e 6e65   self.get_channe
+00009100: 6c5f 6964 5f62 795f 6669 6c65 5f6e 616d  l_id_by_file_nam
+00009110: 6528 6669 6c65 6e61 6d65 5f6e 7365 290a  e(filename_nse).
+00009120: 2020 2020 2020 2020 6966 2063 6861 6e6e          if chann
+00009130: 656c 5f69 6420 6973 206e 6f74 204e 6f6e  el_id is not Non
+00009140: 653a 0a20 2020 2020 2020 2020 2020 2063  e:.            c
+00009150: 6869 6420 3d20 6368 616e 6e65 6c5f 6964  hid = channel_id
+00009160: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00009170: 2020 2020 2020 2020 2020 2023 2069 6620             # if 
+00009180: 6e73 6520 6669 6c65 2069 7320 656d 7074  nse file is empt
+00009190: 7920 6974 2069 7320 6e6f 7420 6c69 7374  y it is not list
+000091a0: 6564 2069 6e20 7365 6c66 2e70 6172 616d  ed in self.param
+000091b0: 6574 6572 735f 6e73 652c 2062 7574 0a20  eters_nse, but. 
+000091c0: 2020 2020 2020 2020 2020 2023 2069 6e20             # in 
+000091d0: 7365 6c66 2e6e 7365 5f61 7661 696c 0a20  self.nse_avail. 
+000091e0: 2020 2020 2020 2020 2020 2069 6620 6669             if fi
+000091f0: 6c65 6e61 6d65 5f6e 7365 2069 6e20 7365  lename_nse in se
+00009200: 6c66 2e6e 7365 5f61 7661 696c 3a0a 2020  lf.nse_avail:.  
+00009210: 2020 2020 2020 2020 2020 2020 2020 7761                wa
+00009220: 726e 696e 6773 2e77 6172 6e28 274e 6575  rnings.warn('Neu
+00009230: 7261 6c79 6e78 494f 2069 7320 6174 7465  ralynxIO is atte
+00009240: 6d70 7469 6e67 2074 6f20 7265 6164 2061  mpting to read a
+00009250: 6e20 656d 7074 7920 270a 2020 2020 2020  n empty '.      
+00009260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009270: 2020 2020 2020 2020 2728 6e6f 7420 6173          '(not as
+00009280: 736f 6369 6174 6564 2920 6e73 6520 6669  sociated) nse fi
+00009290: 6c65 2028 2573 292e 2027 0a20 2020 2020  le (%s). '.     
+000092a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000092b0: 2020 2020 2020 2020 2027 4e6f 7420 6c6f           'Not lo
+000092c0: 6164 696e 6720 6e73 6520 6669 6c65 2e27  ading nse file.'
+000092d0: 2025 2028 6669 6c65 6e61 6d65 5f6e 7365   % (filename_nse
+000092e0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+000092f0: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
+00009300: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00009310: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00009320: 6520 5661 6c75 6545 7272 6f72 2827 4e65  e ValueError('Ne
+00009330: 7572 616c 796e 7849 4f20 6973 2061 7474  uralynxIO is att
+00009340: 656d 7074 696e 6720 746f 2072 6561 6420  empting to read 
+00009350: 6120 6669 6c65 2027 0a20 2020 2020 2020  a file '.       
+00009360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009370: 2020 2020 2020 2020 2020 276e 6f74 2061            'not a
+00009380: 7373 6f63 6961 7465 6420 746f 2074 6869  ssociated to thi
+00009390: 7320 7365 7373 696f 6e20 2825 7329 2e27  s session (%s).'
+000093a0: 2025 2028 0a20 2020 2020 2020 2020 2020   % (.           
+000093b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000093c0: 2020 2020 2020 2020 2020 6669 6c65 6e61            filena
+000093d0: 6d65 5f6e 7365 2929 0a0a 2020 2020 2020  me_nse))..      
+000093e0: 2020 2320 656e 7375 7265 206d 6561 6e69    # ensure meani
+000093f0: 6e67 6675 6c20 7661 6c75 6573 2066 6f72  ngful values for
+00009400: 2072 6571 7565 7374 6564 2073 7461 7274   requested start
+00009410: 2061 6e64 2073 746f 7020 7469 6d65 730a   and stop times.
+00009420: 2020 2020 2020 2020 2320 696e 2063 6173          # in cas
+00009430: 6520 7469 6d65 2069 7320 7072 6f76 6964  e time is provid
+00009440: 6564 2069 6e20 7361 6d70 6c65 733a 2074  ed in samples: t
+00009450: 7261 6e73 666f 726d 2074 6f20 6162 736f  ransform to abso
+00009460: 6c75 7465 2074 696d 6520 756e 6974 730a  lute time units.
+00009470: 2020 2020 2020 2020 2320 6e63 7320 7361          # ncs sa
+00009480: 6d70 6c69 6e67 2072 6174 6520 6973 2062  mpling rate is b
+00009490: 6573 7420 6775 6573 7320 6966 2074 6865  est guess if the
+000094a0: 7265 2069 7320 6e6f 2065 7870 6c69 6369  re is no explici
+000094b0: 7420 7361 6d70 6c69 6e67 0a20 2020 2020  t sampling.     
+000094c0: 2020 2023 2072 6174 6520 6769 7665 6e20     # rate given 
+000094d0: 666f 7220 6e73 6520 7661 6c75 6573 2e0a  for nse values..
+000094e0: 2020 2020 2020 2020 6966 2027 7361 6d70          if 'samp
+000094f0: 6c69 6e67 5f72 6174 6527 2069 6e20 7365  ling_rate' in se
+00009500: 6c66 2e70 6172 616d 6574 6572 735f 6e73  lf.parameters_ns
+00009510: 655b 6368 6964 5d3a 0a20 2020 2020 2020  e[chid]:.       
+00009520: 2020 2020 2073 7220 3d20 7365 6c66 2e70       sr = self.p
+00009530: 6172 616d 6574 6572 735f 6e73 655b 6368  arameters_nse[ch
+00009540: 6964 5d5b 2773 616d 706c 696e 675f 7261  id]['sampling_ra
+00009550: 7465 275d 0a20 2020 2020 2020 2065 6c69  te'].        eli
+00009560: 6620 6368 6964 2069 6e20 7365 6c66 2e70  f chid in self.p
+00009570: 6172 616d 6574 6572 735f 6e63 7320 616e  arameters_ncs an
+00009580: 6420 2773 616d 706c 696e 675f 7261 7465  d 'sampling_rate
+00009590: 2720 696e 205c 0a20 2020 2020 2020 2020  ' in \.         
+000095a0: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
+000095b0: 6d65 7465 7273 5f6e 6373 5b63 6869 645d  meters_ncs[chid]
+000095c0: 3a0a 2020 2020 2020 2020 2020 2020 7372  :.            sr
+000095d0: 203d 2073 656c 662e 7061 7261 6d65 7465   = self.paramete
+000095e0: 7273 5f6e 6373 5b63 6869 645d 5b27 7361  rs_ncs[chid]['sa
+000095f0: 6d70 6c69 6e67 5f72 6174 6527 5d0a 2020  mpling_rate'].  
+00009600: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00009610: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00009620: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
+00009630: 2020 2020 2020 2020 2020 274e 6f20 7361            'No sa
+00009640: 6d70 6c69 6e67 2072 6174 6520 7072 6573  mpling rate pres
+00009650: 656e 7420 666f 7220 6368 616e 6e65 6c20  ent for channel 
+00009660: 6964 2025 6920 696e 206e 7365 2066 696c  id %i in nse fil
+00009670: 6520 270a 2020 2020 2020 2020 2020 2020  e '.            
+00009680: 2020 2020 2725 732e 2027 0a20 2020 2020      '%s. '.     
+00009690: 2020 2020 2020 2020 2020 2027 436f 756c             'Coul
+000096a0: 6420 616c 736f 206e 6f74 2066 696e 6420  d also not find 
+000096b0: 7468 6520 7361 6d70 6c69 6e67 2072 6174  the sampling rat
+000096c0: 6520 6f66 2074 6865 2072 6573 7065 6374  e of the respect
+000096d0: 6976 6520 270a 2020 2020 2020 2020 2020  ive '.          
+000096e0: 2020 2020 2020 276e 6373 2027 0a20 2020        'ncs '.   
+000096f0: 2020 2020 2020 2020 2020 2020 2027 6669               'fi
+00009700: 6c65 2e27 2025 2028 0a20 2020 2020 2020  le.' % (.       
+00009710: 2020 2020 2020 2020 2020 2020 2063 6869               chi
+00009720: 642c 2066 696c 656e 616d 655f 6e73 6529  d, filename_nse)
+00009730: 290a 0a20 2020 2020 2020 2069 6620 6973  )..        if is
+00009740: 696e 7374 616e 6365 2874 5f73 7461 7274  instance(t_start
+00009750: 2c20 696e 7429 3a0a 2020 2020 2020 2020  , int):.        
+00009760: 2020 2020 745f 7374 6172 7420 3d20 745f      t_start = t_
+00009770: 7374 6172 7420 2f20 7372 0a20 2020 2020  start / sr.     
+00009780: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+00009790: 2874 5f73 746f 702c 2069 6e74 293a 0a20  (t_stop, int):. 
+000097a0: 2020 2020 2020 2020 2020 2074 5f73 746f             t_sto
+000097b0: 7020 3d20 745f 7374 6f70 202f 2073 720a  p = t_stop / sr.
+000097c0: 0a20 2020 2020 2020 2023 202b 2072 6573  .        # + res
+000097d0: 6361 6c69 6e67 2067 6c6f 6261 6c20 7265  caling global re
+000097e0: 636f 7264 696e 6720 7374 6172 7420 2866  cording start (f
+000097f0: 6972 7374 2073 616d 706c 6520 696e 2061  irst sample in a
+00009800: 6e79 2066 696c 6520 7479 7065 290a 0a20  ny file type).. 
+00009810: 2020 2020 2020 2023 2054 6869 7320 6973         # This is
+00009820: 206e 6f74 206f 7074 696d 616c 2c20 6173   not optimal, as
+00009830: 2074 6865 7265 2069 7320 6e6f 2077 6179   there is no way
+00009840: 2074 6f20 6b6e 6f77 2068 6f77 206c 6f6e   to know how lon
+00009850: 6720 7468 650a 2020 2020 2020 2020 2320  g the.        # 
+00009860: 7265 636f 7264 696e 6720 6c61 7374 6564  recording lasted
+00009870: 2061 6674 6572 206c 6173 7420 7370 696b   after last spik
+00009880: 650a 2020 2020 2020 2020 6966 2074 5f73  e.        if t_s
+00009890: 7461 7274 2069 7320 4e6f 6e65 206f 7220  tart is None or 
+000098a0: 745f 7374 6172 7420 3c20 280a 2020 2020  t_start < (.    
+000098b0: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+000098c0: 616d 6574 6572 735f 6e73 655b 6368 6964  ameters_nse[chid
+000098d0: 5d5b 2774 5f66 6972 7374 275d 0a20 2020  ]['t_first'].   
+000098e0: 2020 2020 2020 2020 202d 2073 656c 662e           - self.
+000098f0: 7061 7261 6d65 7465 7273 5f67 6c6f 6261  parameters_globa
+00009900: 6c5b 0a20 2020 2020 2020 2020 2020 2020  l[.             
+00009910: 2020 2027 745f 7374 6172 7427 5d29 3a0a     't_start']):.
+00009920: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
+00009930: 6172 7420 3d20 280a 2020 2020 2020 2020  art = (.        
+00009940: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00009950: 616d 6574 6572 735f 6e73 655b 6368 6964  ameters_nse[chid
+00009960: 5d5b 2774 5f66 6972 7374 275d 202d 2073  ]['t_first'] - s
+00009970: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
+00009980: 6c6f 6261 6c5b 0a20 2020 2020 2020 2020  lobal[.         
+00009990: 2020 2020 2020 2020 2020 2027 745f 7374             't_st
+000099a0: 6172 7427 5d29 0a0a 2020 2020 2020 2020  art'])..        
+000099b0: 6966 2074 5f73 7461 7274 203e 2028 0a20  if t_start > (. 
+000099c0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000099d0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+000099e0: 7365 5b63 6869 645d 5b27 745f 6c61 7374  se[chid]['t_last
+000099f0: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
+00009a00: 2020 202d 2073 656c 662e 7061 7261 6d65     - self.parame
+00009a10: 7465 7273 5f67 6c6f 6261 6c5b 2774 5f73  ters_global['t_s
+00009a20: 7461 7274 275d 293a 0a20 2020 2020 2020  tart']):.       
+00009a30: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+00009a40: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
+00009a50: 2020 2020 2020 2027 5265 7175 6573 7465         'Requeste
+00009a60: 6420 7469 6d65 7320 7769 6e64 6f77 2028  d times window (
+00009a70: 2573 2074 6f20 2573 2920 6973 206c 6174  %s to %s) is lat
+00009a80: 6572 2074 6861 6e20 6461 7461 2061 7265  er than data are
+00009a90: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00009aa0: 2020 2027 7265 636f 7264 6564 2028 745f     'recorded (t_
+00009ab0: 7374 6f70 203d 2025 7329 2027 0a20 2020  stop = %s) '.   
+00009ac0: 2020 2020 2020 2020 2020 2020 2027 666f               'fo
+00009ad0: 7220 6669 6c65 2025 732e 2720 2520 2874  r file %s.' % (t
+00009ae0: 5f73 7461 7274 2c20 745f 7374 6f70 2c0a  _start, t_stop,.
+00009af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b10: 2020 2873 656c 662e 7061 7261 6d65 7465    (self.paramete
+00009b20: 7273 5f6e 7365 5b63 6869 645d 5b27 745f  rs_nse[chid]['t_
+00009b30: 6c61 7374 275d 0a20 2020 2020 2020 2020  last'].         
+00009b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b50: 2020 2020 2020 2020 2020 2d20 7365 6c66            - self
+00009b60: 2e70 6172 616d 6574 6572 735f 676c 6f62  .parameters_glob
+00009b70: 616c 5b27 745f 7374 6172 7427 5d29 2c0a  al['t_start']),.
+00009b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ba0: 2020 6669 6c65 6e61 6d65 5f6e 7365 2929    filename_nse))
+00009bb0: 0a0a 2020 2020 2020 2020 6966 2074 5f73  ..        if t_s
+00009bc0: 746f 7020 6973 204e 6f6e 653a 0a20 2020  top is None:.   
+00009bd0: 2020 2020 2020 2020 2074 5f73 746f 7020           t_stop 
+00009be0: 3d20 2873 7973 2e6d 6178 7369 7a65 2920  = (sys.maxsize) 
+00009bf0: 2a20 7365 6c66 2e6e 7365 5f74 696d 655f  * self.nse_time_
+00009c00: 756e 6974 0a20 2020 2020 2020 2069 6620  unit.        if 
+00009c10: 745f 7374 6f70 2069 7320 4e6f 6e65 206f  t_stop is None o
+00009c20: 7220 745f 7374 6f70 203e 2028 0a20 2020  r t_stop > (.   
+00009c30: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
+00009c40: 7261 6d65 7465 7273 5f6e 7365 5b63 6869  rameters_nse[chi
+00009c50: 645d 5b27 745f 6c61 7374 275d 0a20 2020  d]['t_last'].   
+00009c60: 2020 2020 2020 2020 202d 2073 656c 662e           - self.
+00009c70: 7061 7261 6d65 7465 7273 5f67 6c6f 6261  parameters_globa
+00009c80: 6c5b 0a20 2020 2020 2020 2020 2020 2020  l[.             
+00009c90: 2020 2027 745f 7374 6172 7427 5d29 3a0a     't_start']):.
+00009ca0: 2020 2020 2020 2020 2020 2020 745f 7374              t_st
+00009cb0: 6f70 203d 2028 0a20 2020 2020 2020 2020  op = (.         
+00009cc0: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
+00009cd0: 6d65 7465 7273 5f6e 7365 5b63 6869 645d  meters_nse[chid]
+00009ce0: 5b27 745f 6c61 7374 275d 202d 2073 656c  ['t_last'] - sel
+00009cf0: 662e 7061 7261 6d65 7465 7273 5f67 6c6f  f.parameters_glo
+00009d00: 6261 6c5b 0a20 2020 2020 2020 2020 2020  bal[.           
+00009d10: 2020 2020 2020 2020 2027 745f 7374 6172           't_star
+00009d20: 7427 5d29 0a0a 2020 2020 2020 2020 6966  t'])..        if
+00009d30: 2074 5f73 746f 7020 3c20 280a 2020 2020   t_stop < (.    
+00009d40: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00009d50: 616d 6574 6572 735f 6e73 655b 6368 6964  ameters_nse[chid
+00009d60: 5d5b 2774 5f66 6972 7374 275d 0a20 2020  ]['t_first'].   
+00009d70: 2020 2020 2020 2020 202d 2073 656c 662e           - self.
+00009d80: 7061 7261 6d65 7465 7273 5f67 6c6f 6261  parameters_globa
+00009d90: 6c5b 0a20 2020 2020 2020 2020 2020 2020  l[.             
+00009da0: 2020 2027 745f 7374 6172 7427 5d29 3a0a     't_start']):.
+00009db0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00009dc0: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+00009dd0: 2020 2020 2020 2020 2020 2020 2020 2752                'R
+00009de0: 6571 7565 7374 6564 2074 696d 6573 2077  equested times w
+00009df0: 696e 646f 7720 2825 7320 746f 2025 7329  indow (%s to %s)
+00009e00: 2069 7320 6561 726c 6965 7220 7468 616e   is earlier than
+00009e10: 2064 6174 6120 270a 2020 2020 2020 2020   data '.        
+00009e20: 2020 2020 2020 2020 2761 7265 2072 6563          'are rec
+00009e30: 6f72 6465 6420 2874 5f73 7461 7274 203d  orded (t_start =
+00009e40: 2025 7329 2027 0a20 2020 2020 2020 2020   %s) '.         
+00009e50: 2020 2020 2020 2027 666f 7220 6669 6c65         'for file
+00009e60: 2025 732e 2720 2520 2874 5f73 7461 7274   %s.' % (t_start
+00009e70: 2c20 745f 7374 6f70 2c0a 2020 2020 2020  , t_stop,.      
+00009e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e90: 2020 2020 2020 2020 2020 2020 2873 656c              (sel
+00009ea0: 662e 7061 7261 6d65 7465 7273 5f6e 7365  f.parameters_nse
+00009eb0: 5b63 6869 645d 5b27 745f 6669 7273 7427  [chid]['t_first'
+00009ec0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00009ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ee0: 2020 2020 202d 2073 656c 662e 7061 7261       - self.para
+00009ef0: 6d65 7465 7273 5f67 6c6f 6261 6c5b 2774  meters_global['t
+00009f00: 5f73 7461 7274 275d 292c 0a20 2020 2020  _start']),.     
+00009f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f20: 2020 2020 2020 2020 2020 2020 2066 696c               fil
+00009f30: 656e 616d 655f 6e73 6529 290a 0a20 2020  ename_nse))..   
+00009f40: 2020 2020 2069 6620 745f 7374 6172 7420       if t_start 
+00009f50: 3e3d 2074 5f73 746f 703a 0a20 2020 2020  >= t_stop:.     
+00009f60: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+00009f70: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
+00009f80: 2020 2020 2020 2020 2027 5265 7175 6573           'Reques
+00009f90: 7465 6420 7374 6172 7420 7469 6d65 2028  ted start time (
+00009fa0: 2573 2920 6973 206c 6174 6572 2074 6861  %s) is later tha
+00009fb0: 6e20 2f20 6571 7561 6c20 746f 2073 746f  n / equal to sto
+00009fc0: 7020 270a 2020 2020 2020 2020 2020 2020  p '.            
+00009fd0: 2020 2020 2774 696d 6520 270a 2020 2020      'time '.    
+00009fe0: 2020 2020 2020 2020 2020 2020 2728 2573              '(%s
+00009ff0: 2920 666f 7220 6669 6c65 2025 732e 2720  ) for file %s.' 
+0000a000: 2520 2874 5f73 7461 7274 2c20 745f 7374  % (t_start, t_st
+0000a010: 6f70 2c20 6669 6c65 6e61 6d65 5f6e 7365  op, filename_nse
+0000a020: 2929 0a0a 2020 2020 2020 2020 2320 7265  ))..        # re
+0000a030: 6164 696e 6720 6461 7461 0a20 2020 2020  ading data.     
+0000a040: 2020 205b 7469 6d65 7374 616d 7073 2c20     [timestamps, 
+0000a050: 6368 616e 6e65 6c5f 6964 732c 2063 656c  channel_ids, cel
+0000a060: 6c5f 6e75 6d62 6572 732c 2066 6561 7475  l_numbers, featu
+0000a070: 7265 732c 0a20 2020 2020 2020 2020 6461  res,.         da
+0000a080: 7461 5f70 6f69 6e74 735d 203d 2073 656c  ta_points] = sel
+0000a090: 662e 5f5f 6d6d 6170 5f6e 7365 5f70 6163  f.__mmap_nse_pac
+0000a0a0: 6b65 7473 2866 696c 656e 616d 655f 6e73  kets(filename_ns
+0000a0b0: 6529 0a0a 2020 2020 2020 2020 2320 6c6f  e)..        # lo
+0000a0c0: 6164 2061 6c6c 2075 6e69 7473 2061 7661  ad all units ava
+0000a0d0: 696c 6162 6c65 2069 6620 756e 6974 5f6c  ilable if unit_l
+0000a0e0: 6973 743d 3d5b 5d20 6f72 204e 6f6e 650a  ist==[] or None.
+0000a0f0: 2020 2020 2020 2020 6966 2075 6e69 745f          if unit_
+0000a100: 6c69 7374 203d 3d20 5b5d 206f 7220 756e  list == [] or un
+0000a110: 6974 5f6c 6973 7420 6973 204e 6f6e 653a  it_list is None:
+0000a120: 0a20 2020 2020 2020 2020 2020 2075 6e69  .            uni
+0000a130: 745f 6c69 7374 203d 206e 702e 756e 6971  t_list = np.uniq
+0000a140: 7565 2863 656c 6c5f 6e75 6d62 6572 7329  ue(cell_numbers)
+0000a150: 0a20 2020 2020 2020 2065 6c69 6620 6e6f  .        elif no
+0000a160: 7420 616e 7928 5b75 2069 6e20 6365 6c6c  t any([u in cell
+0000a170: 5f6e 756d 6265 7273 2066 6f72 2075 2069  _numbers for u i
+0000a180: 6e20 756e 6974 5f6c 6973 745d 293a 0a20  n unit_list]):. 
+0000a190: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000a1a0: 5f64 6961 676e 6f73 7469 635f 7072 696e  _diagnostic_prin
+0000a1b0: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
+0000a1c0: 2020 2027 4e6f 6e65 206f 6620 7468 6520     'None of the 
+0000a1d0: 7265 7175 6573 7465 6420 756e 6974 2069  requested unit i
+0000a1e0: 6473 2028 2573 2920 7072 6573 656e 7420  ds (%s) present 
+0000a1f0: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+0000a200: 2020 2769 6e20 6e73 6520 6669 6c65 2025    'in nse file %
+0000a210: 7320 2863 6f6e 7461 696e 7320 756e 6974  s (contains unit
+0000a220: 5f6c 6973 7420 2573 2927 2025 2028 0a20  _list %s)' % (. 
+0000a230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a240: 2020 2075 6e69 745f 6c69 7374 2c20 6669     unit_list, fi
+0000a250: 6c65 6e61 6d65 5f6e 7365 2c20 6e70 2e75  lename_nse, np.u
+0000a260: 6e69 7175 6528 6365 6c6c 5f6e 756d 6265  nique(cell_numbe
+0000a270: 7273 2929 290a 0a20 2020 2020 2020 2023  rs)))..        #
+0000a280: 2065 7874 7261 6374 696e 6720 7370 696b   extracting spik
+0000a290: 6573 2075 6e69 742d 7769 7365 2061 6e64  es unit-wise and
+0000a2a0: 2067 656e 6572 6174 6520 7370 696b 6574   generate spiket
+0000a2b0: 7261 696e 730a 2020 2020 2020 2020 666f  rains.        fo
+0000a2c0: 7220 756e 6974 5f69 2069 6e20 756e 6974  r unit_i in unit
+0000a2d0: 5f6c 6973 743a 0a20 2020 2020 2020 2020  _list:.         
+0000a2e0: 2020 2069 6620 6e6f 7420 6c61 7a79 3a0a     if not lazy:.
+0000a2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a300: 2320 4578 7472 6163 7420 616c 6c20 7469  # Extract all ti
+0000a310: 6d65 2073 7461 6d70 7320 6f66 2074 6861  me stamps of tha
+0000a320: 7420 6e65 7572 6f6e 206f 6e20 7468 6174  t neuron on that
+0000a330: 2065 6c65 6374 726f 6465 0a20 2020 2020   electrode.     
+0000a340: 2020 2020 2020 2020 2020 2075 6e69 745f             unit_
+0000a350: 6d61 736b 203d 206e 702e 7768 6572 6528  mask = np.where(
+0000a360: 6365 6c6c 5f6e 756d 6265 7273 203d 3d20  cell_numbers == 
+0000a370: 756e 6974 5f69 295b 305d 0a20 2020 2020  unit_i)[0].     
+0000a380: 2020 2020 2020 2020 2020 2073 7069 6b65             spike
+0000a390: 5f74 696d 6573 203d 2074 696d 6573 7461  _times = timesta
+0000a3a0: 6d70 735b 756e 6974 5f6d 6173 6b5d 202a  mps[unit_mask] *
+0000a3b0: 2073 656c 662e 6e73 655f 7469 6d65 5f75   self.nse_time_u
+0000a3c0: 6e69 740a 2020 2020 2020 2020 2020 2020  nit.            
+0000a3d0: 2020 2020 7370 696b 655f 7469 6d65 7320      spike_times 
+0000a3e0: 3d20 7370 696b 655f 7469 6d65 7320 2d20  = spike_times - 
+0000a3f0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+0000a400: 676c 6f62 616c 5b27 745f 7374 6172 7427  global['t_start'
+0000a410: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000a420: 2020 7469 6d65 5f6d 6173 6b20 3d20 6e70    time_mask = np
+0000a430: 2e77 6865 7265 286e 702e 6c6f 6769 6361  .where(np.logica
+0000a440: 6c5f 616e 6428 7370 696b 655f 7469 6d65  l_and(spike_time
+0000a450: 7320 3e3d 2074 5f73 7461 7274 2c0a 2020  s >= t_start,.  
+0000a460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a490: 2020 7370 696b 655f 7469 6d65 7320 3c20    spike_times < 
+0000a4a0: 745f 7374 6f70 2929 0a20 2020 2020 2020  t_stop)).       
+0000a4b0: 2020 2020 2020 2020 2073 7069 6b65 5f74           spike_t
+0000a4c0: 696d 6573 203d 2073 7069 6b65 5f74 696d  imes = spike_tim
+0000a4d0: 6573 5b74 696d 655f 6d61 736b 5d0a 2020  es[time_mask].  
+0000a4e0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a500: 7370 696b 655f 7469 6d65 7320 3d20 7071  spike_times = pq
+0000a510: 2e51 7561 6e74 6974 7928 5b5d 2c20 756e  .Quantity([], un
+0000a520: 6974 733d 7365 6c66 2e6e 7365 5f74 696d  its=self.nse_tim
+0000a530: 655f 756e 6974 290a 0a20 2020 2020 2020  e_unit)..       
+0000a540: 2020 2020 2023 2043 7265 6174 6520 5370       # Create Sp
+0000a550: 696b 6554 7261 696e 206f 626a 6563 740a  ikeTrain object.
+0000a560: 2020 2020 2020 2020 2020 2020 7374 203d              st =
+0000a570: 2053 7069 6b65 5472 6169 6e28 7469 6d65   SpikeTrain(time
+0000a580: 733d 7370 696b 655f 7469 6d65 732c 0a20  s=spike_times,. 
+0000a590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a5a0: 2020 2020 2020 2020 2020 2074 5f73 7461             t_sta
+0000a5b0: 7274 3d74 5f73 7461 7274 2c0a 2020 2020  rt=t_start,.    
 0000a5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5d0: 2020 2020 2020 2020 2020 2020 2027 7361               'sa
-0000a5e0: 6d70 6c69 6e67 5f72 6174 6527 5d2c 0a20  mpling_rate'],. 
+0000a5d0: 2020 2020 2020 2020 745f 7374 6f70 3d74          t_stop=t
+0000a5e0: 5f73 746f 702c 0a20 2020 2020 2020 2020  _stop,.         
 0000a5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a600: 2020 2020 2020 2020 2020 206e 616d 653d             name=
-0000a610: 2243 6861 6e6e 656c 2025 692c 2055 6e69  "Channel %i, Uni
-0000a620: 7420 2569 2220 2520 2863 6869 642c 2075  t %i" % (chid, u
-0000a630: 6e69 745f 6929 2c0a 2020 2020 2020 2020  nit_i),.        
-0000a640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a650: 2020 2020 6669 6c65 5f6f 7269 6769 6e3d      file_origin=
-0000a660: 6669 6c65 6e61 6d65 5f6e 7365 2c0a 2020  filename_nse,.  
-0000a670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a680: 2020 2020 2020 2020 2020 756e 6974 5f69            unit_i
-0000a690: 643d 756e 6974 5f69 2c0a 2020 2020 2020  d=unit_i,.      
-0000a6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6b0: 2020 2020 2020 6368 616e 6e65 6c5f 6964        channel_id
-0000a6c0: 3d63 6869 6429 0a0a 2020 2020 2020 2020  =chid)..        
-0000a6d0: 2020 2020 6966 2077 6176 6566 6f72 6d73      if waveforms
-0000a6e0: 2061 6e64 206e 6f74 206c 617a 793a 0a20   and not lazy:. 
-0000a6f0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000a700: 2043 6f6c 6c65 6374 2061 6c6c 2077 6176   Collect all wav
-0000a710: 6566 6f72 6d73 206f 6620 7468 6520 7370  eforms of the sp
-0000a720: 6563 6966 6963 2075 6e69 740a 2020 2020  ecific unit.    
-0000a730: 2020 2020 2020 2020 2020 2020 2320 466f              # Fo
-0000a740: 7220 636f 6d70 7574 6174 696f 6e61 6c20  r computational 
-0000a750: 7265 6173 6f6e 733a 206e 6f20 756e 6974  reasons: no unit
-0000a760: 732c 206e 6f20 7469 6d65 2061 7869 730a  s, no time axis.
-0000a770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a780: 7374 2e77 6176 6566 6f72 6d73 203d 2064  st.waveforms = d
-0000a790: 6174 615f 706f 696e 7473 5b75 6e69 745f  ata_points[unit_
-0000a7a0: 6d61 736b 5d5b 7469 6d65 5f6d 6173 6b5d  mask][time_mask]
-0000a7b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a7c0: 2023 2054 4f44 4f3a 2041 6464 2075 6e69   # TODO: Add uni
-0000a7d0: 7473 2074 6f20 7761 7665 666f 726d 7320  ts to waveforms 
-0000a7e0: 2870 712e 7556 3f29 2061 6e64 2061 6464  (pq.uV?) and add
-0000a7f0: 2061 6e6e 6f74 6174 696f 6e0a 2020 2020   annotation.    
-0000a800: 2020 2020 2020 2020 2020 2020 2320 6c65              # le
-0000a810: 6674 5f73 7765 6570 203d 2078 202a 2070  ft_sweep = x * p
-0000a820: 712e 6d73 2069 6e64 6963 6174 696e 6720  q.ms indicating 
-0000a830: 7768 656e 2074 6872 6573 686f 6c64 2063  when threshold c
-0000a840: 726f 7373 696e 670a 2020 2020 2020 2020  rossing.        
-0000a850: 2020 2020 2020 2020 2320 6f63 6375 7272          # occurr
-0000a860: 6564 2069 6e20 7761 7665 666f 726d 0a0a  ed in waveform..
-0000a870: 2020 2020 2020 2020 2020 2020 7374 2e61              st.a
-0000a880: 6e6e 6f74 6174 696f 6e73 2e75 7064 6174  nnotations.updat
-0000a890: 6528 7365 6c66 2e70 6172 616d 6574 6572  e(self.parameter
-0000a8a0: 735f 6e73 655b 6368 6964 5d29 0a20 2020  s_nse[chid]).   
-0000a8b0: 2020 2020 2020 2020 2073 742e 616e 6e6f           st.anno
-0000a8c0: 7461 7469 6f6e 735b 2765 6c65 6374 726f  tations['electro
-0000a8d0: 6465 5f69 6427 5d20 3d20 6368 6964 0a20  de_id'] = chid. 
-0000a8e0: 2020 2020 2020 2020 2020 2023 2054 6869             # Thi
-0000a8f0: 7320 616e 6e6f 7461 7469 6f6e 7320 6973  s annotations is
-0000a900: 206e 6563 6573 7361 7279 2066 6f72 2061   necessary for a
-0000a910: 7574 6f6d 6174 6963 2067 656e 6572 6174  utomatic generat
-0000a920: 696f 6e20 6f66 0a20 2020 2020 2020 2020  ion of.         
-0000a930: 2020 2023 2072 6563 6f72 6469 6e67 6368     # recordingch
-0000a940: 616e 6e65 6c73 0a20 2020 2020 2020 2020  annels.         
-0000a950: 2020 2073 742e 616e 6e6f 7461 7469 6f6e     st.annotation
-0000a960: 735b 2763 6861 6e6e 656c 5f69 6e64 6578  s['channel_index
-0000a970: 275d 203d 2063 6869 640a 0a20 2020 2020  '] = chid..     
-0000a980: 2020 2020 2020 2073 6567 2e73 7069 6b65         seg.spike
-0000a990: 7472 6169 6e73 2e61 7070 656e 6428 7374  trains.append(st
-0000a9a0: 290a 0a20 2020 2064 6566 2072 6561 645f  )..    def read_
-0000a9b0: 6e74 7428 7365 6c66 2c20 6669 6c65 6e61  ntt(self, filena
-0000a9c0: 6d65 5f6e 7474 2c20 7365 672c 206c 617a  me_ntt, seg, laz
-0000a9d0: 793d 4661 6c73 652c 2063 6173 6361 6465  y=False, cascade
-0000a9e0: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
-0000a9f0: 2020 2020 2020 2020 745f 7374 6172 743d          t_start=
-0000aa00: 4e6f 6e65 2c20 745f 7374 6f70 3d4e 6f6e  None, t_stop=Non
-0000aa10: 652c 2075 6e69 745f 6c69 7374 3d4e 6f6e  e, unit_list=Non
-0000aa20: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-0000aa30: 2020 2020 7761 7665 666f 726d 733d 4661      waveforms=Fa
-0000aa40: 6c73 6529 3a0a 2020 2020 2020 2020 2727  lse):.        ''
-0000aa50: 270a 2020 2020 2020 2020 5265 6164 7320  '.        Reads 
-0000aa60: 6e74 7420 6669 6c65 2061 6e64 2061 7474  ntt file and att
-0000aa70: 6163 6865 7320 636f 6e74 656e 7420 6173  aches content as
-0000aa80: 2073 7069 6b65 2074 7261 696e 2074 6f20   spike train to 
-0000aa90: 7072 6f76 6964 6564 206e 656f 0a20 2020  provided neo.   
-0000aaa0: 2020 2020 2073 6567 6d65 6e74 2e0a 0a20       segment... 
-0000aab0: 2020 2020 2020 2041 7267 756d 656e 7473         Arguments
-0000aac0: 3a0a 2020 2020 2020 2020 2020 2020 6669  :.            fi
-0000aad0: 6c65 6e61 6d65 5f6e 7474 203a 204e 616d  lename_ntt : Nam
-0000aae0: 6520 6f66 2074 6865 202e 6e74 7420 6669  e of the .ntt fi
-0000aaf0: 6c65 2074 6f20 6265 206c 6f61 6465 642e  le to be loaded.
-0000ab00: 0a20 2020 2020 2020 2020 2020 2073 6567  .            seg
-0000ab10: 203a 204e 656f 2053 6567 6d65 6e74 2c20   : Neo Segment, 
-0000ab20: 746f 2077 6869 6368 2074 6865 2053 7069  to which the Spi
-0000ab30: 6b65 7472 6169 6e20 636f 6e74 6169 6e69  ketrain containi
-0000ab40: 6e67 2074 6865 2064 6174 610a 2020 2020  ng the data.    
-0000ab50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab60: 2020 2020 2020 2020 7769 6c6c 2062 6520          will be 
-0000ab70: 6174 7461 6368 6564 2e0a 2020 2020 2020  attached..      
-0000ab80: 2020 2020 2020 6c61 7a79 203a 2050 6f73        lazy : Pos
-0000ab90: 7470 6f6e 6520 6163 7475 616c 2072 6561  tpone actual rea
-0000aba0: 6469 6e67 206f 6620 7468 6520 6461 7461  ding of the data
-0000abb0: 2e20 496e 7374 6561 6420 7072 6f76 6964  . Instead provid
-0000abc0: 6520 6120 6475 6d6d 790a 2020 2020 2020  e a dummy.      
-0000abd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000abe0: 2020 2020 2020 5370 696b 6554 7261 696e        SpikeTrain
-0000abf0: 2e20 4465 6661 756c 7420 2746 616c 7365  . Default 'False
-0000ac00: 272e 0a20 2020 2020 2020 2020 2020 2063  '..            c
-0000ac10: 6173 6361 6465 203a 204e 6f74 2075 7365  ascade : Not use
-0000ac20: 6420 696e 2074 6869 7320 636f 6e74 6578  d in this contex
-0000ac30: 742e 2044 6566 6175 6c74 3a20 2754 7275  t. Default: 'Tru
-0000ac40: 6527 2e0a 2020 2020 2020 2020 2020 2020  e'..            
-0000ac50: 745f 7374 6172 7420 3a20 7469 6d65 2028  t_start : time (
-0000ac60: 7175 616e 7469 7479 2920 7468 6174 2074  quantity) that t
-0000ac70: 6865 2053 7069 6b65 5472 6169 6e20 6265  he SpikeTrain be
-0000ac80: 6769 6e73 2e20 4465 6661 756c 7420 4e6f  gins. Default No
-0000ac90: 6e65 2e0a 2020 2020 2020 2020 2020 2020  ne..            
-0000aca0: 745f 7374 6f70 203a 2074 696d 6520 2871  t_stop : time (q
-0000acb0: 7561 6e74 6974 7929 2074 6861 7420 7468  uantity) that th
-0000acc0: 6520 5370 696b 6554 7261 696e 2065 6e64  e SpikeTrain end
-0000acd0: 732e 2044 6566 6175 6c74 204e 6f6e 652e  s. Default None.
-0000ace0: 0a20 2020 2020 2020 2020 2020 2075 6e69  .            uni
-0000acf0: 745f 6c69 7374 203a 2075 6e69 7420 6964  t_list : unit id
-0000ad00: 7320 746f 2062 6520 6c6f 6164 6564 2e20  s to be loaded. 
-0000ad10: 4966 205b 5d20 6f72 204e 6f6e 6520 616c  If [] or None al
-0000ad20: 6c20 756e 6974 7320 6172 650a 2020 2020  l units are.    
-0000ad30: 2020 2020 2020 2020 6c6f 6164 6564 2e0a          loaded..
-0000ad40: 2020 2020 2020 2020 2020 2020 4465 6661              Defa
-0000ad50: 756c 7420 4e6f 6e65 2e0a 2020 2020 2020  ult None..      
-0000ad60: 2020 2020 2020 7761 7665 666f 726d 7320        waveforms 
-0000ad70: 3a20 4c6f 6164 2074 6865 2077 6176 6566  : Load the wavef
-0000ad80: 6f72 6d20 2875 7020 746f 2033 3220 6461  orm (up to 32 da
-0000ad90: 7461 2070 6f69 6e74 7329 2066 6f72 2065  ta points) for e
-0000ada0: 6163 680a 2020 2020 2020 2020 2020 2020  ach.            
-0000adb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000adc0: 7370 696b 6520 7469 6d65 2e20 4465 6661  spike time. Defa
-0000add0: 756c 743a 2046 616c 7365 0a0a 2020 2020  ult: False..    
-0000ade0: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
-0000adf0: 2020 2020 2020 2020 204e 6f6e 650a 0a20           None.. 
-0000ae00: 2020 2020 2020 2027 2727 0a0a 2020 2020         '''..    
-0000ae10: 2020 2020 6966 2066 696c 656e 616d 655f      if filename_
-0000ae20: 6e74 745b 2d34 3a5d 2021 3d20 272e 6e74  ntt[-4:] != '.nt
-0000ae30: 7427 3a0a 2020 2020 2020 2020 2020 2020  t':.            
-0000ae40: 6669 6c65 6e61 6d65 5f6e 7474 202b 3d20  filename_ntt += 
-0000ae50: 272e 6e74 7427 0a20 2020 2020 2020 2069  '.ntt'.        i
-0000ae60: 6620 7365 7020 696e 2066 696c 656e 616d  f sep in filenam
-0000ae70: 655f 6e74 743a 0a20 2020 2020 2020 2020  e_ntt:.         
-0000ae80: 2020 2066 696c 656e 616d 655f 6e74 7420     filename_ntt 
-0000ae90: 3d20 6669 6c65 6e61 6d65 5f6e 7474 2e73  = filename_ntt.s
-0000aea0: 706c 6974 2873 6570 295b 2d31 5d0a 0a20  plit(sep)[-1].. 
-0000aeb0: 2020 2020 2020 2023 2065 7874 7261 6374         # extract
-0000aec0: 696e 6720 6368 616e 6e65 6c20 6964 206f  ing channel id o
-0000aed0: 6620 7265 7175 6573 7465 6420 6669 6c65  f requested file
-0000aee0: 0a20 2020 2020 2020 2063 6861 6e6e 656c  .        channel
-0000aef0: 5f69 6420 3d20 7365 6c66 2e67 6574 5f63  _id = self.get_c
-0000af00: 6861 6e6e 656c 5f69 645f 6279 5f66 696c  hannel_id_by_fil
-0000af10: 655f 6e61 6d65 2866 696c 656e 616d 655f  e_name(filename_
-0000af20: 6e74 7429 0a20 2020 2020 2020 2069 6620  ntt).        if 
-0000af30: 6368 616e 6e65 6c5f 6964 2069 7320 6e6f  channel_id is no
-0000af40: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-0000af50: 2020 2020 6368 6964 203d 2063 6861 6e6e      chid = chann
-0000af60: 656c 5f69 640a 2020 2020 2020 2020 656c  el_id.        el
-0000af70: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000af80: 2320 6966 206e 7474 2066 696c 6520 6973  # if ntt file is
-0000af90: 2065 6d70 7479 2069 7420 6973 206e 6f74   empty it is not
-0000afa0: 206c 6973 7465 6420 696e 2073 656c 662e   listed in self.
-0000afb0: 7061 7261 6d65 7465 7273 5f6e 7474 2c20  parameters_ntt, 
-0000afc0: 6275 740a 2020 2020 2020 2020 2020 2020  but.            
-0000afd0: 2320 696e 2073 656c 662e 6e74 745f 6176  # in self.ntt_av
-0000afe0: 6169 6c0a 2020 2020 2020 2020 2020 2020  ail.            
-0000aff0: 6966 2066 696c 656e 616d 655f 6e74 7420  if filename_ntt 
-0000b000: 696e 2073 656c 662e 6e74 745f 6176 6169  in self.ntt_avai
-0000b010: 6c3a 0a20 2020 2020 2020 2020 2020 2020  l:.             
-0000b020: 2020 2077 6172 6e69 6e67 732e 7761 726e     warnings.warn
-0000b030: 2827 4e65 7572 616c 796e 7849 4f20 6973  ('NeuralynxIO is
-0000b040: 2061 7474 656d 7074 696e 6720 746f 2072   attempting to r
-0000b050: 6561 6420 616e 2065 6d70 7479 2027 0a20  ead an empty '. 
-0000b060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b070: 2020 2020 2020 2020 2020 2020 2027 286e               '(n
-0000b080: 6f74 2061 7373 6f63 6961 7465 6429 206e  ot associated) n
-0000b090: 7474 2066 696c 6520 2825 7329 2e20 270a  tt file (%s). '.
-0000b0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b0b0: 2020 2020 2020 2020 2020 2020 2020 274e                'N
-0000b0c0: 6f74 206c 6f61 6469 6e67 206e 7474 2066  ot loading ntt f
-0000b0d0: 696c 652e 2720 2520 2866 696c 656e 616d  ile.' % (filenam
-0000b0e0: 655f 6e74 7429 290a 2020 2020 2020 2020  e_ntt)).        
-0000b0f0: 2020 2020 2020 2020 7265 7475 726e 0a20          return. 
-0000b100: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000b110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b120: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000b130: 7228 274e 6575 7261 6c79 6e78 494f 2069  r('NeuralynxIO i
-0000b140: 7320 6174 7465 6d70 7469 6e67 2074 6f20  s attempting to 
-0000b150: 7265 6164 2061 2066 696c 6520 270a 2020  read a file '.  
-0000b160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b170: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000b180: 6e6f 7420 6173 736f 6369 6174 6564 2074  not associated t
-0000b190: 6f20 7468 6973 2073 6573 7369 6f6e 2028  o this session (
-0000b1a0: 2573 292e 2720 2520 280a 2020 2020 2020  %s).' % (.      
-0000b1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1c0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000b1d0: 696c 656e 616d 655f 6e74 7429 290a 0a20  ilename_ntt)).. 
-0000b1e0: 2020 2020 2020 2023 2065 6e73 7572 6520         # ensure 
-0000b1f0: 6d65 616e 696e 6766 756c 2076 616c 7565  meaningful value
-0000b200: 7320 666f 7220 7265 7175 6573 7465 6420  s for requested 
-0000b210: 7374 6172 7420 616e 6420 7374 6f70 2074  start and stop t
-0000b220: 696d 6573 0a20 2020 2020 2020 2023 2069  imes.        # i
-0000b230: 6e20 6361 7365 2074 696d 6520 6973 2070  n case time is p
-0000b240: 726f 7669 6465 6420 696e 2073 616d 706c  rovided in sampl
-0000b250: 6573 3a20 7472 616e 7366 6f72 6d20 746f  es: transform to
-0000b260: 2061 6273 6f6c 7574 6520 7469 6d65 2075   absolute time u
-0000b270: 6e69 7473 0a20 2020 2020 2020 2023 206e  nits.        # n
-0000b280: 6373 2073 616d 706c 696e 6720 7261 7465  cs sampling rate
-0000b290: 2069 7320 6265 7374 2067 7565 7373 2069   is best guess i
-0000b2a0: 6620 7468 6572 6520 6973 206e 6f20 6578  f there is no ex
-0000b2b0: 706c 6963 6974 2073 616d 706c 696e 670a  plicit sampling.
-0000b2c0: 2020 2020 2020 2020 2320 7261 7465 2067          # rate g
-0000b2d0: 6976 656e 2066 6f72 206e 7474 2076 616c  iven for ntt val
-0000b2e0: 7565 732e 0a20 2020 2020 2020 2069 6620  ues..        if 
-0000b2f0: 2773 616d 706c 696e 675f 7261 7465 2720  'sampling_rate' 
-0000b300: 696e 2073 656c 662e 7061 7261 6d65 7465  in self.paramete
-0000b310: 7273 5f6e 7474 5b63 6869 645d 3a0a 2020  rs_ntt[chid]:.  
-0000b320: 2020 2020 2020 2020 2020 7372 203d 2073            sr = s
-0000b330: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-0000b340: 7474 5b63 6869 645d 5b27 7361 6d70 6c69  tt[chid]['sampli
-0000b350: 6e67 5f72 6174 6527 5d0a 2020 2020 2020  ng_rate'].      
-0000b360: 2020 656c 6966 2063 6869 6420 696e 2073    elif chid in s
-0000b370: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-0000b380: 6373 2061 6e64 2027 7361 6d70 6c69 6e67  cs and 'sampling
-0000b390: 5f72 6174 6527 2069 6e20 5c0a 2020 2020  _rate' in \.    
-0000b3a0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000b3b0: 2e70 6172 616d 6574 6572 735f 6e63 735b  .parameters_ncs[
-0000b3c0: 6368 6964 5d3a 0a20 2020 2020 2020 2020  chid]:.         
-0000b3d0: 2020 2073 7220 3d20 7365 6c66 2e70 6172     sr = self.par
-0000b3e0: 616d 6574 6572 735f 6e63 735b 6368 6964  ameters_ncs[chid
-0000b3f0: 5d5b 2773 616d 706c 696e 675f 7261 7465  ]['sampling_rate
-0000b400: 275d 0a20 2020 2020 2020 2065 6c73 653a  '].        else:
-0000b410: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-0000b420: 7365 2056 616c 7565 4572 726f 7228 0a20  se ValueError(. 
-0000b430: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000b440: 4e6f 2073 616d 706c 696e 6720 7261 7465  No sampling rate
-0000b450: 2070 7265 7365 6e74 2066 6f72 2063 6861   present for cha
-0000b460: 6e6e 656c 2069 6420 2569 2069 6e20 6e74  nnel id %i in nt
-0000b470: 7420 6669 6c65 2027 0a20 2020 2020 2020  t file '.       
-0000b480: 2020 2020 2020 2020 2027 2573 2e20 270a           '%s. '.
-0000b490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4a0: 2743 6f75 6c64 2061 6c73 6f20 6e6f 7420  'Could also not 
-0000b4b0: 6669 6e64 2074 6865 2073 616d 706c 696e  find the samplin
-0000b4c0: 6720 7261 7465 206f 6620 7468 6520 7265  g rate of the re
-0000b4d0: 7370 6563 7469 7665 2027 0a20 2020 2020  spective '.     
-0000b4e0: 2020 2020 2020 2020 2020 2027 6e63 7320             'ncs 
-0000b4f0: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
-0000b500: 2020 2766 696c 652e 2720 2520 280a 2020    'file.' % (.  
-0000b510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b520: 2020 6368 6964 2c20 6669 6c65 6e61 6d65    chid, filename
-0000b530: 5f6e 7474 2929 0a0a 2020 2020 2020 2020  _ntt))..        
-0000b540: 6966 2069 7369 6e73 7461 6e63 6528 745f  if isinstance(t_
-0000b550: 7374 6172 742c 2069 6e74 293a 0a20 2020  start, int):.   
-0000b560: 2020 2020 2020 2020 2074 5f73 7461 7274           t_start
-0000b570: 203d 2074 5f73 7461 7274 202f 2073 720a   = t_start / sr.
-0000b580: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-0000b590: 7461 6e63 6528 745f 7374 6f70 2c20 696e  tance(t_stop, in
-0000b5a0: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
-0000b5b0: 745f 7374 6f70 203d 2074 5f73 746f 7020  t_stop = t_stop 
-0000b5c0: 2f20 7372 0a0a 2020 2020 2020 2020 2320  / sr..        # 
-0000b5d0: 2b20 7265 7363 616c 696e 6720 746f 2067  + rescaling to g
-0000b5e0: 6c6f 6261 6c20 7265 636f 7264 696e 6720  lobal recording 
-0000b5f0: 7374 6172 7420 2866 6972 7374 2073 616d  start (first sam
-0000b600: 706c 6520 696e 2061 6e79 0a20 2020 2020  ple in any.     
-0000b610: 2020 2023 2072 6563 6f72 6469 6e67 2066     # recording f
-0000b620: 696c 6529 0a20 2020 2020 2020 2069 6620  ile).        if 
-0000b630: 745f 7374 6172 7420 6973 204e 6f6e 6520  t_start is None 
-0000b640: 6f72 2074 5f73 7461 7274 203c 2028 0a20  or t_start < (. 
-0000b650: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000b660: 7061 7261 6d65 7465 7273 5f6e 7474 5b63  parameters_ntt[c
-0000b670: 6869 645d 5b27 745f 6669 7273 7427 5d0a  hid]['t_first'].
-0000b680: 2020 2020 2020 2020 2020 2020 2d20 7365              - se
-0000b690: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
-0000b6a0: 6f62 616c 5b0a 2020 2020 2020 2020 2020  obal[.          
-0000b6b0: 2020 2020 2020 2774 5f73 7461 7274 275d        't_start']
-0000b6c0: 293a 0a20 2020 2020 2020 2020 2020 2074  ):.            t
-0000b6d0: 5f73 7461 7274 203d 2028 0a20 2020 2020  _start = (.     
-0000b6e0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000b6f0: 7061 7261 6d65 7465 7273 5f6e 7474 5b63  parameters_ntt[c
-0000b700: 6869 645d 5b27 745f 6669 7273 7427 5d20  hid]['t_first'] 
-0000b710: 2d20 7365 6c66 2e70 6172 616d 6574 6572  - self.parameter
-0000b720: 735f 676c 6f62 616c 5b0a 2020 2020 2020  s_global[.      
-0000b730: 2020 2020 2020 2020 2020 2020 2020 2774                't
-0000b740: 5f73 7461 7274 275d 290a 0a20 2020 2020  _start'])..     
-0000b750: 2020 2069 6620 745f 7374 6172 7420 3e20     if t_start > 
-0000b760: 280a 2020 2020 2020 2020 2020 2020 7365  (.            se
-0000b770: 6c66 2e70 6172 616d 6574 6572 735f 6e74  lf.parameters_nt
-0000b780: 745b 6368 6964 5d5b 2774 5f6c 6173 7427  t[chid]['t_last'
-0000b790: 5d0a 2020 2020 2020 2020 2020 2020 2d20  ].            - 
-0000b7a0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-0000b7b0: 676c 6f62 616c 5b0a 2020 2020 2020 2020  global[.        
-0000b7c0: 2020 2020 2020 2020 2774 5f73 7461 7274          't_start
-0000b7d0: 275d 293a 0a20 2020 2020 2020 2020 2020  ']):.           
-0000b7e0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000b7f0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-0000b800: 2020 2027 5265 7175 6573 7465 6420 7469     'Requested ti
-0000b810: 6d65 7320 7769 6e64 6f77 2028 2573 2074  mes window (%s t
-0000b820: 6f20 2573 2920 6973 206c 6174 6572 2074  o %s) is later t
-0000b830: 6861 6e20 6461 7461 2061 7265 2027 0a20  han data are '. 
-0000b840: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000b850: 7265 636f 7264 6564 2028 745f 7374 6f70  recorded (t_stop
-0000b860: 203d 2025 7329 2027 0a20 2020 2020 2020   = %s) '.       
-0000b870: 2020 2020 2020 2020 2027 666f 7220 6669           'for fi
-0000b880: 6c65 2025 732e 2720 2520 2874 5f73 7461  le %s.' % (t_sta
-0000b890: 7274 2c20 745f 7374 6f70 2c0a 2020 2020  rt, t_stop,.    
-0000b8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b8b0: 2020 2020 2020 2020 2020 2020 2020 2873                (s
-0000b8c0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-0000b8d0: 7474 5b63 6869 645d 5b27 745f 6c61 7374  tt[chid]['t_last
-0000b8e0: 275d 0a20 2020 2020 2020 2020 2020 2020  '].             
-0000b8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b900: 2020 2020 2020 2d20 7365 6c66 2e70 6172        - self.par
-0000b910: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
-0000b920: 745f 7374 6172 7427 5d29 2c0a 2020 2020  t_start']),.    
-0000b930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b940: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-0000b950: 6c65 6e61 6d65 5f6e 7474 2929 0a0a 2020  lename_ntt))..  
-0000b960: 2020 2020 2020 6966 2074 5f73 746f 7020        if t_stop 
-0000b970: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0000b980: 2020 2020 2074 5f73 746f 7020 3d20 2873       t_stop = (s
-0000b990: 7973 2e6d 6178 7369 7a65 2920 2a20 7365  ys.maxsize) * se
-0000b9a0: 6c66 2e6e 7474 5f74 696d 655f 756e 6974  lf.ntt_time_unit
-0000b9b0: 0a20 2020 2020 2020 2069 6620 745f 7374  .        if t_st
-0000b9c0: 6f70 2069 7320 4e6f 6e65 206f 7220 745f  op is None or t_
-0000b9d0: 7374 6f70 203e 2028 0a20 2020 2020 2020  stop > (.       
-0000b9e0: 2020 2020 2073 656c 662e 7061 7261 6d65       self.parame
-0000b9f0: 7465 7273 5f6e 7474 5b63 6869 645d 5b27  ters_ntt[chid]['
-0000ba00: 745f 6c61 7374 275d 0a20 2020 2020 2020  t_last'].       
-0000ba10: 2020 2020 202d 2073 656c 662e 7061 7261       - self.para
-0000ba20: 6d65 7465 7273 5f67 6c6f 6261 6c5b 0a20  meters_global[. 
-0000ba30: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000ba40: 745f 7374 6172 7427 5d29 3a0a 2020 2020  t_start']):.    
-0000ba50: 2020 2020 2020 2020 745f 7374 6f70 203d          t_stop =
-0000ba60: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-0000ba70: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
-0000ba80: 7273 5f6e 7474 5b63 6869 645d 5b27 745f  rs_ntt[chid]['t_
-0000ba90: 6c61 7374 275d 202d 2073 656c 662e 7061  last'] - self.pa
-0000baa0: 7261 6d65 7465 7273 5f67 6c6f 6261 6c5b  rameters_global[
-0000bab0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bac0: 2020 2020 2027 745f 7374 6172 7427 5d29       't_start'])
-0000bad0: 0a0a 2020 2020 2020 2020 6966 2074 5f73  ..        if t_s
-0000bae0: 746f 7020 3c20 280a 2020 2020 2020 2020  top < (.        
-0000baf0: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
-0000bb00: 6572 735f 6e74 745b 6368 6964 5d5b 2774  ers_ntt[chid]['t
-0000bb10: 5f66 6972 7374 275d 0a20 2020 2020 2020  _first'].       
-0000bb20: 2020 2020 202d 2073 656c 662e 7061 7261       - self.para
-0000bb30: 6d65 7465 7273 5f67 6c6f 6261 6c5b 0a20  meters_global[. 
-0000bb40: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000bb50: 745f 7374 6172 7427 5d29 3a0a 2020 2020  t_start']):.    
-0000bb60: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-0000bb70: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
-0000bb80: 2020 2020 2020 2020 2020 2752 6571 7565            'Reque
-0000bb90: 7374 6564 2074 696d 6573 2077 696e 646f  sted times windo
-0000bba0: 7720 2825 7320 746f 2025 7329 2069 7320  w (%s to %s) is 
-0000bbb0: 6561 726c 6965 7220 7468 616e 2064 6174  earlier than dat
-0000bbc0: 6120 270a 2020 2020 2020 2020 2020 2020  a '.            
-0000bbd0: 2020 2020 2761 7265 2027 0a20 2020 2020      'are '.     
-0000bbe0: 2020 2020 2020 2020 2020 2027 7265 636f             'reco
-0000bbf0: 7264 6564 2028 745f 7374 6172 7420 3d20  rded (t_start = 
-0000bc00: 2573 2920 270a 2020 2020 2020 2020 2020  %s) '.          
-0000bc10: 2020 2020 2020 2766 6f72 2066 696c 6520        'for file 
-0000bc20: 2573 2e27 2025 2028 745f 7374 6172 742c  %s.' % (t_start,
-0000bc30: 2074 5f73 746f 702c 0a20 2020 2020 2020   t_stop,.       
-0000bc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc50: 2020 2020 2020 2020 2020 2028 7365 6c66             (self
-0000bc60: 2e70 6172 616d 6574 6572 735f 6e74 745b  .parameters_ntt[
-0000bc70: 6368 6964 5d5b 2774 5f66 6972 7374 275d  chid]['t_first']
-0000bc80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bca0: 2020 2020 2d20 7365 6c66 2e70 6172 616d      - self.param
-0000bcb0: 6574 6572 735f 676c 6f62 616c 5b27 745f  eters_global['t_
-0000bcc0: 7374 6172 7427 5d29 2c0a 2020 2020 2020  start']),.      
-0000bcd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bce0: 2020 2020 2020 2020 2020 2020 6669 6c65              file
-0000bcf0: 6e61 6d65 5f6e 7474 2929 0a0a 2020 2020  name_ntt))..    
-0000bd00: 2020 2020 6966 2074 5f73 7461 7274 203e      if t_start >
-0000bd10: 3d20 745f 7374 6f70 3a0a 2020 2020 2020  = t_stop:.      
-0000bd20: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-0000bd30: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
-0000bd40: 2020 2020 2020 2020 2752 6571 7565 7374          'Request
-0000bd50: 6564 2073 7461 7274 2074 696d 6520 2825  ed start time (%
-0000bd60: 7329 2069 7320 6c61 7465 7220 7468 616e  s) is later than
-0000bd70: 202f 2065 7175 616c 2074 6f20 7374 6f70   / equal to stop
-0000bd80: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-0000bd90: 2020 2027 7469 6d65 2027 0a20 2020 2020     'time '.     
-0000bda0: 2020 2020 2020 2020 2020 2027 2825 7329             '(%s)
-0000bdb0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-0000bdc0: 2020 2027 666f 7220 6669 6c65 2025 732e     'for file %s.
-0000bdd0: 2720 2520 2874 5f73 7461 7274 2c20 745f  ' % (t_start, t_
-0000bde0: 7374 6f70 2c20 6669 6c65 6e61 6d65 5f6e  stop, filename_n
-0000bdf0: 7474 2929 0a0a 2020 2020 2020 2020 2320  tt))..        # 
-0000be00: 7265 6164 696e 6720 6461 7461 0a20 2020  reading data.   
-0000be10: 2020 2020 205b 7469 6d65 7374 616d 7073       [timestamps
-0000be20: 2c20 6368 616e 6e65 6c5f 6964 732c 2063  , channel_ids, c
-0000be30: 656c 6c5f 6e75 6d62 6572 732c 2066 6561  ell_numbers, fea
-0000be40: 7475 7265 732c 0a20 2020 2020 2020 2020  tures,.         
-0000be50: 6461 7461 5f70 6f69 6e74 735d 203d 2073  data_points] = s
-0000be60: 656c 662e 5f5f 6d6d 6170 5f6e 7474 5f70  elf.__mmap_ntt_p
-0000be70: 6163 6b65 7473 2866 696c 656e 616d 655f  ackets(filename_
-0000be80: 6e74 7429 0a0a 2020 2020 2020 2020 2320  ntt)..        # 
-0000be90: 544f 444f 3a20 5768 656e 206e 7474 2061  TODO: When ntt a
-0000bea0: 7661 696c 6162 6c65 3a20 496d 706c 656d  vailable: Implem
-0000beb0: 656e 7420 3120 5265 636f 7264 696e 6743  ent 1 RecordingC
-0000bec0: 6861 6e6e 656c 4772 6f75 7020 7065 720a  hannelGroup per.
-0000bed0: 2020 2020 2020 2020 2320 5465 7472 6f64          # Tetrod
-0000bee0: 652c 2073 7563 6820 7468 6174 2065 6163  e, such that eac
-0000bef0: 6820 656c 6563 7472 6f64 6520 6765 7473  h electrode gets
-0000bf00: 2069 7473 206f 776e 2072 6563 6f72 6469   its own recordi
-0000bf10: 6e67 2063 6861 6e6e 656c 0a0a 2020 2020  ng channel..    
-0000bf20: 2020 2020 2320 6c6f 6164 2061 6c6c 2075      # load all u
-0000bf30: 6e69 7473 2061 7661 696c 6162 6c65 2069  nits available i
-0000bf40: 6620 756e 6974 733d 3d5b 5d0a 2020 2020  f units==[].    
-0000bf50: 2020 2020 6966 2075 6e69 745f 6c69 7374      if unit_list
-0000bf60: 203d 3d20 5b5d 206f 7220 756e 6974 5f6c   == [] or unit_l
-0000bf70: 6973 7420 6973 204e 6f6e 653a 0a20 2020  ist is None:.   
-0000bf80: 2020 2020 2020 2020 2075 6e69 745f 6c69           unit_li
-0000bf90: 7374 203d 206e 702e 756e 6971 7565 2863  st = np.unique(c
-0000bfa0: 656c 6c5f 6e75 6d62 6572 7329 0a20 2020  ell_numbers).   
-0000bfb0: 2020 2020 2065 6c69 6620 6e6f 7420 616e       elif not an
-0000bfc0: 7928 5b75 2069 6e20 6365 6c6c 5f6e 756d  y([u in cell_num
-0000bfd0: 6265 7273 2066 6f72 2075 2069 6e20 756e  bers for u in un
-0000bfe0: 6974 5f6c 6973 745d 293a 0a20 2020 2020  it_list]):.     
-0000bff0: 2020 2020 2020 2073 656c 662e 5f64 6961         self._dia
-0000c000: 676e 6f73 7469 635f 7072 696e 7428 0a20  gnostic_print(. 
-0000c010: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000c020: 4e6f 6e65 206f 6620 7468 6520 7265 7175  None of the requ
-0000c030: 6573 7465 6420 756e 6974 2069 6473 2028  ested unit ids (
-0000c040: 2573 2920 7072 6573 656e 7420 270a 2020  %s) present '.  
-0000c050: 2020 2020 2020 2020 2020 2020 2020 2769                'i
-0000c060: 6e20 6e74 7420 6669 6c65 2025 7320 2863  n ntt file %s (c
-0000c070: 6f6e 7461 696e 7320 756e 6974 7320 2573  ontains units %s
-0000c080: 2927 2025 2028 0a20 2020 2020 2020 2020  )' % (.         
-0000c090: 2020 2020 2020 2020 2020 2075 6e69 745f             unit_
-0000c0a0: 6c69 7374 2c20 6669 6c65 6e61 6d65 5f6e  list, filename_n
-0000c0b0: 7474 2c20 6e70 2e75 6e69 7175 6528 6365  tt, np.unique(ce
-0000c0c0: 6c6c 5f6e 756d 6265 7273 2929 290a 0a20  ll_numbers))).. 
-0000c0d0: 2020 2020 2020 2023 206c 6f61 6469 6e67         # loading
-0000c0e0: 2064 6174 6120 666f 7220 6561 6368 2075   data for each u
-0000c0f0: 6e69 7420 616e 6420 6765 6e65 7261 7469  nit and generati
-0000c100: 6e67 2073 7069 6b65 7472 6169 6e0a 2020  ng spiketrain.  
-0000c110: 2020 2020 2020 666f 7220 756e 6974 5f69        for unit_i
-0000c120: 2069 6e20 756e 6974 5f6c 6973 743a 0a20   in unit_list:. 
-0000c130: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-0000c140: 7420 6c61 7a79 3a0a 2020 2020 2020 2020  t lazy:.        
-0000c150: 2020 2020 2020 2020 2320 4578 7472 6163          # Extrac
-0000c160: 7420 616c 6c20 7469 6d65 2073 7461 6d70  t all time stamp
-0000c170: 7320 6f66 2074 6861 7420 6e65 7572 6f6e  s of that neuron
-0000c180: 206f 6e20 7468 6174 2065 6c65 6374 726f   on that electro
-0000c190: 6465 0a20 2020 2020 2020 2020 2020 2020  de.             
-0000c1a0: 2020 206d 6173 6b20 3d20 6e70 2e77 6865     mask = np.whe
-0000c1b0: 7265 2863 656c 6c5f 6e75 6d62 6572 7320  re(cell_numbers 
-0000c1c0: 3d3d 2075 6e69 745f 6929 5b30 5d0a 2020  == unit_i)[0].  
-0000c1d0: 2020 2020 2020 2020 2020 2020 2020 7370                sp
-0000c1e0: 696b 655f 7469 6d65 7320 3d20 7469 6d65  ike_times = time
-0000c1f0: 7374 616d 7073 5b6d 6173 6b5d 202a 2073  stamps[mask] * s
-0000c200: 656c 662e 6e74 745f 7469 6d65 5f75 6e69  elf.ntt_time_uni
-0000c210: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-0000c220: 2020 7370 696b 655f 7469 6d65 7320 3d20    spike_times = 
-0000c230: 7370 696b 655f 7469 6d65 7320 2d20 7365  spike_times - se
-0000c240: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
-0000c250: 6f62 616c 5b27 745f 7374 6172 7427 5d0a  obal['t_start'].
-0000c260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c270: 7370 696b 655f 7469 6d65 7320 3d20 7370  spike_times = sp
-0000c280: 696b 655f 7469 6d65 735b 6e70 2e77 6865  ike_times[np.whe
-0000c290: 7265 280a 2020 2020 2020 2020 2020 2020  re(.            
-0000c2a0: 2020 2020 2020 2020 6e70 2e6c 6f67 6963          np.logic
-0000c2b0: 616c 5f61 6e64 2873 7069 6b65 5f74 696d  al_and(spike_tim
-0000c2c0: 6573 203e 3d20 745f 7374 6172 742c 0a20  es >= t_start,. 
-0000c2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c2f0: 2020 7370 696b 655f 7469 6d65 7320 3c20    spike_times < 
-0000c300: 745f 7374 6f70 2929 5d0a 2020 2020 2020  t_stop))].      
-0000c310: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000c320: 2020 2020 2020 2020 2020 2020 7370 696b              spik
-0000c330: 655f 7469 6d65 7320 3d20 7071 2e51 7561  e_times = pq.Qua
-0000c340: 6e74 6974 7928 5b5d 2c20 756e 6974 733d  ntity([], units=
-0000c350: 7365 6c66 2e6e 7474 5f74 696d 655f 756e  self.ntt_time_un
-0000c360: 6974 290a 0a20 2020 2020 2020 2020 2020  it)..           
-0000c370: 2023 2043 7265 6174 6520 5370 696b 6554   # Create SpikeT
-0000c380: 7261 696e 206f 626a 6563 740a 2020 2020  rain object.    
-0000c390: 2020 2020 2020 2020 7374 203d 2053 7069          st = Spi
-0000c3a0: 6b65 5472 6169 6e28 7469 6d65 733d 7370  keTrain(times=sp
-0000c3b0: 696b 655f 7469 6d65 732c 0a20 2020 2020  ike_times,.     
-0000c3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c3d0: 2020 2020 2020 2074 5f73 7461 7274 3d74         t_start=t
-0000c3e0: 5f73 7461 7274 2c0a 2020 2020 2020 2020  _start,.        
-0000c3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c400: 2020 2020 745f 7374 6f70 3d74 5f73 746f      t_stop=t_sto
-0000c410: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-0000c420: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000c430: 616d 706c 696e 675f 7261 7465 3d73 656c  ampling_rate=sel
-0000c440: 662e 7061 7261 6d65 7465 7273 5f6e 6373  f.parameters_ncs
-0000c450: 5b63 6869 645d 5b0a 2020 2020 2020 2020  [chid][.        
+0000a600: 2020 2073 616d 706c 696e 675f 7261 7465     sampling_rate
+0000a610: 3d73 656c 662e 7061 7261 6d65 7465 7273  =self.parameters
+0000a620: 5f6e 6373 5b63 6869 645d 5b0a 2020 2020  _ncs[chid][.    
+0000a630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a640: 2020 2020 2020 2020 2020 2020 2773 616d              'sam
+0000a650: 706c 696e 675f 7261 7465 275d 2c0a 2020  pling_rate'],.  
+0000a660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a670: 2020 2020 2020 2020 2020 6e61 6d65 3d22            name="
+0000a680: 4368 616e 6e65 6c20 2569 2c20 556e 6974  Channel %i, Unit
+0000a690: 2025 6922 2025 2028 6368 6964 2c20 756e   %i" % (chid, un
+0000a6a0: 6974 5f69 292c 0a20 2020 2020 2020 2020  it_i),.         
+0000a6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a6c0: 2020 2066 696c 655f 6f72 6967 696e 3d66     file_origin=f
+0000a6d0: 696c 656e 616d 655f 6e73 652c 0a20 2020  ilename_nse,.   
+0000a6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a6f0: 2020 2020 2020 2020 2075 6e69 745f 6964           unit_id
+0000a700: 3d75 6e69 745f 692c 0a20 2020 2020 2020  =unit_i,.       
+0000a710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a720: 2020 2020 2063 6861 6e6e 656c 5f69 643d       channel_id=
+0000a730: 6368 6964 290a 0a20 2020 2020 2020 2020  chid)..         
+0000a740: 2020 2069 6620 7761 7665 666f 726d 7320     if waveforms 
+0000a750: 616e 6420 6e6f 7420 6c61 7a79 3a0a 2020  and not lazy:.  
+0000a760: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000a770: 436f 6c6c 6563 7420 616c 6c20 7761 7665  Collect all wave
+0000a780: 666f 726d 7320 6f66 2074 6865 2073 7065  forms of the spe
+0000a790: 6369 6669 6320 756e 6974 0a20 2020 2020  cific unit.     
+0000a7a0: 2020 2020 2020 2020 2020 2023 2046 6f72             # For
+0000a7b0: 2063 6f6d 7075 7461 7469 6f6e 616c 2072   computational r
+0000a7c0: 6561 736f 6e73 3a20 6e6f 2075 6e69 7473  easons: no units
+0000a7d0: 2c20 6e6f 2074 696d 6520 6178 6973 0a20  , no time axis. 
+0000a7e0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000a7f0: 742e 7761 7665 666f 726d 7320 3d20 6461  t.waveforms = da
+0000a800: 7461 5f70 6f69 6e74 735b 756e 6974 5f6d  ta_points[unit_m
+0000a810: 6173 6b5d 5b74 696d 655f 6d61 736b 5d0a  ask][time_mask].
+0000a820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a830: 2320 544f 444f 3a20 4164 6420 756e 6974  # TODO: Add unit
+0000a840: 7320 746f 2077 6176 6566 6f72 6d73 2028  s to waveforms (
+0000a850: 7071 2e75 563f 2920 616e 6420 6164 6420  pq.uV?) and add 
+0000a860: 616e 6e6f 7461 7469 6f6e 0a20 2020 2020  annotation.     
+0000a870: 2020 2020 2020 2020 2020 2023 206c 6566             # lef
+0000a880: 745f 7377 6565 7020 3d20 7820 2a20 7071  t_sweep = x * pq
+0000a890: 2e6d 7320 696e 6469 6361 7469 6e67 2077  .ms indicating w
+0000a8a0: 6865 6e20 7468 7265 7368 6f6c 6420 6372  hen threshold cr
+0000a8b0: 6f73 7369 6e67 0a20 2020 2020 2020 2020  ossing.         
+0000a8c0: 2020 2020 2020 2023 206f 6363 7572 7265         # occurre
+0000a8d0: 6420 696e 2077 6176 6566 6f72 6d0a 0a20  d in waveform.. 
+0000a8e0: 2020 2020 2020 2020 2020 2073 742e 616e             st.an
+0000a8f0: 6e6f 7461 7469 6f6e 732e 7570 6461 7465  notations.update
+0000a900: 2873 656c 662e 7061 7261 6d65 7465 7273  (self.parameters
+0000a910: 5f6e 7365 5b63 6869 645d 290a 2020 2020  _nse[chid]).    
+0000a920: 2020 2020 2020 2020 7374 2e61 6e6e 6f74          st.annot
+0000a930: 6174 696f 6e73 5b27 656c 6563 7472 6f64  ations['electrod
+0000a940: 655f 6964 275d 203d 2063 6869 640a 2020  e_id'] = chid.  
+0000a950: 2020 2020 2020 2020 2020 2320 5468 6973            # This
+0000a960: 2061 6e6e 6f74 6174 696f 6e73 2069 7320   annotations is 
+0000a970: 6e65 6365 7373 6172 7920 666f 7220 6175  necessary for au
+0000a980: 746f 6d61 7469 6320 6765 6e65 7261 7469  tomatic generati
+0000a990: 6f6e 206f 660a 2020 2020 2020 2020 2020  on of.          
+0000a9a0: 2020 2320 7265 636f 7264 696e 6763 6861    # recordingcha
+0000a9b0: 6e6e 656c 730a 2020 2020 2020 2020 2020  nnels.          
+0000a9c0: 2020 7374 2e61 6e6e 6f74 6174 696f 6e73    st.annotations
+0000a9d0: 5b27 6368 616e 6e65 6c5f 696e 6465 7827  ['channel_index'
+0000a9e0: 5d20 3d20 6368 6964 0a0a 2020 2020 2020  ] = chid..      
+0000a9f0: 2020 2020 2020 7365 672e 7370 696b 6574        seg.spiket
+0000aa00: 7261 696e 732e 6170 7065 6e64 2873 7429  rains.append(st)
+0000aa10: 0a0a 2020 2020 6465 6620 7265 6164 5f6e  ..    def read_n
+0000aa20: 7474 2873 656c 662c 2066 696c 656e 616d  tt(self, filenam
+0000aa30: 655f 6e74 742c 2073 6567 2c20 6c61 7a79  e_ntt, seg, lazy
+0000aa40: 3d46 616c 7365 2c20 6361 7363 6164 653d  =False, cascade=
+0000aa50: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+0000aa60: 2020 2020 2020 2074 5f73 7461 7274 3d4e         t_start=N
+0000aa70: 6f6e 652c 2074 5f73 746f 703d 4e6f 6e65  one, t_stop=None
+0000aa80: 2c20 756e 6974 5f6c 6973 743d 4e6f 6e65  , unit_list=None
+0000aa90: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000aaa0: 2020 2077 6176 6566 6f72 6d73 3d46 616c     waveforms=Fal
+0000aab0: 7365 293a 0a20 2020 2020 2020 2027 2727  se):.        '''
+0000aac0: 0a20 2020 2020 2020 2052 6561 6473 206e  .        Reads n
+0000aad0: 7474 2066 696c 6520 616e 6420 6174 7461  tt file and atta
+0000aae0: 6368 6573 2063 6f6e 7465 6e74 2061 7320  ches content as 
+0000aaf0: 7370 696b 6520 7472 6169 6e20 746f 2070  spike train to p
+0000ab00: 726f 7669 6465 6420 6e65 6f0a 2020 2020  rovided neo.    
+0000ab10: 2020 2020 7365 676d 656e 742e 0a0a 2020      segment...  
+0000ab20: 2020 2020 2020 4172 6775 6d65 6e74 733a        Arguments:
+0000ab30: 0a20 2020 2020 2020 2020 2020 2066 696c  .            fil
+0000ab40: 656e 616d 655f 6e74 7420 3a20 4e61 6d65  ename_ntt : Name
+0000ab50: 206f 6620 7468 6520 2e6e 7474 2066 696c   of the .ntt fil
+0000ab60: 6520 746f 2062 6520 6c6f 6164 6564 2e0a  e to be loaded..
+0000ab70: 2020 2020 2020 2020 2020 2020 7365 6720              seg 
+0000ab80: 3a20 4e65 6f20 5365 676d 656e 742c 2074  : Neo Segment, t
+0000ab90: 6f20 7768 6963 6820 7468 6520 5370 696b  o which the Spik
+0000aba0: 6574 7261 696e 2063 6f6e 7461 696e 696e  etrain containin
+0000abb0: 6720 7468 6520 6461 7461 0a20 2020 2020  g the data.     
+0000abc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abd0: 2020 2020 2020 2077 696c 6c20 6265 2061         will be a
+0000abe0: 7474 6163 6865 642e 0a20 2020 2020 2020  ttached..       
+0000abf0: 2020 2020 206c 617a 7920 3a20 506f 7374       lazy : Post
+0000ac00: 706f 6e65 2061 6374 7561 6c20 7265 6164  pone actual read
+0000ac10: 696e 6720 6f66 2074 6865 2064 6174 612e  ing of the data.
+0000ac20: 2049 6e73 7465 6164 2070 726f 7669 6465   Instead provide
+0000ac30: 2061 2064 756d 6d79 0a20 2020 2020 2020   a dummy.       
+0000ac40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac50: 2020 2020 2053 7069 6b65 5472 6169 6e2e       SpikeTrain.
+0000ac60: 2044 6566 6175 6c74 2027 4661 6c73 6527   Default 'False'
+0000ac70: 2e0a 2020 2020 2020 2020 2020 2020 6361  ..            ca
+0000ac80: 7363 6164 6520 3a20 4e6f 7420 7573 6564  scade : Not used
+0000ac90: 2069 6e20 7468 6973 2063 6f6e 7465 7874   in this context
+0000aca0: 2e20 4465 6661 756c 743a 2027 5472 7565  . Default: 'True
+0000acb0: 272e 0a20 2020 2020 2020 2020 2020 2074  '..            t
+0000acc0: 5f73 7461 7274 203a 2074 696d 6520 2871  _start : time (q
+0000acd0: 7561 6e74 6974 7929 2074 6861 7420 7468  uantity) that th
+0000ace0: 6520 5370 696b 6554 7261 696e 2062 6567  e SpikeTrain beg
+0000acf0: 696e 732e 2044 6566 6175 6c74 204e 6f6e  ins. Default Non
+0000ad00: 652e 0a20 2020 2020 2020 2020 2020 2074  e..            t
+0000ad10: 5f73 746f 7020 3a20 7469 6d65 2028 7175  _stop : time (qu
+0000ad20: 616e 7469 7479 2920 7468 6174 2074 6865  antity) that the
+0000ad30: 2053 7069 6b65 5472 6169 6e20 656e 6473   SpikeTrain ends
+0000ad40: 2e20 4465 6661 756c 7420 4e6f 6e65 2e0a  . Default None..
+0000ad50: 2020 2020 2020 2020 2020 2020 756e 6974              unit
+0000ad60: 5f6c 6973 7420 3a20 756e 6974 2069 6473  _list : unit ids
+0000ad70: 2074 6f20 6265 206c 6f61 6465 642e 2049   to be loaded. I
+0000ad80: 6620 5b5d 206f 7220 4e6f 6e65 2061 6c6c  f [] or None all
+0000ad90: 2075 6e69 7473 2061 7265 0a20 2020 2020   units are.     
+0000ada0: 2020 2020 2020 206c 6f61 6465 642e 0a20         loaded.. 
+0000adb0: 2020 2020 2020 2020 2020 2044 6566 6175             Defau
+0000adc0: 6c74 204e 6f6e 652e 0a20 2020 2020 2020  lt None..       
+0000add0: 2020 2020 2077 6176 6566 6f72 6d73 203a       waveforms :
+0000ade0: 204c 6f61 6420 7468 6520 7761 7665 666f   Load the wavefo
+0000adf0: 726d 2028 7570 2074 6f20 3332 2064 6174  rm (up to 32 dat
+0000ae00: 6120 706f 696e 7473 2920 666f 7220 6561  a points) for ea
+0000ae10: 6368 0a20 2020 2020 2020 2020 2020 2020  ch.             
+0000ae20: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000ae30: 7069 6b65 2074 696d 652e 2044 6566 6175  pike time. Defau
+0000ae40: 6c74 3a20 4661 6c73 650a 0a20 2020 2020  lt: False..     
+0000ae50: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
+0000ae60: 2020 2020 2020 2020 4e6f 6e65 0a0a 2020          None..  
+0000ae70: 2020 2020 2020 2727 270a 0a20 2020 2020        '''..     
+0000ae80: 2020 2069 6620 6669 6c65 6e61 6d65 5f6e     if filename_n
+0000ae90: 7474 5b2d 343a 5d20 213d 2027 2e6e 7474  tt[-4:] != '.ntt
+0000aea0: 273a 0a20 2020 2020 2020 2020 2020 2066  ':.            f
+0000aeb0: 696c 656e 616d 655f 6e74 7420 2b3d 2027  ilename_ntt += '
+0000aec0: 2e6e 7474 270a 2020 2020 2020 2020 6966  .ntt'.        if
+0000aed0: 2073 6570 2069 6e20 6669 6c65 6e61 6d65   sep in filename
+0000aee0: 5f6e 7474 3a0a 2020 2020 2020 2020 2020  _ntt:.          
+0000aef0: 2020 6669 6c65 6e61 6d65 5f6e 7474 203d    filename_ntt =
+0000af00: 2066 696c 656e 616d 655f 6e74 742e 7370   filename_ntt.sp
+0000af10: 6c69 7428 7365 7029 5b2d 315d 0a0a 2020  lit(sep)[-1]..  
+0000af20: 2020 2020 2020 2320 6578 7472 6163 7469        # extracti
+0000af30: 6e67 2063 6861 6e6e 656c 2069 6420 6f66  ng channel id of
+0000af40: 2072 6571 7565 7374 6564 2066 696c 650a   requested file.
+0000af50: 2020 2020 2020 2020 6368 616e 6e65 6c5f          channel_
+0000af60: 6964 203d 2073 656c 662e 6765 745f 6368  id = self.get_ch
+0000af70: 616e 6e65 6c5f 6964 5f62 795f 6669 6c65  annel_id_by_file
+0000af80: 5f6e 616d 6528 6669 6c65 6e61 6d65 5f6e  _name(filename_n
+0000af90: 7474 290a 2020 2020 2020 2020 6966 2063  tt).        if c
+0000afa0: 6861 6e6e 656c 5f69 6420 6973 206e 6f74  hannel_id is not
+0000afb0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0000afc0: 2020 2063 6869 6420 3d20 6368 616e 6e65     chid = channe
+0000afd0: 6c5f 6964 0a20 2020 2020 2020 2065 6c73  l_id.        els
+0000afe0: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+0000aff0: 2069 6620 6e74 7420 6669 6c65 2069 7320   if ntt file is 
+0000b000: 656d 7074 7920 6974 2069 7320 6e6f 7420  empty it is not 
+0000b010: 6c69 7374 6564 2069 6e20 7365 6c66 2e70  listed in self.p
+0000b020: 6172 616d 6574 6572 735f 6e74 742c 2062  arameters_ntt, b
+0000b030: 7574 0a20 2020 2020 2020 2020 2020 2023  ut.            #
+0000b040: 2069 6e20 7365 6c66 2e6e 7474 5f61 7661   in self.ntt_ava
+0000b050: 696c 0a20 2020 2020 2020 2020 2020 2069  il.            i
+0000b060: 6620 6669 6c65 6e61 6d65 5f6e 7474 2069  f filename_ntt i
+0000b070: 6e20 7365 6c66 2e6e 7474 5f61 7661 696c  n self.ntt_avail
+0000b080: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000b090: 2020 7761 726e 696e 6773 2e77 6172 6e28    warnings.warn(
+0000b0a0: 274e 6575 7261 6c79 6e78 494f 2069 7320  'NeuralynxIO is 
+0000b0b0: 6174 7465 6d70 7469 6e67 2074 6f20 7265  attempting to re
+0000b0c0: 6164 2061 6e20 656d 7074 7920 270a 2020  ad an empty '.  
+0000b0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0e0: 2020 2020 2020 2020 2020 2020 2728 6e6f              '(no
+0000b0f0: 7420 6173 736f 6369 6174 6564 2920 6e74  t associated) nt
+0000b100: 7420 6669 6c65 2028 2573 292e 2027 0a20  t file (%s). '. 
+0000b110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b120: 2020 2020 2020 2020 2020 2020 2027 4e6f               'No
+0000b130: 7420 6c6f 6164 696e 6720 6e74 7420 6669  t loading ntt fi
+0000b140: 6c65 2e27 2025 2028 6669 6c65 6e61 6d65  le.' % (filename
+0000b150: 5f6e 7474 2929 0a20 2020 2020 2020 2020  _ntt)).         
+0000b160: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
+0000b170: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000b180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b190: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+0000b1a0: 2827 4e65 7572 616c 796e 7849 4f20 6973  ('NeuralynxIO is
+0000b1b0: 2061 7474 656d 7074 696e 6720 746f 2072   attempting to r
+0000b1c0: 6561 6420 6120 6669 6c65 2027 0a20 2020  ead a file '.   
+0000b1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1e0: 2020 2020 2020 2020 2020 2020 2020 276e                'n
+0000b1f0: 6f74 2061 7373 6f63 6961 7465 6420 746f  ot associated to
+0000b200: 2074 6869 7320 7365 7373 696f 6e20 2825   this session (%
+0000b210: 7329 2e27 2025 2028 0a20 2020 2020 2020  s).' % (.       
+0000b220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b230: 2020 2020 2020 2020 2020 2020 2020 6669                fi
+0000b240: 6c65 6e61 6d65 5f6e 7474 2929 0a0a 2020  lename_ntt))..  
+0000b250: 2020 2020 2020 2320 656e 7375 7265 206d        # ensure m
+0000b260: 6561 6e69 6e67 6675 6c20 7661 6c75 6573  eaningful values
+0000b270: 2066 6f72 2072 6571 7565 7374 6564 2073   for requested s
+0000b280: 7461 7274 2061 6e64 2073 746f 7020 7469  tart and stop ti
+0000b290: 6d65 730a 2020 2020 2020 2020 2320 696e  mes.        # in
+0000b2a0: 2063 6173 6520 7469 6d65 2069 7320 7072   case time is pr
+0000b2b0: 6f76 6964 6564 2069 6e20 7361 6d70 6c65  ovided in sample
+0000b2c0: 733a 2074 7261 6e73 666f 726d 2074 6f20  s: transform to 
+0000b2d0: 6162 736f 6c75 7465 2074 696d 6520 756e  absolute time un
+0000b2e0: 6974 730a 2020 2020 2020 2020 2320 6e63  its.        # nc
+0000b2f0: 7320 7361 6d70 6c69 6e67 2072 6174 6520  s sampling rate 
+0000b300: 6973 2062 6573 7420 6775 6573 7320 6966  is best guess if
+0000b310: 2074 6865 7265 2069 7320 6e6f 2065 7870   there is no exp
+0000b320: 6c69 6369 7420 7361 6d70 6c69 6e67 0a20  licit sampling. 
+0000b330: 2020 2020 2020 2023 2072 6174 6520 6769         # rate gi
+0000b340: 7665 6e20 666f 7220 6e74 7420 7661 6c75  ven for ntt valu
+0000b350: 6573 2e0a 2020 2020 2020 2020 6966 2027  es..        if '
+0000b360: 7361 6d70 6c69 6e67 5f72 6174 6527 2069  sampling_rate' i
+0000b370: 6e20 7365 6c66 2e70 6172 616d 6574 6572  n self.parameter
+0000b380: 735f 6e74 745b 6368 6964 5d3a 0a20 2020  s_ntt[chid]:.   
+0000b390: 2020 2020 2020 2020 2073 7220 3d20 7365           sr = se
+0000b3a0: 6c66 2e70 6172 616d 6574 6572 735f 6e74  lf.parameters_nt
+0000b3b0: 745b 6368 6964 5d5b 2773 616d 706c 696e  t[chid]['samplin
+0000b3c0: 675f 7261 7465 275d 0a20 2020 2020 2020  g_rate'].       
+0000b3d0: 2065 6c69 6620 6368 6964 2069 6e20 7365   elif chid in se
+0000b3e0: 6c66 2e70 6172 616d 6574 6572 735f 6e63  lf.parameters_nc
+0000b3f0: 7320 616e 6420 2773 616d 706c 696e 675f  s and 'sampling_
+0000b400: 7261 7465 2720 696e 205c 0a20 2020 2020  rate' in \.     
+0000b410: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000b420: 7061 7261 6d65 7465 7273 5f6e 6373 5b63  parameters_ncs[c
+0000b430: 6869 645d 3a0a 2020 2020 2020 2020 2020  hid]:.          
+0000b440: 2020 7372 203d 2073 656c 662e 7061 7261    sr = self.para
+0000b450: 6d65 7465 7273 5f6e 6373 5b63 6869 645d  meters_ncs[chid]
+0000b460: 5b27 7361 6d70 6c69 6e67 5f72 6174 6527  ['sampling_rate'
+0000b470: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
+0000b480: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000b490: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+0000b4a0: 2020 2020 2020 2020 2020 2020 2020 274e                'N
+0000b4b0: 6f20 7361 6d70 6c69 6e67 2072 6174 6520  o sampling rate 
+0000b4c0: 7072 6573 656e 7420 666f 7220 6368 616e  present for chan
+0000b4d0: 6e65 6c20 6964 2025 6920 696e 206e 7474  nel id %i in ntt
+0000b4e0: 2066 696c 6520 270a 2020 2020 2020 2020   file '.        
+0000b4f0: 2020 2020 2020 2020 2725 732e 2027 0a20          '%s. '. 
+0000b500: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+0000b510: 436f 756c 6420 616c 736f 206e 6f74 2066  Could also not f
+0000b520: 696e 6420 7468 6520 7361 6d70 6c69 6e67  ind the sampling
+0000b530: 2072 6174 6520 6f66 2074 6865 2072 6573   rate of the res
+0000b540: 7065 6374 6976 6520 270a 2020 2020 2020  pective '.      
+0000b550: 2020 2020 2020 2020 2020 276e 6373 2027            'ncs '
+0000b560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b570: 2027 6669 6c65 2e27 2025 2028 0a20 2020   'file.' % (.   
+0000b580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b590: 2063 6869 642c 2066 696c 656e 616d 655f   chid, filename_
+0000b5a0: 6e74 7429 290a 0a20 2020 2020 2020 2069  ntt))..        i
+0000b5b0: 6620 6973 696e 7374 616e 6365 2874 5f73  f isinstance(t_s
+0000b5c0: 7461 7274 2c20 696e 7429 3a0a 2020 2020  tart, int):.    
+0000b5d0: 2020 2020 2020 2020 745f 7374 6172 7420          t_start 
+0000b5e0: 3d20 745f 7374 6172 7420 2f20 7372 0a20  = t_start / sr. 
+0000b5f0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+0000b600: 616e 6365 2874 5f73 746f 702c 2069 6e74  ance(t_stop, int
+0000b610: 293a 0a20 2020 2020 2020 2020 2020 2074  ):.            t
+0000b620: 5f73 746f 7020 3d20 745f 7374 6f70 202f  _stop = t_stop /
+0000b630: 2073 720a 0a20 2020 2020 2020 2023 202b   sr..        # +
+0000b640: 2072 6573 6361 6c69 6e67 2074 6f20 676c   rescaling to gl
+0000b650: 6f62 616c 2072 6563 6f72 6469 6e67 2073  obal recording s
+0000b660: 7461 7274 2028 6669 7273 7420 7361 6d70  tart (first samp
+0000b670: 6c65 2069 6e20 616e 790a 2020 2020 2020  le in any.      
+0000b680: 2020 2320 7265 636f 7264 696e 6720 6669    # recording fi
+0000b690: 6c65 290a 2020 2020 2020 2020 6966 2074  le).        if t
+0000b6a0: 5f73 7461 7274 2069 7320 4e6f 6e65 206f  _start is None o
+0000b6b0: 7220 745f 7374 6172 7420 3c20 280a 2020  r t_start < (.  
+0000b6c0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+0000b6d0: 6172 616d 6574 6572 735f 6e74 745b 6368  arameters_ntt[ch
+0000b6e0: 6964 5d5b 2774 5f66 6972 7374 275d 0a20  id]['t_first']. 
+0000b6f0: 2020 2020 2020 2020 2020 202d 2073 656c             - sel
+0000b700: 662e 7061 7261 6d65 7465 7273 5f67 6c6f  f.parameters_glo
+0000b710: 6261 6c5b 0a20 2020 2020 2020 2020 2020  bal[.           
+0000b720: 2020 2020 2027 745f 7374 6172 7427 5d29       't_start'])
+0000b730: 3a0a 2020 2020 2020 2020 2020 2020 745f  :.            t_
+0000b740: 7374 6172 7420 3d20 280a 2020 2020 2020  start = (.      
+0000b750: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+0000b760: 6172 616d 6574 6572 735f 6e74 745b 6368  arameters_ntt[ch
+0000b770: 6964 5d5b 2774 5f66 6972 7374 275d 202d  id]['t_first'] -
+0000b780: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
+0000b790: 5f67 6c6f 6261 6c5b 0a20 2020 2020 2020  _global[.       
+0000b7a0: 2020 2020 2020 2020 2020 2020 2027 745f               't_
+0000b7b0: 7374 6172 7427 5d29 0a0a 2020 2020 2020  start'])..      
+0000b7c0: 2020 6966 2074 5f73 7461 7274 203e 2028    if t_start > (
+0000b7d0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0000b7e0: 662e 7061 7261 6d65 7465 7273 5f6e 7474  f.parameters_ntt
+0000b7f0: 5b63 6869 645d 5b27 745f 6c61 7374 275d  [chid]['t_last']
+0000b800: 0a20 2020 2020 2020 2020 2020 202d 2073  .            - s
+0000b810: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
+0000b820: 6c6f 6261 6c5b 0a20 2020 2020 2020 2020  lobal[.         
+0000b830: 2020 2020 2020 2027 745f 7374 6172 7427         't_start'
+0000b840: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
+0000b850: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+0000b860: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000b870: 2020 2752 6571 7565 7374 6564 2074 696d    'Requested tim
+0000b880: 6573 2077 696e 646f 7720 2825 7320 746f  es window (%s to
+0000b890: 2025 7329 2069 7320 6c61 7465 7220 7468   %s) is later th
+0000b8a0: 616e 2064 6174 6120 6172 6520 270a 2020  an data are '.  
+0000b8b0: 2020 2020 2020 2020 2020 2020 2020 2772                'r
+0000b8c0: 6563 6f72 6465 6420 2874 5f73 746f 7020  ecorded (t_stop 
+0000b8d0: 3d20 2573 2920 270a 2020 2020 2020 2020  = %s) '.        
+0000b8e0: 2020 2020 2020 2020 2766 6f72 2066 696c          'for fil
+0000b8f0: 6520 2573 2e27 2025 2028 745f 7374 6172  e %s.' % (t_star
+0000b900: 742c 2074 5f73 746f 702c 0a20 2020 2020  t, t_stop,.     
+0000b910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b920: 2020 2020 2020 2020 2020 2020 2028 7365               (se
+0000b930: 6c66 2e70 6172 616d 6574 6572 735f 6e74  lf.parameters_nt
+0000b940: 745b 6368 6964 5d5b 2774 5f6c 6173 7427  t[chid]['t_last'
+0000b950: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+0000b960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b970: 2020 2020 202d 2073 656c 662e 7061 7261       - self.para
+0000b980: 6d65 7465 7273 5f67 6c6f 6261 6c5b 2774  meters_global['t
+0000b990: 5f73 7461 7274 275d 292c 0a20 2020 2020  _start']),.     
+0000b9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b9b0: 2020 2020 2020 2020 2020 2020 2066 696c               fil
+0000b9c0: 656e 616d 655f 6e74 7429 290a 0a20 2020  ename_ntt))..   
+0000b9d0: 2020 2020 2069 6620 745f 7374 6f70 2069       if t_stop i
+0000b9e0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0000b9f0: 2020 2020 745f 7374 6f70 203d 2028 7379      t_stop = (sy
+0000ba00: 732e 6d61 7873 697a 6529 202a 2073 656c  s.maxsize) * sel
+0000ba10: 662e 6e74 745f 7469 6d65 5f75 6e69 740a  f.ntt_time_unit.
+0000ba20: 2020 2020 2020 2020 6966 2074 5f73 746f          if t_sto
+0000ba30: 7020 6973 204e 6f6e 6520 6f72 2074 5f73  p is None or t_s
+0000ba40: 746f 7020 3e20 280a 2020 2020 2020 2020  top > (.        
+0000ba50: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
+0000ba60: 6572 735f 6e74 745b 6368 6964 5d5b 2774  ers_ntt[chid]['t
+0000ba70: 5f6c 6173 7427 5d0a 2020 2020 2020 2020  _last'].        
+0000ba80: 2020 2020 2d20 7365 6c66 2e70 6172 616d      - self.param
+0000ba90: 6574 6572 735f 676c 6f62 616c 5b0a 2020  eters_global[.  
+0000baa0: 2020 2020 2020 2020 2020 2020 2020 2774                't
+0000bab0: 5f73 7461 7274 275d 293a 0a20 2020 2020  _start']):.     
+0000bac0: 2020 2020 2020 2074 5f73 746f 7020 3d20         t_stop = 
+0000bad0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000bae0: 2020 7365 6c66 2e70 6172 616d 6574 6572    self.parameter
+0000baf0: 735f 6e74 745b 6368 6964 5d5b 2774 5f6c  s_ntt[chid]['t_l
+0000bb00: 6173 7427 5d20 2d20 7365 6c66 2e70 6172  ast'] - self.par
+0000bb10: 616d 6574 6572 735f 676c 6f62 616c 5b0a  ameters_global[.
+0000bb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb30: 2020 2020 2774 5f73 7461 7274 275d 290a      't_start']).
+0000bb40: 0a20 2020 2020 2020 2069 6620 745f 7374  .        if t_st
+0000bb50: 6f70 203c 2028 0a20 2020 2020 2020 2020  op < (.         
+0000bb60: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
+0000bb70: 7273 5f6e 7474 5b63 6869 645d 5b27 745f  rs_ntt[chid]['t_
+0000bb80: 6669 7273 7427 5d0a 2020 2020 2020 2020  first'].        
+0000bb90: 2020 2020 2d20 7365 6c66 2e70 6172 616d      - self.param
+0000bba0: 6574 6572 735f 676c 6f62 616c 5b0a 2020  eters_global[.  
+0000bbb0: 2020 2020 2020 2020 2020 2020 2020 2774                't
+0000bbc0: 5f73 7461 7274 275d 293a 0a20 2020 2020  _start']):.     
+0000bbd0: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
+0000bbe0: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
+0000bbf0: 2020 2020 2020 2020 2027 5265 7175 6573           'Reques
+0000bc00: 7465 6420 7469 6d65 7320 7769 6e64 6f77  ted times window
+0000bc10: 2028 2573 2074 6f20 2573 2920 6973 2065   (%s to %s) is e
+0000bc20: 6172 6c69 6572 2074 6861 6e20 6461 7461  arlier than data
+0000bc30: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+0000bc40: 2020 2027 6172 6520 270a 2020 2020 2020     'are '.      
+0000bc50: 2020 2020 2020 2020 2020 2772 6563 6f72            'recor
+0000bc60: 6465 6420 2874 5f73 7461 7274 203d 2025  ded (t_start = %
+0000bc70: 7329 2027 0a20 2020 2020 2020 2020 2020  s) '.           
+0000bc80: 2020 2020 2027 666f 7220 6669 6c65 2025       'for file %
+0000bc90: 732e 2720 2520 2874 5f73 7461 7274 2c20  s.' % (t_start, 
+0000bca0: 745f 7374 6f70 2c0a 2020 2020 2020 2020  t_stop,.        
+0000bcb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bcc0: 2020 2020 2020 2020 2020 2873 656c 662e            (self.
+0000bcd0: 7061 7261 6d65 7465 7273 5f6e 7474 5b63  parameters_ntt[c
+0000bce0: 6869 645d 5b27 745f 6669 7273 7427 5d0a  hid]['t_first'].
+0000bcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd10: 2020 202d 2073 656c 662e 7061 7261 6d65     - self.parame
+0000bd20: 7465 7273 5f67 6c6f 6261 6c5b 2774 5f73  ters_global['t_s
+0000bd30: 7461 7274 275d 292c 0a20 2020 2020 2020  tart']),.       
+0000bd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd50: 2020 2020 2020 2020 2020 2066 696c 656e             filen
+0000bd60: 616d 655f 6e74 7429 290a 0a20 2020 2020  ame_ntt))..     
+0000bd70: 2020 2069 6620 745f 7374 6172 7420 3e3d     if t_start >=
+0000bd80: 2074 5f73 746f 703a 0a20 2020 2020 2020   t_stop:.       
+0000bd90: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+0000bda0: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
+0000bdb0: 2020 2020 2020 2027 5265 7175 6573 7465         'Requeste
+0000bdc0: 6420 7374 6172 7420 7469 6d65 2028 2573  d start time (%s
+0000bdd0: 2920 6973 206c 6174 6572 2074 6861 6e20  ) is later than 
+0000bde0: 2f20 6571 7561 6c20 746f 2073 746f 7020  / equal to stop 
+0000bdf0: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+0000be00: 2020 2774 696d 6520 270a 2020 2020 2020    'time '.      
+0000be10: 2020 2020 2020 2020 2020 2728 2573 2920            '(%s) 
+0000be20: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+0000be30: 2020 2766 6f72 2066 696c 6520 2573 2e27    'for file %s.'
+0000be40: 2025 2028 745f 7374 6172 742c 2074 5f73   % (t_start, t_s
+0000be50: 746f 702c 2066 696c 656e 616d 655f 6e74  top, filename_nt
+0000be60: 7429 290a 0a20 2020 2020 2020 2023 2072  t))..        # r
+0000be70: 6561 6469 6e67 2064 6174 610a 2020 2020  eading data.    
+0000be80: 2020 2020 5b74 696d 6573 7461 6d70 732c      [timestamps,
+0000be90: 2063 6861 6e6e 656c 5f69 6473 2c20 6365   channel_ids, ce
+0000bea0: 6c6c 5f6e 756d 6265 7273 2c20 6665 6174  ll_numbers, feat
+0000beb0: 7572 6573 2c0a 2020 2020 2020 2020 2064  ures,.         d
+0000bec0: 6174 615f 706f 696e 7473 5d20 3d20 7365  ata_points] = se
+0000bed0: 6c66 2e5f 5f6d 6d61 705f 6e74 745f 7061  lf.__mmap_ntt_pa
+0000bee0: 636b 6574 7328 6669 6c65 6e61 6d65 5f6e  ckets(filename_n
+0000bef0: 7474 290a 0a20 2020 2020 2020 2023 2054  tt)..        # T
+0000bf00: 4f44 4f3a 2057 6865 6e20 6e74 7420 6176  ODO: When ntt av
+0000bf10: 6169 6c61 626c 653a 2049 6d70 6c65 6d65  ailable: Impleme
+0000bf20: 6e74 2031 2052 6563 6f72 6469 6e67 4368  nt 1 RecordingCh
+0000bf30: 616e 6e65 6c47 726f 7570 2070 6572 0a20  annelGroup per. 
+0000bf40: 2020 2020 2020 2023 2054 6574 726f 6465         # Tetrode
+0000bf50: 2c20 7375 6368 2074 6861 7420 6561 6368  , such that each
+0000bf60: 2065 6c65 6374 726f 6465 2067 6574 7320   electrode gets 
+0000bf70: 6974 7320 6f77 6e20 7265 636f 7264 696e  its own recordin
+0000bf80: 6720 6368 616e 6e65 6c0a 0a20 2020 2020  g channel..     
+0000bf90: 2020 2023 206c 6f61 6420 616c 6c20 756e     # load all un
+0000bfa0: 6974 7320 6176 6169 6c61 626c 6520 6966  its available if
+0000bfb0: 2075 6e69 7473 3d3d 5b5d 0a20 2020 2020   units==[].     
+0000bfc0: 2020 2069 6620 756e 6974 5f6c 6973 7420     if unit_list 
+0000bfd0: 3d3d 205b 5d20 6f72 2075 6e69 745f 6c69  == [] or unit_li
+0000bfe0: 7374 2069 7320 4e6f 6e65 3a0a 2020 2020  st is None:.    
+0000bff0: 2020 2020 2020 2020 756e 6974 5f6c 6973          unit_lis
+0000c000: 7420 3d20 6e70 2e75 6e69 7175 6528 6365  t = np.unique(ce
+0000c010: 6c6c 5f6e 756d 6265 7273 290a 2020 2020  ll_numbers).    
+0000c020: 2020 2020 656c 6966 206e 6f74 2061 6e79      elif not any
+0000c030: 285b 7520 696e 2063 656c 6c5f 6e75 6d62  ([u in cell_numb
+0000c040: 6572 7320 666f 7220 7520 696e 2075 6e69  ers for u in uni
+0000c050: 745f 6c69 7374 5d29 3a0a 2020 2020 2020  t_list]):.      
+0000c060: 2020 2020 2020 7365 6c66 2e5f 6469 6167        self._diag
+0000c070: 6e6f 7374 6963 5f70 7269 6e74 280a 2020  nostic_print(.  
+0000c080: 2020 2020 2020 2020 2020 2020 2020 274e                'N
+0000c090: 6f6e 6520 6f66 2074 6865 2072 6571 7565  one of the reque
+0000c0a0: 7374 6564 2075 6e69 7420 6964 7320 2825  sted unit ids (%
+0000c0b0: 7329 2070 7265 7365 6e74 2027 0a20 2020  s) present '.   
+0000c0c0: 2020 2020 2020 2020 2020 2020 2027 696e               'in
+0000c0d0: 206e 7474 2066 696c 6520 2573 2028 636f   ntt file %s (co
+0000c0e0: 6e74 6169 6e73 2075 6e69 7473 2025 7329  ntains units %s)
+0000c0f0: 2720 2520 280a 2020 2020 2020 2020 2020  ' % (.          
+0000c100: 2020 2020 2020 2020 2020 756e 6974 5f6c            unit_l
+0000c110: 6973 742c 2066 696c 656e 616d 655f 6e74  ist, filename_nt
+0000c120: 742c 206e 702e 756e 6971 7565 2863 656c  t, np.unique(cel
+0000c130: 6c5f 6e75 6d62 6572 7329 2929 0a0a 2020  l_numbers)))..  
+0000c140: 2020 2020 2020 2320 6c6f 6164 696e 6720        # loading 
+0000c150: 6461 7461 2066 6f72 2065 6163 6820 756e  data for each un
+0000c160: 6974 2061 6e64 2067 656e 6572 6174 696e  it and generatin
+0000c170: 6720 7370 696b 6574 7261 696e 0a20 2020  g spiketrain.   
+0000c180: 2020 2020 2066 6f72 2075 6e69 745f 6920       for unit_i 
+0000c190: 696e 2075 6e69 745f 6c69 7374 3a0a 2020  in unit_list:.  
+0000c1a0: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
+0000c1b0: 206c 617a 793a 0a20 2020 2020 2020 2020   lazy:.         
+0000c1c0: 2020 2020 2020 2023 2045 7874 7261 6374         # Extract
+0000c1d0: 2061 6c6c 2074 696d 6520 7374 616d 7073   all time stamps
+0000c1e0: 206f 6620 7468 6174 206e 6575 726f 6e20   of that neuron 
+0000c1f0: 6f6e 2074 6861 7420 656c 6563 7472 6f64  on that electrod
+0000c200: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0000c210: 2020 6d61 736b 203d 206e 702e 7768 6572    mask = np.wher
+0000c220: 6528 6365 6c6c 5f6e 756d 6265 7273 203d  e(cell_numbers =
+0000c230: 3d20 756e 6974 5f69 295b 305d 0a20 2020  = unit_i)[0].   
+0000c240: 2020 2020 2020 2020 2020 2020 2073 7069               spi
+0000c250: 6b65 5f74 696d 6573 203d 2074 696d 6573  ke_times = times
+0000c260: 7461 6d70 735b 6d61 736b 5d20 2a20 7365  tamps[mask] * se
+0000c270: 6c66 2e6e 7474 5f74 696d 655f 756e 6974  lf.ntt_time_unit
+0000c280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c290: 2073 7069 6b65 5f74 696d 6573 203d 2073   spike_times = s
+0000c2a0: 7069 6b65 5f74 696d 6573 202d 2073 656c  pike_times - sel
+0000c2b0: 662e 7061 7261 6d65 7465 7273 5f67 6c6f  f.parameters_glo
+0000c2c0: 6261 6c5b 2774 5f73 7461 7274 275d 0a20  bal['t_start']. 
+0000c2d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000c2e0: 7069 6b65 5f74 696d 6573 203d 2073 7069  pike_times = spi
+0000c2f0: 6b65 5f74 696d 6573 5b6e 702e 7768 6572  ke_times[np.wher
+0000c300: 6528 0a20 2020 2020 2020 2020 2020 2020  e(.             
+0000c310: 2020 2020 2020 206e 702e 6c6f 6769 6361         np.logica
+0000c320: 6c5f 616e 6428 7370 696b 655f 7469 6d65  l_and(spike_time
+0000c330: 7320 3e3d 2074 5f73 7461 7274 2c0a 2020  s >= t_start,.  
+0000c340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c360: 2073 7069 6b65 5f74 696d 6573 203c 2074   spike_times < t
+0000c370: 5f73 746f 7029 295d 0a20 2020 2020 2020  _stop))].       
+0000c380: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000c390: 2020 2020 2020 2020 2020 2073 7069 6b65             spike
+0000c3a0: 5f74 696d 6573 203d 2070 712e 5175 616e  _times = pq.Quan
+0000c3b0: 7469 7479 285b 5d2c 2075 6e69 7473 3d73  tity([], units=s
+0000c3c0: 656c 662e 6e74 745f 7469 6d65 5f75 6e69  elf.ntt_time_uni
+0000c3d0: 7429 0a0a 2020 2020 2020 2020 2020 2020  t)..            
+0000c3e0: 2320 4372 6561 7465 2053 7069 6b65 5472  # Create SpikeTr
+0000c3f0: 6169 6e20 6f62 6a65 6374 0a20 2020 2020  ain object.     
+0000c400: 2020 2020 2020 2073 7420 3d20 5370 696b         st = Spik
+0000c410: 6554 7261 696e 2874 696d 6573 3d73 7069  eTrain(times=spi
+0000c420: 6b65 5f74 696d 6573 2c0a 2020 2020 2020  ke_times,.      
+0000c430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c440: 2020 2020 2020 745f 7374 6172 743d 745f        t_start=t_
+0000c450: 7374 6172 742c 0a20 2020 2020 2020 2020  start,.         
 0000c460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c470: 2020 2020 2020 2020 2773 616d 706c 696e          'samplin
-0000c480: 675f 7261 7465 275d 2c0a 2020 2020 2020  g_rate'],.      
-0000c490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c4a0: 2020 2020 2020 6e61 6d65 3d22 4368 616e        name="Chan
-0000c4b0: 6e65 6c20 2569 2c20 556e 6974 2025 6922  nel %i, Unit %i"
-0000c4c0: 2025 2028 6368 6964 2c20 756e 6974 5f69   % (chid, unit_i
-0000c4d0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-0000c4e0: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000c4f0: 696c 655f 6f72 6967 696e 3d66 696c 656e  ile_origin=filen
-0000c500: 616d 655f 6e74 742c 0a20 2020 2020 2020  ame_ntt,.       
-0000c510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c520: 2020 2020 2075 6e69 745f 6964 3d75 6e69       unit_id=uni
-0000c530: 745f 692c 0a20 2020 2020 2020 2020 2020  t_i,.           
-0000c540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c550: 2063 6861 6e6e 656c 5f69 643d 6368 6964   channel_id=chid
-0000c560: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
-0000c570: 2043 6f6c 6c65 6374 2061 6c6c 2077 6176   Collect all wav
-0000c580: 6566 6f72 6d73 206f 6620 7468 6520 7370  eforms of the sp
-0000c590: 6563 6966 6963 2075 6e69 740a 2020 2020  ecific unit.    
-0000c5a0: 2020 2020 2020 2020 6966 2077 6176 6566          if wavef
-0000c5b0: 6f72 6d73 2061 6e64 206e 6f74 206c 617a  orms and not laz
-0000c5c0: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
-0000c5d0: 2020 2023 2046 6f72 2063 6f6d 7075 7461     # For computa
-0000c5e0: 7469 6f6e 616c 2072 6561 736f 6e73 3a20  tional reasons: 
-0000c5f0: 6e6f 2075 6e69 7473 2c20 6e6f 2074 696d  no units, no tim
-0000c600: 6520 6178 6973 0a20 2020 2020 2020 2020  e axis.         
-0000c610: 2020 2020 2020 2023 2074 7261 6e73 706f         # transpo
-0000c620: 7369 6e67 2074 6f20 6164 6865 7265 2074  sing to adhere t
-0000c630: 6f20 6e65 6f20 6775 6964 6c69 6e65 2c20  o neo guidline, 
-0000c640: 7768 6963 6820 7374 6174 6573 2074 6861  which states tha
-0000c650: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-0000c660: 2020 2320 7469 6d65 2073 686f 756c 6420    # time should 
-0000c670: 6265 2069 6e20 7468 6520 6669 7273 7420  be in the first 
-0000c680: 6178 6973 2e0a 2020 2020 2020 2020 2020  axis..          
-0000c690: 2020 2020 2020 2320 5468 6973 2069 7320        # This is 
-0000c6a0: 7374 7570 6964 2061 6e64 206e 6f74 2069  stupid and not i
-0000c6b0: 6e74 7569 7469 7665 2e0a 2020 2020 2020  ntuitive..      
-0000c6c0: 2020 2020 2020 2020 2020 7374 2e77 6176            st.wav
-0000c6d0: 6566 6f72 6d73 203d 206e 702e 6172 7261  eforms = np.arra
-0000c6e0: 7928 0a20 2020 2020 2020 2020 2020 2020  y(.             
-0000c6f0: 2020 2020 2020 205b 6461 7461 5f70 6f69         [data_poi
-0000c700: 6e74 735b 742c 203a 2c20 3a5d 2066 6f72  nts[t, :, :] for
-0000c710: 2074 2069 6e20 7261 6e67 6528 6c65 6e28   t in range(len(
-0000c720: 7469 6d65 7374 616d 7073 2929 0a20 2020  timestamps)).   
-0000c730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c740: 2020 6966 2063 656c 6c5f 6e75 6d62 6572    if cell_number
-0000c750: 735b 745d 203d 3d20 756e 6974 5f69 5d29  s[t] == unit_i])
-0000c760: 2e74 7261 6e73 706f 7365 2829 0a20 2020  .transpose().   
-0000c770: 2020 2020 2020 2020 2020 2020 2023 2054               # T
-0000c780: 4f44 4f3a 2041 6464 2075 6e69 7473 2074  ODO: Add units t
-0000c790: 6f20 7761 7665 666f 726d 7320 2870 712e  o waveforms (pq.
-0000c7a0: 7556 3f29 2061 6e64 2061 6464 2061 6e6e  uV?) and add ann
-0000c7b0: 6f74 6174 696f 6e0a 2020 2020 2020 2020  otation.        
-0000c7c0: 2020 2020 2020 2020 2320 6c65 6674 5f73          # left_s
-0000c7d0: 7765 6570 203d 2078 202a 2070 712e 6d73  weep = x * pq.ms
-0000c7e0: 2069 6e64 6963 6174 696e 6720 7768 656e   indicating when
-0000c7f0: 2074 6872 6573 686f 6c64 2063 726f 7373   threshold cross
-0000c800: 696e 670a 2020 2020 2020 2020 2020 2020  ing.            
-0000c810: 2020 2020 2320 6f63 6375 7272 6564 2069      # occurred i
-0000c820: 6e20 7761 7665 666f 726d 0a0a 2020 2020  n waveform..    
-0000c830: 2020 2020 2020 2020 7374 2e61 6e6e 6f74          st.annot
-0000c840: 6174 696f 6e73 203d 2073 656c 662e 7061  ations = self.pa
-0000c850: 7261 6d65 7465 7273 5f6e 7474 5b63 6869  rameters_ntt[chi
-0000c860: 645d 0a20 2020 2020 2020 2020 2020 2073  d].            s
-0000c870: 742e 616e 6e6f 7461 7469 6f6e 735b 2765  t.annotations['e
-0000c880: 6c65 6374 726f 6465 5f69 6427 5d20 3d20  lectrode_id'] = 
-0000c890: 6368 6964 0a20 2020 2020 2020 2020 2020  chid.           
-0000c8a0: 2023 2054 6869 7320 616e 6e6f 7461 7469   # This annotati
-0000c8b0: 6f6e 7320 6973 206e 6563 6573 7361 7279  ons is necessary
-0000c8c0: 2066 6f72 2061 7574 6f6d 6174 6963 2067   for automatic g
-0000c8d0: 656e 6572 6174 696f 6e20 6f66 0a20 2020  eneration of.   
-0000c8e0: 2020 2020 2020 2020 2023 2072 6563 6f72           # recor
-0000c8f0: 6469 6e67 6368 616e 6e65 6c73 0a20 2020  dingchannels.   
-0000c900: 2020 2020 2020 2020 2073 742e 616e 6e6f           st.anno
-0000c910: 7461 7469 6f6e 735b 2763 6861 6e6e 656c  tations['channel
-0000c920: 5f69 6e64 6578 275d 203d 2063 6869 640a  _index'] = chid.
-0000c930: 0a20 2020 2020 2020 2020 2020 2073 6567  .            seg
-0000c940: 2e73 7069 6b65 7472 6169 6e73 2e61 7070  .spiketrains.app
-0000c950: 656e 6428 7374 290a 0a20 2020 2020 2020  end(st)..       
-0000c960: 2020 2020 2023 2070 7269 7661 7465 2072       # private r
-0000c970: 6f75 7469 6e65 730a 2020 2020 2020 2020  outines.        
-0000c980: 2020 2020 2320 2323 2323 2323 2323 2323      # ##########
-0000c990: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c9a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c9b0: 2323 2323 2323 230a 0a20 2020 2064 6566  #######..    def
-0000c9c0: 205f 6173 736f 6369 6174 6528 7365 6c66   _associate(self
-0000c9d0: 2c20 6361 6368 6564 6972 3d4e 6f6e 652c  , cachedir=None,
-0000c9e0: 2075 7365 6361 6368 653d 2768 6173 6827   usecache='hash'
-0000c9f0: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-0000ca00: 2020 2020 2020 2041 7373 6f63 6961 7465         Associate
-0000ca10: 7320 7468 6520 6f62 6a65 6374 2077 6974  s the object wit
-0000ca20: 6820 6120 7370 6563 6966 6965 6420 4e65  h a specified Ne
-0000ca30: 7572 616c 796e 7820 7365 7373 696f 6e2c  uralynx session,
-0000ca40: 2069 2e65 2e2c 2061 0a20 2020 2020 2020   i.e., a.       
-0000ca50: 2063 6f6d 6269 6e61 7469 6f6e 206f 6620   combination of 
-0000ca60: 6120 2e6e 7365 2c20 2e6e 6576 2061 6e64  a .nse, .nev and
-0000ca70: 202e 6e63 7320 6669 6c65 732e 2054 6865   .ncs files. The
-0000ca80: 206d 6574 6120 6461 7461 2069 7320 7265   meta data is re
-0000ca90: 6164 0a20 2020 2020 2020 2069 6e74 6f20  ad.        into 
-0000caa0: 7468 650a 2020 2020 2020 2020 6f62 6a65  the.        obje
-0000cab0: 6374 2066 6f72 2066 7574 7572 6520 7265  ct for future re
-0000cac0: 6665 7265 6e63 652e 0a0a 2020 2020 2020  ference...      
-0000cad0: 2020 4172 6775 6d65 6e74 733a 0a20 2020    Arguments:.   
-0000cae0: 2020 2020 2020 2020 2063 6163 6865 6469           cachedi
-0000caf0: 7220 3a20 4469 7265 6374 6f72 7920 666f  r : Directory fo
-0000cb00: 7220 6c6f 6164 696e 6720 616e 6420 7361  r loading and sa
-0000cb10: 7669 6e67 2068 6173 6865 7320 6f66 2072  ving hashes of r
-0000cb20: 6563 6f72 6469 6e67 0a20 2020 2020 2020  ecording.       
-0000cb30: 2020 2020 2073 6573 7369 6f6e 730a 2020       sessions.  
-0000cb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb50: 2020 2020 2020 2020 2020 2061 6e64 2070             and p
-0000cb60: 6963 6b6c 6564 206d 6574 6120 696e 666f  ickled meta info
-0000cb70: 726d 6174 696f 6e20 6162 6f75 7420 6669  rmation about fi
-0000cb80: 6c65 730a 2020 2020 2020 2020 2020 2020  les.            
-0000cb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cba0: 2065 7874 7261 6374 6564 2064 7572 696e   extracted durin
-0000cbb0: 670a 2020 2020 2020 2020 2020 2020 2020  g.              
-0000cbc0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000cbd0: 7373 6f63 6961 7469 6f6e 2070 726f 6365  ssociation proce
-0000cbe0: 7373 0a20 2020 2020 2020 2020 2020 2075  ss.            u
-0000cbf0: 7365 5f63 6163 6865 3a20 6d65 7468 6f64  se_cache: method
-0000cc00: 2075 7365 6420 666f 7220 6361 6368 6520   used for cache 
-0000cc10: 6964 656e 7469 6669 6361 7469 6f6e 2e20  identification. 
-0000cc20: 506f 7373 6962 6c65 2076 616c 7565 733a  Possible values:
-0000cc30: 0a20 2020 2020 2020 2020 2020 2027 6861  .            'ha
-0000cc40: 7368 272f 0a20 2020 2020 2020 2020 2020  sh'/.           
-0000cc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc60: 2027 616c 7761 7973 272f 2764 6174 6573   'always'/'dates
-0000cc70: 697a 6527 2f27 6e65 7665 7227 2e20 4465  ize'/'never'. De
-0000cc80: 6661 756c 7420 2768 6173 6827 0a20 2020  fault 'hash'.   
-0000cc90: 2020 2020 2052 6574 7572 6e73 3a0a 2020       Returns:.  
-0000cca0: 2020 2020 2020 2020 2020 2d0a 2020 2020            -.    
-0000ccb0: 2020 2020 2222 220a 0a20 2020 2020 2020      """..       
-0000ccc0: 2023 2049 6620 616c 7265 6164 7920 6173   # If already as
-0000ccd0: 736f 6369 6174 6564 2c20 6469 7361 7373  sociated, disass
-0000cce0: 6f63 6961 7465 2066 6972 7374 0a20 2020  ociate first.   
-0000ccf0: 2020 2020 2069 6620 7365 6c66 2e61 7373       if self.ass
-0000cd00: 6f63 6961 7465 643a 0a20 2020 2020 2020  ociated:.       
-0000cd10: 2020 2020 2072 6169 7365 2049 4f45 7272       raise IOErr
-0000cd20: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
-0000cd30: 2020 2020 2254 7279 696e 6720 746f 2061      "Trying to a
-0000cd40: 7373 6f63 6961 7465 2061 6e20 616c 7265  ssociate an alre
-0000cd50: 6164 7920 6173 736f 6369 6174 6564 204e  ady associated N
-0000cd60: 6575 7261 6c79 6e78 494f 2022 0a20 2020  euralynxIO ".   
-0000cd70: 2020 2020 2020 2020 2020 2020 2022 6f62               "ob
-0000cd80: 6a65 6374 2e22 290a 0a20 2020 2020 2020  ject.")..       
-0000cd90: 2023 2043 7265 6174 6520 7061 7261 6d65   # Create parame
-0000cda0: 7465 7220 636f 6e74 6169 6e65 7273 0a20  ter containers. 
-0000cdb0: 2020 2020 2020 2023 2044 6963 7469 6f6e         # Diction
-0000cdc0: 6172 7920 7468 6174 2068 6f6c 6473 2064  ary that holds d
-0000cdd0: 6966 6665 7265 6e74 2070 6172 616d 6574  ifferent paramet
-0000cde0: 6572 7320 7265 6164 2066 726f 6d20 7468  ers read from th
-0000cdf0: 6520 2e6e 6576 2066 696c 650a 2020 2020  e .nev file.    
-0000ce00: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
-0000ce10: 6572 735f 6e73 6520 3d20 7b7d 0a20 2020  ers_nse = {}.   
-0000ce20: 2020 2020 2023 204c 6973 7420 6f66 2070       # List of p
-0000ce30: 6172 616d 6574 6572 2064 6963 7469 6f6e  arameter diction
-0000ce40: 6172 6965 7320 666f 7220 616c 6c20 706f  aries for all po
-0000ce50: 7465 6e74 6961 6c20 6669 6c65 2074 7970  tential file typ
-0000ce60: 6573 0a20 2020 2020 2020 2073 656c 662e  es.        self.
-0000ce70: 7061 7261 6d65 7465 7273 5f6e 6373 203d  parameters_ncs =
-0000ce80: 207b 7d0a 2020 2020 2020 2020 7365 6c66   {}.        self
-0000ce90: 2e70 6172 616d 6574 6572 735f 6e65 7620  .parameters_nev 
-0000cea0: 3d20 7b7d 0a20 2020 2020 2020 2073 656c  = {}.        sel
-0000ceb0: 662e 7061 7261 6d65 7465 7273 5f6e 7474  f.parameters_ntt
-0000cec0: 203d 207b 7d0a 0a20 2020 2020 2020 2023   = {}..        #
-0000ced0: 2063 6f6d 6269 6e65 6420 676c 6f62 616c   combined global
-0000cee0: 2070 6172 616d 6574 6572 730a 2020 2020   parameters.    
-0000cef0: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
-0000cf00: 6572 735f 676c 6f62 616c 203d 207b 7d0a  ers_global = {}.
-0000cf10: 0a20 2020 2020 2020 2023 2053 6361 6e6e  .        # Scann
-0000cf20: 696e 6720 7365 7373 696f 6e20 6469 7265  ing session dire
-0000cf30: 6374 6f72 7920 666f 7220 7265 636f 7264  ctory for record
-0000cf40: 6564 2066 696c 6573 0a20 2020 2020 2020  ed files.       
-0000cf50: 2073 656c 662e 7365 7373 696f 6e66 696c   self.sessionfil
-0000cf60: 6573 203d 205b 6620 666f 7220 6620 696e  es = [f for f in
-0000cf70: 206c 6973 7464 6972 2873 656c 662e 7365   listdir(self.se
-0000cf80: 7373 696f 6e64 6972 2920 6966 0a20 2020  ssiondir) if.   
-0000cf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfa0: 2020 2020 2020 2020 2020 6973 6669 6c65            isfile
-0000cfb0: 286f 732e 7061 7468 2e6a 6f69 6e28 7365  (os.path.join(se
-0000cfc0: 6c66 2e73 6573 7369 6f6e 6469 722c 2066  lf.sessiondir, f
-0000cfd0: 2929 5d0a 0a20 2020 2020 2020 2023 204c  ))]..        # L
-0000cfe0: 6973 7469 6e67 2061 7661 696c 6162 6c65  isting available
-0000cff0: 2066 696c 6573 0a20 2020 2020 2020 2073   files.        s
-0000d000: 656c 662e 6e63 735f 6176 6169 6c20 3d20  elf.ncs_avail = 
-0000d010: 5b5d 0a20 2020 2020 2020 2073 656c 662e  [].        self.
-0000d020: 6e73 655f 6176 6169 6c20 3d20 5b5d 0a20  nse_avail = []. 
-0000d030: 2020 2020 2020 2073 656c 662e 6e65 765f         self.nev_
-0000d040: 6176 6169 6c20 3d20 5b5d 0a20 2020 2020  avail = [].     
-0000d050: 2020 2073 656c 662e 6e74 745f 6176 6169     self.ntt_avai
-0000d060: 6c20 3d20 5b5d 0a0a 2020 2020 2020 2020  l = []..        
-0000d070: 2320 4c69 7374 696e 6720 6173 736f 6369  # Listing associ
-0000d080: 6174 6564 2028 3d6e 6f6e 2063 6f72 7275  ated (=non corru
-0000d090: 7074 6564 2c20 6e6f 6e20 656d 7074 7920  pted, non empty 
-0000d0a0: 6669 6c65 7329 0a20 2020 2020 2020 2073  files).        s
-0000d0b0: 656c 662e 6e63 735f 6173 736f 203d 205b  elf.ncs_asso = [
-0000d0c0: 5d0a 2020 2020 2020 2020 7365 6c66 2e6e  ].        self.n
-0000d0d0: 7365 5f61 7373 6f20 3d20 5b5d 0a20 2020  se_asso = [].   
-0000d0e0: 2020 2020 2073 656c 662e 6e65 765f 6173       self.nev_as
-0000d0f0: 736f 203d 205b 5d0a 2020 2020 2020 2020  so = [].        
-0000d100: 7365 6c66 2e6e 7474 5f61 7373 6f20 3d20  self.ntt_asso = 
-0000d110: 5b5d 0a0a 2020 2020 2020 2020 6966 2075  []..        if u
-0000d120: 7365 6361 6368 6520 6e6f 7420 696e 205b  secache not in [
-0000d130: 2768 6173 6827 2c20 2761 6c77 6179 7327  'hash', 'always'
-0000d140: 2c20 2764 6174 6573 697a 6527 2c20 276e  , 'datesize', 'n
-0000d150: 6576 6572 275d 3a0a 2020 2020 2020 2020  ever']:.        
-0000d160: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-0000d170: 7272 6f72 280a 2020 2020 2020 2020 2020  rror(.          
-0000d180: 2020 2020 2020 2241 7267 756d 656e 7420        "Argument 
-0000d190: 7661 6c75 6520 6f66 2075 7365 6361 6368  value of usecach
-0000d1a0: 6520 2725 7327 2069 7320 6e6f 7420 7661  e '%s' is not va
-0000d1b0: 6c69 642e 2041 6363 6570 7465 6420 220a  lid. Accepted ".
-0000d1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d1d0: 2276 616c 7565 7320 6172 6520 2768 6173  "values are 'has
-0000d1e0: 6827 2c27 616c 7761 7973 272c 2764 6174  h','always','dat
-0000d1f0: 6573 697a 6527 2c27 6e65 7665 7227 2220  esize','never'" 
-0000d200: 2520 7573 6563 6163 6865 290a 0a20 2020  % usecache)..   
-0000d210: 2020 2020 2069 6620 6361 6368 6564 6972       if cachedir
-0000d220: 2069 7320 4e6f 6e65 2061 6e64 2075 7365   is None and use
-0000d230: 6361 6368 6520 213d 2027 6e65 7665 7227  cache != 'never'
-0000d240: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
-0000d250: 6973 6520 5661 6c75 6545 7272 6f72 2827  ise ValueError('
-0000d260: 4e6f 2063 6163 6865 2064 6972 6563 746f  No cache directo
-0000d270: 7279 2070 726f 7669 6465 642e 2729 0a0a  ry provided.')..
-0000d280: 2020 2020 2020 2020 2320 6368 6563 6b20          # check 
-0000d290: 6966 2074 6865 7265 2061 7265 2061 6e79  if there are any
-0000d2a0: 2063 6861 6e67 6573 206f 6620 7468 6520   changes of the 
-0000d2b0: 6461 7461 2066 696c 6573 202d 3e20 6e65  data files -> ne
-0000d2c0: 7720 6461 7461 2063 6865 636b 2072 756e  w data check run
-0000d2d0: 0a20 2020 2020 2020 2063 6865 636b 5f66  .        check_f
-0000d2e0: 696c 6573 203d 2054 7275 6520 6966 2075  iles = True if u
-0000d2f0: 7365 6361 6368 6520 213d 2027 616c 7761  secache != 'alwa
-0000d300: 7973 2720 656c 7365 2046 616c 7365 2020  ys' else False  
-0000d310: 2320 6e65 7665 720a 2020 2020 2020 2020  # never.        
-0000d320: 2320 6368 6563 6b69 6e67 2066 696c 6573  # checking files
-0000d330: 2069 6620 7573 6563 6163 6865 3d3d 2761   if usecache=='a
-0000d340: 6c77 6179 7327 0a20 2020 2020 2020 2069  lways'.        i
-0000d350: 6620 6361 6368 6564 6972 2069 7320 6e6f  f cachedir is no
-0000d360: 7420 4e6f 6e65 2061 6e64 2075 7365 6361  t None and useca
-0000d370: 6368 6520 213d 2027 6e65 7665 7227 3a0a  che != 'never':.
-0000d380: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0000d390: 662e 5f64 6961 676e 6f73 7469 635f 7072  f._diagnostic_pr
-0000d3a0: 696e 7428 0a20 2020 2020 2020 2020 2020  int(.           
-0000d3b0: 2020 2020 2027 4361 6c63 756c 6174 696e       'Calculatin
-0000d3c0: 6720 2573 206f 6620 7365 7373 696f 6e20  g %s of session 
-0000d3d0: 6669 6c65 7320 746f 2063 6865 636b 2066  files to check f
-0000d3e0: 6f72 2063 6163 6865 6420 270a 2020 2020  or cached '.    
-0000d3f0: 2020 2020 2020 2020 2020 2020 2770 6172              'par
-0000d400: 616d 6574 6572 2066 696c 6573 2e27 2025  ameter files.' %
-0000d410: 2075 7365 6361 6368 6529 0a20 2020 2020   usecache).     
-0000d420: 2020 2020 2020 2063 6163 6865 6669 6c65         cachefile
-0000d430: 203d 2063 6163 6865 6469 7220 2b20 7365   = cachedir + se
-0000d440: 7020 2b20 7365 6c66 2e73 6573 7369 6f6e  p + self.session
-0000d450: 6469 722e 7370 6c69 7428 7365 7029 5b0a  dir.split(sep)[.
-0000d460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d470: 2d31 5d20 2b20 272f 6861 7368 6b65 7973  -1] + '/hashkeys
-0000d480: 270a 2020 2020 2020 2020 2020 2020 6966  '.            if
-0000d490: 206e 6f74 206f 732e 7061 7468 2e65 7869   not os.path.exi
-0000d4a0: 7374 7328 6361 6368 6564 6972 202b 2073  sts(cachedir + s
-0000d4b0: 6570 202b 2073 656c 662e 7365 7373 696f  ep + self.sessio
-0000d4c0: 6e64 6972 2e73 706c 6974 2873 6570 295b  ndir.split(sep)[
-0000d4d0: 2d31 5d29 3a0a 2020 2020 2020 2020 2020  -1]):.          
-0000d4e0: 2020 2020 2020 6f73 2e6d 616b 6564 6972        os.makedir
-0000d4f0: 7328 6361 6368 6564 6972 202b 2073 6570  s(cachedir + sep
-0000d500: 202b 2073 656c 662e 7365 7373 696f 6e64   + self.sessiond
-0000d510: 6972 2e73 706c 6974 2873 6570 295b 2d31  ir.split(sep)[-1
-0000d520: 5d29 0a0a 2020 2020 2020 2020 2020 2020  ])..            
-0000d530: 6966 2075 7365 6361 6368 6520 3d3d 2027  if usecache == '
-0000d540: 6861 7368 273a 0a20 2020 2020 2020 2020  hash':.         
-0000d550: 2020 2020 2020 2068 6173 6865 735f 6361         hashes_ca
-0000d560: 6c63 203d 207b 7d0a 2020 2020 2020 2020  lc = {}.        
-0000d570: 2020 2020 2020 2020 2320 6361 6c63 756c          # calcul
-0000d580: 6174 6573 2068 6173 6820 6f66 2061 6c6c  ates hash of all
-0000d590: 2061 7661 696c 6162 6c65 2066 696c 6573   available files
-0000d5a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d5b0: 2066 6f72 2066 2069 6e20 7365 6c66 2e73   for f in self.s
-0000d5c0: 6573 7369 6f6e 6669 6c65 733a 0a20 2020  essionfiles:.   
-0000d5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d5e0: 2066 696c 655f 6861 7368 203d 2073 656c   file_hash = sel
-0000d5f0: 662e 6861 7368 6669 6c65 286f 7065 6e28  f.hashfile(open(
-0000d600: 7365 6c66 2e73 6573 7369 6f6e 6469 7220  self.sessiondir 
-0000d610: 2b20 7365 7020 2b20 662c 0a20 2020 2020  + sep + f,.     
-0000d620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d640: 2020 2020 2020 2020 2020 2020 2020 2772                'r
-0000d650: 6227 292c 2068 6173 686c 6962 2e73 6861  b'), hashlib.sha
-0000d660: 3235 3628 2929 0a20 2020 2020 2020 2020  256()).         
-0000d670: 2020 2020 2020 2020 2020 2068 6173 6865             hashe
-0000d680: 735f 6361 6c63 5b66 5d20 3d20 6669 6c65  s_calc[f] = file
-0000d690: 5f68 6173 680a 2020 2020 2020 2020 2020  _hash.          
-0000d6a0: 2020 656c 6966 2075 7365 6361 6368 6520    elif usecache 
-0000d6b0: 3d3d 2027 6461 7465 7369 7a65 273a 0a20  == 'datesize':. 
-0000d6c0: 2020 2020 2020 2020 2020 2020 2020 2068                 h
-0000d6d0: 6173 6865 735f 6361 6c63 203d 207b 7d0a  ashes_calc = {}.
-0000d6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d6f0: 666f 7220 6620 696e 2073 656c 662e 7365  for f in self.se
-0000d700: 7373 696f 6e66 696c 6573 3a0a 2020 2020  ssionfiles:.    
-0000d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d720: 6861 7368 6573 5f63 616c 635b 665d 203d  hashes_calc[f] =
-0000d730: 2073 656c 662e 6461 7465 7369 7a65 6669   self.datesizefi
-0000d740: 6c65 280a 2020 2020 2020 2020 2020 2020  le(.            
-0000d750: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000d760: 2e73 6573 7369 6f6e 6469 7220 2b20 7365  .sessiondir + se
-0000d770: 7020 2b20 6629 0a0a 2020 2020 2020 2020  p + f)..        
-0000d780: 2020 2020 2320 6c6f 6164 2068 6173 6865      # load hashe
-0000d790: 7320 7361 7665 6420 666f 7220 7468 6973  s saved for this
-0000d7a0: 2073 6573 7369 6f6e 2069 6e20 616e 2065   session in an e
-0000d7b0: 6172 6c69 6572 206c 6f61 6469 6e67 2072  arlier loading r
-0000d7c0: 756e 0a20 2020 2020 2020 2020 2020 2069  un.            i
-0000d7d0: 6620 6f73 2e70 6174 682e 6578 6973 7473  f os.path.exists
-0000d7e0: 2863 6163 6865 6669 6c65 293a 0a20 2020  (cachefile):.   
-0000d7f0: 2020 2020 2020 2020 2020 2020 2068 6173               has
-0000d800: 6865 735f 7265 6164 203d 2070 6963 6b6c  hes_read = pickl
-0000d810: 652e 6c6f 6164 286f 7065 6e28 6361 6368  e.load(open(cach
-0000d820: 6566 696c 652c 2027 7262 2729 290a 2020  efile, 'rb')).  
-0000d830: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0000d840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d850: 6861 7368 6573 5f72 6561 6420 3d20 7b7d  hashes_read = {}
-0000d860: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000d870: 636f 6d70 6172 6520 6861 7368 6573 2074  compare hashes t
-0000d880: 6f20 7072 6576 696f 7573 6c79 2073 6176  o previously sav
-0000d890: 6564 206d 6574 6120 6461 7461 2075 6e64  ed meta data und
-0000d8a0: 206c 6f61 6420 6d65 7461 2064 6174 610a   load meta data.
-0000d8b0: 2020 2020 2020 2020 2020 2020 2320 2069              #  i
-0000d8c0: 6620 6e6f 2063 6861 6e67 6573 206f 6363  f no changes occ
-0000d8d0: 7572 6564 0a20 2020 2020 2020 2020 2020  ured.           
-0000d8e0: 2069 6620 7573 6563 6163 6865 203d 3d20   if usecache == 
-0000d8f0: 2761 6c77 6179 7327 206f 7220 616c 6c28  'always' or all(
-0000d900: 5b66 2069 6e20 6861 7368 6573 5f63 616c  [f in hashes_cal
-0000d910: 630a 2020 2020 2020 2020 2020 2020 2020  c.              
-0000d920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d930: 2020 2020 2020 2020 2020 2020 2020 616e                an
-0000d940: 6420 6620 696e 2068 6173 6865 735f 7265  d f in hashes_re
-0000d950: 6164 0a20 2020 2020 2020 2020 2020 2020  ad.             
-0000d960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d970: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000d980: 6e64 2068 6173 6865 735f 6361 6c63 5b66  nd hashes_calc[f
-0000d990: 5d20 3d3d 2068 6173 6865 735f 7265 6164  ] == hashes_read
-0000d9a0: 5b66 5d0a 2020 2020 2020 2020 2020 2020  [f].            
-0000d9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d9d0: 666f 7220 6620 696e 2073 656c 662e 7365  for f in self.se
-0000d9e0: 7373 696f 6e66 696c 6573 5d29 3a0a 2020  ssionfiles]):.  
-0000d9f0: 2020 2020 2020 2020 2020 2020 2020 6368                ch
-0000da00: 6563 6b5f 6669 6c65 7320 3d20 4661 6c73  eck_files = Fals
-0000da10: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-0000da20: 2020 7365 6c66 2e5f 6469 6167 6e6f 7374    self._diagnost
-0000da30: 6963 5f70 7269 6e74 280a 2020 2020 2020  ic_print(.      
-0000da40: 2020 2020 2020 2020 2020 2020 2020 2755                'U
-0000da50: 7369 6e67 2063 6163 6865 6420 6d65 7461  sing cached meta
-0000da60: 6461 7461 2066 726f 6d20 6561 726c 6965  data from earlie
-0000da70: 7220 616e 616c 7973 6973 2072 756e 2069  r analysis run i
-0000da80: 6e20 270a 2020 2020 2020 2020 2020 2020  n '.            
-0000da90: 2020 2020 2020 2020 2766 696c 6520 270a          'file '.
-0000daa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dab0: 2020 2020 2725 732e 2053 6b69 7070 696e      '%s. Skippin
-0000dac0: 6720 6669 6c65 2063 6865 636b 732e 2720  g file checks.' 
-0000dad0: 2520 6361 6368 6566 696c 6529 0a0a 2020  % cachefile)..  
-0000dae0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0000daf0: 6c6f 6164 696e 6720 7361 7665 6420 7061  loading saved pa
-0000db00: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
-0000db10: 2020 2020 2020 2020 2070 6172 616d 6574           paramet
-0000db20: 6572 6669 6c65 203d 2063 6163 6865 6469  erfile = cachedi
-0000db30: 7220 2b20 7365 7020 2b20 7365 6c66 2e73  r + sep + self.s
-0000db40: 6573 7369 6f6e 6469 722e 7370 6c69 7428  essiondir.split(
-0000db50: 7365 7029 5b0a 2020 2020 2020 2020 2020  sep)[.          
-0000db60: 2020 2020 2020 2020 2020 2d31 5d20 2b20            -1] + 
-0000db70: 272f 7061 7261 6d65 7465 7273 2e63 6163  '/parameters.cac
-0000db80: 6865 270a 2020 2020 2020 2020 2020 2020  he'.            
-0000db90: 2020 2020 6966 206f 732e 7061 7468 2e65      if os.path.e
-0000dba0: 7869 7374 7328 7061 7261 6d65 7465 7266  xists(parameterf
-0000dbb0: 696c 6529 3a0a 2020 2020 2020 2020 2020  ile):.          
-0000dbc0: 2020 2020 2020 2020 2020 7061 7261 6d65            parame
-0000dbd0: 7465 7273 5f72 6561 6420 3d20 7069 636b  ters_read = pick
-0000dbe0: 6c65 2e6c 6f61 6428 6f70 656e 2870 6172  le.load(open(par
-0000dbf0: 616d 6574 6572 6669 6c65 2c20 2772 6227  ameterfile, 'rb'
-0000dc00: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-0000dc10: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000dc20: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-0000dc30: 7365 2049 4f45 7272 6f72 2827 496e 636f  se IOError('Inco
-0000dc40: 6e73 6973 7465 6e74 2063 6163 6865 2066  nsistent cache f
-0000dc50: 696c 6573 2e27 290a 0a20 2020 2020 2020  iles.')..       
-0000dc60: 2020 2020 2020 2020 2066 6f72 2049 4f64           for IOd
-0000dc70: 6963 742c 2064 6963 746e 616d 6520 696e  ict, dictname in
-0000dc80: 205b 2873 656c 662e 7061 7261 6d65 7465   [(self.paramete
-0000dc90: 7273 5f67 6c6f 6261 6c2c 2027 676c 6f62  rs_global, 'glob
-0000dca0: 616c 2729 2c0a 2020 2020 2020 2020 2020  al'),.          
-0000dcb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dcc0: 2020 2020 2020 2020 2020 2020 2020 2028                 (
-0000dcd0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-0000dce0: 6e63 732c 2027 6e63 7327 292c 0a20 2020  ncs, 'ncs'),.   
-0000dcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd10: 2020 2020 2020 2873 656c 662e 7061 7261        (self.para
-0000dd20: 6d65 7465 7273 5f6e 7365 2c20 276e 7365  meters_nse, 'nse
-0000dd30: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-0000dd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd50: 2020 2020 2020 2020 2020 2020 2028 7365               (se
-0000dd60: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
-0000dd70: 762c 2027 6e65 7627 292c 0a20 2020 2020  v, 'nev'),.     
-0000dd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dda0: 2020 2020 2873 656c 662e 7061 7261 6d65      (self.parame
-0000ddb0: 7465 7273 5f6e 7474 2c20 276e 7474 2729  ters_ntt, 'ntt')
-0000ddc0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-0000ddd0: 2020 2020 2020 2049 4f64 6963 742e 7570         IOdict.up
-0000dde0: 6461 7465 2870 6172 616d 6574 6572 735f  date(parameters_
-0000ddf0: 7265 6164 5b64 6963 746e 616d 655d 290a  read[dictname]).
+0000c470: 2020 2074 5f73 746f 703d 745f 7374 6f70     t_stop=t_stop
+0000c480: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000c490: 2020 2020 2020 2020 2020 2020 2020 7361                sa
+0000c4a0: 6d70 6c69 6e67 5f72 6174 653d 7365 6c66  mpling_rate=self
+0000c4b0: 2e70 6172 616d 6574 6572 735f 6e63 735b  .parameters_ncs[
+0000c4c0: 6368 6964 5d5b 0a20 2020 2020 2020 2020  chid][.         
+0000c4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c4e0: 2020 2020 2020 2027 7361 6d70 6c69 6e67         'sampling
+0000c4f0: 5f72 6174 6527 5d2c 0a20 2020 2020 2020  _rate'],.       
+0000c500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c510: 2020 2020 206e 616d 653d 2243 6861 6e6e       name="Chann
+0000c520: 656c 2025 692c 2055 6e69 7420 2569 2220  el %i, Unit %i" 
+0000c530: 2520 2863 6869 642c 2075 6e69 745f 6929  % (chid, unit_i)
+0000c540: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000c550: 2020 2020 2020 2020 2020 2020 2020 6669                fi
+0000c560: 6c65 5f6f 7269 6769 6e3d 6669 6c65 6e61  le_origin=filena
+0000c570: 6d65 5f6e 7474 2c0a 2020 2020 2020 2020  me_ntt,.        
+0000c580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c590: 2020 2020 756e 6974 5f69 643d 756e 6974      unit_id=unit
+0000c5a0: 5f69 2c0a 2020 2020 2020 2020 2020 2020  _i,.            
+0000c5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c5c0: 6368 616e 6e65 6c5f 6964 3d63 6869 6429  channel_id=chid)
+0000c5d0: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
+0000c5e0: 436f 6c6c 6563 7420 616c 6c20 7761 7665  Collect all wave
+0000c5f0: 666f 726d 7320 6f66 2074 6865 2073 7065  forms of the spe
+0000c600: 6369 6669 6320 756e 6974 0a20 2020 2020  cific unit.     
+0000c610: 2020 2020 2020 2069 6620 7761 7665 666f         if wavefo
+0000c620: 726d 7320 616e 6420 6e6f 7420 6c61 7a79  rms and not lazy
+0000c630: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000c640: 2020 2320 466f 7220 636f 6d70 7574 6174    # For computat
+0000c650: 696f 6e61 6c20 7265 6173 6f6e 733a 206e  ional reasons: n
+0000c660: 6f20 756e 6974 732c 206e 6f20 7469 6d65  o units, no time
+0000c670: 2061 7869 730a 2020 2020 2020 2020 2020   axis.          
+0000c680: 2020 2020 2020 2320 7472 616e 7370 6f73        # transpos
+0000c690: 696e 6720 746f 2061 6468 6572 6520 746f  ing to adhere to
+0000c6a0: 206e 656f 2067 7569 646c 696e 652c 2077   neo guidline, w
+0000c6b0: 6869 6368 2073 7461 7465 7320 7468 6174  hich states that
+0000c6c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c6d0: 2023 2074 696d 6520 7368 6f75 6c64 2062   # time should b
+0000c6e0: 6520 696e 2074 6865 2066 6972 7374 2061  e in the first a
+0000c6f0: 7869 732e 0a20 2020 2020 2020 2020 2020  xis..           
+0000c700: 2020 2020 2023 2054 6869 7320 6973 2073       # This is s
+0000c710: 7475 7069 6420 616e 6420 6e6f 7420 696e  tupid and not in
+0000c720: 7475 6974 6976 652e 0a20 2020 2020 2020  tuitive..       
+0000c730: 2020 2020 2020 2020 2073 742e 7761 7665           st.wave
+0000c740: 666f 726d 7320 3d20 6e70 2e61 7272 6179  forms = np.array
+0000c750: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000c760: 2020 2020 2020 5b64 6174 615f 706f 696e        [data_poin
+0000c770: 7473 5b74 2c20 3a2c 203a 5d20 666f 7220  ts[t, :, :] for 
+0000c780: 7420 696e 2072 616e 6765 286c 656e 2874  t in range(len(t
+0000c790: 696d 6573 7461 6d70 7329 290a 2020 2020  imestamps)).    
+0000c7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7b0: 2069 6620 6365 6c6c 5f6e 756d 6265 7273   if cell_numbers
+0000c7c0: 5b74 5d20 3d3d 2075 6e69 745f 695d 292e  [t] == unit_i]).
+0000c7d0: 7472 616e 7370 6f73 6528 290a 2020 2020  transpose().    
+0000c7e0: 2020 2020 2020 2020 2020 2020 2320 544f              # TO
+0000c7f0: 444f 3a20 4164 6420 756e 6974 7320 746f  DO: Add units to
+0000c800: 2077 6176 6566 6f72 6d73 2028 7071 2e75   waveforms (pq.u
+0000c810: 563f 2920 616e 6420 6164 6420 616e 6e6f  V?) and add anno
+0000c820: 7461 7469 6f6e 0a20 2020 2020 2020 2020  tation.         
+0000c830: 2020 2020 2020 2023 206c 6566 745f 7377         # left_sw
+0000c840: 6565 7020 3d20 7820 2a20 7071 2e6d 7320  eep = x * pq.ms 
+0000c850: 696e 6469 6361 7469 6e67 2077 6865 6e20  indicating when 
+0000c860: 7468 7265 7368 6f6c 6420 6372 6f73 7369  threshold crossi
+0000c870: 6e67 0a20 2020 2020 2020 2020 2020 2020  ng.             
+0000c880: 2020 2023 206f 6363 7572 7265 6420 696e     # occurred in
+0000c890: 2077 6176 6566 6f72 6d0a 0a20 2020 2020   waveform..     
+0000c8a0: 2020 2020 2020 2073 742e 616e 6e6f 7461         st.annota
+0000c8b0: 7469 6f6e 7320 3d20 7365 6c66 2e70 6172  tions = self.par
+0000c8c0: 616d 6574 6572 735f 6e74 745b 6368 6964  ameters_ntt[chid
+0000c8d0: 5d0a 2020 2020 2020 2020 2020 2020 7374  ].            st
+0000c8e0: 2e61 6e6e 6f74 6174 696f 6e73 5b27 656c  .annotations['el
+0000c8f0: 6563 7472 6f64 655f 6964 275d 203d 2063  ectrode_id'] = c
+0000c900: 6869 640a 2020 2020 2020 2020 2020 2020  hid.            
+0000c910: 2320 5468 6973 2061 6e6e 6f74 6174 696f  # This annotatio
+0000c920: 6e73 2069 7320 6e65 6365 7373 6172 7920  ns is necessary 
+0000c930: 666f 7220 6175 746f 6d61 7469 6320 6765  for automatic ge
+0000c940: 6e65 7261 7469 6f6e 206f 660a 2020 2020  neration of.    
+0000c950: 2020 2020 2020 2020 2320 7265 636f 7264          # record
+0000c960: 696e 6763 6861 6e6e 656c 730a 2020 2020  ingchannels.    
+0000c970: 2020 2020 2020 2020 7374 2e61 6e6e 6f74          st.annot
+0000c980: 6174 696f 6e73 5b27 6368 616e 6e65 6c5f  ations['channel_
+0000c990: 696e 6465 7827 5d20 3d20 6368 6964 0a0a  index'] = chid..
+0000c9a0: 2020 2020 2020 2020 2020 2020 7365 672e              seg.
+0000c9b0: 7370 696b 6574 7261 696e 732e 6170 7065  spiketrains.appe
+0000c9c0: 6e64 2873 7429 0a0a 2020 2020 2020 2020  nd(st)..        
+0000c9d0: 2020 2020 2320 7072 6976 6174 6520 726f      # private ro
+0000c9e0: 7574 696e 6573 0a20 2020 2020 2020 2020  utines.         
+0000c9f0: 2020 2023 2023 2323 2323 2323 2323 2323     # ###########
+0000ca00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ca10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ca20: 2323 2323 2323 0a0a 2020 2020 6465 6620  ######..    def 
+0000ca30: 5f61 7373 6f63 6961 7465 2873 656c 662c  _associate(self,
+0000ca40: 2063 6163 6865 6469 723d 4e6f 6e65 2c20   cachedir=None, 
+0000ca50: 7573 6563 6163 6865 3d27 6861 7368 2729  usecache='hash')
+0000ca60: 3a0a 2020 2020 2020 2020 2222 220a 2020  :.        """.  
+0000ca70: 2020 2020 2020 4173 736f 6369 6174 6573        Associates
+0000ca80: 2074 6865 206f 626a 6563 7420 7769 7468   the object with
+0000ca90: 2061 2073 7065 6369 6669 6564 204e 6575   a specified Neu
+0000caa0: 7261 6c79 6e78 2073 6573 7369 6f6e 2c20  ralynx session, 
+0000cab0: 692e 652e 2c20 610a 2020 2020 2020 2020  i.e., a.        
+0000cac0: 636f 6d62 696e 6174 696f 6e20 6f66 2061  combination of a
+0000cad0: 202e 6e73 652c 202e 6e65 7620 616e 6420   .nse, .nev and 
+0000cae0: 2e6e 6373 2066 696c 6573 2e20 5468 6520  .ncs files. The 
+0000caf0: 6d65 7461 2064 6174 6120 6973 2072 6561  meta data is rea
+0000cb00: 640a 2020 2020 2020 2020 696e 746f 2074  d.        into t
+0000cb10: 6865 0a20 2020 2020 2020 206f 626a 6563  he.        objec
+0000cb20: 7420 666f 7220 6675 7475 7265 2072 6566  t for future ref
+0000cb30: 6572 656e 6365 2e0a 0a20 2020 2020 2020  erence...       
+0000cb40: 2041 7267 756d 656e 7473 3a0a 2020 2020   Arguments:.    
+0000cb50: 2020 2020 2020 2020 6361 6368 6564 6972          cachedir
+0000cb60: 203a 2044 6972 6563 746f 7279 2066 6f72   : Directory for
+0000cb70: 206c 6f61 6469 6e67 2061 6e64 2073 6176   loading and sav
+0000cb80: 696e 6720 6861 7368 6573 206f 6620 7265  ing hashes of re
+0000cb90: 636f 7264 696e 670a 2020 2020 2020 2020  cording.        
+0000cba0: 2020 2020 7365 7373 696f 6e73 0a20 2020      sessions.   
+0000cbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbc0: 2020 2020 2020 2020 2020 616e 6420 7069            and pi
+0000cbd0: 636b 6c65 6420 6d65 7461 2069 6e66 6f72  ckled meta infor
+0000cbe0: 6d61 7469 6f6e 2061 626f 7574 2066 696c  mation about fil
+0000cbf0: 6573 0a20 2020 2020 2020 2020 2020 2020  es.             
+0000cc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc10: 6578 7472 6163 7465 6420 6475 7269 6e67  extracted during
+0000cc20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000cc30: 2020 2020 2020 2020 2020 2020 2020 6173                as
+0000cc40: 736f 6369 6174 696f 6e20 7072 6f63 6573  sociation proces
+0000cc50: 730a 2020 2020 2020 2020 2020 2020 7573  s.            us
+0000cc60: 655f 6361 6368 653a 206d 6574 686f 6420  e_cache: method 
+0000cc70: 7573 6564 2066 6f72 2063 6163 6865 2069  used for cache i
+0000cc80: 6465 6e74 6966 6963 6174 696f 6e2e 2050  dentification. P
+0000cc90: 6f73 7369 626c 6520 7661 6c75 6573 3a0a  ossible values:.
+0000cca0: 2020 2020 2020 2020 2020 2020 2768 6173              'has
+0000ccb0: 6827 2f0a 2020 2020 2020 2020 2020 2020  h'/.            
+0000ccc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ccd0: 2761 6c77 6179 7327 2f27 6461 7465 7369  'always'/'datesi
+0000cce0: 7a65 272f 276e 6576 6572 272e 2044 6566  ze'/'never'. Def
+0000ccf0: 6175 6c74 2027 6861 7368 270a 2020 2020  ault 'hash'.    
+0000cd00: 2020 2020 5265 7475 726e 733a 0a20 2020      Returns:.   
+0000cd10: 2020 2020 2020 2020 202d 0a20 2020 2020           -.     
+0000cd20: 2020 2022 2222 0a0a 2020 2020 2020 2020     """..        
+0000cd30: 2320 4966 2061 6c72 6561 6479 2061 7373  # If already ass
+0000cd40: 6f63 6961 7465 642c 2064 6973 6173 736f  ociated, disasso
+0000cd50: 6369 6174 6520 6669 7273 740a 2020 2020  ciate first.    
+0000cd60: 2020 2020 6966 2073 656c 662e 6173 736f      if self.asso
+0000cd70: 6369 6174 6564 3a0a 2020 2020 2020 2020  ciated:.        
+0000cd80: 2020 2020 7261 6973 6520 4f53 4572 726f      raise OSErro
+0000cd90: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
+0000cda0: 2020 2022 5472 7969 6e67 2074 6f20 6173     "Trying to as
+0000cdb0: 736f 6369 6174 6520 616e 2061 6c72 6561  sociate an alrea
+0000cdc0: 6479 2061 7373 6f63 6961 7465 6420 4e65  dy associated Ne
+0000cdd0: 7572 616c 796e 7849 4f20 220a 2020 2020  uralynxIO ".    
+0000cde0: 2020 2020 2020 2020 2020 2020 226f 626a              "obj
+0000cdf0: 6563 742e 2229 0a0a 2020 2020 2020 2020  ect.")..        
+0000ce00: 2320 4372 6561 7465 2070 6172 616d 6574  # Create paramet
+0000ce10: 6572 2063 6f6e 7461 696e 6572 730a 2020  er containers.  
+0000ce20: 2020 2020 2020 2320 4469 6374 696f 6e61        # Dictiona
+0000ce30: 7279 2074 6861 7420 686f 6c64 7320 6469  ry that holds di
+0000ce40: 6666 6572 656e 7420 7061 7261 6d65 7465  fferent paramete
+0000ce50: 7273 2072 6561 6420 6672 6f6d 2074 6865  rs read from the
+0000ce60: 202e 6e65 7620 6669 6c65 0a20 2020 2020   .nev file.     
+0000ce70: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
+0000ce80: 7273 5f6e 7365 203d 207b 7d0a 2020 2020  rs_nse = {}.    
+0000ce90: 2020 2020 2320 4c69 7374 206f 6620 7061      # List of pa
+0000cea0: 7261 6d65 7465 7220 6469 6374 696f 6e61  rameter dictiona
+0000ceb0: 7269 6573 2066 6f72 2061 6c6c 2070 6f74  ries for all pot
+0000cec0: 656e 7469 616c 2066 696c 6520 7479 7065  ential file type
+0000ced0: 730a 2020 2020 2020 2020 7365 6c66 2e70  s.        self.p
+0000cee0: 6172 616d 6574 6572 735f 6e63 7320 3d20  arameters_ncs = 
+0000cef0: 7b7d 0a20 2020 2020 2020 2073 656c 662e  {}.        self.
+0000cf00: 7061 7261 6d65 7465 7273 5f6e 6576 203d  parameters_nev =
+0000cf10: 207b 7d0a 2020 2020 2020 2020 7365 6c66   {}.        self
+0000cf20: 2e70 6172 616d 6574 6572 735f 6e74 7420  .parameters_ntt 
+0000cf30: 3d20 7b7d 0a0a 2020 2020 2020 2020 2320  = {}..        # 
+0000cf40: 636f 6d62 696e 6564 2067 6c6f 6261 6c20  combined global 
+0000cf50: 7061 7261 6d65 7465 7273 0a20 2020 2020  parameters.     
+0000cf60: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
+0000cf70: 7273 5f67 6c6f 6261 6c20 3d20 7b7d 0a0a  rs_global = {}..
+0000cf80: 2020 2020 2020 2020 2320 5363 616e 6e69          # Scanni
+0000cf90: 6e67 2073 6573 7369 6f6e 2064 6972 6563  ng session direc
+0000cfa0: 746f 7279 2066 6f72 2072 6563 6f72 6465  tory for recorde
+0000cfb0: 6420 6669 6c65 730a 2020 2020 2020 2020  d files.        
+0000cfc0: 7365 6c66 2e73 6573 7369 6f6e 6669 6c65  self.sessionfile
+0000cfd0: 7320 3d20 5b66 2066 6f72 2066 2069 6e20  s = [f for f in 
+0000cfe0: 6c69 7374 6469 7228 7365 6c66 2e73 6573  listdir(self.ses
+0000cff0: 7369 6f6e 6469 7229 2069 660a 2020 2020  siondir) if.    
+0000d000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d010: 2020 2020 2020 2020 2069 7366 696c 6528           isfile(
+0000d020: 6f73 2e70 6174 682e 6a6f 696e 2873 656c  os.path.join(sel
+0000d030: 662e 7365 7373 696f 6e64 6972 2c20 6629  f.sessiondir, f)
+0000d040: 295d 0a0a 2020 2020 2020 2020 2320 4c69  )]..        # Li
+0000d050: 7374 696e 6720 6176 6169 6c61 626c 6520  sting available 
+0000d060: 6669 6c65 730a 2020 2020 2020 2020 7365  files.        se
+0000d070: 6c66 2e6e 6373 5f61 7661 696c 203d 205b  lf.ncs_avail = [
+0000d080: 5d0a 2020 2020 2020 2020 7365 6c66 2e6e  ].        self.n
+0000d090: 7365 5f61 7661 696c 203d 205b 5d0a 2020  se_avail = [].  
+0000d0a0: 2020 2020 2020 7365 6c66 2e6e 6576 5f61        self.nev_a
+0000d0b0: 7661 696c 203d 205b 5d0a 2020 2020 2020  vail = [].      
+0000d0c0: 2020 7365 6c66 2e6e 7474 5f61 7661 696c    self.ntt_avail
+0000d0d0: 203d 205b 5d0a 0a20 2020 2020 2020 2023   = []..        #
+0000d0e0: 204c 6973 7469 6e67 2061 7373 6f63 6961   Listing associa
+0000d0f0: 7465 6420 283d 6e6f 6e20 636f 7272 7570  ted (=non corrup
+0000d100: 7465 642c 206e 6f6e 2065 6d70 7479 2066  ted, non empty f
+0000d110: 696c 6573 290a 2020 2020 2020 2020 7365  iles).        se
+0000d120: 6c66 2e6e 6373 5f61 7373 6f20 3d20 5b5d  lf.ncs_asso = []
+0000d130: 0a20 2020 2020 2020 2073 656c 662e 6e73  .        self.ns
+0000d140: 655f 6173 736f 203d 205b 5d0a 2020 2020  e_asso = [].    
+0000d150: 2020 2020 7365 6c66 2e6e 6576 5f61 7373      self.nev_ass
+0000d160: 6f20 3d20 5b5d 0a20 2020 2020 2020 2073  o = [].        s
+0000d170: 656c 662e 6e74 745f 6173 736f 203d 205b  elf.ntt_asso = [
+0000d180: 5d0a 0a20 2020 2020 2020 2069 6620 7573  ]..        if us
+0000d190: 6563 6163 6865 206e 6f74 2069 6e20 5b27  ecache not in ['
+0000d1a0: 6861 7368 272c 2027 616c 7761 7973 272c  hash', 'always',
+0000d1b0: 2027 6461 7465 7369 7a65 272c 2027 6e65   'datesize', 'ne
+0000d1c0: 7665 7227 5d3a 0a20 2020 2020 2020 2020  ver']:.         
+0000d1d0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+0000d1e0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+0000d1f0: 2020 2020 2022 4172 6775 6d65 6e74 2076       "Argument v
+0000d200: 616c 7565 206f 6620 7573 6563 6163 6865  alue of usecache
+0000d210: 2027 2573 2720 6973 206e 6f74 2076 616c   '%s' is not val
+0000d220: 6964 2e20 4163 6365 7074 6564 2022 0a20  id. Accepted ". 
+0000d230: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000d240: 7661 6c75 6573 2061 7265 2027 6861 7368  values are 'hash
+0000d250: 272c 2761 6c77 6179 7327 2c27 6461 7465  ','always','date
+0000d260: 7369 7a65 272c 276e 6576 6572 2722 2025  size','never'" %
+0000d270: 2075 7365 6361 6368 6529 0a0a 2020 2020   usecache)..    
+0000d280: 2020 2020 6966 2063 6163 6865 6469 7220      if cachedir 
+0000d290: 6973 204e 6f6e 6520 616e 6420 7573 6563  is None and usec
+0000d2a0: 6163 6865 2021 3d20 276e 6576 6572 273a  ache != 'never':
+0000d2b0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+0000d2c0: 7365 2056 616c 7565 4572 726f 7228 274e  se ValueError('N
+0000d2d0: 6f20 6361 6368 6520 6469 7265 6374 6f72  o cache director
+0000d2e0: 7920 7072 6f76 6964 6564 2e27 290a 0a20  y provided.').. 
+0000d2f0: 2020 2020 2020 2023 2063 6865 636b 2069         # check i
+0000d300: 6620 7468 6572 6520 6172 6520 616e 7920  f there are any 
+0000d310: 6368 616e 6765 7320 6f66 2074 6865 2064  changes of the d
+0000d320: 6174 6120 6669 6c65 7320 2d3e 206e 6577  ata files -> new
+0000d330: 2064 6174 6120 6368 6563 6b20 7275 6e0a   data check run.
+0000d340: 2020 2020 2020 2020 6368 6563 6b5f 6669          check_fi
+0000d350: 6c65 7320 3d20 5472 7565 2069 6620 7573  les = True if us
+0000d360: 6563 6163 6865 2021 3d20 2761 6c77 6179  ecache != 'alway
+0000d370: 7327 2065 6c73 6520 4661 6c73 6520 2023  s' else False  #
+0000d380: 206e 6576 6572 0a20 2020 2020 2020 2023   never.        #
+0000d390: 2063 6865 636b 696e 6720 6669 6c65 7320   checking files 
+0000d3a0: 6966 2075 7365 6361 6368 653d 3d27 616c  if usecache=='al
+0000d3b0: 7761 7973 270a 2020 2020 2020 2020 6966  ways'.        if
+0000d3c0: 2063 6163 6865 6469 7220 6973 206e 6f74   cachedir is not
+0000d3d0: 204e 6f6e 6520 616e 6420 7573 6563 6163   None and usecac
+0000d3e0: 6865 2021 3d20 276e 6576 6572 273a 0a0a  he != 'never':..
+0000d3f0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000d400: 2e5f 6469 6167 6e6f 7374 6963 5f70 7269  ._diagnostic_pri
+0000d410: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
+0000d420: 2020 2020 2743 616c 6375 6c61 7469 6e67      'Calculating
+0000d430: 2025 7320 6f66 2073 6573 7369 6f6e 2066   %s of session f
+0000d440: 696c 6573 2074 6f20 6368 6563 6b20 666f  iles to check fo
+0000d450: 7220 6361 6368 6564 2027 0a20 2020 2020  r cached '.     
+0000d460: 2020 2020 2020 2020 2020 2027 7061 7261             'para
+0000d470: 6d65 7465 7220 6669 6c65 732e 2720 2520  meter files.' % 
+0000d480: 7573 6563 6163 6865 290a 2020 2020 2020  usecache).      
+0000d490: 2020 2020 2020 6361 6368 6566 696c 6520        cachefile 
+0000d4a0: 3d20 6361 6368 6564 6972 202b 2073 6570  = cachedir + sep
+0000d4b0: 202b 2073 656c 662e 7365 7373 696f 6e64   + self.sessiond
+0000d4c0: 6972 2e73 706c 6974 2873 6570 295b 0a20  ir.split(sep)[. 
+0000d4d0: 2020 2020 2020 2020 2020 2020 2020 202d                 -
+0000d4e0: 315d 202b 2027 2f68 6173 686b 6579 7327  1] + '/hashkeys'
+0000d4f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000d500: 6e6f 7420 6f73 2e70 6174 682e 6578 6973  not os.path.exis
+0000d510: 7473 2863 6163 6865 6469 7220 2b20 7365  ts(cachedir + se
+0000d520: 7020 2b20 7365 6c66 2e73 6573 7369 6f6e  p + self.session
+0000d530: 6469 722e 7370 6c69 7428 7365 7029 5b2d  dir.split(sep)[-
+0000d540: 315d 293a 0a20 2020 2020 2020 2020 2020  1]):.           
+0000d550: 2020 2020 206f 732e 6d61 6b65 6469 7273       os.makedirs
+0000d560: 2863 6163 6865 6469 7220 2b20 7365 7020  (cachedir + sep 
+0000d570: 2b20 7365 6c66 2e73 6573 7369 6f6e 6469  + self.sessiondi
+0000d580: 722e 7370 6c69 7428 7365 7029 5b2d 315d  r.split(sep)[-1]
+0000d590: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
+0000d5a0: 6620 7573 6563 6163 6865 203d 3d20 2768  f usecache == 'h
+0000d5b0: 6173 6827 3a0a 2020 2020 2020 2020 2020  ash':.          
+0000d5c0: 2020 2020 2020 6861 7368 6573 5f63 616c        hashes_cal
+0000d5d0: 6320 3d20 7b7d 0a20 2020 2020 2020 2020  c = {}.         
+0000d5e0: 2020 2020 2020 2023 2063 616c 6375 6c61         # calcula
+0000d5f0: 7465 7320 6861 7368 206f 6620 616c 6c20  tes hash of all 
+0000d600: 6176 6169 6c61 626c 6520 6669 6c65 730a  available files.
+0000d610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d620: 666f 7220 6620 696e 2073 656c 662e 7365  for f in self.se
+0000d630: 7373 696f 6e66 696c 6573 3a0a 2020 2020  ssionfiles:.    
+0000d640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d650: 6669 6c65 5f68 6173 6820 3d20 7365 6c66  file_hash = self
+0000d660: 2e68 6173 6866 696c 6528 6f70 656e 2873  .hashfile(open(s
+0000d670: 656c 662e 7365 7373 696f 6e64 6972 202b  elf.sessiondir +
+0000d680: 2073 6570 202b 2066 2c0a 2020 2020 2020   sep + f,.      
+0000d690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6b0: 2020 2020 2020 2020 2020 2020 2027 7262               'rb
+0000d6c0: 2729 2c20 6861 7368 6c69 622e 7368 6132  '), hashlib.sha2
+0000d6d0: 3536 2829 290a 2020 2020 2020 2020 2020  56()).          
+0000d6e0: 2020 2020 2020 2020 2020 6861 7368 6573            hashes
+0000d6f0: 5f63 616c 635b 665d 203d 2066 696c 655f  _calc[f] = file_
+0000d700: 6861 7368 0a20 2020 2020 2020 2020 2020  hash.           
+0000d710: 2065 6c69 6620 7573 6563 6163 6865 203d   elif usecache =
+0000d720: 3d20 2764 6174 6573 697a 6527 3a0a 2020  = 'datesize':.  
+0000d730: 2020 2020 2020 2020 2020 2020 2020 6861                ha
+0000d740: 7368 6573 5f63 616c 6320 3d20 7b7d 0a20  shes_calc = {}. 
+0000d750: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000d760: 6f72 2066 2069 6e20 7365 6c66 2e73 6573  or f in self.ses
+0000d770: 7369 6f6e 6669 6c65 733a 0a20 2020 2020  sionfiles:.     
+0000d780: 2020 2020 2020 2020 2020 2020 2020 2068                 h
+0000d790: 6173 6865 735f 6361 6c63 5b66 5d20 3d20  ashes_calc[f] = 
+0000d7a0: 7365 6c66 2e64 6174 6573 697a 6566 696c  self.datesizefil
+0000d7b0: 6528 0a20 2020 2020 2020 2020 2020 2020  e(.             
+0000d7c0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000d7d0: 7365 7373 696f 6e64 6972 202b 2073 6570  sessiondir + sep
+0000d7e0: 202b 2066 290a 0a20 2020 2020 2020 2020   + f)..         
+0000d7f0: 2020 2023 206c 6f61 6420 6861 7368 6573     # load hashes
+0000d800: 2073 6176 6564 2066 6f72 2074 6869 7320   saved for this 
+0000d810: 7365 7373 696f 6e20 696e 2061 6e20 6561  session in an ea
+0000d820: 726c 6965 7220 6c6f 6164 696e 6720 7275  rlier loading ru
+0000d830: 6e0a 2020 2020 2020 2020 2020 2020 6966  n.            if
+0000d840: 206f 732e 7061 7468 2e65 7869 7374 7328   os.path.exists(
+0000d850: 6361 6368 6566 696c 6529 3a0a 2020 2020  cachefile):.    
+0000d860: 2020 2020 2020 2020 2020 2020 6861 7368              hash
+0000d870: 6573 5f72 6561 6420 3d20 7069 636b 6c65  es_read = pickle
+0000d880: 2e6c 6f61 6428 6f70 656e 2863 6163 6865  .load(open(cache
+0000d890: 6669 6c65 2c20 2772 6227 2929 0a20 2020  file, 'rb')).   
+0000d8a0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000d8b0: 2020 2020 2020 2020 2020 2020 2020 2068                 h
+0000d8c0: 6173 6865 735f 7265 6164 203d 207b 7d0a  ashes_read = {}.
+0000d8d0: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
+0000d8e0: 6f6d 7061 7265 2068 6173 6865 7320 746f  ompare hashes to
+0000d8f0: 2070 7265 7669 6f75 736c 7920 7361 7665   previously save
+0000d900: 6420 6d65 7461 2064 6174 6120 756e 6420  d meta data und 
+0000d910: 6c6f 6164 206d 6574 6120 6461 7461 0a20  load meta data. 
+0000d920: 2020 2020 2020 2020 2020 2023 2020 6966             #  if
+0000d930: 206e 6f20 6368 616e 6765 7320 6f63 6375   no changes occu
+0000d940: 7265 640a 2020 2020 2020 2020 2020 2020  red.            
+0000d950: 6966 2075 7365 6361 6368 6520 3d3d 2027  if usecache == '
+0000d960: 616c 7761 7973 2720 6f72 2061 6c6c 285b  always' or all([
+0000d970: 6620 696e 2068 6173 6865 735f 6361 6c63  f in hashes_calc
+0000d980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9a0: 2020 2020 2020 2020 2020 2020 2061 6e64               and
+0000d9b0: 2066 2069 6e20 6861 7368 6573 5f72 6561   f in hashes_rea
+0000d9c0: 640a 2020 2020 2020 2020 2020 2020 2020  d.              
+0000d9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9e0: 2020 2020 2020 2020 2020 2020 2020 616e                an
+0000d9f0: 6420 6861 7368 6573 5f63 616c 635b 665d  d hashes_calc[f]
+0000da00: 203d 3d20 6861 7368 6573 5f72 6561 645b   == hashes_read[
+0000da10: 665d 0a20 2020 2020 2020 2020 2020 2020  f].             
+0000da20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da30: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000da40: 6f72 2066 2069 6e20 7365 6c66 2e73 6573  or f in self.ses
+0000da50: 7369 6f6e 6669 6c65 735d 293a 0a20 2020  sionfiles]):.   
+0000da60: 2020 2020 2020 2020 2020 2020 2063 6865               che
+0000da70: 636b 5f66 696c 6573 203d 2046 616c 7365  ck_files = False
+0000da80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000da90: 2073 656c 662e 5f64 6961 676e 6f73 7469   self._diagnosti
+0000daa0: 635f 7072 696e 7428 0a20 2020 2020 2020  c_print(.       
+0000dab0: 2020 2020 2020 2020 2020 2020 2027 5573               'Us
+0000dac0: 696e 6720 6361 6368 6564 206d 6574 6164  ing cached metad
+0000dad0: 6174 6120 6672 6f6d 2065 6172 6c69 6572  ata from earlier
+0000dae0: 2061 6e61 6c79 7369 7320 7275 6e20 696e   analysis run in
+0000daf0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+0000db00: 2020 2020 2020 2027 6669 6c65 2027 0a20         'file '. 
+0000db10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db20: 2020 2027 2573 2e20 536b 6970 7069 6e67     '%s. Skipping
+0000db30: 2066 696c 6520 6368 6563 6b73 2e27 2025   file checks.' %
+0000db40: 2063 6163 6865 6669 6c65 290a 0a20 2020   cachefile)..   
+0000db50: 2020 2020 2020 2020 2020 2020 2023 206c               # l
+0000db60: 6f61 6469 6e67 2073 6176 6564 2070 6172  oading saved par
+0000db70: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+0000db80: 2020 2020 2020 2020 7061 7261 6d65 7465          paramete
+0000db90: 7266 696c 6520 3d20 6361 6368 6564 6972  rfile = cachedir
+0000dba0: 202b 2073 6570 202b 2073 656c 662e 7365   + sep + self.se
+0000dbb0: 7373 696f 6e64 6972 2e73 706c 6974 2873  ssiondir.split(s
+0000dbc0: 6570 295b 0a20 2020 2020 2020 2020 2020  ep)[.           
+0000dbd0: 2020 2020 2020 2020 202d 315d 202b 2027           -1] + '
+0000dbe0: 2f70 6172 616d 6574 6572 732e 6361 6368  /parameters.cach
+0000dbf0: 6527 0a20 2020 2020 2020 2020 2020 2020  e'.             
+0000dc00: 2020 2069 6620 6f73 2e70 6174 682e 6578     if os.path.ex
+0000dc10: 6973 7473 2870 6172 616d 6574 6572 6669  ists(parameterfi
+0000dc20: 6c65 293a 0a20 2020 2020 2020 2020 2020  le):.           
+0000dc30: 2020 2020 2020 2020 2070 6172 616d 6574           paramet
+0000dc40: 6572 735f 7265 6164 203d 2070 6963 6b6c  ers_read = pickl
+0000dc50: 652e 6c6f 6164 286f 7065 6e28 7061 7261  e.load(open(para
+0000dc60: 6d65 7465 7266 696c 652c 2027 7262 2729  meterfile, 'rb')
+0000dc70: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000dc80: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000dc90: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+0000dca0: 6520 4f53 4572 726f 7228 2749 6e63 6f6e  e OSError('Incon
+0000dcb0: 7369 7374 656e 7420 6361 6368 6520 6669  sistent cache fi
+0000dcc0: 6c65 732e 2729 0a0a 2020 2020 2020 2020  les.')..        
+0000dcd0: 2020 2020 2020 2020 666f 7220 494f 6469          for IOdi
+0000dce0: 6374 2c20 6469 6374 6e61 6d65 2069 6e20  ct, dictname in 
+0000dcf0: 5b28 7365 6c66 2e70 6172 616d 6574 6572  [(self.parameter
+0000dd00: 735f 676c 6f62 616c 2c20 2767 6c6f 6261  s_global, 'globa
+0000dd10: 6c27 292c 0a20 2020 2020 2020 2020 2020  l'),.           
+0000dd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd30: 2020 2020 2020 2020 2020 2020 2020 2873                (s
+0000dd40: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+0000dd50: 6373 2c20 276e 6373 2729 2c0a 2020 2020  cs, 'ncs'),.    
+0000dd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd80: 2020 2020 2028 7365 6c66 2e70 6172 616d       (self.param
+0000dd90: 6574 6572 735f 6e73 652c 2027 6e73 6527  eters_nse, 'nse'
+0000dda0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0000ddb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ddc0: 2020 2020 2020 2020 2020 2020 2873 656c              (sel
+0000ddd0: 662e 7061 7261 6d65 7465 7273 5f6e 6576  f.parameters_nev
+0000dde0: 2c20 276e 6576 2729 2c0a 2020 2020 2020  , 'nev'),.      
+0000ddf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000de00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de10: 7365 6c66 2e6e 6576 5f61 7373 6f20 3d20  self.nev_asso = 
-0000de20: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-0000de30: 6e65 762e 6b65 7973 2829 0a20 2020 2020  nev.keys().     
-0000de40: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000de50: 6e63 735f 6173 736f 203d 205b 7661 6c5b  ncs_asso = [val[
-0000de60: 2766 696c 656e 616d 6527 5d20 666f 7220  'filename'] for 
-0000de70: 7661 6c20 696e 0a20 2020 2020 2020 2020  val in.         
-0000de80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de90: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-0000dea0: 616d 6574 6572 735f 6e63 732e 7661 6c75  ameters_ncs.valu
-0000deb0: 6573 2829 5d0a 2020 2020 2020 2020 2020  es()].          
-0000dec0: 2020 2020 2020 7365 6c66 2e6e 7365 5f61        self.nse_a
-0000ded0: 7373 6f20 3d20 5b76 616c 5b27 6669 6c65  sso = [val['file
-0000dee0: 6e61 6d65 275d 2066 6f72 2076 616c 2069  name'] for val i
-0000def0: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
-0000df00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df10: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
-0000df20: 7273 5f6e 7365 2e76 616c 7565 7328 295d  rs_nse.values()]
-0000df30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000df40: 2073 656c 662e 6e74 745f 6173 736f 203d   self.ntt_asso =
-0000df50: 205b 7661 6c5b 2766 696c 656e 616d 6527   [val['filename'
-0000df60: 5d20 666f 7220 7661 6c20 696e 0a20 2020  ] for val in.   
+0000de10: 2020 2028 7365 6c66 2e70 6172 616d 6574     (self.paramet
+0000de20: 6572 735f 6e74 742c 2027 6e74 7427 295d  ers_ntt, 'ntt')]
+0000de30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000de40: 2020 2020 2020 494f 6469 6374 2e75 7064        IOdict.upd
+0000de50: 6174 6528 7061 7261 6d65 7465 7273 5f72  ate(parameters_r
+0000de60: 6561 645b 6469 6374 6e61 6d65 5d29 0a20  ead[dictname]). 
+0000de70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000de80: 656c 662e 6e65 765f 6173 736f 203d 2073  elf.nev_asso = s
+0000de90: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+0000dea0: 6576 2e6b 6579 7328 290a 2020 2020 2020  ev.keys().      
+0000deb0: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
+0000dec0: 6373 5f61 7373 6f20 3d20 5b76 616c 5b27  cs_asso = [val['
+0000ded0: 6669 6c65 6e61 6d65 275d 2066 6f72 2076  filename'] for v
+0000dee0: 616c 2069 6e0a 2020 2020 2020 2020 2020  al in.          
+0000def0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df00: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
+0000df10: 6d65 7465 7273 5f6e 6373 2e76 616c 7565  meters_ncs.value
+0000df20: 7328 295d 0a20 2020 2020 2020 2020 2020  s()].           
+0000df30: 2020 2020 2073 656c 662e 6e73 655f 6173       self.nse_as
+0000df40: 736f 203d 205b 7661 6c5b 2766 696c 656e  so = [val['filen
+0000df50: 616d 6527 5d20 666f 7220 7661 6c20 696e  ame'] for val in
+0000df60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0000df70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df80: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000df90: 6c66 2e70 6172 616d 6574 6572 735f 6e74  lf.parameters_nt
-0000dfa0: 742e 7661 6c75 6573 2829 5d0a 0a20 2020  t.values()]..   
-0000dfb0: 2020 2020 2066 6f72 2066 696c 656e 616d       for filenam
-0000dfc0: 6520 696e 2073 656c 662e 7365 7373 696f  e in self.sessio
-0000dfd0: 6e66 696c 6573 3a0a 2020 2020 2020 2020  nfiles:.        
-0000dfe0: 2020 2020 2320 4578 7472 6163 7469 6e67      # Extracting
-0000dff0: 206f 6e6c 7920 636f 6e74 696e 756f 7573   only continuous
-0000e000: 2073 6967 6e61 6c20 6669 6c65 7320 282e   signal files (.
-0000e010: 6e63 7329 0a20 2020 2020 2020 2020 2020  ncs).           
-0000e020: 2069 6620 6669 6c65 6e61 6d65 5b2d 343a   if filename[-4:
-0000e030: 5d20 3d3d 2027 2e6e 6373 273a 0a20 2020  ] == '.ncs':.   
-0000e040: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000e050: 662e 6e63 735f 6176 6169 6c2e 6170 7065  f.ncs_avail.appe
-0000e060: 6e64 2866 696c 656e 616d 6529 0a20 2020  nd(filename).   
-0000e070: 2020 2020 2020 2020 2065 6c69 6620 6669           elif fi
-0000e080: 6c65 6e61 6d65 5b2d 343a 5d20 3d3d 2027  lename[-4:] == '
-0000e090: 2e6e 7365 273a 0a20 2020 2020 2020 2020  .nse':.         
-0000e0a0: 2020 2020 2020 2073 656c 662e 6e73 655f         self.nse_
-0000e0b0: 6176 6169 6c2e 6170 7065 6e64 2866 696c  avail.append(fil
-0000e0c0: 656e 616d 6529 0a20 2020 2020 2020 2020  ename).         
-0000e0d0: 2020 2065 6c69 6620 6669 6c65 6e61 6d65     elif filename
-0000e0e0: 5b2d 343a 5d20 3d3d 2027 2e6e 6576 273a  [-4:] == '.nev':
-0000e0f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e100: 2073 656c 662e 6e65 765f 6176 6169 6c2e   self.nev_avail.
-0000e110: 6170 7065 6e64 2866 696c 656e 616d 6529  append(filename)
-0000e120: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-0000e130: 6620 6669 6c65 6e61 6d65 5b2d 343a 5d20  f filename[-4:] 
-0000e140: 3d3d 2027 2e6e 7474 273a 0a20 2020 2020  == '.ntt':.     
-0000e150: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000e160: 6e74 745f 6176 6169 6c2e 6170 7065 6e64  ntt_avail.append
-0000e170: 2866 696c 656e 616d 6529 0a20 2020 2020  (filename).     
-0000e180: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000e190: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000e1a0: 662e 5f64 6961 676e 6f73 7469 635f 7072  f._diagnostic_pr
-0000e1b0: 696e 7428 0a20 2020 2020 2020 2020 2020  int(.           
-0000e1c0: 2020 2020 2020 2020 2027 4967 6e6f 7269           'Ignori
-0000e1d0: 6e67 2066 696c 6520 6f66 2075 6e6b 6e6f  ng file of unkno
-0000e1e0: 776e 2064 6174 6120 7479 7065 2025 7327  wn data type %s'
-0000e1f0: 2025 2066 696c 656e 616d 6529 0a0a 2020   % filename)..  
-0000e200: 2020 2020 2020 6966 2063 6865 636b 5f66        if check_f
-0000e210: 696c 6573 3a0a 2020 2020 2020 2020 2020  iles:.          
-0000e220: 2020 7365 6c66 2e5f 6469 6167 6e6f 7374    self._diagnost
-0000e230: 6963 5f70 7269 6e74 2827 5374 6172 7469  ic_print('Starti
-0000e240: 6e67 2069 6e64 6976 6964 7561 6c20 6669  ng individual fi
-0000e250: 6c65 2063 6865 636b 732e 2729 0a20 2020  le checks.').   
-0000e260: 2020 2020 2020 2020 2023 203d 3d3d 3d3d           # =====
-0000e270: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e280: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e290: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e2a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e2b0: 3d3d 0a20 2020 2020 2020 2020 2020 2023  ==.            #
-0000e2c0: 2023 2053 6361 6e20 4e43 5320 6669 6c65   # Scan NCS file
-0000e2d0: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
+0000df80: 2020 7365 6c66 2e70 6172 616d 6574 6572    self.parameter
+0000df90: 735f 6e73 652e 7661 6c75 6573 2829 5d0a  s_nse.values()].
+0000dfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfb0: 7365 6c66 2e6e 7474 5f61 7373 6f20 3d20  self.ntt_asso = 
+0000dfc0: 5b76 616c 5b27 6669 6c65 6e61 6d65 275d  [val['filename']
+0000dfd0: 2066 6f72 2076 616c 2069 6e0a 2020 2020   for val in.    
+0000dfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dff0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000e000: 662e 7061 7261 6d65 7465 7273 5f6e 7474  f.parameters_ntt
+0000e010: 2e76 616c 7565 7328 295d 0a0a 2020 2020  .values()]..    
+0000e020: 2020 2020 666f 7220 6669 6c65 6e61 6d65      for filename
+0000e030: 2069 6e20 7365 6c66 2e73 6573 7369 6f6e   in self.session
+0000e040: 6669 6c65 733a 0a20 2020 2020 2020 2020  files:.         
+0000e050: 2020 2023 2045 7874 7261 6374 696e 6720     # Extracting 
+0000e060: 6f6e 6c79 2063 6f6e 7469 6e75 6f75 7320  only continuous 
+0000e070: 7369 676e 616c 2066 696c 6573 2028 2e6e  signal files (.n
+0000e080: 6373 290a 2020 2020 2020 2020 2020 2020  cs).            
+0000e090: 6966 2066 696c 656e 616d 655b 2d34 3a5d  if filename[-4:]
+0000e0a0: 203d 3d20 272e 6e63 7327 3a0a 2020 2020   == '.ncs':.    
+0000e0b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000e0c0: 2e6e 6373 5f61 7661 696c 2e61 7070 656e  .ncs_avail.appen
+0000e0d0: 6428 6669 6c65 6e61 6d65 290a 2020 2020  d(filename).    
+0000e0e0: 2020 2020 2020 2020 656c 6966 2066 696c          elif fil
+0000e0f0: 656e 616d 655b 2d34 3a5d 203d 3d20 272e  ename[-4:] == '.
+0000e100: 6e73 6527 3a0a 2020 2020 2020 2020 2020  nse':.          
+0000e110: 2020 2020 2020 7365 6c66 2e6e 7365 5f61        self.nse_a
+0000e120: 7661 696c 2e61 7070 656e 6428 6669 6c65  vail.append(file
+0000e130: 6e61 6d65 290a 2020 2020 2020 2020 2020  name).          
+0000e140: 2020 656c 6966 2066 696c 656e 616d 655b    elif filename[
+0000e150: 2d34 3a5d 203d 3d20 272e 6e65 7627 3a0a  -4:] == '.nev':.
+0000e160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e170: 7365 6c66 2e6e 6576 5f61 7661 696c 2e61  self.nev_avail.a
+0000e180: 7070 656e 6428 6669 6c65 6e61 6d65 290a  ppend(filename).
+0000e190: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+0000e1a0: 2066 696c 656e 616d 655b 2d34 3a5d 203d   filename[-4:] =
+0000e1b0: 3d20 272e 6e74 7427 3a0a 2020 2020 2020  = '.ntt':.      
+0000e1c0: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
+0000e1d0: 7474 5f61 7661 696c 2e61 7070 656e 6428  tt_avail.append(
+0000e1e0: 6669 6c65 6e61 6d65 290a 2020 2020 2020  filename).      
+0000e1f0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000e200: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000e210: 2e5f 6469 6167 6e6f 7374 6963 5f70 7269  ._diagnostic_pri
+0000e220: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
+0000e230: 2020 2020 2020 2020 2749 676e 6f72 696e          'Ignorin
+0000e240: 6720 6669 6c65 206f 6620 756e 6b6e 6f77  g file of unknow
+0000e250: 6e20 6461 7461 2074 7970 6520 2573 2720  n data type %s' 
+0000e260: 2520 6669 6c65 6e61 6d65 290a 0a20 2020  % filename)..   
+0000e270: 2020 2020 2069 6620 6368 6563 6b5f 6669       if check_fi
+0000e280: 6c65 733a 0a20 2020 2020 2020 2020 2020  les:.           
+0000e290: 2073 656c 662e 5f64 6961 676e 6f73 7469   self._diagnosti
+0000e2a0: 635f 7072 696e 7428 2753 7461 7274 696e  c_print('Startin
+0000e2b0: 6720 696e 6469 7669 6475 616c 2066 696c  g individual fil
+0000e2c0: 6520 6368 6563 6b73 2e27 290a 2020 2020  e checks.').    
+0000e2d0: 2020 2020 2020 2020 2320 3d3d 3d3d 3d3d          # ======
 0000e2e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000e2f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000e300: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000e310: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e320: 3d3d 3d3d 3d3d 3d0a 0a20 2020 2020 2020  =======..       
-0000e330: 2020 2020 2073 656c 662e 5f64 6961 676e       self._diagn
-0000e340: 6f73 7469 635f 7072 696e 7428 0a20 2020  ostic_print(.   
-0000e350: 2020 2020 2020 2020 2020 2020 2027 5c6e               '\n
-0000e360: 4465 7465 6374 6564 2025 6920 2e6e 6373  Detected %i .ncs
-0000e370: 2066 696c 6528 7329 2e27 2025 2028 6c65   file(s).' % (le
-0000e380: 6e28 7365 6c66 2e6e 6373 5f61 7661 696c  n(self.ncs_avail
-0000e390: 2929 290a 0a20 2020 2020 2020 2020 2020  )))..           
-0000e3a0: 2066 6f72 206e 6373 5f66 696c 6520 696e   for ncs_file in
-0000e3b0: 2073 656c 662e 6e63 735f 6176 6169 6c3a   self.ncs_avail:
-0000e3c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e3d0: 2023 204c 6f61 6469 6e67 2069 6e64 6976   # Loading indiv
-0000e3e0: 6964 7561 6c20 4e43 5320 6669 6c65 2061  idual NCS file a
-0000e3f0: 6e64 2065 7874 7261 6374 696e 6720 7061  nd extracting pa
-0000e400: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
-0000e410: 2020 2020 2020 2020 2073 656c 662e 5f64           self._d
-0000e420: 6961 676e 6f73 7469 635f 7072 696e 7428  iagnostic_print(
-0000e430: 2253 6361 6e6e 696e 6720 2220 2b20 6e63  "Scanning " + nc
-0000e440: 735f 6669 6c65 202b 2022 2e22 290a 0a20  s_file + ".").. 
-0000e450: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000e460: 2052 6561 6469 6e67 2066 696c 6520 7061   Reading file pa
-0000e470: 636b 6574 2068 6561 6465 7273 0a20 2020  cket headers.   
-0000e480: 2020 2020 2020 2020 2020 2020 2066 696c               fil
-0000e490: 6568 616e 646c 6520 3d20 7365 6c66 2e5f  ehandle = self._
-0000e4a0: 5f6d 6d61 705f 6e63 735f 7061 636b 6574  _mmap_ncs_packet
-0000e4b0: 5f68 6561 6465 7273 286e 6373 5f66 696c  _headers(ncs_fil
-0000e4c0: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-0000e4d0: 2020 2069 6620 6669 6c65 6861 6e64 6c65     if filehandle
-0000e4e0: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-0000e4f0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0000e500: 6e74 696e 7565 0a0a 2020 2020 2020 2020  ntinue..        
-0000e510: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-0000e520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e530: 2023 2043 6865 636b 696e 6720 636f 6e73   # Checking cons
-0000e540: 6973 7465 6e63 7920 6f66 206e 6373 2066  istency of ncs f
-0000e550: 696c 650a 2020 2020 2020 2020 2020 2020  ile.            
-0000e560: 2020 2020 2020 2020 7365 6c66 2e5f 5f6e          self.__n
-0000e570: 6373 5f70 6163 6b65 745f 6368 6563 6b28  cs_packet_check(
-0000e580: 6669 6c65 6861 6e64 6c65 290a 2020 2020  filehandle).    
-0000e590: 2020 2020 2020 2020 2020 2020 6578 6365              exce
-0000e5a0: 7074 2041 7373 6572 7469 6f6e 4572 726f  pt AssertionErro
-0000e5b0: 723a 0a20 2020 2020 2020 2020 2020 2020  r:.             
-0000e5c0: 2020 2020 2020 2077 6172 6e69 6e67 732e         warnings.
-0000e5d0: 7761 726e 280a 2020 2020 2020 2020 2020  warn(.          
-0000e5e0: 2020 2020 2020 2020 2020 2020 2020 2753                'S
-0000e5f0: 6573 7369 6f6e 2066 696c 6520 2573 2064  ession file %s d
-0000e600: 6964 206e 6f74 2070 6173 7320 6461 7461  id not pass data
-0000e610: 2070 6163 6b65 7420 6368 6563 6b2e 2027   packet check. '
-0000e620: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e630: 2020 2020 2020 2020 2027 5468 6973 2066           'This f
-0000e640: 696c 6520 6361 6e20 6e6f 7420 6265 206c  ile can not be l
-0000e650: 6f61 6465 642e 2720 2520 6e63 735f 6669  oaded.' % ncs_fi
-0000e660: 6c65 290a 2020 2020 2020 2020 2020 2020  le).            
-0000e670: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
-0000e680: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e690: 2020 2320 5265 6164 696e 6720 6461 7461    # Reading data
-0000e6a0: 2070 6163 6b65 7420 6865 6164 6572 2069   packet header i
-0000e6b0: 6e66 6f72 6d61 7469 6f6e 2061 6e64 2073  nformation and s
-0000e6c0: 746f 7265 2074 6865 6d20 696e 0a20 2020  tore them in.   
-0000e6d0: 2020 2020 2020 2020 2020 2020 2023 2070               # p
-0000e6e0: 6172 616d 6574 6572 735f 6e63 730a 2020  arameters_ncs.  
-0000e6f0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000e700: 6c66 2e5f 5f72 6561 645f 6e63 735f 6461  lf.__read_ncs_da
-0000e710: 7461 5f68 6561 6465 7273 2866 696c 6568  ta_headers(fileh
-0000e720: 616e 646c 652c 206e 6373 5f66 696c 6529  andle, ncs_file)
-0000e730: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e740: 2020 2320 5265 6164 696e 6720 7478 7420    # Reading txt 
-0000e750: 6669 6c65 2068 6561 6465 720a 2020 2020  file header.    
-0000e760: 2020 2020 2020 2020 2020 2020 6368 616e              chan
-0000e770: 6e65 6c5f 6964 203d 2073 656c 662e 6765  nel_id = self.ge
-0000e780: 745f 6368 616e 6e65 6c5f 6964 5f62 795f  t_channel_id_by_
-0000e790: 6669 6c65 5f6e 616d 6528 6e63 735f 6669  file_name(ncs_fi
-0000e7a0: 6c65 290a 2020 2020 2020 2020 2020 2020  le).            
-0000e7b0: 2020 2020 7365 6c66 2e5f 5f72 6561 645f      self.__read_
-0000e7c0: 7465 7874 5f68 6561 6465 7228 6e63 735f  text_header(ncs_
-0000e7d0: 6669 6c65 2c0a 2020 2020 2020 2020 2020  file,.          
-0000e7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e7f0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000e800: 6c66 2e70 6172 616d 6574 6572 735f 6e63  lf.parameters_nc
-0000e810: 735b 6368 616e 6e65 6c5f 6964 5d29 0a0a  s[channel_id])..
-0000e820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e830: 2320 4368 6563 6b20 666f 7220 696e 7661  # Check for inva
-0000e840: 6c69 6420 7374 6172 7469 6e67 2074 696d  lid starting tim
-0000e850: 6573 206f 6620 6461 7461 2070 6163 6b65  es of data packe
-0000e860: 7473 2069 6e20 6e63 7320 6669 6c65 0a20  ts in ncs file. 
-0000e870: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000e880: 656c 662e 5f5f 6e63 735f 696e 7661 6c69  elf.__ncs_invali
-0000e890: 645f 6669 7273 745f 7361 6d70 6c65 5f63  d_first_sample_c
-0000e8a0: 6865 636b 2866 696c 6568 616e 646c 6529  heck(filehandle)
-0000e8b0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e8c0: 2020 2320 4368 6563 6b20 6e63 7320 6669    # Check ncs fi
-0000e8d0: 6c65 2066 6f72 2067 6170 730a 2020 2020  le for gaps.    
-0000e8e0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000e8f0: 2e5f 5f6e 6373 5f67 6170 5f63 6865 636b  .__ncs_gap_check
-0000e900: 2866 696c 6568 616e 646c 6529 0a0a 2020  (filehandle)..  
-0000e910: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000e920: 6c66 2e6e 6373 5f61 7373 6f2e 6170 7065  lf.ncs_asso.appe
-0000e930: 6e64 286e 6373 5f66 696c 6529 0a0a 2020  nd(ncs_file)..  
-0000e940: 2020 2020 2020 2020 2020 2320 3d3d 3d3d            # ====
-0000e950: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e960: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e970: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e980: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000e990: 3d3d 3d0a 2020 2020 2020 2020 2020 2020  ===.            
-0000e9a0: 2320 2320 5363 616e 204e 5345 2066 696c  # # Scan NSE fil
-0000e9b0: 6573 0a20 2020 2020 2020 2020 2020 2023  es.            #
-0000e9c0: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+0000e320: 3d0a 2020 2020 2020 2020 2020 2020 2320  =.            # 
+0000e330: 2320 5363 616e 204e 4353 2066 696c 6573  # Scan NCS files
+0000e340: 0a20 2020 2020 2020 2020 2020 2023 203d  .            # =
+0000e350: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000e360: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000e370: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000e380: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000e390: 3d3d 3d3d 3d3d 0a0a 2020 2020 2020 2020  ======..        
+0000e3a0: 2020 2020 7365 6c66 2e5f 6469 6167 6e6f      self._diagno
+0000e3b0: 7374 6963 5f70 7269 6e74 280a 2020 2020  stic_print(.    
+0000e3c0: 2020 2020 2020 2020 2020 2020 275c 6e44              '\nD
+0000e3d0: 6574 6563 7465 6420 2569 202e 6e63 7320  etected %i .ncs 
+0000e3e0: 6669 6c65 2873 292e 2720 2520 286c 656e  file(s).' % (len
+0000e3f0: 2873 656c 662e 6e63 735f 6176 6169 6c29  (self.ncs_avail)
+0000e400: 2929 0a0a 2020 2020 2020 2020 2020 2020  ))..            
+0000e410: 666f 7220 6e63 735f 6669 6c65 2069 6e20  for ncs_file in 
+0000e420: 7365 6c66 2e6e 6373 5f61 7661 696c 3a0a  self.ncs_avail:.
+0000e430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e440: 2320 4c6f 6164 696e 6720 696e 6469 7669  # Loading indivi
+0000e450: 6475 616c 204e 4353 2066 696c 6520 616e  dual NCS file an
+0000e460: 6420 6578 7472 6163 7469 6e67 2070 6172  d extracting par
+0000e470: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+0000e480: 2020 2020 2020 2020 7365 6c66 2e5f 6469          self._di
+0000e490: 6167 6e6f 7374 6963 5f70 7269 6e74 2822  agnostic_print("
+0000e4a0: 5363 616e 6e69 6e67 2022 202b 206e 6373  Scanning " + ncs
+0000e4b0: 5f66 696c 6520 2b20 222e 2229 0a0a 2020  _file + ".")..  
+0000e4c0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000e4d0: 5265 6164 696e 6720 6669 6c65 2070 6163  Reading file pac
+0000e4e0: 6b65 7420 6865 6164 6572 730a 2020 2020  ket headers.    
+0000e4f0: 2020 2020 2020 2020 2020 2020 6669 6c65              file
+0000e500: 6861 6e64 6c65 203d 2073 656c 662e 5f5f  handle = self.__
+0000e510: 6d6d 6170 5f6e 6373 5f70 6163 6b65 745f  mmap_ncs_packet_
+0000e520: 6865 6164 6572 7328 6e63 735f 6669 6c65  headers(ncs_file
+0000e530: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000e540: 2020 6966 2066 696c 6568 616e 646c 6520    if filehandle 
+0000e550: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0000e560: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+0000e570: 7469 6e75 650a 0a20 2020 2020 2020 2020  tinue..         
+0000e580: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+0000e590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e5a0: 2320 4368 6563 6b69 6e67 2063 6f6e 7369  # Checking consi
+0000e5b0: 7374 656e 6379 206f 6620 6e63 7320 6669  stency of ncs fi
+0000e5c0: 6c65 0a20 2020 2020 2020 2020 2020 2020  le.             
+0000e5d0: 2020 2020 2020 2073 656c 662e 5f5f 6e63         self.__nc
+0000e5e0: 735f 7061 636b 6574 5f63 6865 636b 2866  s_packet_check(f
+0000e5f0: 696c 6568 616e 646c 6529 0a20 2020 2020  ilehandle).     
+0000e600: 2020 2020 2020 2020 2020 2065 7863 6570             excep
+0000e610: 7420 4173 7365 7274 696f 6e45 7272 6f72  t AssertionError
+0000e620: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000e630: 2020 2020 2020 7761 726e 696e 6773 2e77        warnings.w
+0000e640: 6172 6e28 0a20 2020 2020 2020 2020 2020  arn(.           
+0000e650: 2020 2020 2020 2020 2020 2020 2027 5365               'Se
+0000e660: 7373 696f 6e20 6669 6c65 2025 7320 6469  ssion file %s di
+0000e670: 6420 6e6f 7420 7061 7373 2064 6174 6120  d not pass data 
+0000e680: 7061 636b 6574 2063 6865 636b 2e20 270a  packet check. '.
+0000e690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6a0: 2020 2020 2020 2020 2754 6869 7320 6669          'This fi
+0000e6b0: 6c65 2063 616e 206e 6f74 2062 6520 6c6f  le can not be lo
+0000e6c0: 6164 6564 2e27 2025 206e 6373 5f66 696c  aded.' % ncs_fil
+0000e6d0: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+0000e6e0: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+0000e6f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e700: 2023 2052 6561 6469 6e67 2064 6174 6120   # Reading data 
+0000e710: 7061 636b 6574 2068 6561 6465 7220 696e  packet header in
+0000e720: 666f 726d 6174 696f 6e20 616e 6420 7374  formation and st
+0000e730: 6f72 6520 7468 656d 2069 6e0a 2020 2020  ore them in.    
+0000e740: 2020 2020 2020 2020 2020 2020 2320 7061              # pa
+0000e750: 7261 6d65 7465 7273 5f6e 6373 0a20 2020  rameters_ncs.   
+0000e760: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000e770: 662e 5f5f 7265 6164 5f6e 6373 5f64 6174  f.__read_ncs_dat
+0000e780: 615f 6865 6164 6572 7328 6669 6c65 6861  a_headers(fileha
+0000e790: 6e64 6c65 2c20 6e63 735f 6669 6c65 290a  ndle, ncs_file).
+0000e7a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e7b0: 2023 2052 6561 6469 6e67 2074 7874 2066   # Reading txt f
+0000e7c0: 696c 6520 6865 6164 6572 0a20 2020 2020  ile header.     
+0000e7d0: 2020 2020 2020 2020 2020 2063 6861 6e6e             chann
+0000e7e0: 656c 5f69 6420 3d20 7365 6c66 2e67 6574  el_id = self.get
+0000e7f0: 5f63 6861 6e6e 656c 5f69 645f 6279 5f66  _channel_id_by_f
+0000e800: 696c 655f 6e61 6d65 286e 6373 5f66 696c  ile_name(ncs_fil
+0000e810: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+0000e820: 2020 2073 656c 662e 5f5f 7265 6164 5f74     self.__read_t
+0000e830: 6578 745f 6865 6164 6572 286e 6373 5f66  ext_header(ncs_f
+0000e840: 696c 652c 0a20 2020 2020 2020 2020 2020  ile,.           
+0000e850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e860: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000e870: 662e 7061 7261 6d65 7465 7273 5f6e 6373  f.parameters_ncs
+0000e880: 5b63 6861 6e6e 656c 5f69 645d 290a 0a20  [channel_id]).. 
+0000e890: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000e8a0: 2043 6865 636b 2066 6f72 2069 6e76 616c   Check for inval
+0000e8b0: 6964 2073 7461 7274 696e 6720 7469 6d65  id starting time
+0000e8c0: 7320 6f66 2064 6174 6120 7061 636b 6574  s of data packet
+0000e8d0: 7320 696e 206e 6373 2066 696c 650a 2020  s in ncs file.  
+0000e8e0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000e8f0: 6c66 2e5f 5f6e 6373 5f69 6e76 616c 6964  lf.__ncs_invalid
+0000e900: 5f66 6972 7374 5f73 616d 706c 655f 6368  _first_sample_ch
+0000e910: 6563 6b28 6669 6c65 6861 6e64 6c65 290a  eck(filehandle).
+0000e920: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e930: 2023 2043 6865 636b 206e 6373 2066 696c   # Check ncs fil
+0000e940: 6520 666f 7220 6761 7073 0a20 2020 2020  e for gaps.     
+0000e950: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000e960: 5f5f 6e63 735f 6761 705f 6368 6563 6b28  __ncs_gap_check(
+0000e970: 6669 6c65 6861 6e64 6c65 290a 0a20 2020  filehandle)..   
+0000e980: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000e990: 662e 6e63 735f 6173 736f 2e61 7070 656e  f.ncs_asso.appen
+0000e9a0: 6428 6e63 735f 6669 6c65 290a 0a20 2020  d(ncs_file)..   
+0000e9b0: 2020 2020 2020 2020 2023 203d 3d3d 3d3d           # =====
+0000e9c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000e9d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000e9e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000e9f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000ea00: 3d3d 3d3d 3d3d 3d3d 0a0a 2020 2020 2020  ========..      
-0000ea10: 2020 2020 2020 2320 4c6f 6164 696e 6720        # Loading 
-0000ea20: 696e 6469 7669 6475 616c 204e 5345 2066  individual NSE f
-0000ea30: 696c 6520 616e 6420 6578 7472 6163 7469  ile and extracti
-0000ea40: 6e67 2070 6172 616d 6574 6572 730a 2020  ng parameters.  
-0000ea50: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
-0000ea60: 6469 6167 6e6f 7374 6963 5f70 7269 6e74  diagnostic_print
-0000ea70: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000ea80: 2020 275c 6e44 6574 6563 7465 6420 2569    '\nDetected %i
-0000ea90: 202e 6e73 6520 6669 6c65 2873 292e 2720   .nse file(s).' 
-0000eaa0: 2520 286c 656e 2873 656c 662e 6e73 655f  % (len(self.nse_
-0000eab0: 6176 6169 6c29 2929 0a0a 2020 2020 2020  avail)))..      
-0000eac0: 2020 2020 2020 666f 7220 6e73 655f 6669        for nse_fi
-0000ead0: 6c65 2069 6e20 7365 6c66 2e6e 7365 5f61  le in self.nse_a
-0000eae0: 7661 696c 3a0a 2020 2020 2020 2020 2020  vail:.          
-0000eaf0: 2020 2020 2020 2320 4c6f 6164 696e 6720        # Loading 
-0000eb00: 696e 6469 7669 6475 616c 204e 5345 2066  individual NSE f
-0000eb10: 696c 6520 616e 6420 6578 7472 6163 7469  ile and extracti
-0000eb20: 6e67 2070 6172 616d 6574 6572 730a 2020  ng parameters.  
-0000eb30: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000eb40: 6c66 2e5f 6469 6167 6e6f 7374 6963 5f70  lf._diagnostic_p
-0000eb50: 7269 6e74 2827 5363 616e 6e69 6e67 2027  rint('Scanning '
-0000eb60: 202b 206e 7365 5f66 696c 6520 2b20 272e   + nse_file + '.
-0000eb70: 2729 0a0a 2020 2020 2020 2020 2020 2020  ')..            
-0000eb80: 2020 2020 2320 5265 6164 696e 6720 6669      # Reading fi
-0000eb90: 6c65 0a20 2020 2020 2020 2020 2020 2020  le.             
-0000eba0: 2020 2066 696c 6568 616e 646c 6520 3d20     filehandle = 
-0000ebb0: 7365 6c66 2e5f 5f6d 6d61 705f 6e73 655f  self.__mmap_nse_
-0000ebc0: 7061 636b 6574 7328 6e73 655f 6669 6c65  packets(nse_file
-0000ebd0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000ebe0: 2020 6966 2066 696c 6568 616e 646c 6520    if filehandle 
-0000ebf0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0000ec00: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-0000ec10: 7469 6e75 650a 0a20 2020 2020 2020 2020  tinue..         
-0000ec20: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-0000ec30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec40: 2320 4368 6563 6b69 6e67 2063 6f6e 7369  # Checking consi
-0000ec50: 7374 656e 6379 206f 6620 6e73 6520 6669  stency of nse fi
-0000ec60: 6c65 0a20 2020 2020 2020 2020 2020 2020  le.             
-0000ec70: 2020 2020 2020 2073 656c 662e 5f5f 6e73         self.__ns
-0000ec80: 655f 6368 6563 6b28 6669 6c65 6861 6e64  e_check(filehand
-0000ec90: 6c65 290a 2020 2020 2020 2020 2020 2020  le).            
-0000eca0: 2020 2020 6578 6365 7074 2041 7373 6572      except Asser
-0000ecb0: 7469 6f6e 4572 726f 723a 0a20 2020 2020  tionError:.     
-0000ecc0: 2020 2020 2020 2020 2020 2020 2020 2077                 w
-0000ecd0: 6172 6e69 6e67 732e 7761 726e 280a 2020  arnings.warn(.  
-0000ece0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ecf0: 2020 2020 2020 2753 6573 7369 6f6e 2066        'Session f
-0000ed00: 696c 6520 2573 2064 6964 206e 6f74 2070  ile %s did not p
-0000ed10: 6173 7320 6461 7461 2070 6163 6b65 7420  ass data packet 
-0000ed20: 6368 6563 6b2e 2027 0a20 2020 2020 2020  check. '.       
-0000ed30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed40: 2027 5468 6973 2066 696c 6520 6361 6e20   'This file can 
-0000ed50: 6e6f 7420 6265 206c 6f61 6465 642e 2720  not be loaded.' 
-0000ed60: 2520 6e73 655f 6669 6c65 290a 2020 2020  % nse_file).    
-0000ed70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed80: 636f 6e74 696e 7565 0a0a 2020 2020 2020  continue..      
-0000ed90: 2020 2020 2020 2020 2020 2320 5265 6164            # Read
-0000eda0: 696e 6720 6865 6164 6572 2069 6e66 6f72  ing header infor
-0000edb0: 6d61 7469 6f6e 2061 6e64 2073 746f 7265  mation and store
-0000edc0: 2074 6865 6d20 696e 2070 6172 616d 6574   them in paramet
-0000edd0: 6572 735f 6e73 650a 2020 2020 2020 2020  ers_nse.        
-0000ede0: 2020 2020 2020 2020 7365 6c66 2e5f 5f72          self.__r
-0000edf0: 6561 645f 6e73 655f 6461 7461 5f68 6561  ead_nse_data_hea
-0000ee00: 6465 7228 6669 6c65 6861 6e64 6c65 2c20  der(filehandle, 
-0000ee10: 6e73 655f 6669 6c65 290a 0a20 2020 2020  nse_file)..     
-0000ee20: 2020 2020 2020 2020 2020 2023 2052 6561             # Rea
-0000ee30: 6469 6e67 2074 7874 2066 696c 6520 6865  ding txt file he
-0000ee40: 6164 6572 0a20 2020 2020 2020 2020 2020  ader.           
-0000ee50: 2020 2020 2063 6861 6e6e 656c 5f69 6420       channel_id 
-0000ee60: 3d20 7365 6c66 2e67 6574 5f63 6861 6e6e  = self.get_chann
-0000ee70: 656c 5f69 645f 6279 5f66 696c 655f 6e61  el_id_by_file_na
-0000ee80: 6d65 286e 7365 5f66 696c 6529 0a20 2020  me(nse_file).   
-0000ee90: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000eea0: 662e 5f5f 7265 6164 5f74 6578 745f 6865  f.__read_text_he
-0000eeb0: 6164 6572 286e 7365 5f66 696c 652c 0a20  ader(nse_file,. 
-0000eec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eee0: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
-0000eef0: 6d65 7465 7273 5f6e 7365 5b63 6861 6e6e  meters_nse[chann
-0000ef00: 656c 5f69 645d 290a 0a20 2020 2020 2020  el_id])..       
-0000ef10: 2020 2020 2020 2020 2023 2075 7369 6e67           # using
-0000ef20: 2073 616d 706c 696e 6720 7261 7465 2066   sampling rate f
-0000ef30: 726f 6d20 7478 7420 6865 6164 6572 2c20  rom txt header, 
-0000ef40: 6173 2074 6869 7320 6973 206e 6f74 2073  as this is not s
-0000ef50: 6176 6564 0a20 2020 2020 2020 2020 2020  aved.           
-0000ef60: 2020 2020 2023 2069 6e20 6461 7461 2070       # in data p
-0000ef70: 6163 6b65 7473 0a20 2020 2020 2020 2020  ackets.         
-0000ef80: 2020 2020 2020 2069 6620 2753 616d 706c         if 'Sampl
-0000ef90: 696e 6746 7265 7175 656e 6379 2720 696e  ingFrequency' in
-0000efa0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-0000efb0: 5f6e 7365 5b63 6861 6e6e 656c 5f69 645d  _nse[channel_id]
-0000efc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000efd0: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
-0000efe0: 6574 6572 735f 6e73 655b 6368 616e 6e65  eters_nse[channe
-0000eff0: 6c5f 6964 5d5b 2773 616d 706c 696e 675f  l_id]['sampling_
-0000f000: 7261 7465 275d 203d 205c 0a20 2020 2020  rate'] = \.     
-0000f010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f020: 2020 2028 7365 6c66 2e70 6172 616d 6574     (self.paramet
-0000f030: 6572 735f 6e73 655b 6368 616e 6e65 6c5f  ers_nse[channel_
-0000f040: 6964 5d5b 0a20 2020 2020 2020 2020 2020  id][.           
-0000f050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f060: 2027 5361 6d70 6c69 6e67 4672 6571 7565   'SamplingFreque
-0000f070: 6e63 7927 5d20 2a20 7365 6c66 2e6e 7365  ncy'] * self.nse
-0000f080: 5f73 725f 756e 6974 290a 0a20 2020 2020  _sr_unit)..     
-0000f090: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000f0a0: 6e73 655f 6173 736f 2e61 7070 656e 6428  nse_asso.append(
-0000f0b0: 6e73 655f 6669 6c65 290a 0a20 2020 2020  nse_file)..     
-0000f0c0: 2020 2020 2020 2023 203d 3d3d 3d3d 3d3d         # =======
-0000f0d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f0e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f0f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f100: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f110: 0a20 2020 2020 2020 2020 2020 2023 2023  .            # #
-0000f120: 2053 6361 6e20 4e45 5620 6669 6c65 730a   Scan NEV files.
-0000f130: 2020 2020 2020 2020 2020 2020 2320 3d3d              # ==
+0000ea00: 3d3d 0a20 2020 2020 2020 2020 2020 2023  ==.            #
+0000ea10: 2023 2053 6361 6e20 4e53 4520 6669 6c65   # Scan NSE file
+0000ea20: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
+0000ea30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000ea40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000ea50: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000ea60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000ea70: 3d3d 3d3d 3d3d 3d0a 0a20 2020 2020 2020  =======..       
+0000ea80: 2020 2020 2023 204c 6f61 6469 6e67 2069       # Loading i
+0000ea90: 6e64 6976 6964 7561 6c20 4e53 4520 6669  ndividual NSE fi
+0000eaa0: 6c65 2061 6e64 2065 7874 7261 6374 696e  le and extractin
+0000eab0: 6720 7061 7261 6d65 7465 7273 0a20 2020  g parameters.   
+0000eac0: 2020 2020 2020 2020 2073 656c 662e 5f64           self._d
+0000ead0: 6961 676e 6f73 7469 635f 7072 696e 7428  iagnostic_print(
+0000eae0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000eaf0: 2027 5c6e 4465 7465 6374 6564 2025 6920   '\nDetected %i 
+0000eb00: 2e6e 7365 2066 696c 6528 7329 2e27 2025  .nse file(s).' %
+0000eb10: 2028 6c65 6e28 7365 6c66 2e6e 7365 5f61   (len(self.nse_a
+0000eb20: 7661 696c 2929 290a 0a20 2020 2020 2020  vail)))..       
+0000eb30: 2020 2020 2066 6f72 206e 7365 5f66 696c       for nse_fil
+0000eb40: 6520 696e 2073 656c 662e 6e73 655f 6176  e in self.nse_av
+0000eb50: 6169 6c3a 0a20 2020 2020 2020 2020 2020  ail:.           
+0000eb60: 2020 2020 2023 204c 6f61 6469 6e67 2069       # Loading i
+0000eb70: 6e64 6976 6964 7561 6c20 4e53 4520 6669  ndividual NSE fi
+0000eb80: 6c65 2061 6e64 2065 7874 7261 6374 696e  le and extractin
+0000eb90: 6720 7061 7261 6d65 7465 7273 0a20 2020  g parameters.   
+0000eba0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000ebb0: 662e 5f64 6961 676e 6f73 7469 635f 7072  f._diagnostic_pr
+0000ebc0: 696e 7428 2753 6361 6e6e 696e 6720 2720  int('Scanning ' 
+0000ebd0: 2b20 6e73 655f 6669 6c65 202b 2027 2e27  + nse_file + '.'
+0000ebe0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+0000ebf0: 2020 2023 2052 6561 6469 6e67 2066 696c     # Reading fil
+0000ec00: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0000ec10: 2020 6669 6c65 6861 6e64 6c65 203d 2073    filehandle = s
+0000ec20: 656c 662e 5f5f 6d6d 6170 5f6e 7365 5f70  elf.__mmap_nse_p
+0000ec30: 6163 6b65 7473 286e 7365 5f66 696c 6529  ackets(nse_file)
+0000ec40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ec50: 2069 6620 6669 6c65 6861 6e64 6c65 2069   if filehandle i
+0000ec60: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+0000ec70: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+0000ec80: 696e 7565 0a0a 2020 2020 2020 2020 2020  inue..          
+0000ec90: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+0000eca0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000ecb0: 2043 6865 636b 696e 6720 636f 6e73 6973   Checking consis
+0000ecc0: 7465 6e63 7920 6f66 206e 7365 2066 696c  tency of nse fil
+0000ecd0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0000ece0: 2020 2020 2020 7365 6c66 2e5f 5f6e 7365        self.__nse
+0000ecf0: 5f63 6865 636b 2866 696c 6568 616e 646c  _check(filehandl
+0000ed00: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+0000ed10: 2020 2065 7863 6570 7420 4173 7365 7274     except Assert
+0000ed20: 696f 6e45 7272 6f72 3a0a 2020 2020 2020  ionError:.      
+0000ed30: 2020 2020 2020 2020 2020 2020 2020 7761                wa
+0000ed40: 726e 696e 6773 2e77 6172 6e28 0a20 2020  rnings.warn(.   
+0000ed50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed60: 2020 2020 2027 5365 7373 696f 6e20 6669       'Session fi
+0000ed70: 6c65 2025 7320 6469 6420 6e6f 7420 7061  le %s did not pa
+0000ed80: 7373 2064 6174 6120 7061 636b 6574 2063  ss data packet c
+0000ed90: 6865 636b 2e20 270a 2020 2020 2020 2020  heck. '.        
+0000eda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000edb0: 2754 6869 7320 6669 6c65 2063 616e 206e  'This file can n
+0000edc0: 6f74 2062 6520 6c6f 6164 6564 2e27 2025  ot be loaded.' %
+0000edd0: 206e 7365 5f66 696c 6529 0a20 2020 2020   nse_file).     
+0000ede0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000edf0: 6f6e 7469 6e75 650a 0a20 2020 2020 2020  ontinue..       
+0000ee00: 2020 2020 2020 2020 2023 2052 6561 6469           # Readi
+0000ee10: 6e67 2068 6561 6465 7220 696e 666f 726d  ng header inform
+0000ee20: 6174 696f 6e20 616e 6420 7374 6f72 6520  ation and store 
+0000ee30: 7468 656d 2069 6e20 7061 7261 6d65 7465  them in paramete
+0000ee40: 7273 5f6e 7365 0a20 2020 2020 2020 2020  rs_nse.         
+0000ee50: 2020 2020 2020 2073 656c 662e 5f5f 7265         self.__re
+0000ee60: 6164 5f6e 7365 5f64 6174 615f 6865 6164  ad_nse_data_head
+0000ee70: 6572 2866 696c 6568 616e 646c 652c 206e  er(filehandle, n
+0000ee80: 7365 5f66 696c 6529 0a0a 2020 2020 2020  se_file)..      
+0000ee90: 2020 2020 2020 2020 2020 2320 5265 6164            # Read
+0000eea0: 696e 6720 7478 7420 6669 6c65 2068 6561  ing txt file hea
+0000eeb0: 6465 720a 2020 2020 2020 2020 2020 2020  der.            
+0000eec0: 2020 2020 6368 616e 6e65 6c5f 6964 203d      channel_id =
+0000eed0: 2073 656c 662e 6765 745f 6368 616e 6e65   self.get_channe
+0000eee0: 6c5f 6964 5f62 795f 6669 6c65 5f6e 616d  l_id_by_file_nam
+0000eef0: 6528 6e73 655f 6669 6c65 290a 2020 2020  e(nse_file).    
+0000ef00: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000ef10: 2e5f 5f72 6561 645f 7465 7874 5f68 6561  .__read_text_hea
+0000ef20: 6465 7228 6e73 655f 6669 6c65 2c0a 2020  der(nse_file,.  
+0000ef30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef50: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
+0000ef60: 6574 6572 735f 6e73 655b 6368 616e 6e65  eters_nse[channe
+0000ef70: 6c5f 6964 5d29 0a0a 2020 2020 2020 2020  l_id])..        
+0000ef80: 2020 2020 2020 2020 2320 7573 696e 6720          # using 
+0000ef90: 7361 6d70 6c69 6e67 2072 6174 6520 6672  sampling rate fr
+0000efa0: 6f6d 2074 7874 2068 6561 6465 722c 2061  om txt header, a
+0000efb0: 7320 7468 6973 2069 7320 6e6f 7420 7361  s this is not sa
+0000efc0: 7665 640a 2020 2020 2020 2020 2020 2020  ved.            
+0000efd0: 2020 2020 2320 696e 2064 6174 6120 7061      # in data pa
+0000efe0: 636b 6574 730a 2020 2020 2020 2020 2020  ckets.          
+0000eff0: 2020 2020 2020 6966 2027 5361 6d70 6c69        if 'Sampli
+0000f000: 6e67 4672 6571 7565 6e63 7927 2069 6e20  ngFrequency' in 
+0000f010: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+0000f020: 6e73 655b 6368 616e 6e65 6c5f 6964 5d3a  nse[channel_id]:
+0000f030: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f040: 2020 2020 2073 656c 662e 7061 7261 6d65       self.parame
+0000f050: 7465 7273 5f6e 7365 5b63 6861 6e6e 656c  ters_nse[channel
+0000f060: 5f69 645d 5b27 7361 6d70 6c69 6e67 5f72  _id]['sampling_r
+0000f070: 6174 6527 5d20 3d20 5c0a 2020 2020 2020  ate'] = \.      
+0000f080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f090: 2020 2873 656c 662e 7061 7261 6d65 7465    (self.paramete
+0000f0a0: 7273 5f6e 7365 5b63 6861 6e6e 656c 5f69  rs_nse[channel_i
+0000f0b0: 645d 5b0a 2020 2020 2020 2020 2020 2020  d][.            
+0000f0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f0d0: 2753 616d 706c 696e 6746 7265 7175 656e  'SamplingFrequen
+0000f0e0: 6379 275d 202a 2073 656c 662e 6e73 655f  cy'] * self.nse_
+0000f0f0: 7372 5f75 6e69 7429 0a0a 2020 2020 2020  sr_unit)..      
+0000f100: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
+0000f110: 7365 5f61 7373 6f2e 6170 7065 6e64 286e  se_asso.append(n
+0000f120: 7365 5f66 696c 6529 0a0a 2020 2020 2020  se_file)..      
+0000f130: 2020 2020 2020 2320 3d3d 3d3d 3d3d 3d3d        # ========
 0000f140: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000f150: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000f160: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f170: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f180: 3d3d 3d3d 3d0a 0a20 2020 2020 2020 2020  =====..         
-0000f190: 2020 2073 656c 662e 5f64 6961 676e 6f73     self._diagnos
-0000f1a0: 7469 635f 7072 696e 7428 0a20 2020 2020  tic_print(.     
-0000f1b0: 2020 2020 2020 2020 2020 2027 5c6e 4465             '\nDe
-0000f1c0: 7465 6374 6564 2025 6920 2e6e 6576 2066  tected %i .nev f
-0000f1d0: 696c 6528 7329 2e27 2025 2028 6c65 6e28  ile(s).' % (len(
-0000f1e0: 7365 6c66 2e6e 6576 5f61 7661 696c 2929  self.nev_avail))
-0000f1f0: 290a 0a20 2020 2020 2020 2020 2020 2066  )..            f
-0000f200: 6f72 206e 6576 5f66 696c 6520 696e 2073  or nev_file in s
-0000f210: 656c 662e 6e65 765f 6176 6169 6c3a 0a20  elf.nev_avail:. 
-0000f220: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000f230: 204c 6f61 6469 6e67 2069 6e64 6976 6964   Loading individ
-0000f240: 7561 6c20 4e45 5620 6669 6c65 2061 6e64  ual NEV file and
-0000f250: 2065 7874 7261 6374 696e 6720 7061 7261   extracting para
-0000f260: 6d65 7465 7273 0a20 2020 2020 2020 2020  meters.         
-0000f270: 2020 2020 2020 2073 656c 662e 5f64 6961         self._dia
-0000f280: 676e 6f73 7469 635f 7072 696e 7428 2753  gnostic_print('S
-0000f290: 6361 6e6e 696e 6720 2720 2b20 6e65 765f  canning ' + nev_
-0000f2a0: 6669 6c65 202b 2027 2e27 290a 0a20 2020  file + '.')..   
-0000f2b0: 2020 2020 2020 2020 2020 2020 2023 2052               # R
-0000f2c0: 6561 6469 6e67 2066 696c 650a 2020 2020  eading file.    
-0000f2d0: 2020 2020 2020 2020 2020 2020 6669 6c65              file
-0000f2e0: 6861 6e64 6c65 203d 2073 656c 662e 5f5f  handle = self.__
-0000f2f0: 6d6d 6170 5f6e 6576 5f66 696c 6528 6e65  mmap_nev_file(ne
-0000f300: 765f 6669 6c65 290a 2020 2020 2020 2020  v_file).        
-0000f310: 2020 2020 2020 2020 6966 2066 696c 6568          if fileh
-0000f320: 616e 646c 6520 6973 204e 6f6e 653a 0a20  andle is None:. 
-0000f330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f340: 2020 2063 6f6e 7469 6e75 650a 0a20 2020     continue..   
-0000f350: 2020 2020 2020 2020 2020 2020 2074 7279               try
-0000f360: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000f370: 2020 2020 2020 2320 4368 6563 6b69 6e67        # Checking
-0000f380: 2063 6f6e 7369 7374 656e 6379 206f 6620   consistency of 
-0000f390: 6e65 7620 6669 6c65 0a20 2020 2020 2020  nev file.       
-0000f3a0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000f3b0: 662e 5f5f 6e65 765f 6368 6563 6b28 6669  f.__nev_check(fi
-0000f3c0: 6c65 6861 6e64 6c65 290a 2020 2020 2020  lehandle).      
-0000f3d0: 2020 2020 2020 2020 2020 6578 6365 7074            except
-0000f3e0: 2041 7373 6572 7469 6f6e 4572 726f 723a   AssertionError:
-0000f3f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f400: 2020 2020 2077 6172 6e69 6e67 732e 7761       warnings.wa
-0000f410: 726e 280a 2020 2020 2020 2020 2020 2020  rn(.            
-0000f420: 2020 2020 2020 2020 2020 2020 2753 6573              'Ses
-0000f430: 7369 6f6e 2066 696c 6520 2573 2064 6964  sion file %s did
-0000f440: 206e 6f74 2070 6173 7320 6461 7461 2070   not pass data p
-0000f450: 6163 6b65 7420 6368 6563 6b2e 2027 0a20  acket check. '. 
+0000f170: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
+0000f180: 2020 2020 2020 2020 2020 2020 2320 2320              # # 
+0000f190: 5363 616e 204e 4556 2066 696c 6573 0a20  Scan NEV files. 
+0000f1a0: 2020 2020 2020 2020 2020 2023 203d 3d3d             # ===
+0000f1b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f1c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f1d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f1e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f1f0: 3d3d 3d3d 0a0a 2020 2020 2020 2020 2020  ====..          
+0000f200: 2020 7365 6c66 2e5f 6469 6167 6e6f 7374    self._diagnost
+0000f210: 6963 5f70 7269 6e74 280a 2020 2020 2020  ic_print(.      
+0000f220: 2020 2020 2020 2020 2020 275c 6e44 6574            '\nDet
+0000f230: 6563 7465 6420 2569 202e 6e65 7620 6669  ected %i .nev fi
+0000f240: 6c65 2873 292e 2720 2520 286c 656e 2873  le(s).' % (len(s
+0000f250: 656c 662e 6e65 765f 6176 6169 6c29 2929  elf.nev_avail)))
+0000f260: 0a0a 2020 2020 2020 2020 2020 2020 666f  ..            fo
+0000f270: 7220 6e65 765f 6669 6c65 2069 6e20 7365  r nev_file in se
+0000f280: 6c66 2e6e 6576 5f61 7661 696c 3a0a 2020  lf.nev_avail:.  
+0000f290: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000f2a0: 4c6f 6164 696e 6720 696e 6469 7669 6475  Loading individu
+0000f2b0: 616c 204e 4556 2066 696c 6520 616e 6420  al NEV file and 
+0000f2c0: 6578 7472 6163 7469 6e67 2070 6172 616d  extracting param
+0000f2d0: 6574 6572 730a 2020 2020 2020 2020 2020  eters.          
+0000f2e0: 2020 2020 2020 7365 6c66 2e5f 6469 6167        self._diag
+0000f2f0: 6e6f 7374 6963 5f70 7269 6e74 2827 5363  nostic_print('Sc
+0000f300: 616e 6e69 6e67 2027 202b 206e 6576 5f66  anning ' + nev_f
+0000f310: 696c 6520 2b20 272e 2729 0a0a 2020 2020  ile + '.')..    
+0000f320: 2020 2020 2020 2020 2020 2020 2320 5265              # Re
+0000f330: 6164 696e 6720 6669 6c65 0a20 2020 2020  ading file.     
+0000f340: 2020 2020 2020 2020 2020 2066 696c 6568             fileh
+0000f350: 616e 646c 6520 3d20 7365 6c66 2e5f 5f6d  andle = self.__m
+0000f360: 6d61 705f 6e65 765f 6669 6c65 286e 6576  map_nev_file(nev
+0000f370: 5f66 696c 6529 0a20 2020 2020 2020 2020  _file).         
+0000f380: 2020 2020 2020 2069 6620 6669 6c65 6861         if fileha
+0000f390: 6e64 6c65 2069 7320 4e6f 6e65 3a0a 2020  ndle is None:.  
+0000f3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f3b0: 2020 636f 6e74 696e 7565 0a0a 2020 2020    continue..    
+0000f3c0: 2020 2020 2020 2020 2020 2020 7472 793a              try:
+0000f3d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f3e0: 2020 2020 2023 2043 6865 636b 696e 6720       # Checking 
+0000f3f0: 636f 6e73 6973 7465 6e63 7920 6f66 206e  consistency of n
+0000f400: 6576 2066 696c 650a 2020 2020 2020 2020  ev file.        
+0000f410: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000f420: 2e5f 5f6e 6576 5f63 6865 636b 2866 696c  .__nev_check(fil
+0000f430: 6568 616e 646c 6529 0a20 2020 2020 2020  ehandle).       
+0000f440: 2020 2020 2020 2020 2065 7863 6570 7420           except 
+0000f450: 4173 7365 7274 696f 6e45 7272 6f72 3a0a  AssertionError:.
 0000f460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f470: 2020 2020 2020 2027 5468 6973 2066 696c         'This fil
-0000f480: 6520 6361 6e20 6e6f 7420 6265 206c 6f61  e can not be loa
-0000f490: 6465 642e 2720 2520 6e65 765f 6669 6c65  ded.' % nev_file
-0000f4a0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000f4b0: 2020 2020 2020 636f 6e74 696e 7565 0a0a        continue..
-0000f4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f4d0: 2320 5265 6164 696e 6720 6865 6164 6572  # Reading header
-0000f4e0: 2069 6e66 6f72 6d61 7469 6f6e 2061 6e64   information and
-0000f4f0: 2073 746f 7265 2074 6865 6d20 696e 2070   store them in p
-0000f500: 6172 616d 6574 6572 735f 6e65 760a 2020  arameters_nev.  
-0000f510: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000f520: 6c66 2e5f 5f72 6561 645f 6e65 765f 6461  lf.__read_nev_da
-0000f530: 7461 5f68 6561 6465 7228 6669 6c65 6861  ta_header(fileha
-0000f540: 6e64 6c65 2c20 6e65 765f 6669 6c65 290a  ndle, nev_file).
-0000f550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f560: 2023 2052 6561 6469 6e67 2074 7874 2066   # Reading txt f
-0000f570: 696c 6520 6865 6164 6572 0a20 2020 2020  ile header.     
-0000f580: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000f590: 5f5f 7265 6164 5f74 6578 745f 6865 6164  __read_text_head
-0000f5a0: 6572 286e 6576 5f66 696c 652c 2073 656c  er(nev_file, sel
-0000f5b0: 662e 7061 7261 6d65 7465 7273 5f6e 6576  f.parameters_nev
-0000f5c0: 5b6e 6576 5f66 696c 655d 290a 0a20 2020  [nev_file])..   
-0000f5d0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000f5e0: 662e 6e65 765f 6173 736f 2e61 7070 656e  f.nev_asso.appen
-0000f5f0: 6428 6e65 765f 6669 6c65 290a 0a20 2020  d(nev_file)..   
-0000f600: 2020 2020 2020 2020 2023 203d 3d3d 3d3d           # =====
-0000f610: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f620: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f630: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f640: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f650: 3d3d 0a20 2020 2020 2020 2020 2020 2023  ==.            #
-0000f660: 2023 2053 6361 6e20 4e54 5420 6669 6c65   # Scan NTT file
-0000f670: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
+0000f470: 2020 2020 7761 726e 696e 6773 2e77 6172      warnings.war
+0000f480: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
+0000f490: 2020 2020 2020 2020 2020 2027 5365 7373             'Sess
+0000f4a0: 696f 6e20 6669 6c65 2025 7320 6469 6420  ion file %s did 
+0000f4b0: 6e6f 7420 7061 7373 2064 6174 6120 7061  not pass data pa
+0000f4c0: 636b 6574 2063 6865 636b 2e20 270a 2020  cket check. '.  
+0000f4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f4e0: 2020 2020 2020 2754 6869 7320 6669 6c65        'This file
+0000f4f0: 2063 616e 206e 6f74 2062 6520 6c6f 6164   can not be load
+0000f500: 6564 2e27 2025 206e 6576 5f66 696c 6529  ed.' % nev_file)
+0000f510: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f520: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
+0000f530: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000f540: 2052 6561 6469 6e67 2068 6561 6465 7220   Reading header 
+0000f550: 696e 666f 726d 6174 696f 6e20 616e 6420  information and 
+0000f560: 7374 6f72 6520 7468 656d 2069 6e20 7061  store them in pa
+0000f570: 7261 6d65 7465 7273 5f6e 6576 0a20 2020  rameters_nev.   
+0000f580: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000f590: 662e 5f5f 7265 6164 5f6e 6576 5f64 6174  f.__read_nev_dat
+0000f5a0: 615f 6865 6164 6572 2866 696c 6568 616e  a_header(filehan
+0000f5b0: 646c 652c 206e 6576 5f66 696c 6529 0a0a  dle, nev_file)..
+0000f5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f5d0: 2320 5265 6164 696e 6720 7478 7420 6669  # Reading txt fi
+0000f5e0: 6c65 2068 6561 6465 720a 2020 2020 2020  le header.      
+0000f5f0: 2020 2020 2020 2020 2020 7365 6c66 2e5f            self._
+0000f600: 5f72 6561 645f 7465 7874 5f68 6561 6465  _read_text_heade
+0000f610: 7228 6e65 765f 6669 6c65 2c20 7365 6c66  r(nev_file, self
+0000f620: 2e70 6172 616d 6574 6572 735f 6e65 765b  .parameters_nev[
+0000f630: 6e65 765f 6669 6c65 5d29 0a0a 2020 2020  nev_file])..    
+0000f640: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000f650: 2e6e 6576 5f61 7373 6f2e 6170 7065 6e64  .nev_asso.append
+0000f660: 286e 6576 5f66 696c 6529 0a0a 2020 2020  (nev_file)..    
+0000f670: 2020 2020 2020 2020 2320 3d3d 3d3d 3d3d          # ======
 0000f680: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000f690: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000f6a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000f6b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000f6c0: 3d3d 3d3d 3d3d 3d0a 0a20 2020 2020 2020  =======..       
-0000f6d0: 2020 2020 2073 656c 662e 5f64 6961 676e       self._diagn
-0000f6e0: 6f73 7469 635f 7072 696e 7428 0a20 2020  ostic_print(.   
-0000f6f0: 2020 2020 2020 2020 2020 2020 2027 5c6e               '\n
-0000f700: 4465 7465 6374 6564 2025 6920 2e6e 7474  Detected %i .ntt
-0000f710: 2066 696c 6528 7329 2e27 2025 2028 6c65   file(s).' % (le
-0000f720: 6e28 7365 6c66 2e6e 7474 5f61 7661 696c  n(self.ntt_avail
-0000f730: 2929 290a 0a20 2020 2020 2020 2020 2020  )))..           
-0000f740: 2066 6f72 206e 7474 5f66 696c 6520 696e   for ntt_file in
-0000f750: 2073 656c 662e 6e74 745f 6176 6169 6c3a   self.ntt_avail:
-0000f760: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f770: 2023 204c 6f61 6469 6e67 2069 6e64 6976   # Loading indiv
-0000f780: 6964 7561 6c20 4e54 5420 6669 6c65 2061  idual NTT file a
-0000f790: 6e64 2065 7874 7261 6374 696e 6720 7061  nd extracting pa
-0000f7a0: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
-0000f7b0: 2020 2020 2020 2020 2073 656c 662e 5f64           self._d
-0000f7c0: 6961 676e 6f73 7469 635f 7072 696e 7428  iagnostic_print(
-0000f7d0: 2753 6361 6e6e 696e 6720 2720 2b20 6e74  'Scanning ' + nt
-0000f7e0: 745f 6669 6c65 202b 2027 2e27 290a 0a20  t_file + '.').. 
-0000f7f0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000f800: 2052 6561 6469 6e67 2066 696c 650a 2020   Reading file.  
-0000f810: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-0000f820: 6c65 6861 6e64 6c65 203d 2073 656c 662e  lehandle = self.
-0000f830: 5f5f 6d6d 6170 5f6e 7474 5f66 696c 6528  __mmap_ntt_file(
-0000f840: 6e74 745f 6669 6c65 290a 2020 2020 2020  ntt_file).      
-0000f850: 2020 2020 2020 2020 2020 6966 2066 696c            if fil
-0000f860: 6568 616e 646c 6520 6973 204e 6f6e 653a  ehandle is None:
-0000f870: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f880: 2020 2020 2063 6f6e 7469 6e75 650a 0a20       continue.. 
-0000f890: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000f8a0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-0000f8b0: 2020 2020 2020 2020 2320 4368 6563 6b69          # Checki
-0000f8c0: 6e67 2063 6f6e 7369 7374 656e 6379 206f  ng consistency o
-0000f8d0: 6620 6e65 7620 6669 6c65 0a20 2020 2020  f nev file.     
-0000f8e0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000f8f0: 656c 662e 5f5f 6e74 745f 6368 6563 6b28  elf.__ntt_check(
-0000f900: 6669 6c65 6861 6e64 6c65 290a 2020 2020  filehandle).    
-0000f910: 2020 2020 2020 2020 2020 2020 6578 6365              exce
-0000f920: 7074 2041 7373 6572 7469 6f6e 4572 726f  pt AssertionErro
-0000f930: 723a 0a20 2020 2020 2020 2020 2020 2020  r:.             
-0000f940: 2020 2020 2020 2077 6172 6e69 6e67 732e         warnings.
-0000f950: 7761 726e 280a 2020 2020 2020 2020 2020  warn(.          
-0000f960: 2020 2020 2020 2020 2020 2020 2020 2753                'S
-0000f970: 6573 7369 6f6e 2066 696c 6520 2573 2064  ession file %s d
-0000f980: 6964 206e 6f74 2070 6173 7320 6461 7461  id not pass data
-0000f990: 2070 6163 6b65 7420 6368 6563 6b2e 2027   packet check. '
-0000f9a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f9b0: 2020 2020 2020 2020 2027 5468 6973 2066           'This f
-0000f9c0: 696c 6520 6361 6e20 6e6f 7420 6265 206c  ile can not be l
-0000f9d0: 6f61 6465 642e 2720 2520 6e74 745f 6669  oaded.' % ntt_fi
-0000f9e0: 6c65 290a 2020 2020 2020 2020 2020 2020  le).            
-0000f9f0: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
-0000fa00: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000fa10: 2020 2320 5265 6164 696e 6720 6865 6164    # Reading head
-0000fa20: 6572 2069 6e66 6f72 6d61 7469 6f6e 2061  er information a
-0000fa30: 6e64 2073 746f 7265 2074 6865 6d20 696e  nd store them in
-0000fa40: 2070 6172 616d 6574 6572 735f 6e65 760a   parameters_nev.
-0000fa50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fa60: 7365 6c66 2e5f 5f72 6561 645f 6e74 745f  self.__read_ntt_
-0000fa70: 6461 7461 5f68 6561 6465 7228 6669 6c65  data_header(file
-0000fa80: 6861 6e64 6c65 2c20 6e74 745f 6669 6c65  handle, ntt_file
-0000fa90: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-0000faa0: 2020 2023 2052 6561 6469 6e67 2074 7874     # Reading txt
-0000fab0: 2066 696c 6520 6865 6164 6572 0a20 2020   file header.   
-0000fac0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000fad0: 662e 5f5f 7265 6164 5f6e 7474 5f74 6578  f.__read_ntt_tex
-0000fae0: 745f 6865 6164 6572 286e 7474 5f66 696c  t_header(ntt_fil
-0000faf0: 6529 0a0a 2020 2020 2020 2020 2020 2020  e)..            
-0000fb00: 2020 2020 2320 7573 696e 6720 7361 6d70      # using samp
-0000fb10: 6c69 6e67 2072 6174 6520 6672 6f6d 2074  ling rate from t
-0000fb20: 7874 2068 6561 6465 722c 2061 7320 7468  xt header, as th
-0000fb30: 6973 2069 7320 6e6f 7420 7361 7665 640a  is is not saved.
-0000fb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fb50: 2320 696e 2064 6174 6120 7061 636b 6574  # in data packet
-0000fb60: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
-0000fb70: 2020 6966 2027 5361 6d70 6c69 6e67 4672    if 'SamplingFr
-0000fb80: 6571 7565 6e63 7927 2069 6e20 7365 6c66  equency' in self
-0000fb90: 2e70 6172 616d 6574 6572 735f 6e74 745b  .parameters_ntt[
-0000fba0: 6368 616e 6e65 6c5f 6964 5d3a 0a20 2020  channel_id]:.   
-0000fbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fbc0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-0000fbd0: 5f6e 7474 5b63 6861 6e6e 656c 5f69 645d  _ntt[channel_id]
-0000fbe0: 5b27 7361 6d70 6c69 6e67 5f72 6174 6527  ['sampling_rate'
-0000fbf0: 5d20 3d20 5c0a 2020 2020 2020 2020 2020  ] = \.          
-0000fc00: 2020 2020 2020 2020 2020 2020 2020 2873                (s
-0000fc10: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-0000fc20: 7474 5b63 6861 6e6e 656c 5f69 645d 5b0a  tt[channel_id][.
-0000fc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fc40: 2020 2020 2020 2020 2020 2020 2753 616d              'Sam
-0000fc50: 706c 696e 6746 7265 7175 656e 6379 275d  plingFrequency']
-0000fc60: 202a 2073 656c 662e 6e74 745f 7372 5f75   * self.ntt_sr_u
-0000fc70: 6e69 7429 0a0a 2020 2020 2020 2020 2020  nit)..          
-0000fc80: 2020 2020 2020 7365 6c66 2e6e 7474 5f61        self.ntt_a
-0000fc90: 7373 6f2e 6170 7065 6e64 286e 7474 5f66  sso.append(ntt_f
-0000fca0: 696c 6529 0a0a 2020 2020 2020 2020 2020  ile)..          
-0000fcb0: 2020 2320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d    # ============
-0000fcc0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000fcd0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000fce0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000fcf0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a 2020 2020  ===========.    
-0000fd00: 2020 2020 2020 2020 2320 2320 4368 6563          # # Chec
-0000fd10: 6b20 636f 6e73 6973 7465 6e63 7920 6163  k consistency ac
-0000fd20: 726f 7373 2066 696c 6573 0a20 2020 2020  ross files.     
-0000fd30: 2020 2020 2020 2023 203d 3d3d 3d3d 3d3d         # =======
+0000f6c0: 3d0a 2020 2020 2020 2020 2020 2020 2320  =.            # 
+0000f6d0: 2320 5363 616e 204e 5454 2066 696c 6573  # Scan NTT files
+0000f6e0: 0a20 2020 2020 2020 2020 2020 2023 203d  .            # =
+0000f6f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f700: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f710: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f720: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000f730: 3d3d 3d3d 3d3d 0a0a 2020 2020 2020 2020  ======..        
+0000f740: 2020 2020 7365 6c66 2e5f 6469 6167 6e6f      self._diagno
+0000f750: 7374 6963 5f70 7269 6e74 280a 2020 2020  stic_print(.    
+0000f760: 2020 2020 2020 2020 2020 2020 275c 6e44              '\nD
+0000f770: 6574 6563 7465 6420 2569 202e 6e74 7420  etected %i .ntt 
+0000f780: 6669 6c65 2873 292e 2720 2520 286c 656e  file(s).' % (len
+0000f790: 2873 656c 662e 6e74 745f 6176 6169 6c29  (self.ntt_avail)
+0000f7a0: 2929 0a0a 2020 2020 2020 2020 2020 2020  ))..            
+0000f7b0: 666f 7220 6e74 745f 6669 6c65 2069 6e20  for ntt_file in 
+0000f7c0: 7365 6c66 2e6e 7474 5f61 7661 696c 3a0a  self.ntt_avail:.
+0000f7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f7e0: 2320 4c6f 6164 696e 6720 696e 6469 7669  # Loading indivi
+0000f7f0: 6475 616c 204e 5454 2066 696c 6520 616e  dual NTT file an
+0000f800: 6420 6578 7472 6163 7469 6e67 2070 6172  d extracting par
+0000f810: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+0000f820: 2020 2020 2020 2020 7365 6c66 2e5f 6469          self._di
+0000f830: 6167 6e6f 7374 6963 5f70 7269 6e74 2827  agnostic_print('
+0000f840: 5363 616e 6e69 6e67 2027 202b 206e 7474  Scanning ' + ntt
+0000f850: 5f66 696c 6520 2b20 272e 2729 0a0a 2020  _file + '.')..  
+0000f860: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000f870: 5265 6164 696e 6720 6669 6c65 0a20 2020  Reading file.   
+0000f880: 2020 2020 2020 2020 2020 2020 2066 696c               fil
+0000f890: 6568 616e 646c 6520 3d20 7365 6c66 2e5f  ehandle = self._
+0000f8a0: 5f6d 6d61 705f 6e74 745f 6669 6c65 286e  _mmap_ntt_file(n
+0000f8b0: 7474 5f66 696c 6529 0a20 2020 2020 2020  tt_file).       
+0000f8c0: 2020 2020 2020 2020 2069 6620 6669 6c65           if file
+0000f8d0: 6861 6e64 6c65 2069 7320 4e6f 6e65 3a0a  handle is None:.
+0000f8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f8f0: 2020 2020 636f 6e74 696e 7565 0a0a 2020      continue..  
+0000f900: 2020 2020 2020 2020 2020 2020 2020 7472                tr
+0000f910: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
+0000f920: 2020 2020 2020 2023 2043 6865 636b 696e         # Checkin
+0000f930: 6720 636f 6e73 6973 7465 6e63 7920 6f66  g consistency of
+0000f940: 206e 6576 2066 696c 650a 2020 2020 2020   nev file.      
+0000f950: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000f960: 6c66 2e5f 5f6e 7474 5f63 6865 636b 2866  lf.__ntt_check(f
+0000f970: 696c 6568 616e 646c 6529 0a20 2020 2020  ilehandle).     
+0000f980: 2020 2020 2020 2020 2020 2065 7863 6570             excep
+0000f990: 7420 4173 7365 7274 696f 6e45 7272 6f72  t AssertionError
+0000f9a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000f9b0: 2020 2020 2020 7761 726e 696e 6773 2e77        warnings.w
+0000f9c0: 6172 6e28 0a20 2020 2020 2020 2020 2020  arn(.           
+0000f9d0: 2020 2020 2020 2020 2020 2020 2027 5365               'Se
+0000f9e0: 7373 696f 6e20 6669 6c65 2025 7320 6469  ssion file %s di
+0000f9f0: 6420 6e6f 7420 7061 7373 2064 6174 6120  d not pass data 
+0000fa00: 7061 636b 6574 2063 6865 636b 2e20 270a  packet check. '.
+0000fa10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fa20: 2020 2020 2020 2020 2754 6869 7320 6669          'This fi
+0000fa30: 6c65 2063 616e 206e 6f74 2062 6520 6c6f  le can not be lo
+0000fa40: 6164 6564 2e27 2025 206e 7474 5f66 696c  aded.' % ntt_fil
+0000fa50: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+0000fa60: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+0000fa70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000fa80: 2023 2052 6561 6469 6e67 2068 6561 6465   # Reading heade
+0000fa90: 7220 696e 666f 726d 6174 696f 6e20 616e  r information an
+0000faa0: 6420 7374 6f72 6520 7468 656d 2069 6e20  d store them in 
+0000fab0: 7061 7261 6d65 7465 7273 5f6e 6576 0a20  parameters_nev. 
+0000fac0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000fad0: 656c 662e 5f5f 7265 6164 5f6e 7474 5f64  elf.__read_ntt_d
+0000fae0: 6174 615f 6865 6164 6572 2866 696c 6568  ata_header(fileh
+0000faf0: 616e 646c 652c 206e 7474 5f66 696c 6529  andle, ntt_file)
+0000fb00: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0000fb10: 2020 2320 5265 6164 696e 6720 7478 7420    # Reading txt 
+0000fb20: 6669 6c65 2068 6561 6465 720a 2020 2020  file header.    
+0000fb30: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000fb40: 2e5f 5f72 6561 645f 6e74 745f 7465 7874  .__read_ntt_text
+0000fb50: 5f68 6561 6465 7228 6e74 745f 6669 6c65  _header(ntt_file
+0000fb60: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+0000fb70: 2020 2023 2075 7369 6e67 2073 616d 706c     # using sampl
+0000fb80: 696e 6720 7261 7465 2066 726f 6d20 7478  ing rate from tx
+0000fb90: 7420 6865 6164 6572 2c20 6173 2074 6869  t header, as thi
+0000fba0: 7320 6973 206e 6f74 2073 6176 6564 0a20  s is not saved. 
+0000fbb0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000fbc0: 2069 6e20 6461 7461 2070 6163 6b65 7473   in data packets
+0000fbd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000fbe0: 2069 6620 2753 616d 706c 696e 6746 7265   if 'SamplingFre
+0000fbf0: 7175 656e 6379 2720 696e 2073 656c 662e  quency' in self.
+0000fc00: 7061 7261 6d65 7465 7273 5f6e 7474 5b63  parameters_ntt[c
+0000fc10: 6861 6e6e 656c 5f69 645d 3a0a 2020 2020  hannel_id]:.    
+0000fc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fc30: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+0000fc40: 6e74 745b 6368 616e 6e65 6c5f 6964 5d5b  ntt[channel_id][
+0000fc50: 2773 616d 706c 696e 675f 7261 7465 275d  'sampling_rate']
+0000fc60: 203d 205c 0a20 2020 2020 2020 2020 2020   = \.           
+0000fc70: 2020 2020 2020 2020 2020 2020 2028 7365               (se
+0000fc80: 6c66 2e70 6172 616d 6574 6572 735f 6e74  lf.parameters_nt
+0000fc90: 745b 6368 616e 6e65 6c5f 6964 5d5b 0a20  t[channel_id][. 
+0000fca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fcb0: 2020 2020 2020 2020 2020 2027 5361 6d70             'Samp
+0000fcc0: 6c69 6e67 4672 6571 7565 6e63 7927 5d20  lingFrequency'] 
+0000fcd0: 2a20 7365 6c66 2e6e 7474 5f73 725f 756e  * self.ntt_sr_un
+0000fce0: 6974 290a 0a20 2020 2020 2020 2020 2020  it)..           
+0000fcf0: 2020 2020 2073 656c 662e 6e74 745f 6173       self.ntt_as
+0000fd00: 736f 2e61 7070 656e 6428 6e74 745f 6669  so.append(ntt_fi
+0000fd10: 6c65 290a 0a20 2020 2020 2020 2020 2020  le)..           
+0000fd20: 2023 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   # =============
+0000fd30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000fd40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 0000fd50: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000fd60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000fd70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-0000fd80: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0000fd90: 6368 6563 6b20 5245 434f 5244 494e 475f  check RECORDING_
-0000fda0: 4f50 454e 4544 202f 2043 4c4f 5345 4420  OPENED / CLOSED 
-0000fdb0: 7469 6d65 7320 2866 726f 6d20 7478 7420  times (from txt 
-0000fdc0: 6865 6164 6572 2920 666f 720a 2020 2020  header) for.    
-0000fdd0: 2020 2020 2020 2020 2320 6469 6666 6572          # differ
-0000fde0: 656e 7420 6669 6c65 730a 2020 2020 2020  ent files.      
-0000fdf0: 2020 2020 2020 666f 7220 7061 7261 6d65        for parame
-0000fe00: 7465 725f 636f 6c6c 6563 7469 6f6e 2069  ter_collection i
-0000fe10: 6e20 5b73 656c 662e 7061 7261 6d65 7465  n [self.paramete
-0000fe20: 7273 5f6e 6373 2c0a 2020 2020 2020 2020  rs_ncs,.        
-0000fe30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fe40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fe50: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-0000fe60: 5f6e 7365 2c0a 2020 2020 2020 2020 2020  _nse,.          
-0000fe70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fe80: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000fe90: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-0000fea0: 6576 2c0a 2020 2020 2020 2020 2020 2020  ev,.            
+0000fd60: 3d3d 3d3d 3d3d 3d3d 3d3d 0a20 2020 2020  ==========.     
+0000fd70: 2020 2020 2020 2023 2023 2043 6865 636b         # # Check
+0000fd80: 2063 6f6e 7369 7374 656e 6379 2061 6372   consistency acr
+0000fd90: 6f73 7320 6669 6c65 730a 2020 2020 2020  oss files.      
+0000fda0: 2020 2020 2020 2320 3d3d 3d3d 3d3d 3d3d        # ========
+0000fdb0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000fdc0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000fdd0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+0000fde0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0a  ===============.
+0000fdf0: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
+0000fe00: 6865 636b 2052 4543 4f52 4449 4e47 5f4f  heck RECORDING_O
+0000fe10: 5045 4e45 4420 2f20 434c 4f53 4544 2074  PENED / CLOSED t
+0000fe20: 696d 6573 2028 6672 6f6d 2074 7874 2068  imes (from txt h
+0000fe30: 6561 6465 7229 2066 6f72 0a20 2020 2020  eader) for.     
+0000fe40: 2020 2020 2020 2023 2064 6966 6665 7265         # differe
+0000fe50: 6e74 2066 696c 6573 0a20 2020 2020 2020  nt files.       
+0000fe60: 2020 2020 2066 6f72 2070 6172 616d 6574       for paramet
+0000fe70: 6572 5f63 6f6c 6c65 6374 696f 6e20 696e  er_collection in
+0000fe80: 205b 7365 6c66 2e70 6172 616d 6574 6572   [self.parameter
+0000fe90: 735f 6e63 732c 0a20 2020 2020 2020 2020  s_ncs,.         
+0000fea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000feb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fec0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000fed0: 662e 7061 7261 6d65 7465 7273 5f6e 7474  f.parameters_ntt
-0000fee0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-0000fef0: 2020 2023 2063 6865 636b 2072 6563 6f64     # check recod
-0000ff00: 696e 675f 636c 6f73 6564 2074 696d 6573  ing_closed times
-0000ff10: 2066 6f72 2073 7065 6369 6669 6320 6669   for specific fi
-0000ff20: 6c65 2074 7970 6573 0a20 2020 2020 2020  le types.       
-0000ff30: 2020 2020 2020 2020 2069 6620 616e 7928           if any(
-0000ff40: 6e70 2e61 6273 286e 702e 6469 6666 285b  np.abs(np.diff([
-0000ff50: 695b 2772 6563 6f72 6469 6e67 5f6f 7065  i['recording_ope
-0000ff60: 6e65 6427 5d20 666f 7220 6920 696e 0a20  ned'] for i in. 
-0000ff70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ff80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ff90: 2020 2020 2020 7061 7261 6d65 7465 725f        parameter_
-0000ffa0: 636f 6c6c 6563 7469 6f6e 2e76 616c 7565  collection.value
-0000ffb0: 7328 295d 2929 0a20 2020 2020 2020 2020  s()])).         
-0000ffc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ffd0: 2020 2020 2020 3e20 6461 7465 7469 6d65        > datetime
-0000ffe0: 2e74 696d 6564 656c 7461 2873 6563 6f6e  .timedelta(secon
-0000fff0: 6473 3d31 2929 3a0a 2020 2020 2020 2020  ds=1)):.        
-00010000: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00010010: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
-00010020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010030: 2020 2020 2020 274e 4353 2066 696c 6573        'NCS files
-00010040: 2077 6572 6520 6f70 656e 6564 2066 6f72   were opened for
-00010050: 2072 6563 6f72 6469 6e67 2077 6974 6820   recording with 
-00010060: 6120 6465 6c61 7920 270a 2020 2020 2020  a delay '.      
-00010070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010080: 2020 2767 7265 6174 6572 2074 6861 6e20    'greater than 
-00010090: 302e 3120 7365 636f 6e64 2e27 290a 0a20  0.1 second.').. 
-000100a0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000100b0: 2063 6865 636b 2072 6563 6f64 696e 675f   check recoding_
-000100c0: 636c 6f73 6564 2074 696d 6573 2066 6f72  closed times for
-000100d0: 2073 7065 6369 6669 6320 6669 6c65 2074   specific file t
-000100e0: 7970 6573 0a20 2020 2020 2020 2020 2020  ypes.           
-000100f0: 2020 2020 2069 6620 616e 7928 6e70 2e64       if any(np.d
-00010100: 6966 6628 5b69 5b27 7265 636f 7264 696e  iff([i['recordin
-00010110: 675f 636c 6f73 6564 275d 2066 6f72 2069  g_closed'] for i
-00010120: 2069 6e0a 2020 2020 2020 2020 2020 2020   in.            
-00010130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010140: 2020 2020 7061 7261 6d65 7465 725f 636f      parameter_co
-00010150: 6c6c 6563 7469 6f6e 2e76 616c 7565 7328  llection.values(
-00010160: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00010170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010180: 2020 6966 2069 5b27 7265 636f 7264 696e    if i['recordin
-00010190: 675f 636c 6f73 6564 275d 2069 7320 6e6f  g_closed'] is no
-000101a0: 7420 4e6f 6e65 5d29 0a20 2020 2020 2020  t None]).       
-000101b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101c0: 203e 2064 6174 6574 696d 652e 7469 6d65   > datetime.time
-000101d0: 6465 6c74 6128 7365 636f 6e64 733d 302e  delta(seconds=0.
-000101e0: 3129 293a 0a20 2020 2020 2020 2020 2020  1)):.           
-000101f0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-00010200: 616c 7565 4572 726f 7228 0a20 2020 2020  alueError(.     
-00010210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010220: 2020 2027 4e43 5320 6669 6c65 7320 7765     'NCS files we
-00010230: 7265 2063 6c6f 7365 6420 6166 7465 7220  re closed after 
-00010240: 7265 636f 7264 696e 6720 7769 7468 2061  recording with a
-00010250: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-00010260: 2020 2020 2020 2020 2020 2027 6465 6c61             'dela
-00010270: 7920 270a 2020 2020 2020 2020 2020 2020  y '.            
-00010280: 2020 2020 2020 2020 2020 2020 2767 7265              'gre
-00010290: 6174 6572 2074 6861 6e20 302e 3120 7365  ater than 0.1 se
-000102a0: 636f 6e64 2e27 290a 0a20 2020 2020 2020  cond.')..       
-000102b0: 2020 2020 2023 2067 6574 206d 6178 696d       # get maxim
-000102c0: 616c 2064 7572 6174 696f 6e20 6f66 2061  al duration of a
-000102d0: 6e79 2066 696c 6520 696e 2074 6865 2072  ny file in the r
-000102e0: 6563 6f72 6469 6e67 0a20 2020 2020 2020  ecording.       
-000102f0: 2020 2020 2070 6172 616d 6574 6572 5f63       parameter_c
-00010300: 6f6c 6c65 6374 696f 6e20 3d20 6c69 7374  ollection = list
-00010310: 2873 656c 662e 7061 7261 6d65 7465 7273  (self.parameters
-00010320: 5f6e 6373 2e76 616c 7565 7328 2929 202b  _ncs.values()) +
-00010330: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-00010340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010350: 2020 2020 2020 6c69 7374 2873 656c 662e        list(self.
-00010360: 7061 7261 6d65 7465 7273 5f6e 7365 2e76  parameters_nse.v
-00010370: 616c 7565 7328 2929 202b 205c 0a20 2020  alues()) + \.   
-00010380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000103a0: 6c69 7374 2873 656c 662e 7061 7261 6d65  list(self.parame
-000103b0: 7465 7273 5f6e 7474 2e76 616c 7565 7328  ters_ntt.values(
-000103c0: 2929 202b 205c 0a20 2020 2020 2020 2020  )) + \.         
-000103d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000103e0: 2020 2020 2020 2020 2020 6c69 7374 2873            list(s
-000103f0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-00010400: 6576 2e76 616c 7565 7328 2929 0a20 2020  ev.values()).   
-00010410: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
-00010420: 7261 6d65 7465 7273 5f67 6c6f 6261 6c5b  rameters_global[
-00010430: 2772 6563 6f72 6469 6e67 5f6f 7065 6e65  'recording_opene
-00010440: 6427 5d20 3d20 6d69 6e28 0a20 2020 2020  d'] = min(.     
-00010450: 2020 2020 2020 2020 2020 205b 695b 2772             [i['r
-00010460: 6563 6f72 6469 6e67 5f6f 7065 6e65 6427  ecording_opened'
-00010470: 5d20 666f 7220 6920 696e 2070 6172 616d  ] for i in param
-00010480: 6574 6572 5f63 6f6c 6c65 6374 696f 6e5d  eter_collection]
-00010490: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
-000104a0: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
-000104b0: 6f62 616c 5b27 7265 636f 7264 696e 675f  obal['recording_
-000104c0: 636c 6f73 6564 275d 203d 206d 6178 280a  closed'] = max(.
-000104d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000104e0: 5b69 5b27 7265 636f 7264 696e 675f 636c  [i['recording_cl
-000104f0: 6f73 6564 275d 2066 6f72 2069 2069 6e20  osed'] for i in 
-00010500: 7061 7261 6d65 7465 725f 636f 6c6c 6563  parameter_collec
-00010510: 7469 6f6e 5d29 0a0a 2020 2020 2020 2020  tion])..        
-00010520: 2020 2020 2320 5365 7420 7570 2047 4c4f      # Set up GLO
-00010530: 4241 4c20 5449 4d49 4e47 2053 4348 454d  BAL TIMING SCHEM
-00010540: 450a 2020 2020 2020 2020 2020 2020 2320  E.            # 
-00010550: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010560: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-00010570: 2020 2020 2020 2020 2020 666f 7220 6669            for fi
-00010580: 6c65 5f74 7970 652c 2070 6172 616d 6574  le_type, paramet
-00010590: 6572 5f63 6f6c 6c65 6374 696f 6e20 696e  er_collection in
-000105a0: 205b 0a20 2020 2020 2020 2020 2020 2020   [.             
-000105b0: 2020 2020 2020 2028 276e 6373 272c 2073         ('ncs', s
-000105c0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-000105d0: 6373 292c 2028 276e 7365 272c 2073 656c  cs), ('nse', sel
-000105e0: 662e 7061 7261 6d65 7465 7273 5f6e 7365  f.parameters_nse
-000105f0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-00010600: 2020 2020 2020 2028 276e 6576 272c 2073         ('nev', s
-00010610: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-00010620: 6576 292c 2028 276e 7474 272c 2073 656c  ev), ('ntt', sel
-00010630: 662e 7061 7261 6d65 7465 7273 5f6e 7474  f.parameters_ntt
-00010640: 295d 3a0a 2020 2020 2020 2020 2020 2020  )]:.            
-00010650: 2020 2020 2320 6368 6563 6b20 7374 6172      # check star
-00010660: 7469 6e67 2074 696d 6573 0a20 2020 2020  ting times.     
-00010670: 2020 2020 2020 2020 2020 206e 616d 655f             name_
-00010680: 7431 2c20 6e61 6d65 5f74 3220 3d20 5b27  t1, name_t2 = ['
-00010690: 745f 7374 6172 7427 2c20 2774 5f73 746f  t_start', 't_sto
-000106a0: 7027 5d20 6966 2028 0a20 2020 2020 2020  p'] if (.       
-000106b0: 2020 2020 2020 2020 2020 2020 2066 696c               fil
-000106c0: 655f 7479 7065 2021 3d20 276e 7365 2720  e_type != 'nse' 
-000106d0: 616e 6420 6669 6c65 5f74 7970 6520 213d  and file_type !=
-000106e0: 2027 6e74 7427 2920 5c0a 2020 2020 2020   'ntt') \.      
-000106f0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00010700: 7365 205b 2774 5f66 6972 7374 272c 2027  se ['t_first', '
-00010710: 745f 6c61 7374 275d 0a0a 2020 2020 2020  t_last']..      
-00010720: 2020 2020 2020 2020 2020 2320 6368 6563            # chec
-00010730: 6b69 6e67 2069 6620 6669 6c65 7320 6f66  king if files of
-00010740: 2073 616d 6520 7479 7065 2073 7461 7274   same type start
-00010750: 2061 7420 7361 6d65 2074 696d 6520 706f   at same time po
-00010760: 696e 740a 2020 2020 2020 2020 2020 2020  int.            
-00010770: 2020 2020 6966 2066 696c 655f 7479 7065      if file_type
-00010780: 2021 3d20 276e 7365 2720 616e 6420 6669   != 'nse' and fi
-00010790: 6c65 5f74 7970 6520 213d 2027 6e74 7427  le_type != 'ntt'
-000107a0: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-000107b0: 2020 2020 2020 2020 2020 2061 6e64 206c             and l
-000107c0: 656e 286e 702e 756e 6971 7565 286e 702e  en(np.unique(np.
-000107d0: 6172 7261 7928 0a20 2020 2020 2020 2020  array(.         
-000107e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000107f0: 2020 205b 695b 6e61 6d65 5f74 315d 2e6d     [i[name_t1].m
-00010800: 6167 6e69 7475 6465 2066 6f72 2069 2069  agnitude for i i
-00010810: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
-00010820: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00010830: 6172 616d 6574 6572 5f63 6f6c 6c65 6374  arameter_collect
-00010840: 696f 6e2e 7661 6c75 6573 2829 5d29 2929  ion.values()])))
-00010850: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
-00010860: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-00010870: 5661 6c75 6545 7272 6f72 280a 2020 2020  ValueError(.    
-00010880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010890: 2020 2020 2725 7320 6669 6c65 7320 646f      '%s files do
-000108a0: 206e 6f74 2073 7461 7274 2061 7420 7361   not start at sa
-000108b0: 6d65 2074 696d 6520 706f 696e 742e 2720  me time point.' 
-000108c0: 250a 2020 2020 2020 2020 2020 2020 2020  %.              
-000108d0: 2020 2020 2020 2020 2020 6669 6c65 5f74            file_t
-000108e0: 7970 6529 0a0a 2020 2020 2020 2020 2020  ype)..          
-000108f0: 2020 2020 2020 2320 7361 7669 6e67 2074        # saving t
-00010900: 5f73 7461 7274 2061 6e64 2074 5f73 746f  _start and t_sto
-00010910: 7020 666f 7220 6561 6368 2066 696c 6520  p for each file 
-00010920: 7479 7065 2061 7661 696c 6162 6c65 0a20  type available. 
-00010930: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00010940: 6620 6c65 6e28 5b69 5b6e 616d 655f 7431  f len([i[name_t1
-00010950: 5d20 666f 7220 6920 696e 2070 6172 616d  ] for i in param
-00010960: 6574 6572 5f63 6f6c 6c65 6374 696f 6e2e  eter_collection.
-00010970: 7661 6c75 6573 2829 5d29 3a0a 2020 2020  values()]):.    
-00010980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010990: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-000109a0: 676c 6f62 616c 5b27 2573 5f74 5f73 7461  global['%s_t_sta
-000109b0: 7274 2720 2520 6669 6c65 5f74 7970 655d  rt' % file_type]
-000109c0: 203d 206d 696e 280a 2020 2020 2020 2020   = min(.        
-000109d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000109e0: 5b69 5b6e 616d 655f 7431 5d0a 2020 2020  [i[name_t1].    
-000109f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010a00: 2020 2020 2066 6f72 2069 2069 6e20 7061       for i in pa
-00010a10: 7261 6d65 7465 725f 636f 6c6c 6563 7469  rameter_collecti
-00010a20: 6f6e 2e76 616c 7565 7328 295d 290a 2020  on.values()]).  
-00010a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010a40: 2020 7365 6c66 2e70 6172 616d 6574 6572    self.parameter
-00010a50: 735f 676c 6f62 616c 5b27 2573 5f74 5f73  s_global['%s_t_s
-00010a60: 746f 7027 2025 2066 696c 655f 7479 7065  top' % file_type
-00010a70: 5d20 3d20 6d69 6e28 0a20 2020 2020 2020  ] = min(.       
-00010a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010a90: 205b 695b 6e61 6d65 5f74 325d 0a20 2020   [i[name_t2].   
+0000fec0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+0000fed0: 6e73 652c 0a20 2020 2020 2020 2020 2020  nse,.           
+0000fee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fef0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000ff00: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
+0000ff10: 762c 0a20 2020 2020 2020 2020 2020 2020  v,.             
+0000ff20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ff30: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000ff40: 2e70 6172 616d 6574 6572 735f 6e74 745d  .parameters_ntt]
+0000ff50: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000ff60: 2020 2320 6368 6563 6b20 7265 636f 6469    # check recodi
+0000ff70: 6e67 5f63 6c6f 7365 6420 7469 6d65 7320  ng_closed times 
+0000ff80: 666f 7220 7370 6563 6966 6963 2066 696c  for specific fil
+0000ff90: 6520 7479 7065 730a 2020 2020 2020 2020  e types.        
+0000ffa0: 2020 2020 2020 2020 6966 2061 6e79 286e          if any(n
+0000ffb0: 702e 6162 7328 6e70 2e64 6966 6628 5b69  p.abs(np.diff([i
+0000ffc0: 5b27 7265 636f 7264 696e 675f 6f70 656e  ['recording_open
+0000ffd0: 6564 275d 2066 6f72 2069 2069 6e0a 2020  ed'] for i in.  
+0000ffe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010000: 2020 2020 2070 6172 616d 6574 6572 5f63       parameter_c
+00010010: 6f6c 6c65 6374 696f 6e2e 7661 6c75 6573  ollection.values
+00010020: 2829 5d29 290a 2020 2020 2020 2020 2020  ()])).          
+00010030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010040: 2020 2020 203e 2064 6174 6574 696d 652e       > datetime.
+00010050: 7469 6d65 6465 6c74 6128 7365 636f 6e64  timedelta(second
+00010060: 733d 3129 293a 0a20 2020 2020 2020 2020  s=1)):.         
+00010070: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00010080: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+00010090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000100a0: 2020 2020 2027 4e43 5320 6669 6c65 7320       'NCS files 
+000100b0: 7765 7265 206f 7065 6e65 6420 666f 7220  were opened for 
+000100c0: 7265 636f 7264 696e 6720 7769 7468 2061  recording with a
+000100d0: 2064 656c 6179 2027 0a20 2020 2020 2020   delay '.       
+000100e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000100f0: 2027 6772 6561 7465 7220 7468 616e 2030   'greater than 0
+00010100: 2e31 2073 6563 6f6e 642e 2729 0a0a 2020  .1 second.')..  
+00010110: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00010120: 6368 6563 6b20 7265 636f 6469 6e67 5f63  check recoding_c
+00010130: 6c6f 7365 6420 7469 6d65 7320 666f 7220  losed times for 
+00010140: 7370 6563 6966 6963 2066 696c 6520 7479  specific file ty
+00010150: 7065 730a 2020 2020 2020 2020 2020 2020  pes.            
+00010160: 2020 2020 6966 2061 6e79 286e 702e 6469      if any(np.di
+00010170: 6666 285b 695b 2772 6563 6f72 6469 6e67  ff([i['recording
+00010180: 5f63 6c6f 7365 6427 5d20 666f 7220 6920  _closed'] for i 
+00010190: 696e 0a20 2020 2020 2020 2020 2020 2020  in.             
+000101a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000101b0: 2020 2070 6172 616d 6574 6572 5f63 6f6c     parameter_col
+000101c0: 6c65 6374 696f 6e2e 7661 6c75 6573 2829  lection.values()
+000101d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000101e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000101f0: 2069 6620 695b 2772 6563 6f72 6469 6e67   if i['recording
+00010200: 5f63 6c6f 7365 6427 5d20 6973 206e 6f74  _closed'] is not
+00010210: 204e 6f6e 655d 290a 2020 2020 2020 2020   None]).        
+00010220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010230: 3e20 6461 7465 7469 6d65 2e74 696d 6564  > datetime.timed
+00010240: 656c 7461 2873 6563 6f6e 6473 3d30 2e31  elta(seconds=0.1
+00010250: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
+00010260: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
+00010270: 6c75 6545 7272 6f72 280a 2020 2020 2020  lueError(.      
+00010280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010290: 2020 274e 4353 2066 696c 6573 2077 6572    'NCS files wer
+000102a0: 6520 636c 6f73 6564 2061 6674 6572 2072  e closed after r
+000102b0: 6563 6f72 6469 6e67 2077 6974 6820 6120  ecording with a 
+000102c0: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+000102d0: 2020 2020 2020 2020 2020 2764 656c 6179            'delay
+000102e0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+000102f0: 2020 2020 2020 2020 2020 2027 6772 6561             'grea
+00010300: 7465 7220 7468 616e 2030 2e31 2073 6563  ter than 0.1 sec
+00010310: 6f6e 642e 2729 0a0a 2020 2020 2020 2020  ond.')..        
+00010320: 2020 2020 2320 6765 7420 6d61 7869 6d61      # get maxima
+00010330: 6c20 6475 7261 7469 6f6e 206f 6620 616e  l duration of an
+00010340: 7920 6669 6c65 2069 6e20 7468 6520 7265  y file in the re
+00010350: 636f 7264 696e 670a 2020 2020 2020 2020  cording.        
+00010360: 2020 2020 7061 7261 6d65 7465 725f 636f      parameter_co
+00010370: 6c6c 6563 7469 6f6e 203d 206c 6973 7428  llection = list(
+00010380: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00010390: 6e63 732e 7661 6c75 6573 2829 2920 2b20  ncs.values()) + 
+000103a0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+000103b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000103c0: 2020 2020 206c 6973 7428 7365 6c66 2e70       list(self.p
+000103d0: 6172 616d 6574 6572 735f 6e73 652e 7661  arameters_nse.va
+000103e0: 6c75 6573 2829 2920 2b20 5c0a 2020 2020  lues()) + \.    
+000103f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010400: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+00010410: 6973 7428 7365 6c66 2e70 6172 616d 6574  ist(self.paramet
+00010420: 6572 735f 6e74 742e 7661 6c75 6573 2829  ers_ntt.values()
+00010430: 2920 2b20 5c0a 2020 2020 2020 2020 2020  ) + \.          
+00010440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010450: 2020 2020 2020 2020 206c 6973 7428 7365           list(se
+00010460: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
+00010470: 762e 7661 6c75 6573 2829 290a 2020 2020  v.values()).    
+00010480: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00010490: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
+000104a0: 7265 636f 7264 696e 675f 6f70 656e 6564  recording_opened
+000104b0: 275d 203d 206d 696e 280a 2020 2020 2020  '] = min(.      
+000104c0: 2020 2020 2020 2020 2020 5b69 5b27 7265            [i['re
+000104d0: 636f 7264 696e 675f 6f70 656e 6564 275d  cording_opened']
+000104e0: 2066 6f72 2069 2069 6e20 7061 7261 6d65   for i in parame
+000104f0: 7465 725f 636f 6c6c 6563 7469 6f6e 5d29  ter_collection])
+00010500: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00010510: 662e 7061 7261 6d65 7465 7273 5f67 6c6f  f.parameters_glo
+00010520: 6261 6c5b 2772 6563 6f72 6469 6e67 5f63  bal['recording_c
+00010530: 6c6f 7365 6427 5d20 3d20 6d61 7828 0a20  losed'] = max(. 
+00010540: 2020 2020 2020 2020 2020 2020 2020 205b                 [
+00010550: 695b 2772 6563 6f72 6469 6e67 5f63 6c6f  i['recording_clo
+00010560: 7365 6427 5d20 666f 7220 6920 696e 2070  sed'] for i in p
+00010570: 6172 616d 6574 6572 5f63 6f6c 6c65 6374  arameter_collect
+00010580: 696f 6e5d 290a 0a20 2020 2020 2020 2020  ion])..         
+00010590: 2020 2023 2053 6574 2075 7020 474c 4f42     # Set up GLOB
+000105a0: 414c 2054 494d 494e 4720 5343 4845 4d45  AL TIMING SCHEME
+000105b0: 0a20 2020 2020 2020 2020 2020 2023 2023  .            # #
+000105c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000105d0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+000105e0: 2020 2020 2020 2020 2066 6f72 2066 696c           for fil
+000105f0: 655f 7479 7065 2c20 7061 7261 6d65 7465  e_type, paramete
+00010600: 725f 636f 6c6c 6563 7469 6f6e 2069 6e20  r_collection in 
+00010610: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
+00010620: 2020 2020 2020 2827 6e63 7327 2c20 7365        ('ncs', se
+00010630: 6c66 2e70 6172 616d 6574 6572 735f 6e63  lf.parameters_nc
+00010640: 7329 2c20 2827 6e73 6527 2c20 7365 6c66  s), ('nse', self
+00010650: 2e70 6172 616d 6574 6572 735f 6e73 6529  .parameters_nse)
+00010660: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00010670: 2020 2020 2020 2827 6e65 7627 2c20 7365        ('nev', se
+00010680: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
+00010690: 7629 2c20 2827 6e74 7427 2c20 7365 6c66  v), ('ntt', self
+000106a0: 2e70 6172 616d 6574 6572 735f 6e74 7429  .parameters_ntt)
+000106b0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+000106c0: 2020 2023 2063 6865 636b 2073 7461 7274     # check start
+000106d0: 696e 6720 7469 6d65 730a 2020 2020 2020  ing times.      
+000106e0: 2020 2020 2020 2020 2020 6e61 6d65 5f74            name_t
+000106f0: 312c 206e 616d 655f 7432 203d 205b 2774  1, name_t2 = ['t
+00010700: 5f73 7461 7274 272c 2027 745f 7374 6f70  _start', 't_stop
+00010710: 275d 2069 6620 280a 2020 2020 2020 2020  '] if (.        
+00010720: 2020 2020 2020 2020 2020 2020 6669 6c65              file
+00010730: 5f74 7970 6520 213d 2027 6e73 6527 2061  _type != 'nse' a
+00010740: 6e64 2066 696c 655f 7479 7065 2021 3d20  nd file_type != 
+00010750: 276e 7474 2729 205c 0a20 2020 2020 2020  'ntt') \.       
+00010760: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00010770: 6520 5b27 745f 6669 7273 7427 2c20 2774  e ['t_first', 't
+00010780: 5f6c 6173 7427 5d0a 0a20 2020 2020 2020  _last']..       
+00010790: 2020 2020 2020 2020 2023 2063 6865 636b           # check
+000107a0: 696e 6720 6966 2066 696c 6573 206f 6620  ing if files of 
+000107b0: 7361 6d65 2074 7970 6520 7374 6172 7420  same type start 
+000107c0: 6174 2073 616d 6520 7469 6d65 2070 6f69  at same time poi
+000107d0: 6e74 0a20 2020 2020 2020 2020 2020 2020  nt.             
+000107e0: 2020 2069 6620 6669 6c65 5f74 7970 6520     if file_type 
+000107f0: 213d 2027 6e73 6527 2061 6e64 2066 696c  != 'nse' and fil
+00010800: 655f 7479 7065 2021 3d20 276e 7474 2720  e_type != 'ntt' 
+00010810: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00010820: 2020 2020 2020 2020 2020 616e 6420 6c65            and le
+00010830: 6e28 6e70 2e75 6e69 7175 6528 6e70 2e61  n(np.unique(np.a
+00010840: 7272 6179 280a 2020 2020 2020 2020 2020  rray(.          
+00010850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010860: 2020 5b69 5b6e 616d 655f 7431 5d2e 6d61    [i[name_t1].ma
+00010870: 676e 6974 7564 6520 666f 7220 6920 696e  gnitude for i in
+00010880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010890: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+000108a0: 7261 6d65 7465 725f 636f 6c6c 6563 7469  rameter_collecti
+000108b0: 6f6e 2e76 616c 7565 7328 295d 2929 2920  on.values()]))) 
+000108c0: 3e20 313a 0a20 2020 2020 2020 2020 2020  > 1:.           
+000108d0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+000108e0: 616c 7565 4572 726f 7228 0a20 2020 2020  alueError(.     
+000108f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010900: 2020 2027 2573 2066 696c 6573 2064 6f20     '%s files do 
+00010910: 6e6f 7420 7374 6172 7420 6174 2073 616d  not start at sam
+00010920: 6520 7469 6d65 2070 6f69 6e74 2e27 2025  e time point.' %
+00010930: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010940: 2020 2020 2020 2020 2066 696c 655f 7479           file_ty
+00010950: 7065 290a 0a20 2020 2020 2020 2020 2020  pe)..           
+00010960: 2020 2020 2023 2073 6176 696e 6720 745f       # saving t_
+00010970: 7374 6172 7420 616e 6420 745f 7374 6f70  start and t_stop
+00010980: 2066 6f72 2065 6163 6820 6669 6c65 2074   for each file t
+00010990: 7970 6520 6176 6169 6c61 626c 650a 2020  ype available.  
+000109a0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000109b0: 206c 656e 285b 695b 6e61 6d65 5f74 315d   len([i[name_t1]
+000109c0: 2066 6f72 2069 2069 6e20 7061 7261 6d65   for i in parame
+000109d0: 7465 725f 636f 6c6c 6563 7469 6f6e 2e76  ter_collection.v
+000109e0: 616c 7565 7328 295d 293a 0a20 2020 2020  alues()]):.     
+000109f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00010a00: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
+00010a10: 6c6f 6261 6c5b 2725 735f 745f 7374 6172  lobal['%s_t_star
+00010a20: 7427 2025 2066 696c 655f 7479 7065 5d20  t' % file_type] 
+00010a30: 3d20 6d69 6e28 0a20 2020 2020 2020 2020  = min(.         
+00010a40: 2020 2020 2020 2020 2020 2020 2020 205b                 [
+00010a50: 695b 6e61 6d65 5f74 315d 0a20 2020 2020  i[name_t1].     
+00010a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010a70: 2020 2020 666f 7220 6920 696e 2070 6172      for i in par
+00010a80: 616d 6574 6572 5f63 6f6c 6c65 6374 696f  ameter_collectio
+00010a90: 6e2e 7661 6c75 6573 2829 5d29 0a20 2020  n.values()]).   
 00010aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010ab0: 2020 2020 2020 666f 7220 6920 696e 2070        for i in p
-00010ac0: 6172 616d 6574 6572 5f63 6f6c 6c65 6374  arameter_collect
-00010ad0: 696f 6e2e 7661 6c75 6573 2829 5d29 0a0a  ion.values()])..
-00010ae0: 2020 2020 2020 2020 2020 2020 2320 6578              # ex
-00010af0: 7472 6163 7469 6e67 206d 696e 696d 6961  tracting minimia
-00010b00: 6c20 745f 7374 6172 7420 616e 6420 6d61  l t_start and ma
-00010b10: 7869 6d61 6c20 745f 7374 6f70 2076 616c  ximal t_stop val
-00010b20: 7565 2066 6f72 2074 6869 730a 2020 2020  ue for this.    
-00010b30: 2020 2020 2020 2020 2320 7265 636f 7264          # record
-00010b40: 696e 6720 7365 7373 696f 6e0a 2020 2020  ing session.    
-00010b50: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-00010b60: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
-00010b70: 745f 7374 6172 7427 5d20 3d20 6d69 6e28  t_start'] = min(
-00010b80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010b90: 205b 7365 6c66 2e70 6172 616d 6574 6572   [self.parameter
-00010ba0: 735f 676c 6f62 616c 5b27 2573 5f74 5f73  s_global['%s_t_s
-00010bb0: 7461 7274 2720 2520 745d 0a20 2020 2020  tart' % t].     
-00010bc0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00010bd0: 7420 696e 205b 276e 6373 272c 2027 6e65  t in ['ncs', 'ne
-00010be0: 7627 2c20 276e 7365 272c 2027 6e74 7427  v', 'nse', 'ntt'
-00010bf0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00010c00: 2020 2069 6620 2725 735f 745f 7374 6172     if '%s_t_star
-00010c10: 7427 2025 2074 2069 6e20 7365 6c66 2e70  t' % t in self.p
-00010c20: 6172 616d 6574 6572 735f 676c 6f62 616c  arameters_global
-00010c30: 5d29 0a20 2020 2020 2020 2020 2020 2073  ]).            s
-00010c40: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
-00010c50: 6c6f 6261 6c5b 2774 5f73 746f 7027 5d20  lobal['t_stop'] 
-00010c60: 3d20 6d61 7828 0a20 2020 2020 2020 2020  = max(.         
-00010c70: 2020 2020 2020 205b 7365 6c66 2e70 6172         [self.par
-00010c80: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
-00010c90: 2573 5f74 5f73 746f 7027 2025 2074 5d0a  %s_t_stop' % t].
-00010ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010cb0: 2066 6f72 2074 2069 6e20 5b27 6e63 7327   for t in ['ncs'
-00010cc0: 2c20 276e 6576 272c 2027 6e73 6527 2c20  , 'nev', 'nse', 
-00010cd0: 276e 7474 275d 0a20 2020 2020 2020 2020  'ntt'].         
-00010ce0: 2020 2020 2020 2020 6966 2027 2573 5f74          if '%s_t
-00010cf0: 5f73 7461 7274 2720 2520 7420 696e 2073  _start' % t in s
-00010d00: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
-00010d10: 6c6f 6261 6c5d 290a 0a20 2020 2020 2020  lobal])..       
-00010d20: 2020 2020 2023 2063 6865 636b 696e 6720       # checking 
-00010d30: 6761 7020 636f 6e73 6973 7465 6e63 7920  gap consistency 
-00010d40: 6163 726f 7373 206e 6373 2066 696c 6573  across ncs files
-00010d50: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
-00010d60: 6865 636b 206e 756d 6265 7220 6f66 2067  heck number of g
-00010d70: 6170 7320 6465 7465 6374 6564 0a20 2020  aps detected.   
-00010d80: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-00010d90: 6e70 2e75 6e69 7175 6528 5b6c 656e 2869  np.unique([len(i
-00010da0: 5b27 6761 7073 275d 2920 666f 7220 6920  ['gaps']) for i 
-00010db0: 696e 0a20 2020 2020 2020 2020 2020 2020  in.             
-00010dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010dd0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-00010de0: 5f6e 6373 2e76 616c 7565 7328 295d 2929  _ncs.values()]))
-00010df0: 2021 3d20 313a 0a20 2020 2020 2020 2020   != 1:.         
-00010e00: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-00010e10: 7565 4572 726f 7228 274e 4353 2066 696c  ueError('NCS fil
-00010e20: 6573 2063 6f6e 7461 696e 2064 6966 6665  es contain diffe
-00010e30: 7265 6e74 206e 756d 6265 7273 206f 6620  rent numbers of 
-00010e40: 6761 7073 2127 290a 2020 2020 2020 2020  gaps!').        
-00010e50: 2020 2020 2320 6368 6563 6b20 636f 6e73      # check cons
-00010e60: 6973 7465 6e63 7920 6f66 2067 6170 7320  istency of gaps 
-00010e70: 6163 726f 7373 2066 696c 6573 2061 6e64  across files and
-00010e80: 2063 7265 6174 6520 676c 6f62 616c 2067   create global g
-00010e90: 6170 0a20 2020 2020 2020 2020 2020 2023  ap.            #
-00010ea0: 2063 6f6c 6c65 6374 696f 6e0a 2020 2020   collection.    
-00010eb0: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-00010ec0: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
-00010ed0: 6761 7073 275d 203d 205b 5d0a 2020 2020  gaps'] = [].    
-00010ee0: 2020 2020 2020 2020 666f 7220 6720 696e          for g in
-00010ef0: 2072 616e 6765 286c 656e 286c 6973 7428   range(len(list(
-00010f00: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00010f10: 6e63 732e 7661 6c75 6573 2829 295b 305d  ncs.values())[0]
-00010f20: 5b27 6761 7073 275d 2929 3a0a 2020 2020  ['gaps'])):.    
-00010f30: 2020 2020 2020 2020 2020 2020 696e 7465              inte
-00010f40: 6772 6174 6564 203d 2046 616c 7365 0a20  grated = False. 
-00010f50: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-00010f60: 6170 5f73 7461 7473 203d 206e 702e 756e  ap_stats = np.un
-00010f70: 6971 7565 280a 2020 2020 2020 2020 2020  ique(.          
-00010f80: 2020 2020 2020 2020 2020 5b69 5b27 6761            [i['ga
-00010f90: 7073 275d 5b67 5d20 666f 7220 6920 696e  ps'][g] for i in
-00010fa0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-00010fb0: 5f6e 6373 2e76 616c 7565 7328 295d 2c0a  _ncs.values()],.
-00010fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010fd0: 2020 2020 7265 7475 726e 5f63 6f75 6e74      return_count
-00010fe0: 733d 5472 7565 290a 2020 2020 2020 2020  s=True).        
-00010ff0: 2020 2020 2020 2020 6966 206c 656e 2867          if len(g
-00011000: 6170 5f73 7461 7473 5b30 5d29 2021 3d20  ap_stats[0]) != 
-00011010: 3320 6f72 206c 656e 286e 702e 756e 6971  3 or len(np.uniq
-00011020: 7565 2867 6170 5f73 7461 7473 5b31 5d29  ue(gap_stats[1])
-00011030: 2920 213d 2031 3a0a 2020 2020 2020 2020  ) != 1:.        
-00011040: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00011050: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
-00011060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011070: 2020 2020 2020 2747 6170 206e 756d 6265        'Gap numbe
-00011080: 7220 2569 2069 7320 6e6f 7420 636f 6e73  r %i is not cons
-00011090: 6973 7465 6e74 2061 6372 6f73 7320 4e43  istent across NC
-000110a0: 5320 270a 2020 2020 2020 2020 2020 2020  S '.            
-000110b0: 2020 2020 2020 2020 2020 2020 2766 696c              'fil
-000110c0: 6573 2e27 2025 2028 0a20 2020 2020 2020  es.' % (.       
+00010ab0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
+00010ac0: 5f67 6c6f 6261 6c5b 2725 735f 745f 7374  _global['%s_t_st
+00010ad0: 6f70 2720 2520 6669 6c65 5f74 7970 655d  op' % file_type]
+00010ae0: 203d 206d 696e 280a 2020 2020 2020 2020   = min(.        
+00010af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010b00: 5b69 5b6e 616d 655f 7432 5d0a 2020 2020  [i[name_t2].    
+00010b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010b20: 2020 2020 2066 6f72 2069 2069 6e20 7061       for i in pa
+00010b30: 7261 6d65 7465 725f 636f 6c6c 6563 7469  rameter_collecti
+00010b40: 6f6e 2e76 616c 7565 7328 295d 290a 0a20  on.values()]).. 
+00010b50: 2020 2020 2020 2020 2020 2023 2065 7874             # ext
+00010b60: 7261 6374 696e 6720 6d69 6e69 6d69 616c  racting minimial
+00010b70: 2074 5f73 7461 7274 2061 6e64 206d 6178   t_start and max
+00010b80: 696d 616c 2074 5f73 746f 7020 7661 6c75  imal t_stop valu
+00010b90: 6520 666f 7220 7468 6973 0a20 2020 2020  e for this.     
+00010ba0: 2020 2020 2020 2023 2072 6563 6f72 6469         # recordi
+00010bb0: 6e67 2073 6573 7369 6f6e 0a20 2020 2020  ng session.     
+00010bc0: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
+00010bd0: 6d65 7465 7273 5f67 6c6f 6261 6c5b 2774  meters_global['t
+00010be0: 5f73 7461 7274 275d 203d 206d 696e 280a  _start'] = min(.
+00010bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010c00: 5b73 656c 662e 7061 7261 6d65 7465 7273  [self.parameters
+00010c10: 5f67 6c6f 6261 6c5b 2725 735f 745f 7374  _global['%s_t_st
+00010c20: 6172 7427 2025 2074 5d0a 2020 2020 2020  art' % t].      
+00010c30: 2020 2020 2020 2020 2020 2066 6f72 2074             for t
+00010c40: 2069 6e20 5b27 6e63 7327 2c20 276e 6576   in ['ncs', 'nev
+00010c50: 272c 2027 6e73 6527 2c20 276e 7474 275d  ', 'nse', 'ntt']
+00010c60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010c70: 2020 6966 2027 2573 5f74 5f73 7461 7274    if '%s_t_start
+00010c80: 2720 2520 7420 696e 2073 656c 662e 7061  ' % t in self.pa
+00010c90: 7261 6d65 7465 7273 5f67 6c6f 6261 6c5d  rameters_global]
+00010ca0: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+00010cb0: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
+00010cc0: 6f62 616c 5b27 745f 7374 6f70 275d 203d  obal['t_stop'] =
+00010cd0: 206d 6178 280a 2020 2020 2020 2020 2020   max(.          
+00010ce0: 2020 2020 2020 5b73 656c 662e 7061 7261        [self.para
+00010cf0: 6d65 7465 7273 5f67 6c6f 6261 6c5b 2725  meters_global['%
+00010d00: 735f 745f 7374 6f70 2720 2520 745d 0a20  s_t_stop' % t]. 
+00010d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010d20: 666f 7220 7420 696e 205b 276e 6373 272c  for t in ['ncs',
+00010d30: 2027 6e65 7627 2c20 276e 7365 272c 2027   'nev', 'nse', '
+00010d40: 6e74 7427 5d0a 2020 2020 2020 2020 2020  ntt'].          
+00010d50: 2020 2020 2020 2069 6620 2725 735f 745f         if '%s_t_
+00010d60: 7374 6172 7427 2025 2074 2069 6e20 7365  start' % t in se
+00010d70: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
+00010d80: 6f62 616c 5d29 0a0a 2020 2020 2020 2020  obal])..        
+00010d90: 2020 2020 2320 6368 6563 6b69 6e67 2067      # checking g
+00010da0: 6170 2063 6f6e 7369 7374 656e 6379 2061  ap consistency a
+00010db0: 6372 6f73 7320 6e63 7320 6669 6c65 730a  cross ncs files.
+00010dc0: 2020 2020 2020 2020 2020 2020 2320 6368              # ch
+00010dd0: 6563 6b20 6e75 6d62 6572 206f 6620 6761  eck number of ga
+00010de0: 7073 2064 6574 6563 7465 640a 2020 2020  ps detected.    
+00010df0: 2020 2020 2020 2020 6966 206c 656e 286e          if len(n
+00010e00: 702e 756e 6971 7565 285b 6c65 6e28 695b  p.unique([len(i[
+00010e10: 2767 6170 7327 5d29 2066 6f72 2069 2069  'gaps']) for i i
+00010e20: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+00010e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010e40: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00010e50: 6e63 732e 7661 6c75 6573 2829 5d29 2920  ncs.values()])) 
+00010e60: 213d 2031 3a0a 2020 2020 2020 2020 2020  != 1:.          
+00010e70: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00010e80: 6545 7272 6f72 2827 4e43 5320 6669 6c65  eError('NCS file
+00010e90: 7320 636f 6e74 6169 6e20 6469 6666 6572  s contain differ
+00010ea0: 656e 7420 6e75 6d62 6572 7320 6f66 2067  ent numbers of g
+00010eb0: 6170 7321 2729 0a20 2020 2020 2020 2020  aps!').         
+00010ec0: 2020 2023 2063 6865 636b 2063 6f6e 7369     # check consi
+00010ed0: 7374 656e 6379 206f 6620 6761 7073 2061  stency of gaps a
+00010ee0: 6372 6f73 7320 6669 6c65 7320 616e 6420  cross files and 
+00010ef0: 6372 6561 7465 2067 6c6f 6261 6c20 6761  create global ga
+00010f00: 700a 2020 2020 2020 2020 2020 2020 2320  p.            # 
+00010f10: 636f 6c6c 6563 7469 6f6e 0a20 2020 2020  collection.     
+00010f20: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
+00010f30: 6d65 7465 7273 5f67 6c6f 6261 6c5b 2767  meters_global['g
+00010f40: 6170 7327 5d20 3d20 5b5d 0a20 2020 2020  aps'] = [].     
+00010f50: 2020 2020 2020 2066 6f72 2067 2069 6e20         for g in 
+00010f60: 7261 6e67 6528 6c65 6e28 6c69 7374 2873  range(len(list(s
+00010f70: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+00010f80: 6373 2e76 616c 7565 7328 2929 5b30 5d5b  cs.values())[0][
+00010f90: 2767 6170 7327 5d29 293a 0a20 2020 2020  'gaps'])):.     
+00010fa0: 2020 2020 2020 2020 2020 2069 6e74 6567             integ
+00010fb0: 7261 7465 6420 3d20 4661 6c73 650a 2020  rated = False.  
+00010fc0: 2020 2020 2020 2020 2020 2020 2020 6761                ga
+00010fd0: 705f 7374 6174 7320 3d20 6e70 2e75 6e69  p_stats = np.uni
+00010fe0: 7175 6528 0a20 2020 2020 2020 2020 2020  que(.           
+00010ff0: 2020 2020 2020 2020 205b 695b 2767 6170           [i['gap
+00011000: 7327 5d5b 675d 2066 6f72 2069 2069 6e20  s'][g] for i in 
+00011010: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00011020: 6e63 732e 7661 6c75 6573 2829 5d2c 0a20  ncs.values()],. 
+00011030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011040: 2020 2072 6574 7572 6e5f 636f 756e 7473     return_counts
+00011050: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
+00011060: 2020 2020 2020 2069 6620 6c65 6e28 6761         if len(ga
+00011070: 705f 7374 6174 735b 305d 2920 213d 2033  p_stats[0]) != 3
+00011080: 206f 7220 6c65 6e28 6e70 2e75 6e69 7175   or len(np.uniqu
+00011090: 6528 6761 705f 7374 6174 735b 315d 2929  e(gap_stats[1]))
+000110a0: 2021 3d20 313a 0a20 2020 2020 2020 2020   != 1:.         
+000110b0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+000110c0: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
 000110d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000110e0: 2020 2020 2067 2929 0a20 2020 2020 2020       g)).       
-000110f0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00011100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011110: 2020 2023 2063 6865 636b 2069 6620 7468     # check if th
-00011120: 6973 2069 7320 7365 636f 6e64 2070 6172  is is second par
-00011130: 7420 6f66 2061 6c72 6561 6479 2065 7869  t of already exi
-00011140: 7374 696e 6720 6761 700a 2020 2020 2020  sting gap.      
-00011150: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00011160: 7220 6767 2069 6e20 7261 6e67 6528 6c65  r gg in range(le
-00011170: 6e28 7365 6c66 2e70 6172 616d 6574 6572  n(self.parameter
-00011180: 735f 676c 6f62 616c 5b27 6761 7073 275d  s_global['gaps']
-00011190: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
-000111a0: 2020 2020 2020 2020 2020 2020 676c 6f62              glob
-000111b0: 616c 6761 7020 3d20 7365 6c66 2e70 6172  algap = self.par
-000111c0: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
-000111d0: 6761 7073 275d 5b67 675d 0a20 2020 2020  gaps'][gg].     
-000111e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000111f0: 2020 2023 2063 6865 636b 2069 6620 7374     # check if st
-00011200: 6f70 2074 696d 6520 6f66 2066 6972 7374  op time of first
-00011210: 2069 7320 7374 6172 7420 7469 6d65 206f   is start time o
-00011220: 6620 7365 636f 6e64 0a20 2020 2020 2020  f second.       
-00011230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011240: 2023 2020 2d3e 2063 6f6e 7469 6e75 6f75   #  -> continuou
-00011250: 7320 6761 700a 2020 2020 2020 2020 2020  s gap.          
-00011260: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00011270: 2067 6c6f 6261 6c67 6170 5b32 5d20 3d3d   globalgap[2] ==
-00011280: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-00011290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000112a0: 2020 206c 6973 7428 7365 6c66 2e70 6172     list(self.par
-000112b0: 616d 6574 6572 735f 6e63 732e 7661 6c75  ameters_ncs.valu
-000112c0: 6573 2829 295b 305d 5b27 6761 7073 275d  es())[0]['gaps']
-000112d0: 5b0a 2020 2020 2020 2020 2020 2020 2020  [.              
-000112e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000112f0: 2020 2020 2020 675d 5b31 5d3a 0a20 2020        g][1]:.   
+000110e0: 2020 2020 2027 4761 7020 6e75 6d62 6572       'Gap number
+000110f0: 2025 6920 6973 206e 6f74 2063 6f6e 7369   %i is not consi
+00011100: 7374 656e 7420 6163 726f 7373 204e 4353  stent across NCS
+00011110: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00011120: 2020 2020 2020 2020 2020 2027 6669 6c65             'file
+00011130: 732e 2720 2520 280a 2020 2020 2020 2020  s.' % (.        
+00011140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011150: 2020 2020 6729 290a 2020 2020 2020 2020      g)).        
+00011160: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00011170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011180: 2020 2320 6368 6563 6b20 6966 2074 6869    # check if thi
+00011190: 7320 6973 2073 6563 6f6e 6420 7061 7274  s is second part
+000111a0: 206f 6620 616c 7265 6164 7920 6578 6973   of already exis
+000111b0: 7469 6e67 2067 6170 0a20 2020 2020 2020  ting gap.       
+000111c0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+000111d0: 2067 6720 696e 2072 616e 6765 286c 656e   gg in range(len
+000111e0: 2873 656c 662e 7061 7261 6d65 7465 7273  (self.parameters
+000111f0: 5f67 6c6f 6261 6c5b 2767 6170 7327 5d29  _global['gaps'])
+00011200: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00011210: 2020 2020 2020 2020 2020 2067 6c6f 6261             globa
+00011220: 6c67 6170 203d 2073 656c 662e 7061 7261  lgap = self.para
+00011230: 6d65 7465 7273 5f67 6c6f 6261 6c5b 2767  meters_global['g
+00011240: 6170 7327 5d5b 6767 5d0a 2020 2020 2020  aps'][gg].      
+00011250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011260: 2020 2320 6368 6563 6b20 6966 2073 746f    # check if sto
+00011270: 7020 7469 6d65 206f 6620 6669 7273 7420  p time of first 
+00011280: 6973 2073 7461 7274 2074 696d 6520 6f66  is start time of
+00011290: 2073 6563 6f6e 640a 2020 2020 2020 2020   second.        
+000112a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000112b0: 2320 202d 3e20 636f 6e74 696e 756f 7573  #  -> continuous
+000112c0: 2067 6170 0a20 2020 2020 2020 2020 2020   gap.           
+000112d0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000112e0: 676c 6f62 616c 6761 705b 325d 203d 3d20  globalgap[2] == 
+000112f0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
 00011300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011310: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
-00011320: 7261 6d65 7465 7273 5f67 6c6f 6261 6c5b  rameters_global[
-00011330: 2767 6170 7327 5d5b 6767 5d20 3d20 5c0a  'gaps'][gg] = \.
-00011340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011310: 2020 6c69 7374 2873 656c 662e 7061 7261    list(self.para
+00011320: 6d65 7465 7273 5f6e 6373 2e76 616c 7565  meters_ncs.value
+00011330: 7328 2929 5b30 5d5b 2767 6170 7327 5d5b  s())[0]['gaps'][
+00011340: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00011350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011360: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00011370: 676c 6f62 616c 5b27 6761 7073 275d 5b67  global['gaps'][g
-00011380: 675d 5b3a 325d 202b 2028 0a20 2020 2020  g][:2] + (.     
-00011390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000113a0: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-000113b0: 6973 7428 7365 6c66 2e70 6172 616d 6574  ist(self.paramet
-000113c0: 6572 735f 6e63 732e 7661 6c75 6573 2829  ers_ncs.values()
-000113d0: 295b 305d 5b0a 2020 2020 2020 2020 2020  )[0][.          
-000113e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000113f0: 2020 2020 2020 2020 2020 2020 2020 2767                'g
-00011400: 6170 7327 5d5b 675d 5b0a 2020 2020 2020  aps'][g][.      
-00011410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011430: 2020 325d 2c29 0a20 2020 2020 2020 2020    2],).         
-00011440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011450: 2020 2069 6e74 6567 7261 7465 6420 3d20     integrated = 
-00011460: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-00011470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011480: 2062 7265 616b 0a0a 2020 2020 2020 2020   break..        
-00011490: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-000114a0: 6f74 2069 6e74 6567 7261 7465 643a 0a20  ot integrated:. 
+00011360: 2020 2020 2067 5d5b 315d 3a0a 2020 2020       g][1]:.    
+00011370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011380: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00011390: 616d 6574 6572 735f 676c 6f62 616c 5b27  ameters_global['
+000113a0: 6761 7073 275d 5b67 675d 203d 205c 0a20  gaps'][gg] = \. 
+000113b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000113c0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000113d0: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
+000113e0: 6c6f 6261 6c5b 2767 6170 7327 5d5b 6767  lobal['gaps'][gg
+000113f0: 5d5b 3a32 5d20 2b20 280a 2020 2020 2020  ][:2] + (.      
+00011400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011410: 2020 2020 2020 2020 2020 2020 2020 6c69                li
+00011420: 7374 2873 656c 662e 7061 7261 6d65 7465  st(self.paramete
+00011430: 7273 5f6e 6373 2e76 616c 7565 7328 2929  rs_ncs.values())
+00011440: 5b30 5d5b 0a20 2020 2020 2020 2020 2020  [0][.           
+00011450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011460: 2020 2020 2020 2020 2020 2020 2027 6761               'ga
+00011470: 7073 275d 5b67 5d5b 0a20 2020 2020 2020  ps'][g][.       
+00011480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000114a0: 2032 5d2c 290a 2020 2020 2020 2020 2020   2],).          
 000114b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000114c0: 2020 2020 2020 2023 2061 6464 2061 7320         # add as 
-000114d0: 6e65 7720 6761 7020 6966 2074 6869 7320  new gap if this 
-000114e0: 6973 206e 6f74 2061 2063 6f6e 7469 6e75  is not a continu
-000114f0: 6174 696f 6e20 6f66 0a20 2020 2020 2020  ation of.       
-00011500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011510: 2023 2065 7869 7374 696e 6720 676c 6f62   # existing glob
-00011520: 616c 2067 6170 0a20 2020 2020 2020 2020  al gap.         
-00011530: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00011540: 656c 662e 7061 7261 6d65 7465 7273 5f67  elf.parameters_g
-00011550: 6c6f 6261 6c5b 2767 6170 7327 5d2e 6170  lobal['gaps'].ap
-00011560: 7065 6e64 280a 2020 2020 2020 2020 2020  pend(.          
+000114c0: 2020 696e 7465 6772 6174 6564 203d 2054    integrated = T
+000114d0: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
+000114e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000114f0: 6272 6561 6b0a 0a20 2020 2020 2020 2020  break..         
+00011500: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00011510: 7420 696e 7465 6772 6174 6564 3a0a 2020  t integrated:.  
+00011520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011530: 2020 2020 2020 2320 6164 6420 6173 206e        # add as n
+00011540: 6577 2067 6170 2069 6620 7468 6973 2069  ew gap if this i
+00011550: 7320 6e6f 7420 6120 636f 6e74 696e 7561  s not a continua
+00011560: 7469 6f6e 206f 660a 2020 2020 2020 2020  tion of.        
 00011570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011580: 2020 6c69 7374 2873 656c 662e 7061 7261    list(self.para
-00011590: 6d65 7465 7273 5f6e 6373 2e76 616c 7565  meters_ncs.value
-000115a0: 7328 2929 5b30 5d5b 0a20 2020 2020 2020  s())[0][.       
-000115b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000115c0: 2020 2020 2020 2020 2027 6761 7073 275d           'gaps']
-000115d0: 5b67 5d29 0a0a 2020 2020 2020 2020 2320  [g])..        # 
-000115e0: 7361 7665 2072 6573 756c 7473 206f 6620  save results of 
-000115f0: 6173 736f 6369 6174 696f 6e20 666f 7220  association for 
-00011600: 6675 7475 7265 2061 6e61 6c79 7369 7320  future analysis 
-00011610: 746f 6765 7468 6572 2077 6974 6820 6861  together with ha
-00011620: 7368 0a20 2020 2020 2020 2023 2076 616c  sh.        # val
-00011630: 7565 7320 666f 7220 6368 616e 6765 2074  ues for change t
-00011640: 7261 636b 696e 670a 2020 2020 2020 2020  racking.        
-00011650: 6966 2063 6163 6865 6469 7220 6973 206e  if cachedir is n
-00011660: 6f74 204e 6f6e 6520 616e 6420 7573 6563  ot None and usec
-00011670: 6163 6865 2021 3d20 276e 6576 6572 273a  ache != 'never':
-00011680: 0a20 2020 2020 2020 2020 2020 2070 6963  .            pic
-00011690: 6b6c 652e 6475 6d70 287b 2767 6c6f 6261  kle.dump({'globa
-000116a0: 6c27 3a20 7365 6c66 2e70 6172 616d 6574  l': self.paramet
-000116b0: 6572 735f 676c 6f62 616c 2c0a 2020 2020  ers_global,.    
-000116c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000116d0: 2020 2020 2027 6e63 7327 3a20 7365 6c66       'ncs': self
-000116e0: 2e70 6172 616d 6574 6572 735f 6e63 732c  .parameters_ncs,
-000116f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011700: 2020 2020 2020 2020 2020 276e 6576 273a            'nev':
-00011710: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
-00011720: 5f6e 6576 2c0a 2020 2020 2020 2020 2020  _nev,.          
-00011730: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00011740: 6e73 6527 3a20 7365 6c66 2e70 6172 616d  nse': self.param
-00011750: 6574 6572 735f 6e73 652c 0a20 2020 2020  eters_nse,.     
+00011580: 2320 6578 6973 7469 6e67 2067 6c6f 6261  # existing globa
+00011590: 6c20 6761 700a 2020 2020 2020 2020 2020  l gap.          
+000115a0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+000115b0: 6c66 2e70 6172 616d 6574 6572 735f 676c  lf.parameters_gl
+000115c0: 6f62 616c 5b27 6761 7073 275d 2e61 7070  obal['gaps'].app
+000115d0: 656e 6428 0a20 2020 2020 2020 2020 2020  end(.           
+000115e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000115f0: 206c 6973 7428 7365 6c66 2e70 6172 616d   list(self.param
+00011600: 6574 6572 735f 6e63 732e 7661 6c75 6573  eters_ncs.values
+00011610: 2829 295b 305d 5b0a 2020 2020 2020 2020  ())[0][.        
+00011620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011630: 2020 2020 2020 2020 2767 6170 7327 5d5b          'gaps'][
+00011640: 675d 290a 0a20 2020 2020 2020 2023 2073  g])..        # s
+00011650: 6176 6520 7265 7375 6c74 7320 6f66 2061  ave results of a
+00011660: 7373 6f63 6961 7469 6f6e 2066 6f72 2066  ssociation for f
+00011670: 7574 7572 6520 616e 616c 7973 6973 2074  uture analysis t
+00011680: 6f67 6574 6865 7220 7769 7468 2068 6173  ogether with has
+00011690: 680a 2020 2020 2020 2020 2320 7661 6c75  h.        # valu
+000116a0: 6573 2066 6f72 2063 6861 6e67 6520 7472  es for change tr
+000116b0: 6163 6b69 6e67 0a20 2020 2020 2020 2069  acking.        i
+000116c0: 6620 6361 6368 6564 6972 2069 7320 6e6f  f cachedir is no
+000116d0: 7420 4e6f 6e65 2061 6e64 2075 7365 6361  t None and useca
+000116e0: 6368 6520 213d 2027 6e65 7665 7227 3a0a  che != 'never':.
+000116f0: 2020 2020 2020 2020 2020 2020 7069 636b              pick
+00011700: 6c65 2e64 756d 7028 7b27 676c 6f62 616c  le.dump({'global
+00011710: 273a 2073 656c 662e 7061 7261 6d65 7465  ': self.paramete
+00011720: 7273 5f67 6c6f 6261 6c2c 0a20 2020 2020  rs_global,.     
+00011730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011740: 2020 2020 276e 6373 273a 2073 656c 662e      'ncs': self.
+00011750: 7061 7261 6d65 7465 7273 5f6e 6373 2c0a  parameters_ncs,.
 00011760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011770: 2020 2020 276e 7474 273a 2073 656c 662e      'ntt': self.
-00011780: 7061 7261 6d65 7465 7273 5f6e 7474 7d2c  parameters_ntt},
-00011790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000117a0: 2020 2020 2020 2020 206f 7065 6e28 6361           open(ca
-000117b0: 6368 6564 6972 202b 2073 6570 202b 2073  chedir + sep + s
-000117c0: 656c 662e 7365 7373 696f 6e64 6972 2e73  elf.sessiondir.s
-000117d0: 706c 6974 2873 6570 295b 0a20 2020 2020  plit(sep)[.     
-000117e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000117f0: 2020 2020 2020 202d 315d 202b 2027 2f70         -1] + '/p
-00011800: 6172 616d 6574 6572 732e 6361 6368 6527  arameters.cache'
-00011810: 2c20 2777 6227 2929 0a20 2020 2020 2020  , 'wb')).       
-00011820: 2020 2020 2069 6620 7573 6563 6163 6865       if usecache
-00011830: 2021 3d20 2761 6c77 6179 7327 3a0a 2020   != 'always':.  
-00011840: 2020 2020 2020 2020 2020 2020 2020 7069                pi
-00011850: 636b 6c65 2e64 756d 7028 6861 7368 6573  ckle.dump(hashes
-00011860: 5f63 616c 632c 206f 7065 6e28 0a20 2020  _calc, open(.   
-00011870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011880: 2063 6163 6865 6469 7220 2b20 7365 7020   cachedir + sep 
-00011890: 2b20 7365 6c66 2e73 6573 7369 6f6e 6469  + self.sessiondi
-000118a0: 722e 7370 6c69 7428 7365 7029 5b0a 2020  r.split(sep)[.  
-000118b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000118c0: 2020 2020 2020 2d31 5d20 2b20 272f 6861        -1] + '/ha
-000118d0: 7368 6b65 7973 272c 2027 7762 2729 290a  shkeys', 'wb')).
-000118e0: 0a20 2020 2020 2020 2073 656c 662e 6173  .        self.as
-000118f0: 736f 6369 6174 6564 203d 2054 7275 650a  sociated = True.
-00011900: 0a20 2020 2023 2070 7269 7661 7465 2072  .    # private r
-00011910: 6f75 7469 6e65 730a 2020 2020 2320 2323  outines.    # ##
-00011920: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011930: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011940: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011950: 2323 2323 2323 23ef bfbd 0a0a 2020 2020  #######.....    
-00011960: 2320 4d65 6d6f 7279 204d 6170 7069 6e67  # Memory Mapping
-00011970: 204d 6574 686f 6473 0a0a 2020 2020 6465   Methods..    de
-00011980: 6620 5f5f 6d6d 6170 5f6e 7365 5f70 6163  f __mmap_nse_pac
-00011990: 6b65 7473 2873 656c 662c 2066 696c 656e  kets(self, filen
-000119a0: 616d 6529 3a0a 2020 2020 2020 2020 2222  ame):.        ""
-000119b0: 220a 2020 2020 2020 2020 4d65 6d6f 7279  ".        Memory
-000119c0: 206d 6170 206f 6620 7468 6520 4e65 7572   map of the Neur
-000119d0: 616c 796e 7820 2e6e 6373 2066 696c 6520  alynx .ncs file 
-000119e0: 6f70 7469 6d69 7a65 6420 666f 7220 6578  optimized for ex
-000119f0: 7472 6163 7469 6f6e 206f 660a 2020 2020  traction of.    
-00011a00: 2020 2020 6461 7461 2070 6163 6b65 7420      data packet 
-00011a10: 6865 6164 6572 730a 2020 2020 2020 2020  headers.        
-00011a20: 5265 6164 696e 6720 7374 616e 6461 7264  Reading standard
-00011a30: 2064 7479 7065 2069 6d70 726f 7665 7320   dtype improves 
-00011a40: 7370 6565 642c 2062 7574 2074 696d 6573  speed, but times
-00011a50: 7461 6d70 7320 6e65 6564 2074 6f20 6265  tamps need to be
-00011a60: 0a20 2020 2020 2020 2072 6563 6f6e 7374  .        reconst
-00011a70: 7275 6374 6564 0a20 2020 2020 2020 2022  ructed.        "
-00011a80: 2222 0a20 2020 2020 2020 2066 696c 6573  "".        files
-00011a90: 697a 6520 3d20 6765 7473 697a 6528 7365  ize = getsize(se
-00011aa0: 6c66 2e73 6573 7369 6f6e 6469 7220 2b20  lf.sessiondir + 
-00011ab0: 7365 7020 2b20 6669 6c65 6e61 6d65 2920  sep + filename) 
-00011ac0: 2023 2069 6e20 6279 7465 0a20 2020 2020   # in byte.     
-00011ad0: 2020 2069 6620 6669 6c65 7369 7a65 203e     if filesize >
-00011ae0: 2031 3633 3834 3a0a 2020 2020 2020 2020   16384:.        
-00011af0: 2020 2020 6461 7461 203d 206e 702e 6d65      data = np.me
-00011b00: 6d6d 6170 2873 656c 662e 7365 7373 696f  mmap(self.sessio
-00011b10: 6e64 6972 202b 2073 6570 202b 2066 696c  ndir + sep + fil
-00011b20: 656e 616d 652c 0a20 2020 2020 2020 2020  ename,.         
-00011b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b40: 2020 2020 6474 7970 653d 273c 7532 272c      dtype='<u2',
-00011b50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011b60: 2020 2020 2020 2020 2020 2020 2020 7368                sh
-00011b70: 6170 653d 2828 6669 6c65 7369 7a65 202d  ape=((filesize -
-00011b80: 2031 3633 3834 2920 2f2f 2032 202f 2f20   16384) // 2 // 
-00011b90: 3536 2c20 3536 292c 0a20 2020 2020 2020  56, 56),.       
+00011770: 2020 2020 2020 2020 2027 6e65 7627 3a20           'nev': 
+00011780: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00011790: 6e65 762c 0a20 2020 2020 2020 2020 2020  nev,.           
+000117a0: 2020 2020 2020 2020 2020 2020 2020 276e                'n
+000117b0: 7365 273a 2073 656c 662e 7061 7261 6d65  se': self.parame
+000117c0: 7465 7273 5f6e 7365 2c0a 2020 2020 2020  ters_nse,.      
+000117d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117e0: 2020 2027 6e74 7427 3a20 7365 6c66 2e70     'ntt': self.p
+000117f0: 6172 616d 6574 6572 735f 6e74 747d 2c0a  arameters_ntt},.
+00011800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011810: 2020 2020 2020 2020 6f70 656e 2863 6163          open(cac
+00011820: 6865 6469 7220 2b20 7365 7020 2b20 7365  hedir + sep + se
+00011830: 6c66 2e73 6573 7369 6f6e 6469 722e 7370  lf.sessiondir.sp
+00011840: 6c69 7428 7365 7029 5b0a 2020 2020 2020  lit(sep)[.      
+00011850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011860: 2020 2020 2020 2d31 5d20 2b20 272f 7061        -1] + '/pa
+00011870: 7261 6d65 7465 7273 2e63 6163 6865 272c  rameters.cache',
+00011880: 2027 7762 2729 290a 2020 2020 2020 2020   'wb')).        
+00011890: 2020 2020 6966 2075 7365 6361 6368 6520      if usecache 
+000118a0: 213d 2027 616c 7761 7973 273a 0a20 2020  != 'always':.   
+000118b0: 2020 2020 2020 2020 2020 2020 2070 6963               pic
+000118c0: 6b6c 652e 6475 6d70 2868 6173 6865 735f  kle.dump(hashes_
+000118d0: 6361 6c63 2c20 6f70 656e 280a 2020 2020  calc, open(.    
+000118e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000118f0: 6361 6368 6564 6972 202b 2073 6570 202b  cachedir + sep +
+00011900: 2073 656c 662e 7365 7373 696f 6e64 6972   self.sessiondir
+00011910: 2e73 706c 6974 2873 6570 295b 0a20 2020  .split(sep)[.   
+00011920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011930: 2020 2020 202d 315d 202b 2027 2f68 6173       -1] + '/has
+00011940: 686b 6579 7327 2c20 2777 6227 2929 0a0a  hkeys', 'wb'))..
+00011950: 2020 2020 2020 2020 7365 6c66 2e61 7373          self.ass
+00011960: 6f63 6961 7465 6420 3d20 5472 7565 0a0a  ociated = True..
+00011970: 2020 2020 2320 7072 6976 6174 6520 726f      # private ro
+00011980: 7574 696e 6573 0a20 2020 2023 2023 2323  utines.    # ###
+00011990: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000119a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000119b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000119c0: 2323 2323 2323 efbf bd0a 0a20 2020 2023  ######.....    #
+000119d0: 204d 656d 6f72 7920 4d61 7070 696e 6720   Memory Mapping 
+000119e0: 4d65 7468 6f64 730a 0a20 2020 2064 6566  Methods..    def
+000119f0: 205f 5f6d 6d61 705f 6e73 655f 7061 636b   __mmap_nse_pack
+00011a00: 6574 7328 7365 6c66 2c20 6669 6c65 6e61  ets(self, filena
+00011a10: 6d65 293a 0a20 2020 2020 2020 2022 2222  me):.        """
+00011a20: 0a20 2020 2020 2020 204d 656d 6f72 7920  .        Memory 
+00011a30: 6d61 7020 6f66 2074 6865 204e 6575 7261  map of the Neura
+00011a40: 6c79 6e78 202e 6e63 7320 6669 6c65 206f  lynx .ncs file o
+00011a50: 7074 696d 697a 6564 2066 6f72 2065 7874  ptimized for ext
+00011a60: 7261 6374 696f 6e20 6f66 0a20 2020 2020  raction of.     
+00011a70: 2020 2064 6174 6120 7061 636b 6574 2068     data packet h
+00011a80: 6561 6465 7273 0a20 2020 2020 2020 2052  eaders.        R
+00011a90: 6561 6469 6e67 2073 7461 6e64 6172 6420  eading standard 
+00011aa0: 6474 7970 6520 696d 7072 6f76 6573 2073  dtype improves s
+00011ab0: 7065 6564 2c20 6275 7420 7469 6d65 7374  peed, but timest
+00011ac0: 616d 7073 206e 6565 6420 746f 2062 650a  amps need to be.
+00011ad0: 2020 2020 2020 2020 7265 636f 6e73 7472          reconstr
+00011ae0: 7563 7465 640a 2020 2020 2020 2020 2222  ucted.        ""
+00011af0: 220a 2020 2020 2020 2020 6669 6c65 7369  ".        filesi
+00011b00: 7a65 203d 2067 6574 7369 7a65 2873 656c  ze = getsize(sel
+00011b10: 662e 7365 7373 696f 6e64 6972 202b 2073  f.sessiondir + s
+00011b20: 6570 202b 2066 696c 656e 616d 6529 2020  ep + filename)  
+00011b30: 2320 696e 2062 7974 650a 2020 2020 2020  # in byte.      
+00011b40: 2020 6966 2066 696c 6573 697a 6520 3e20    if filesize > 
+00011b50: 3136 3338 343a 0a20 2020 2020 2020 2020  16384:.         
+00011b60: 2020 2064 6174 6120 3d20 6e70 2e6d 656d     data = np.mem
+00011b70: 6d61 7028 7365 6c66 2e73 6573 7369 6f6e  map(self.session
+00011b80: 6469 7220 2b20 7365 7020 2b20 6669 6c65  dir + sep + file
+00011b90: 6e61 6d65 2c0a 2020 2020 2020 2020 2020  name,.          
 00011ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011bb0: 2020 2020 2020 6d6f 6465 3d27 7227 2c20        mode='r', 
-00011bc0: 6f66 6673 6574 3d31 3633 3834 290a 0a20  offset=16384).. 
-00011bd0: 2020 2020 2020 2020 2020 2023 2072 6563             # rec
-00011be0: 6f6e 7374 7275 6374 696e 6720 6f72 6967  onstructing orig
-00011bf0: 696e 616c 2064 6174 610a 2020 2020 2020  inal data.      
-00011c00: 2020 2020 2020 2320 6669 7273 7420 3420        # first 4 
-00011c10: 696e 7473 202d 3e20 7469 6d65 7374 616d  ints -> timestam
-00011c20: 7020 696e 206d 6963 726f 7365 630a 2020  p in microsec.  
-00011c30: 2020 2020 2020 2020 2020 7469 6d65 7374            timest
-00011c40: 616d 7073 203d 2064 6174 615b 3a2c 2030  amps = data[:, 0
-00011c50: 5d20 5c0a 2020 2020 2020 2020 2020 2020  ] \.            
-00011c60: 2020 2020 2020 2020 2020 2020 202b 2064               + d
-00011c70: 6174 615b 3a2c 2031 5d20 2a20 3220 2a2a  ata[:, 1] * 2 **
-00011c80: 2031 3620 5c0a 2020 2020 2020 2020 2020   16 \.          
-00011c90: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-00011ca0: 2064 6174 615b 3a2c 2032 5d20 2a20 3220   data[:, 2] * 2 
-00011cb0: 2a2a 2033 3220 5c0a 2020 2020 2020 2020  ** 32 \.        
-00011cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011cd0: 202b 2064 6174 615b 3a2c 2033 5d20 2a20   + data[:, 3] * 
-00011ce0: 3220 2a2a 2034 380a 2020 2020 2020 2020  2 ** 48.        
-00011cf0: 2020 2020 6368 616e 6e65 6c5f 6964 203d      channel_id =
-00011d00: 2064 6174 615b 3a2c 2034 5d20 2b20 6461   data[:, 4] + da
-00011d10: 7461 5b3a 2c20 355d 202a 2032 202a 2a20  ta[:, 5] * 2 ** 
-00011d20: 3136 0a20 2020 2020 2020 2020 2020 2063  16.            c
-00011d30: 656c 6c5f 6e75 6d62 6572 203d 2064 6174  ell_number = dat
-00011d40: 615b 3a2c 2036 5d20 2b20 6461 7461 5b3a  a[:, 6] + data[:
-00011d50: 2c20 375d 202a 2032 202a 2a20 3136 0a20  , 7] * 2 ** 16. 
-00011d60: 2020 2020 2020 2020 2020 2066 6561 7475             featu
-00011d70: 7265 7320 3d20 5b64 6174 615b 3a2c 2070  res = [data[:, p
-00011d80: 5d20 2b20 6461 7461 5b3a 2c20 7020 2b20  ] + data[:, p + 
-00011d90: 315d 202a 2032 202a 2a20 3136 2066 6f72  1] * 2 ** 16 for
-00011da0: 2070 2069 6e0a 2020 2020 2020 2020 2020   p in.          
-00011db0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
-00011dc0: 6e67 6528 382c 2032 332c 2032 295d 0a20  nge(8, 23, 2)]. 
-00011dd0: 2020 2020 2020 2020 2020 2066 6561 7475             featu
-00011de0: 7265 7320 3d20 6e70 2e61 7272 6179 2866  res = np.array(f
-00011df0: 6561 7475 7265 732c 2064 7479 7065 3d27  eatures, dtype='
-00011e00: 6934 2729 0a0a 2020 2020 2020 2020 2020  i4')..          
-00011e10: 2020 6461 7461 5f70 6f69 6e74 7320 3d20    data_points = 
-00011e20: 6461 7461 5b3a 2c20 3234 3a35 365d 2e61  data[:, 24:56].a
-00011e30: 7374 7970 6528 2769 3227 290a 2020 2020  stype('i2').    
-00011e40: 2020 2020 2020 2020 6465 6c20 6461 7461          del data
-00011e50: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00011e60: 7572 6e20 7469 6d65 7374 616d 7073 2c20  urn timestamps, 
-00011e70: 6368 616e 6e65 6c5f 6964 2c20 6365 6c6c  channel_id, cell
-00011e80: 5f6e 756d 6265 722c 2066 6561 7475 7265  _number, feature
-00011e90: 732c 2064 6174 615f 706f 696e 7473 0a20  s, data_points. 
-00011ea0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00011eb0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00011ec0: 4e6f 6e65 0a0a 2020 2020 6465 6620 5f5f  None..    def __
-00011ed0: 6d6d 6170 5f6e 6373 5f64 6174 6128 7365  mmap_ncs_data(se
-00011ee0: 6c66 2c20 6669 6c65 6e61 6d65 293a 0a20  lf, filename):. 
-00011ef0: 2020 2020 2020 2022 2222 204d 656d 6f72         """ Memor
-00011f00: 7920 6d61 7020 6f66 2074 6865 204e 6575  y map of the Neu
-00011f10: 7261 6c79 6e78 202e 6e63 7320 6669 6c65  ralynx .ncs file
-00011f20: 206f 7074 696d 697a 6564 2066 6f72 2064   optimized for d
-00011f30: 6174 610a 2020 2020 2020 2020 6578 7472  ata.        extr
-00011f40: 6163 7469 6f6e 2222 220a 2020 2020 2020  action""".      
-00011f50: 2020 6966 2067 6574 7369 7a65 2873 656c    if getsize(sel
-00011f60: 662e 7365 7373 696f 6e64 6972 202b 2073  f.sessiondir + s
-00011f70: 6570 202b 2066 696c 656e 616d 6529 203e  ep + filename) >
-00011f80: 2031 3633 3834 3a0a 2020 2020 2020 2020   16384:.        
-00011f90: 2020 2020 6461 7461 203d 206e 702e 6d65      data = np.me
-00011fa0: 6d6d 6170 2873 656c 662e 7365 7373 696f  mmap(self.sessio
-00011fb0: 6e64 6972 202b 2073 6570 202b 2066 696c  ndir + sep + fil
-00011fc0: 656e 616d 652c 0a20 2020 2020 2020 2020  ename,.         
-00011fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011fe0: 2020 2020 6474 7970 653d 6e70 2e64 7479      dtype=np.dty
-00011ff0: 7065 2828 2769 3227 2c20 2835 3232 2929  pe(('i2', (522))
-00012000: 292c 206d 6f64 653d 2772 272c 0a20 2020  ), mode='r',.   
-00012010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012020: 2020 2020 2020 2020 2020 6f66 6673 6574            offset
-00012030: 3d31 3633 3834 290a 2020 2020 2020 2020  =16384).        
-00012040: 2020 2020 2320 7265 6d6f 7669 6e67 2064      # removing d
-00012050: 6174 6120 7061 636b 6574 2068 6561 6465  ata packet heade
-00012060: 7273 2061 6e64 2066 6c61 7474 656e 696e  rs and flattenin
-00012070: 6720 6461 7461 0a20 2020 2020 2020 2020  g data.         
-00012080: 2020 2072 6574 7572 6e20 6461 7461 5b3a     return data[:
-00012090: 2c20 3130 3a5d 0a20 2020 2020 2020 2065  , 10:].        e
-000120a0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-000120b0: 2072 6574 7572 6e20 4e6f 6e65 0a0a 2020   return None..  
-000120c0: 2020 6465 6620 5f5f 6d6d 6170 5f6e 6373    def __mmap_ncs
-000120d0: 5f70 6163 6b65 745f 6865 6164 6572 7328  _packet_headers(
-000120e0: 7365 6c66 2c20 6669 6c65 6e61 6d65 293a  self, filename):
-000120f0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00012100: 2020 2020 204d 656d 6f72 7920 6d61 7020       Memory map 
-00012110: 6f66 2074 6865 204e 6575 7261 6c79 6e78  of the Neuralynx
-00012120: 202e 6e63 7320 6669 6c65 206f 7074 696d   .ncs file optim
-00012130: 697a 6564 2066 6f72 2065 7874 7261 6374  ized for extract
-00012140: 696f 6e20 6f66 0a20 2020 2020 2020 2064  ion of.        d
-00012150: 6174 6120 7061 636b 6574 2068 6561 6465  ata packet heade
-00012160: 7273 0a20 2020 2020 2020 2052 6561 6469  rs.        Readi
-00012170: 6e67 2073 7461 6e64 6172 6420 6474 7970  ng standard dtyp
-00012180: 6520 696d 7072 6f76 6573 2073 7065 6564  e improves speed
-00012190: 2c20 6275 7420 7469 6d65 7374 616d 7073  , but timestamps
-000121a0: 206e 6565 6420 746f 2062 650a 2020 2020   need to be.    
-000121b0: 2020 2020 7265 636f 6e73 7472 7563 7465      reconstructe
-000121c0: 640a 2020 2020 2020 2020 2222 220a 2020  d.        """.  
-000121d0: 2020 2020 2020 6669 6c65 7369 7a65 203d        filesize =
-000121e0: 2067 6574 7369 7a65 2873 656c 662e 7365   getsize(self.se
-000121f0: 7373 696f 6e64 6972 202b 2073 6570 202b  ssiondir + sep +
-00012200: 2066 696c 656e 616d 6529 2020 2320 696e   filename)  # in
-00012210: 2062 7974 650a 2020 2020 2020 2020 6966   byte.        if
-00012220: 2066 696c 6573 697a 6520 3e20 3136 3338   filesize > 1638
-00012230: 343a 0a20 2020 2020 2020 2020 2020 2064  4:.            d
-00012240: 6174 6120 3d20 6e70 2e6d 656d 6d61 7028  ata = np.memmap(
-00012250: 7365 6c66 2e73 6573 7369 6f6e 6469 7220  self.sessiondir 
-00012260: 2b20 7365 7020 2b20 6669 6c65 6e61 6d65  + sep + filename
-00012270: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00012280: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00012290: 7479 7065 3d27 3c75 3427 2c0a 2020 2020  type='<u4',.    
-000122a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000122b0: 2020 2020 2020 2020 2073 6861 7065 3d28           shape=(
-000122c0: 2866 696c 6573 697a 6520 2d20 3136 3338  (filesize - 1638
-000122d0: 3429 202f 2f20 3420 2f2f 2032 3631 2c20  4) // 4 // 261, 
-000122e0: 3236 3129 2c0a 2020 2020 2020 2020 2020  261),.          
-000122f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012300: 2020 206d 6f64 653d 2772 272c 206f 6666     mode='r', off
-00012310: 7365 743d 3136 3338 3429 0a0a 2020 2020  set=16384)..    
-00012320: 2020 2020 2020 2020 7473 203d 2064 6174          ts = dat
-00012330: 615b 3a2c 2030 3a32 5d0a 2020 2020 2020  a[:, 0:2].      
-00012340: 2020 2020 2020 6d75 6c74 6920 3d20 6e70        multi = np
-00012350: 2e72 6570 6561 7428 6e70 2e61 7272 6179  .repeat(np.array
-00012360: 285b 312c 2032 202a 2a20 3332 5d2c 206e  ([1, 2 ** 32], n
-00012370: 646d 696e 3d32 292c 206c 656e 2864 6174  dmin=2), len(dat
-00012380: 6129 2c0a 2020 2020 2020 2020 2020 2020  a),.            
-00012390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000123a0: 2020 6178 6973 3d30 290a 2020 2020 2020    axis=0).      
-000123b0: 2020 2020 2020 7469 6d65 7374 616d 7073        timestamps
-000123c0: 203d 206e 702e 7375 6d28 7473 202a 206d   = np.sum(ts * m
-000123d0: 756c 7469 2c20 6178 6973 3d31 290a 2020  ulti, axis=1).  
-000123e0: 2020 2020 2020 2020 2020 2320 7469 6d65            # time
-000123f0: 7374 616d 7073 203d 2064 6174 615b 3a2c  stamps = data[:,
-00012400: 305d 202b 2028 6461 7461 5b3a 2c31 5d20  0] + (data[:,1] 
-00012410: 2a32 2a2a 3332 290a 2020 2020 2020 2020  *2**32).        
-00012420: 2020 2020 6865 6164 6572 5f75 3420 3d20      header_u4 = 
-00012430: 6461 7461 5b3a 2c20 323a 355d 0a0a 2020  data[:, 2:5]..  
-00012440: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00012450: 2074 696d 6573 7461 6d70 732c 2068 6561   timestamps, hea
-00012460: 6465 725f 7534 0a20 2020 2020 2020 2065  der_u4.        e
-00012470: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00012480: 2072 6574 7572 6e20 4e6f 6e65 0a0a 2020   return None..  
-00012490: 2020 6465 6620 5f5f 6d6d 6170 5f6e 6373    def __mmap_ncs
-000124a0: 5f70 6163 6b65 745f 7469 6d65 7374 616d  _packet_timestam
-000124b0: 7073 2873 656c 662c 2066 696c 656e 616d  ps(self, filenam
-000124c0: 6529 3a0a 2020 2020 2020 2020 2222 220a  e):.        """.
-000124d0: 2020 2020 2020 2020 4d65 6d6f 7279 206d          Memory m
-000124e0: 6170 206f 6620 7468 6520 4e65 7572 616c  ap of the Neural
-000124f0: 796e 7820 2e6e 6373 2066 696c 6520 6f70  ynx .ncs file op
-00012500: 7469 6d69 7a65 6420 666f 7220 6578 7472  timized for extr
-00012510: 6163 7469 6f6e 206f 660a 2020 2020 2020  action of.      
-00012520: 2020 6461 7461 2070 6163 6b65 7420 6865    data packet he
-00012530: 6164 6572 730a 2020 2020 2020 2020 5265  aders.        Re
-00012540: 6164 696e 6720 7374 616e 6461 7264 2064  ading standard d
-00012550: 7479 7065 2069 6d70 726f 7665 7320 7370  type improves sp
-00012560: 6565 642c 2062 7574 2074 696d 6573 7461  eed, but timesta
-00012570: 6d70 7320 6e65 6564 2074 6f20 6265 0a20  mps need to be. 
-00012580: 2020 2020 2020 2072 6563 6f6e 7374 7275         reconstru
-00012590: 6374 6564 0a20 2020 2020 2020 2022 2222  cted.        """
-000125a0: 0a20 2020 2020 2020 2066 696c 6573 697a  .        filesiz
-000125b0: 6520 3d20 6765 7473 697a 6528 7365 6c66  e = getsize(self
-000125c0: 2e73 6573 7369 6f6e 6469 7220 2b20 7365  .sessiondir + se
-000125d0: 7020 2b20 6669 6c65 6e61 6d65 2920 2023  p + filename)  #
-000125e0: 2069 6e20 6279 7465 0a20 2020 2020 2020   in byte.       
-000125f0: 2069 6620 6669 6c65 7369 7a65 203e 2031   if filesize > 1
-00012600: 3633 3834 3a0a 2020 2020 2020 2020 2020  6384:.          
-00012610: 2020 6461 7461 203d 206e 702e 6d65 6d6d    data = np.memm
-00012620: 6170 2873 656c 662e 7365 7373 696f 6e64  ap(self.sessiond
-00012630: 6972 202b 2073 6570 202b 2066 696c 656e  ir + sep + filen
-00012640: 616d 652c 0a20 2020 2020 2020 2020 2020  ame,.           
-00012650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012660: 2020 6474 7970 653d 273c 7534 272c 0a20    dtype='<u4',. 
-00012670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012680: 2020 2020 2020 2020 2020 2020 7368 6170              shap
-00012690: 653d 2869 6e74 2828 6669 6c65 7369 7a65  e=(int((filesize
-000126a0: 202d 2031 3633 3834 2920 2f20 3420 2f20   - 16384) / 4 / 
-000126b0: 3236 3129 2c20 3236 3129 2c0a 2020 2020  261), 261),.    
+00011bb0: 2020 2064 7479 7065 3d27 3c75 3227 2c0a     dtype='<u2',.
+00011bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011bd0: 2020 2020 2020 2020 2020 2020 2073 6861               sha
+00011be0: 7065 3d28 2866 696c 6573 697a 6520 2d20  pe=((filesize - 
+00011bf0: 3136 3338 3429 202f 2f20 3220 2f2f 2035  16384) // 2 // 5
+00011c00: 362c 2035 3629 2c0a 2020 2020 2020 2020  6, 56),.        
+00011c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011c20: 2020 2020 206d 6f64 653d 2772 272c 206f       mode='r', o
+00011c30: 6666 7365 743d 3136 3338 3429 0a0a 2020  ffset=16384)..  
+00011c40: 2020 2020 2020 2020 2020 2320 7265 636f            # reco
+00011c50: 6e73 7472 7563 7469 6e67 206f 7269 6769  nstructing origi
+00011c60: 6e61 6c20 6461 7461 0a20 2020 2020 2020  nal data.       
+00011c70: 2020 2020 2023 2066 6972 7374 2034 2069       # first 4 i
+00011c80: 6e74 7320 2d3e 2074 696d 6573 7461 6d70  nts -> timestamp
+00011c90: 2069 6e20 6d69 6372 6f73 6563 0a20 2020   in microsec.   
+00011ca0: 2020 2020 2020 2020 2074 696d 6573 7461           timesta
+00011cb0: 6d70 7320 3d20 6461 7461 5b3a 2c20 305d  mps = data[:, 0]
+00011cc0: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
+00011cd0: 2020 2020 2020 2020 2020 2020 2b20 6461              + da
+00011ce0: 7461 5b3a 2c20 315d 202a 2032 202a 2a20  ta[:, 1] * 2 ** 
+00011cf0: 3136 205c 0a20 2020 2020 2020 2020 2020  16 \.           
+00011d00: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+00011d10: 6461 7461 5b3a 2c20 325d 202a 2032 202a  data[:, 2] * 2 *
+00011d20: 2a20 3332 205c 0a20 2020 2020 2020 2020  * 32 \.         
+00011d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011d40: 2b20 6461 7461 5b3a 2c20 335d 202a 2032  + data[:, 3] * 2
+00011d50: 202a 2a20 3438 0a20 2020 2020 2020 2020   ** 48.         
+00011d60: 2020 2063 6861 6e6e 656c 5f69 6420 3d20     channel_id = 
+00011d70: 6461 7461 5b3a 2c20 345d 202b 2064 6174  data[:, 4] + dat
+00011d80: 615b 3a2c 2035 5d20 2a20 3220 2a2a 2031  a[:, 5] * 2 ** 1
+00011d90: 360a 2020 2020 2020 2020 2020 2020 6365  6.            ce
+00011da0: 6c6c 5f6e 756d 6265 7220 3d20 6461 7461  ll_number = data
+00011db0: 5b3a 2c20 365d 202b 2064 6174 615b 3a2c  [:, 6] + data[:,
+00011dc0: 2037 5d20 2a20 3220 2a2a 2031 360a 2020   7] * 2 ** 16.  
+00011dd0: 2020 2020 2020 2020 2020 6665 6174 7572            featur
+00011de0: 6573 203d 205b 6461 7461 5b3a 2c20 705d  es = [data[:, p]
+00011df0: 202b 2064 6174 615b 3a2c 2070 202b 2031   + data[:, p + 1
+00011e00: 5d20 2a20 3220 2a2a 2031 3620 666f 7220  ] * 2 ** 16 for 
+00011e10: 7020 696e 0a20 2020 2020 2020 2020 2020  p in.           
+00011e20: 2020 2020 2020 2020 2020 2020 2072 616e               ran
+00011e30: 6765 2838 2c20 3233 2c20 3229 5d0a 2020  ge(8, 23, 2)].  
+00011e40: 2020 2020 2020 2020 2020 6665 6174 7572            featur
+00011e50: 6573 203d 206e 702e 6172 7261 7928 6665  es = np.array(fe
+00011e60: 6174 7572 6573 2c20 6474 7970 653d 2769  atures, dtype='i
+00011e70: 3427 290a 0a20 2020 2020 2020 2020 2020  4')..           
+00011e80: 2064 6174 615f 706f 696e 7473 203d 2064   data_points = d
+00011e90: 6174 615b 3a2c 2032 343a 3536 5d2e 6173  ata[:, 24:56].as
+00011ea0: 7479 7065 2827 6932 2729 0a20 2020 2020  type('i2').     
+00011eb0: 2020 2020 2020 2064 656c 2064 6174 610a         del data.
+00011ec0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00011ed0: 726e 2074 696d 6573 7461 6d70 732c 2063  rn timestamps, c
+00011ee0: 6861 6e6e 656c 5f69 642c 2063 656c 6c5f  hannel_id, cell_
+00011ef0: 6e75 6d62 6572 2c20 6665 6174 7572 6573  number, features
+00011f00: 2c20 6461 7461 5f70 6f69 6e74 730a 2020  , data_points.  
+00011f10: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00011f20: 2020 2020 2020 2020 7265 7475 726e 204e          return N
+00011f30: 6f6e 650a 0a20 2020 2064 6566 205f 5f6d  one..    def __m
+00011f40: 6d61 705f 6e63 735f 6461 7461 2873 656c  map_ncs_data(sel
+00011f50: 662c 2066 696c 656e 616d 6529 3a0a 2020  f, filename):.  
+00011f60: 2020 2020 2020 2222 2220 4d65 6d6f 7279        """ Memory
+00011f70: 206d 6170 206f 6620 7468 6520 4e65 7572   map of the Neur
+00011f80: 616c 796e 7820 2e6e 6373 2066 696c 6520  alynx .ncs file 
+00011f90: 6f70 7469 6d69 7a65 6420 666f 7220 6461  optimized for da
+00011fa0: 7461 0a20 2020 2020 2020 2065 7874 7261  ta.        extra
+00011fb0: 6374 696f 6e22 2222 0a20 2020 2020 2020  ction""".       
+00011fc0: 2069 6620 6765 7473 697a 6528 7365 6c66   if getsize(self
+00011fd0: 2e73 6573 7369 6f6e 6469 7220 2b20 7365  .sessiondir + se
+00011fe0: 7020 2b20 6669 6c65 6e61 6d65 2920 3e20  p + filename) > 
+00011ff0: 3136 3338 343a 0a20 2020 2020 2020 2020  16384:.         
+00012000: 2020 2064 6174 6120 3d20 6e70 2e6d 656d     data = np.mem
+00012010: 6d61 7028 7365 6c66 2e73 6573 7369 6f6e  map(self.session
+00012020: 6469 7220 2b20 7365 7020 2b20 6669 6c65  dir + sep + file
+00012030: 6e61 6d65 2c0a 2020 2020 2020 2020 2020  name,.          
+00012040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012050: 2020 2064 7479 7065 3d6e 702e 6474 7970     dtype=np.dtyp
+00012060: 6528 2827 6932 272c 2028 3532 3229 2929  e(('i2', (522)))
+00012070: 2c20 6d6f 6465 3d27 7227 2c0a 2020 2020  , mode='r',.    
+00012080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012090: 2020 2020 2020 2020 206f 6666 7365 743d           offset=
+000120a0: 3136 3338 3429 0a20 2020 2020 2020 2020  16384).         
+000120b0: 2020 2023 2072 656d 6f76 696e 6720 6461     # removing da
+000120c0: 7461 2070 6163 6b65 7420 6865 6164 6572  ta packet header
+000120d0: 7320 616e 6420 666c 6174 7465 6e69 6e67  s and flattening
+000120e0: 2064 6174 610a 2020 2020 2020 2020 2020   data.          
+000120f0: 2020 7265 7475 726e 2064 6174 615b 3a2c    return data[:,
+00012100: 2031 303a 5d0a 2020 2020 2020 2020 656c   10:].        el
+00012110: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00012120: 7265 7475 726e 204e 6f6e 650a 0a20 2020  return None..   
+00012130: 2064 6566 205f 5f6d 6d61 705f 6e63 735f   def __mmap_ncs_
+00012140: 7061 636b 6574 5f68 6561 6465 7273 2873  packet_headers(s
+00012150: 656c 662c 2066 696c 656e 616d 6529 3a0a  elf, filename):.
+00012160: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00012170: 2020 2020 4d65 6d6f 7279 206d 6170 206f      Memory map o
+00012180: 6620 7468 6520 4e65 7572 616c 796e 7820  f the Neuralynx 
+00012190: 2e6e 6373 2066 696c 6520 6f70 7469 6d69  .ncs file optimi
+000121a0: 7a65 6420 666f 7220 6578 7472 6163 7469  zed for extracti
+000121b0: 6f6e 206f 660a 2020 2020 2020 2020 6461  on of.        da
+000121c0: 7461 2070 6163 6b65 7420 6865 6164 6572  ta packet header
+000121d0: 730a 2020 2020 2020 2020 5265 6164 696e  s.        Readin
+000121e0: 6720 7374 616e 6461 7264 2064 7479 7065  g standard dtype
+000121f0: 2069 6d70 726f 7665 7320 7370 6565 642c   improves speed,
+00012200: 2062 7574 2074 696d 6573 7461 6d70 7320   but timestamps 
+00012210: 6e65 6564 2074 6f20 6265 0a20 2020 2020  need to be.     
+00012220: 2020 2072 6563 6f6e 7374 7275 6374 6564     reconstructed
+00012230: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00012240: 2020 2020 2066 696c 6573 697a 6520 3d20       filesize = 
+00012250: 6765 7473 697a 6528 7365 6c66 2e73 6573  getsize(self.ses
+00012260: 7369 6f6e 6469 7220 2b20 7365 7020 2b20  siondir + sep + 
+00012270: 6669 6c65 6e61 6d65 2920 2023 2069 6e20  filename)  # in 
+00012280: 6279 7465 0a20 2020 2020 2020 2069 6620  byte.        if 
+00012290: 6669 6c65 7369 7a65 203e 2031 3633 3834  filesize > 16384
+000122a0: 3a0a 2020 2020 2020 2020 2020 2020 6461  :.            da
+000122b0: 7461 203d 206e 702e 6d65 6d6d 6170 2873  ta = np.memmap(s
+000122c0: 656c 662e 7365 7373 696f 6e64 6972 202b  elf.sessiondir +
+000122d0: 2073 6570 202b 2066 696c 656e 616d 652c   sep + filename,
+000122e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000122f0: 2020 2020 2020 2020 2020 2020 2020 6474                dt
+00012300: 7970 653d 273c 7534 272c 0a20 2020 2020  ype='<u4',.     
+00012310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012320: 2020 2020 2020 2020 7368 6170 653d 2828          shape=((
+00012330: 6669 6c65 7369 7a65 202d 2031 3633 3834  filesize - 16384
+00012340: 2920 2f2f 2034 202f 2f20 3236 312c 2032  ) // 4 // 261, 2
+00012350: 3631 292c 0a20 2020 2020 2020 2020 2020  61),.           
+00012360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012370: 2020 6d6f 6465 3d27 7227 2c20 6f66 6673    mode='r', offs
+00012380: 6574 3d31 3633 3834 290a 0a20 2020 2020  et=16384)..     
+00012390: 2020 2020 2020 2074 7320 3d20 6461 7461         ts = data
+000123a0: 5b3a 2c20 303a 325d 0a20 2020 2020 2020  [:, 0:2].       
+000123b0: 2020 2020 206d 756c 7469 203d 206e 702e       multi = np.
+000123c0: 7265 7065 6174 286e 702e 6172 7261 7928  repeat(np.array(
+000123d0: 5b31 2c20 3220 2a2a 2033 325d 2c20 6e64  [1, 2 ** 32], nd
+000123e0: 6d69 6e3d 3229 2c20 6c65 6e28 6461 7461  min=2), len(data
+000123f0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00012400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012410: 2061 7869 733d 3029 0a20 2020 2020 2020   axis=0).       
+00012420: 2020 2020 2074 696d 6573 7461 6d70 7320       timestamps 
+00012430: 3d20 6e70 2e73 756d 2874 7320 2a20 6d75  = np.sum(ts * mu
+00012440: 6c74 692c 2061 7869 733d 3129 0a20 2020  lti, axis=1).   
+00012450: 2020 2020 2020 2020 2023 2074 696d 6573           # times
+00012460: 7461 6d70 7320 3d20 6461 7461 5b3a 2c30  tamps = data[:,0
+00012470: 5d20 2b20 2864 6174 615b 3a2c 315d 202a  ] + (data[:,1] *
+00012480: 322a 2a33 3229 0a20 2020 2020 2020 2020  2**32).         
+00012490: 2020 2068 6561 6465 725f 7534 203d 2064     header_u4 = d
+000124a0: 6174 615b 3a2c 2032 3a35 5d0a 0a20 2020  ata[:, 2:5]..   
+000124b0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000124c0: 7469 6d65 7374 616d 7073 2c20 6865 6164  timestamps, head
+000124d0: 6572 5f75 340a 2020 2020 2020 2020 656c  er_u4.        el
+000124e0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+000124f0: 7265 7475 726e 204e 6f6e 650a 0a20 2020  return None..   
+00012500: 2064 6566 205f 5f6d 6d61 705f 6e63 735f   def __mmap_ncs_
+00012510: 7061 636b 6574 5f74 696d 6573 7461 6d70  packet_timestamp
+00012520: 7328 7365 6c66 2c20 6669 6c65 6e61 6d65  s(self, filename
+00012530: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
+00012540: 2020 2020 2020 204d 656d 6f72 7920 6d61         Memory ma
+00012550: 7020 6f66 2074 6865 204e 6575 7261 6c79  p of the Neuraly
+00012560: 6e78 202e 6e63 7320 6669 6c65 206f 7074  nx .ncs file opt
+00012570: 696d 697a 6564 2066 6f72 2065 7874 7261  imized for extra
+00012580: 6374 696f 6e20 6f66 0a20 2020 2020 2020  ction of.       
+00012590: 2064 6174 6120 7061 636b 6574 2068 6561   data packet hea
+000125a0: 6465 7273 0a20 2020 2020 2020 2052 6561  ders.        Rea
+000125b0: 6469 6e67 2073 7461 6e64 6172 6420 6474  ding standard dt
+000125c0: 7970 6520 696d 7072 6f76 6573 2073 7065  ype improves spe
+000125d0: 6564 2c20 6275 7420 7469 6d65 7374 616d  ed, but timestam
+000125e0: 7073 206e 6565 6420 746f 2062 650a 2020  ps need to be.  
+000125f0: 2020 2020 2020 7265 636f 6e73 7472 7563        reconstruc
+00012600: 7465 640a 2020 2020 2020 2020 2222 220a  ted.        """.
+00012610: 2020 2020 2020 2020 6669 6c65 7369 7a65          filesize
+00012620: 203d 2067 6574 7369 7a65 2873 656c 662e   = getsize(self.
+00012630: 7365 7373 696f 6e64 6972 202b 2073 6570  sessiondir + sep
+00012640: 202b 2066 696c 656e 616d 6529 2020 2320   + filename)  # 
+00012650: 696e 2062 7974 650a 2020 2020 2020 2020  in byte.        
+00012660: 6966 2066 696c 6573 697a 6520 3e20 3136  if filesize > 16
+00012670: 3338 343a 0a20 2020 2020 2020 2020 2020  384:.           
+00012680: 2064 6174 6120 3d20 6e70 2e6d 656d 6d61   data = np.memma
+00012690: 7028 7365 6c66 2e73 6573 7369 6f6e 6469  p(self.sessiondi
+000126a0: 7220 2b20 7365 7020 2b20 6669 6c65 6e61  r + sep + filena
+000126b0: 6d65 2c0a 2020 2020 2020 2020 2020 2020  me,.            
 000126c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000126d0: 2020 2020 2020 2020 206d 6f64 653d 2772           mode='r
-000126e0: 272c 206f 6666 7365 743d 3136 3338 3429  ', offset=16384)
-000126f0: 0a0a 2020 2020 2020 2020 2020 2020 7473  ..            ts
-00012700: 203d 2064 6174 615b 3a2c 2030 3a32 5d0a   = data[:, 0:2].
-00012710: 2020 2020 2020 2020 2020 2020 6d75 6c74              mult
-00012720: 6920 3d20 6e70 2e72 6570 6561 7428 6e70  i = np.repeat(np
-00012730: 2e61 7272 6179 285b 312c 2032 202a 2a20  .array([1, 2 ** 
-00012740: 3332 5d2c 206e 646d 696e 3d32 292c 206c  32], ndmin=2), l
-00012750: 656e 2864 6174 6129 2c0a 2020 2020 2020  en(data),.      
-00012760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012770: 2020 2020 2020 2020 6178 6973 3d30 290a          axis=0).
-00012780: 2020 2020 2020 2020 2020 2020 7469 6d65              time
-00012790: 7374 616d 7073 203d 206e 702e 7375 6d28  stamps = np.sum(
-000127a0: 7473 202a 206d 756c 7469 2c20 6178 6973  ts * multi, axis
-000127b0: 3d31 290a 2020 2020 2020 2020 2020 2020  =1).            
-000127c0: 2320 7469 6d65 7374 616d 7073 203d 2064  # timestamps = d
-000127d0: 6174 615b 3a2c 305d 202b 2064 6174 615b  ata[:,0] + data[
-000127e0: 3a2c 315d 2a32 2a2a 3332 0a0a 2020 2020  :,1]*2**32..    
-000127f0: 2020 2020 2020 2020 7265 7475 726e 2074          return t
-00012800: 696d 6573 7461 6d70 730a 2020 2020 2020  imestamps.      
-00012810: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00012820: 2020 2020 7265 7475 726e 204e 6f6e 650a      return None.
-00012830: 0a20 2020 2064 6566 205f 5f6d 6d61 705f  .    def __mmap_
-00012840: 6e65 765f 6669 6c65 2873 656c 662c 2066  nev_file(self, f
-00012850: 696c 656e 616d 6529 3a0a 2020 2020 2020  ilename):.      
-00012860: 2020 2222 2220 4d65 6d6f 7279 206d 6170    """ Memory map
-00012870: 2074 6865 204e 6575 7261 6c79 6e78 202e   the Neuralynx .
-00012880: 6e65 7620 6669 6c65 2022 2222 0a20 2020  nev file """.   
-00012890: 2020 2020 206e 6576 5f64 7479 7065 203d       nev_dtype =
-000128a0: 206e 702e 6474 7970 6528 5b0a 2020 2020   np.dtype([.    
-000128b0: 2020 2020 2020 2020 2827 7265 7365 7276          ('reserv
-000128c0: 6564 272c 2027 3c69 3227 292c 0a20 2020  ed', '<i2'),.   
-000128d0: 2020 2020 2020 2020 2028 2773 7973 7465           ('syste
-000128e0: 6d5f 6964 272c 2027 3c69 3227 292c 0a20  m_id', '<i2'),. 
-000128f0: 2020 2020 2020 2020 2020 2028 2764 6174             ('dat
-00012900: 615f 7369 7a65 272c 2027 3c69 3227 292c  a_size', '<i2'),
-00012910: 0a20 2020 2020 2020 2020 2020 2028 2774  .            ('t
-00012920: 696d 6573 7461 6d70 272c 2027 3c75 3827  imestamp', '<u8'
-00012930: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
-00012940: 2765 7665 6e74 5f69 6427 2c20 273c 6932  'event_id', '<i2
-00012950: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
-00012960: 2827 7474 6c5f 696e 7075 7427 2c20 273c  ('ttl_input', '<
-00012970: 6932 2729 2c0a 2020 2020 2020 2020 2020  i2'),.          
-00012980: 2020 2827 6372 635f 6368 6563 6b27 2c20    ('crc_check', 
-00012990: 273c 6932 2729 2c0a 2020 2020 2020 2020  '<i2'),.        
-000129a0: 2020 2020 2827 6475 6d6d 7931 272c 2027      ('dummy1', '
-000129b0: 3c69 3227 292c 0a20 2020 2020 2020 2020  <i2'),.         
-000129c0: 2020 2028 2764 756d 6d79 3227 2c20 273c     ('dummy2', '<
-000129d0: 6932 2729 2c0a 2020 2020 2020 2020 2020  i2'),.          
-000129e0: 2020 2827 6578 7472 6127 2c20 273c 6934    ('extra', '<i4
-000129f0: 272c 2028 382c 2929 2c0a 2020 2020 2020  ', (8,)),.      
-00012a00: 2020 2020 2020 2827 6576 656e 745f 7374        ('event_st
-00012a10: 7269 6e67 272c 2027 6131 3238 2729 2c0a  ring', 'a128'),.
-00012a20: 2020 2020 2020 2020 5d29 0a0a 2020 2020          ])..    
-00012a30: 2020 2020 6966 2067 6574 7369 7a65 2873      if getsize(s
-00012a40: 656c 662e 7365 7373 696f 6e64 6972 202b  elf.sessiondir +
-00012a50: 2073 6570 202b 2066 696c 656e 616d 6529   sep + filename)
-00012a60: 203e 2031 3633 3834 3a0a 2020 2020 2020   > 16384:.      
-00012a70: 2020 2020 2020 7265 7475 726e 206e 702e        return np.
-00012a80: 6d65 6d6d 6170 2873 656c 662e 7365 7373  memmap(self.sess
-00012a90: 696f 6e64 6972 202b 2073 6570 202b 2066  iondir + sep + f
-00012aa0: 696c 656e 616d 652c 0a20 2020 2020 2020  ilename,.       
-00012ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012ac0: 2020 2020 2020 6474 7970 653d 6e65 765f        dtype=nev_
-00012ad0: 6474 7970 652c 206d 6f64 653d 2772 272c  dtype, mode='r',
-00012ae0: 206f 6666 7365 743d 3136 3338 3429 0a20   offset=16384). 
-00012af0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00012b00: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00012b10: 4e6f 6e65 0a0a 2020 2020 6465 6620 5f5f  None..    def __
-00012b20: 6d6d 6170 5f6e 7474 5f66 696c 6528 7365  mmap_ntt_file(se
-00012b30: 6c66 2c20 6669 6c65 6e61 6d65 293a 0a20  lf, filename):. 
-00012b40: 2020 2020 2020 2022 2222 204d 656d 6f72         """ Memor
-00012b50: 7920 6d61 7020 7468 6520 4e65 7572 616c  y map the Neural
-00012b60: 796e 7820 2e6e 7365 2066 696c 6520 2222  ynx .nse file ""
-00012b70: 220a 2020 2020 2020 2020 6e73 655f 6474  ".        nse_dt
-00012b80: 7970 6520 3d20 6e70 2e64 7479 7065 285b  ype = np.dtype([
-00012b90: 0a20 2020 2020 2020 2020 2020 2028 2774  .            ('t
-00012ba0: 696d 6573 7461 6d70 272c 2027 3c75 3827  imestamp', '<u8'
-00012bb0: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
-00012bc0: 2773 635f 6e75 6d62 6572 272c 2027 3c75  'sc_number', '<u
-00012bd0: 3427 292c 0a20 2020 2020 2020 2020 2020  4'),.           
-00012be0: 2028 2763 656c 6c5f 6e75 6d62 6572 272c   ('cell_number',
-00012bf0: 2027 3c75 3427 292c 0a20 2020 2020 2020   '<u4'),.       
-00012c00: 2020 2020 2028 2770 6172 616d 7327 2c20       ('params', 
-00012c10: 273c 7534 272c 2028 382c 2929 2c0a 2020  '<u4', (8,)),.  
-00012c20: 2020 2020 2020 2020 2020 2827 6461 7461            ('data
-00012c30: 272c 2027 3c69 3227 2c20 2833 322c 2034  ', '<i2', (32, 4
-00012c40: 2929 2c0a 2020 2020 2020 2020 5d29 0a20  )),.        ]). 
-00012c50: 2020 2020 2020 2069 6620 6765 7473 697a         if getsiz
-00012c60: 6528 7365 6c66 2e73 6573 7369 6f6e 6469  e(self.sessiondi
-00012c70: 7220 2b20 7365 7020 2b20 6669 6c65 6e61  r + sep + filena
-00012c80: 6d65 2920 3e20 3136 3338 343a 0a20 2020  me) > 16384:.   
-00012c90: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00012ca0: 6e70 2e6d 656d 6d61 7028 7365 6c66 2e73  np.memmap(self.s
-00012cb0: 6573 7369 6f6e 6469 7220 2b20 7365 7020  essiondir + sep 
-00012cc0: 2b20 6669 6c65 6e61 6d65 2c0a 2020 2020  + filename,.    
-00012cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012ce0: 2020 2020 2020 2020 2064 7479 7065 3d6e           dtype=n
-00012cf0: 7365 5f64 7479 7065 2c20 6d6f 6465 3d27  se_dtype, mode='
-00012d00: 7227 2c20 6f66 6673 6574 3d31 3633 3834  r', offset=16384
-00012d10: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-00012d20: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00012d30: 726e 204e 6f6e 650a 0a20 2020 2064 6566  rn None..    def
-00012d40: 205f 5f6d 6d61 705f 6e74 745f 7061 636b   __mmap_ntt_pack
-00012d50: 6574 7328 7365 6c66 2c20 6669 6c65 6e61  ets(self, filena
-00012d60: 6d65 293a 0a20 2020 2020 2020 2022 2222  me):.        """
-00012d70: 0a20 2020 2020 2020 204d 656d 6f72 7920  .        Memory 
-00012d80: 6d61 7020 6f66 2074 6865 204e 6575 7261  map of the Neura
-00012d90: 6c79 6e78 202e 6e63 7320 6669 6c65 206f  lynx .ncs file o
-00012da0: 7074 696d 697a 6564 2066 6f72 2065 7874  ptimized for ext
-00012db0: 7261 6374 696f 6e20 6f66 0a20 2020 2020  raction of.     
-00012dc0: 2020 2064 6174 6120 7061 636b 6574 2068     data packet h
-00012dd0: 6561 6465 7273 0a20 2020 2020 2020 2052  eaders.        R
-00012de0: 6561 6469 6e67 2073 7461 6e64 6172 6420  eading standard 
-00012df0: 6474 7970 6520 696d 7072 6f76 6573 2073  dtype improves s
-00012e00: 7065 6564 2c20 6275 7420 7469 6d65 7374  peed, but timest
-00012e10: 616d 7073 206e 6565 6420 746f 2062 650a  amps need to be.
-00012e20: 2020 2020 2020 2020 7265 636f 6e73 7472          reconstr
-00012e30: 7563 7465 640a 2020 2020 2020 2020 2222  ucted.        ""
-00012e40: 220a 2020 2020 2020 2020 6669 6c65 7369  ".        filesi
-00012e50: 7a65 203d 2067 6574 7369 7a65 2873 656c  ze = getsize(sel
-00012e60: 662e 7365 7373 696f 6e64 6972 202b 2073  f.sessiondir + s
-00012e70: 6570 202b 2066 696c 656e 616d 6529 2020  ep + filename)  
-00012e80: 2320 696e 2062 7974 650a 2020 2020 2020  # in byte.      
-00012e90: 2020 6966 2066 696c 6573 697a 6520 3e20    if filesize > 
-00012ea0: 3136 3338 343a 0a20 2020 2020 2020 2020  16384:.         
-00012eb0: 2020 2064 6174 6120 3d20 6e70 2e6d 656d     data = np.mem
-00012ec0: 6d61 7028 7365 6c66 2e73 6573 7369 6f6e  map(self.session
-00012ed0: 6469 7220 2b20 7365 7020 2b20 6669 6c65  dir + sep + file
-00012ee0: 6e61 6d65 2c0a 2020 2020 2020 2020 2020  name,.          
-00012ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012f00: 2020 2064 7479 7065 3d27 3c75 3227 2c0a     dtype='<u2',.
-00012f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012f20: 2020 2020 2020 2020 2020 2020 2073 6861               sha
-00012f30: 7065 3d28 2866 696c 6573 697a 6520 2d20  pe=((filesize - 
-00012f40: 3136 3338 3429 202f 2032 202f 2031 3532  16384) / 2 / 152
-00012f50: 2c20 3135 3229 2c0a 2020 2020 2020 2020  , 152),.        
+000126d0: 2064 7479 7065 3d27 3c75 3427 2c0a 2020   dtype='<u4',.  
+000126e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000126f0: 2020 2020 2020 2020 2020 2073 6861 7065             shape
+00012700: 3d28 696e 7428 2866 696c 6573 697a 6520  =(int((filesize 
+00012710: 2d20 3136 3338 3429 202f 2034 202f 2032  - 16384) / 4 / 2
+00012720: 3631 292c 2032 3631 292c 0a20 2020 2020  61), 261),.     
+00012730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012740: 2020 2020 2020 2020 6d6f 6465 3d27 7227          mode='r'
+00012750: 2c20 6f66 6673 6574 3d31 3633 3834 290a  , offset=16384).
+00012760: 0a20 2020 2020 2020 2020 2020 2074 7320  .            ts 
+00012770: 3d20 6461 7461 5b3a 2c20 303a 325d 0a20  = data[:, 0:2]. 
+00012780: 2020 2020 2020 2020 2020 206d 756c 7469             multi
+00012790: 203d 206e 702e 7265 7065 6174 286e 702e   = np.repeat(np.
+000127a0: 6172 7261 7928 5b31 2c20 3220 2a2a 2033  array([1, 2 ** 3
+000127b0: 325d 2c20 6e64 6d69 6e3d 3229 2c20 6c65  2], ndmin=2), le
+000127c0: 6e28 6461 7461 292c 0a20 2020 2020 2020  n(data),.       
+000127d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000127e0: 2020 2020 2020 2061 7869 733d 3029 0a20         axis=0). 
+000127f0: 2020 2020 2020 2020 2020 2074 696d 6573             times
+00012800: 7461 6d70 7320 3d20 6e70 2e73 756d 2874  tamps = np.sum(t
+00012810: 7320 2a20 6d75 6c74 692c 2061 7869 733d  s * multi, axis=
+00012820: 3129 0a20 2020 2020 2020 2020 2020 2023  1).            #
+00012830: 2074 696d 6573 7461 6d70 7320 3d20 6461   timestamps = da
+00012840: 7461 5b3a 2c30 5d20 2b20 6461 7461 5b3a  ta[:,0] + data[:
+00012850: 2c31 5d2a 322a 2a33 320a 0a20 2020 2020  ,1]*2**32..     
+00012860: 2020 2020 2020 2072 6574 7572 6e20 7469         return ti
+00012870: 6d65 7374 616d 7073 0a20 2020 2020 2020  mestamps.       
+00012880: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00012890: 2020 2072 6574 7572 6e20 4e6f 6e65 0a0a     return None..
+000128a0: 2020 2020 6465 6620 5f5f 6d6d 6170 5f6e      def __mmap_n
+000128b0: 6576 5f66 696c 6528 7365 6c66 2c20 6669  ev_file(self, fi
+000128c0: 6c65 6e61 6d65 293a 0a20 2020 2020 2020  lename):.       
+000128d0: 2022 2222 204d 656d 6f72 7920 6d61 7020   """ Memory map 
+000128e0: 7468 6520 4e65 7572 616c 796e 7820 2e6e  the Neuralynx .n
+000128f0: 6576 2066 696c 6520 2222 220a 2020 2020  ev file """.    
+00012900: 2020 2020 6e65 765f 6474 7970 6520 3d20      nev_dtype = 
+00012910: 6e70 2e64 7479 7065 285b 0a20 2020 2020  np.dtype([.     
+00012920: 2020 2020 2020 2028 2772 6573 6572 7665         ('reserve
+00012930: 6427 2c20 273c 6932 2729 2c0a 2020 2020  d', '<i2'),.    
+00012940: 2020 2020 2020 2020 2827 7379 7374 656d          ('system
+00012950: 5f69 6427 2c20 273c 6932 2729 2c0a 2020  _id', '<i2'),.  
+00012960: 2020 2020 2020 2020 2020 2827 6461 7461            ('data
+00012970: 5f73 697a 6527 2c20 273c 6932 2729 2c0a  _size', '<i2'),.
+00012980: 2020 2020 2020 2020 2020 2020 2827 7469              ('ti
+00012990: 6d65 7374 616d 7027 2c20 273c 7538 2729  mestamp', '<u8')
+000129a0: 2c0a 2020 2020 2020 2020 2020 2020 2827  ,.            ('
+000129b0: 6576 656e 745f 6964 272c 2027 3c69 3227  event_id', '<i2'
+000129c0: 292c 0a20 2020 2020 2020 2020 2020 2028  ),.            (
+000129d0: 2774 746c 5f69 6e70 7574 272c 2027 3c69  'ttl_input', '<i
+000129e0: 3227 292c 0a20 2020 2020 2020 2020 2020  2'),.           
+000129f0: 2028 2763 7263 5f63 6865 636b 272c 2027   ('crc_check', '
+00012a00: 3c69 3227 292c 0a20 2020 2020 2020 2020  <i2'),.         
+00012a10: 2020 2028 2764 756d 6d79 3127 2c20 273c     ('dummy1', '<
+00012a20: 6932 2729 2c0a 2020 2020 2020 2020 2020  i2'),.          
+00012a30: 2020 2827 6475 6d6d 7932 272c 2027 3c69    ('dummy2', '<i
+00012a40: 3227 292c 0a20 2020 2020 2020 2020 2020  2'),.           
+00012a50: 2028 2765 7874 7261 272c 2027 3c69 3427   ('extra', '<i4'
+00012a60: 2c20 2838 2c29 292c 0a20 2020 2020 2020  , (8,)),.       
+00012a70: 2020 2020 2028 2765 7665 6e74 5f73 7472       ('event_str
+00012a80: 696e 6727 2c20 2761 3132 3827 292c 0a20  ing', 'a128'),. 
+00012a90: 2020 2020 2020 205d 290a 0a20 2020 2020         ])..     
+00012aa0: 2020 2069 6620 6765 7473 697a 6528 7365     if getsize(se
+00012ab0: 6c66 2e73 6573 7369 6f6e 6469 7220 2b20  lf.sessiondir + 
+00012ac0: 7365 7020 2b20 6669 6c65 6e61 6d65 2920  sep + filename) 
+00012ad0: 3e20 3136 3338 343a 0a20 2020 2020 2020  > 16384:.       
+00012ae0: 2020 2020 2072 6574 7572 6e20 6e70 2e6d       return np.m
+00012af0: 656d 6d61 7028 7365 6c66 2e73 6573 7369  emmap(self.sessi
+00012b00: 6f6e 6469 7220 2b20 7365 7020 2b20 6669  ondir + sep + fi
+00012b10: 6c65 6e61 6d65 2c0a 2020 2020 2020 2020  lename,.        
+00012b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012b30: 2020 2020 2064 7479 7065 3d6e 6576 5f64       dtype=nev_d
+00012b40: 7479 7065 2c20 6d6f 6465 3d27 7227 2c20  type, mode='r', 
+00012b50: 6f66 6673 6574 3d31 3633 3834 290a 2020  offset=16384).  
+00012b60: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00012b70: 2020 2020 2020 2020 7265 7475 726e 204e          return N
+00012b80: 6f6e 650a 0a20 2020 2064 6566 205f 5f6d  one..    def __m
+00012b90: 6d61 705f 6e74 745f 6669 6c65 2873 656c  map_ntt_file(sel
+00012ba0: 662c 2066 696c 656e 616d 6529 3a0a 2020  f, filename):.  
+00012bb0: 2020 2020 2020 2222 2220 4d65 6d6f 7279        """ Memory
+00012bc0: 206d 6170 2074 6865 204e 6575 7261 6c79   map the Neuraly
+00012bd0: 6e78 202e 6e73 6520 6669 6c65 2022 2222  nx .nse file """
+00012be0: 0a20 2020 2020 2020 206e 7365 5f64 7479  .        nse_dty
+00012bf0: 7065 203d 206e 702e 6474 7970 6528 5b0a  pe = np.dtype([.
+00012c00: 2020 2020 2020 2020 2020 2020 2827 7469              ('ti
+00012c10: 6d65 7374 616d 7027 2c20 273c 7538 2729  mestamp', '<u8')
+00012c20: 2c0a 2020 2020 2020 2020 2020 2020 2827  ,.            ('
+00012c30: 7363 5f6e 756d 6265 7227 2c20 273c 7534  sc_number', '<u4
+00012c40: 2729 2c0a 2020 2020 2020 2020 2020 2020  '),.            
+00012c50: 2827 6365 6c6c 5f6e 756d 6265 7227 2c20  ('cell_number', 
+00012c60: 273c 7534 2729 2c0a 2020 2020 2020 2020  '<u4'),.        
+00012c70: 2020 2020 2827 7061 7261 6d73 272c 2027      ('params', '
+00012c80: 3c75 3427 2c20 2838 2c29 292c 0a20 2020  <u4', (8,)),.   
+00012c90: 2020 2020 2020 2020 2028 2764 6174 6127           ('data'
+00012ca0: 2c20 273c 6932 272c 2028 3332 2c20 3429  , '<i2', (32, 4)
+00012cb0: 292c 0a20 2020 2020 2020 205d 290a 2020  ),.        ]).  
+00012cc0: 2020 2020 2020 6966 2067 6574 7369 7a65        if getsize
+00012cd0: 2873 656c 662e 7365 7373 696f 6e64 6972  (self.sessiondir
+00012ce0: 202b 2073 6570 202b 2066 696c 656e 616d   + sep + filenam
+00012cf0: 6529 203e 2031 3633 3834 3a0a 2020 2020  e) > 16384:.    
+00012d00: 2020 2020 2020 2020 7265 7475 726e 206e          return n
+00012d10: 702e 6d65 6d6d 6170 2873 656c 662e 7365  p.memmap(self.se
+00012d20: 7373 696f 6e64 6972 202b 2073 6570 202b  ssiondir + sep +
+00012d30: 2066 696c 656e 616d 652c 0a20 2020 2020   filename,.     
+00012d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012d50: 2020 2020 2020 2020 6474 7970 653d 6e73          dtype=ns
+00012d60: 655f 6474 7970 652c 206d 6f64 653d 2772  e_dtype, mode='r
+00012d70: 272c 206f 6666 7365 743d 3136 3338 3429  ', offset=16384)
+00012d80: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00012d90: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00012da0: 6e20 4e6f 6e65 0a0a 2020 2020 6465 6620  n None..    def 
+00012db0: 5f5f 6d6d 6170 5f6e 7474 5f70 6163 6b65  __mmap_ntt_packe
+00012dc0: 7473 2873 656c 662c 2066 696c 656e 616d  ts(self, filenam
+00012dd0: 6529 3a0a 2020 2020 2020 2020 2222 220a  e):.        """.
+00012de0: 2020 2020 2020 2020 4d65 6d6f 7279 206d          Memory m
+00012df0: 6170 206f 6620 7468 6520 4e65 7572 616c  ap of the Neural
+00012e00: 796e 7820 2e6e 6373 2066 696c 6520 6f70  ynx .ncs file op
+00012e10: 7469 6d69 7a65 6420 666f 7220 6578 7472  timized for extr
+00012e20: 6163 7469 6f6e 206f 660a 2020 2020 2020  action of.      
+00012e30: 2020 6461 7461 2070 6163 6b65 7420 6865    data packet he
+00012e40: 6164 6572 730a 2020 2020 2020 2020 5265  aders.        Re
+00012e50: 6164 696e 6720 7374 616e 6461 7264 2064  ading standard d
+00012e60: 7479 7065 2069 6d70 726f 7665 7320 7370  type improves sp
+00012e70: 6565 642c 2062 7574 2074 696d 6573 7461  eed, but timesta
+00012e80: 6d70 7320 6e65 6564 2074 6f20 6265 0a20  mps need to be. 
+00012e90: 2020 2020 2020 2072 6563 6f6e 7374 7275         reconstru
+00012ea0: 6374 6564 0a20 2020 2020 2020 2022 2222  cted.        """
+00012eb0: 0a20 2020 2020 2020 2066 696c 6573 697a  .        filesiz
+00012ec0: 6520 3d20 6765 7473 697a 6528 7365 6c66  e = getsize(self
+00012ed0: 2e73 6573 7369 6f6e 6469 7220 2b20 7365  .sessiondir + se
+00012ee0: 7020 2b20 6669 6c65 6e61 6d65 2920 2023  p + filename)  #
+00012ef0: 2069 6e20 6279 7465 0a20 2020 2020 2020   in byte.       
+00012f00: 2069 6620 6669 6c65 7369 7a65 203e 2031   if filesize > 1
+00012f10: 3633 3834 3a0a 2020 2020 2020 2020 2020  6384:.          
+00012f20: 2020 6461 7461 203d 206e 702e 6d65 6d6d    data = np.memm
+00012f30: 6170 2873 656c 662e 7365 7373 696f 6e64  ap(self.sessiond
+00012f40: 6972 202b 2073 6570 202b 2066 696c 656e  ir + sep + filen
+00012f50: 616d 652c 0a20 2020 2020 2020 2020 2020  ame,.           
 00012f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012f70: 2020 2020 206d 6f64 653d 2772 272c 206f       mode='r', o
-00012f80: 6666 7365 743d 3136 3338 3429 0a0a 2020  ffset=16384)..  
-00012f90: 2020 2020 2020 2020 2020 2320 7265 636f            # reco
-00012fa0: 6e73 7472 7563 7469 6e67 206f 7269 6769  nstructing origi
-00012fb0: 6e61 6c20 6461 7461 0a20 2020 2020 2020  nal data.       
-00012fc0: 2020 2020 2023 2066 6972 7374 2034 2069       # first 4 i
-00012fd0: 6e74 7320 2d3e 2074 696d 6573 7461 6d70  nts -> timestamp
-00012fe0: 2069 6e20 6d69 6372 6f73 6563 0a20 2020   in microsec.   
-00012ff0: 2020 2020 2020 2020 2074 696d 6573 7461           timesta
-00013000: 6d70 7320 3d20 6461 7461 5b3a 2c20 305d  mps = data[:, 0]
-00013010: 202b 2064 6174 615b 3a2c 2031 5d20 2a20   + data[:, 1] * 
-00013020: 3220 2a2a 2031 3620 2b20 5c0a 2020 2020  2 ** 16 + \.    
-00013030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013040: 2020 2020 2064 6174 615b 3a2c 2032 5d20       data[:, 2] 
-00013050: 2a20 3220 2a2a 2033 3220 2b20 6461 7461  * 2 ** 32 + data
-00013060: 5b3a 2c20 335d 202a 2032 202a 2a20 3438  [:, 3] * 2 ** 48
-00013070: 0a20 2020 2020 2020 2020 2020 2063 6861  .            cha
-00013080: 6e6e 656c 5f69 6420 3d20 6461 7461 5b3a  nnel_id = data[:
-00013090: 2c20 345d 202b 2064 6174 615b 3a2c 2035  , 4] + data[:, 5
-000130a0: 5d20 2a20 3220 2a2a 2031 360a 2020 2020  ] * 2 ** 16.    
-000130b0: 2020 2020 2020 2020 6365 6c6c 5f6e 756d          cell_num
-000130c0: 6265 7220 3d20 6461 7461 5b3a 2c20 365d  ber = data[:, 6]
-000130d0: 202b 2064 6174 615b 3a2c 2037 5d20 2a20   + data[:, 7] * 
-000130e0: 3220 2a2a 2031 360a 2020 2020 2020 2020  2 ** 16.        
-000130f0: 2020 2020 6665 6174 7572 6573 203d 205b      features = [
-00013100: 6461 7461 5b3a 2c20 705d 202b 2064 6174  data[:, p] + dat
-00013110: 615b 3a2c 2070 202b 2031 5d20 2a20 3220  a[:, p + 1] * 2 
-00013120: 2a2a 2031 3620 666f 7220 7020 696e 0a20  ** 16 for p in. 
-00013130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013140: 2020 2020 2020 2072 616e 6765 2838 2c20         range(8, 
-00013150: 3233 2c20 3229 5d0a 2020 2020 2020 2020  23, 2)].        
-00013160: 2020 2020 6665 6174 7572 6573 203d 206e      features = n
-00013170: 702e 6172 7261 7928 6665 6174 7572 6573  p.array(features
-00013180: 2c20 6474 7970 653d 2769 3427 290a 0a20  , dtype='i4').. 
-00013190: 2020 2020 2020 2020 2020 2064 6174 615f             data_
-000131a0: 706f 696e 7473 203d 2064 6174 615b 3a2c  points = data[:,
-000131b0: 2032 343a 3135 325d 2e61 7374 7970 6528   24:152].astype(
-000131c0: 2769 3227 292e 7265 7368 6170 6528 2834  'i2').reshape((4
-000131d0: 2c20 3332 2929 0a20 2020 2020 2020 2020  , 32)).         
-000131e0: 2020 2064 656c 2064 6174 610a 2020 2020     del data.    
-000131f0: 2020 2020 2020 2020 7265 7475 726e 2074          return t
-00013200: 696d 6573 7461 6d70 732c 2063 6861 6e6e  imestamps, chann
-00013210: 656c 5f69 642c 2063 656c 6c5f 6e75 6d62  el_id, cell_numb
-00013220: 6572 2c20 6665 6174 7572 6573 2c20 6461  er, features, da
-00013230: 7461 5f70 6f69 6e74 730a 2020 2020 2020  ta_points.      
-00013240: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00013250: 2020 2020 7265 7475 726e 204e 6f6e 650a      return None.
-00013260: 0a20 2020 2023 205f 5f5f 5f5f 5f5f 5f5f  .    # _________
-00013270: 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f  ________________
-00013280: 5f5f 2068 6561 6465 7220 6578 7472 6163  __ header extrac
-00013290: 7469 6f6e 205f 5f5f 5f5f 5f5f 5f5f 5f5f  tion ___________
-000132a0: 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f0a  _______________.
-000132b0: 0a20 2020 2064 6566 205f 5f72 6561 645f  .    def __read_
-000132c0: 7465 7874 5f68 6561 6465 7228 7365 6c66  text_header(self
-000132d0: 2c20 6669 6c65 6e61 6d65 2c20 7061 7261  , filename, para
-000132e0: 6d65 7465 725f 6469 6374 293a 0a20 2020  meter_dict):.   
-000132f0: 2020 2020 2023 2052 6561 6469 6e67 206d       # Reading m
-00013300: 6169 6e20 6669 6c65 2068 6561 6465 7220  ain file header 
-00013310: 2870 6c61 696e 2074 6578 742c 2031 366b  (plain text, 16k
-00013320: 4229 0a20 2020 2020 2020 2074 6578 745f  B).        text_
-00013330: 6865 6164 6572 203d 2063 6f64 6563 732e  header = codecs.
-00013340: 6f70 656e 2873 656c 662e 7365 7373 696f  open(self.sessio
-00013350: 6e64 6972 202b 2073 6570 202b 2066 696c  ndir + sep + fil
-00013360: 656e 616d 652c 2027 7227 2c0a 2020 2020  ename, 'r',.    
-00013370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013380: 2020 2020 2020 2020 2020 2020 2020 276c                'l
-00013390: 6174 696e 2d31 2729 2e72 6561 6428 3136  atin-1').read(16
-000133a0: 3338 3429 0a0a 2020 2020 2020 2020 2320  384)..        # 
-000133b0: 6e65 6365 7373 6172 7920 7465 7874 2065  necessary text e
-000133c0: 6e63 6f64 696e 6720 6465 7065 6e64 7320  ncoding depends 
-000133d0: 6f6e 2050 7974 686f 6e20 7665 7273 696f  on Python versio
-000133e0: 6e0a 2020 2020 2020 2020 6966 2073 7973  n.        if sys
-000133f0: 2e76 6572 7369 6f6e 5f69 6e66 6f2e 6d61  .version_info.ma
-00013400: 6a6f 7220 3c20 333a 0a20 2020 2020 2020  jor < 3:.       
-00013410: 2020 2020 2074 6578 745f 6865 6164 6572       text_header
-00013420: 203d 2074 6578 745f 6865 6164 6572 2e65   = text_header.e
-00013430: 6e63 6f64 6528 276c 6174 696e 2d31 2729  ncode('latin-1')
-00013440: 0a0a 2020 2020 2020 2020 7061 7261 6d65  ..        parame
-00013450: 7465 725f 6469 6374 5b27 6368 6565 7461  ter_dict['cheeta
-00013460: 685f 7665 7273 696f 6e27 5d20 3d20 5c0a  h_version'] = \.
-00013470: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00013480: 2e5f 5f67 6574 5f63 6865 6574 6168 5f76  .__get_cheetah_v
-00013490: 6572 7369 6f6e 5f66 726f 6d5f 7478 745f  ersion_from_txt_
-000134a0: 6865 6164 6572 2874 6578 745f 6865 6164  header(text_head
-000134b0: 6572 2c20 6669 6c65 6e61 6d65 290a 0a20  er, filename).. 
-000134c0: 2020 2020 2020 2070 6172 616d 6574 6572         parameter
-000134d0: 5f64 6963 742e 7570 6461 7465 2873 656c  _dict.update(sel
-000134e0: 662e 5f5f 6765 745f 6669 6c65 6e61 6d65  f.__get_filename
-000134f0: 5f61 6e64 5f74 696d 6573 5f66 726f 6d5f  _and_times_from_
-00013500: 7478 745f 6865 6164 6572 280a 2020 2020  txt_header(.    
-00013510: 2020 2020 2020 2020 7465 7874 5f68 6561          text_hea
-00013520: 6465 722c 2070 6172 616d 6574 6572 5f64  der, parameter_d
-00013530: 6963 745b 2763 6865 6574 6168 5f76 6572  ict['cheetah_ver
-00013540: 7369 6f6e 275d 2929 0a20 2020 2020 2020  sion'])).       
-00013550: 2023 2073 6570 6172 6174 696e 6720 6c69   # separating li
-00013560: 6e65 7320 6f66 2068 6561 6465 7220 616e  nes of header an
-00013570: 6420 6967 6e6f 7269 6e67 206c 6173 7420  d ignoring last 
-00013580: 6c69 6e65 2028 6669 6c6c 292c 2063 6865  line (fill), che
-00013590: 636b 2069 660a 2020 2020 2020 2020 2320  ck if.        # 
-000135a0: 4c69 6e75 7820 6f72 2057 696e 646f 7773  Linux or Windows
-000135b0: 204f 530a 2020 2020 2020 2020 6966 2073   OS.        if s
-000135c0: 6570 203d 3d20 272f 273a 0a20 2020 2020  ep == '/':.     
-000135d0: 2020 2020 2020 2074 6578 745f 6865 6164         text_head
-000135e0: 6572 203d 2074 6578 745f 6865 6164 6572  er = text_header
-000135f0: 2e73 706c 6974 2827 5c72 5c6e 2729 5b3a  .split('\r\n')[:
-00013600: 2d31 5d0a 2020 2020 2020 2020 6966 2073  -1].        if s
-00013610: 6570 203d 3d20 275c 5c27 3a0a 2020 2020  ep == '\\':.    
-00013620: 2020 2020 2020 2020 7465 7874 5f68 6561          text_hea
-00013630: 6465 7220 3d20 7465 7874 5f68 6561 6465  der = text_heade
-00013640: 722e 7370 6c69 7428 275c 6e27 295b 3a2d  r.split('\n')[:-
-00013650: 315d 0a0a 2020 2020 2020 2020 2320 6d69  1]..        # mi
-00013660: 6e6f 7220 7061 7261 6d65 7465 7273 2070  nor parameters p
-00013670: 6f73 7369 626c 7920 7361 7665 6420 696e  ossibly saved in
-00013680: 2068 6561 6465 7220 2866 6f72 2061 6e79   header (for any
-00013690: 2066 696c 6520 7479 7065 290a 2020 2020   file type).    
-000136a0: 2020 2020 6d69 6e6f 725f 6b65 7973 203d      minor_keys =
-000136b0: 205b 2741 6371 456e 744e 616d 6527 2c0a   ['AcqEntName',.
-000136c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000136d0: 2020 2020 2020 2746 696c 6554 7970 6527        'FileType'
-000136e0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000136f0: 2020 2020 2020 2020 2746 696c 6556 6572          'FileVer
-00013700: 7369 6f6e 272c 0a20 2020 2020 2020 2020  sion',.         
-00013710: 2020 2020 2020 2020 2020 2020 2027 5265               'Re
-00013720: 636f 7264 5369 7a65 272c 0a20 2020 2020  cordSize',.     
+00012f70: 2020 6474 7970 653d 273c 7532 272c 0a20    dtype='<u2',. 
+00012f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012f90: 2020 2020 2020 2020 2020 2020 7368 6170              shap
+00012fa0: 653d 2828 6669 6c65 7369 7a65 202d 2031  e=((filesize - 1
+00012fb0: 3633 3834 2920 2f20 3220 2f20 3135 322c  6384) / 2 / 152,
+00012fc0: 2031 3532 292c 0a20 2020 2020 2020 2020   152),.         
+00012fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012fe0: 2020 2020 6d6f 6465 3d27 7227 2c20 6f66      mode='r', of
+00012ff0: 6673 6574 3d31 3633 3834 290a 0a20 2020  fset=16384)..   
+00013000: 2020 2020 2020 2020 2023 2072 6563 6f6e           # recon
+00013010: 7374 7275 6374 696e 6720 6f72 6967 696e  structing origin
+00013020: 616c 2064 6174 610a 2020 2020 2020 2020  al data.        
+00013030: 2020 2020 2320 6669 7273 7420 3420 696e      # first 4 in
+00013040: 7473 202d 3e20 7469 6d65 7374 616d 7020  ts -> timestamp 
+00013050: 696e 206d 6963 726f 7365 630a 2020 2020  in microsec.    
+00013060: 2020 2020 2020 2020 7469 6d65 7374 616d          timestam
+00013070: 7073 203d 2064 6174 615b 3a2c 2030 5d20  ps = data[:, 0] 
+00013080: 2b20 6461 7461 5b3a 2c20 315d 202a 2032  + data[:, 1] * 2
+00013090: 202a 2a20 3136 202b 205c 0a20 2020 2020   ** 16 + \.     
+000130a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000130b0: 2020 2020 6461 7461 5b3a 2c20 325d 202a      data[:, 2] *
+000130c0: 2032 202a 2a20 3332 202b 2064 6174 615b   2 ** 32 + data[
+000130d0: 3a2c 2033 5d20 2a20 3220 2a2a 2034 380a  :, 3] * 2 ** 48.
+000130e0: 2020 2020 2020 2020 2020 2020 6368 616e              chan
+000130f0: 6e65 6c5f 6964 203d 2064 6174 615b 3a2c  nel_id = data[:,
+00013100: 2034 5d20 2b20 6461 7461 5b3a 2c20 355d   4] + data[:, 5]
+00013110: 202a 2032 202a 2a20 3136 0a20 2020 2020   * 2 ** 16.     
+00013120: 2020 2020 2020 2063 656c 6c5f 6e75 6d62         cell_numb
+00013130: 6572 203d 2064 6174 615b 3a2c 2036 5d20  er = data[:, 6] 
+00013140: 2b20 6461 7461 5b3a 2c20 375d 202a 2032  + data[:, 7] * 2
+00013150: 202a 2a20 3136 0a20 2020 2020 2020 2020   ** 16.         
+00013160: 2020 2066 6561 7475 7265 7320 3d20 5b64     features = [d
+00013170: 6174 615b 3a2c 2070 5d20 2b20 6461 7461  ata[:, p] + data
+00013180: 5b3a 2c20 7020 2b20 315d 202a 2032 202a  [:, p + 1] * 2 *
+00013190: 2a20 3136 2066 6f72 2070 2069 6e0a 2020  * 16 for p in.  
+000131a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000131b0: 2020 2020 2020 7261 6e67 6528 382c 2032        range(8, 2
+000131c0: 332c 2032 295d 0a20 2020 2020 2020 2020  3, 2)].         
+000131d0: 2020 2066 6561 7475 7265 7320 3d20 6e70     features = np
+000131e0: 2e61 7272 6179 2866 6561 7475 7265 732c  .array(features,
+000131f0: 2064 7479 7065 3d27 6934 2729 0a0a 2020   dtype='i4')..  
+00013200: 2020 2020 2020 2020 2020 6461 7461 5f70            data_p
+00013210: 6f69 6e74 7320 3d20 6461 7461 5b3a 2c20  oints = data[:, 
+00013220: 3234 3a31 3532 5d2e 6173 7479 7065 2827  24:152].astype('
+00013230: 6932 2729 2e72 6573 6861 7065 2828 342c  i2').reshape((4,
+00013240: 2033 3229 290a 2020 2020 2020 2020 2020   32)).          
+00013250: 2020 6465 6c20 6461 7461 0a20 2020 2020    del data.     
+00013260: 2020 2020 2020 2072 6574 7572 6e20 7469         return ti
+00013270: 6d65 7374 616d 7073 2c20 6368 616e 6e65  mestamps, channe
+00013280: 6c5f 6964 2c20 6365 6c6c 5f6e 756d 6265  l_id, cell_numbe
+00013290: 722c 2066 6561 7475 7265 732c 2064 6174  r, features, dat
+000132a0: 615f 706f 696e 7473 0a20 2020 2020 2020  a_points.       
+000132b0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000132c0: 2020 2072 6574 7572 6e20 4e6f 6e65 0a0a     return None..
+000132d0: 2020 2020 2320 5f5f 5f5f 5f5f 5f5f 5f5f      # __________
+000132e0: 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f  ________________
+000132f0: 5f20 6865 6164 6572 2065 7874 7261 6374  _ header extract
+00013300: 696f 6e20 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f  ion ____________
+00013310: 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 0a0a  ______________..
+00013320: 2020 2020 6465 6620 5f5f 7265 6164 5f74      def __read_t
+00013330: 6578 745f 6865 6164 6572 2873 656c 662c  ext_header(self,
+00013340: 2066 696c 656e 616d 652c 2070 6172 616d   filename, param
+00013350: 6574 6572 5f64 6963 7429 3a0a 2020 2020  eter_dict):.    
+00013360: 2020 2020 2320 5265 6164 696e 6720 6d61      # Reading ma
+00013370: 696e 2066 696c 6520 6865 6164 6572 2028  in file header (
+00013380: 706c 6169 6e20 7465 7874 2c20 3136 6b42  plain text, 16kB
+00013390: 290a 2020 2020 2020 2020 7465 7874 5f68  ).        text_h
+000133a0: 6561 6465 7220 3d20 636f 6465 6373 2e6f  eader = codecs.o
+000133b0: 7065 6e28 7365 6c66 2e73 6573 7369 6f6e  pen(self.session
+000133c0: 6469 7220 2b20 7365 7020 2b20 6669 6c65  dir + sep + file
+000133d0: 6e61 6d65 2c20 2772 272c 0a20 2020 2020  name, 'r',.     
+000133e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000133f0: 2020 2020 2020 2020 2020 2020 2027 6c61               'la
+00013400: 7469 6e2d 3127 292e 7265 6164 2831 3633  tin-1').read(163
+00013410: 3834 290a 0a20 2020 2020 2020 2070 6172  84)..        par
+00013420: 616d 6574 6572 5f64 6963 745b 2763 6865  ameter_dict['che
+00013430: 6574 6168 5f76 6572 7369 6f6e 275d 203d  etah_version'] =
+00013440: 205c 0a20 2020 2020 2020 2020 2020 2073   \.            s
+00013450: 656c 662e 5f5f 6765 745f 6368 6565 7461  elf.__get_cheeta
+00013460: 685f 7665 7273 696f 6e5f 6672 6f6d 5f74  h_version_from_t
+00013470: 7874 5f68 6561 6465 7228 7465 7874 5f68  xt_header(text_h
+00013480: 6561 6465 722c 2066 696c 656e 616d 6529  eader, filename)
+00013490: 0a0a 2020 2020 2020 2020 7061 7261 6d65  ..        parame
+000134a0: 7465 725f 6469 6374 2e75 7064 6174 6528  ter_dict.update(
+000134b0: 7365 6c66 2e5f 5f67 6574 5f66 696c 656e  self.__get_filen
+000134c0: 616d 655f 616e 645f 7469 6d65 735f 6672  ame_and_times_fr
+000134d0: 6f6d 5f74 7874 5f68 6561 6465 7228 0a20  om_txt_header(. 
+000134e0: 2020 2020 2020 2020 2020 2074 6578 745f             text_
+000134f0: 6865 6164 6572 2c20 7061 7261 6d65 7465  header, paramete
+00013500: 725f 6469 6374 5b27 6368 6565 7461 685f  r_dict['cheetah_
+00013510: 7665 7273 696f 6e27 5d29 290a 2020 2020  version'])).    
+00013520: 2020 2020 2320 7365 7061 7261 7469 6e67      # separating
+00013530: 206c 696e 6573 206f 6620 6865 6164 6572   lines of header
+00013540: 2061 6e64 2069 676e 6f72 696e 6720 6c61   and ignoring la
+00013550: 7374 206c 696e 6520 2866 696c 6c29 2c20  st line (fill), 
+00013560: 6368 6563 6b20 6966 0a20 2020 2020 2020  check if.       
+00013570: 2023 204c 696e 7578 206f 7220 5769 6e64   # Linux or Wind
+00013580: 6f77 7320 4f53 0a20 2020 2020 2020 2069  ows OS.        i
+00013590: 6620 7365 7020 3d3d 2027 2f27 3a0a 2020  f sep == '/':.  
+000135a0: 2020 2020 2020 2020 2020 7465 7874 5f68            text_h
+000135b0: 6561 6465 7220 3d20 7465 7874 5f68 6561  eader = text_hea
+000135c0: 6465 722e 7370 6c69 7428 275c 725c 6e27  der.split('\r\n'
+000135d0: 295b 3a2d 315d 0a20 2020 2020 2020 2069  )[:-1].        i
+000135e0: 6620 7365 7020 3d3d 2027 5c5c 273a 0a20  f sep == '\\':. 
+000135f0: 2020 2020 2020 2020 2020 2074 6578 745f             text_
+00013600: 6865 6164 6572 203d 2074 6578 745f 6865  header = text_he
+00013610: 6164 6572 2e73 706c 6974 2827 5c6e 2729  ader.split('\n')
+00013620: 5b3a 2d31 5d0a 0a20 2020 2020 2020 2023  [:-1]..        #
+00013630: 206d 696e 6f72 2070 6172 616d 6574 6572   minor parameter
+00013640: 7320 706f 7373 6962 6c79 2073 6176 6564  s possibly saved
+00013650: 2069 6e20 6865 6164 6572 2028 666f 7220   in header (for 
+00013660: 616e 7920 6669 6c65 2074 7970 6529 0a20  any file type). 
+00013670: 2020 2020 2020 206d 696e 6f72 5f6b 6579         minor_key
+00013680: 7320 3d20 5b27 4163 7145 6e74 4e61 6d65  s = ['AcqEntName
+00013690: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
+000136a0: 2020 2020 2020 2020 2027 4669 6c65 5479           'FileTy
+000136b0: 7065 272c 0a20 2020 2020 2020 2020 2020  pe',.           
+000136c0: 2020 2020 2020 2020 2020 2027 4669 6c65             'File
+000136d0: 5665 7273 696f 6e27 2c0a 2020 2020 2020  Version',.      
+000136e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000136f0: 2752 6563 6f72 6453 697a 6527 2c0a 2020  'RecordSize',.  
+00013700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013710: 2020 2020 2748 6172 6477 6172 6553 7562      'HardwareSub
+00013720: 5379 7374 656d 4e61 6d65 272c 0a20 2020  SystemName',.   
 00013730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013740: 2027 4861 7264 7761 7265 5375 6253 7973   'HardwareSubSys
-00013750: 7465 6d4e 616d 6527 2c0a 2020 2020 2020  temName',.      
+00013740: 2020 2027 4861 7264 7761 7265 5375 6253     'HardwareSubS
+00013750: 7973 7465 6d54 7970 6527 2c0a 2020 2020  ystemType',.    
 00013760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013770: 2748 6172 6477 6172 6553 7562 5379 7374  'HardwareSubSyst
-00013780: 656d 5479 7065 272c 0a20 2020 2020 2020  emType',.       
-00013790: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-000137a0: 5361 6d70 6c69 6e67 4672 6571 7565 6e63  SamplingFrequenc
-000137b0: 7927 2c0a 2020 2020 2020 2020 2020 2020  y',.            
-000137c0: 2020 2020 2020 2020 2020 2741 444d 6178            'ADMax
-000137d0: 5661 6c75 6527 2c0a 2020 2020 2020 2020  Value',.        
-000137e0: 2020 2020 2020 2020 2020 2020 2020 2741                'A
-000137f0: 4442 6974 566f 6c74 7327 2c0a 2020 2020  DBitVolts',.    
-00013800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013810: 2020 274e 756d 4144 4368 616e 6e65 6c73    'NumADChannels
-00013820: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
-00013830: 2020 2020 2020 2020 2027 4144 4368 616e           'ADChan
-00013840: 6e65 6c27 2c0a 2020 2020 2020 2020 2020  nel',.          
-00013850: 2020 2020 2020 2020 2020 2020 2749 6e70              'Inp
-00013860: 7574 5261 6e67 6527 2c0a 2020 2020 2020  utRange',.      
-00013870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013880: 2749 6e70 7574 496e 7665 7274 6564 272c  'InputInverted',
-00013890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000138a0: 2020 2020 2020 2027 4453 504c 6f77 4375         'DSPLowCu
-000138b0: 7446 696c 7465 7245 6e61 626c 6564 272c  tFilterEnabled',
-000138c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000138d0: 2020 2020 2020 2027 4473 704c 6f77 4375         'DspLowCu
-000138e0: 7446 7265 7175 656e 6379 272c 0a20 2020  tFrequency',.   
+00013770: 2020 2753 616d 706c 696e 6746 7265 7175    'SamplingFrequ
+00013780: 656e 6379 272c 0a20 2020 2020 2020 2020  ency',.         
+00013790: 2020 2020 2020 2020 2020 2020 2027 4144               'AD
+000137a0: 4d61 7856 616c 7565 272c 0a20 2020 2020  MaxValue',.     
+000137b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000137c0: 2027 4144 4269 7456 6f6c 7473 272c 0a20   'ADBitVolts',. 
+000137d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000137e0: 2020 2020 2027 4e75 6d41 4443 6861 6e6e       'NumADChann
+000137f0: 656c 7327 2c0a 2020 2020 2020 2020 2020  els',.          
+00013800: 2020 2020 2020 2020 2020 2020 2741 4443              'ADC
+00013810: 6861 6e6e 656c 272c 0a20 2020 2020 2020  hannel',.       
+00013820: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00013830: 496e 7075 7452 616e 6765 272c 0a20 2020  InputRange',.   
+00013840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013850: 2020 2027 496e 7075 7449 6e76 6572 7465     'InputInverte
+00013860: 6427 2c0a 2020 2020 2020 2020 2020 2020  d',.            
+00013870: 2020 2020 2020 2020 2020 2744 5350 4c6f            'DSPLo
+00013880: 7743 7574 4669 6c74 6572 456e 6162 6c65  wCutFilterEnable
+00013890: 6427 2c0a 2020 2020 2020 2020 2020 2020  d',.            
+000138a0: 2020 2020 2020 2020 2020 2744 7370 4c6f            'DspLo
+000138b0: 7743 7574 4672 6571 7565 6e63 7927 2c0a  wCutFrequency',.
+000138c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000138d0: 2020 2020 2020 2744 7370 4c6f 7743 7574        'DspLowCut
+000138e0: 4e75 6d54 6170 7327 2c0a 2020 2020 2020  NumTaps',.      
 000138f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013900: 2020 2027 4473 704c 6f77 4375 744e 756d     'DspLowCutNum
-00013910: 5461 7073 272c 0a20 2020 2020 2020 2020  Taps',.         
-00013920: 2020 2020 2020 2020 2020 2020 2027 4473               'Ds
-00013930: 704c 6f77 4375 7446 696c 7465 7254 7970  pLowCutFilterTyp
-00013940: 6527 2c0a 2020 2020 2020 2020 2020 2020  e',.            
-00013950: 2020 2020 2020 2020 2020 2744 5350 4869            'DSPHi
-00013960: 6768 4375 7446 696c 7465 7245 6e61 626c  ghCutFilterEnabl
-00013970: 6564 272c 0a20 2020 2020 2020 2020 2020  ed',.           
+00013900: 2744 7370 4c6f 7743 7574 4669 6c74 6572  'DspLowCutFilter
+00013910: 5479 7065 272c 0a20 2020 2020 2020 2020  Type',.         
+00013920: 2020 2020 2020 2020 2020 2020 2027 4453               'DS
+00013930: 5048 6967 6843 7574 4669 6c74 6572 456e  PHighCutFilterEn
+00013940: 6162 6c65 6427 2c0a 2020 2020 2020 2020  abled',.        
+00013950: 2020 2020 2020 2020 2020 2020 2020 2744                'D
+00013960: 7370 4869 6768 4375 7446 7265 7175 656e  spHighCutFrequen
+00013970: 6379 272c 0a20 2020 2020 2020 2020 2020  cy',.           
 00013980: 2020 2020 2020 2020 2020 2027 4473 7048             'DspH
-00013990: 6967 6843 7574 4672 6571 7565 6e63 7927  ighCutFrequency'
-000139a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000139b0: 2020 2020 2020 2020 2744 7370 4869 6768          'DspHigh
-000139c0: 4375 744e 756d 5461 7073 272c 0a20 2020  CutNumTaps',.   
+00013990: 6967 6843 7574 4e75 6d54 6170 7327 2c0a  ighCutNumTaps',.
+000139a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000139b0: 2020 2020 2020 2744 7370 4869 6768 4375        'DspHighCu
+000139c0: 7446 696c 7465 7254 7970 6527 2c0a 2020  tFilterType',.  
 000139d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000139e0: 2020 2027 4473 7048 6967 6843 7574 4669     'DspHighCutFi
-000139f0: 6c74 6572 5479 7065 272c 0a20 2020 2020  lterType',.     
+000139e0: 2020 2020 2744 7370 4465 6c61 7943 6f6d      'DspDelayCom
+000139f0: 7065 6e73 6174 696f 6e27 2c0a 2020 2020  pensation',.    
 00013a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013a10: 2027 4473 7044 656c 6179 436f 6d70 656e   'DspDelayCompen
-00013a20: 7361 7469 6f6e 272c 0a20 2020 2020 2020  sation',.       
-00013a30: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00013a40: 4473 7046 696c 7465 7244 656c 6179 5f5c  DspFilterDelay_\
-00013a50: 7862 3573 272c 0a20 2020 2020 2020 2020  xb5s',.         
-00013a60: 2020 2020 2020 2020 2020 2020 2027 4469               'Di
-00013a70: 7361 626c 6564 5375 6243 6861 6e6e 656c  sabledSubChannel
-00013a80: 7327 2c0a 2020 2020 2020 2020 2020 2020  s',.            
-00013a90: 2020 2020 2020 2020 2020 2757 6176 6566            'Wavef
-00013aa0: 6f72 6d4c 656e 6774 6827 2c0a 2020 2020  ormLength',.    
-00013ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013ac0: 2020 2741 6c69 676e 6d65 6e74 5074 272c    'AlignmentPt',
-00013ad0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013ae0: 2020 2020 2020 2027 5468 7265 7368 5661         'ThreshVa
-00013af0: 6c27 2c0a 2020 2020 2020 2020 2020 2020  l',.            
-00013b00: 2020 2020 2020 2020 2020 274d 696e 5265            'MinRe
-00013b10: 7472 6967 6765 7253 616d 706c 6573 272c  triggerSamples',
-00013b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013b30: 2020 2020 2020 2027 5370 696b 6552 6574         'SpikeRet
-00013b40: 7269 6767 6572 5469 6d65 272c 0a20 2020  riggerTime',.   
+00013a10: 2020 2744 7370 4669 6c74 6572 4465 6c61    'DspFilterDela
+00013a20: 795f 5c78 6235 7327 2c0a 2020 2020 2020  y_\xb5s',.      
+00013a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013a40: 2744 6973 6162 6c65 6453 7562 4368 616e  'DisabledSubChan
+00013a50: 6e65 6c73 272c 0a20 2020 2020 2020 2020  nels',.         
+00013a60: 2020 2020 2020 2020 2020 2020 2027 5761               'Wa
+00013a70: 7665 666f 726d 4c65 6e67 7468 272c 0a20  veformLength',. 
+00013a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013a90: 2020 2020 2027 416c 6967 6e6d 656e 7450       'AlignmentP
+00013aa0: 7427 2c0a 2020 2020 2020 2020 2020 2020  t',.            
+00013ab0: 2020 2020 2020 2020 2020 2754 6872 6573            'Thres
+00013ac0: 6856 616c 272c 0a20 2020 2020 2020 2020  hVal',.         
+00013ad0: 2020 2020 2020 2020 2020 2020 2027 4d69               'Mi
+00013ae0: 6e52 6574 7269 6767 6572 5361 6d70 6c65  nRetriggerSample
+00013af0: 7327 2c0a 2020 2020 2020 2020 2020 2020  s',.            
+00013b00: 2020 2020 2020 2020 2020 2753 7069 6b65            'Spike
+00013b10: 5265 7472 6967 6765 7254 696d 6527 2c0a  RetriggerTime',.
+00013b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013b30: 2020 2020 2020 2744 7561 6c54 6872 6573        'DualThres
+00013b40: 686f 6c64 696e 6727 2c0a 2020 2020 2020  holding',.      
 00013b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013b60: 2020 2027 4475 616c 5468 7265 7368 6f6c     'DualThreshol
-00013b70: 6469 6e67 272c 0a20 2020 2020 2020 2020  ding',.         
-00013b80: 2020 2020 2020 2020 2020 2020 2027 4665               'Fe
-00013b90: 6174 7572 6520 5065 616b 2030 272c 0a20  ature Peak 0',. 
+00013b60: 2746 6561 7475 7265 2050 6561 6b20 3027  'Feature Peak 0'
+00013b70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013b80: 2020 2020 2020 2020 2746 6561 7475 7265          'Feature
+00013b90: 2056 616c 6c65 7920 3127 2c0a 2020 2020   Valley 1',.    
 00013ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013bb0: 2020 2020 2027 4665 6174 7572 6520 5661       'Feature Va
-00013bc0: 6c6c 6579 2031 272c 0a20 2020 2020 2020  lley 1',.       
-00013bd0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00013be0: 4665 6174 7572 6520 456e 6572 6779 2032  Feature Energy 2
-00013bf0: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
-00013c00: 2020 2020 2020 2020 2027 4665 6174 7572           'Featur
-00013c10: 6520 4865 6967 6874 2033 272c 0a20 2020  e Height 3',.   
+00013bb0: 2020 2746 6561 7475 7265 2045 6e65 7267    'Feature Energ
+00013bc0: 7920 3227 2c0a 2020 2020 2020 2020 2020  y 2',.          
+00013bd0: 2020 2020 2020 2020 2020 2020 2746 6561              'Fea
+00013be0: 7475 7265 2048 6569 6768 7420 3327 2c0a  ture Height 3',.
+00013bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013c00: 2020 2020 2020 2746 6561 7475 7265 204e        'Feature N
+00013c10: 7468 5361 6d70 6c65 2034 272c 0a20 2020  thSample 4',.   
 00013c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00013c30: 2020 2027 4665 6174 7572 6520 4e74 6853     'Feature NthS
-00013c40: 616d 706c 6520 3427 2c0a 2020 2020 2020  ample 4',.      
+00013c40: 616d 706c 6520 3527 2c0a 2020 2020 2020  ample 5',.      
 00013c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00013c60: 2746 6561 7475 7265 204e 7468 5361 6d70  'Feature NthSamp
-00013c70: 6c65 2035 272c 0a20 2020 2020 2020 2020  le 5',.         
+00013c70: 6c65 2036 272c 0a20 2020 2020 2020 2020  le 6',.         
 00013c80: 2020 2020 2020 2020 2020 2020 2027 4665               'Fe
 00013c90: 6174 7572 6520 4e74 6853 616d 706c 6520  ature NthSample 
-00013ca0: 3627 2c0a 2020 2020 2020 2020 2020 2020  6',.            
-00013cb0: 2020 2020 2020 2020 2020 2746 6561 7475            'Featu
-00013cc0: 7265 204e 7468 5361 6d70 6c65 2037 272c  re NthSample 7',
-00013cd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013ce0: 2020 2020 2020 2027 5365 7373 696f 6e55         'SessionU
-00013cf0: 5549 4427 2c0a 2020 2020 2020 2020 2020  UID',.          
-00013d00: 2020 2020 2020 2020 2020 2020 2746 696c              'Fil
-00013d10: 6555 5549 4427 2c0a 2020 2020 2020 2020  eUUID',.        
-00013d20: 2020 2020 2020 2020 2020 2020 2020 2743                'C
-00013d30: 6865 6574 6168 5265 7627 2c0a 2020 2020  heetahRev',.    
-00013d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013d50: 2020 2750 726f 6265 4e61 6d65 272c 0a20    'ProbeName',. 
+00013ca0: 3727 2c0a 2020 2020 2020 2020 2020 2020  7',.            
+00013cb0: 2020 2020 2020 2020 2020 2753 6573 7369            'Sessi
+00013cc0: 6f6e 5555 4944 272c 0a20 2020 2020 2020  onUUID',.       
+00013cd0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00013ce0: 4669 6c65 5555 4944 272c 0a20 2020 2020  FileUUID',.     
+00013cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013d00: 2027 4368 6565 7461 6852 6576 272c 0a20   'CheetahRev',. 
+00013d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013d20: 2020 2020 2027 5072 6f62 654e 616d 6527       'ProbeName'
+00013d30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00013d40: 2020 2020 2020 2020 274f 7269 6769 6e61          'Origina
+00013d50: 6c46 696c 654e 616d 6527 2c0a 2020 2020  lFileName',.    
 00013d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013d70: 2020 2020 2027 4f72 6967 696e 616c 4669       'OriginalFi
-00013d80: 6c65 4e61 6d65 272c 0a20 2020 2020 2020  leName',.       
-00013d90: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00013da0: 5469 6d65 4372 6561 7465 6427 2c0a 2020  TimeCreated',.  
-00013db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013dc0: 2020 2020 2754 696d 6543 6c6f 7365 6427      'TimeClosed'
-00013dd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00013de0: 2020 2020 2020 2020 2741 7070 6c69 6361          'Applica
-00013df0: 7469 6f6e 4e61 6d65 272c 0a20 2020 2020  tionName',.     
-00013e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013e10: 2027 4163 7175 6973 6974 696f 6e53 7973   'AcquisitionSys
-00013e20: 7465 6d27 2c0a 2020 2020 2020 2020 2020  tem',.          
-00013e30: 2020 2020 2020 2020 2020 2020 2752 6566              'Ref
-00013e40: 6572 656e 6365 4368 616e 6e65 6c27 5d0a  erenceChannel'].
-00013e50: 0a20 2020 2020 2020 2023 2065 7874 7261  .        # extra
-00013e60: 6374 696e 6720 6d69 6e6f 7220 6b65 7920  cting minor key 
-00013e70: 7661 6c75 6573 206f 6620 6865 6164 6572  values of header
-00013e80: 2028 6f6e 6c79 2074 616b 696e 6720 696e   (only taking in
-00013e90: 746f 2061 6363 6f75 6e74 0a20 2020 2020  to account.     
-00013ea0: 2020 2023 206e 6f6e 2d65 6d70 7479 206c     # non-empty l
-00013eb0: 696e 6573 290a 2020 2020 2020 2020 666f  ines).        fo
-00013ec0: 7220 692c 206d 696e 6f72 5f65 6e74 7279  r i, minor_entry
-00013ed0: 2069 6e20 656e 756d 6572 6174 6528 7465   in enumerate(te
-00013ee0: 7874 5f68 6561 6465 7229 3a0a 2020 2020  xt_header):.    
-00013ef0: 2020 2020 2020 2020 6966 206d 696e 6f72          if minor
-00013f00: 5f65 6e74 7279 203d 3d20 2727 206f 7220  _entry == '' or 
-00013f10: 6d69 6e6f 725f 656e 7472 795b 305d 203d  minor_entry[0] =
-00013f20: 3d20 2723 273a 0a20 2020 2020 2020 2020  = '#':.         
-00013f30: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
-00013f40: 2020 2020 2020 2020 2020 2020 6d61 7463              matc
-00013f50: 6869 6e67 5f6b 6579 203d 205b 6b65 7920  hing_key = [key 
-00013f60: 666f 7220 6b65 7920 696e 206d 696e 6f72  for key in minor
-00013f70: 5f6b 6579 7320 6966 0a20 2020 2020 2020  _keys if.       
-00013f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013f90: 2020 2020 206d 696e 6f72 5f65 6e74 7279       minor_entry
-00013fa0: 2e73 7472 6970 2827 2d27 292e 7374 6172  .strip('-').star
-00013fb0: 7473 7769 7468 286b 6579 295d 0a20 2020  tswith(key)].   
-00013fc0: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-00013fd0: 6d61 7463 6869 6e67 5f6b 6579 2920 3d3d  matching_key) ==
-00013fe0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-00013ff0: 2020 2020 6d61 7463 6869 6e67 5f6b 6579      matching_key
-00014000: 203d 206d 6174 6368 696e 675f 6b65 795b   = matching_key[
-00014010: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
-00014020: 2020 206d 696e 6f72 5f76 616c 7565 203d     minor_value =
-00014030: 206d 696e 6f72 5f65 6e74 7279 2e73 706c   minor_entry.spl
-00014040: 6974 286d 6174 6368 696e 675f 6b65 7929  it(matching_key)
-00014050: 5b31 5d2e 7374 7269 7028 0a20 2020 2020  [1].strip(.     
-00014060: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00014070: 2027 292e 7273 7472 6970 2827 2027 290a   ').rstrip(' ').
-00014080: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014090: 2023 2064 6574 6572 6d69 6e65 2064 6174   # determine dat
-000140a0: 6120 7479 7065 206f 6620 656e 7472 790a  a type of entry.
+00013d70: 2020 2754 696d 6543 7265 6174 6564 272c    'TimeCreated',
+00013d80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013d90: 2020 2020 2020 2027 5469 6d65 436c 6f73         'TimeClos
+00013da0: 6564 272c 0a20 2020 2020 2020 2020 2020  ed',.           
+00013db0: 2020 2020 2020 2020 2020 2027 4170 706c             'Appl
+00013dc0: 6963 6174 696f 6e4e 616d 6527 2c0a 2020  icationName',.  
+00013dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013de0: 2020 2020 2741 6371 7569 7369 7469 6f6e      'Acquisition
+00013df0: 5379 7374 656d 272c 0a20 2020 2020 2020  System',.       
+00013e00: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00013e10: 5265 6665 7265 6e63 6543 6861 6e6e 656c  ReferenceChannel
+00013e20: 275d 0a0a 2020 2020 2020 2020 2320 6578  ']..        # ex
+00013e30: 7472 6163 7469 6e67 206d 696e 6f72 206b  tracting minor k
+00013e40: 6579 2076 616c 7565 7320 6f66 2068 6561  ey values of hea
+00013e50: 6465 7220 286f 6e6c 7920 7461 6b69 6e67  der (only taking
+00013e60: 2069 6e74 6f20 6163 636f 756e 740a 2020   into account.  
+00013e70: 2020 2020 2020 2320 6e6f 6e2d 656d 7074        # non-empt
+00013e80: 7920 6c69 6e65 7329 0a20 2020 2020 2020  y lines).       
+00013e90: 2066 6f72 2069 2c20 6d69 6e6f 725f 656e   for i, minor_en
+00013ea0: 7472 7920 696e 2065 6e75 6d65 7261 7465  try in enumerate
+00013eb0: 2874 6578 745f 6865 6164 6572 293a 0a20  (text_header):. 
+00013ec0: 2020 2020 2020 2020 2020 2069 6620 6d69             if mi
+00013ed0: 6e6f 725f 656e 7472 7920 3d3d 2027 2720  nor_entry == '' 
+00013ee0: 6f72 206d 696e 6f72 5f65 6e74 7279 5b30  or minor_entry[0
+00013ef0: 5d20 3d3d 2027 2327 3a0a 2020 2020 2020  ] == '#':.      
+00013f00: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
+00013f10: 7565 0a20 2020 2020 2020 2020 2020 206d  ue.            m
+00013f20: 6174 6368 696e 675f 6b65 7920 3d20 5b6b  atching_key = [k
+00013f30: 6579 2066 6f72 206b 6579 2069 6e20 6d69  ey for key in mi
+00013f40: 6e6f 725f 6b65 7973 2069 660a 2020 2020  nor_keys if.    
+00013f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013f60: 2020 2020 2020 2020 6d69 6e6f 725f 656e          minor_en
+00013f70: 7472 792e 7374 7269 7028 272d 2729 2e73  try.strip('-').s
+00013f80: 7461 7274 7377 6974 6828 6b65 7929 5d0a  tartswith(key)].
+00013f90: 2020 2020 2020 2020 2020 2020 6966 206c              if l
+00013fa0: 656e 286d 6174 6368 696e 675f 6b65 7929  en(matching_key)
+00013fb0: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
+00013fc0: 2020 2020 2020 206d 6174 6368 696e 675f         matching_
+00013fd0: 6b65 7920 3d20 6d61 7463 6869 6e67 5f6b  key = matching_k
+00013fe0: 6579 5b30 5d0a 2020 2020 2020 2020 2020  ey[0].          
+00013ff0: 2020 2020 2020 6d69 6e6f 725f 7661 6c75        minor_valu
+00014000: 6520 3d20 6d69 6e6f 725f 656e 7472 792e  e = minor_entry.
+00014010: 7370 6c69 7428 6d61 7463 6869 6e67 5f6b  split(matching_k
+00014020: 6579 295b 315d 2e73 7472 6970 280a 2020  ey)[1].strip(.  
+00014030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014040: 2020 2720 2729 2e72 7374 7269 7028 2720    ' ').rstrip(' 
+00014050: 2729 0a0a 2020 2020 2020 2020 2020 2020  ')..            
+00014060: 2020 2020 2320 6465 7465 726d 696e 6520      # determine 
+00014070: 6461 7461 2074 7970 6520 6f66 2065 6e74  data type of ent
+00014080: 7279 0a20 2020 2020 2020 2020 2020 2020  ry.             
+00014090: 2020 2069 6620 6d69 6e6f 725f 7661 6c75     if minor_valu
+000140a0: 652e 6973 6469 6769 7428 293a 0a20 2020  e.isdigit():.   
 000140b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000140c0: 6966 206d 696e 6f72 5f76 616c 7565 2e69  if minor_value.i
-000140d0: 7364 6967 6974 2829 3a0a 2020 2020 2020  sdigit():.      
-000140e0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000140f0: 636f 6e76 6572 7469 6e67 2074 6f20 696e  converting to in
-00014100: 7420 6966 2070 6f73 7369 626c 650a 2020  t if possible.  
-00014110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014120: 2020 6d69 6e6f 725f 7661 6c75 6520 3d20    minor_value = 
-00014130: 696e 7428 6d69 6e6f 725f 7661 6c75 6529  int(minor_value)
-00014140: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014150: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00014160: 2020 2020 2020 2020 2020 2023 2063 6f6e             # con
-00014170: 7665 7274 696e 6720 746f 2066 6c6f 6174  verting to float
-00014180: 2069 6620 706f 7373 6962 6c65 0a20 2020   if possible.   
-00014190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000141a0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
-000141b0: 2020 2020 2020 2020 2020 2020 2020 6d69                mi
-000141c0: 6e6f 725f 7661 6c75 6520 3d20 666c 6f61  nor_value = floa
-000141d0: 7428 6d69 6e6f 725f 7661 6c75 6529 0a20  t(minor_value). 
-000141e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000141f0: 2020 2065 7863 6570 743a 0a20 2020 2020     except:.     
-00014200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014210: 2020 2070 6173 730a 0a20 2020 2020 2020     pass..       
-00014220: 2020 2020 2020 2020 2069 6620 6d61 7463           if matc
-00014230: 6869 6e67 5f6b 6579 2069 6e20 7061 7261  hing_key in para
-00014240: 6d65 7465 725f 6469 6374 3a0a 2020 2020  meter_dict:.    
-00014250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014260: 7761 726e 696e 6773 2e77 6172 6e28 0a20  warnings.warn(. 
-00014270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014280: 2020 2020 2020 2027 4d75 6c74 6970 6c65         'Multiple
-00014290: 2065 6e74 7269 6573 2066 6f72 207b 7d20   entries for {} 
-000142a0: 696e 2074 6578 7420 6865 6164 6572 206f  in text header o
-000142b0: 6620 7b7d 272e 666f 726d 6174 280a 2020  f {}'.format(.  
-000142c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000142d0: 2020 2020 2020 2020 2020 6d61 7463 6869            matchi
-000142e0: 6e67 5f6b 6579 2c20 6669 6c65 6e61 6d65  ng_key, filename
-000142f0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
-00014300: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00014310: 2020 2020 2020 2020 2020 2020 2070 6172               par
-00014320: 616d 6574 6572 5f64 6963 745b 6d61 7463  ameter_dict[matc
-00014330: 6869 6e67 5f6b 6579 5d20 3d20 6d69 6e6f  hing_key] = mino
-00014340: 725f 7661 6c75 650a 2020 2020 2020 2020  r_value.        
-00014350: 2020 2020 656c 6966 206c 656e 286d 6174      elif len(mat
-00014360: 6368 696e 675f 6b65 7929 203e 2031 3a0a  ching_key) > 1:.
-00014370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014380: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00014390: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000143a0: 2020 2020 2020 2749 6e63 6f6e 7369 7374        'Inconsist
-000143b0: 656e 7420 6d69 6e6f 7220 6b65 7920 6c69  ent minor key li
-000143c0: 7374 2066 6f72 2074 6578 7420 6865 6164  st for text head
-000143d0: 6572 2027 0a20 2020 2020 2020 2020 2020  er '.           
-000143e0: 2020 2020 2020 2020 2027 696e 7465 7270           'interp
-000143f0: 7265 7461 7469 6f6e 2e27 290a 2020 2020  retation.').    
-00014400: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00014410: 2020 2020 2020 2020 2020 2020 2020 7761                wa
-00014420: 726e 696e 6773 2e77 6172 6e28 0a20 2020  rnings.warn(.   
-00014430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014440: 2027 536b 6970 7069 6e67 2074 6578 7420   'Skipping text 
-00014450: 6865 6164 6572 2065 6e74 7279 2025 732c  header entry %s,
-00014460: 2062 6563 6175 7365 2069 7420 6973 206e   because it is n
-00014470: 6f74 2069 6e20 270a 2020 2020 2020 2020  ot in '.        
-00014480: 2020 2020 2020 2020 2020 2020 276d 696e              'min
-00014490: 6f72 206b 6579 206c 6973 7427 2025 206d  or key list' % m
-000144a0: 696e 6f72 5f65 6e74 7279 290a 0a20 2020  inor_entry)..   
-000144b0: 2020 2020 2073 656c 662e 5f64 6961 676e       self._diagn
-000144c0: 6f73 7469 635f 7072 696e 7428 0a20 2020  ostic_print(.   
-000144d0: 2020 2020 2020 2020 2027 5375 6363 6573           'Succes
-000144e0: 7366 756c 6c79 2064 6563 6f64 6564 2074  sfully decoded t
-000144f0: 6578 7420 6865 6164 6572 206f 6620 6669  ext header of fi
-00014500: 6c65 2028 2573 292e 2720 2520 6669 6c65  le (%s).' % file
-00014510: 6e61 6d65 290a 0a20 2020 2064 6566 205f  name)..    def _
-00014520: 5f67 6574 5f63 6865 6574 6168 5f76 6572  _get_cheetah_ver
-00014530: 7369 6f6e 5f66 726f 6d5f 7478 745f 6865  sion_from_txt_he
-00014540: 6164 6572 2873 656c 662c 2074 6578 745f  ader(self, text_
-00014550: 6865 6164 6572 2c20 6669 6c65 6e61 6d65  header, filename
-00014560: 293a 0a20 2020 2020 2020 2076 6572 7369  ):.        versi
-00014570: 6f6e 5f72 6567 6578 203d 2072 652e 636f  on_regex = re.co
-00014580: 6d70 696c 6528 7227 2828 2d43 6865 6574  mpile(r'((-Cheet
-00014590: 6168 5265 7620 297c 270a 2020 2020 2020  ahRev )|'.      
-000145a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000145b0: 2020 2020 2020 2020 2020 2020 2072 2728               r'(
-000145c0: 4170 706c 6963 6174 696f 6e4e 616d 6520  ApplicationName 
-000145d0: 4368 6565 7461 6820 2229 2927 0a20 2020  Cheetah "))'.   
-000145e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000145f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014600: 7227 283f 503c 7665 7273 696f 6e3e 5c64  r'(?P<version>\d
-00014610: 7b31 2c33 7d5c 2e5c 647b 312c 337d 5c2e  {1,3}\.\d{1,3}\.
-00014620: 5c64 7b31 2c33 7d29 2729 0a20 2020 2020  \d{1,3})').     
-00014630: 2020 206d 6174 6368 203d 2076 6572 7369     match = versi
-00014640: 6f6e 5f72 6567 6578 2e73 6561 7263 6828  on_regex.search(
-00014650: 7465 7874 5f68 6561 6465 7229 0a20 2020  text_header).   
-00014660: 2020 2020 2069 6620 6d61 7463 683a 0a20       if match:. 
-00014670: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00014680: 6e20 6d61 7463 682e 6772 6f75 7064 6963  n match.groupdic
-00014690: 7428 295b 2776 6572 7369 6f6e 275d 0a20  t()['version']. 
-000146a0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-000146b0: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
-000146c0: 616c 7565 4572 726f 7228 2743 616e 206e  alueError('Can n
-000146d0: 6f74 2065 7874 7261 6374 2043 6865 6574  ot extract Cheet
-000146e0: 6168 2076 6572 7369 6f6e 2066 726f 6d20  ah version from 
-000146f0: 6669 6c65 2027 0a20 2020 2020 2020 2020  file '.         
-00014700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014710: 2020 2020 2768 6561 6465 7220 6f66 2066      'header of f
-00014720: 696c 6520 2573 2720 2520 6669 6c65 6e61  ile %s' % filena
-00014730: 6d65 290a 0a20 2020 2064 6566 205f 5f67  me)..    def __g
-00014740: 6574 5f66 696c 656e 616d 655f 616e 645f  et_filename_and_
-00014750: 7469 6d65 735f 6672 6f6d 5f74 7874 5f68  times_from_txt_h
-00014760: 6561 6465 7228 7365 6c66 2c20 7465 7874  eader(self, text
-00014770: 5f68 6561 6465 722c 2076 6572 7369 6f6e  _header, version
-00014780: 293a 0a20 2020 2020 2020 2069 6620 7061  ):.        if pa
-00014790: 7273 655f 7665 7273 696f 6e28 7665 7273  rse_version(vers
-000147a0: 696f 6e29 203c 3d20 7061 7273 655f 7665  ion) <= parse_ve
-000147b0: 7273 696f 6e28 2735 2e36 2e34 2729 3a0a  rsion('5.6.4'):.
-000147c0: 2020 2020 2020 2020 2020 2020 6461 7465              date
-000147d0: 7469 6d65 315f 7265 6765 7820 3d20 7265  time1_regex = re
-000147e0: 2e63 6f6d 7069 6c65 2872 2723 2320 5469  .compile(r'## Ti
-000147f0: 6d65 204f 7065 6e65 6420 5c28 6d2f 642f  me Opened \(m/d/
-00014800: 795c 293a 2027 0a20 2020 2020 2020 2020  y\): '.         
-00014810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000140c0: 2023 2063 6f6e 7665 7274 696e 6720 746f   # converting to
+000140d0: 2069 6e74 2069 6620 706f 7373 6962 6c65   int if possible
+000140e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000140f0: 2020 2020 206d 696e 6f72 5f76 616c 7565       minor_value
+00014100: 203d 2069 6e74 286d 696e 6f72 5f76 616c   = int(minor_val
+00014110: 7565 290a 2020 2020 2020 2020 2020 2020  ue).            
+00014120: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00014130: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00014140: 636f 6e76 6572 7469 6e67 2074 6f20 666c  converting to fl
+00014150: 6f61 7420 6966 2070 6f73 7369 626c 650a  oat if possible.
+00014160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014170: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+00014180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014190: 206d 696e 6f72 5f76 616c 7565 203d 2066   minor_value = f
+000141a0: 6c6f 6174 286d 696e 6f72 5f76 616c 7565  loat(minor_value
+000141b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000141c0: 2020 2020 2020 6578 6365 7074 3a0a 2020        except:.  
+000141d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000141e0: 2020 2020 2020 7061 7373 0a0a 2020 2020        pass..    
+000141f0: 2020 2020 2020 2020 2020 2020 6966 206d              if m
+00014200: 6174 6368 696e 675f 6b65 7920 696e 2070  atching_key in p
+00014210: 6172 616d 6574 6572 5f64 6963 743a 0a20  arameter_dict:. 
+00014220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014230: 2020 2077 6172 6e69 6e67 732e 7761 726e     warnings.warn
+00014240: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00014250: 2020 2020 2020 2020 2020 274d 756c 7469            'Multi
+00014260: 706c 6520 656e 7472 6965 7320 666f 7220  ple entries for 
+00014270: 7b7d 2069 6e20 7465 7874 2068 6561 6465  {} in text heade
+00014280: 7220 6f66 207b 7d27 2e66 6f72 6d61 7428  r of {}'.format(
+00014290: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000142a0: 2020 2020 2020 2020 2020 2020 206d 6174               mat
+000142b0: 6368 696e 675f 6b65 792c 2066 696c 656e  ching_key, filen
+000142c0: 616d 6529 290a 2020 2020 2020 2020 2020  ame)).          
+000142d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+000142e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000142f0: 7061 7261 6d65 7465 725f 6469 6374 5b6d  parameter_dict[m
+00014300: 6174 6368 696e 675f 6b65 795d 203d 206d  atching_key] = m
+00014310: 696e 6f72 5f76 616c 7565 0a20 2020 2020  inor_value.     
+00014320: 2020 2020 2020 2065 6c69 6620 6c65 6e28         elif len(
+00014330: 6d61 7463 6869 6e67 5f6b 6579 2920 3e20  matching_key) > 
+00014340: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
+00014350: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00014360: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+00014370: 2020 2020 2020 2020 2027 496e 636f 6e73           'Incons
+00014380: 6973 7465 6e74 206d 696e 6f72 206b 6579  istent minor key
+00014390: 206c 6973 7420 666f 7220 7465 7874 2068   list for text h
+000143a0: 6561 6465 7220 270a 2020 2020 2020 2020  eader '.        
+000143b0: 2020 2020 2020 2020 2020 2020 2769 6e74              'int
+000143c0: 6572 7072 6574 6174 696f 6e2e 2729 0a20  erpretation.'). 
+000143d0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+000143e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000143f0: 2077 6172 6e69 6e67 732e 7761 726e 280a   warnings.warn(.
+00014400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014410: 2020 2020 2753 6b69 7070 696e 6720 7465      'Skipping te
+00014420: 7874 2068 6561 6465 7220 656e 7472 7920  xt header entry 
+00014430: 2573 2c20 6265 6361 7573 6520 6974 2069  %s, because it i
+00014440: 7320 6e6f 7420 696e 2027 0a20 2020 2020  s not in '.     
+00014450: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00014460: 6d69 6e6f 7220 6b65 7920 6c69 7374 2720  minor key list' 
+00014470: 2520 6d69 6e6f 725f 656e 7472 7929 0a0a  % minor_entry)..
+00014480: 2020 2020 2020 2020 7365 6c66 2e5f 6469          self._di
+00014490: 6167 6e6f 7374 6963 5f70 7269 6e74 280a  agnostic_print(.
+000144a0: 2020 2020 2020 2020 2020 2020 2753 7563              'Suc
+000144b0: 6365 7373 6675 6c6c 7920 6465 636f 6465  cessfully decode
+000144c0: 6420 7465 7874 2068 6561 6465 7220 6f66  d text header of
+000144d0: 2066 696c 6520 2825 7329 2e27 2025 2066   file (%s).' % f
+000144e0: 696c 656e 616d 6529 0a0a 2020 2020 6465  ilename)..    de
+000144f0: 6620 5f5f 6765 745f 6368 6565 7461 685f  f __get_cheetah_
+00014500: 7665 7273 696f 6e5f 6672 6f6d 5f74 7874  version_from_txt
+00014510: 5f68 6561 6465 7228 7365 6c66 2c20 7465  _header(self, te
+00014520: 7874 5f68 6561 6465 722c 2066 696c 656e  xt_header, filen
+00014530: 616d 6529 3a0a 2020 2020 2020 2020 7665  ame):.        ve
+00014540: 7273 696f 6e5f 7265 6765 7820 3d20 7265  rsion_regex = re
+00014550: 2e63 6f6d 7069 6c65 2872 2728 282d 4368  .compile(r'((-Ch
+00014560: 6565 7461 6852 6576 2029 7c27 0a20 2020  eetahRev )|'.   
+00014570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014590: 7227 2841 7070 6c69 6361 7469 6f6e 4e61  r'(ApplicationNa
+000145a0: 6d65 2043 6865 6574 6168 2022 2929 270a  me Cheetah "))'.
+000145b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000145c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000145d0: 2020 2072 2728 3f50 3c76 6572 7369 6f6e     r'(?P<version
+000145e0: 3e5c 647b 312c 337d 5c2e 5c64 7b31 2c33  >\d{1,3}\.\d{1,3
+000145f0: 7d5c 2e5c 647b 312c 337d 2927 290a 2020  }\.\d{1,3})').  
+00014600: 2020 2020 2020 6d61 7463 6820 3d20 7665        match = ve
+00014610: 7273 696f 6e5f 7265 6765 782e 7365 6172  rsion_regex.sear
+00014620: 6368 2874 6578 745f 6865 6164 6572 290a  ch(text_header).
+00014630: 2020 2020 2020 2020 6966 206d 6174 6368          if match
+00014640: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00014650: 7475 726e 206d 6174 6368 2e67 726f 7570  turn match.group
+00014660: 6469 6374 2829 5b27 7665 7273 696f 6e27  dict()['version'
+00014670: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
+00014680: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00014690: 6520 5661 6c75 6545 7272 6f72 2827 4361  e ValueError('Ca
+000146a0: 6e20 6e6f 7420 6578 7472 6163 7420 4368  n not extract Ch
+000146b0: 6565 7461 6820 7665 7273 696f 6e20 6672  eetah version fr
+000146c0: 6f6d 2066 696c 6520 270a 2020 2020 2020  om file '.      
+000146d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000146e0: 2020 2020 2020 2027 6865 6164 6572 206f         'header o
+000146f0: 6620 6669 6c65 2025 7327 2025 2066 696c  f file %s' % fil
+00014700: 656e 616d 6529 0a0a 2020 2020 6465 6620  ename)..    def 
+00014710: 5f5f 6765 745f 6669 6c65 6e61 6d65 5f61  __get_filename_a
+00014720: 6e64 5f74 696d 6573 5f66 726f 6d5f 7478  nd_times_from_tx
+00014730: 745f 6865 6164 6572 2873 656c 662c 2074  t_header(self, t
+00014740: 6578 745f 6865 6164 6572 2c20 7665 7273  ext_header, vers
+00014750: 696f 6e29 3a0a 2020 2020 2020 2020 6966  ion):.        if
+00014760: 2070 6172 7365 5f76 6572 7369 6f6e 2876   parse_version(v
+00014770: 6572 7369 6f6e 2920 3c3d 2070 6172 7365  ersion) <= parse
+00014780: 5f76 6572 7369 6f6e 2827 352e 362e 3427  _version('5.6.4'
+00014790: 293a 0a20 2020 2020 2020 2020 2020 2064  ):.            d
+000147a0: 6174 6574 696d 6531 5f72 6567 6578 203d  atetime1_regex =
+000147b0: 2072 652e 636f 6d70 696c 6528 7227 2323   re.compile(r'##
+000147c0: 2054 696d 6520 4f70 656e 6564 205c 286d   Time Opened \(m
+000147d0: 2f64 2f79 5c29 3a20 270a 2020 2020 2020  /d/y\): '.      
+000147e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000147f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014800: 2020 2072 2728 3f50 3c64 6174 653e 5c53     r'(?P<date>\S
+00014810: 2b29 270a 2020 2020 2020 2020 2020 2020  +)'.            
 00014820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014830: 7227 283f 503c 6461 7465 3e5c 532b 2927  r'(?P<date>\S+)'
-00014840: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014860: 2020 2020 2020 2020 2020 7227 2020 5c28            r'  \(
-00014870: 683a 6d3a 735c 2e6d 735c 2920 270a 2020  h:m:s\.ms\) '.  
-00014880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000148a0: 2020 2020 2020 2072 2728 3f50 3c74 696d         r'(?P<tim
-000148b0: 653e 5c53 2b29 2729 0a20 2020 2020 2020  e>\S+)').       
-000148c0: 2020 2020 2064 6174 6574 696d 6532 5f72       datetime2_r
-000148d0: 6567 6578 203d 2072 652e 636f 6d70 696c  egex = re.compil
-000148e0: 6528 7227 2323 2054 696d 6520 436c 6f73  e(r'## Time Clos
-000148f0: 6564 205c 286d 2f64 2f79 5c29 3a20 270a  ed \(m/d/y\): '.
-00014900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014830: 2020 2020 2020 2020 2020 2020 2072 2720               r' 
+00014840: 205c 2868 3a6d 3a73 5c2e 6d73 5c29 2027   \(h:m:s\.ms\) '
+00014850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014870: 2020 2020 2020 2020 2020 7227 283f 503c            r'(?P<
+00014880: 7469 6d65 3e5c 532b 2927 290a 2020 2020  time>\S+)').    
+00014890: 2020 2020 2020 2020 6461 7465 7469 6d65          datetime
+000148a0: 325f 7265 6765 7820 3d20 7265 2e63 6f6d  2_regex = re.com
+000148b0: 7069 6c65 2872 2723 2320 5469 6d65 2043  pile(r'## Time C
+000148c0: 6c6f 7365 6420 5c28 6d2f 642f 795c 293a  losed \(m/d/y\):
+000148d0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+000148e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000148f0: 2020 2020 2020 2020 2020 2020 7227 283f              r'(?
+00014900: 503c 6461 7465 3e5c 532b 2927 0a20 2020  P<date>\S+)'.   
 00014910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014920: 2020 2020 2020 2020 2072 2728 3f50 3c64           r'(?P<d
-00014930: 6174 653e 5c53 2b29 270a 2020 2020 2020  ate>\S+)'.      
-00014940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014930: 2020 2020 2020 7227 2020 5c28 683a 6d3a        r'  \(h:m:
+00014940: 735c 2e6d 735c 2920 270a 2020 2020 2020  s\.ms\) '.      
 00014950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014960: 2020 2072 2720 205c 2868 3a6d 3a73 5c2e     r'  \(h:m:s\.
-00014970: 6d73 5c29 2027 0a20 2020 2020 2020 2020  ms\) '.         
-00014980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000149a0: 7227 283f 503c 7469 6d65 3e5c 532b 2927  r'(?P<time>\S+)'
-000149b0: 290a 2020 2020 2020 2020 2020 2020 6669  ).            fi
-000149c0: 6c65 6e61 6d65 5f72 6567 6578 203d 2072  lename_regex = r
-000149d0: 652e 636f 6d70 696c 6528 7227 2323 2046  e.compile(r'## F
-000149e0: 696c 6520 4e61 6d65 2028 3f50 3c66 696c  ile Name (?P<fil
-000149f0: 656e 616d 653e 5c53 2b29 2729 0a0a 2020  ename>\S+)')..  
-00014a00: 2020 2020 2020 2020 2020 6461 7465 7469            dateti
-00014a10: 6d65 666f 726d 6174 203d 2027 256d 2f25  meformat = '%m/%
-00014a20: 642f 2559 2025 483a 254d 3a25 532e 2566  d/%Y %H:%M:%S.%f
-00014a30: 270a 0a20 2020 2020 2020 2065 6c73 653a  '..        else:
-00014a40: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
-00014a50: 6574 696d 6531 5f72 6567 6578 203d 2072  etime1_regex = r
-00014a60: 652e 636f 6d70 696c 6528 7227 2d54 696d  e.compile(r'-Tim
-00014a70: 6543 7265 6174 6564 2027 0a20 2020 2020  eCreated '.     
-00014a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014970: 2020 2072 2728 3f50 3c74 696d 653e 5c53     r'(?P<time>\S
+00014980: 2b29 2729 0a20 2020 2020 2020 2020 2020  +)').           
+00014990: 2066 696c 656e 616d 655f 7265 6765 7820   filename_regex 
+000149a0: 3d20 7265 2e63 6f6d 7069 6c65 2872 2723  = re.compile(r'#
+000149b0: 2320 4669 6c65 204e 616d 6520 283f 503c  # File Name (?P<
+000149c0: 6669 6c65 6e61 6d65 3e5c 532b 2927 290a  filename>\S+)').
+000149d0: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
+000149e0: 6574 696d 6566 6f72 6d61 7420 3d20 2725  etimeformat = '%
+000149f0: 6d2f 2564 2f25 5920 2548 3a25 4d3a 2553  m/%d/%Y %H:%M:%S
+00014a00: 2e25 6627 0a0a 2020 2020 2020 2020 656c  .%f'..        el
+00014a10: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00014a20: 6461 7465 7469 6d65 315f 7265 6765 7820  datetime1_regex 
+00014a30: 3d20 7265 2e63 6f6d 7069 6c65 2872 272d  = re.compile(r'-
+00014a40: 5469 6d65 4372 6561 7465 6420 270a 2020  TimeCreated '.  
+00014a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a70: 2020 2020 2020 2072 2728 3f50 3c64 6174         r'(?P<dat
+00014a80: 653e 5c53 2b29 2027 0a20 2020 2020 2020  e>\S+) '.       
 00014a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014aa0: 2020 2020 7227 283f 503c 6461 7465 3e5c      r'(?P<date>\
-00014ab0: 532b 2920 270a 2020 2020 2020 2020 2020  S+) '.          
-00014ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014ad0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00014ae0: 2728 3f50 3c74 696d 653e 5c53 2b29 2729  '(?P<time>\S+)')
-00014af0: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
-00014b00: 6574 696d 6532 5f72 6567 6578 203d 2072  etime2_regex = r
-00014b10: 652e 636f 6d70 696c 6528 7227 2d54 696d  e.compile(r'-Tim
-00014b20: 6543 6c6f 7365 6420 270a 2020 2020 2020  eClosed '.      
-00014b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014ab0: 2020 7227 283f 503c 7469 6d65 3e5c 532b    r'(?P<time>\S+
+00014ac0: 2927 290a 2020 2020 2020 2020 2020 2020  )').            
+00014ad0: 6461 7465 7469 6d65 325f 7265 6765 7820  datetime2_regex 
+00014ae0: 3d20 7265 2e63 6f6d 7069 6c65 2872 272d  = re.compile(r'-
+00014af0: 5469 6d65 436c 6f73 6564 2027 0a20 2020  TimeClosed '.   
+00014b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014b20: 2020 2020 2020 7227 283f 503c 6461 7465        r'(?P<date
+00014b30: 3e5c 532b 2920 270a 2020 2020 2020 2020  >\S+) '.        
 00014b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b50: 2020 2072 2728 3f50 3c64 6174 653e 5c53     r'(?P<date>\S
-00014b60: 2b29 2027 0a20 2020 2020 2020 2020 2020  +) '.           
-00014b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b80: 2020 2020 2020 2020 2020 2020 2020 7227                r'
-00014b90: 283f 503c 7469 6d65 3e5c 532b 2927 290a  (?P<time>\S+)').
-00014ba0: 2020 2020 2020 2020 2020 2020 6669 6c65              file
-00014bb0: 6e61 6d65 5f72 6567 6578 203d 2072 652e  name_regex = re.
-00014bc0: 636f 6d70 696c 6528 7227 2d4f 7269 6769  compile(r'-Origi
-00014bd0: 6e61 6c46 696c 654e 616d 6520 270a 2020  nalFileName '.  
-00014be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014c00: 2020 2020 2020 7227 223f 283f 503c 6669        r'"?(?P<fi
-00014c10: 6c65 6e61 6d65 3e5c 532b 2922 3f27 290a  lename>\S+)"?').
-00014c20: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
-00014c30: 6574 696d 6566 6f72 6d61 7420 3d20 2725  etimeformat = '%
-00014c40: 592f 256d 2f25 6420 2548 3a25 4d3a 2553  Y/%m/%d %H:%M:%S
-00014c50: 270a 0a20 2020 2020 2020 206d 6174 6368  '..        match
-00014c60: 7469 6d65 3120 3d20 6461 7465 7469 6d65  time1 = datetime
-00014c70: 315f 7265 6765 782e 7365 6172 6368 2874  1_regex.search(t
-00014c80: 6578 745f 6865 6164 6572 292e 6772 6f75  ext_header).grou
-00014c90: 7064 6963 7428 290a 2020 2020 2020 2020  pdict().        
-00014ca0: 6d61 7463 6874 696d 6532 203d 2064 6174  matchtime2 = dat
-00014cb0: 6574 696d 6532 5f72 6567 6578 2e73 6561  etime2_regex.sea
-00014cc0: 7263 6828 7465 7874 5f68 6561 6465 7229  rch(text_header)
-00014cd0: 2e67 726f 7570 6469 6374 2829 0a20 2020  .groupdict().   
-00014ce0: 2020 2020 206d 6174 6368 6669 6c65 6e61       matchfilena
-00014cf0: 6d65 203d 2066 696c 656e 616d 655f 7265  me = filename_re
-00014d00: 6765 782e 7365 6172 6368 2874 6578 745f  gex.search(text_
-00014d10: 6865 6164 6572 290a 0a20 2020 2020 2020  header)..       
-00014d20: 2066 696c 656e 616d 6520 3d20 6d61 7463   filename = matc
-00014d30: 6866 696c 656e 616d 652e 6772 6f75 7064  hfilename.groupd
-00014d40: 6963 7428 295b 2766 696c 656e 616d 6527  ict()['filename'
-00014d50: 5d0a 0a20 2020 2020 2020 2069 6620 2723  ]..        if '#
-00014d60: 2320 5469 6d65 2043 6c6f 7365 6420 4669  # Time Closed Fi
-00014d70: 6c65 2077 6173 206e 6f74 2063 6c6f 7365  le was not close
-00014d80: 6420 7072 6f70 6572 6c79 2720 696e 2074  d properly' in t
-00014d90: 6578 745f 6865 6164 6572 3a0a 2020 2020  ext_header:.    
-00014da0: 2020 2020 2020 2020 7761 726e 696e 6773          warnings
-00014db0: 2e77 6172 6e28 2754 6578 7420 6865 6164  .warn('Text head
-00014dc0: 6572 206f 6620 6669 6c65 2025 7320 646f  er of file %s do
-00014dd0: 6573 206e 6f74 2063 6f6e 7461 696e 2072  es not contain r
-00014de0: 6563 6f72 6469 6e67 2027 0a20 2020 2020  ecording '.     
-00014df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e00: 2020 2020 2027 636c 6f73 6564 2074 696d       'closed tim
-00014e10: 652e 2046 696c 6520 7761 7320 6e6f 7420  e. File was not 
-00014e20: 636c 6f73 6564 2070 726f 7065 726c 792e  closed properly.
-00014e30: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
-00014e40: 2020 2020 2020 2020 2020 2020 2727 2025              '' %
-00014e50: 2066 696c 656e 616d 6529 0a0a 2020 2020   filename)..    
-00014e60: 2020 2020 6461 7465 7469 6d65 3120 3d20      datetime1 = 
-00014e70: 6461 7465 7469 6d65 2e64 6174 6574 696d  datetime.datetim
-00014e80: 652e 7374 7270 7469 6d65 286d 6174 6368  e.strptime(match
-00014e90: 7469 6d65 315b 2764 6174 6527 5d20 2b20  time1['date'] + 
-00014ea0: 2720 270a 2020 2020 2020 2020 2020 2020  ' '.            
-00014eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014b60: 2072 2728 3f50 3c74 696d 653e 5c53 2b29   r'(?P<time>\S+)
+00014b70: 2729 0a20 2020 2020 2020 2020 2020 2066  ').            f
+00014b80: 696c 656e 616d 655f 7265 6765 7820 3d20  ilename_regex = 
+00014b90: 7265 2e63 6f6d 7069 6c65 2872 272d 4f72  re.compile(r'-Or
+00014ba0: 6967 696e 616c 4669 6c65 4e61 6d65 2027  iginalFileName '
+00014bb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014bd0: 2020 2020 2020 2020 2072 2722 3f28 3f50           r'"?(?P
+00014be0: 3c66 696c 656e 616d 653e 5c53 2b29 223f  <filename>\S+)"?
+00014bf0: 2729 0a0a 2020 2020 2020 2020 2020 2020  ')..            
+00014c00: 6461 7465 7469 6d65 666f 726d 6174 203d  datetimeformat =
+00014c10: 2027 2559 2f25 6d2f 2564 2025 483a 254d   '%Y/%m/%d %H:%M
+00014c20: 3a25 5327 0a0a 2020 2020 2020 2020 6d61  :%S'..        ma
+00014c30: 7463 6874 696d 6531 203d 2064 6174 6574  tchtime1 = datet
+00014c40: 696d 6531 5f72 6567 6578 2e73 6561 7263  ime1_regex.searc
+00014c50: 6828 7465 7874 5f68 6561 6465 7229 2e67  h(text_header).g
+00014c60: 726f 7570 6469 6374 2829 0a20 2020 2020  roupdict().     
+00014c70: 2020 206d 6174 6368 7469 6d65 3220 3d20     matchtime2 = 
+00014c80: 6461 7465 7469 6d65 325f 7265 6765 782e  datetime2_regex.
+00014c90: 7365 6172 6368 2874 6578 745f 6865 6164  search(text_head
+00014ca0: 6572 292e 6772 6f75 7064 6963 7428 290a  er).groupdict().
+00014cb0: 2020 2020 2020 2020 6d61 7463 6866 696c          matchfil
+00014cc0: 656e 616d 6520 3d20 6669 6c65 6e61 6d65  ename = filename
+00014cd0: 5f72 6567 6578 2e73 6561 7263 6828 7465  _regex.search(te
+00014ce0: 7874 5f68 6561 6465 7229 0a0a 2020 2020  xt_header)..    
+00014cf0: 2020 2020 6669 6c65 6e61 6d65 203d 206d      filename = m
+00014d00: 6174 6368 6669 6c65 6e61 6d65 2e67 726f  atchfilename.gro
+00014d10: 7570 6469 6374 2829 5b27 6669 6c65 6e61  updict()['filena
+00014d20: 6d65 275d 0a0a 2020 2020 2020 2020 6966  me']..        if
+00014d30: 2027 2323 2054 696d 6520 436c 6f73 6564   '## Time Closed
+00014d40: 2046 696c 6520 7761 7320 6e6f 7420 636c   File was not cl
+00014d50: 6f73 6564 2070 726f 7065 726c 7927 2069  osed properly' i
+00014d60: 6e20 7465 7874 5f68 6561 6465 723a 0a20  n text_header:. 
+00014d70: 2020 2020 2020 2020 2020 2077 6172 6e69             warni
+00014d80: 6e67 732e 7761 726e 2827 5465 7874 2068  ngs.warn('Text h
+00014d90: 6561 6465 7220 6f66 2066 696c 6520 2573  eader of file %s
+00014da0: 2064 6f65 7320 6e6f 7420 636f 6e74 6169   does not contai
+00014db0: 6e20 7265 636f 7264 696e 6720 270a 2020  n recording '.  
+00014dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014dd0: 2020 2020 2020 2020 2763 6c6f 7365 6420          'closed 
+00014de0: 7469 6d65 2e20 4669 6c65 2077 6173 206e  time. File was n
+00014df0: 6f74 2063 6c6f 7365 6420 7072 6f70 6572  ot closed proper
+00014e00: 6c79 2e27 0a20 2020 2020 2020 2020 2020  ly.'.           
+00014e10: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00014e20: 2720 2520 6669 6c65 6e61 6d65 290a 0a20  ' % filename).. 
+00014e30: 2020 2020 2020 2064 6174 6574 696d 6531         datetime1
+00014e40: 203d 2064 6174 6574 696d 652e 6461 7465   = datetime.date
+00014e50: 7469 6d65 2e73 7472 7074 696d 6528 6d61  time.strptime(ma
+00014e60: 7463 6874 696d 6531 5b27 6461 7465 275d  tchtime1['date']
+00014e70: 202b 2027 2027 0a20 2020 2020 2020 2020   + ' '.         
+00014e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014ea0: 2020 2020 2020 2b20 6d61 7463 6874 696d        + matchtim
+00014eb0: 6531 5b27 7469 6d65 275d 2c0a 2020 2020  e1['time'],.    
 00014ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014ed0: 2020 202b 206d 6174 6368 7469 6d65 315b     + matchtime1[
-00014ee0: 2774 696d 6527 5d2c 0a20 2020 2020 2020  'time'],.       
-00014ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f10: 2020 2020 2020 2020 6461 7465 7469 6d65          datetime
-00014f20: 666f 726d 6174 290a 2020 2020 2020 2020  format).        
-00014f30: 6461 7465 7469 6d65 3220 3d20 6461 7465  datetime2 = date
-00014f40: 7469 6d65 2e64 6174 6574 696d 652e 7374  time.datetime.st
-00014f50: 7270 7469 6d65 286d 6174 6368 7469 6d65  rptime(matchtime
-00014f60: 325b 2764 6174 6527 5d20 2b20 2720 270a  2['date'] + ' '.
-00014f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f90: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-00014fa0: 206d 6174 6368 7469 6d65 325b 2774 696d   matchtime2['tim
-00014fb0: 6527 5d2c 0a20 2020 2020 2020 2020 2020  e'],.           
-00014fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014fe0: 2020 2020 6461 7465 7469 6d65 666f 726d      datetimeform
-00014ff0: 6174 290a 0a20 2020 2020 2020 206f 7574  at)..        out
-00015000: 7075 7420 3d20 7b27 7265 636f 7264 696e  put = {'recordin
-00015010: 675f 6f70 656e 6564 273a 2064 6174 6574  g_opened': datet
-00015020: 696d 6531 2c0a 2020 2020 2020 2020 2020  ime1,.          
-00015030: 2020 2020 2020 2020 2772 6563 6f72 6469          'recordi
-00015040: 6e67 5f63 6c6f 7365 6427 3a20 6461 7465  ng_closed': date
-00015050: 7469 6d65 322c 0a20 2020 2020 2020 2020  time2,.         
+00014ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014ee0: 2020 2020 2020 2020 2020 2064 6174 6574             datet
+00014ef0: 696d 6566 6f72 6d61 7429 0a20 2020 2020  imeformat).     
+00014f00: 2020 2064 6174 6574 696d 6532 203d 2064     datetime2 = d
+00014f10: 6174 6574 696d 652e 6461 7465 7469 6d65  atetime.datetime
+00014f20: 2e73 7472 7074 696d 6528 6d61 7463 6874  .strptime(matcht
+00014f30: 696d 6532 5b27 6461 7465 275d 202b 2027  ime2['date'] + '
+00014f40: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00014f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014f70: 2020 2b20 6d61 7463 6874 696d 6532 5b27    + matchtime2['
+00014f80: 7469 6d65 275d 2c0a 2020 2020 2020 2020  time'],.        
+00014f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014fb0: 2020 2020 2020 2064 6174 6574 696d 6566         datetimef
+00014fc0: 6f72 6d61 7429 0a0a 2020 2020 2020 2020  ormat)..        
+00014fd0: 6f75 7470 7574 203d 207b 2772 6563 6f72  output = {'recor
+00014fe0: 6469 6e67 5f6f 7065 6e65 6427 3a20 6461  ding_opened': da
+00014ff0: 7465 7469 6d65 312c 0a20 2020 2020 2020  tetime1,.       
+00015000: 2020 2020 2020 2020 2020 2027 7265 636f             'reco
+00015010: 7264 696e 675f 636c 6f73 6564 273a 2064  rding_closed': d
+00015020: 6174 6574 696d 6532 2c0a 2020 2020 2020  atetime2,.      
+00015030: 2020 2020 2020 2020 2020 2020 2766 696c              'fil
+00015040: 655f 6372 6561 7465 6427 3a20 6461 7465  e_created': date
+00015050: 7469 6d65 312c 0a20 2020 2020 2020 2020  time1,.         
 00015060: 2020 2020 2020 2020 2027 6669 6c65 5f63           'file_c
-00015070: 7265 6174 6564 273a 2064 6174 6574 696d  reated': datetim
-00015080: 6531 2c0a 2020 2020 2020 2020 2020 2020  e1,.            
-00015090: 2020 2020 2020 2766 696c 655f 636c 6f73        'file_clos
-000150a0: 6564 273a 2064 6174 6574 696d 6532 2c0a  ed': datetime2,.
-000150b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000150c0: 2020 2772 6563 6f72 6469 6e67 5f66 696c    'recording_fil
-000150d0: 655f 6e61 6d65 273a 2066 696c 656e 616d  e_name': filenam
-000150e0: 657d 0a0a 2020 2020 2020 2020 7265 7475  e}..        retu
-000150f0: 726e 206f 7574 7075 740a 0a20 2020 2064  rn output..    d
-00015100: 6566 205f 5f72 6561 645f 6e63 735f 6461  ef __read_ncs_da
-00015110: 7461 5f68 6561 6465 7273 2873 656c 662c  ta_headers(self,
-00015120: 2066 696c 6568 616e 646c 652c 2066 696c   filehandle, fil
-00015130: 656e 616d 6529 3a0a 2020 2020 2020 2020  ename):.        
-00015140: 2727 270a 2020 2020 2020 2020 5265 6164  '''.        Read
-00015150: 7320 7468 6520 2e6e 6373 2064 6174 6120  s the .ncs data 
-00015160: 626c 6f63 6b20 6865 6164 6572 7320 616e  block headers an
-00015170: 6420 7374 6f72 6573 2074 6865 2069 6e66  d stores the inf
-00015180: 6f72 6d61 7469 6f6e 2069 6e20 7468 650a  ormation in the.
-00015190: 2020 2020 2020 2020 6f62 6a65 6374 2773          object's
-000151a0: 2070 6172 616d 6574 6572 735f 6e63 7320   parameters_ncs 
-000151b0: 6469 6374 696f 6e61 7279 2e0a 0a20 2020  dictionary...   
-000151c0: 2020 2020 2041 7267 733a 0a20 2020 2020       Args:.     
-000151d0: 2020 2020 2020 2066 696c 6568 616e 646c         filehandl
-000151e0: 6520 2866 696c 6520 6f62 6a65 6374 293a  e (file object):
-000151f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015200: 2048 616e 646c 6520 746f 2074 6865 2061   Handle to the a
-00015210: 6c72 6561 6479 206f 7065 6e65 6420 2e6e  lready opened .n
-00015220: 6373 2066 696c 652e 0a20 2020 2020 2020  cs file..       
-00015230: 2020 2020 2066 696c 656e 616d 6520 2873       filename (s
-00015240: 7472 696e 6729 3a0a 2020 2020 2020 2020  tring):.        
-00015250: 2020 2020 2020 2020 4e61 6d65 206f 6620          Name of 
-00015260: 7468 6520 6e63 7320 6669 6c65 2e0a 2020  the ncs file..  
-00015270: 2020 2020 2020 5265 7475 726e 733a 0a20        Returns:. 
-00015280: 2020 2020 2020 2020 2020 2064 6963 7420             dict 
-00015290: 6f66 2065 7874 7261 6374 6564 2064 6174  of extracted dat
-000152a0: 610a 2020 2020 2020 2020 2727 270a 2020  a.        '''.  
-000152b0: 2020 2020 2020 7469 6d65 7374 616d 7073        timestamps
-000152c0: 203d 2066 696c 6568 616e 646c 655b 305d   = filehandle[0]
-000152d0: 0a20 2020 2020 2020 2068 6561 6465 725f  .        header_
-000152e0: 7534 203d 2066 696c 6568 616e 646c 655b  u4 = filehandle[
-000152f0: 315d 0a0a 2020 2020 2020 2020 6368 616e  1]..        chan
-00015300: 6e65 6c5f 6964 203d 2068 6561 6465 725f  nel_id = header_
-00015310: 7534 5b30 5d5b 305d 0a20 2020 2020 2020  u4[0][0].       
-00015320: 2073 7220 3d20 6865 6164 6572 5f75 345b   sr = header_u4[
-00015330: 305d 5b31 5d20 2023 2069 6e20 487a 0a0a  0][1]  # in Hz..
-00015340: 2020 2020 2020 2020 745f 7374 6172 7420          t_start 
-00015350: 3d20 7469 6d65 7374 616d 7073 5b30 5d20  = timestamps[0] 
-00015360: 2023 2069 6e20 6d69 6372 6f73 6563 6f6e   # in microsecon
-00015370: 6473 0a20 2020 2020 2020 2023 2063 616c  ds.        # cal
-00015380: 6375 6c61 7469 6e67 2063 6f72 7265 7370  culating corresp
-00015390: 6f6e 6469 6e67 2074 696d 6520 7374 616d  onding time stam
-000153a0: 7020 6f66 2066 6972 7374 2073 616d 706c  p of first sampl
-000153b0: 652c 2074 6861 7420 7761 7320 6e6f 740a  e, that was not.
-000153c0: 2020 2020 2020 2020 2320 7265 636f 7264          # record
-000153d0: 6564 2061 6e79 206d 6f72 650a 2020 2020  ed any more.    
-000153e0: 2020 2020 2320 745f 7374 6f70 3d20 7469      # t_stop= ti
-000153f0: 6d65 206f 6620 6669 7273 7420 7361 6d70  me of first samp
-00015400: 6c65 2069 6e20 6c61 7374 2070 6163 6b65  le in last packe
-00015410: 7420 2b28 2373 616d 706c 6573 2070 6572  t +(#samples per
-00015420: 2070 6163 6b65 7420 2a0a 2020 2020 2020   packet *.      
-00015430: 2020 2320 2063 6f6e 7665 7273 696f 6e20    #  conversion 
-00015440: 6661 6374 6f72 202f 2073 616d 706c 696e  factor / samplin
-00015450: 6720 7261 7465 290a 2020 2020 2020 2020  g rate).        
-00015460: 2320 636f 6e76 6572 7369 6f6e 2066 6163  # conversion fac
-00015470: 746f 7220 6973 206e 6565 6465 6420 6173  tor is needed as
-00015480: 2074 696d 6573 2061 7265 2072 6563 6f72   times are recor
-00015490: 6465 6420 696e 206d 730a 2020 2020 2020  ded in ms.      
-000154a0: 2020 745f 7374 6f70 203d 2074 696d 6573    t_stop = times
-000154b0: 7461 6d70 735b 2d31 5d20 2b20 280a 2020  tamps[-1] + (.  
-000154c0: 2020 2020 2020 2020 2020 2868 6561 6465            (heade
-000154d0: 725f 7534 5b2d 315d 5b32 5d29 202a 2028  r_u4[-1][2]) * (
-000154e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000154f0: 2031 202f 2073 656c 662e 6e63 735f 7469   1 / self.ncs_ti
-00015500: 6d65 5f75 6e69 742e 7265 7363 616c 6528  me_unit.rescale(
-00015510: 7071 2e73 2929 2e6d 6167 6e69 7475 6465  pq.s)).magnitude
-00015520: 0a20 2020 2020 2020 2020 2020 202f 2068  .            / h
-00015530: 6561 6465 725f 7534 5b2d 315d 5b31 5d29  eader_u4[-1][1])
-00015540: 0a0a 2020 2020 2020 2020 6966 2063 6861  ..        if cha
-00015550: 6e6e 656c 5f69 6420 696e 2073 656c 662e  nnel_id in self.
-00015560: 7061 7261 6d65 7465 7273 5f6e 6373 3a0a  parameters_ncs:.
-00015570: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00015580: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
-00015590: 2020 2020 2020 2020 2020 2020 2020 2744                'D
-000155a0: 6574 6563 7465 6420 6d75 6c74 6970 6c65  etected multiple
-000155b0: 206e 6373 2066 696c 6573 2066 6f72 2063   ncs files for c
-000155c0: 6861 6e6e 656c 5f69 6420 2569 2e27 0a20  hannel_id %i.'. 
-000155d0: 2020 2020 2020 2020 2020 2020 2020 2025                 %
-000155e0: 2063 6861 6e6e 656c 5f69 6429 0a20 2020   channel_id).   
-000155f0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00015600: 2020 2020 2020 2073 616d 706c 696e 675f         sampling_
-00015610: 756e 6974 203d 205b 7071 2e43 6f6d 706f  unit = [pq.Compo
-00015620: 756e 6455 6e69 7428 2725 662a 2573 270a  undUnit('%f*%s'.
-00015630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015070: 6c6f 7365 6427 3a20 6461 7465 7469 6d65  losed': datetime
+00015080: 322c 0a20 2020 2020 2020 2020 2020 2020  2,.             
+00015090: 2020 2020 2027 7265 636f 7264 696e 675f       'recording_
+000150a0: 6669 6c65 5f6e 616d 6527 3a20 6669 6c65  file_name': file
+000150b0: 6e61 6d65 7d0a 0a20 2020 2020 2020 2072  name}..        r
+000150c0: 6574 7572 6e20 6f75 7470 7574 0a0a 2020  eturn output..  
+000150d0: 2020 6465 6620 5f5f 7265 6164 5f6e 6373    def __read_ncs
+000150e0: 5f64 6174 615f 6865 6164 6572 7328 7365  _data_headers(se
+000150f0: 6c66 2c20 6669 6c65 6861 6e64 6c65 2c20  lf, filehandle, 
+00015100: 6669 6c65 6e61 6d65 293a 0a20 2020 2020  filename):.     
+00015110: 2020 2027 2727 0a20 2020 2020 2020 2052     '''.        R
+00015120: 6561 6473 2074 6865 202e 6e63 7320 6461  eads the .ncs da
+00015130: 7461 2062 6c6f 636b 2068 6561 6465 7273  ta block headers
+00015140: 2061 6e64 2073 746f 7265 7320 7468 6520   and stores the 
+00015150: 696e 666f 726d 6174 696f 6e20 696e 2074  information in t
+00015160: 6865 0a20 2020 2020 2020 206f 626a 6563  he.        objec
+00015170: 7427 7320 7061 7261 6d65 7465 7273 5f6e  t's parameters_n
+00015180: 6373 2064 6963 7469 6f6e 6172 792e 0a0a  cs dictionary...
+00015190: 2020 2020 2020 2020 4172 6773 3a0a 2020          Args:.  
+000151a0: 2020 2020 2020 2020 2020 6669 6c65 6861            fileha
+000151b0: 6e64 6c65 2028 6669 6c65 206f 626a 6563  ndle (file objec
+000151c0: 7429 3a0a 2020 2020 2020 2020 2020 2020  t):.            
+000151d0: 2020 2020 4861 6e64 6c65 2074 6f20 7468      Handle to th
+000151e0: 6520 616c 7265 6164 7920 6f70 656e 6564  e already opened
+000151f0: 202e 6e63 7320 6669 6c65 2e0a 2020 2020   .ncs file..    
+00015200: 2020 2020 2020 2020 6669 6c65 6e61 6d65          filename
+00015210: 2028 7374 7269 6e67 293a 0a20 2020 2020   (string):.     
+00015220: 2020 2020 2020 2020 2020 204e 616d 6520             Name 
+00015230: 6f66 2074 6865 206e 6373 2066 696c 652e  of the ncs file.
+00015240: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
+00015250: 3a0a 2020 2020 2020 2020 2020 2020 6469  :.            di
+00015260: 6374 206f 6620 6578 7472 6163 7465 6420  ct of extracted 
+00015270: 6461 7461 0a20 2020 2020 2020 2027 2727  data.        '''
+00015280: 0a20 2020 2020 2020 2074 696d 6573 7461  .        timesta
+00015290: 6d70 7320 3d20 6669 6c65 6861 6e64 6c65  mps = filehandle
+000152a0: 5b30 5d0a 2020 2020 2020 2020 6865 6164  [0].        head
+000152b0: 6572 5f75 3420 3d20 6669 6c65 6861 6e64  er_u4 = filehand
+000152c0: 6c65 5b31 5d0a 0a20 2020 2020 2020 2063  le[1]..        c
+000152d0: 6861 6e6e 656c 5f69 6420 3d20 6865 6164  hannel_id = head
+000152e0: 6572 5f75 345b 305d 5b30 5d0a 2020 2020  er_u4[0][0].    
+000152f0: 2020 2020 7372 203d 2068 6561 6465 725f      sr = header_
+00015300: 7534 5b30 5d5b 315d 2020 2320 696e 2048  u4[0][1]  # in H
+00015310: 7a0a 0a20 2020 2020 2020 2074 5f73 7461  z..        t_sta
+00015320: 7274 203d 2074 696d 6573 7461 6d70 735b  rt = timestamps[
+00015330: 305d 2020 2320 696e 206d 6963 726f 7365  0]  # in microse
+00015340: 636f 6e64 730a 2020 2020 2020 2020 2320  conds.        # 
+00015350: 6361 6c63 756c 6174 696e 6720 636f 7272  calculating corr
+00015360: 6573 706f 6e64 696e 6720 7469 6d65 2073  esponding time s
+00015370: 7461 6d70 206f 6620 6669 7273 7420 7361  tamp of first sa
+00015380: 6d70 6c65 2c20 7468 6174 2077 6173 206e  mple, that was n
+00015390: 6f74 0a20 2020 2020 2020 2023 2072 6563  ot.        # rec
+000153a0: 6f72 6465 6420 616e 7920 6d6f 7265 0a20  orded any more. 
+000153b0: 2020 2020 2020 2023 2074 5f73 746f 703d         # t_stop=
+000153c0: 2074 696d 6520 6f66 2066 6972 7374 2073   time of first s
+000153d0: 616d 706c 6520 696e 206c 6173 7420 7061  ample in last pa
+000153e0: 636b 6574 202b 2823 7361 6d70 6c65 7320  cket +(#samples 
+000153f0: 7065 7220 7061 636b 6574 202a 0a20 2020  per packet *.   
+00015400: 2020 2020 2023 2020 636f 6e76 6572 7369       #  conversi
+00015410: 6f6e 2066 6163 746f 7220 2f20 7361 6d70  on factor / samp
+00015420: 6c69 6e67 2072 6174 6529 0a20 2020 2020  ling rate).     
+00015430: 2020 2023 2063 6f6e 7665 7273 696f 6e20     # conversion 
+00015440: 6661 6374 6f72 2069 7320 6e65 6564 6564  factor is needed
+00015450: 2061 7320 7469 6d65 7320 6172 6520 7265   as times are re
+00015460: 636f 7264 6564 2069 6e20 6d73 0a20 2020  corded in ms.   
+00015470: 2020 2020 2074 5f73 746f 7020 3d20 7469       t_stop = ti
+00015480: 6d65 7374 616d 7073 5b2d 315d 202b 2028  mestamps[-1] + (
+00015490: 0a20 2020 2020 2020 2020 2020 2028 6865  .            (he
+000154a0: 6164 6572 5f75 345b 2d31 5d5b 325d 2920  ader_u4[-1][2]) 
+000154b0: 2a20 280a 2020 2020 2020 2020 2020 2020  * (.            
+000154c0: 2020 2020 3120 2f20 7365 6c66 2e6e 6373      1 / self.ncs
+000154d0: 5f74 696d 655f 756e 6974 2e72 6573 6361  _time_unit.resca
+000154e0: 6c65 2870 712e 7329 292e 6d61 676e 6974  le(pq.s)).magnit
+000154f0: 7564 650a 2020 2020 2020 2020 2020 2020  ude.            
+00015500: 2f20 6865 6164 6572 5f75 345b 2d31 5d5b  / header_u4[-1][
+00015510: 315d 290a 0a20 2020 2020 2020 2069 6620  1])..        if 
+00015520: 6368 616e 6e65 6c5f 6964 2069 6e20 7365  channel_id in se
+00015530: 6c66 2e70 6172 616d 6574 6572 735f 6e63  lf.parameters_nc
+00015540: 733a 0a20 2020 2020 2020 2020 2020 2072  s:.            r
+00015550: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+00015560: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015570: 2027 4465 7465 6374 6564 206d 756c 7469   'Detected multi
+00015580: 706c 6520 6e63 7320 6669 6c65 7320 666f  ple ncs files fo
+00015590: 7220 6368 616e 6e65 6c5f 6964 2025 692e  r channel_id %i.
+000155a0: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+000155b0: 2020 2520 6368 616e 6e65 6c5f 6964 290a    % channel_id).
+000155c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000155d0: 2020 2020 2020 2020 2020 7361 6d70 6c69            sampli
+000155e0: 6e67 5f75 6e69 7420 3d20 5b70 712e 436f  ng_unit = [pq.Co
+000155f0: 6d70 6f75 6e64 556e 6974 2827 2566 2a25  mpoundUnit('%f*%
+00015600: 7327 0a20 2020 2020 2020 2020 2020 2020  s'.             
+00015610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015630: 2727 2025 2028 7372 2c0a 2020 2020 2020  '' % (sr,.      
 00015640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015650: 2020 2020 2020 2020 2020 2020 2027 2720               '' 
-00015660: 2520 2873 722c 0a20 2020 2020 2020 2020  % (sr,.         
-00015670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015690: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
-000156a0: 6373 5f73 725f 756e 6974 2e73 796d 626f  cs_sr_unit.symbo
-000156b0: 6c29 295d 0a20 2020 2020 2020 2020 2020  l))].           
-000156c0: 2073 616d 706c 696e 675f 7261 7465 203d   sampling_rate =
-000156d0: 2073 7220 2a20 7365 6c66 2e6e 6373 5f73   sr * self.ncs_s
-000156e0: 725f 756e 6974 0a20 2020 2020 2020 2020  r_unit.         
-000156f0: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
-00015700: 7273 5f6e 6373 5b63 6861 6e6e 656c 5f69  rs_ncs[channel_i
-00015710: 645d 203d 207b 2766 696c 656e 616d 6527  d] = {'filename'
-00015720: 3a20 6669 6c65 6e61 6d65 2c0a 2020 2020  : filename,.    
-00015730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015750: 2020 2020 2020 2020 2020 2027 745f 7374             't_st
-00015760: 6172 7427 3a20 745f 7374 6172 740a 2020  art': t_start.  
-00015770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000157a0: 2020 2020 2020 2020 2a20 7365 6c66 2e6e          * self.n
-000157b0: 6373 5f74 696d 655f 756e 6974 2c0a 2020  cs_time_unit,.  
-000157c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000157d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000157e0: 2020 2020 2020 2020 2020 2020 2027 745f               't_
-000157f0: 7374 6f70 273a 2074 5f73 746f 700a 2020  stop': t_stop.  
-00015800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015660: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00015670: 662e 6e63 735f 7372 5f75 6e69 742e 7379  f.ncs_sr_unit.sy
+00015680: 6d62 6f6c 2929 5d0a 2020 2020 2020 2020  mbol))].        
+00015690: 2020 2020 7361 6d70 6c69 6e67 5f72 6174      sampling_rat
+000156a0: 6520 3d20 7372 202a 2073 656c 662e 6e63  e = sr * self.nc
+000156b0: 735f 7372 5f75 6e69 740a 2020 2020 2020  s_sr_unit.      
+000156c0: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
+000156d0: 6574 6572 735f 6e63 735b 6368 616e 6e65  eters_ncs[channe
+000156e0: 6c5f 6964 5d20 3d20 7b27 6669 6c65 6e61  l_id] = {'filena
+000156f0: 6d65 273a 2066 696c 656e 616d 652c 0a20  me': filename,. 
+00015700: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015720: 2020 2020 2020 2020 2020 2020 2020 2774                't
+00015730: 5f73 7461 7274 273a 2074 5f73 7461 7274  _start': t_start
+00015740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015770: 2020 2020 2020 2020 2020 202a 2073 656c             * sel
+00015780: 662e 6e63 735f 7469 6d65 5f75 6e69 742c  f.ncs_time_unit,
+00015790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000157a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000157b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000157c0: 2774 5f73 746f 7027 3a20 745f 7374 6f70  't_stop': t_stop
+000157d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000157e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000157f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015800: 2020 2020 2020 2020 2020 2a20 7365 6c66            * self
+00015810: 2e6e 6373 5f74 696d 655f 756e 6974 2c0a  .ncs_time_unit,.
 00015820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015830: 2020 2020 2020 202a 2073 656c 662e 6e63         * self.nc
-00015840: 735f 7469 6d65 5f75 6e69 742c 0a20 2020  s_time_unit,.   
-00015850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015870: 2020 2020 2020 2020 2020 2020 2773 616d              'sam
-00015880: 706c 696e 675f 7261 7465 273a 2073 616d  pling_rate': sam
-00015890: 706c 696e 675f 7261 7465 2c0a 2020 2020  pling_rate,.    
-000158a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000158b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000158c0: 2020 2020 2020 2020 2020 2027 7361 6d70             'samp
-000158d0: 6c69 6e67 5f75 6e69 7427 3a20 7361 6d70  ling_unit': samp
-000158e0: 6c69 6e67 5f75 6e69 742c 0a20 2020 2020  ling_unit,.     
-000158f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015910: 2020 2020 2020 2020 2020 2767 6170 7327            'gaps'
-00015920: 3a20 5b5d 7d0a 0a20 2020 2020 2020 2020  : []}..         
-00015930: 2020 2072 6574 7572 6e20 7b63 6861 6e6e     return {chann
-00015940: 656c 5f69 643a 2073 656c 662e 7061 7261  el_id: self.para
-00015950: 6d65 7465 7273 5f6e 6373 5b63 6861 6e6e  meters_ncs[chann
-00015960: 656c 5f69 645d 7d0a 0a20 2020 2064 6566  el_id]}..    def
-00015970: 205f 5f72 6561 645f 6e73 655f 6461 7461   __read_nse_data
-00015980: 5f68 6561 6465 7228 7365 6c66 2c20 6669  _header(self, fi
-00015990: 6c65 6861 6e64 6c65 2c20 6669 6c65 6e61  lehandle, filena
-000159a0: 6d65 293a 0a20 2020 2020 2020 2027 2727  me):.        '''
-000159b0: 0a20 2020 2020 2020 2052 6561 6473 2074  .        Reads t
-000159c0: 6865 202e 6e73 6520 6461 7461 2062 6c6f  he .nse data blo
-000159d0: 636b 2068 6561 6465 7273 2061 6e64 2073  ck headers and s
-000159e0: 746f 7265 7320 7468 6520 696e 666f 726d  tores the inform
-000159f0: 6174 696f 6e20 696e 2074 6865 0a20 2020  ation in the.   
-00015a00: 2020 2020 206f 626a 6563 7427 7320 7061       object's pa
-00015a10: 7261 6d65 7465 7273 5f6e 6373 2064 6963  rameters_ncs dic
-00015a20: 7469 6f6e 6172 792e 0a0a 2020 2020 2020  tionary...      
-00015a30: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
-00015a40: 2020 2020 6669 6c65 6861 6e64 6c65 2028      filehandle (
-00015a50: 6669 6c65 206f 626a 6563 7429 3a0a 2020  file object):.  
-00015a60: 2020 2020 2020 2020 2020 2020 2020 4861                Ha
-00015a70: 6e64 6c65 2074 6f20 7468 6520 616c 7265  ndle to the alre
-00015a80: 6164 7920 6f70 656e 6564 202e 6e73 6520  ady opened .nse 
-00015a90: 6669 6c65 2e0a 2020 2020 2020 2020 2020  file..          
-00015aa0: 2020 6669 6c65 6e61 6d65 2028 7374 7269    filename (stri
-00015ab0: 6e67 293a 0a20 2020 2020 2020 2020 2020  ng):.           
-00015ac0: 2020 2020 204e 616d 6520 6f66 2074 6865       Name of the
-00015ad0: 206e 7365 2066 696c 652e 0a20 2020 2020   nse file..     
-00015ae0: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
-00015af0: 2020 2020 2020 2020 2d0a 2020 2020 2020          -.      
-00015b00: 2020 2727 270a 0a20 2020 2020 2020 205b    '''..        [
-00015b10: 7469 6d65 7374 616d 7073 2c20 6368 616e  timestamps, chan
-00015b20: 6e65 6c5f 6964 732c 2063 656c 6c5f 6e75  nel_ids, cell_nu
-00015b30: 6d62 6572 732c 2066 6561 7475 7265 732c  mbers, features,
-00015b40: 0a20 2020 2020 2020 2020 6461 7461 5f70  .         data_p
-00015b50: 6f69 6e74 735d 203d 2066 696c 6568 616e  oints] = filehan
-00015b60: 646c 650a 0a20 2020 2020 2020 2069 6620  dle..        if 
-00015b70: 6669 6c65 6861 6e64 6c65 2069 7320 6e6f  filehandle is no
-00015b80: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-00015b90: 2020 2020 745f 6669 7273 7420 3d20 7469      t_first = ti
-00015ba0: 6d65 7374 616d 7073 5b30 5d20 2023 2069  mestamps[0]  # i
-00015bb0: 6e20 6d69 6372 6f73 6563 6f6e 6473 0a20  n microseconds. 
-00015bc0: 2020 2020 2020 2020 2020 2074 5f6c 6173             t_las
-00015bd0: 7420 3d20 7469 6d65 7374 616d 7073 5b2d  t = timestamps[-
-00015be0: 315d 2020 2320 696e 206d 6963 726f 7365  1]  # in microse
-00015bf0: 636f 6e64 730a 2020 2020 2020 2020 2020  conds.          
-00015c00: 2020 6368 616e 6e65 6c5f 6964 203d 2063    channel_id = c
-00015c10: 6861 6e6e 656c 5f69 6473 5b30 5d0a 2020  hannel_ids[0].  
-00015c20: 2020 2020 2020 2020 2020 6365 6c6c 5f63            cell_c
-00015c30: 6f75 6e74 203d 2063 656c 6c5f 6e75 6d62  ount = cell_numb
-00015c40: 6572 735b 305d 2020 2320 6e75 6d62 6572  ers[0]  # number
-00015c50: 206f 6620 6365 6c6c 7320 6964 656e 7469   of cells identi
-00015c60: 6669 6564 0a0a 2020 2020 2020 2020 2020  fied..          
-00015c70: 2020 7365 6c66 2e70 6172 616d 6574 6572    self.parameter
-00015c80: 735f 6e73 655b 6368 616e 6e65 6c5f 6964  s_nse[channel_id
-00015c90: 5d20 3d20 7b27 6669 6c65 6e61 6d65 273a  ] = {'filename':
-00015ca0: 2066 696c 656e 616d 652c 0a20 2020 2020   filename,.     
-00015cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015840: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00015850: 7361 6d70 6c69 6e67 5f72 6174 6527 3a20  sampling_rate': 
+00015860: 7361 6d70 6c69 6e67 5f72 6174 652c 0a20  sampling_rate,. 
+00015870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015890: 2020 2020 2020 2020 2020 2020 2020 2773                's
+000158a0: 616d 706c 696e 675f 756e 6974 273a 2073  ampling_unit': s
+000158b0: 616d 706c 696e 675f 756e 6974 2c0a 2020  ampling_unit,.  
+000158c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000158d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000158e0: 2020 2020 2020 2020 2020 2020 2027 6761               'ga
+000158f0: 7073 273a 205b 5d7d 0a0a 2020 2020 2020  ps': []}..      
+00015900: 2020 2020 2020 7265 7475 726e 207b 6368        return {ch
+00015910: 616e 6e65 6c5f 6964 3a20 7365 6c66 2e70  annel_id: self.p
+00015920: 6172 616d 6574 6572 735f 6e63 735b 6368  arameters_ncs[ch
+00015930: 616e 6e65 6c5f 6964 5d7d 0a0a 2020 2020  annel_id]}..    
+00015940: 6465 6620 5f5f 7265 6164 5f6e 7365 5f64  def __read_nse_d
+00015950: 6174 615f 6865 6164 6572 2873 656c 662c  ata_header(self,
+00015960: 2066 696c 6568 616e 646c 652c 2066 696c   filehandle, fil
+00015970: 656e 616d 6529 3a0a 2020 2020 2020 2020  ename):.        
+00015980: 2727 270a 2020 2020 2020 2020 5265 6164  '''.        Read
+00015990: 7320 7468 6520 2e6e 7365 2064 6174 6120  s the .nse data 
+000159a0: 626c 6f63 6b20 6865 6164 6572 7320 616e  block headers an
+000159b0: 6420 7374 6f72 6573 2074 6865 2069 6e66  d stores the inf
+000159c0: 6f72 6d61 7469 6f6e 2069 6e20 7468 650a  ormation in the.
+000159d0: 2020 2020 2020 2020 6f62 6a65 6374 2773          object's
+000159e0: 2070 6172 616d 6574 6572 735f 6e63 7320   parameters_ncs 
+000159f0: 6469 6374 696f 6e61 7279 2e0a 0a20 2020  dictionary...   
+00015a00: 2020 2020 2041 7267 733a 0a20 2020 2020       Args:.     
+00015a10: 2020 2020 2020 2066 696c 6568 616e 646c         filehandl
+00015a20: 6520 2866 696c 6520 6f62 6a65 6374 293a  e (file object):
+00015a30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015a40: 2048 616e 646c 6520 746f 2074 6865 2061   Handle to the a
+00015a50: 6c72 6561 6479 206f 7065 6e65 6420 2e6e  lready opened .n
+00015a60: 7365 2066 696c 652e 0a20 2020 2020 2020  se file..       
+00015a70: 2020 2020 2066 696c 656e 616d 6520 2873       filename (s
+00015a80: 7472 696e 6729 3a0a 2020 2020 2020 2020  tring):.        
+00015a90: 2020 2020 2020 2020 4e61 6d65 206f 6620          Name of 
+00015aa0: 7468 6520 6e73 6520 6669 6c65 2e0a 2020  the nse file..  
+00015ab0: 2020 2020 2020 5265 7475 726e 733a 0a20        Returns:. 
+00015ac0: 2020 2020 2020 2020 2020 202d 0a20 2020             -.   
+00015ad0: 2020 2020 2027 2727 0a0a 2020 2020 2020       '''..      
+00015ae0: 2020 5b74 696d 6573 7461 6d70 732c 2063    [timestamps, c
+00015af0: 6861 6e6e 656c 5f69 6473 2c20 6365 6c6c  hannel_ids, cell
+00015b00: 5f6e 756d 6265 7273 2c20 6665 6174 7572  _numbers, featur
+00015b10: 6573 2c0a 2020 2020 2020 2020 2064 6174  es,.         dat
+00015b20: 615f 706f 696e 7473 5d20 3d20 6669 6c65  a_points] = file
+00015b30: 6861 6e64 6c65 0a0a 2020 2020 2020 2020  handle..        
+00015b40: 6966 2066 696c 6568 616e 646c 6520 6973  if filehandle is
+00015b50: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00015b60: 2020 2020 2020 2074 5f66 6972 7374 203d         t_first =
+00015b70: 2074 696d 6573 7461 6d70 735b 305d 2020   timestamps[0]  
+00015b80: 2320 696e 206d 6963 726f 7365 636f 6e64  # in microsecond
+00015b90: 730a 2020 2020 2020 2020 2020 2020 745f  s.            t_
+00015ba0: 6c61 7374 203d 2074 696d 6573 7461 6d70  last = timestamp
+00015bb0: 735b 2d31 5d20 2023 2069 6e20 6d69 6372  s[-1]  # in micr
+00015bc0: 6f73 6563 6f6e 6473 0a20 2020 2020 2020  oseconds.       
+00015bd0: 2020 2020 2063 6861 6e6e 656c 5f69 6420       channel_id 
+00015be0: 3d20 6368 616e 6e65 6c5f 6964 735b 305d  = channel_ids[0]
+00015bf0: 0a20 2020 2020 2020 2020 2020 2063 656c  .            cel
+00015c00: 6c5f 636f 756e 7420 3d20 6365 6c6c 5f6e  l_count = cell_n
+00015c10: 756d 6265 7273 5b30 5d20 2023 206e 756d  umbers[0]  # num
+00015c20: 6265 7220 6f66 2063 656c 6c73 2069 6465  ber of cells ide
+00015c30: 6e74 6966 6965 640a 0a20 2020 2020 2020  ntified..       
+00015c40: 2020 2020 2073 656c 662e 7061 7261 6d65       self.parame
+00015c50: 7465 7273 5f6e 7365 5b63 6861 6e6e 656c  ters_nse[channel
+00015c60: 5f69 645d 203d 207b 2766 696c 656e 616d  _id] = {'filenam
+00015c70: 6527 3a20 6669 6c65 6e61 6d65 2c0a 2020  e': filename,.  
+00015c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015ca0: 2020 2020 2020 2020 2020 2020 2027 745f               't_
+00015cb0: 6669 7273 7427 3a20 745f 6669 7273 740a  first': t_first.
 00015cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015cd0: 2020 2020 2020 2020 2020 2774 5f66 6972            't_fir
-00015ce0: 7374 273a 2074 5f66 6972 7374 0a20 2020  st': t_first.   
-00015cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015cf0: 2020 2020 2020 2020 2020 2a20 7365 6c66            * self
+00015d00: 2e6e 7365 5f74 696d 655f 756e 6974 2c0a  .nse_time_unit,.
 00015d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d20: 2020 2020 2020 202a 2073 656c 662e 6e73         * self.ns
-00015d30: 655f 7469 6d65 5f75 6e69 742c 0a20 2020  e_time_unit,.   
-00015d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015d30: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00015d40: 745f 6c61 7374 273a 2074 5f6c 6173 740a  t_last': t_last.
 00015d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d60: 2020 2020 2020 2020 2020 2020 2774 5f6c              't_l
-00015d70: 6173 7427 3a20 745f 6c61 7374 0a20 2020  ast': t_last.   
-00015d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015d80: 2020 2020 2020 2020 202a 2073 656c 662e           * self.
+00015d90: 6e73 655f 7469 6d65 5f75 6e69 742c 0a20  nse_time_unit,. 
 00015da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015db0: 2020 2020 2020 2a20 7365 6c66 2e6e 7365        * self.nse
-00015dc0: 5f74 696d 655f 756e 6974 2c0a 2020 2020  _time_unit,.    
-00015dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015df0: 2020 2020 2020 2020 2020 2027 6365 6c6c             'cell
-00015e00: 5f63 6f75 6e74 273a 2063 656c 6c5f 636f  _count': cell_co
-00015e10: 756e 747d 0a0a 2020 2020 6465 6620 5f5f  unt}..    def __
-00015e20: 7265 6164 5f6e 7474 5f64 6174 615f 6865  read_ntt_data_he
-00015e30: 6164 6572 2873 656c 662c 2066 696c 6568  ader(self, fileh
-00015e40: 616e 646c 652c 2066 696c 656e 616d 6529  andle, filename)
-00015e50: 3a0a 2020 2020 2020 2020 2727 270a 2020  :.        '''.  
-00015e60: 2020 2020 2020 5265 6164 7320 7468 6520        Reads the 
-00015e70: 2e6e 7365 2064 6174 6120 626c 6f63 6b20  .nse data block 
-00015e80: 6865 6164 6572 7320 616e 6420 7374 6f72  headers and stor
-00015e90: 6573 2074 6865 2069 6e66 6f72 6d61 7469  es the informati
-00015ea0: 6f6e 2069 6e20 7468 650a 2020 2020 2020  on in the.      
-00015eb0: 2020 6f62 6a65 6374 2773 2070 6172 616d    object's param
-00015ec0: 6574 6572 735f 6e63 7320 6469 6374 696f  eters_ncs dictio
-00015ed0: 6e61 7279 2e0a 0a20 2020 2020 2020 2041  nary...        A
-00015ee0: 7267 733a 0a20 2020 2020 2020 2020 2020  rgs:.           
-00015ef0: 2066 696c 6568 616e 646c 6520 2866 696c   filehandle (fil
-00015f00: 6520 6f62 6a65 6374 293a 0a20 2020 2020  e object):.     
-00015f10: 2020 2020 2020 2020 2020 2048 616e 646c             Handl
-00015f20: 6520 746f 2074 6865 2061 6c72 6561 6479  e to the already
-00015f30: 206f 7065 6e65 6420 2e6e 7365 2066 696c   opened .nse fil
-00015f40: 652e 0a20 2020 2020 2020 2020 2020 2066  e..            f
-00015f50: 696c 656e 616d 6520 2873 7472 696e 6729  ilename (string)
-00015f60: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00015f70: 2020 4e61 6d65 206f 6620 7468 6520 6e73    Name of the ns
-00015f80: 6520 6669 6c65 2e0a 2020 2020 2020 2020  e file..        
-00015f90: 5265 7475 726e 733a 0a20 2020 2020 2020  Returns:.       
-00015fa0: 2020 2020 202d 0a20 2020 2020 2020 2027       -.        '
-00015fb0: 2727 0a0a 2020 2020 2020 2020 5b74 696d  ''..        [tim
-00015fc0: 6573 7461 6d70 732c 2063 6861 6e6e 656c  estamps, channel
-00015fd0: 5f69 6473 2c20 6365 6c6c 5f6e 756d 6265  _ids, cell_numbe
-00015fe0: 7273 2c20 6665 6174 7572 6573 2c0a 2020  rs, features,.  
-00015ff0: 2020 2020 2020 2064 6174 615f 706f 696e         data_poin
-00016000: 7473 5d20 3d20 6669 6c65 6861 6e64 6c65  ts] = filehandle
-00016010: 0a0a 2020 2020 2020 2020 6966 2066 696c  ..        if fil
-00016020: 6568 616e 646c 6520 6973 206e 6f74 204e  ehandle is not N
-00016030: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00016040: 2074 5f66 6972 7374 203d 2074 696d 6573   t_first = times
-00016050: 7461 6d70 735b 305d 2020 2320 696e 206d  tamps[0]  # in m
-00016060: 6963 726f 7365 636f 6e64 730a 2020 2020  icroseconds.    
-00016070: 2020 2020 2020 2020 745f 6c61 7374 203d          t_last =
-00016080: 2074 696d 6573 7461 6d70 735b 2d31 5d20   timestamps[-1] 
-00016090: 2023 2069 6e20 6d69 6372 6f73 6563 6f6e   # in microsecon
-000160a0: 6473 0a20 2020 2020 2020 2020 2020 2063  ds.            c
-000160b0: 6861 6e6e 656c 5f69 6420 3d20 6368 616e  hannel_id = chan
-000160c0: 6e65 6c5f 6964 735b 305d 0a20 2020 2020  nel_ids[0].     
-000160d0: 2020 2020 2020 2063 656c 6c5f 636f 756e         cell_coun
-000160e0: 7420 3d20 6365 6c6c 5f6e 756d 6265 7273  t = cell_numbers
-000160f0: 5b30 5d20 2023 206e 756d 6265 7220 6f66  [0]  # number of
-00016100: 2063 656c 6c73 2069 6465 6e74 6966 6965   cells identifie
-00016110: 640a 2020 2020 2020 2020 2020 2020 2320  d.            # 
-00016120: 7370 696b 655f 7061 7261 6d65 7465 7273  spike_parameters
-00016130: 203d 2066 696c 6568 616e 646c 655b 305d   = filehandle[0]
-00016140: 5b33 5d0a 2020 2020 2020 2020 2020 2020  [3].            
-00016150: 2320 656c 7365 3a0a 2020 2020 2020 2020  # else:.        
-00016160: 2020 2020 2320 2020 2020 745f 6669 7273      #     t_firs
-00016170: 7420 3d20 4e6f 6e65 0a20 2020 2020 2020  t = None.       
-00016180: 2020 2020 2023 2020 2020 2063 6861 6e6e       #     chann
-00016190: 656c 5f69 6420 3d20 4e6f 6e65 0a20 2020  el_id = None.   
-000161a0: 2020 2020 2020 2020 2023 2020 2020 2063           #     c
-000161b0: 656c 6c5f 636f 756e 7420 3d20 300a 2020  ell_count = 0.  
-000161c0: 2020 2020 2020 2020 2020 2320 2020 2020            #     
-000161d0: 2320 7370 696b 655f 7061 7261 6d65 7465  # spike_paramete
-000161e0: 7273 203d 2020 4e6f 6e65 0a20 2020 2020  rs =  None.     
-000161f0: 2020 2020 2020 2023 0a20 2020 2020 2020         #.       
-00016200: 2020 2020 2023 2020 2020 2073 656c 662e       #     self.
-00016210: 5f64 6961 676e 6f73 7469 635f 7072 696e  _diagnostic_prin
-00016220: 7428 2745 6d70 7479 2066 696c 653a 204e  t('Empty file: N
-00016230: 6f20 696e 666f 726d 6174 696f 6e0a 2020  o information.  
-00016240: 2020 2020 2020 2020 2020 2320 636f 6e74            # cont
-00016250: 6169 6e65 6420 696e 2025 7327 2566 696c  ained in %s'%fil
-00016260: 656e 616d 6529 0a0a 2020 2020 2020 2020  ename)..        
-00016270: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
-00016280: 6572 735f 6e74 745b 6368 616e 6e65 6c5f  ers_ntt[channel_
-00016290: 6964 5d20 3d20 7b27 6669 6c65 6e61 6d65  id] = {'filename
-000162a0: 273a 2066 696c 656e 616d 652c 0a20 2020  ': filename,.   
-000162b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000162c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000162d0: 2020 2020 2020 2020 2020 2020 2774 5f66              't_f
-000162e0: 6972 7374 273a 2074 5f66 6972 7374 0a20  irst': t_first. 
-000162f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016320: 2020 2020 2020 2020 202a 2073 656c 662e           * self.
-00016330: 6e74 745f 7469 6d65 5f75 6e69 742c 0a20  ntt_time_unit,. 
-00016340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016360: 2020 2020 2020 2020 2020 2020 2020 2774                't
-00016370: 5f6c 6173 7427 3a20 745f 6c61 7374 0a20  _last': t_last. 
-00016380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163b0: 2020 2020 2020 2020 2a20 7365 6c66 2e6e          * self.n
-000163c0: 7365 5f74 696d 655f 756e 6974 2c0a 2020  se_time_unit,.  
-000163d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163f0: 2020 2020 2020 2020 2020 2020 2027 6365               'ce
-00016400: 6c6c 5f63 6f75 6e74 273a 2063 656c 6c5f  ll_count': cell_
-00016410: 636f 756e 747d 0a0a 2020 2020 6465 6620  count}..    def 
-00016420: 5f5f 7265 6164 5f6e 6576 5f64 6174 615f  __read_nev_data_
-00016430: 6865 6164 6572 2873 656c 662c 2066 696c  header(self, fil
-00016440: 6568 616e 646c 652c 2066 696c 656e 616d  ehandle, filenam
-00016450: 6529 3a0a 2020 2020 2020 2020 2727 270a  e):.        '''.
-00016460: 2020 2020 2020 2020 5265 6164 7320 7468          Reads th
-00016470: 6520 2e6e 6576 2064 6174 6120 626c 6f63  e .nev data bloc
-00016480: 6b20 6865 6164 6572 7320 616e 6420 7374  k headers and st
-00016490: 6f72 6573 2074 6865 2072 656c 6576 616e  ores the relevan
-000164a0: 7420 696e 666f 726d 6174 696f 6e0a 2020  t information.  
-000164b0: 2020 2020 2020 696e 2074 6865 0a20 2020        in the.   
-000164c0: 2020 2020 206f 626a 6563 7427 7320 7061       object's pa
-000164d0: 7261 6d65 7465 7273 5f6e 6576 2064 6963  rameters_nev dic
-000164e0: 7469 6f6e 6172 792e 0a0a 2020 2020 2020  tionary...      
-000164f0: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
-00016500: 2020 2020 6669 6c65 6861 6e64 6c65 2028      filehandle (
-00016510: 6669 6c65 206f 626a 6563 7429 3a0a 2020  file object):.  
-00016520: 2020 2020 2020 2020 2020 2020 2020 4861                Ha
-00016530: 6e64 6c65 2074 6f20 7468 6520 616c 7265  ndle to the alre
-00016540: 6164 7920 6f70 656e 6564 202e 6e65 7620  ady opened .nev 
-00016550: 6669 6c65 2e0a 2020 2020 2020 2020 2020  file..          
-00016560: 2020 6669 6c65 6e61 6d65 2028 7374 7269    filename (stri
-00016570: 6e67 293a 0a20 2020 2020 2020 2020 2020  ng):.           
-00016580: 2020 2020 204e 616d 6520 6f66 2074 6865       Name of the
-00016590: 206e 6576 2066 696c 652e 0a20 2020 2020   nev file..     
-000165a0: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
-000165b0: 2020 2020 2020 2020 2d0a 2020 2020 2020          -.      
-000165c0: 2020 2727 270a 0a20 2020 2020 2020 2023    '''..        #
-000165d0: 2045 7874 7261 6374 696e 6720 6261 7369   Extracting basi
-000165e0: 6320 7265 636f 7264 696e 6720 6576 656e  c recording even
-000165f0: 7473 2074 6f20 6265 2061 626c 6520 746f  ts to be able to
-00016600: 2063 6865 636b 2072 6563 6f72 6469 6e67   check recording
-00016610: 0a20 2020 2020 2020 2023 2063 6f6e 7369  .        # consi
-00016620: 7374 656e 6379 0a20 2020 2020 2020 2069  stency.        i
-00016630: 6620 6669 6c65 6e61 6d65 2069 6e20 7365  f filename in se
-00016640: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
-00016650: 763a 0a20 2020 2020 2020 2020 2020 2072  v:.            r
-00016660: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00016670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016680: 2027 4465 7465 6374 6564 206d 756c 7469   'Detected multi
-00016690: 706c 6520 6e65 7620 6669 6c65 7320 6f66  ple nev files of
-000166a0: 206e 616d 6520 2573 2e27 2025 2028 6669   name %s.' % (fi
-000166b0: 6c65 6e61 6d65 2929 0a20 2020 2020 2020  lename)).       
-000166c0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-000166d0: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
-000166e0: 7273 5f6e 6576 5b66 696c 656e 616d 655d  rs_nev[filename]
-000166f0: 203d 207b 7d0a 2020 2020 2020 2020 2020   = {}.          
-00016700: 2020 6966 2027 5374 6172 7469 6e67 5f52    if 'Starting_R
-00016710: 6563 6f72 6469 6e67 2720 696e 2073 656c  ecording' in sel
-00016720: 662e 7061 7261 6d65 7465 7273 5f6e 6576  f.parameters_nev
-00016730: 5b66 696c 656e 616d 655d 3a0a 2020 2020  [filename]:.    
-00016740: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00016750: 6520 5661 6c75 6545 7272 6f72 2827 5472  e ValueError('Tr
-00016760: 7969 6e67 2074 6f20 7265 6164 2073 6563  ying to read sec
-00016770: 6f6e 6420 6e65 7620 6669 6c65 206f 6620  ond nev file of 
-00016780: 6e61 6d65 2025 732e 2027 0a20 2020 2020  name %s. '.     
-00016790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000167a0: 2020 2020 2020 2020 2020 2020 2720 4f6e              ' On
-000167b0: 6c79 206f 6e65 2063 616e 2062 6520 6861  ly one can be ha
-000167c0: 6e64 6c65 642e 2720 2520 6669 6c65 6e61  ndled.' % filena
-000167d0: 6d65 290a 2020 2020 2020 2020 2020 2020  me).            
-000167e0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-000167f0: 6e65 765b 6669 6c65 6e61 6d65 5d5b 2753  nev[filename]['S
-00016800: 7461 7274 696e 675f 5265 636f 7264 696e  tarting_Recordin
-00016810: 6727 5d20 3d20 5b5d 0a20 2020 2020 2020  g'] = [].       
-00016820: 2020 2020 2073 656c 662e 7061 7261 6d65       self.parame
-00016830: 7465 7273 5f6e 6576 5b66 696c 656e 616d  ters_nev[filenam
-00016840: 655d 5b27 6576 656e 7473 275d 203d 205b  e]['events'] = [
-00016850: 5d0a 2020 2020 2020 2020 2020 2020 666f  ].            fo
-00016860: 7220 6576 656e 7420 696e 2066 696c 6568  r event in fileh
-00016870: 616e 646c 653a 0a20 2020 2020 2020 2020  andle:.         
-00016880: 2020 2020 2020 2023 2073 6570 6172 6174         # separat
-00016890: 656c 7920 6578 7472 6163 7469 6e67 2027  ely extracting '
-000168a0: 5374 6172 7469 6e67 2052 6563 6f72 6469  Starting Recordi
-000168b0: 6e67 270a 2020 2020 2020 2020 2020 2020  ng'.            
-000168c0: 2020 2020 6966 2028 2865 7665 6e74 5b34      if ((event[4
-000168d0: 5d20 696e 205b 3131 2c20 3139 5d29 0a20  ] in [11, 19]). 
-000168e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000168f0: 2020 2020 2020 2061 6e64 2028 6576 656e         and (even
-00016900: 745b 3130 5d2e 6465 636f 6465 2827 6c61  t[10].decode('la
-00016910: 7469 6e2d 3127 2920 3d3d 2027 5374 6172  tin-1') == 'Star
-00016920: 7469 6e67 2052 6563 6f72 6469 6e67 2729  ting Recording')
-00016930: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00016940: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
-00016950: 6d65 7465 7273 5f6e 6576 5b66 696c 656e  meters_nev[filen
-00016960: 616d 655d 5b27 5374 6172 7469 6e67 5f52  ame]['Starting_R
-00016970: 6563 6f72 6469 6e67 275d 2e61 7070 656e  ecording'].appen
-00016980: 6428 0a20 2020 2020 2020 2020 2020 2020  d(.             
-00016990: 2020 2020 2020 2020 2020 2065 7665 6e74             event
-000169a0: 5b33 5d20 2a20 7365 6c66 2e6e 6576 5f74  [3] * self.nev_t
-000169b0: 696d 655f 756e 6974 290a 0a20 2020 2020  ime_unit)..     
-000169c0: 2020 2020 2020 2020 2020 2023 2061 6464             # add
-000169d0: 696e 6720 616c 6c20 6576 656e 7473 2074  ing all events t
-000169e0: 6f20 7061 7261 6d65 7465 7220 636f 6c6c  o parameter coll
-000169f0: 6563 7469 6f6e 0a20 2020 2020 2020 2020  ection.         
-00016a00: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
-00016a10: 6d65 7465 7273 5f6e 6576 5b66 696c 656e  meters_nev[filen
-00016a20: 616d 655d 5b27 6576 656e 7473 275d 2e61  ame]['events'].a
-00016a30: 7070 656e 6428 0a20 2020 2020 2020 2020  ppend(.         
-00016a40: 2020 2020 2020 2020 2020 207b 2774 696d             {'tim
-00016a50: 6573 7461 6d70 273a 2065 7665 6e74 5b33  estamp': event[3
-00016a60: 5d20 2a20 7365 6c66 2e6e 6576 5f74 696d  ] * self.nev_tim
-00016a70: 655f 756e 6974 2c0a 2020 2020 2020 2020  e_unit,.        
-00016a80: 2020 2020 2020 2020 2020 2020 2027 6576               'ev
-00016a90: 656e 745f 6964 273a 2065 7665 6e74 5b34  ent_id': event[4
-00016aa0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
-00016ab0: 2020 2020 2020 2020 276e 7474 6c27 3a20          'nttl': 
-00016ac0: 6576 656e 745b 355d 2c0a 2020 2020 2020  event[5],.      
-00016ad0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00016ae0: 6e61 6d65 273a 2065 7665 6e74 5b31 305d  name': event[10]
-00016af0: 2e64 6563 6f64 6528 276c 6174 696e 2d31  .decode('latin-1
-00016b00: 2729 7d29 0a0a 2020 2020 2020 2020 2020  ')})..          
-00016b10: 2020 6966 206c 656e 2873 656c 662e 7061    if len(self.pa
-00016b20: 7261 6d65 7465 7273 5f6e 6576 5b66 696c  rameters_nev[fil
-00016b30: 656e 616d 655d 5b27 5374 6172 7469 6e67  ename]['Starting
-00016b40: 5f52 6563 6f72 6469 6e67 275d 2920 3c20  _Recording']) < 
-00016b50: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
-00016b60: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00016b70: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
-00016b80: 2020 2020 2020 2020 2027 4e6f 2045 7665           'No Eve
-00016b90: 6e74 2022 5374 6172 7469 6e67 5f52 6563  nt "Starting_Rec
-00016ba0: 6f72 6469 6e67 2220 6465 7465 6374 6564  ording" detected
-00016bb0: 2069 6e20 2573 2720 2520 280a 2020 2020   in %s' % (.    
-00016bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016bd0: 2020 2020 6669 6c65 6e61 6d65 2929 0a0a      filename))..
-00016be0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00016bf0: 2e70 6172 616d 6574 6572 735f 6e65 765b  .parameters_nev[
-00016c00: 6669 6c65 6e61 6d65 5d5b 2774 5f73 7461  filename]['t_sta
-00016c10: 7274 275d 203d 206d 696e 280a 2020 2020  rt'] = min(.    
-00016c20: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00016c30: 2e70 6172 616d 6574 6572 735f 6e65 765b  .parameters_nev[
-00016c40: 6669 6c65 6e61 6d65 5d5b 2753 7461 7274  filename]['Start
-00016c50: 696e 675f 5265 636f 7264 696e 6727 5d29  ing_Recording'])
-00016c60: 0a20 2020 2020 2020 2020 2020 2023 2074  .            # t
-00016c70: 5f73 746f 7020 3d20 7469 6d65 2073 7461  _stop = time sta
-00016c80: 6d70 206f 6620 6c61 7374 2065 7665 6e74  mp of last event
-00016c90: 2069 6e20 6669 6c65 0a20 2020 2020 2020   in file.       
-00016ca0: 2020 2020 2073 656c 662e 7061 7261 6d65       self.parame
-00016cb0: 7465 7273 5f6e 6576 5b66 696c 656e 616d  ters_nev[filenam
-00016cc0: 655d 5b27 745f 7374 6f70 275d 203d 206d  e]['t_stop'] = m
-00016cd0: 6178 280a 2020 2020 2020 2020 2020 2020  ax(.            
-00016ce0: 2020 2020 5b65 5b27 7469 6d65 7374 616d      [e['timestam
-00016cf0: 7027 5d20 666f 7220 6520 696e 0a20 2020  p'] for e in.   
-00016d00: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00016d10: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
-00016d20: 765b 6669 6c65 6e61 6d65 5d5b 2765 7665  v[filename]['eve
-00016d30: 6e74 7327 5d5d 290a 0a20 2020 2020 2020  nts']])..       
-00016d40: 2020 2020 2023 2065 7874 7261 6374 2061       # extract a
-00016d50: 6c6c 206f 6363 7572 7269 6e67 2065 7665  ll occurring eve
-00016d60: 6e74 2074 7970 6573 2028 3d20 636f 6d62  nt types (= comb
-00016d70: 696e 6174 696f 6e20 6f66 206e 7474 6c2c  ination of nttl,
-00016d80: 0a20 2020 2020 2020 2020 2020 2023 2065  .            # e
-00016d90: 7665 6e74 5f69 6420 616e 6420 6e61 6d65  vent_id and name
-00016da0: 2f73 7472 696e 6729 0a20 2020 2020 2020  /string).       
-00016db0: 2020 2020 2065 7665 6e74 5f74 7970 6573       event_types
-00016dc0: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
-00016dd0: 2873 656c 662e 7061 7261 6d65 7465 7273  (self.parameters
-00016de0: 5f6e 6576 5b66 696c 656e 616d 655d 5b27  _nev[filename]['
-00016df0: 6576 656e 7473 275d 290a 2020 2020 2020  events']).      
-00016e00: 2020 2020 2020 666f 7220 6420 696e 2065        for d in e
-00016e10: 7665 6e74 5f74 7970 6573 3a0a 2020 2020  vent_types:.    
-00016e20: 2020 2020 2020 2020 2020 2020 642e 706f              d.po
-00016e30: 7028 2774 696d 6573 7461 6d70 2729 0a20  p('timestamp'). 
-00016e40: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00016e50: 7061 7261 6d65 7465 7273 5f6e 6576 5b66  parameters_nev[f
-00016e60: 696c 656e 616d 655d 5b27 6576 656e 745f  ilename]['event_
-00016e70: 7479 7065 7327 5d20 3d20 5b64 6963 7428  types'] = [dict(
-00016e80: 7929 2066 6f72 2079 2069 6e0a 2020 2020  y) for y in.    
-00016e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015dc0: 2020 2020 2020 2020 2020 2020 2020 2763                'c
+00015dd0: 656c 6c5f 636f 756e 7427 3a20 6365 6c6c  ell_count': cell
+00015de0: 5f63 6f75 6e74 7d0a 0a20 2020 2064 6566  _count}..    def
+00015df0: 205f 5f72 6561 645f 6e74 745f 6461 7461   __read_ntt_data
+00015e00: 5f68 6561 6465 7228 7365 6c66 2c20 6669  _header(self, fi
+00015e10: 6c65 6861 6e64 6c65 2c20 6669 6c65 6e61  lehandle, filena
+00015e20: 6d65 293a 0a20 2020 2020 2020 2027 2727  me):.        '''
+00015e30: 0a20 2020 2020 2020 2052 6561 6473 2074  .        Reads t
+00015e40: 6865 202e 6e73 6520 6461 7461 2062 6c6f  he .nse data blo
+00015e50: 636b 2068 6561 6465 7273 2061 6e64 2073  ck headers and s
+00015e60: 746f 7265 7320 7468 6520 696e 666f 726d  tores the inform
+00015e70: 6174 696f 6e20 696e 2074 6865 0a20 2020  ation in the.   
+00015e80: 2020 2020 206f 626a 6563 7427 7320 7061       object's pa
+00015e90: 7261 6d65 7465 7273 5f6e 6373 2064 6963  rameters_ncs dic
+00015ea0: 7469 6f6e 6172 792e 0a0a 2020 2020 2020  tionary...      
+00015eb0: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
+00015ec0: 2020 2020 6669 6c65 6861 6e64 6c65 2028      filehandle (
+00015ed0: 6669 6c65 206f 626a 6563 7429 3a0a 2020  file object):.  
+00015ee0: 2020 2020 2020 2020 2020 2020 2020 4861                Ha
+00015ef0: 6e64 6c65 2074 6f20 7468 6520 616c 7265  ndle to the alre
+00015f00: 6164 7920 6f70 656e 6564 202e 6e73 6520  ady opened .nse 
+00015f10: 6669 6c65 2e0a 2020 2020 2020 2020 2020  file..          
+00015f20: 2020 6669 6c65 6e61 6d65 2028 7374 7269    filename (stri
+00015f30: 6e67 293a 0a20 2020 2020 2020 2020 2020  ng):.           
+00015f40: 2020 2020 204e 616d 6520 6f66 2074 6865       Name of the
+00015f50: 206e 7365 2066 696c 652e 0a20 2020 2020   nse file..     
+00015f60: 2020 2052 6574 7572 6e73 3a0a 2020 2020     Returns:.    
+00015f70: 2020 2020 2020 2020 2d0a 2020 2020 2020          -.      
+00015f80: 2020 2727 270a 0a20 2020 2020 2020 205b    '''..        [
+00015f90: 7469 6d65 7374 616d 7073 2c20 6368 616e  timestamps, chan
+00015fa0: 6e65 6c5f 6964 732c 2063 656c 6c5f 6e75  nel_ids, cell_nu
+00015fb0: 6d62 6572 732c 2066 6561 7475 7265 732c  mbers, features,
+00015fc0: 0a20 2020 2020 2020 2020 6461 7461 5f70  .         data_p
+00015fd0: 6f69 6e74 735d 203d 2066 696c 6568 616e  oints] = filehan
+00015fe0: 646c 650a 0a20 2020 2020 2020 2069 6620  dle..        if 
+00015ff0: 6669 6c65 6861 6e64 6c65 2069 7320 6e6f  filehandle is no
+00016000: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+00016010: 2020 2020 745f 6669 7273 7420 3d20 7469      t_first = ti
+00016020: 6d65 7374 616d 7073 5b30 5d20 2023 2069  mestamps[0]  # i
+00016030: 6e20 6d69 6372 6f73 6563 6f6e 6473 0a20  n microseconds. 
+00016040: 2020 2020 2020 2020 2020 2074 5f6c 6173             t_las
+00016050: 7420 3d20 7469 6d65 7374 616d 7073 5b2d  t = timestamps[-
+00016060: 315d 2020 2320 696e 206d 6963 726f 7365  1]  # in microse
+00016070: 636f 6e64 730a 2020 2020 2020 2020 2020  conds.          
+00016080: 2020 6368 616e 6e65 6c5f 6964 203d 2063    channel_id = c
+00016090: 6861 6e6e 656c 5f69 6473 5b30 5d0a 2020  hannel_ids[0].  
+000160a0: 2020 2020 2020 2020 2020 6365 6c6c 5f63            cell_c
+000160b0: 6f75 6e74 203d 2063 656c 6c5f 6e75 6d62  ount = cell_numb
+000160c0: 6572 735b 305d 2020 2320 6e75 6d62 6572  ers[0]  # number
+000160d0: 206f 6620 6365 6c6c 7320 6964 656e 7469   of cells identi
+000160e0: 6669 6564 0a20 2020 2020 2020 2020 2020  fied.           
+000160f0: 2023 2073 7069 6b65 5f70 6172 616d 6574   # spike_paramet
+00016100: 6572 7320 3d20 6669 6c65 6861 6e64 6c65  ers = filehandle
+00016110: 5b30 5d5b 335d 0a20 2020 2020 2020 2020  [0][3].         
+00016120: 2020 2023 2065 6c73 653a 0a20 2020 2020     # else:.     
+00016130: 2020 2020 2020 2023 2020 2020 2074 5f66         #     t_f
+00016140: 6972 7374 203d 204e 6f6e 650a 2020 2020  irst = None.    
+00016150: 2020 2020 2020 2020 2320 2020 2020 6368          #     ch
+00016160: 616e 6e65 6c5f 6964 203d 204e 6f6e 650a  annel_id = None.
+00016170: 2020 2020 2020 2020 2020 2020 2320 2020              #   
+00016180: 2020 6365 6c6c 5f63 6f75 6e74 203d 2030    cell_count = 0
+00016190: 0a20 2020 2020 2020 2020 2020 2023 2020  .            #  
+000161a0: 2020 2023 2073 7069 6b65 5f70 6172 616d     # spike_param
+000161b0: 6574 6572 7320 3d20 204e 6f6e 650a 2020  eters =  None.  
+000161c0: 2020 2020 2020 2020 2020 230a 2020 2020            #.    
+000161d0: 2020 2020 2020 2020 2320 2020 2020 7365          #     se
+000161e0: 6c66 2e5f 6469 6167 6e6f 7374 6963 5f70  lf._diagnostic_p
+000161f0: 7269 6e74 2827 456d 7074 7920 6669 6c65  rint('Empty file
+00016200: 3a20 4e6f 2069 6e66 6f72 6d61 7469 6f6e  : No information
+00016210: 0a20 2020 2020 2020 2020 2020 2023 2063  .            # c
+00016220: 6f6e 7461 696e 6564 2069 6e20 2573 2725  ontained in %s'%
+00016230: 6669 6c65 6e61 6d65 290a 0a20 2020 2020  filename)..     
+00016240: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
+00016250: 6d65 7465 7273 5f6e 7474 5b63 6861 6e6e  meters_ntt[chann
+00016260: 656c 5f69 645d 203d 207b 2766 696c 656e  el_id] = {'filen
+00016270: 616d 6527 3a20 6669 6c65 6e61 6d65 2c0a  ame': filename,.
+00016280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000162a0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+000162b0: 745f 6669 7273 7427 3a20 745f 6669 7273  t_first': t_firs
+000162c0: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+000162d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000162e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000162f0: 2020 2020 2020 2020 2020 2020 2a20 7365              * se
+00016300: 6c66 2e6e 7474 5f74 696d 655f 756e 6974  lf.ntt_time_unit
+00016310: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00016320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016340: 2027 745f 6c61 7374 273a 2074 5f6c 6173   't_last': t_las
+00016350: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+00016360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016380: 2020 2020 2020 2020 2020 202a 2073 656c             * sel
+00016390: 662e 6e73 655f 7469 6d65 5f75 6e69 742c  f.nse_time_unit,
+000163a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000163b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000163c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000163d0: 2763 656c 6c5f 636f 756e 7427 3a20 6365  'cell_count': ce
+000163e0: 6c6c 5f63 6f75 6e74 7d0a 0a20 2020 2064  ll_count}..    d
+000163f0: 6566 205f 5f72 6561 645f 6e65 765f 6461  ef __read_nev_da
+00016400: 7461 5f68 6561 6465 7228 7365 6c66 2c20  ta_header(self, 
+00016410: 6669 6c65 6861 6e64 6c65 2c20 6669 6c65  filehandle, file
+00016420: 6e61 6d65 293a 0a20 2020 2020 2020 2027  name):.        '
+00016430: 2727 0a20 2020 2020 2020 2052 6561 6473  ''.        Reads
+00016440: 2074 6865 202e 6e65 7620 6461 7461 2062   the .nev data b
+00016450: 6c6f 636b 2068 6561 6465 7273 2061 6e64  lock headers and
+00016460: 2073 746f 7265 7320 7468 6520 7265 6c65   stores the rele
+00016470: 7661 6e74 2069 6e66 6f72 6d61 7469 6f6e  vant information
+00016480: 0a20 2020 2020 2020 2069 6e20 7468 650a  .        in the.
+00016490: 2020 2020 2020 2020 6f62 6a65 6374 2773          object's
+000164a0: 2070 6172 616d 6574 6572 735f 6e65 7620   parameters_nev 
+000164b0: 6469 6374 696f 6e61 7279 2e0a 0a20 2020  dictionary...   
+000164c0: 2020 2020 2041 7267 733a 0a20 2020 2020       Args:.     
+000164d0: 2020 2020 2020 2066 696c 6568 616e 646c         filehandl
+000164e0: 6520 2866 696c 6520 6f62 6a65 6374 293a  e (file object):
+000164f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016500: 2048 616e 646c 6520 746f 2074 6865 2061   Handle to the a
+00016510: 6c72 6561 6479 206f 7065 6e65 6420 2e6e  lready opened .n
+00016520: 6576 2066 696c 652e 0a20 2020 2020 2020  ev file..       
+00016530: 2020 2020 2066 696c 656e 616d 6520 2873       filename (s
+00016540: 7472 696e 6729 3a0a 2020 2020 2020 2020  tring):.        
+00016550: 2020 2020 2020 2020 4e61 6d65 206f 6620          Name of 
+00016560: 7468 6520 6e65 7620 6669 6c65 2e0a 2020  the nev file..  
+00016570: 2020 2020 2020 5265 7475 726e 733a 0a20        Returns:. 
+00016580: 2020 2020 2020 2020 2020 202d 0a20 2020             -.   
+00016590: 2020 2020 2027 2727 0a0a 2020 2020 2020       '''..      
+000165a0: 2020 2320 4578 7472 6163 7469 6e67 2062    # Extracting b
+000165b0: 6173 6963 2072 6563 6f72 6469 6e67 2065  asic recording e
+000165c0: 7665 6e74 7320 746f 2062 6520 6162 6c65  vents to be able
+000165d0: 2074 6f20 6368 6563 6b20 7265 636f 7264   to check record
+000165e0: 696e 670a 2020 2020 2020 2020 2320 636f  ing.        # co
+000165f0: 6e73 6973 7465 6e63 790a 2020 2020 2020  nsistency.      
+00016600: 2020 6966 2066 696c 656e 616d 6520 696e    if filename in
+00016610: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
+00016620: 5f6e 6576 3a0a 2020 2020 2020 2020 2020  _nev:.          
+00016630: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
+00016640: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
+00016650: 2020 2020 2744 6574 6563 7465 6420 6d75      'Detected mu
+00016660: 6c74 6970 6c65 206e 6576 2066 696c 6573  ltiple nev files
+00016670: 206f 6620 6e61 6d65 2025 732e 2720 2520   of name %s.' % 
+00016680: 2866 696c 656e 616d 6529 290a 2020 2020  (filename)).    
+00016690: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+000166a0: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
+000166b0: 6574 6572 735f 6e65 765b 6669 6c65 6e61  eters_nev[filena
+000166c0: 6d65 5d20 3d20 7b7d 0a20 2020 2020 2020  me] = {}.       
+000166d0: 2020 2020 2069 6620 2753 7461 7274 696e       if 'Startin
+000166e0: 675f 5265 636f 7264 696e 6727 2069 6e20  g_Recording' in 
+000166f0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
+00016700: 6e65 765b 6669 6c65 6e61 6d65 5d3a 0a20  nev[filename]:. 
+00016710: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00016720: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+00016730: 2754 7279 696e 6720 746f 2072 6561 6420  'Trying to read 
+00016740: 7365 636f 6e64 206e 6576 2066 696c 6520  second nev file 
+00016750: 6f66 206e 616d 6520 2573 2e20 270a 2020  of name %s. '.  
+00016760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016770: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00016780: 204f 6e6c 7920 6f6e 6520 6361 6e20 6265   Only one can be
+00016790: 2068 616e 646c 6564 2e27 2025 2066 696c   handled.' % fil
+000167a0: 656e 616d 6529 0a20 2020 2020 2020 2020  ename).         
+000167b0: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
+000167c0: 7273 5f6e 6576 5b66 696c 656e 616d 655d  rs_nev[filename]
+000167d0: 5b27 5374 6172 7469 6e67 5f52 6563 6f72  ['Starting_Recor
+000167e0: 6469 6e67 275d 203d 205b 5d0a 2020 2020  ding'] = [].    
+000167f0: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00016800: 616d 6574 6572 735f 6e65 765b 6669 6c65  ameters_nev[file
+00016810: 6e61 6d65 5d5b 2765 7665 6e74 7327 5d20  name]['events'] 
+00016820: 3d20 5b5d 0a20 2020 2020 2020 2020 2020  = [].           
+00016830: 2066 6f72 2065 7665 6e74 2069 6e20 6669   for event in fi
+00016840: 6c65 6861 6e64 6c65 3a0a 2020 2020 2020  lehandle:.      
+00016850: 2020 2020 2020 2020 2020 2320 7365 7061            # sepa
+00016860: 7261 7465 6c79 2065 7874 7261 6374 696e  rately extractin
+00016870: 6720 2753 7461 7274 696e 6720 5265 636f  g 'Starting Reco
+00016880: 7264 696e 6727 0a20 2020 2020 2020 2020  rding'.         
+00016890: 2020 2020 2020 2069 6620 2828 6576 656e         if ((even
+000168a0: 745b 345d 2069 6e20 5b31 312c 2031 395d  t[4] in [11, 19]
+000168b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000168c0: 2020 2020 2020 2020 2020 616e 6420 2865            and (e
+000168d0: 7665 6e74 5b31 305d 2e64 6563 6f64 6528  vent[10].decode(
+000168e0: 276c 6174 696e 2d31 2729 203d 3d20 2753  'latin-1') == 'S
+000168f0: 7461 7274 696e 6720 5265 636f 7264 696e  tarting Recordin
+00016900: 6727 2929 3a0a 2020 2020 2020 2020 2020  g')):.          
+00016910: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+00016920: 6172 616d 6574 6572 735f 6e65 765b 6669  arameters_nev[fi
+00016930: 6c65 6e61 6d65 5d5b 2753 7461 7274 696e  lename]['Startin
+00016940: 675f 5265 636f 7264 696e 6727 5d2e 6170  g_Recording'].ap
+00016950: 7065 6e64 280a 2020 2020 2020 2020 2020  pend(.          
+00016960: 2020 2020 2020 2020 2020 2020 2020 6576                ev
+00016970: 656e 745b 335d 202a 2073 656c 662e 6e65  ent[3] * self.ne
+00016980: 765f 7469 6d65 5f75 6e69 7429 0a0a 2020  v_time_unit)..  
+00016990: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+000169a0: 6164 6469 6e67 2061 6c6c 2065 7665 6e74  adding all event
+000169b0: 7320 746f 2070 6172 616d 6574 6572 2063  s to parameter c
+000169c0: 6f6c 6c65 6374 696f 6e0a 2020 2020 2020  ollection.      
+000169d0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+000169e0: 6172 616d 6574 6572 735f 6e65 765b 6669  arameters_nev[fi
+000169f0: 6c65 6e61 6d65 5d5b 2765 7665 6e74 7327  lename]['events'
+00016a00: 5d2e 6170 7065 6e64 280a 2020 2020 2020  ].append(.      
+00016a10: 2020 2020 2020 2020 2020 2020 2020 7b27                {'
+00016a20: 7469 6d65 7374 616d 7027 3a20 6576 656e  timestamp': even
+00016a30: 745b 335d 202a 2073 656c 662e 6e65 765f  t[3] * self.nev_
+00016a40: 7469 6d65 5f75 6e69 742c 0a20 2020 2020  time_unit,.     
+00016a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016a60: 2765 7665 6e74 5f69 6427 3a20 6576 656e  'event_id': even
+00016a70: 745b 345d 2c0a 2020 2020 2020 2020 2020  t[4],.          
+00016a80: 2020 2020 2020 2020 2020 2027 6e74 746c             'nttl
+00016a90: 273a 2065 7665 6e74 5b35 5d2c 0a20 2020  ': event[5],.   
+00016aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016ab0: 2020 276e 616d 6527 3a20 6576 656e 745b    'name': event[
+00016ac0: 3130 5d2e 6465 636f 6465 2827 6c61 7469  10].decode('lati
+00016ad0: 6e2d 3127 297d 290a 0a20 2020 2020 2020  n-1')})..       
+00016ae0: 2020 2020 2069 6620 6c65 6e28 7365 6c66       if len(self
+00016af0: 2e70 6172 616d 6574 6572 735f 6e65 765b  .parameters_nev[
+00016b00: 6669 6c65 6e61 6d65 5d5b 2753 7461 7274  filename]['Start
+00016b10: 696e 675f 5265 636f 7264 696e 6727 5d29  ing_Recording'])
+00016b20: 203c 2031 3a0a 2020 2020 2020 2020 2020   < 1:.          
+00016b30: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00016b40: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
+00016b50: 2020 2020 2020 2020 2020 2020 274e 6f20              'No 
+00016b60: 4576 656e 7420 2253 7461 7274 696e 675f  Event "Starting_
+00016b70: 5265 636f 7264 696e 6722 2064 6574 6563  Recording" detec
+00016b80: 7465 6420 696e 2025 7327 2025 2028 0a20  ted in %s' % (. 
+00016b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016ba0: 2020 2020 2020 2066 696c 656e 616d 6529         filename)
+00016bb0: 290a 0a20 2020 2020 2020 2020 2020 2073  )..            s
+00016bc0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+00016bd0: 6576 5b66 696c 656e 616d 655d 5b27 745f  ev[filename]['t_
+00016be0: 7374 6172 7427 5d20 3d20 6d69 6e28 0a20  start'] = min(. 
+00016bf0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00016c00: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
+00016c10: 6576 5b66 696c 656e 616d 655d 5b27 5374  ev[filename]['St
+00016c20: 6172 7469 6e67 5f52 6563 6f72 6469 6e67  arting_Recording
+00016c30: 275d 290a 2020 2020 2020 2020 2020 2020  ']).            
+00016c40: 2320 745f 7374 6f70 203d 2074 696d 6520  # t_stop = time 
+00016c50: 7374 616d 7020 6f66 206c 6173 7420 6576  stamp of last ev
+00016c60: 656e 7420 696e 2066 696c 650a 2020 2020  ent in file.    
+00016c70: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
+00016c80: 616d 6574 6572 735f 6e65 765b 6669 6c65  ameters_nev[file
+00016c90: 6e61 6d65 5d5b 2774 5f73 746f 7027 5d20  name]['t_stop'] 
+00016ca0: 3d20 6d61 7828 0a20 2020 2020 2020 2020  = max(.         
+00016cb0: 2020 2020 2020 205b 655b 2774 696d 6573         [e['times
+00016cc0: 7461 6d70 275d 2066 6f72 2065 2069 6e0a  tamp'] for e in.
+00016cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016ce0: 2073 656c 662e 7061 7261 6d65 7465 7273   self.parameters
+00016cf0: 5f6e 6576 5b66 696c 656e 616d 655d 5b27  _nev[filename]['
+00016d00: 6576 656e 7473 275d 5d29 0a0a 2020 2020  events']])..    
+00016d10: 2020 2020 2020 2020 2320 6578 7472 6163          # extrac
+00016d20: 7420 616c 6c20 6f63 6375 7272 696e 6720  t all occurring 
+00016d30: 6576 656e 7420 7479 7065 7320 283d 2063  event types (= c
+00016d40: 6f6d 6269 6e61 7469 6f6e 206f 6620 6e74  ombination of nt
+00016d50: 746c 2c0a 2020 2020 2020 2020 2020 2020  tl,.            
+00016d60: 2320 6576 656e 745f 6964 2061 6e64 206e  # event_id and n
+00016d70: 616d 652f 7374 7269 6e67 290a 2020 2020  ame/string).    
+00016d80: 2020 2020 2020 2020 6576 656e 745f 7479          event_ty
+00016d90: 7065 7320 3d20 636f 7079 2e64 6565 7063  pes = copy.deepc
+00016da0: 6f70 7928 7365 6c66 2e70 6172 616d 6574  opy(self.paramet
+00016db0: 6572 735f 6e65 765b 6669 6c65 6e61 6d65  ers_nev[filename
+00016dc0: 5d5b 2765 7665 6e74 7327 5d29 0a20 2020  ]['events']).   
+00016dd0: 2020 2020 2020 2020 2066 6f72 2064 2069           for d i
+00016de0: 6e20 6576 656e 745f 7479 7065 733a 0a20  n event_types:. 
+00016df0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00016e00: 2e70 6f70 2827 7469 6d65 7374 616d 7027  .pop('timestamp'
+00016e10: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+00016e20: 6c66 2e70 6172 616d 6574 6572 735f 6e65  lf.parameters_ne
+00016e30: 765b 6669 6c65 6e61 6d65 5d5b 2765 7665  v[filename]['eve
+00016e40: 6e74 5f74 7970 6573 275d 203d 205b 6469  nt_types'] = [di
+00016e50: 6374 2879 2920 666f 7220 7920 696e 0a20  ct(y) for y in. 
+00016e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016e90: 2020 2020 2020 2020 2020 207b 7475 706c             {tupl
+00016ea0: 6528 0a20 2020 2020 2020 2020 2020 2020  e(.             
 00016eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ec0: 2020 2020 2020 2020 7b74 7570 6c65 280a          {tuple(.
+00016ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00016ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016ee0: 2020 2078 2e69 7465 6d73 2829 290a 2020     x.items()).  
 00016ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 00016f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f10: 782e 6974 656d 7328 2929 0a20 2020 2020  x.items()).     
-00016f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f20: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00016f30: 7220 7820 696e 0a20 2020 2020 2020 2020  r x in.         
 00016f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f50: 2020 2020 2020 2020 2020 2066 6f72 2078             for x
-00016f60: 2069 6e0a 2020 2020 2020 2020 2020 2020   in.            
-00016f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016fa0: 2020 2020 6576 656e 745f 7479 7065 737d      event_types}
-00016fb0: 5d0a 0a20 2020 2023 205f 5f5f 5f5f 5f5f  ]..    # _______
-00016fc0: 5f5f 5f5f 5f5f 5f5f 5f20 4669 6c65 2043  _________ File C
-00016fd0: 6865 636b 7320 5f5f 5f5f 5f5f 5f5f 5f5f  hecks __________
-00016fe0: 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f  ________________
-00016ff0: 5f5f 5f5f 5f5f 5f5f 0a0a 2020 2020 6465  ________..    de
-00017000: 6620 5f5f 6e63 735f 7061 636b 6574 5f63  f __ncs_packet_c
-00017010: 6865 636b 2873 656c 662c 2066 696c 6568  heck(self, fileh
-00017020: 616e 646c 6529 3a0a 2020 2020 2020 2020  andle):.        
-00017030: 2727 270a 2020 2020 2020 2020 4368 6563  '''.        Chec
-00017040: 6b73 2063 6f6e 7369 7374 656e 6379 206f  ks consistency o
-00017050: 6620 6461 7461 2069 6e20 6e63 7320 6669  f data in ncs fi
-00017060: 6c65 2061 6e64 2072 6169 7365 7320 6173  le and raises as
-00017070: 7365 7274 696f 6e20 6572 726f 7220 6966  sertion error if
-00017080: 2061 0a20 2020 2020 2020 2063 6865 636b   a.        check
-00017090: 2066 6169 6c73 2e20 4465 7465 6374 6564   fails. Detected
-000170a0: 2072 6563 6f72 6469 6e67 2067 6170 7320   recording gaps 
-000170b0: 6172 6520 6164 6465 6420 746f 2070 6172  are added to par
-000170c0: 616d 6574 6572 5f6e 6373 0a0a 2020 2020  ameter_ncs..    
-000170d0: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
-000170e0: 2020 2020 2020 6669 6c65 6861 6e64 6c65        filehandle
-000170f0: 2028 6669 6c65 206f 626a 6563 7429 3a0a   (file object):.
-00017100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017110: 4861 6e64 6c65 2074 6f20 7468 6520 616c  Handle to the al
-00017120: 7265 6164 7920 6f70 656e 6564 202e 6e63  ready opened .nc
-00017130: 7320 6669 6c65 2e0a 2020 2020 2020 2020  s file..        
-00017140: 2727 270a 0a20 2020 2020 2020 2074 696d  '''..        tim
-00017150: 6573 7461 6d70 7320 3d20 6669 6c65 6861  estamps = fileha
-00017160: 6e64 6c65 5b30 5d0a 2020 2020 2020 2020  ndle[0].        
-00017170: 6865 6164 6572 5f75 3420 3d20 6669 6c65  header_u4 = file
-00017180: 6861 6e64 6c65 5b31 5d0a 0a20 2020 2020  handle[1]..     
-00017190: 2020 2023 2063 6865 636b 696e 6720 7361     # checking sa
-000171a0: 6d70 6c69 6e67 2072 6174 6520 6f66 2064  mpling rate of d
-000171b0: 6174 6120 7061 636b 6574 730a 2020 2020  ata packets.    
-000171c0: 2020 2020 7372 3020 3d20 6865 6164 6572      sr0 = header
-000171d0: 5f75 345b 302c 2031 5d0a 2020 2020 2020  _u4[0, 1].      
-000171e0: 2020 6173 7365 7274 2061 6c6c 2868 6561    assert all(hea
-000171f0: 6465 725f 7534 5b3a 2c20 315d 203d 3d20  der_u4[:, 1] == 
-00017200: 7372 3029 0a0a 2020 2020 2020 2020 2320  sr0)..        # 
-00017210: 6368 6563 6b69 6e67 2063 6861 6e6e 656c  checking channel
-00017220: 2069 6420 6f66 2064 6174 6120 7061 636b   id of data pack
-00017230: 6574 730a 2020 2020 2020 2020 6368 616e  ets.        chan
-00017240: 6e65 6c5f 6964 203d 2068 6561 6465 725f  nel_id = header_
-00017250: 7534 5b30 2c20 305d 0a20 2020 2020 2020  u4[0, 0].       
-00017260: 2061 7373 6572 7420 616c 6c28 6865 6164   assert all(head
-00017270: 6572 5f75 345b 3a2c 2030 5d20 3d3d 2063  er_u4[:, 0] == c
-00017280: 6861 6e6e 656c 5f69 6429 0a0a 2020 2020  hannel_id)..    
-00017290: 2020 2020 2320 7469 6d65 206f 6666 7365      # time offse
-000172a0: 7420 6f66 2064 6174 6120 7061 636b 6574  t of data packet
-000172b0: 730a 2020 2020 2020 2020 2320 544f 444f  s.        # TODO
-000172c0: 3a20 4368 6563 6b20 6966 2074 6865 7265  : Check if there
-000172d0: 2069 7320 6120 7361 6665 7220 7761 7920   is a safer way 
-000172e0: 746f 2064 6f20 7468 6520 6465 6c74 615f  to do the delta_
-000172f0: 7420 6368 6563 6b20 666f 7220 6e63 730a  t check for ncs.
-00017300: 2020 2020 2020 2020 2320 2064 6174 6120          #  data 
-00017310: 7061 636b 6574 730a 2020 2020 2020 2020  packets.        
-00017320: 2320 7468 6973 2069 7320 6120 6e6f 7420  # this is a not 
-00017330: 7361 6665 2061 7373 756d 7074 696f 6e2c  safe assumption,
-00017340: 2074 6861 7420 7468 6520 6669 7273 7420   that the first 
-00017350: 7477 6f20 6461 7461 2070 6163 6b65 7473  two data packets
-00017360: 2068 6176 650a 2020 2020 2020 2020 2320   have.        # 
-00017370: 2063 6f72 7265 6374 2074 696d 6520 7374   correct time st
-00017380: 616d 7073 0a20 2020 2020 2020 2064 656c  amps.        del
-00017390: 7461 5f74 203d 2074 696d 6573 7461 6d70  ta_t = timestamp
-000173a0: 735b 315d 202d 2074 696d 6573 7461 6d70  s[1] - timestamp
-000173b0: 735b 305d 0a0a 2020 2020 2020 2020 2320  s[0]..        # 
-000173c0: 7661 6c69 6420 7361 6d70 6c65 7320 6f66  valid samples of
-000173d0: 2066 6972 7374 2064 6174 6120 7061 636b   first data pack
-000173e0: 6574 0a20 2020 2020 2020 2074 656d 705f  et.        temp_
-000173f0: 7661 6c69 645f 7361 6d70 6c65 7320 3d20  valid_samples = 
-00017400: 6865 6164 6572 5f75 345b 302c 2032 5d0a  header_u4[0, 2].
-00017410: 0a20 2020 2020 2020 2023 2075 6e69 7420  .        # unit 
-00017420: 7465 7374 0a20 2020 2020 2020 2023 2074  test.        # t
-00017430: 696d 6520 6469 6666 6572 656e 6365 2062  ime difference b
-00017440: 6574 7765 656e 2070 6163 6b65 7473 2063  etween packets c
-00017450: 6f72 7265 7370 6f6e 6473 2074 6f20 6e75  orresponds to nu
-00017460: 6d62 6572 206f 6620 7265 636f 7264 6564  mber of recorded
-00017470: 0a20 2020 2020 2020 2023 2073 616d 706c  .        # sampl
-00017480: 6573 0a20 2020 2020 2020 2061 7373 6572  es.        asser
-00017490: 7420 6465 6c74 615f 7420 3d3d 2028 0a20  t delta_t == (. 
-000174a0: 2020 2020 2020 2020 2020 2074 656d 705f             temp_
-000174b0: 7661 6c69 645f 7361 6d70 6c65 7320 2f20  valid_samples / 
-000174c0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000174d0: 2020 7365 6c66 2e6e 6373 5f74 696d 655f    self.ncs_time_
-000174e0: 756e 6974 2e72 6573 6361 6c65 2870 712e  unit.rescale(pq.
-000174f0: 7329 2e6d 6167 6e69 7475 6465 202a 2073  s).magnitude * s
-00017500: 7230 2929 0a0a 2020 2020 2020 2020 7365  r0))..        se
-00017510: 6c66 2e5f 6469 6167 6e6f 7374 6963 5f70  lf._diagnostic_p
-00017520: 7269 6e74 2827 4e43 5320 7061 636b 6574  rint('NCS packet
-00017530: 2063 6865 636b 2073 7563 6365 7373 6675   check successfu
-00017540: 6c2e 2729 0a0a 2020 2020 6465 6620 5f5f  l.')..    def __
-00017550: 6e73 655f 6368 6563 6b28 7365 6c66 2c20  nse_check(self, 
-00017560: 6669 6c65 6861 6e64 6c65 293a 0a20 2020  filehandle):.   
-00017570: 2020 2020 2027 2727 0a20 2020 2020 2020       '''.       
-00017580: 2043 6865 636b 7320 636f 6e73 6973 7465   Checks consiste
-00017590: 6e63 7920 6f66 2064 6174 6120 696e 206e  ncy of data in n
-000175a0: 6373 2066 696c 6520 616e 6420 7261 6973  cs file and rais
-000175b0: 6573 2061 7373 6572 7469 6f6e 2065 7272  es assertion err
-000175c0: 6f72 2069 6620 610a 2020 2020 2020 2020  or if a.        
-000175d0: 6368 6563 6b20 6661 696c 732e 0a0a 2020  check fails...  
-000175e0: 2020 2020 2020 4172 6773 3a0a 2020 2020        Args:.    
-000175f0: 2020 2020 2020 2020 6669 6c65 6861 6e64          filehand
-00017600: 6c65 2028 6669 6c65 206f 626a 6563 7429  le (file object)
-00017610: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00017620: 2020 4861 6e64 6c65 2074 6f20 7468 6520    Handle to the 
-00017630: 616c 7265 6164 7920 6f70 656e 6564 202e  already opened .
-00017640: 6e73 6520 6669 6c65 2e0a 2020 2020 2020  nse file..      
-00017650: 2020 2727 270a 0a20 2020 2020 2020 205b    '''..        [
-00017660: 7469 6d65 7374 616d 7073 2c20 6368 616e  timestamps, chan
-00017670: 6e65 6c5f 6964 732c 2063 656c 6c5f 6e75  nel_ids, cell_nu
-00017680: 6d62 6572 732c 2066 6561 7475 7265 732c  mbers, features,
-00017690: 0a20 2020 2020 2020 2020 6461 7461 5f70  .         data_p
-000176a0: 6f69 6e74 735d 203d 2066 696c 6568 616e  oints] = filehan
-000176b0: 646c 650a 0a20 2020 2020 2020 2061 7373  dle..        ass
-000176c0: 6572 7420 616c 6c28 6368 616e 6e65 6c5f  ert all(channel_
-000176d0: 6964 7320 3d3d 2063 6861 6e6e 656c 5f69  ids == channel_i
-000176e0: 6473 5b30 5d29 0a0a 2020 2020 2020 2020  ds[0])..        
-000176f0: 6173 7365 7274 2061 6c6c 285b 6c65 6e28  assert all([len(
-00017700: 6470 2920 3d3d 206c 656e 2864 6174 615f  dp) == len(data_
-00017710: 706f 696e 7473 5b30 5d29 2066 6f72 2064  points[0]) for d
-00017720: 7020 696e 2064 6174 615f 706f 696e 7473  p in data_points
-00017730: 5d29 0a0a 2020 2020 2020 2020 7365 6c66  ])..        self
-00017740: 2e5f 6469 6167 6e6f 7374 6963 5f70 7269  ._diagnostic_pri
-00017750: 6e74 2827 4e53 4520 6669 6c65 2063 6865  nt('NSE file che
-00017760: 636b 2073 7563 6365 7373 6675 6c2e 2729  ck successful.')
-00017770: 0a0a 2020 2020 6465 6620 5f5f 6e65 765f  ..    def __nev_
-00017780: 6368 6563 6b28 7365 6c66 2c20 6669 6c65  check(self, file
-00017790: 6861 6e64 6c65 293a 0a20 2020 2020 2020  handle):.       
-000177a0: 2027 2727 0a20 2020 2020 2020 2043 6865   '''.        Che
-000177b0: 636b 7320 636f 6e73 6973 7465 6e63 7920  cks consistency 
-000177c0: 6f66 2064 6174 6120 696e 206e 6576 2066  of data in nev f
-000177d0: 696c 6520 616e 6420 7261 6973 6573 2061  ile and raises a
-000177e0: 7373 6572 7469 6f6e 2065 7272 6f72 2069  ssertion error i
-000177f0: 6620 610a 2020 2020 2020 2020 6368 6563  f a.        chec
-00017800: 6b20 6661 696c 732e 0a0a 2020 2020 2020  k fails...      
-00017810: 2020 4172 6773 3a0a 2020 2020 2020 2020    Args:.        
-00017820: 2020 2020 6669 6c65 6861 6e64 6c65 2028      filehandle (
-00017830: 6669 6c65 206f 626a 6563 7429 3a0a 2020  file object):.  
-00017840: 2020 2020 2020 2020 2020 2020 2020 4861                Ha
-00017850: 6e64 6c65 2074 6f20 7468 6520 616c 7265  ndle to the alre
-00017860: 6164 7920 6f70 656e 6564 202e 6e65 7620  ady opened .nev 
-00017870: 6669 6c65 2e0a 2020 2020 2020 2020 2727  file..        ''
-00017880: 270a 0a20 2020 2020 2020 2023 2074 6869  '..        # thi
-00017890: 7320 656e 7472 7920 7368 6f75 6c64 2061  s entry should a
-000178a0: 6c77 6179 7320 6571 7561 6c20 3220 2873  lways equal 2 (s
-000178b0: 6565 204e 6575 7261 6c79 6e78 2046 696c  ee Neuralynx Fil
-000178c0: 6520 4465 7363 7269 7074 696f 6e29 2c0a  e Description),.
-000178d0: 2020 2020 2020 2020 2320 6275 7420 6974          # but it
-000178e0: 2069 7320 6e6f 742e 2046 6f72 206d 652c   is not. For me,
-000178f0: 2074 6869 7320 6973 2030 2e0a 2020 2020   this is 0..    
-00017900: 2020 2020 6173 7365 7274 2061 6c6c 285b      assert all([
-00017910: 665b 325d 203d 3d20 3220 6f72 2066 5b32  f[2] == 2 or f[2
-00017920: 5d20 3d3d 2030 2066 6f72 2066 2069 6e20  ] == 0 for f in 
-00017930: 6669 6c65 6861 6e64 6c65 5d29 0a0a 2020  filehandle])..  
-00017940: 2020 2020 2020 2320 544f 444f 3a20 6368        # TODO: ch
-00017950: 6563 6b20 7769 7468 206d 6f72 6520 6e65  eck with more ne
-00017960: 7620 6669 6c65 732c 2069 6620 696e 6465  v files, if inde
-00017970: 7820 302c 312c 322c 362c 372c 3820 616e  x 0,1,2,6,7,8 an
-00017980: 6420 3920 6361 6e20 6265 0a20 2020 2020  d 9 can be.     
-00017990: 2020 2023 206e 6f6e 2d7a 6572 6f2e 2049     # non-zero. I
-000179a0: 6e74 6572 7072 6574 6174 696f 6e3f 2049  nterpretation? I
-000179b0: 6e63 6c75 6465 2069 6e20 6576 656e 7420  nclude in event 
-000179c0: 6578 7472 6163 7469 6f6e 2e0a 2020 2020  extraction..    
-000179d0: 2020 2020 2320 6f6e 6c79 206f 6273 6572      # only obser
-000179e0: 7665 6420 3020 666f 7220 696e 6465 7820  ved 0 for index 
-000179f0: 302c 312c 322c 362c 372c 382c 3920 696e  0,1,2,6,7,8,9 in
-00017a00: 206e 6576 2066 696c 6573 2e0a 2020 2020   nev files..    
-00017a10: 2020 2020 2320 4966 2074 6865 7920 6172      # If they ar
-00017a20: 6520 6e6f 6e2d 7a65 726f 2c20 7468 6973  e non-zero, this
-00017a30: 206e 6565 6473 2074 6f20 6265 2069 6e63   needs to be inc
-00017a40: 6c75 6465 6420 696e 2065 7665 6e74 2065  luded in event e
-00017a50: 7874 7261 6374 696f 6e0a 2020 2020 2020  xtraction.      
-00017a60: 2020 6173 7365 7274 2061 6c6c 285b 665b    assert all([f[
-00017a70: 305d 203d 3d20 3020 666f 7220 6620 696e  0] == 0 for f in
-00017a80: 2066 696c 6568 616e 646c 655d 290a 2020   filehandle]).  
-00017a90: 2020 2020 2020 6173 7365 7274 2061 6c6c        assert all
-00017aa0: 285b 665b 315d 203d 3d20 3020 666f 7220  ([f[1] == 0 for 
-00017ab0: 6620 696e 2066 696c 6568 616e 646c 655d  f in filehandle]
-00017ac0: 290a 2020 2020 2020 2020 6173 7365 7274  ).        assert
-00017ad0: 2061 6c6c 285b 665b 325d 2069 6e20 5b30   all([f[2] in [0
-00017ae0: 2c20 325d 2066 6f72 2066 2069 6e20 6669  , 2] for f in fi
-00017af0: 6c65 6861 6e64 6c65 5d29 0a0a 2020 2020  lehandle])..    
-00017b00: 2020 2020 6173 7365 7274 2061 6c6c 285b      assert all([
-00017b10: 665b 365d 203d 3d20 3020 666f 7220 6620  f[6] == 0 for f 
-00017b20: 696e 2066 696c 6568 616e 646c 655d 290a  in filehandle]).
-00017b30: 2020 2020 2020 2020 6173 7365 7274 2061          assert a
-00017b40: 6c6c 285b 665b 375d 203d 3d20 3020 666f  ll([f[7] == 0 fo
-00017b50: 7220 6620 696e 2066 696c 6568 616e 646c  r f in filehandl
-00017b60: 655d 290a 2020 2020 2020 2020 6173 7365  e]).        asse
-00017b70: 7274 2061 6c6c 285b 665b 385d 203d 3d20  rt all([f[8] == 
-00017b80: 3020 666f 7220 6620 696e 2066 696c 6568  0 for f in fileh
-00017b90: 616e 646c 655d 290a 2020 2020 2020 2020  andle]).        
-00017ba0: 6173 7365 7274 2061 6c6c 285b 616c 6c28  assert all([all(
-00017bb0: 665b 395d 203d 3d20 3029 2066 6f72 2066  f[9] == 0) for f
-00017bc0: 2069 6e20 6669 6c65 6861 6e64 6c65 5d29   in filehandle])
-00017bd0: 0a0a 2020 2020 2020 2020 7365 6c66 2e5f  ..        self._
-00017be0: 6469 6167 6e6f 7374 6963 5f70 7269 6e74  diagnostic_print
-00017bf0: 2827 4e45 5620 6669 6c65 2063 6865 636b  ('NEV file check
-00017c00: 2073 7563 6365 7373 6675 6c2e 2729 0a0a   successful.')..
-00017c10: 2020 2020 6465 6620 5f5f 6e74 745f 6368      def __ntt_ch
-00017c20: 6563 6b28 7365 6c66 2c20 6669 6c65 6861  eck(self, fileha
-00017c30: 6e64 6c65 293a 0a20 2020 2020 2020 2027  ndle):.        '
-00017c40: 2727 0a20 2020 2020 2020 2043 6865 636b  ''.        Check
-00017c50: 7320 636f 6e73 6973 7465 6e63 7920 6f66  s consistency of
-00017c60: 2064 6174 6120 696e 206e 6373 2066 696c   data in ncs fil
-00017c70: 6520 616e 6420 7261 6973 6573 2061 7373  e and raises ass
-00017c80: 6572 7469 6f6e 2065 7272 6f72 2069 6620  ertion error if 
-00017c90: 610a 2020 2020 2020 2020 6368 6563 6b20  a.        check 
-00017ca0: 6661 696c 732e 0a0a 2020 2020 2020 2020  fails...        
-00017cb0: 4172 6773 3a0a 2020 2020 2020 2020 2020  Args:.          
-00017cc0: 2020 6669 6c65 6861 6e64 6c65 2028 6669    filehandle (fi
-00017cd0: 6c65 206f 626a 6563 7429 3a0a 2020 2020  le object):.    
-00017ce0: 2020 2020 2020 2020 2020 2020 4861 6e64              Hand
-00017cf0: 6c65 2074 6f20 7468 6520 616c 7265 6164  le to the alread
-00017d00: 7920 6f70 656e 6564 202e 6e73 6520 6669  y opened .nse fi
-00017d10: 6c65 2e0a 2020 2020 2020 2020 2727 270a  le..        '''.
-00017d20: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
-00017d30: 6368 6563 6b20 7468 6973 2077 6865 6e20  check this when 
-00017d40: 6669 7273 7420 2e6e 7474 2066 696c 6573  first .ntt files
-00017d50: 2061 7265 2061 7661 696c 6162 6c65 0a20   are available. 
-00017d60: 2020 2020 2020 205b 7469 6d65 7374 616d         [timestam
-00017d70: 7073 2c20 6368 616e 6e65 6c5f 6964 732c  ps, channel_ids,
-00017d80: 2063 656c 6c5f 6e75 6d62 6572 732c 2066   cell_numbers, f
-00017d90: 6561 7475 7265 732c 0a20 2020 2020 2020  eatures,.       
-00017da0: 2020 6461 7461 5f70 6f69 6e74 735d 203d    data_points] =
-00017db0: 2066 696c 6568 616e 646c 650a 0a20 2020   filehandle..   
-00017dc0: 2020 2020 2061 7373 6572 7420 616c 6c28       assert all(
-00017dd0: 6368 616e 6e65 6c5f 6964 7320 3d3d 2063  channel_ids == c
-00017de0: 6861 6e6e 656c 5f69 6473 5b30 5d29 0a0a  hannel_ids[0])..
-00017df0: 2020 2020 2020 2020 6173 7365 7274 2061          assert a
-00017e00: 6c6c 285b 6c65 6e28 6470 2920 3d3d 206c  ll([len(dp) == l
-00017e10: 656e 2864 6174 615f 706f 696e 7473 5b30  en(data_points[0
-00017e20: 5d29 2066 6f72 2064 7020 696e 2064 6174  ]) for dp in dat
-00017e30: 615f 706f 696e 7473 5d29 0a0a 2020 2020  a_points])..    
-00017e40: 2020 2020 7365 6c66 2e5f 6469 6167 6e6f      self._diagno
-00017e50: 7374 6963 5f70 7269 6e74 2827 4e54 5420  stic_print('NTT 
-00017e60: 6669 6c65 2063 6865 636b 2073 7563 6365  file check succe
-00017e70: 7373 6675 6c2e 2729 0a0a 2020 2020 6465  ssful.')..    de
-00017e80: 6620 5f5f 6e63 735f 6761 705f 6368 6563  f __ncs_gap_chec
-00017e90: 6b28 7365 6c66 2c20 6669 6c65 6861 6e64  k(self, filehand
-00017ea0: 6c65 293a 0a20 2020 2020 2020 2027 2727  le):.        '''
-00017eb0: 0a20 2020 2020 2020 2043 6865 636b 7320  .        Checks 
-00017ec0: 696e 6469 7669 6475 616c 2064 6174 6120  individual data 
-00017ed0: 626c 6f63 6b73 206f 6620 6e63 7320 6669  blocks of ncs fi
-00017ee0: 6c65 7320 666f 7220 636f 6e73 6973 7465  les for consiste
-00017ef0: 6e74 2073 7461 7274 696e 670a 2020 2020  nt starting.    
-00017f00: 2020 2020 7469 6d65 7320 7769 7468 2072      times with r
-00017f10: 6573 7065 6374 2074 6f20 7361 6d70 6c65  espect to sample
-00017f20: 2063 6f75 6e74 2e0a 2020 2020 2020 2020   count..        
-00017f30: 5468 6973 2063 6f76 6572 7320 696e 7465  This covers inte
-00017f40: 6e64 6564 2072 6563 6f72 6469 6e67 2067  nded recording g
-00017f50: 6170 7320 6173 2077 656c 6c20 6173 2073  aps as well as s
-00017f60: 686f 7274 656e 6564 2064 6174 6120 7061  hortened data pa
-00017f70: 636b 6574 2c0a 2020 2020 2020 2020 7768  cket,.        wh
-00017f80: 6963 6820 6172 6520 696e 636f 6d70 6c65  ich are incomple
-00017f90: 7465 0a20 2020 2020 2020 2027 2727 0a0a  te.        '''..
-00017fa0: 2020 2020 2020 2020 7469 6d65 7374 616d          timestam
-00017fb0: 7073 203d 2066 696c 6568 616e 646c 655b  ps = filehandle[
-00017fc0: 305d 0a20 2020 2020 2020 2068 6561 6465  0].        heade
-00017fd0: 725f 7534 203d 2066 696c 6568 616e 646c  r_u4 = filehandl
-00017fe0: 655b 315d 0a20 2020 2020 2020 2063 6861  e[1].        cha
-00017ff0: 6e6e 656c 5f69 6420 3d20 6865 6164 6572  nnel_id = header
-00018000: 5f75 345b 302c 2030 5d0a 2020 2020 2020  _u4[0, 0].      
-00018010: 2020 6966 2063 6861 6e6e 656c 5f69 6420    if channel_id 
-00018020: 6e6f 7420 696e 2073 656c 662e 7061 7261  not in self.para
-00018030: 6d65 7465 7273 5f6e 6373 3a0a 2020 2020  meters_ncs:.    
-00018040: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-00018050: 616d 6574 6572 735f 6e63 735b 6368 616e  ameters_ncs[chan
-00018060: 6e65 6c5f 6964 5d20 3d20 7b7d 0a0a 2020  nel_id] = {}..  
-00018070: 2020 2020 2020 2320 7469 6d65 2073 7461        # time sta
-00018080: 6d70 7320 6f66 2064 6174 6120 7061 636b  mps of data pack
-00018090: 6574 730a 2020 2020 2020 2020 6465 6c74  ets.        delt
-000180a0: 615f 7420 3d20 7469 6d65 7374 616d 7073  a_t = timestamps
-000180b0: 5b31 5d20 2d20 7469 6d65 7374 616d 7073  [1] - timestamps
-000180c0: 5b30 5d20 2023 2069 6e20 6d69 6372 6f73  [0]  # in micros
-000180d0: 6563 0a20 2020 2020 2020 2064 6174 615f  ec.        data_
-000180e0: 7061 636b 6574 5f6f 6666 7365 7473 203d  packet_offsets =
-000180f0: 206e 702e 6469 6666 2874 696d 6573 7461   np.diff(timesta
-00018100: 6d70 7329 2020 2320 696e 206d 6963 726f  mps)  # in micro
-00018110: 7365 630a 0a20 2020 2020 2020 2023 2063  sec..        # c
-00018120: 6865 636b 2069 6620 6465 6c74 615f 7420  heck if delta_t 
-00018130: 636f 7272 6573 706f 6e64 7320 746f 206e  corresponds to n
-00018140: 756d 6265 7220 6f66 2076 616c 6964 2073  umber of valid s
-00018150: 616d 706c 6573 2070 7265 7365 6e74 2069  amples present i
-00018160: 6e0a 2020 2020 2020 2020 2320 6461 7461  n.        # data
-00018170: 2070 6163 6b65 7473 0a20 2020 2020 2020   packets.       
-00018180: 2023 204e 4f54 453a 2054 6869 7320 616c   # NOTE: This al
-00018190: 736f 2064 6574 6563 7473 2072 6563 6f72  so detects recor
-000181a0: 6469 6e67 2067 6170 7321 0a20 2020 2020  ding gaps!.     
-000181b0: 2020 2076 616c 6964 5f73 616d 706c 6573     valid_samples
-000181c0: 203d 2068 6561 6465 725f 7534 5b3a 2d31   = header_u4[:-1
-000181d0: 2c20 325d 0a20 2020 2020 2020 2073 616d  , 2].        sam
-000181e0: 706c 696e 675f 7261 7465 203d 2068 6561  pling_rate = hea
-000181f0: 6465 725f 7534 5b30 2c20 315d 0a20 2020  der_u4[0, 1].   
-00018200: 2020 2020 2070 6163 6b65 745f 6368 6563       packet_chec
-00018210: 6b73 203d 2028 7661 6c69 645f 7361 6d70  ks = (valid_samp
-00018220: 6c65 7320 2f20 2873 656c 662e 6e63 735f  les / (self.ncs_
-00018230: 7469 6d65 5f75 6e69 742e 7265 7363 616c  time_unit.rescal
-00018240: 6528 0a20 2020 2020 2020 2020 2020 2070  e(.            p
-00018250: 712e 7329 2e6d 6167 6e69 7475 6465 202a  q.s).magnitude *
-00018260: 2073 616d 706c 696e 675f 7261 7465 2929   sampling_rate))
-00018270: 203d 3d20 6461 7461 5f70 6163 6b65 745f   == data_packet_
-00018280: 6f66 6673 6574 730a 2020 2020 2020 2020  offsets.        
-00018290: 6966 206e 6f74 2061 6c6c 2870 6163 6b65  if not all(packe
-000182a0: 745f 6368 6563 6b73 293a 0a20 2020 2020  t_checks):.     
-000182b0: 2020 2020 2020 2069 6620 2762 726f 6b65         if 'broke
-000182c0: 6e5f 7061 636b 6574 7327 206e 6f74 2069  n_packets' not i
-000182d0: 6e20 7365 6c66 2e70 6172 616d 6574 6572  n self.parameter
-000182e0: 735f 6e63 735b 6368 616e 6e65 6c5f 6964  s_ncs[channel_id
-000182f0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-00018300: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
-00018310: 7273 5f6e 6373 5b63 6861 6e6e 656c 5f69  rs_ncs[channel_i
-00018320: 645d 5b27 6272 6f6b 656e 5f70 6163 6b65  d]['broken_packe
-00018330: 7473 275d 203d 205b 5d0a 2020 2020 2020  ts'] = [].      
-00018340: 2020 2020 2020 6272 6f6b 656e 5f70 6163        broken_pac
-00018350: 6b65 7473 203d 206e 702e 7768 6572 6528  kets = np.where(
-00018360: 6e70 2e61 7272 6179 2870 6163 6b65 745f  np.array(packet_
-00018370: 6368 6563 6b73 2920 6973 2046 616c 7365  checks) is False
-00018380: 295b 305d 0a20 2020 2020 2020 2020 2020  )[0].           
-00018390: 2066 6f72 2062 726f 6b65 6e5f 7061 636b   for broken_pack
-000183a0: 6574 2069 6e20 6272 6f6b 656e 5f70 6163  et in broken_pac
-000183b0: 6b65 7473 3a0a 2020 2020 2020 2020 2020  kets:.          
-000183c0: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
-000183d0: 6574 6572 735f 6e63 735b 6368 616e 6e65  eters_ncs[channe
-000183e0: 6c5f 6964 5d5b 2762 726f 6b65 6e5f 7061  l_id]['broken_pa
-000183f0: 636b 6574 7327 5d2e 6170 7065 6e64 280a  ckets'].append(.
-00018400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018410: 2020 2020 2862 726f 6b65 6e5f 7061 636b      (broken_pack
-00018420: 6574 2c0a 2020 2020 2020 2020 2020 2020  et,.            
-00018430: 2020 2020 2020 2020 2076 616c 6964 5f73           valid_s
-00018440: 616d 706c 6573 5b62 726f 6b65 6e5f 7061  amples[broken_pa
-00018450: 636b 6574 5d2c 0a20 2020 2020 2020 2020  cket],.         
-00018460: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00018470: 5f70 6163 6b65 745f 6f66 6673 6574 735b  _packet_offsets[
-00018480: 6272 6f6b 656e 5f70 6163 6b65 745d 2929  broken_packet]))
-00018490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000184a0: 2073 656c 662e 5f64 6961 676e 6f73 7469   self._diagnosti
-000184b0: 635f 7072 696e 7428 2744 6574 6563 7465  c_print('Detecte
-000184c0: 6420 6272 6f6b 656e 2070 6163 6b65 7420  d broken packet 
-000184d0: 696e 204e 4353 2066 696c 6520 6174 2027  in NCS file at '
-000184e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000184f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018500: 2020 2020 2020 2020 2770 6163 6b65 7420          'packet 
-00018510: 6964 2025 6920 2873 616d 706c 6520 6e75  id %i (sample nu
-00018520: 6d62 6572 2025 6920 270a 2020 2020 2020  mber %i '.      
-00018530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f70: 2020 2020 2020 2065 7665 6e74 5f74 7970         event_typ
+00016f80: 6573 7d5d 0a0a 2020 2020 2320 5f5f 5f5f  es}]..    # ____
+00016f90: 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 2046 696c  ____________ Fil
+00016fa0: 6520 4368 6563 6b73 205f 5f5f 5f5f 5f5f  e Checks _______
+00016fb0: 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f 5f5f  ________________
+00016fc0: 5f5f 5f5f 5f5f 5f5f 5f5f 5f0a 0a20 2020  ___________..   
+00016fd0: 2064 6566 205f 5f6e 6373 5f70 6163 6b65   def __ncs_packe
+00016fe0: 745f 6368 6563 6b28 7365 6c66 2c20 6669  t_check(self, fi
+00016ff0: 6c65 6861 6e64 6c65 293a 0a20 2020 2020  lehandle):.     
+00017000: 2020 2027 2727 0a20 2020 2020 2020 2043     '''.        C
+00017010: 6865 636b 7320 636f 6e73 6973 7465 6e63  hecks consistenc
+00017020: 7920 6f66 2064 6174 6120 696e 206e 6373  y of data in ncs
+00017030: 2066 696c 6520 616e 6420 7261 6973 6573   file and raises
+00017040: 2061 7373 6572 7469 6f6e 2065 7272 6f72   assertion error
+00017050: 2069 6620 610a 2020 2020 2020 2020 6368   if a.        ch
+00017060: 6563 6b20 6661 696c 732e 2044 6574 6563  eck fails. Detec
+00017070: 7465 6420 7265 636f 7264 696e 6720 6761  ted recording ga
+00017080: 7073 2061 7265 2061 6464 6564 2074 6f20  ps are added to 
+00017090: 7061 7261 6d65 7465 725f 6e63 730a 0a20  parameter_ncs.. 
+000170a0: 2020 2020 2020 2041 7267 733a 0a20 2020         Args:.   
+000170b0: 2020 2020 2020 2020 2066 696c 6568 616e           filehan
+000170c0: 646c 6520 2866 696c 6520 6f62 6a65 6374  dle (file object
+000170d0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000170e0: 2020 2048 616e 646c 6520 746f 2074 6865     Handle to the
+000170f0: 2061 6c72 6561 6479 206f 7065 6e65 6420   already opened 
+00017100: 2e6e 6373 2066 696c 652e 0a20 2020 2020  .ncs file..     
+00017110: 2020 2027 2727 0a0a 2020 2020 2020 2020     '''..        
+00017120: 7469 6d65 7374 616d 7073 203d 2066 696c  timestamps = fil
+00017130: 6568 616e 646c 655b 305d 0a20 2020 2020  ehandle[0].     
+00017140: 2020 2068 6561 6465 725f 7534 203d 2066     header_u4 = f
+00017150: 696c 6568 616e 646c 655b 315d 0a0a 2020  ilehandle[1]..  
+00017160: 2020 2020 2020 2320 6368 6563 6b69 6e67        # checking
+00017170: 2073 616d 706c 696e 6720 7261 7465 206f   sampling rate o
+00017180: 6620 6461 7461 2070 6163 6b65 7473 0a20  f data packets. 
+00017190: 2020 2020 2020 2073 7230 203d 2068 6561         sr0 = hea
+000171a0: 6465 725f 7534 5b30 2c20 315d 0a20 2020  der_u4[0, 1].   
+000171b0: 2020 2020 2061 7373 6572 7420 616c 6c28       assert all(
+000171c0: 6865 6164 6572 5f75 345b 3a2c 2031 5d20  header_u4[:, 1] 
+000171d0: 3d3d 2073 7230 290a 0a20 2020 2020 2020  == sr0)..       
+000171e0: 2023 2063 6865 636b 696e 6720 6368 616e   # checking chan
+000171f0: 6e65 6c20 6964 206f 6620 6461 7461 2070  nel id of data p
+00017200: 6163 6b65 7473 0a20 2020 2020 2020 2063  ackets.        c
+00017210: 6861 6e6e 656c 5f69 6420 3d20 6865 6164  hannel_id = head
+00017220: 6572 5f75 345b 302c 2030 5d0a 2020 2020  er_u4[0, 0].    
+00017230: 2020 2020 6173 7365 7274 2061 6c6c 2868      assert all(h
+00017240: 6561 6465 725f 7534 5b3a 2c20 305d 203d  eader_u4[:, 0] =
+00017250: 3d20 6368 616e 6e65 6c5f 6964 290a 0a20  = channel_id).. 
+00017260: 2020 2020 2020 2023 2074 696d 6520 6f66         # time of
+00017270: 6673 6574 206f 6620 6461 7461 2070 6163  fset of data pac
+00017280: 6b65 7473 0a20 2020 2020 2020 2023 2054  kets.        # T
+00017290: 4f44 4f3a 2043 6865 636b 2069 6620 7468  ODO: Check if th
+000172a0: 6572 6520 6973 2061 2073 6166 6572 2077  ere is a safer w
+000172b0: 6179 2074 6f20 646f 2074 6865 2064 656c  ay to do the del
+000172c0: 7461 5f74 2063 6865 636b 2066 6f72 206e  ta_t check for n
+000172d0: 6373 0a20 2020 2020 2020 2023 2020 6461  cs.        #  da
+000172e0: 7461 2070 6163 6b65 7473 0a20 2020 2020  ta packets.     
+000172f0: 2020 2023 2074 6869 7320 6973 2061 206e     # this is a n
+00017300: 6f74 2073 6166 6520 6173 7375 6d70 7469  ot safe assumpti
+00017310: 6f6e 2c20 7468 6174 2074 6865 2066 6972  on, that the fir
+00017320: 7374 2074 776f 2064 6174 6120 7061 636b  st two data pack
+00017330: 6574 7320 6861 7665 0a20 2020 2020 2020  ets have.       
+00017340: 2023 2020 636f 7272 6563 7420 7469 6d65   #  correct time
+00017350: 2073 7461 6d70 730a 2020 2020 2020 2020   stamps.        
+00017360: 6465 6c74 615f 7420 3d20 7469 6d65 7374  delta_t = timest
+00017370: 616d 7073 5b31 5d20 2d20 7469 6d65 7374  amps[1] - timest
+00017380: 616d 7073 5b30 5d0a 0a20 2020 2020 2020  amps[0]..       
+00017390: 2023 2076 616c 6964 2073 616d 706c 6573   # valid samples
+000173a0: 206f 6620 6669 7273 7420 6461 7461 2070   of first data p
+000173b0: 6163 6b65 740a 2020 2020 2020 2020 7465  acket.        te
+000173c0: 6d70 5f76 616c 6964 5f73 616d 706c 6573  mp_valid_samples
+000173d0: 203d 2068 6561 6465 725f 7534 5b30 2c20   = header_u4[0, 
+000173e0: 325d 0a0a 2020 2020 2020 2020 2320 756e  2]..        # un
+000173f0: 6974 2074 6573 740a 2020 2020 2020 2020  it test.        
+00017400: 2320 7469 6d65 2064 6966 6665 7265 6e63  # time differenc
+00017410: 6520 6265 7477 6565 6e20 7061 636b 6574  e between packet
+00017420: 7320 636f 7272 6573 706f 6e64 7320 746f  s corresponds to
+00017430: 206e 756d 6265 7220 6f66 2072 6563 6f72   number of recor
+00017440: 6465 640a 2020 2020 2020 2020 2320 7361  ded.        # sa
+00017450: 6d70 6c65 730a 2020 2020 2020 2020 6173  mples.        as
+00017460: 7365 7274 2064 656c 7461 5f74 203d 3d20  sert delta_t == 
+00017470: 280a 2020 2020 2020 2020 2020 2020 7465  (.            te
+00017480: 6d70 5f76 616c 6964 5f73 616d 706c 6573  mp_valid_samples
+00017490: 202f 2028 0a20 2020 2020 2020 2020 2020   / (.           
+000174a0: 2020 2020 2073 656c 662e 6e63 735f 7469       self.ncs_ti
+000174b0: 6d65 5f75 6e69 742e 7265 7363 616c 6528  me_unit.rescale(
+000174c0: 7071 2e73 292e 6d61 676e 6974 7564 6520  pq.s).magnitude 
+000174d0: 2a20 7372 3029 290a 0a20 2020 2020 2020  * sr0))..       
+000174e0: 2073 656c 662e 5f64 6961 676e 6f73 7469   self._diagnosti
+000174f0: 635f 7072 696e 7428 274e 4353 2070 6163  c_print('NCS pac
+00017500: 6b65 7420 6368 6563 6b20 7375 6363 6573  ket check succes
+00017510: 7366 756c 2e27 290a 0a20 2020 2064 6566  sful.')..    def
+00017520: 205f 5f6e 7365 5f63 6865 636b 2873 656c   __nse_check(sel
+00017530: 662c 2066 696c 6568 616e 646c 6529 3a0a  f, filehandle):.
+00017540: 2020 2020 2020 2020 2727 270a 2020 2020          '''.    
+00017550: 2020 2020 4368 6563 6b73 2063 6f6e 7369      Checks consi
+00017560: 7374 656e 6379 206f 6620 6461 7461 2069  stency of data i
+00017570: 6e20 6e63 7320 6669 6c65 2061 6e64 2072  n ncs file and r
+00017580: 6169 7365 7320 6173 7365 7274 696f 6e20  aises assertion 
+00017590: 6572 726f 7220 6966 2061 0a20 2020 2020  error if a.     
+000175a0: 2020 2063 6865 636b 2066 6169 6c73 2e0a     check fails..
+000175b0: 0a20 2020 2020 2020 2041 7267 733a 0a20  .        Args:. 
+000175c0: 2020 2020 2020 2020 2020 2066 696c 6568             fileh
+000175d0: 616e 646c 6520 2866 696c 6520 6f62 6a65  andle (file obje
+000175e0: 6374 293a 0a20 2020 2020 2020 2020 2020  ct):.           
+000175f0: 2020 2020 2048 616e 646c 6520 746f 2074       Handle to t
+00017600: 6865 2061 6c72 6561 6479 206f 7065 6e65  he already opene
+00017610: 6420 2e6e 7365 2066 696c 652e 0a20 2020  d .nse file..   
+00017620: 2020 2020 2027 2727 0a0a 2020 2020 2020       '''..      
+00017630: 2020 5b74 696d 6573 7461 6d70 732c 2063    [timestamps, c
+00017640: 6861 6e6e 656c 5f69 6473 2c20 6365 6c6c  hannel_ids, cell
+00017650: 5f6e 756d 6265 7273 2c20 6665 6174 7572  _numbers, featur
+00017660: 6573 2c0a 2020 2020 2020 2020 2064 6174  es,.         dat
+00017670: 615f 706f 696e 7473 5d20 3d20 6669 6c65  a_points] = file
+00017680: 6861 6e64 6c65 0a0a 2020 2020 2020 2020  handle..        
+00017690: 6173 7365 7274 2061 6c6c 2863 6861 6e6e  assert all(chann
+000176a0: 656c 5f69 6473 203d 3d20 6368 616e 6e65  el_ids == channe
+000176b0: 6c5f 6964 735b 305d 290a 0a20 2020 2020  l_ids[0])..     
+000176c0: 2020 2061 7373 6572 7420 616c 6c28 5b6c     assert all([l
+000176d0: 656e 2864 7029 203d 3d20 6c65 6e28 6461  en(dp) == len(da
+000176e0: 7461 5f70 6f69 6e74 735b 305d 2920 666f  ta_points[0]) fo
+000176f0: 7220 6470 2069 6e20 6461 7461 5f70 6f69  r dp in data_poi
+00017700: 6e74 735d 290a 0a20 2020 2020 2020 2073  nts])..        s
+00017710: 656c 662e 5f64 6961 676e 6f73 7469 635f  elf._diagnostic_
+00017720: 7072 696e 7428 274e 5345 2066 696c 6520  print('NSE file 
+00017730: 6368 6563 6b20 7375 6363 6573 7366 756c  check successful
+00017740: 2e27 290a 0a20 2020 2064 6566 205f 5f6e  .')..    def __n
+00017750: 6576 5f63 6865 636b 2873 656c 662c 2066  ev_check(self, f
+00017760: 696c 6568 616e 646c 6529 3a0a 2020 2020  ilehandle):.    
+00017770: 2020 2020 2727 270a 2020 2020 2020 2020      '''.        
+00017780: 4368 6563 6b73 2063 6f6e 7369 7374 656e  Checks consisten
+00017790: 6379 206f 6620 6461 7461 2069 6e20 6e65  cy of data in ne
+000177a0: 7620 6669 6c65 2061 6e64 2072 6169 7365  v file and raise
+000177b0: 7320 6173 7365 7274 696f 6e20 6572 726f  s assertion erro
+000177c0: 7220 6966 2061 0a20 2020 2020 2020 2063  r if a.        c
+000177d0: 6865 636b 2066 6169 6c73 2e0a 0a20 2020  heck fails...   
+000177e0: 2020 2020 2041 7267 733a 0a20 2020 2020       Args:.     
+000177f0: 2020 2020 2020 2066 696c 6568 616e 646c         filehandl
+00017800: 6520 2866 696c 6520 6f62 6a65 6374 293a  e (file object):
+00017810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00017820: 2048 616e 646c 6520 746f 2074 6865 2061   Handle to the a
+00017830: 6c72 6561 6479 206f 7065 6e65 6420 2e6e  lready opened .n
+00017840: 6576 2066 696c 652e 0a20 2020 2020 2020  ev file..       
+00017850: 2027 2727 0a0a 2020 2020 2020 2020 2320   '''..        # 
+00017860: 7468 6973 2065 6e74 7279 2073 686f 756c  this entry shoul
+00017870: 6420 616c 7761 7973 2065 7175 616c 2032  d always equal 2
+00017880: 2028 7365 6520 4e65 7572 616c 796e 7820   (see Neuralynx 
+00017890: 4669 6c65 2044 6573 6372 6970 7469 6f6e  File Description
+000178a0: 292c 0a20 2020 2020 2020 2023 2062 7574  ),.        # but
+000178b0: 2069 7420 6973 206e 6f74 2e20 466f 7220   it is not. For 
+000178c0: 6d65 2c20 7468 6973 2069 7320 302e 0a20  me, this is 0.. 
+000178d0: 2020 2020 2020 2061 7373 6572 7420 616c         assert al
+000178e0: 6c28 5b66 5b32 5d20 3d3d 2032 206f 7220  l([f[2] == 2 or 
+000178f0: 665b 325d 203d 3d20 3020 666f 7220 6620  f[2] == 0 for f 
+00017900: 696e 2066 696c 6568 616e 646c 655d 290a  in filehandle]).
+00017910: 0a20 2020 2020 2020 2023 2054 4f44 4f3a  .        # TODO:
+00017920: 2063 6865 636b 2077 6974 6820 6d6f 7265   check with more
+00017930: 206e 6576 2066 696c 6573 2c20 6966 2069   nev files, if i
+00017940: 6e64 6578 2030 2c31 2c32 2c36 2c37 2c38  ndex 0,1,2,6,7,8
+00017950: 2061 6e64 2039 2063 616e 2062 650a 2020   and 9 can be.  
+00017960: 2020 2020 2020 2320 6e6f 6e2d 7a65 726f        # non-zero
+00017970: 2e20 496e 7465 7270 7265 7461 7469 6f6e  . Interpretation
+00017980: 3f20 496e 636c 7564 6520 696e 2065 7665  ? Include in eve
+00017990: 6e74 2065 7874 7261 6374 696f 6e2e 0a20  nt extraction.. 
+000179a0: 2020 2020 2020 2023 206f 6e6c 7920 6f62         # only ob
+000179b0: 7365 7276 6564 2030 2066 6f72 2069 6e64  served 0 for ind
+000179c0: 6578 2030 2c31 2c32 2c36 2c37 2c38 2c39  ex 0,1,2,6,7,8,9
+000179d0: 2069 6e20 6e65 7620 6669 6c65 732e 0a20   in nev files.. 
+000179e0: 2020 2020 2020 2023 2049 6620 7468 6579         # If they
+000179f0: 2061 7265 206e 6f6e 2d7a 6572 6f2c 2074   are non-zero, t
+00017a00: 6869 7320 6e65 6564 7320 746f 2062 6520  his needs to be 
+00017a10: 696e 636c 7564 6564 2069 6e20 6576 656e  included in even
+00017a20: 7420 6578 7472 6163 7469 6f6e 0a20 2020  t extraction.   
+00017a30: 2020 2020 2061 7373 6572 7420 616c 6c28       assert all(
+00017a40: 5b66 5b30 5d20 3d3d 2030 2066 6f72 2066  [f[0] == 0 for f
+00017a50: 2069 6e20 6669 6c65 6861 6e64 6c65 5d29   in filehandle])
+00017a60: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+00017a70: 616c 6c28 5b66 5b31 5d20 3d3d 2030 2066  all([f[1] == 0 f
+00017a80: 6f72 2066 2069 6e20 6669 6c65 6861 6e64  or f in filehand
+00017a90: 6c65 5d29 0a20 2020 2020 2020 2061 7373  le]).        ass
+00017aa0: 6572 7420 616c 6c28 5b66 5b32 5d20 696e  ert all([f[2] in
+00017ab0: 205b 302c 2032 5d20 666f 7220 6620 696e   [0, 2] for f in
+00017ac0: 2066 696c 6568 616e 646c 655d 290a 0a20   filehandle]).. 
+00017ad0: 2020 2020 2020 2061 7373 6572 7420 616c         assert al
+00017ae0: 6c28 5b66 5b36 5d20 3d3d 2030 2066 6f72  l([f[6] == 0 for
+00017af0: 2066 2069 6e20 6669 6c65 6861 6e64 6c65   f in filehandle
+00017b00: 5d29 0a20 2020 2020 2020 2061 7373 6572  ]).        asser
+00017b10: 7420 616c 6c28 5b66 5b37 5d20 3d3d 2030  t all([f[7] == 0
+00017b20: 2066 6f72 2066 2069 6e20 6669 6c65 6861   for f in fileha
+00017b30: 6e64 6c65 5d29 0a20 2020 2020 2020 2061  ndle]).        a
+00017b40: 7373 6572 7420 616c 6c28 5b66 5b38 5d20  ssert all([f[8] 
+00017b50: 3d3d 2030 2066 6f72 2066 2069 6e20 6669  == 0 for f in fi
+00017b60: 6c65 6861 6e64 6c65 5d29 0a20 2020 2020  lehandle]).     
+00017b70: 2020 2061 7373 6572 7420 616c 6c28 5b61     assert all([a
+00017b80: 6c6c 2866 5b39 5d20 3d3d 2030 2920 666f  ll(f[9] == 0) fo
+00017b90: 7220 6620 696e 2066 696c 6568 616e 646c  r f in filehandl
+00017ba0: 655d 290a 0a20 2020 2020 2020 2073 656c  e])..        sel
+00017bb0: 662e 5f64 6961 676e 6f73 7469 635f 7072  f._diagnostic_pr
+00017bc0: 696e 7428 274e 4556 2066 696c 6520 6368  int('NEV file ch
+00017bd0: 6563 6b20 7375 6363 6573 7366 756c 2e27  eck successful.'
+00017be0: 290a 0a20 2020 2064 6566 205f 5f6e 7474  )..    def __ntt
+00017bf0: 5f63 6865 636b 2873 656c 662c 2066 696c  _check(self, fil
+00017c00: 6568 616e 646c 6529 3a0a 2020 2020 2020  ehandle):.      
+00017c10: 2020 2727 270a 2020 2020 2020 2020 4368    '''.        Ch
+00017c20: 6563 6b73 2063 6f6e 7369 7374 656e 6379  ecks consistency
+00017c30: 206f 6620 6461 7461 2069 6e20 6e63 7320   of data in ncs 
+00017c40: 6669 6c65 2061 6e64 2072 6169 7365 7320  file and raises 
+00017c50: 6173 7365 7274 696f 6e20 6572 726f 7220  assertion error 
+00017c60: 6966 2061 0a20 2020 2020 2020 2063 6865  if a.        che
+00017c70: 636b 2066 6169 6c73 2e0a 0a20 2020 2020  ck fails...     
+00017c80: 2020 2041 7267 733a 0a20 2020 2020 2020     Args:.       
+00017c90: 2020 2020 2066 696c 6568 616e 646c 6520       filehandle 
+00017ca0: 2866 696c 6520 6f62 6a65 6374 293a 0a20  (file object):. 
+00017cb0: 2020 2020 2020 2020 2020 2020 2020 2048                 H
+00017cc0: 616e 646c 6520 746f 2074 6865 2061 6c72  andle to the alr
+00017cd0: 6561 6479 206f 7065 6e65 6420 2e6e 7365  eady opened .nse
+00017ce0: 2066 696c 652e 0a20 2020 2020 2020 2027   file..        '
+00017cf0: 2727 0a20 2020 2020 2020 2023 2054 4f44  ''.        # TOD
+00017d00: 4f3a 2063 6865 636b 2074 6869 7320 7768  O: check this wh
+00017d10: 656e 2066 6972 7374 202e 6e74 7420 6669  en first .ntt fi
+00017d20: 6c65 7320 6172 6520 6176 6169 6c61 626c  les are availabl
+00017d30: 650a 2020 2020 2020 2020 5b74 696d 6573  e.        [times
+00017d40: 7461 6d70 732c 2063 6861 6e6e 656c 5f69  tamps, channel_i
+00017d50: 6473 2c20 6365 6c6c 5f6e 756d 6265 7273  ds, cell_numbers
+00017d60: 2c20 6665 6174 7572 6573 2c0a 2020 2020  , features,.    
+00017d70: 2020 2020 2064 6174 615f 706f 696e 7473       data_points
+00017d80: 5d20 3d20 6669 6c65 6861 6e64 6c65 0a0a  ] = filehandle..
+00017d90: 2020 2020 2020 2020 6173 7365 7274 2061          assert a
+00017da0: 6c6c 2863 6861 6e6e 656c 5f69 6473 203d  ll(channel_ids =
+00017db0: 3d20 6368 616e 6e65 6c5f 6964 735b 305d  = channel_ids[0]
+00017dc0: 290a 0a20 2020 2020 2020 2061 7373 6572  )..        asser
+00017dd0: 7420 616c 6c28 5b6c 656e 2864 7029 203d  t all([len(dp) =
+00017de0: 3d20 6c65 6e28 6461 7461 5f70 6f69 6e74  = len(data_point
+00017df0: 735b 305d 2920 666f 7220 6470 2069 6e20  s[0]) for dp in 
+00017e00: 6461 7461 5f70 6f69 6e74 735d 290a 0a20  data_points]).. 
+00017e10: 2020 2020 2020 2073 656c 662e 5f64 6961         self._dia
+00017e20: 676e 6f73 7469 635f 7072 696e 7428 274e  gnostic_print('N
+00017e30: 5454 2066 696c 6520 6368 6563 6b20 7375  TT file check su
+00017e40: 6363 6573 7366 756c 2e27 290a 0a20 2020  ccessful.')..   
+00017e50: 2064 6566 205f 5f6e 6373 5f67 6170 5f63   def __ncs_gap_c
+00017e60: 6865 636b 2873 656c 662c 2066 696c 6568  heck(self, fileh
+00017e70: 616e 646c 6529 3a0a 2020 2020 2020 2020  andle):.        
+00017e80: 2727 270a 2020 2020 2020 2020 4368 6563  '''.        Chec
+00017e90: 6b73 2069 6e64 6976 6964 7561 6c20 6461  ks individual da
+00017ea0: 7461 2062 6c6f 636b 7320 6f66 206e 6373  ta blocks of ncs
+00017eb0: 2066 696c 6573 2066 6f72 2063 6f6e 7369   files for consi
+00017ec0: 7374 656e 7420 7374 6172 7469 6e67 0a20  stent starting. 
+00017ed0: 2020 2020 2020 2074 696d 6573 2077 6974         times wit
+00017ee0: 6820 7265 7370 6563 7420 746f 2073 616d  h respect to sam
+00017ef0: 706c 6520 636f 756e 742e 0a20 2020 2020  ple count..     
+00017f00: 2020 2054 6869 7320 636f 7665 7273 2069     This covers i
+00017f10: 6e74 656e 6465 6420 7265 636f 7264 696e  ntended recordin
+00017f20: 6720 6761 7073 2061 7320 7765 6c6c 2061  g gaps as well a
+00017f30: 7320 7368 6f72 7465 6e65 6420 6461 7461  s shortened data
+00017f40: 2070 6163 6b65 742c 0a20 2020 2020 2020   packet,.       
+00017f50: 2077 6869 6368 2061 7265 2069 6e63 6f6d   which are incom
+00017f60: 706c 6574 650a 2020 2020 2020 2020 2727  plete.        ''
+00017f70: 270a 0a20 2020 2020 2020 2074 696d 6573  '..        times
+00017f80: 7461 6d70 7320 3d20 6669 6c65 6861 6e64  tamps = filehand
+00017f90: 6c65 5b30 5d0a 2020 2020 2020 2020 6865  le[0].        he
+00017fa0: 6164 6572 5f75 3420 3d20 6669 6c65 6861  ader_u4 = fileha
+00017fb0: 6e64 6c65 5b31 5d0a 2020 2020 2020 2020  ndle[1].        
+00017fc0: 6368 616e 6e65 6c5f 6964 203d 2068 6561  channel_id = hea
+00017fd0: 6465 725f 7534 5b30 2c20 305d 0a20 2020  der_u4[0, 0].   
+00017fe0: 2020 2020 2069 6620 6368 616e 6e65 6c5f       if channel_
+00017ff0: 6964 206e 6f74 2069 6e20 7365 6c66 2e70  id not in self.p
+00018000: 6172 616d 6574 6572 735f 6e63 733a 0a20  arameters_ncs:. 
+00018010: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00018020: 7061 7261 6d65 7465 7273 5f6e 6373 5b63  parameters_ncs[c
+00018030: 6861 6e6e 656c 5f69 645d 203d 207b 7d0a  hannel_id] = {}.
+00018040: 0a20 2020 2020 2020 2023 2074 696d 6520  .        # time 
+00018050: 7374 616d 7073 206f 6620 6461 7461 2070  stamps of data p
+00018060: 6163 6b65 7473 0a20 2020 2020 2020 2064  ackets.        d
+00018070: 656c 7461 5f74 203d 2074 696d 6573 7461  elta_t = timesta
+00018080: 6d70 735b 315d 202d 2074 696d 6573 7461  mps[1] - timesta
+00018090: 6d70 735b 305d 2020 2320 696e 206d 6963  mps[0]  # in mic
+000180a0: 726f 7365 630a 2020 2020 2020 2020 6461  rosec.        da
+000180b0: 7461 5f70 6163 6b65 745f 6f66 6673 6574  ta_packet_offset
+000180c0: 7320 3d20 6e70 2e64 6966 6628 7469 6d65  s = np.diff(time
+000180d0: 7374 616d 7073 2920 2023 2069 6e20 6d69  stamps)  # in mi
+000180e0: 6372 6f73 6563 0a0a 2020 2020 2020 2020  crosec..        
+000180f0: 2320 6368 6563 6b20 6966 2064 656c 7461  # check if delta
+00018100: 5f74 2063 6f72 7265 7370 6f6e 6473 2074  _t corresponds t
+00018110: 6f20 6e75 6d62 6572 206f 6620 7661 6c69  o number of vali
+00018120: 6420 7361 6d70 6c65 7320 7072 6573 656e  d samples presen
+00018130: 7420 696e 0a20 2020 2020 2020 2023 2064  t in.        # d
+00018140: 6174 6120 7061 636b 6574 730a 2020 2020  ata packets.    
+00018150: 2020 2020 2320 4e4f 5445 3a20 5468 6973      # NOTE: This
+00018160: 2061 6c73 6f20 6465 7465 6374 7320 7265   also detects re
+00018170: 636f 7264 696e 6720 6761 7073 210a 2020  cording gaps!.  
+00018180: 2020 2020 2020 7661 6c69 645f 7361 6d70        valid_samp
+00018190: 6c65 7320 3d20 6865 6164 6572 5f75 345b  les = header_u4[
+000181a0: 3a2d 312c 2032 5d0a 2020 2020 2020 2020  :-1, 2].        
+000181b0: 7361 6d70 6c69 6e67 5f72 6174 6520 3d20  sampling_rate = 
+000181c0: 6865 6164 6572 5f75 345b 302c 2031 5d0a  header_u4[0, 1].
+000181d0: 2020 2020 2020 2020 7061 636b 6574 5f63          packet_c
+000181e0: 6865 636b 7320 3d20 2876 616c 6964 5f73  hecks = (valid_s
+000181f0: 616d 706c 6573 202f 2028 7365 6c66 2e6e  amples / (self.n
+00018200: 6373 5f74 696d 655f 756e 6974 2e72 6573  cs_time_unit.res
+00018210: 6361 6c65 280a 2020 2020 2020 2020 2020  cale(.          
+00018220: 2020 7071 2e73 292e 6d61 676e 6974 7564    pq.s).magnitud
+00018230: 6520 2a20 7361 6d70 6c69 6e67 5f72 6174  e * sampling_rat
+00018240: 6529 2920 3d3d 2064 6174 615f 7061 636b  e)) == data_pack
+00018250: 6574 5f6f 6666 7365 7473 0a20 2020 2020  et_offsets.     
+00018260: 2020 2069 6620 6e6f 7420 616c 6c28 7061     if not all(pa
+00018270: 636b 6574 5f63 6865 636b 7329 3a0a 2020  cket_checks):.  
+00018280: 2020 2020 2020 2020 2020 6966 2027 6272            if 'br
+00018290: 6f6b 656e 5f70 6163 6b65 7473 2720 6e6f  oken_packets' no
+000182a0: 7420 696e 2073 656c 662e 7061 7261 6d65  t in self.parame
+000182b0: 7465 7273 5f6e 6373 5b63 6861 6e6e 656c  ters_ncs[channel
+000182c0: 5f69 645d 3a0a 2020 2020 2020 2020 2020  _id]:.          
+000182d0: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
+000182e0: 6574 6572 735f 6e63 735b 6368 616e 6e65  eters_ncs[channe
+000182f0: 6c5f 6964 5d5b 2762 726f 6b65 6e5f 7061  l_id]['broken_pa
+00018300: 636b 6574 7327 5d20 3d20 5b5d 0a20 2020  ckets'] = [].   
+00018310: 2020 2020 2020 2020 2062 726f 6b65 6e5f           broken_
+00018320: 7061 636b 6574 7320 3d20 6e70 2e77 6865  packets = np.whe
+00018330: 7265 286e 702e 6172 7261 7928 7061 636b  re(np.array(pack
+00018340: 6574 5f63 6865 636b 7329 2069 7320 4661  et_checks) is Fa
+00018350: 6c73 6529 5b30 5d0a 2020 2020 2020 2020  lse)[0].        
+00018360: 2020 2020 666f 7220 6272 6f6b 656e 5f70      for broken_p
+00018370: 6163 6b65 7420 696e 2062 726f 6b65 6e5f  acket in broken_
+00018380: 7061 636b 6574 733a 0a20 2020 2020 2020  packets:.       
+00018390: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
+000183a0: 7261 6d65 7465 7273 5f6e 6373 5b63 6861  rameters_ncs[cha
+000183b0: 6e6e 656c 5f69 645d 5b27 6272 6f6b 656e  nnel_id]['broken
+000183c0: 5f70 6163 6b65 7473 275d 2e61 7070 656e  _packets'].appen
+000183d0: 6428 0a20 2020 2020 2020 2020 2020 2020  d(.             
+000183e0: 2020 2020 2020 2028 6272 6f6b 656e 5f70         (broken_p
+000183f0: 6163 6b65 742c 0a20 2020 2020 2020 2020  acket,.         
+00018400: 2020 2020 2020 2020 2020 2020 7661 6c69              vali
+00018410: 645f 7361 6d70 6c65 735b 6272 6f6b 656e  d_samples[broken
+00018420: 5f70 6163 6b65 745d 2c0a 2020 2020 2020  _packet],.      
+00018430: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00018440: 6174 615f 7061 636b 6574 5f6f 6666 7365  ata_packet_offse
+00018450: 7473 5b62 726f 6b65 6e5f 7061 636b 6574  ts[broken_packet
+00018460: 5d29 290a 2020 2020 2020 2020 2020 2020  ])).            
+00018470: 2020 2020 7365 6c66 2e5f 6469 6167 6e6f      self._diagno
+00018480: 7374 6963 5f70 7269 6e74 2827 4465 7465  stic_print('Dete
+00018490: 6374 6564 2062 726f 6b65 6e20 7061 636b  cted broken pack
+000184a0: 6574 2069 6e20 4e43 5320 6669 6c65 2061  et in NCS file a
+000184b0: 7420 270a 2020 2020 2020 2020 2020 2020  t '.            
+000184c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000184d0: 2020 2020 2020 2020 2020 2027 7061 636b             'pack
+000184e0: 6574 2069 6420 2569 2028 7361 6d70 6c65  et id %i (sample
+000184f0: 206e 756d 6265 7220 2569 2027 0a20 2020   number %i '.   
+00018500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018520: 2020 2020 2774 696d 6520 6f66 6673 6574      'time offset
+00018530: 2069 6420 2569 2927 0a20 2020 2020 2020   id %i)'.       
 00018540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018550: 2027 7469 6d65 206f 6666 7365 7420 6964   'time offset id
-00018560: 2025 6929 270a 2020 2020 2020 2020 2020   %i)'.          
-00018570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018580: 2020 2020 2020 2020 2020 2020 2027 2720               '' 
-00018590: 2520 2862 726f 6b65 6e5f 7061 636b 6574  % (broken_packet
-000185a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000185b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000185c0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-000185d0: 616c 6964 5f73 616d 706c 6573 5b62 726f  alid_samples[bro
-000185e0: 6b65 6e5f 7061 636b 6574 5d2c 0a20 2020  ken_packet],.   
-000185f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018610: 2020 2020 2020 2020 2020 6461 7461 5f70            data_p
-00018620: 6163 6b65 745f 6f66 6673 6574 735b 6272  acket_offsets[br
-00018630: 6f6b 656e 5f70 6163 6b65 745d 290a 2020  oken_packet]).  
-00018640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018660: 2020 2020 2029 2020 2320 696e 206d 6963       )  # in mic
-00018670: 726f 7365 630a 0a20 2020 2020 2020 2023  rosec..        #
-00018680: 2063 6865 636b 696e 6720 666f 7220 6972   checking for ir
-00018690: 7265 6775 6c61 7220 6461 7461 2070 6163  regular data pac
-000186a0: 6b65 7420 6475 7261 7469 6f6e 7320 2d3e  ket durations ->
-000186b0: 2067 6170 7320 2f20 7368 6f72 7465 6e65   gaps / shortene
-000186c0: 640a 2020 2020 2020 2020 2320 6461 7461  d.        # data
-000186d0: 2070 6163 6b65 7473 0a20 2020 2020 2020   packets.       
-000186e0: 2069 6620 6e6f 7420 616c 6c28 6461 7461   if not all(data
-000186f0: 5f70 6163 6b65 745f 6f66 6673 6574 7320  _packet_offsets 
-00018700: 3d3d 2064 656c 7461 5f74 293a 0a20 2020  == delta_t):.   
-00018710: 2020 2020 2020 2020 2069 6620 2767 6170           if 'gap
-00018720: 7327 206e 6f74 2069 6e20 7365 6c66 2e70  s' not in self.p
-00018730: 6172 616d 6574 6572 735f 6e63 735b 6368  arameters_ncs[ch
-00018740: 616e 6e65 6c5f 6964 5d3a 0a20 2020 2020  annel_id]:.     
-00018750: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00018760: 7061 7261 6d65 7465 7273 5f6e 6373 5b63  parameters_ncs[c
-00018770: 6861 6e6e 656c 5f69 645d 5b27 6761 7073  hannel_id]['gaps
-00018780: 275d 203d 205b 5d0a 2020 2020 2020 2020  '] = [].        
-00018790: 2020 2020 2320 6761 7020 6964 656e 7469      # gap identi
-000187a0: 6669 6361 7469 6f6e 2062 7920 2873 616d  fication by (sam
-000187b0: 706c 6520 6f66 2067 6170 2073 7461 7274  ple of gap start
-000187c0: 2c20 6475 7261 7469 6f6e 290a 2020 2020  , duration).    
-000187d0: 2020 2020 2020 2020 2320 6761 7020 7061          # gap pa
-000187e0: 636b 6574 730a 2020 2020 2020 2020 2020  ckets.          
-000187f0: 2020 6761 705f 7061 636b 6574 5f69 6473    gap_packet_ids
-00018800: 203d 206e 702e 7768 6572 6528 6461 7461   = np.where(data
-00018810: 5f70 6163 6b65 745f 6f66 6673 6574 7320  _packet_offsets 
-00018820: 213d 2064 656c 7461 5f74 295b 305d 0a20  != delta_t)[0]. 
-00018830: 2020 2020 2020 2020 2020 2066 6f72 2067             for g
-00018840: 6170 5f70 6163 6b65 745f 6964 2069 6e20  ap_packet_id in 
-00018850: 6761 705f 7061 636b 6574 5f69 6473 3a0a  gap_packet_ids:.
-00018860: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018870: 2023 2073 6b69 7020 6966 2074 6869 7320   # skip if this 
-00018880: 7061 636b 6574 2073 7461 7274 696e 6720  packet starting 
-00018890: 7469 6d65 2069 7320 6b6e 6f77 6e20 746f  time is known to
-000188a0: 2062 6520 636f 7272 7570 7465 640a 2020   be corrupted.  
-000188b0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000188c0: 686f 7069 6e67 206e 6f20 636f 7272 7570  hoping no corrup
-000188d0: 7469 6f6e 2061 6e64 2067 6170 206f 6363  tion and gap occ
-000188e0: 7572 7320 7369 6d75 6c74 616e 656f 7573  urs simultaneous
-000188f0: 6c79 0a20 2020 2020 2020 2020 2020 2020  ly.             
-00018900: 2020 2023 2063 6f72 7275 7074 6564 2074     # corrupted t
-00018910: 696d 6520 7374 616d 7020 6166 6665 6374  ime stamp affect
-00018920: 7320 7477 6f20 6465 6c74 615f 7420 636f  s two delta_t co
-00018930: 6d70 6172 6973 6f6e 733a 0a20 2020 2020  mparisons:.     
-00018940: 2020 2020 2020 2020 2020 2069 6620 6761             if ga
-00018950: 705f 7061 636b 6574 5f69 6420 696e 2073  p_packet_id in s
-00018960: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-00018970: 6373 5b63 6861 6e6e 656c 5f69 645d 5b0a  cs[channel_id][.
-00018980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018990: 2020 2020 2769 6e76 616c 6964 5f66 6972      'invalid_fir
-000189a0: 7374 5f73 616d 706c 6573 275d 205c 0a20  st_samples'] \. 
-000189b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000189c0: 2020 2020 2020 206f 7220 6761 705f 7061         or gap_pa
-000189d0: 636b 6574 5f69 6420 2b20 3120 696e 2073  cket_id + 1 in s
-000189e0: 656c 662e 7061 7261 6d65 7465 7273 5f6e  elf.parameters_n
-000189f0: 6373 5b63 6861 6e6e 656c 5f69 645d 5b0a  cs[channel_id][.
-00018a00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018a10: 2020 2020 2020 2020 2020 2020 2769 6e76              'inv
-00018a20: 616c 6964 5f66 6972 7374 5f73 616d 706c  alid_first_sampl
-00018a30: 6573 275d 3a0a 2020 2020 2020 2020 2020  es']:.          
-00018a40: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00018a50: 7565 0a0a 2020 2020 2020 2020 2020 2020  ue..            
-00018a60: 2020 2020 6761 705f 7374 6172 7420 3d20      gap_start = 
-00018a70: 7469 6d65 7374 616d 7073 5b0a 2020 2020  timestamps[.    
-00018a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018a90: 6761 705f 7061 636b 6574 5f69 645d 2020  gap_packet_id]  
-00018aa0: 2320 745f 7374 6172 7420 6f66 206c 6173  # t_start of las
-00018ab0: 7420 7061 636b 6574 205b 6d69 6372 6f73  t packet [micros
-00018ac0: 6563 5d0a 2020 2020 2020 2020 2020 2020  ec].            
-00018ad0: 2020 2020 6761 705f 7374 6f70 203d 2074      gap_stop = t
-00018ae0: 696d 6573 7461 6d70 735b 0a20 2020 2020  imestamps[.     
-00018af0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-00018b00: 6170 5f70 6163 6b65 745f 6964 202b 2031  ap_packet_id + 1
-00018b10: 5d20 2023 2074 5f73 746f 7020 6f66 2066  ]  # t_stop of f
-00018b20: 6972 7374 2070 6163 6b65 7420 5b6d 6963  irst packet [mic
-00018b30: 726f 7365 635d 0a0a 2020 2020 2020 2020  rosec]..        
-00018b40: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-00018b50: 616d 6574 6572 735f 6e63 735b 6368 616e  ameters_ncs[chan
-00018b60: 6e65 6c5f 6964 5d5b 2767 6170 7327 5d2e  nel_id]['gaps'].
-00018b70: 6170 7065 6e64 2828 6761 705f 7061 636b  append((gap_pack
-00018b80: 6574 5f69 642c 0a20 2020 2020 2020 2020  et_id,.         
-00018b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018560: 2727 2025 2028 6272 6f6b 656e 5f70 6163  '' % (broken_pac
+00018570: 6b65 742c 0a20 2020 2020 2020 2020 2020  ket,.           
+00018580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000185a0: 2020 7661 6c69 645f 7361 6d70 6c65 735b    valid_samples[
+000185b0: 6272 6f6b 656e 5f70 6163 6b65 745d 2c0a  broken_packet],.
+000185c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000185d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000185e0: 2020 2020 2020 2020 2020 2020 2064 6174               dat
+000185f0: 615f 7061 636b 6574 5f6f 6666 7365 7473  a_packet_offsets
+00018600: 5b62 726f 6b65 6e5f 7061 636b 6574 5d29  [broken_packet])
+00018610: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018630: 2020 2020 2020 2020 2920 2023 2069 6e20          )  # in 
+00018640: 6d69 6372 6f73 6563 0a0a 2020 2020 2020  microsec..      
+00018650: 2020 2320 6368 6563 6b69 6e67 2066 6f72    # checking for
+00018660: 2069 7272 6567 756c 6172 2064 6174 6120   irregular data 
+00018670: 7061 636b 6574 2064 7572 6174 696f 6e73  packet durations
+00018680: 202d 3e20 6761 7073 202f 2073 686f 7274   -> gaps / short
+00018690: 656e 6564 0a20 2020 2020 2020 2023 2064  ened.        # d
+000186a0: 6174 6120 7061 636b 6574 730a 2020 2020  ata packets.    
+000186b0: 2020 2020 6966 206e 6f74 2061 6c6c 2864      if not all(d
+000186c0: 6174 615f 7061 636b 6574 5f6f 6666 7365  ata_packet_offse
+000186d0: 7473 203d 3d20 6465 6c74 615f 7429 3a0a  ts == delta_t):.
+000186e0: 2020 2020 2020 2020 2020 2020 6966 2027              if '
+000186f0: 6761 7073 2720 6e6f 7420 696e 2073 656c  gaps' not in sel
+00018700: 662e 7061 7261 6d65 7465 7273 5f6e 6373  f.parameters_ncs
+00018710: 5b63 6861 6e6e 656c 5f69 645d 3a0a 2020  [channel_id]:.  
+00018720: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00018730: 6c66 2e70 6172 616d 6574 6572 735f 6e63  lf.parameters_nc
+00018740: 735b 6368 616e 6e65 6c5f 6964 5d5b 2767  s[channel_id]['g
+00018750: 6170 7327 5d20 3d20 5b5d 0a20 2020 2020  aps'] = [].     
+00018760: 2020 2020 2020 2023 2067 6170 2069 6465         # gap ide
+00018770: 6e74 6966 6963 6174 696f 6e20 6279 2028  ntification by (
+00018780: 7361 6d70 6c65 206f 6620 6761 7020 7374  sample of gap st
+00018790: 6172 742c 2064 7572 6174 696f 6e29 0a20  art, duration). 
+000187a0: 2020 2020 2020 2020 2020 2023 2067 6170             # gap
+000187b0: 2070 6163 6b65 7473 0a20 2020 2020 2020   packets.       
+000187c0: 2020 2020 2067 6170 5f70 6163 6b65 745f       gap_packet_
+000187d0: 6964 7320 3d20 6e70 2e77 6865 7265 2864  ids = np.where(d
+000187e0: 6174 615f 7061 636b 6574 5f6f 6666 7365  ata_packet_offse
+000187f0: 7473 2021 3d20 6465 6c74 615f 7429 5b30  ts != delta_t)[0
+00018800: 5d0a 2020 2020 2020 2020 2020 2020 666f  ].            fo
+00018810: 7220 6761 705f 7061 636b 6574 5f69 6420  r gap_packet_id 
+00018820: 696e 2067 6170 5f70 6163 6b65 745f 6964  in gap_packet_id
+00018830: 733a 0a0a 2020 2020 2020 2020 2020 2020  s:..            
+00018840: 2020 2020 2320 736b 6970 2069 6620 7468      # skip if th
+00018850: 6973 2070 6163 6b65 7420 7374 6172 7469  is packet starti
+00018860: 6e67 2074 696d 6520 6973 206b 6e6f 776e  ng time is known
+00018870: 2074 6f20 6265 2063 6f72 7275 7074 6564   to be corrupted
+00018880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018890: 2023 2068 6f70 696e 6720 6e6f 2063 6f72   # hoping no cor
+000188a0: 7275 7074 696f 6e20 616e 6420 6761 7020  ruption and gap 
+000188b0: 6f63 6375 7273 2073 696d 756c 7461 6e65  occurs simultane
+000188c0: 6f75 736c 790a 2020 2020 2020 2020 2020  ously.          
+000188d0: 2020 2020 2020 2320 636f 7272 7570 7465        # corrupte
+000188e0: 6420 7469 6d65 2073 7461 6d70 2061 6666  d time stamp aff
+000188f0: 6563 7473 2074 776f 2064 656c 7461 5f74  ects two delta_t
+00018900: 2063 6f6d 7061 7269 736f 6e73 3a0a 2020   comparisons:.  
+00018910: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00018920: 2067 6170 5f70 6163 6b65 745f 6964 2069   gap_packet_id i
+00018930: 6e20 7365 6c66 2e70 6172 616d 6574 6572  n self.parameter
+00018940: 735f 6e63 735b 6368 616e 6e65 6c5f 6964  s_ncs[channel_id
+00018950: 5d5b 0a20 2020 2020 2020 2020 2020 2020  ][.             
+00018960: 2020 2020 2020 2027 696e 7661 6c69 645f         'invalid_
+00018970: 6669 7273 745f 7361 6d70 6c65 7327 5d20  first_samples'] 
+00018980: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00018990: 2020 2020 2020 2020 2020 6f72 2067 6170            or gap
+000189a0: 5f70 6163 6b65 745f 6964 202b 2031 2069  _packet_id + 1 i
+000189b0: 6e20 7365 6c66 2e70 6172 616d 6574 6572  n self.parameter
+000189c0: 735f 6e63 735b 6368 616e 6e65 6c5f 6964  s_ncs[channel_id
+000189d0: 5d5b 0a20 2020 2020 2020 2020 2020 2020  ][.             
+000189e0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+000189f0: 696e 7661 6c69 645f 6669 7273 745f 7361  invalid_first_sa
+00018a00: 6d70 6c65 7327 5d3a 0a20 2020 2020 2020  mples']:.       
+00018a10: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+00018a20: 7469 6e75 650a 0a20 2020 2020 2020 2020  tinue..         
+00018a30: 2020 2020 2020 2067 6170 5f73 7461 7274         gap_start
+00018a40: 203d 2074 696d 6573 7461 6d70 735b 0a20   = timestamps[. 
+00018a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018a60: 2020 2067 6170 5f70 6163 6b65 745f 6964     gap_packet_id
+00018a70: 5d20 2023 2074 5f73 7461 7274 206f 6620  ]  # t_start of 
+00018a80: 6c61 7374 2070 6163 6b65 7420 5b6d 6963  last packet [mic
+00018a90: 726f 7365 635d 0a20 2020 2020 2020 2020  rosec].         
+00018aa0: 2020 2020 2020 2067 6170 5f73 746f 7020         gap_stop 
+00018ab0: 3d20 7469 6d65 7374 616d 7073 5b0a 2020  = timestamps[.  
+00018ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018ad0: 2020 6761 705f 7061 636b 6574 5f69 6420    gap_packet_id 
+00018ae0: 2b20 315d 2020 2320 745f 7374 6f70 206f  + 1]  # t_stop o
+00018af0: 6620 6669 7273 7420 7061 636b 6574 205b  f first packet [
+00018b00: 6d69 6372 6f73 6563 5d0a 0a20 2020 2020  microsec]..     
+00018b10: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00018b20: 7061 7261 6d65 7465 7273 5f6e 6373 5b63  parameters_ncs[c
+00018b30: 6861 6e6e 656c 5f69 645d 5b27 6761 7073  hannel_id]['gaps
+00018b40: 275d 2e61 7070 656e 6428 2867 6170 5f70  '].append((gap_p
+00018b50: 6163 6b65 745f 6964 2c0a 2020 2020 2020  acket_id,.      
+00018b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018b90: 2020 2020 2020 2020 2020 6761 705f 7374            gap_st
+00018ba0: 6172 742c 0a20 2020 2020 2020 2020 2020  art,.           
 00018bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018bc0: 2020 2020 2020 2067 6170 5f73 7461 7274         gap_start
-00018bd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00018be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018c10: 2020 6761 705f 7374 6f70 2929 2020 230a    gap_stop))  #.
-00018c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018c30: 2320 205b 2c6d 6963 726f 7365 632c 6d69  #  [,microsec,mi
-00018c40: 6372 6f73 6563 5d0a 2020 2020 2020 2020  crosec].        
-00018c50: 2020 2020 2020 2020 7365 6c66 2e5f 6469          self._di
-00018c60: 6167 6e6f 7374 6963 5f70 7269 6e74 2827  agnostic_print('
-00018c70: 4465 7465 6374 6564 2067 6170 2069 6e20  Detected gap in 
-00018c80: 4e43 5320 6669 6c65 2062 6574 7765 656e  NCS file between
-00018c90: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
-00018ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018cb0: 2020 2020 2020 2020 2027 7361 6d70 6c65           'sample
-00018cc0: 2074 696d 6520 2569 2061 6e64 2025 6920   time %i and %i 
-00018cd0: 2028 6c61 7374 2063 6f72 7265 6374 2027   (last correct '
-00018ce0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d00: 2020 2020 2020 2020 2770 6163 6b65 7420          'packet 
-00018d10: 6964 2025 6929 2720 2520 2867 6170 5f73  id %i)' % (gap_s
-00018d20: 7461 7274 2c20 6761 705f 7374 6f70 2c0a  tart, gap_stop,.
-00018d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d60: 2020 2020 2020 2020 2020 6761 705f 7061            gap_pa
-00018d70: 636b 6574 5f69 6429 290a 0a20 2020 2064  cket_id))..    d
-00018d80: 6566 205f 5f6e 6373 5f69 6e76 616c 6964  ef __ncs_invalid
-00018d90: 5f66 6972 7374 5f73 616d 706c 655f 6368  _first_sample_ch
-00018da0: 6563 6b28 7365 6c66 2c20 6669 6c65 6861  eck(self, fileha
-00018db0: 6e64 6c65 293a 0a20 2020 2020 2020 2027  ndle):.        '
-00018dc0: 2727 0a20 2020 2020 2020 2043 6865 636b  ''.        Check
-00018dd0: 7320 6461 7461 2062 6c6f 636b 7320 6f66  s data blocks of
-00018de0: 206e 6373 2066 696c 6573 2066 6f72 2063   ncs files for c
-00018df0: 6f72 7275 7074 6564 2073 7461 7274 696e  orrupted startin
-00018e00: 6720 7469 6d65 7320 696e 6469 6361 7469  g times indicati
-00018e10: 6e67 0a20 2020 2020 2020 2061 206d 6973  ng.        a mis
-00018e20: 7369 6e67 2066 6972 7374 2073 616d 706c  sing first sampl
-00018e30: 6520 696e 2074 6865 2064 6174 6120 7061  e in the data pa
-00018e40: 636b 6574 2e20 5468 6573 6520 6172 6520  cket. These are 
-00018e50: 7468 656e 2065 7863 6c75 6465 6420 6672  then excluded fr
-00018e60: 6f6d 0a20 2020 2020 2020 2074 6865 2067  om.        the g
-00018e70: 6170 2063 6865 636b 2c20 6275 7420 6967  ap check, but ig
-00018e80: 6e6f 7265 6420 666f 7220 6675 7274 6865  nored for furthe
-00018e90: 7220 616e 616c 7973 6973 2e0a 2020 2020  r analysis..    
-00018ea0: 2020 2020 2727 270a 2020 2020 2020 2020      '''.        
-00018eb0: 7469 6d65 7374 616d 7073 203d 2066 696c  timestamps = fil
-00018ec0: 6568 616e 646c 655b 305d 0a20 2020 2020  ehandle[0].     
-00018ed0: 2020 2068 6561 6465 725f 7534 203d 2066     header_u4 = f
-00018ee0: 696c 6568 616e 646c 655b 315d 0a20 2020  ilehandle[1].   
-00018ef0: 2020 2020 2063 6861 6e6e 656c 5f69 6420       channel_id 
-00018f00: 3d20 6865 6164 6572 5f75 345b 302c 2030  = header_u4[0, 0
-00018f10: 5d0a 2020 2020 2020 2020 7365 6c66 2e70  ].        self.p
-00018f20: 6172 616d 6574 6572 735f 6e63 735b 6368  arameters_ncs[ch
-00018f30: 616e 6e65 6c5f 6964 5d5b 2769 6e76 616c  annel_id]['inval
-00018f40: 6964 5f66 6972 7374 5f73 616d 706c 6573  id_first_samples
-00018f50: 275d 203d 205b 5d0a 0a20 2020 2020 2020  '] = []..       
-00018f60: 2023 2063 6865 636b 696e 6720 6966 2066   # checking if f
-00018f70: 6972 7374 2062 6974 206f 6620 7469 6d65  irst bit of time
-00018f80: 7374 616d 7020 6973 2031 2c20 7768 6963  stamp is 1, whic
-00018f90: 6820 696e 6469 6361 7465 7320 6572 726f  h indicates erro
-00018fa0: 720a 2020 2020 2020 2020 696e 7661 6c69  r.        invali
-00018fb0: 645f 7061 636b 6574 5f69 6473 203d 206e  d_packet_ids = n
-00018fc0: 702e 7768 6572 6528 7469 6d65 7374 616d  p.where(timestam
-00018fd0: 7073 203e 3d20 3220 2a2a 2035 3529 5b30  ps >= 2 ** 55)[0
-00018fe0: 5d0a 2020 2020 2020 2020 6966 206c 656e  ].        if len
-00018ff0: 2869 6e76 616c 6964 5f70 6163 6b65 745f  (invalid_packet_
-00019000: 6964 7329 203e 2030 3a0a 2020 2020 2020  ids) > 0:.      
-00019010: 2020 2020 2020 7761 726e 696e 6773 2e77        warnings.w
-00019020: 6172 6e28 2749 6e76 616c 6964 2066 6972  arn('Invalid fir
-00019030: 7374 2073 616d 706c 6528 7329 2064 6574  st sample(s) det
-00019040: 6563 7465 6420 696e 206e 6373 2066 696c  ected in ncs fil
-00019050: 6527 0a20 2020 2020 2020 2020 2020 2020  e'.             
-00019060: 2020 2020 2020 2020 2020 2020 2027 2870               '(p
-00019070: 6163 6b65 7420 6964 2873 2920 2569 2921  acket id(s) %i)!
-00019080: 2054 6869 7320 6572 726f 7220 6973 2069   This error is i
-00019090: 676e 6f72 6564 2069 6e27 0a20 2020 2020  gnored in'.     
-000190a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000190b0: 2020 2020 2027 7375 6273 6571 7565 6e74       'subsequent
-000190c0: 2072 6f75 7469 6e65 732e 2720 2520 2869   routines.' % (i
-000190d0: 6e76 616c 6964 5f70 6163 6b65 745f 6964  nvalid_packet_id
-000190e0: 7329 290a 2020 2020 2020 2020 2020 2020  s)).            
-000190f0: 7365 6c66 2e70 6172 616d 6574 6572 735f  self.parameters_
-00019100: 6e63 735b 6368 616e 6e65 6c5f 6964 5d5b  ncs[channel_id][
-00019110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00019120: 2027 696e 7661 6c69 645f 6669 7273 745f   'invalid_first_
-00019130: 7361 6d70 6c65 7327 5d20 3d20 696e 7661  samples'] = inva
-00019140: 6c69 645f 7061 636b 6574 5f69 6473 0a0a  lid_packet_ids..
-00019150: 2020 2020 2020 2020 2020 2020 2320 6368              # ch
-00019160: 6563 6b69 6e67 2063 6f6e 7369 7374 656e  ecking consisten
-00019170: 6379 206f 6620 6461 7461 2061 726f 756e  cy of data aroun
-00019180: 6420 636f 7272 7570 7465 6420 7061 636b  d corrupted pack
-00019190: 6574 2074 696d 650a 2020 2020 2020 2020  et time.        
-000191a0: 2020 2020 666f 7220 696e 7661 6c69 645f      for invalid_
-000191b0: 7061 636b 6574 5f69 6420 696e 2069 6e76  packet_id in inv
-000191c0: 616c 6964 5f70 6163 6b65 745f 6964 733a  alid_packet_ids:
-000191d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000191e0: 2069 6620 696e 7661 6c69 645f 7061 636b   if invalid_pack
-000191f0: 6574 5f69 6420 3c20 3220 6f72 2069 6e76  et_id < 2 or inv
-00019200: 616c 6964 5f70 6163 6b65 745f 6964 203e  alid_packet_id >
-00019210: 206c 656e 280a 2020 2020 2020 2020 2020   len(.          
-00019220: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-00019230: 6c65 6861 6e64 6c65 2920 2d20 323a 0a20  lehandle) - 2:. 
+00018bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018be0: 2020 2020 2067 6170 5f73 746f 7029 2920       gap_stop)) 
+00018bf0: 2023 0a20 2020 2020 2020 2020 2020 2020   #.             
+00018c00: 2020 2023 2020 5b2c 6d69 6372 6f73 6563     #  [,microsec
+00018c10: 2c6d 6963 726f 7365 635d 0a20 2020 2020  ,microsec].     
+00018c20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00018c30: 5f64 6961 676e 6f73 7469 635f 7072 696e  _diagnostic_prin
+00018c40: 7428 2744 6574 6563 7465 6420 6761 7020  t('Detected gap 
+00018c50: 696e 204e 4353 2066 696c 6520 6265 7477  in NCS file betw
+00018c60: 6565 6e27 0a20 2020 2020 2020 2020 2020  een'.           
+00018c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018c80: 2020 2020 2020 2020 2020 2020 2773 616d              'sam
+00018c90: 706c 6520 7469 6d65 2025 6920 616e 6420  ple time %i and 
+00018ca0: 2569 2020 286c 6173 7420 636f 7272 6563  %i  (last correc
+00018cb0: 7420 270a 2020 2020 2020 2020 2020 2020  t '.            
+00018cc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018cd0: 2020 2020 2020 2020 2020 2027 7061 636b             'pack
+00018ce0: 6574 2069 6420 2569 2927 2025 2028 6761  et id %i)' % (ga
+00018cf0: 705f 7374 6172 742c 2067 6170 5f73 746f  p_start, gap_sto
+00018d00: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
+00018d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018d30: 2020 2020 2020 2020 2020 2020 2067 6170               gap
+00018d40: 5f70 6163 6b65 745f 6964 2929 0a0a 2020  _packet_id))..  
+00018d50: 2020 6465 6620 5f5f 6e63 735f 696e 7661    def __ncs_inva
+00018d60: 6c69 645f 6669 7273 745f 7361 6d70 6c65  lid_first_sample
+00018d70: 5f63 6865 636b 2873 656c 662c 2066 696c  _check(self, fil
+00018d80: 6568 616e 646c 6529 3a0a 2020 2020 2020  ehandle):.      
+00018d90: 2020 2727 270a 2020 2020 2020 2020 4368    '''.        Ch
+00018da0: 6563 6b73 2064 6174 6120 626c 6f63 6b73  ecks data blocks
+00018db0: 206f 6620 6e63 7320 6669 6c65 7320 666f   of ncs files fo
+00018dc0: 7220 636f 7272 7570 7465 6420 7374 6172  r corrupted star
+00018dd0: 7469 6e67 2074 696d 6573 2069 6e64 6963  ting times indic
+00018de0: 6174 696e 670a 2020 2020 2020 2020 6120  ating.        a 
+00018df0: 6d69 7373 696e 6720 6669 7273 7420 7361  missing first sa
+00018e00: 6d70 6c65 2069 6e20 7468 6520 6461 7461  mple in the data
+00018e10: 2070 6163 6b65 742e 2054 6865 7365 2061   packet. These a
+00018e20: 7265 2074 6865 6e20 6578 636c 7564 6564  re then excluded
+00018e30: 2066 726f 6d0a 2020 2020 2020 2020 7468   from.        th
+00018e40: 6520 6761 7020 6368 6563 6b2c 2062 7574  e gap check, but
+00018e50: 2069 676e 6f72 6564 2066 6f72 2066 7572   ignored for fur
+00018e60: 7468 6572 2061 6e61 6c79 7369 732e 0a20  ther analysis.. 
+00018e70: 2020 2020 2020 2027 2727 0a20 2020 2020         '''.     
+00018e80: 2020 2074 696d 6573 7461 6d70 7320 3d20     timestamps = 
+00018e90: 6669 6c65 6861 6e64 6c65 5b30 5d0a 2020  filehandle[0].  
+00018ea0: 2020 2020 2020 6865 6164 6572 5f75 3420        header_u4 
+00018eb0: 3d20 6669 6c65 6861 6e64 6c65 5b31 5d0a  = filehandle[1].
+00018ec0: 2020 2020 2020 2020 6368 616e 6e65 6c5f          channel_
+00018ed0: 6964 203d 2068 6561 6465 725f 7534 5b30  id = header_u4[0
+00018ee0: 2c20 305d 0a20 2020 2020 2020 2073 656c  , 0].        sel
+00018ef0: 662e 7061 7261 6d65 7465 7273 5f6e 6373  f.parameters_ncs
+00018f00: 5b63 6861 6e6e 656c 5f69 645d 5b27 696e  [channel_id]['in
+00018f10: 7661 6c69 645f 6669 7273 745f 7361 6d70  valid_first_samp
+00018f20: 6c65 7327 5d20 3d20 5b5d 0a0a 2020 2020  les'] = []..    
+00018f30: 2020 2020 2320 6368 6563 6b69 6e67 2069      # checking i
+00018f40: 6620 6669 7273 7420 6269 7420 6f66 2074  f first bit of t
+00018f50: 696d 6573 7461 6d70 2069 7320 312c 2077  imestamp is 1, w
+00018f60: 6869 6368 2069 6e64 6963 6174 6573 2065  hich indicates e
+00018f70: 7272 6f72 0a20 2020 2020 2020 2069 6e76  rror.        inv
+00018f80: 616c 6964 5f70 6163 6b65 745f 6964 7320  alid_packet_ids 
+00018f90: 3d20 6e70 2e77 6865 7265 2874 696d 6573  = np.where(times
+00018fa0: 7461 6d70 7320 3e3d 2032 202a 2a20 3535  tamps >= 2 ** 55
+00018fb0: 295b 305d 0a20 2020 2020 2020 2069 6620  )[0].        if 
+00018fc0: 6c65 6e28 696e 7661 6c69 645f 7061 636b  len(invalid_pack
+00018fd0: 6574 5f69 6473 2920 3e20 303a 0a20 2020  et_ids) > 0:.   
+00018fe0: 2020 2020 2020 2020 2077 6172 6e69 6e67           warning
+00018ff0: 732e 7761 726e 2827 496e 7661 6c69 6420  s.warn('Invalid 
+00019000: 6669 7273 7420 7361 6d70 6c65 2873 2920  first sample(s) 
+00019010: 6465 7465 6374 6564 2069 6e20 6e63 7320  detected in ncs 
+00019020: 6669 6c65 270a 2020 2020 2020 2020 2020  file'.          
+00019030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019040: 2728 7061 636b 6574 2069 6428 7329 2025  '(packet id(s) %
+00019050: 6929 2120 5468 6973 2065 7272 6f72 2069  i)! This error i
+00019060: 7320 6967 6e6f 7265 6420 696e 270a 2020  s ignored in'.  
+00019070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019080: 2020 2020 2020 2020 2773 7562 7365 7175          'subsequ
+00019090: 656e 7420 726f 7574 696e 6573 2e27 2025  ent routines.' %
+000190a0: 2028 696e 7661 6c69 645f 7061 636b 6574   (invalid_packet
+000190b0: 5f69 6473 2929 0a20 2020 2020 2020 2020  _ids)).         
+000190c0: 2020 2073 656c 662e 7061 7261 6d65 7465     self.paramete
+000190d0: 7273 5f6e 6373 5b63 6861 6e6e 656c 5f69  rs_ncs[channel_i
+000190e0: 645d 5b0a 2020 2020 2020 2020 2020 2020  d][.            
+000190f0: 2020 2020 2769 6e76 616c 6964 5f66 6972      'invalid_fir
+00019100: 7374 5f73 616d 706c 6573 275d 203d 2069  st_samples'] = i
+00019110: 6e76 616c 6964 5f70 6163 6b65 745f 6964  nvalid_packet_id
+00019120: 730a 0a20 2020 2020 2020 2020 2020 2023  s..            #
+00019130: 2063 6865 636b 696e 6720 636f 6e73 6973   checking consis
+00019140: 7465 6e63 7920 6f66 2064 6174 6120 6172  tency of data ar
+00019150: 6f75 6e64 2063 6f72 7275 7074 6564 2070  ound corrupted p
+00019160: 6163 6b65 7420 7469 6d65 0a20 2020 2020  acket time.     
+00019170: 2020 2020 2020 2066 6f72 2069 6e76 616c         for inval
+00019180: 6964 5f70 6163 6b65 745f 6964 2069 6e20  id_packet_id in 
+00019190: 696e 7661 6c69 645f 7061 636b 6574 5f69  invalid_packet_i
+000191a0: 6473 3a0a 2020 2020 2020 2020 2020 2020  ds:.            
+000191b0: 2020 2020 6966 2069 6e76 616c 6964 5f70      if invalid_p
+000191c0: 6163 6b65 745f 6964 203c 2032 206f 7220  acket_id < 2 or 
+000191d0: 696e 7661 6c69 645f 7061 636b 6574 5f69  invalid_packet_i
+000191e0: 6420 3e20 6c65 6e28 0a20 2020 2020 2020  d > len(.       
+000191f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019200: 2066 696c 6568 616e 646c 6529 202d 2032   filehandle) - 2
+00019210: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00019220: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00019230: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
 00019240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019250: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00019260: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
-00019270: 2020 2020 2020 2020 2020 2020 2027 436f               'Co
-00019280: 7272 7570 7465 6420 6e63 7320 6461 7461  rrupted ncs data
-00019290: 2070 6163 6b65 7420 6174 2074 6865 2062   packet at the b
-000192a0: 6567 696e 6e69 6e67 270a 2020 2020 2020  eginning'.      
-000192b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000192c0: 2020 276f 7220 656e 6420 6f66 2066 696c    'or end of fil
-000192d0: 652e 2729 0a20 2020 2020 2020 2020 2020  e.').           
-000192e0: 2020 2020 2065 6c69 6620 2874 696d 6573       elif (times
-000192f0: 7461 6d70 735b 696e 7661 6c69 645f 7061  tamps[invalid_pa
-00019300: 636b 6574 5f69 6420 2b20 315d 202d 2074  cket_id + 1] - t
-00019310: 696d 6573 7461 6d70 735b 0a20 2020 2020  imestamps[.     
-00019320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019330: 2020 2069 6e76 616c 6964 5f70 6163 6b65     invalid_packe
-00019340: 745f 6964 202d 2031 5d20 213d 2032 202a  t_id - 1] != 2 *
-00019350: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00019360: 2020 2020 2020 2074 696d 6573 7461 6d70         timestamp
-00019370: 735b 696e 7661 6c69 645f 7061 636b 6574  s[invalid_packet
-00019380: 5f69 6420 2d20 315d 202d 2074 696d 6573  _id - 1] - times
-00019390: 7461 6d70 735b 0a20 2020 2020 2020 2020  tamps[.         
-000193a0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000193b0: 6e76 616c 6964 5f70 6163 6b65 745f 6964  nvalid_packet_id
-000193c0: 202d 2032 5d29 293a 0a20 2020 2020 2020   - 2])):.       
-000193d0: 2020 2020 2020 2020 2020 2020 2072 6169               rai
-000193e0: 7365 2056 616c 7565 4572 726f 7228 2753  se ValueError('S
-000193f0: 7461 7274 696e 6720 7469 6d65 7320 6f66  tarting times of
-00019400: 206e 6373 2064 6174 6120 7061 636b 6574   ncs data packet
-00019410: 7320 6172 6f75 6e64 270a 2020 2020 2020  s around'.      
-00019420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019430: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00019440: 636f 7272 7570 7465 6420 6461 7461 2070  corrupted data p
-00019450: 6163 6b65 7420 6172 6520 6e6f 7420 270a  acket are not '.
-00019460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019480: 2020 2020 2027 636f 6e73 6973 7465 6e74       'consistent
-00019490: 2127 290a 0a20 2020 2023 2053 7570 706c  !')..    # Suppl
-000194a0: 656d 656e 746f 7279 2046 756e 6374 696f  ementory Functio
-000194b0: 6e73 0a20 2020 2064 6566 2067 6574 5f63  ns.    def get_c
-000194c0: 6861 6e6e 656c 5f69 645f 6279 5f66 696c  hannel_id_by_fil
-000194d0: 655f 6e61 6d65 2873 656c 662c 2066 696c  e_name(self, fil
-000194e0: 656e 616d 6529 3a0a 2020 2020 2020 2020  ename):.        
-000194f0: 2222 220a 2020 2020 2020 2020 4368 6563  """.        Chec
-00019500: 6b69 6e67 2070 6172 616d 6574 6572 7320  king parameters 
-00019510: 6f66 204e 4353 2c20 4e53 4520 616e 6420  of NCS, NSE and 
-00019520: 4e54 5420 4669 6c65 7320 666f 7220 6769  NTT Files for gi
-00019530: 7665 6e20 6669 6c65 6e61 6d65 2061 6e64  ven filename and
-00019540: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00019550: 6368 616e 6e65 6c5f 6964 2069 6620 7265  channel_id if re
-00019560: 7375 6c74 2069 7320 636f 6e73 6973 7465  sult is consiste
-00019570: 6e74 0a20 2020 2020 2020 203a 7061 7261  nt.        :para
-00019580: 6d20 6669 6c65 6e61 6d65 3a0a 2020 2020  m filename:.    
-00019590: 2020 2020 3a72 6574 7572 6e3a 0a20 2020      :return:.   
-000195a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000195b0: 2063 6861 6e6e 656c 5f69 6473 203d 205b   channel_ids = [
-000195c0: 5d0a 2020 2020 2020 2020 6368 616e 6e65  ].        channe
-000195d0: 6c5f 6964 7320 2b3d 205b 6b20 666f 7220  l_ids += [k for 
-000195e0: 6b20 696e 2073 656c 662e 7061 7261 6d65  k in self.parame
-000195f0: 7465 7273 5f6e 6373 2069 660a 2020 2020  ters_ncs if.    
-00019600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019610: 2020 2020 7365 6c66 2e70 6172 616d 6574      self.paramet
-00019620: 6572 735f 6e63 735b 6b5d 5b27 6669 6c65  ers_ncs[k]['file
-00019630: 6e61 6d65 275d 203d 3d20 6669 6c65 6e61  name'] == filena
-00019640: 6d65 5d0a 2020 2020 2020 2020 6368 616e  me].        chan
-00019650: 6e65 6c5f 6964 7320 2b3d 205b 6b20 666f  nel_ids += [k fo
-00019660: 7220 6b20 696e 2073 656c 662e 7061 7261  r k in self.para
-00019670: 6d65 7465 7273 5f6e 7365 2069 660a 2020  meters_nse if.  
-00019680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019690: 2020 2020 2020 7365 6c66 2e70 6172 616d        self.param
-000196a0: 6574 6572 735f 6e73 655b 6b5d 5b27 6669  eters_nse[k]['fi
-000196b0: 6c65 6e61 6d65 275d 203d 3d20 6669 6c65  lename'] == file
-000196c0: 6e61 6d65 5d0a 2020 2020 2020 2020 6368  name].        ch
-000196d0: 616e 6e65 6c5f 6964 7320 2b3d 205b 6b20  annel_ids += [k 
-000196e0: 666f 7220 6b20 696e 2073 656c 662e 7061  for k in self.pa
-000196f0: 7261 6d65 7465 7273 5f6e 7474 2069 660a  rameters_ntt if.
-00019700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019710: 2020 2020 2020 2020 7365 6c66 2e70 6172          self.par
-00019720: 616d 6574 6572 735f 6e74 745b 6b5d 5b27  ameters_ntt[k]['
-00019730: 6669 6c65 6e61 6d65 275d 203d 3d20 6669  filename'] == fi
-00019740: 6c65 6e61 6d65 5d0a 2020 2020 2020 2020  lename].        
-00019750: 6966 206c 656e 286e 702e 756e 6971 7565  if len(np.unique
-00019760: 286e 702e 6173 6172 7261 7928 6368 616e  (np.asarray(chan
-00019770: 6e65 6c5f 6964 7329 2929 203d 3d20 313a  nel_ids))) == 1:
-00019780: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00019790: 7572 6e20 6368 616e 6e65 6c5f 6964 735b  urn channel_ids[
-000197a0: 305d 0a20 2020 2020 2020 2065 6c69 6620  0].        elif 
-000197b0: 6c65 6e28 6368 616e 6e65 6c5f 6964 7329  len(channel_ids)
-000197c0: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
-000197d0: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-000197e0: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
-000197f0: 2020 2020 2741 6d62 6967 756f 7573 2063      'Ambiguous c
-00019800: 6861 6e6e 656c 2069 6473 2064 6574 6563  hannel ids detec
-00019810: 7465 642e 2046 696c 656e 616d 6520 2573  ted. Filename %s
-00019820: 2069 7320 6173 736f 6369 6174 6564 270a   is associated'.
-00019830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019840: 2720 746f 2064 6966 6665 7265 6e74 2063  ' to different c
-00019850: 6861 6e6e 656c 7320 6f66 204e 4353 2061  hannels of NCS a
-00019860: 6e64 204e 5345 2061 6e64 204e 5454 2025  nd NSE and NTT %
-00019870: 7327 0a20 2020 2020 2020 2020 2020 2020  s'.             
-00019880: 2020 2027 2720 2520 2866 696c 656e 616d     '' % (filenam
-00019890: 652c 2063 6861 6e6e 656c 5f69 6473 2929  e, channel_ids))
-000198a0: 0a20 2020 2020 2020 2065 6c73 653a 2020  .        else:  
-000198b0: 2320 6966 2066 696c 656e 616d 6520 7761  # if filename wa
-000198c0: 7320 6e6f 7420 6465 7465 6374 6564 0a20  s not detected. 
-000198d0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000198e0: 6e20 4e6f 6e65 0a0a 2020 2020 6465 6620  n None..    def 
-000198f0: 6861 7368 6669 6c65 2873 656c 662c 2061  hashfile(self, a
-00019900: 6669 6c65 2c20 6861 7368 6572 2c20 626c  file, hasher, bl
-00019910: 6f63 6b73 697a 653d 3635 3533 3629 3a0a  ocksize=65536):.
-00019920: 2020 2020 2020 2020 6275 6620 3d20 6166          buf = af
-00019930: 696c 652e 7265 6164 2862 6c6f 636b 7369  ile.read(blocksi
-00019940: 7a65 290a 2020 2020 2020 2020 7768 696c  ze).        whil
-00019950: 6520 6c65 6e28 6275 6629 203e 2030 3a0a  e len(buf) > 0:.
-00019960: 2020 2020 2020 2020 2020 2020 6861 7368              hash
-00019970: 6572 2e75 7064 6174 6528 6275 6629 0a20  er.update(buf). 
-00019980: 2020 2020 2020 2020 2020 2062 7566 203d             buf =
-00019990: 2061 6669 6c65 2e72 6561 6428 626c 6f63   afile.read(bloc
-000199a0: 6b73 697a 6529 0a20 2020 2020 2020 2072  ksize).        r
-000199b0: 6574 7572 6e20 6861 7368 6572 2e64 6967  eturn hasher.dig
-000199c0: 6573 7428 290a 0a20 2020 2064 6566 2064  est()..    def d
-000199d0: 6174 6573 697a 6566 696c 6528 7365 6c66  atesizefile(self
-000199e0: 2c20 6669 6c65 6e61 6d65 293a 0a20 2020  , filename):.   
-000199f0: 2020 2020 2072 6574 7572 6e20 7374 7228       return str(
-00019a00: 6f73 2e70 6174 682e 6765 746d 7469 6d65  os.path.getmtime
-00019a10: 2866 696c 656e 616d 6529 2920 2b20 275f  (filename)) + '_
-00019a20: 2720 2b20 7374 7228 0a20 2020 2020 2020  ' + str(.       
-00019a30: 2020 2020 206f 732e 7061 7468 2e67 6574       os.path.get
-00019a40: 7369 7a65 2866 696c 656e 616d 6529 290a  size(filename)).
-00019a50: 0a20 2020 2064 6566 205f 6469 6167 6e6f  .    def _diagno
-00019a60: 7374 6963 5f70 7269 6e74 2873 656c 662c  stic_print(self,
-00019a70: 2074 6578 7429 3a0a 2020 2020 2020 2020   text):.        
-00019a80: 2727 270a 2020 2020 2020 2020 5072 696e  '''.        Prin
-00019a90: 7420 6120 6469 6167 6e6f 7374 6963 206d  t a diagnostic m
-00019aa0: 6573 7361 6765 2e0a 0a20 2020 2020 2020  essage...       
-00019ab0: 2041 7267 733a 0a20 2020 2020 2020 2020   Args:.         
-00019ac0: 2020 2074 6578 7420 2873 7472 696e 6729     text (string)
-00019ad0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00019ae0: 2020 4469 6167 6e6f 7374 6963 2074 6578    Diagnostic tex
-00019af0: 7420 746f 2070 7269 6e74 2e0a 0a20 2020  t to print...   
-00019b00: 2020 2020 2052 6574 7572 6e73 3a0a 2020       Returns:.  
-00019b10: 2020 2020 2020 2020 2020 2d0a 2020 2020            -.    
-00019b20: 2020 2020 2727 270a 0a20 2020 2020 2020      '''..       
-00019b30: 2069 6620 7365 6c66 2e5f 7072 696e 745f   if self._print_
-00019b40: 6469 6167 6e6f 7374 6963 3a0a 2020 2020  diagnostic:.    
-00019b50: 2020 2020 2020 2020 7072 696e 7428 274e          print('N
-00019b60: 6575 7261 6c79 6e78 494f 3a20 2720 2b20  euralynxIO: ' + 
-00019b70: 7465 7874 290a                           text).
+00019250: 2743 6f72 7275 7074 6564 206e 6373 2064  'Corrupted ncs d
+00019260: 6174 6120 7061 636b 6574 2061 7420 7468  ata packet at th
+00019270: 6520 6265 6769 6e6e 696e 6727 0a20 2020  e beginning'.   
+00019280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019290: 2020 2020 2027 6f72 2065 6e64 206f 6620       'or end of 
+000192a0: 6669 6c65 2e27 290a 2020 2020 2020 2020  file.').        
+000192b0: 2020 2020 2020 2020 656c 6966 2028 7469          elif (ti
+000192c0: 6d65 7374 616d 7073 5b69 6e76 616c 6964  mestamps[invalid
+000192d0: 5f70 6163 6b65 745f 6964 202b 2031 5d20  _packet_id + 1] 
+000192e0: 2d20 7469 6d65 7374 616d 7073 5b0a 2020  - timestamps[.  
+000192f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019300: 2020 2020 2020 696e 7661 6c69 645f 7061        invalid_pa
+00019310: 636b 6574 5f69 6420 2d20 315d 2021 3d20  cket_id - 1] != 
+00019320: 3220 2a20 280a 2020 2020 2020 2020 2020  2 * (.          
+00019330: 2020 2020 2020 2020 2020 7469 6d65 7374            timest
+00019340: 616d 7073 5b69 6e76 616c 6964 5f70 6163  amps[invalid_pac
+00019350: 6b65 745f 6964 202d 2031 5d20 2d20 7469  ket_id - 1] - ti
+00019360: 6d65 7374 616d 7073 5b0a 2020 2020 2020  mestamps[.      
+00019370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019380: 2020 696e 7661 6c69 645f 7061 636b 6574    invalid_packet
+00019390: 5f69 6420 2d20 325d 2929 3a0a 2020 2020  _id - 2])):.    
+000193a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000193b0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+000193c0: 2827 5374 6172 7469 6e67 2074 696d 6573  ('Starting times
+000193d0: 206f 6620 6e63 7320 6461 7461 2070 6163   of ncs data pac
+000193e0: 6b65 7473 2061 726f 756e 6427 0a20 2020  kets around'.   
+000193f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019410: 2020 2763 6f72 7275 7074 6564 2064 6174    'corrupted dat
+00019420: 6120 7061 636b 6574 2061 7265 206e 6f74  a packet are not
+00019430: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+00019440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019450: 2020 2020 2020 2020 2763 6f6e 7369 7374          'consist
+00019460: 656e 7421 2729 0a0a 2020 2020 2320 5375  ent!')..    # Su
+00019470: 7070 6c65 6d65 6e74 6f72 7920 4675 6e63  pplementory Func
+00019480: 7469 6f6e 730a 2020 2020 6465 6620 6765  tions.    def ge
+00019490: 745f 6368 616e 6e65 6c5f 6964 5f62 795f  t_channel_id_by_
+000194a0: 6669 6c65 5f6e 616d 6528 7365 6c66 2c20  file_name(self, 
+000194b0: 6669 6c65 6e61 6d65 293a 0a20 2020 2020  filename):.     
+000194c0: 2020 2022 2222 0a20 2020 2020 2020 2043     """.        C
+000194d0: 6865 636b 696e 6720 7061 7261 6d65 7465  hecking paramete
+000194e0: 7273 206f 6620 4e43 532c 204e 5345 2061  rs of NCS, NSE a
+000194f0: 6e64 204e 5454 2046 696c 6573 2066 6f72  nd NTT Files for
+00019500: 2067 6976 656e 2066 696c 656e 616d 6520   given filename 
+00019510: 616e 640a 2020 2020 2020 2020 7265 7475  and.        retu
+00019520: 726e 2063 6861 6e6e 656c 5f69 6420 6966  rn channel_id if
+00019530: 2072 6573 756c 7420 6973 2063 6f6e 7369   result is consi
+00019540: 7374 656e 740a 2020 2020 2020 2020 3a70  stent.        :p
+00019550: 6172 616d 2066 696c 656e 616d 653a 0a20  aram filename:. 
+00019560: 2020 2020 2020 203a 7265 7475 726e 3a0a         :return:.
+00019570: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00019580: 2020 2020 6368 616e 6e65 6c5f 6964 7320      channel_ids 
+00019590: 3d20 5b5d 0a20 2020 2020 2020 2063 6861  = [].        cha
+000195a0: 6e6e 656c 5f69 6473 202b 3d20 5b6b 2066  nnel_ids += [k f
+000195b0: 6f72 206b 2069 6e20 7365 6c66 2e70 6172  or k in self.par
+000195c0: 616d 6574 6572 735f 6e63 7320 6966 0a20  ameters_ncs if. 
+000195d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000195e0: 2020 2020 2020 2073 656c 662e 7061 7261         self.para
+000195f0: 6d65 7465 7273 5f6e 6373 5b6b 5d5b 2766  meters_ncs[k]['f
+00019600: 696c 656e 616d 6527 5d20 3d3d 2066 696c  ilename'] == fil
+00019610: 656e 616d 655d 0a20 2020 2020 2020 2063  ename].        c
+00019620: 6861 6e6e 656c 5f69 6473 202b 3d20 5b6b  hannel_ids += [k
+00019630: 2066 6f72 206b 2069 6e20 7365 6c66 2e70   for k in self.p
+00019640: 6172 616d 6574 6572 735f 6e73 6520 6966  arameters_nse if
+00019650: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019660: 2020 2020 2020 2020 2073 656c 662e 7061           self.pa
+00019670: 7261 6d65 7465 7273 5f6e 7365 5b6b 5d5b  rameters_nse[k][
+00019680: 2766 696c 656e 616d 6527 5d20 3d3d 2066  'filename'] == f
+00019690: 696c 656e 616d 655d 0a20 2020 2020 2020  ilename].       
+000196a0: 2063 6861 6e6e 656c 5f69 6473 202b 3d20   channel_ids += 
+000196b0: 5b6b 2066 6f72 206b 2069 6e20 7365 6c66  [k for k in self
+000196c0: 2e70 6172 616d 6574 6572 735f 6e74 7420  .parameters_ntt 
+000196d0: 6966 0a20 2020 2020 2020 2020 2020 2020  if.             
+000196e0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000196f0: 7061 7261 6d65 7465 7273 5f6e 7474 5b6b  parameters_ntt[k
+00019700: 5d5b 2766 696c 656e 616d 6527 5d20 3d3d  ]['filename'] ==
+00019710: 2066 696c 656e 616d 655d 0a20 2020 2020   filename].     
+00019720: 2020 2069 6620 6c65 6e28 6e70 2e75 6e69     if len(np.uni
+00019730: 7175 6528 6e70 2e61 7361 7272 6179 2863  que(np.asarray(c
+00019740: 6861 6e6e 656c 5f69 6473 2929 2920 3d3d  hannel_ids))) ==
+00019750: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+00019760: 7265 7475 726e 2063 6861 6e6e 656c 5f69  return channel_i
+00019770: 6473 5b30 5d0a 2020 2020 2020 2020 656c  ds[0].        el
+00019780: 6966 206c 656e 2863 6861 6e6e 656c 5f69  if len(channel_i
+00019790: 6473 2920 3e20 313a 0a20 2020 2020 2020  ds) > 1:.       
+000197a0: 2020 2020 2072 6169 7365 2056 616c 7565       raise Value
+000197b0: 4572 726f 7228 0a20 2020 2020 2020 2020  Error(.         
+000197c0: 2020 2020 2020 2027 416d 6269 6775 6f75         'Ambiguou
+000197d0: 7320 6368 616e 6e65 6c20 6964 7320 6465  s channel ids de
+000197e0: 7465 6374 6564 2e20 4669 6c65 6e61 6d65  tected. Filename
+000197f0: 2025 7320 6973 2061 7373 6f63 6961 7465   %s is associate
+00019800: 6427 0a20 2020 2020 2020 2020 2020 2020  d'.             
+00019810: 2020 2027 2074 6f20 6469 6666 6572 656e     ' to differen
+00019820: 7420 6368 616e 6e65 6c73 206f 6620 4e43  t channels of NC
+00019830: 5320 616e 6420 4e53 4520 616e 6420 4e54  S and NSE and NT
+00019840: 5420 2573 270a 2020 2020 2020 2020 2020  T %s'.          
+00019850: 2020 2020 2020 2727 2025 2028 6669 6c65        '' % (file
+00019860: 6e61 6d65 2c20 6368 616e 6e65 6c5f 6964  name, channel_id
+00019870: 7329 290a 2020 2020 2020 2020 656c 7365  s)).        else
+00019880: 3a20 2023 2069 6620 6669 6c65 6e61 6d65  :  # if filename
+00019890: 2077 6173 206e 6f74 2064 6574 6563 7465   was not detecte
+000198a0: 640a 2020 2020 2020 2020 2020 2020 7265  d.            re
+000198b0: 7475 726e 204e 6f6e 650a 0a20 2020 2064  turn None..    d
+000198c0: 6566 2068 6173 6866 696c 6528 7365 6c66  ef hashfile(self
+000198d0: 2c20 6166 696c 652c 2068 6173 6865 722c  , afile, hasher,
+000198e0: 2062 6c6f 636b 7369 7a65 3d36 3535 3336   blocksize=65536
+000198f0: 293a 0a20 2020 2020 2020 2062 7566 203d  ):.        buf =
+00019900: 2061 6669 6c65 2e72 6561 6428 626c 6f63   afile.read(bloc
+00019910: 6b73 697a 6529 0a20 2020 2020 2020 2077  ksize).        w
+00019920: 6869 6c65 206c 656e 2862 7566 2920 3e20  hile len(buf) > 
+00019930: 303a 0a20 2020 2020 2020 2020 2020 2068  0:.            h
+00019940: 6173 6865 722e 7570 6461 7465 2862 7566  asher.update(buf
+00019950: 290a 2020 2020 2020 2020 2020 2020 6275  ).            bu
+00019960: 6620 3d20 6166 696c 652e 7265 6164 2862  f = afile.read(b
+00019970: 6c6f 636b 7369 7a65 290a 2020 2020 2020  locksize).      
+00019980: 2020 7265 7475 726e 2068 6173 6865 722e    return hasher.
+00019990: 6469 6765 7374 2829 0a0a 2020 2020 6465  digest()..    de
+000199a0: 6620 6461 7465 7369 7a65 6669 6c65 2873  f datesizefile(s
+000199b0: 656c 662c 2066 696c 656e 616d 6529 3a0a  elf, filename):.
+000199c0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+000199d0: 7472 286f 732e 7061 7468 2e67 6574 6d74  tr(os.path.getmt
+000199e0: 696d 6528 6669 6c65 6e61 6d65 2929 202b  ime(filename)) +
+000199f0: 2027 5f27 202b 2073 7472 280a 2020 2020   '_' + str(.    
+00019a00: 2020 2020 2020 2020 6f73 2e70 6174 682e          os.path.
+00019a10: 6765 7473 697a 6528 6669 6c65 6e61 6d65  getsize(filename
+00019a20: 2929 0a0a 2020 2020 6465 6620 5f64 6961  ))..    def _dia
+00019a30: 676e 6f73 7469 635f 7072 696e 7428 7365  gnostic_print(se
+00019a40: 6c66 2c20 7465 7874 293a 0a20 2020 2020  lf, text):.     
+00019a50: 2020 2027 2727 0a20 2020 2020 2020 2050     '''.        P
+00019a60: 7269 6e74 2061 2064 6961 676e 6f73 7469  rint a diagnosti
+00019a70: 6320 6d65 7373 6167 652e 0a0a 2020 2020  c message...    
+00019a80: 2020 2020 4172 6773 3a0a 2020 2020 2020      Args:.      
+00019a90: 2020 2020 2020 7465 7874 2028 7374 7269        text (stri
+00019aa0: 6e67 293a 0a20 2020 2020 2020 2020 2020  ng):.           
+00019ab0: 2020 2020 2044 6961 676e 6f73 7469 6320       Diagnostic 
+00019ac0: 7465 7874 2074 6f20 7072 696e 742e 0a0a  text to print...
+00019ad0: 2020 2020 2020 2020 5265 7475 726e 733a          Returns:
+00019ae0: 0a20 2020 2020 2020 2020 2020 202d 0a20  .            -. 
+00019af0: 2020 2020 2020 2027 2727 0a0a 2020 2020         '''..    
+00019b00: 2020 2020 6966 2073 656c 662e 5f70 7269      if self._pri
+00019b10: 6e74 5f64 6961 676e 6f73 7469 633a 0a20  nt_diagnostic:. 
+00019b20: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00019b30: 2827 4e65 7572 616c 796e 7849 4f3a 2027  ('NeuralynxIO: '
+00019b40: 202b 2074 6578 7429 0a                    + text).
```

### Comparing `neo-0.8.0/neo/io/neuroshareapiio.py` & `neo-0.9.0/neo/io/neuroshareapiio.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,17 +5,14 @@
 Depends on: Neuroshare API 0.9.1, numpy 1.6.1, quantities 0.10.1
 
 Supported: Read
 
 Author: Andre Maia Chagas
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 # note neo.core needs only numpy and quantities
 import numpy as np
 import quantities as pq
 
 import os
 
 # check to see if the neuroshare bindings are properly imported
@@ -380,15 +377,15 @@
             # on triggered recordings it seems that only onset events are
             # recorded. On continuous recordings both onset(==1)
             # and offset(==255) seem to be recorded
             if onOrOff == 1:
                 # append the time stamp to them empty list
                 tempTimeStamp.append(tempData)
                 # create an event array
-        eva = Event(labels=np.array(tempNames, dtype="S"),
+        eva = Event(labels=np.array(tempNames, dtype="U"),
                     times=np.array(tempTimeStamp) * pq.s,
                     file_origin=self.filename,
                     description="the trigger events (without durations)")
         return eva
 
     def read_epoch(self, lazy=False,
                         channel_index=0,
@@ -430,10 +427,10 @@
                 tempData1, onOrOff = digEntity.get_data(i)
                 # if onOrOff == 255:
                 # pass
                 durations.append(tempData1 - tempData)
         epa = Epoch(file_origin=self.filename,
                     times=np.array(tempTimeStamp) * pq.s,
                     durations=np.array(durations) * pq.s,
-                    labels=np.array(tempNames, dtype="S"),
+                    labels=np.array(tempNames, dtype="U"),
                     description="digital events with duration")
         return epa
```

### Comparing `neo-0.8.0/neo/io/neurosharectypesio.py` & `neo-0.9.0/neo/io/neurosharectypesio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 NeuroshareIO is a wrap with ctypes of neuroshare DLLs.
 Neuroshare is a C API for reading neural data.
 Neuroshare also provides a Matlab and a Python API on top of that.
 
 Neuroshare is an open source API but each dll is provided directly by the vendor.
 The neo user have to download separtatly the dll on neurosharewebsite:
@@ -17,22 +16,14 @@
 
 """
 
 import sys
 import ctypes
 import os
 
-# file no longer exists in Python3
-try:
-    file
-except NameError:
-    import io
-
-    file = io.BufferedReader
-
 import numpy as np
 import quantities as pq
 
 from neo.io.baseio import BaseIO
 from neo.core import Segment, AnalogSignal, SpikeTrain, Event
 
 ns_OK = 0  # Function successful
@@ -192,15 +183,15 @@
                 for dwIndex in range(entityInfo.dwItemCount):
                     neuroshare.ns_GetEventData(hFile, dwEntityID, dwIndex,
                                                ctypes.byref(pdTimeStamp), ctypes.byref(pData),
                                                ctypes.sizeof(pData), ctypes.byref(pdwDataRetSize))
                     times.append(pdTimeStamp.value)
                     labels.append(str(pData.value))
                 ea.times = times * pq.s
-                ea.labels = np.array(labels, dtype='S')
+                ea.labels = np.array(labels, dtype='U')
 
                 seg.events.append(ea)
 
             # analog
             if entity_types[entityInfo.dwEntityType] == 'ns_ENTITY_ANALOG':
                 pAnalogInfo = ns_ANALOGINFO()
```

### Comparing `neo-0.8.0/neo/io/nixio.py` & `neo-0.9.0/neo/io/nixio.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 # Copyright (c) 2016, German Neuroinformatics Node (G-Node)
 #                     Achilleas Koutsou <achilleas.k@gmail.com>
 #
 # All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted under the terms of the BSD License. See
@@ -16,53 +15,55 @@
 only if the NIX file was created using this IO.
 
 Details on how the Neo object tree is mapped to NIX, as well as details on
 behaviours specific to this IO, can be found on the wiki of the G-Node fork of
 Neo: https://github.com/G-Node/python-neo/wiki
 """
 
-from __future__ import absolute_import
 
-import time
-from datetime import datetime
-try:
-    from collections.abc import Iterable
-except ImportError:
-    from collections import Iterable
+from datetime import date, time, datetime
+from collections.abc import Iterable
 from collections import OrderedDict
 import itertools
 from uuid import uuid4
 import warnings
 from distutils.version import LooseVersion as Version
+from itertools import chain
 
 import quantities as pq
 import numpy as np
 
 from .baseio import BaseIO
 from ..core import (Block, Segment, ChannelIndex, AnalogSignal,
-                    IrregularlySampledSignal, Epoch, Event, SpikeTrain, Unit)
+                    IrregularlySampledSignal, Epoch, Event, SpikeTrain,
+                    ImageSequence, Unit, ChannelView, Group)
 from ..io.proxyobjects import BaseProxy
 from ..version import version as neover
 
 try:
     import nixio as nix
 
     HAVE_NIX = True
 except ImportError:
     HAVE_NIX = False
 
-try:
-    string_types = basestring
-except NameError:
-    string_types = str
+
+datetime_types = (date, time, datetime)
 
 EMPTYANNOTATION = "EMPTYLIST"
 ARRAYANNOTATION = "ARRAYANNOTATION"
+DATETIMEANNOTATION = "DATETIME"
+DATEANNOTATION = "DATE"
+TIMEANNOTATION = "TIME"
 MIN_NIX_VER = Version("1.5.0")
 
+datefmt = "%Y-%m-%d"
+timefmt = "%H:%M:%S.%f"
+datetimefmt = datefmt + "T" + timefmt
+
 
 def stringify(value):
     if value is None:
         return value
     if isinstance(value, bytes):
         value = value.decode()
     return str(value)
@@ -79,18 +80,48 @@
 def units_to_string(pqunit):
     dim = str(pqunit.dimensionality)
     if dim.startswith("(") and dim.endswith(")"):
         return dim.strip("()")
     return dim
 
 
-def calculate_timestamp(dt):
+def dt_to_nix(dt):
+    """
+    Converts date, time, and datetime objects to an ISO string representation
+    appropriate for storing in NIX. Returns the converted value and the
+    annotation type definition for converting back to the original value
+    type.
+    """
     if isinstance(dt, datetime):
-        return int(time.mktime(dt.timetuple()))
-    return int(dt)
+        return dt.strftime(datetimefmt), DATETIMEANNOTATION
+    if isinstance(dt, date):
+        return dt.strftime(datefmt), DATEANNOTATION
+    if isinstance(dt, time):
+        return dt.strftime(timefmt), TIMEANNOTATION
+    # Unknown: returning as is
+    return dt
+
+
+def dt_from_nix(nixdt, annotype):
+    """
+    Inverse function of 'dt_to_nix()'. Requires the stored annotation type to
+    distinguish between the three source types (date, time, and datetime).
+    """
+    if annotype == DATEANNOTATION:
+        dt = datetime.strptime(nixdt, datefmt)
+        return dt.date()
+    if annotype == TIMEANNOTATION:
+        dt = datetime.strptime(nixdt, timefmt)
+        return dt.time()
+    if annotype == DATETIMEANNOTATION:
+        dt = datetime.strptime(nixdt, datetimefmt)
+        return dt
+    # Unknown type: older (or newer) IO version?
+    # Returning as is to avoid data loss.
+    return nixdt
 
 
 def check_nix_version():
     if not HAVE_NIX:
         raise Exception(
             "Failed to import NIX. "
             "The NixIO requires the Python package for NIX "
@@ -100,38 +131,37 @@
 
     # nixio version numbers have a 'v' prefix which breaks the comparison
     nixverstr = nix.__version__.lstrip("v")
     try:
         nixver = Version(nixverstr)
     except ValueError:
         warnings.warn(
-            "Could not understand NIX Python version {}. "
-            "The NixIO requires version {} of the Python package for NIX. "
-            "The IO may not work correctly.".format(nixverstr,
-                                                    str(MIN_NIX_VER))
+            f"Could not understand NIX Python version {nixverstr}. "
+            f"The NixIO requires version {MIN_NIX_VER} of the Python package for NIX. "
+            "The IO may not work correctly."
         )
         return
 
     if nixver < MIN_NIX_VER:
         raise Exception(
             "NIX version not supported. "
-            "The NixIO requires version {} or higher of the Python package "
-            "for NIX. Found version {}".format(str(MIN_NIX_VER), nixverstr)
+            f"The NixIO requires version {MIN_NIX_VER} or higher of the Python package "
+            f"for NIX. Found version {nixverstr}"
         )
 
 
 class NixIO(BaseIO):
     """
     Class for reading and writing NIX files.
     """
 
     is_readable = True
     is_writable = True
 
-    supported_objects = [Block, Segment, ChannelIndex,
+    supported_objects = [Block, Segment, ChannelIndex, Group, ChannelView,
                          AnalogSignal, IrregularlySampledSignal,
                          Epoch, Event, SpikeTrain, Unit]
     readable_objects = [Block]
     writeable_objects = [Block]
 
     name = "NIX"
     extensions = ["h5", "nix"]
@@ -149,17 +179,17 @@
         if mode == "ro":
             filemode = nix.FileMode.ReadOnly
         elif mode == "rw":
             filemode = nix.FileMode.ReadWrite
         elif mode == "ow":
             filemode = nix.FileMode.Overwrite
         else:
-            raise ValueError("Invalid mode specified '{}'. "
+            raise ValueError(f"Invalid mode specified '{mode}'. "
                              "Valid modes: 'ro' (ReadOnly)', 'rw' (ReadWrite),"
-                             " 'ow' (Overwrite).".format(mode))
+                             " 'ow' (Overwrite).")
         self.nix_file = nix.File.open(self.filename, filemode)
 
         if self.nix_file.mode == nix.FileMode.ReadOnly:
             self._file_version = '0.5.2'
             if "neo" in self.nix_file.sections:
                 self._file_version = self.nix_file.sections["neo"]["version"]
         elif self.nix_file.mode == nix.FileMode.ReadWrite:
@@ -177,14 +207,15 @@
 
         self._block_read_counter = 0
 
         # helper maps
         self._neo_map = dict()
         self._ref_map = dict()
         self._signal_map = dict()
+        self._view_map = dict()
 
         # _names_ok is used to guard against name check duplication
         self._names_ok = False
 
     def __enter__(self):
         return self
 
@@ -234,17 +265,15 @@
         elif neoname is not None:
             for blk in self.nix_file.blocks:
                 if ("neo_name" in blk.metadata
                         and blk.metadata["neo_name"] == neoname):
                     nix_block = blk
                     break
             else:
-                raise KeyError(
-                    "Block with Neo name '{}' does not exist".format(neoname)
-                )
+                raise KeyError(f"Block with Neo name '{neoname}' does not exist")
         else:
             index = self._block_read_counter
             if index >= len(self.nix_file.blocks):
                 return None
             nix_block = self.nix_file.blocks[index]
             self._block_read_counter += 1
 
@@ -257,80 +286,105 @@
         """
         for blk in self.nix_file.blocks:
             yield self._nix_to_neo_block(blk)
 
     def _nix_to_neo_block(self, nix_block):
         neo_attrs = self._nix_attr_to_neo(nix_block)
         neo_block = Block(**neo_attrs)
-        neo_block.rec_datetime = datetime.fromtimestamp(
-            nix_block.created_at
-        )
+        neo_block.rec_datetime = datetime.fromtimestamp(nix_block.created_at)
 
         # descend into Groups
+        groups_to_resolve = []
         for grp in nix_block.groups:
-            newseg = self._nix_to_neo_segment(grp)
-            neo_block.segments.append(newseg)
-            # parent reference
-            newseg.block = neo_block
+            if grp.type == "neo.segment":
+                newseg = self._nix_to_neo_segment(grp)
+                neo_block.segments.append(newseg)
+                # parent reference
+                newseg.block = neo_block
+            elif grp.type == "neo.group":
+                newgrp, parent_name = self._nix_to_neo_group(grp)
+                assert parent_name is None
+                neo_block.groups.append(newgrp)
+                # parent reference
+                newgrp.block = neo_block
+            elif grp.type == "neo.subgroup":
+                newgrp, parent_name = self._nix_to_neo_group(grp)
+                groups_to_resolve.append((newgrp, parent_name))
+            else:
+                raise Exception("Unexpected group type")
+
+        # link subgroups to parents
+        for newgrp, parent_name in groups_to_resolve:
+            parent = self._neo_map[parent_name]
+            parent.groups.append(newgrp)
 
         # find free floating (Groupless) signals and spiketrains
         blockdas = self._group_signals(nix_block.data_arrays)
         for name, das in blockdas.items():
             if name not in self._neo_map:
                 if das[0].type == "neo.analogsignal":
                     self._nix_to_neo_analogsignal(das)
                 elif das[0].type == "neo.irregularlysampledsignal":
                     self._nix_to_neo_irregularlysampledsignal(das)
+                elif das[0].type == "neo.imagesequence":
+                    self._nix_to_neo_imagesequence(das)
         for mt in nix_block.multi_tags:
             if mt.type == "neo.spiketrain" and mt.name not in self._neo_map:
                 self._nix_to_neo_spiketrain(mt)
 
         # descend into Sources
         for src in nix_block.sources:
             newchx = self._nix_to_neo_channelindex(src)
             neo_block.channel_indexes.append(newchx)
             # parent reference
             newchx.block = neo_block
 
+        # create object links
+        neo_block.create_relationship()
+
         # reset maps
         self._neo_map = dict()
         self._ref_map = dict()
         self._signal_map = dict()
+        self._view_map = dict()
 
         return neo_block
 
     def _nix_to_neo_segment(self, nix_group):
         neo_attrs = self._nix_attr_to_neo(nix_group)
         neo_segment = Segment(**neo_attrs)
-        neo_segment.rec_datetime = datetime.fromtimestamp(
-            nix_group.created_at
-        )
-
+        neo_segment.rec_datetime = datetime.fromtimestamp(nix_group.created_at)
         self._neo_map[nix_group.name] = neo_segment
 
         # this will probably get all the DAs anyway, but if we change any part
         # of the mapping to add other kinds of DataArrays to a group, such as
         # MultiTag positions and extents, this filter will be necessary
         dataarrays = list(filter(
             lambda da: da.type in ("neo.analogsignal",
-                                   "neo.irregularlysampledsignal"),
+                                   "neo.irregularlysampledsignal",
+                                   "neo.imagesequence",),
             nix_group.data_arrays))
         dataarrays = self._group_signals(dataarrays)
         # descend into DataArrays
         for name, das in dataarrays.items():
             if das[0].type == "neo.analogsignal":
                 newasig = self._nix_to_neo_analogsignal(das)
                 neo_segment.analogsignals.append(newasig)
                 # parent reference
                 newasig.segment = neo_segment
             elif das[0].type == "neo.irregularlysampledsignal":
                 newisig = self._nix_to_neo_irregularlysampledsignal(das)
                 neo_segment.irregularlysampledsignals.append(newisig)
                 # parent reference
                 newisig.segment = neo_segment
+            elif das[0].type == "neo.imagesequence":
+                new_imgseq = self._nix_to_neo_imagesequence(das)
+                neo_segment.imagesequences.append(new_imgseq)
+                # parent reference
+                new_imgseq.segment = neo_segment
 
         # descend into MultiTags
         for mtag in nix_group.multi_tags:
             if mtag.type == "neo.event":
                 newevent = self._nix_to_neo_event(mtag)
                 neo_segment.events.append(newevent)
                 # parent reference
@@ -344,33 +398,53 @@
                 newst = self._nix_to_neo_spiketrain(mtag)
                 neo_segment.spiketrains.append(newst)
                 # parent reference
                 newst.segment = neo_segment
 
         return neo_segment
 
+    def _nix_to_neo_group(self, nix_group):
+        neo_attrs = self._nix_attr_to_neo(nix_group)
+        parent_name = neo_attrs.pop("neo_parent", None)
+        neo_group = Group(**neo_attrs)
+        self._neo_map[nix_group.name] = neo_group
+        dataarrays = list(filter(
+            lambda da: da.type in ("neo.analogsignal",
+                                   "neo.irregularlysampledsignal",
+                                   "neo.imagesequence",),
+            nix_group.data_arrays))
+        dataarrays = self._group_signals(dataarrays)
+        # descend into DataArrays
+        for name in dataarrays:
+            obj = self._neo_map[name]
+            neo_group.add(obj)
+        # descend into MultiTags
+        for mtag in nix_group.multi_tags:
+            if mtag.type == "neo.channelview" and mtag.name not in self._neo_map:
+                self._nix_to_neo_channelview(mtag)
+            obj = self._neo_map[mtag.name]
+            neo_group.add(obj)
+
+        return neo_group, parent_name
+
     def _nix_to_neo_channelindex(self, nix_source):
         neo_attrs = self._nix_attr_to_neo(nix_source)
-        channels = list(self._nix_attr_to_neo(c)
-                        for c in nix_source.sources
+        channels = list(self._nix_attr_to_neo(c) for c in nix_source.sources
                         if c.type == "neo.channelindex")
-        neo_attrs["index"] = np.array([c["index"]
-                                       for c in channels])
+        neo_attrs["index"] = np.array([c["index"] for c in channels])
         if len(channels):
-            chan_names = list(c["neo_name"]
-                              for c in channels if "neo_name" in c)
-            chan_ids = list(c["channel_id"]
-                            for c in channels if "channel_id" in c)
+            chan_names = list(c["name"] for c in channels
+                              if "name" in c and c["name"] is not None)
+            chan_ids = list(c["channel_id"] for c in channels if "channel_id" in c)
             if chan_names:
                 neo_attrs["channel_names"] = chan_names
             if chan_ids:
                 neo_attrs["channel_ids"] = chan_ids
             if "coordinates" in channels[0]:
-                neo_attrs["coordinates"] = list(c["coordinates"]
-                                                for c in channels)
+                neo_attrs["coordinates"] = list(c["coordinates"] for c in channels)
 
         neo_chx = ChannelIndex(**neo_attrs)
         self._neo_map[nix_source.name] = neo_chx
 
         # create references to Signals
         signals = self._ref_map.get(nix_source.name, list())
         for sig in signals:
@@ -386,14 +460,23 @@
                 newunit = self._nix_to_neo_unit(src)
                 neo_chx.units.append(newunit)
                 # parent reference
                 newunit.channel_index = neo_chx
 
         return neo_chx
 
+    def _nix_to_neo_channelview(self, nix_mtag):
+        neo_attrs = self._nix_attr_to_neo(nix_mtag)
+        index = nix_mtag.positions
+        nix_name, = self._group_signals(nix_mtag.references).keys()
+        obj = self._neo_map[nix_name]
+        neo_chview = ChannelView(obj, index, **neo_attrs)
+        self._neo_map[nix_mtag.name] = neo_chview
+        return neo_chview
+
     def _nix_to_neo_unit(self, nix_source):
         neo_attrs = self._nix_attr_to_neo(nix_source)
         neo_unit = Unit(**neo_attrs)
         self._neo_map[nix_source.name] = neo_unit
 
         # create references to SpikeTrains
         neo_unit.spiketrains.extend(self._ref_map.get(nix_source.name, list()))
@@ -412,40 +495,76 @@
         metadata = nix_da_group[0].metadata
         neo_attrs["nix_name"] = metadata.name  # use the common base name
 
         unit = nix_da_group[0].unit
         signaldata = np.array([d[:] for d in nix_da_group]).transpose()
         signaldata = create_quantity(signaldata, unit)
         timedim = self._get_time_dimension(nix_da_group[0])
-        sampling_period = create_quantity(timedim.sampling_interval,
-                                          timedim.unit)
+        sampling_period = create_quantity(timedim.sampling_interval, timedim.unit)
         # t_start should have been added to neo_attrs via the NIX
         # object's metadata. This may not be present since in older
         # versions, we didn't store t_start in the metadata when it
         # wasn't necessary, such as when the timedim.offset and unit
         # did not require rescaling.
         if "t_start" in neo_attrs:
             t_start = neo_attrs["t_start"]
             del neo_attrs["t_start"]
         else:
             t_start = create_quantity(timedim.offset, timedim.unit)
 
-        neo_signal = AnalogSignal(
-            signal=signaldata, sampling_period=sampling_period,
-            t_start=t_start, **neo_attrs
-        )
+        neo_signal = AnalogSignal(signal=signaldata, sampling_period=sampling_period,
+                                  t_start=t_start, **neo_attrs)
         self._neo_map[neo_attrs["nix_name"]] = neo_signal
         # all DAs reference the same sources
         srcnames = list(src.name for src in nix_da_group[0].sources)
         for n in srcnames:
             if n not in self._ref_map:
                 self._ref_map[n] = list()
             self._ref_map[n].append(neo_signal)
         return neo_signal
 
+    def _nix_to_neo_imagesequence(self, nix_da_group):
+        """
+        Convert a group of NIX DataArrays to a Neo ImageSequence. This method
+        expects a list of data arrays that all represent the same,
+        multidimensional Neo ImageSequence object.
+
+        :param nix_da_group: a list of NIX DataArray objects
+        :return: a Neo ImageSequence object
+        """
+
+        neo_attrs = self._nix_attr_to_neo(nix_da_group[0])
+        metadata = nix_da_group[0].metadata
+        neo_attrs["nix_name"] = metadata.name  # use the common base name
+        unit = nix_da_group[0].unit
+        imgseq = np.array([d[:] for d in nix_da_group]).transpose()
+
+        sampling_rate = neo_attrs["sampling_rate"]
+        del neo_attrs["sampling_rate"]
+        spatial_scale = neo_attrs["spatial_scale"]
+        del neo_attrs["spatial_scale"]
+        if "t_start" in neo_attrs:
+            t_start = neo_attrs["t_start"]
+            del neo_attrs["t_start"]
+        else:
+            t_start = 0.0 * pq.ms
+
+        neo_seq = ImageSequence(image_data=imgseq, sampling_rate=sampling_rate,
+                                spatial_scale=spatial_scale, units=unit,
+                                t_start=t_start, **neo_attrs)
+
+        self._neo_map[neo_attrs["nix_name"]] = neo_seq
+        # all DAs reference the same sources
+        srcnames = list(src.name for src in nix_da_group[0].sources)
+        for n in srcnames:
+            if n not in self._ref_map:
+                self._ref_map[n] = list()
+            self._ref_map[n].append(neo_seq)
+        return neo_seq
+
     def _nix_to_neo_irregularlysampledsignal(self, nix_da_group):
         """
         Convert a group of NIX DataArrays to a Neo IrregularlySampledSignal.
         This method expects a list of data arrays that all represent the same,
         multidimensional Neo IrregularlySampledSignal object.
 
         :param nix_da_group: a list of NIX DataArray objects
@@ -457,47 +576,41 @@
 
         unit = nix_da_group[0].unit
         signaldata = np.array([d[:] for d in nix_da_group]).transpose()
         signaldata = create_quantity(signaldata, unit)
         timedim = self._get_time_dimension(nix_da_group[0])
         times = create_quantity(timedim.ticks, timedim.unit)
 
-        neo_signal = IrregularlySampledSignal(
-            signal=signaldata, times=times, **neo_attrs
-        )
+        neo_signal = IrregularlySampledSignal(signal=signaldata, times=times, **neo_attrs)
         self._neo_map[neo_attrs["nix_name"]] = neo_signal
         # all DAs reference the same sources
         srcnames = list(src.name for src in nix_da_group[0].sources)
         for n in srcnames:
             if n not in self._ref_map:
                 self._ref_map[n] = list()
             self._ref_map[n].append(neo_signal)
         return neo_signal
 
     def _nix_to_neo_event(self, nix_mtag):
         neo_attrs = self._nix_attr_to_neo(nix_mtag)
         time_unit = nix_mtag.positions.unit
         times = create_quantity(nix_mtag.positions, time_unit)
-        labels = np.array(nix_mtag.positions.dimensions[0].labels,
-                          dtype="S")
-
+        labels = np.array(nix_mtag.positions.dimensions[0].labels, dtype="U")
         neo_event = Event(times=times, labels=labels, **neo_attrs)
         self._neo_map[nix_mtag.name] = neo_event
         return neo_event
 
     def _nix_to_neo_epoch(self, nix_mtag):
         neo_attrs = self._nix_attr_to_neo(nix_mtag)
         time_unit = nix_mtag.positions.unit
         times = create_quantity(nix_mtag.positions, time_unit)
-        durations = create_quantity(nix_mtag.extents,
-                                    nix_mtag.extents.unit)
+        durations = create_quantity(nix_mtag.extents, nix_mtag.extents.unit)
 
         if len(nix_mtag.positions.dimensions[0].labels) > 0:
-            labels = np.array(nix_mtag.positions.dimensions[0].labels,
-                              dtype="S")
+            labels = np.array(nix_mtag.positions.dimensions[0].labels, dtype="U")
         else:
             labels = None
         neo_epoch = Epoch(times=times, durations=durations, labels=labels, **neo_attrs)
         self._neo_map[nix_mtag.name] = neo_epoch
         return neo_epoch
 
     def _nix_to_neo_spiketrain(self, nix_mtag):
@@ -507,22 +620,20 @@
 
         neo_spiketrain = SpikeTrain(times=times, **neo_attrs)
         if nix_mtag.features:
             wfda = nix_mtag.features[0].data
             wftime = self._get_time_dimension(wfda)
             neo_spiketrain.waveforms = create_quantity(wfda, wfda.unit)
             interval_units = wftime.unit
-            neo_spiketrain.sampling_period = create_quantity(
-                wftime.sampling_interval, interval_units
-            )
+            neo_spiketrain.sampling_period = create_quantity(wftime.sampling_interval,
+                                                             interval_units)
             left_sweep_units = wftime.unit
             if "left_sweep" in wfda.metadata:
-                neo_spiketrain.left_sweep = create_quantity(
-                    wfda.metadata["left_sweep"], left_sweep_units
-                )
+                neo_spiketrain.left_sweep = create_quantity(wfda.metadata["left_sweep"],
+                                                            left_sweep_units)
         self._neo_map[nix_mtag.name] = neo_spiketrain
 
         srcnames = list(src.name for src in nix_mtag.sources)
         for n in srcnames:
             if n not in self._ref_map:
                 self._ref_map[n] = list()
             self._ref_map[n].append(neo_spiketrain)
@@ -558,69 +669,70 @@
             if not self._names_ok:
                 # _names_ok guards against check duplication
                 # If it's False, it means write_block() was called directly
                 self._use_obj_names([block])
         if "nix_name" in block.annotations:
             nix_name = block.annotations["nix_name"]
         else:
-            nix_name = "neo.block.{}".format(self._generate_nix_name())
+            nix_name = f"neo.block.{self._generate_nix_name()}"
             block.annotate(nix_name=nix_name)
 
         if nix_name in self.nix_file.blocks:
             nixblock = self.nix_file.blocks[nix_name]
             del self.nix_file.blocks[nix_name]
             del self.nix_file.sections[nix_name]
 
         nixblock = self.nix_file.create_block(nix_name, "neo.block")
-        nixblock.metadata = self.nix_file.create_section(
-            nix_name, "neo.block.metadata"
-        )
+        nixblock.metadata = self.nix_file.create_section(nix_name, "neo.block.metadata")
         metadata = nixblock.metadata
         neoname = block.name if block.name is not None else ""
         metadata["neo_name"] = neoname
         nixblock.definition = block.description
         if block.rec_datetime:
-            nixblock.force_created_at(
-                calculate_timestamp(block.rec_datetime)
-            )
+            nix_rec_dt = int(block.rec_datetime.strftime("%s"))
+            nixblock.force_created_at(nix_rec_dt)
         if block.file_datetime:
-            fdt = calculate_timestamp(block.file_datetime)
-            metadata["file_datetime"] = fdt
+            fdt, annotype = dt_to_nix(block.file_datetime)
+            fdtprop = metadata.create_property("file_datetime", fdt)
+            fdtprop.definition = annotype
         if block.annotations:
             for k, v in block.annotations.items():
                 self._write_property(metadata, k, v)
 
         # descend into Segments
         for seg in block.segments:
             self._write_segment(seg, nixblock)
 
         # descend into ChannelIndexes
         for chx in block.channel_indexes:
             self._write_channelindex(chx, nixblock)
 
+        # descend into Neo Groups
+        for group in block.groups:
+            self._write_group(group, nixblock)
+
         self._create_source_links(block, nixblock)
 
     def _write_channelindex(self, chx, nixblock):
         """
         Convert the provided Neo ChannelIndex to a NIX Source and write it to
         the NIX file. For each index in the ChannelIndex object, a child
         NIX Source is also created.
 
         :param chx: The Neo ChannelIndex to be written
         :param nixblock: NIX Block where the Source will be created
         """
         if "nix_name" in chx.annotations:
             nix_name = chx.annotations["nix_name"]
         else:
-            nix_name = "neo.channelindex.{}".format(self._generate_nix_name())
+            nix_name = f"neo.channelindex.{self._generate_nix_name()}"
             chx.annotate(nix_name=nix_name)
         nixsource = nixblock.create_source(nix_name, "neo.channelindex")
-        nixsource.metadata = nixblock.metadata.create_section(
-            nix_name, "neo.channelindex.metadata"
-        )
+        nixsource.metadata = nixblock.metadata.create_section(nix_name,
+                                                              "neo.channelindex.metadata")
 
         metadata = nixsource.metadata
         neoname = chx.name if chx.name is not None else ""
         metadata["neo_name"] = neoname
         nixsource.definition = chx.description
         if chx.annotations:
             for k, v in chx.annotations.items():
@@ -628,19 +740,18 @@
 
         coordinates = chx.coordinates
         if coordinates is not None and np.ndim(coordinates) == 1:
             # support 1D coordinates for single ChannelIndex
             coordinates = [coordinates]
 
         for idx, channel in enumerate(chx.index):
-            channame = "{}.ChannelIndex{}".format(nix_name, idx)
+            channame = f"{nix_name}.ChannelIndex{idx}"
             nixchan = nixsource.create_source(channame, "neo.channelindex")
-            nixchan.metadata = nixsource.metadata.create_section(
-                nixchan.name, "neo.channelindex.metadata"
-            )
+            nixchan.metadata = nixsource.metadata.create_section(nixchan.name,
+                                                                 "neo.channelindex.metadata")
             nixchan.definition = nixsource.definition
             chanmd = nixchan.metadata
             chanmd["index"] = int(channel)
             if len(chx.channel_names):
                 neochanname = stringify(chx.channel_names[idx])
                 chanmd["neo_name"] = neochanname
             if len(chx.channel_ids):
@@ -653,43 +764,90 @@
                 chanprop = chanmd.create_property("coordinates", nixcoords)
                 chanprop.unit = coordunits
 
         # Descend into Units
         for unit in chx.units:
             self._write_unit(unit, nixsource)
 
+    def _write_channelview(self, chview, nixblock, nixgroup):
+        """
+        Convert the provided Neo ChannelView to a NIX MultiTag and write it to
+        the NIX file.
+
+        :param chx: The Neo ChannelView to be written
+        :param nixblock: NIX Block where the MultiTag will be created
+        """
+        if "nix_name" in chview.annotations:
+            nix_name = chview.annotations["nix_name"]
+        else:
+            nix_name = "neo.channelview.{}".format(self._generate_nix_name())
+            chview.annotate(nix_name=nix_name)
+
+        # create a new data array if this channelview was not saved yet
+        if not nix_name in self._view_map:
+            channels = nixblock.create_data_array(
+                "{}.index".format(nix_name), "neo.channelview.index", data=chview.index
+            )
+
+            nixmt = nixblock.create_multi_tag(nix_name, "neo.channelview",
+                                              positions=channels)
+
+            nixmt.metadata = nixgroup.metadata.create_section(
+                nix_name, "neo.channelview.metadata"
+            )
+            metadata = nixmt.metadata
+            neoname = chview.name if chview.name is not None else ""
+            metadata["neo_name"] = neoname
+            nixmt.definition = chview.description
+            if chview.annotations:
+                for k, v in chview.annotations.items():
+                    self._write_property(metadata, k, v)
+            self._view_map[nix_name] = nixmt
+
+            # link tag to the data array for the ChannelView's signal
+            if not ("nix_name" in chview.obj.annotations
+                    and chview.obj.annotations["nix_name"] in self._signal_map):
+                # the following restriction could be relaxed later
+                # but for a first pass this simplifies my mental model
+                raise Exception("Need to save signals before saving views")
+            nix_name = chview.obj.annotations["nix_name"]
+            nixmt.references.extend(self._signal_map[nix_name])
+        else:
+            nixmt = self._view_map[nix_name]
+
+        nixgroup.multi_tags.append(nixmt)
+
     def _write_segment(self, segment, nixblock):
         """
         Convert the provided Neo Segment to a NIX Group and write it to the
         NIX file.
 
         :param segment: Neo Segment to be written
         :param nixblock: NIX Block where the Group will be created
         """
         if "nix_name" in segment.annotations:
             nix_name = segment.annotations["nix_name"]
         else:
-            nix_name = "neo.segment.{}".format(self._generate_nix_name())
+            nix_name = f"neo.segment.{self._generate_nix_name()}"
             segment.annotate(nix_name=nix_name)
 
         nixgroup = nixblock.create_group(nix_name, "neo.segment")
-        nixgroup.metadata = nixblock.metadata.create_section(
-            nix_name, "neo.segment.metadata"
-        )
+        nixgroup.metadata = nixblock.metadata.create_section(nix_name,
+                                                             "neo.segment.metadata")
         metadata = nixgroup.metadata
         neoname = segment.name if segment.name is not None else ""
         metadata["neo_name"] = neoname
         nixgroup.definition = segment.description
         if segment.rec_datetime:
-            nixgroup.force_created_at(
-                calculate_timestamp(segment.rec_datetime)
-            )
+            nix_rec_dt = int(segment.rec_datetime.strftime("%s"))
+            nixgroup.force_created_at(nix_rec_dt)
         if segment.file_datetime:
-            fdt = calculate_timestamp(segment.file_datetime)
-            metadata["file_datetime"] = fdt
+            fdt, annotype = dt_to_nix(segment.file_datetime)
+            fdtprop = metadata.create_property("file_datetime", fdt)
+            fdtprop.definition = annotype
         if segment.annotations:
             for k, v in segment.annotations.items():
                 self._write_property(metadata, k, v)
 
         # write signals, events, epochs, and spiketrains
         for asig in segment.analogsignals:
             self._write_analogsignal(asig, nixblock, nixgroup)
@@ -698,62 +856,143 @@
         for event in segment.events:
             self._write_event(event, nixblock, nixgroup)
         for epoch in segment.epochs:
             self._write_epoch(epoch, nixblock, nixgroup)
         for spiketrain in segment.spiketrains:
             self._write_spiketrain(spiketrain, nixblock, nixgroup)
 
+        for imagesequence in segment.imagesequences:
+            self._write_imagesequence(imagesequence, nixblock, nixgroup)
+
+    def _write_group(self, neo_group, nixblock, parent=None):
+        """
+        Convert the provided Neo Group to a NIX Group and write it to the
+        NIX file.
+
+        :param neo_group: Neo Group to be written
+        :param nixblock: NIX Block where the NIX Group will be created
+        :param parent: for sub-groups, the parent Neo Group
+        """
+        if parent:
+            label = "neo.subgroup"
+            # note that the use of a different label for top-level groups and sub-groups is not
+            # strictly  necessary, the presence of the "neo_parent" annotation is sufficient.
+            # However, I think it adds clarity and helps in debugging and testing.
+        else:
+            label = "neo.group"
+
+        if "nix_name" in neo_group.annotations:
+            nix_name = neo_group.annotations["nix_name"]
+        else:
+            nix_name = "{}.{}".format(label, self._generate_nix_name())
+            neo_group.annotate(nix_name=nix_name)
+
+        nixgroup = nixblock.create_group(nix_name, label)
+        nixgroup.metadata = nixblock.metadata.create_section(
+            nix_name, f"{label}.metadata"
+        )
+        metadata = nixgroup.metadata
+        neoname = neo_group.name if neo_group.name is not None else ""
+        metadata["neo_name"] = neoname
+        if parent:
+            metadata["neo_parent"] = parent.annotations["nix_name"]
+        nixgroup.definition = neo_group.description
+        if neo_group.annotations:
+            for k, v in neo_group.annotations.items():
+                self._write_property(metadata, k, v)
+
+        # link signals and image sequences
+        objnames = []
+        for obj in chain(
+            neo_group.analogsignals,
+            neo_group.irregularlysampledsignals,
+            neo_group.imagesequences,
+        ):
+            if not ("nix_name" in obj.annotations
+                    and obj.annotations["nix_name"] in self._signal_map):
+                # the following restriction could be relaxed later
+                # but for a first pass this simplifies my mental model
+                raise Exception("Orphan signals/image sequences cannot be stored, needs to belong to a Segment")
+            objnames.append(obj.annotations["nix_name"])
+        for name in objnames:
+            for da in self._signal_map[name]:
+                nixgroup.data_arrays.append(da)
+
+        # link events, epochs and spiketrains
+        objnames = []
+        for obj in chain(
+            neo_group.events,
+            neo_group.epochs,
+            neo_group.spiketrains,
+        ):
+            if not ("nix_name" in obj.annotations
+                    and obj.annotations["nix_name"] in nixblock.multi_tags):
+                # the following restriction could be relaxed later
+                # but for a first pass this simplifies my mental model
+                raise Exception("Orphan epochs/events/spiketrains cannot be stored, needs to belong to a Segment")
+            objnames.append(obj.annotations["nix_name"])
+        for name in objnames:
+            mt = nixblock.multi_tags[name]
+            nixgroup.multi_tags.append(mt)
+
+        # save channel views
+        for chview in neo_group.channelviews:
+            self._write_channelview(chview, nixblock, nixgroup)
+
+        # save sub-groups
+        for subgroup in neo_group.groups:
+            self._write_group(subgroup, nixblock, parent=neo_group)
+
     def _write_analogsignal(self, anasig, nixblock, nixgroup):
         """
         Convert the provided ``anasig`` (AnalogSignal) to a list of NIX
         DataArray objects and write them to the NIX file. All DataArray objects
         created from the same AnalogSignal have their metadata section point to
         the same object.
 
         :param anasig: The Neo AnalogSignal to be written
         :param nixblock: NIX Block where the DataArrays will be created
         :param nixgroup: NIX Group where the DataArrays will be attached
         """
         if "nix_name" in anasig.annotations:
             nix_name = anasig.annotations["nix_name"]
         else:
-            nix_name = "neo.analogsignal.{}".format(self._generate_nix_name())
+            nix_name = f"neo.analogsignal.{self._generate_nix_name()}"
             anasig.annotate(nix_name=nix_name)
 
-        if "{}.0".format(nix_name) in nixblock.data_arrays and nixgroup:
+        if f"{nix_name}.0" in nixblock.data_arrays and nixgroup:
             # AnalogSignal is in multiple Segments.
             # Append DataArrays to Group and return.
             dalist = list()
             for idx in itertools.count():
-                daname = "{}.{}".format(nix_name, idx)
+                daname = f"{nix_name}.{idx}"
                 if daname in nixblock.data_arrays:
                     dalist.append(nixblock.data_arrays[daname])
                 else:
                     break
             nixgroup.data_arrays.extend(dalist)
             return
 
         if isinstance(anasig, BaseProxy):
             data = np.transpose(anasig.load()[:].magnitude)
         else:
             data = np.transpose(anasig[:].magnitude)
 
         parentmd = nixgroup.metadata if nixgroup else nixblock.metadata
-        metadata = parentmd.create_section(nix_name,
-                                           "neo.analogsignal.metadata")
+        metadata = parentmd.create_section(nix_name, "neo.analogsignal.metadata")
         nixdas = list()
         for idx, row in enumerate(data):
-            daname = "{}.{}".format(nix_name, idx)
-            da = nixblock.create_data_array(daname, "neo.analogsignal",
-                                            data=row)
+            daname = f"{nix_name}.{idx}"
+            da = nixblock.create_data_array(daname, "neo.analogsignal", data=row)
             da.metadata = metadata
             da.definition = anasig.description
             da.unit = units_to_string(anasig.units)
 
-            timedim = da.append_sampled_dimension(anasig.sampling_period.magnitude.item())
+            sampling_period = anasig.sampling_period.magnitude.item()
+            timedim = da.append_sampled_dimension(sampling_period)
             timedim.unit = units_to_string(anasig.sampling_period.units)
             tstart = anasig.t_start
             metadata["t_start"] = tstart.magnitude.item()
             metadata.props["t_start"].unit = units_to_string(tstart.units)
             timedim.offset = tstart.rescale(timedim.unit).magnitude.item()
             timedim.label = "time"
 
@@ -765,16 +1004,84 @@
         metadata["neo_name"] = neoname
         if anasig.annotations:
             for k, v in anasig.annotations.items():
                 self._write_property(metadata, k, v)
         if anasig.array_annotations:
             for k, v in anasig.array_annotations.items():
                 p = self._write_property(metadata, k, v)
-                p.definition = ARRAYANNOTATION
+                p.type = ARRAYANNOTATION
+
+        self._signal_map[nix_name] = nixdas
+
+    def _write_imagesequence(self, imgseq, nixblock, nixgroup):
+        """
+       Convert the provided ``imgseq`` (ImageSequence) to a list of NIX
+       DataArray objects and write them to the NIX file. All DataArray objects
+       created from the same ImageSequence have their metadata section point to
+       the same object.
+
+       :param anasig: The Neo ImageSequence to be written
+       :param nixblock: NIX Block where the DataArrays will be created
+       :param nixgroup: NIX Group where the DataArrays will be attached
+       """
+
+        if "nix_name" in imgseq.annotations:
+            nix_name = imgseq.annotations["nix_name"]
+        else:
+            nix_name = f"neo.imagesequence.{self._generate_nix_name()}"
+            imgseq.annotate(nix_name=nix_name)
+
+        if f"{nix_name}.0" in nixblock.data_arrays and nixgroup:
+
+            dalist = list()
+            for idx in itertools.count():
+                daname = f"{nix_name}.{idx}"
+                if daname in nixblock.data_arrays:
+                    dalist.append(nixblock.data_arrays[daname])
+                else:
+                    break
+            nixgroup.data_arrays.extend(dalist)
+            return
+
+        if isinstance(imgseq, BaseProxy):
+            data = np.transpose(imgseq.load()[:].magnitude)
+        else:
+            data = np.transpose(imgseq[:].magnitude)
+
+        parentmd = nixgroup.metadata if nixgroup else nixblock.metadata
+        metadata = parentmd.create_section(nix_name, "neo.imagesequence.metadata")
 
+        nixdas = list()
+        for idx, row in enumerate(data):
+            daname = f"{nix_name}.{idx}"
+            da = nixblock.create_data_array(daname, "neo.imagesequence", data=row)
+
+            da.metadata = metadata
+            da.definition = imgseq.description
+            da.unit = units_to_string(imgseq.units)
+
+            metadata["sampling_rate"] = imgseq.sampling_rate.magnitude.item()
+            units = imgseq.sampling_rate.units
+            metadata.props["sampling_rate"].unit = units_to_string(units)
+            metadata["spatial_scale"] = imgseq.spatial_scale.magnitude.item()
+            units = imgseq.spatial_scale.units
+            metadata.props["spatial_scale"].unit = units_to_string(units)
+            metadata["t_start"] = imgseq.t_start.magnitude.item()
+            units = imgseq.t_start.units
+            metadata.props["t_start"].unit = units_to_string(units)
+
+            nixdas.append(da)
+            if nixgroup:
+                nixgroup.data_arrays.append(da)
+
+        neoname = imgseq.name if imgseq.name is not None else ""
+        metadata["neo_name"] = neoname
+        if imgseq.annotations:
+            for k, v in imgseq.annotations.items():
+                self._write_property(metadata, k, v)
         self._signal_map[nix_name] = nixdas
 
     def _write_irregularlysampledsignal(self, irsig, nixblock, nixgroup):
         """
         Convert the provided ``irsig`` (IrregularlySampledSignal) to a list of
         NIX DataArray objects and write them to the NIX file at the location.
         All DataArray objects created from the same IrregularlySampledSignal
@@ -783,47 +1090,41 @@
         :param irsig: The Neo IrregularlySampledSignal to be written
         :param nixblock: NIX Block where the DataArrays will be created
         :param nixgroup: NIX Group where the DataArrays will be attached
         """
         if "nix_name" in irsig.annotations:
             nix_name = irsig.annotations["nix_name"]
         else:
-            nix_name = "neo.irregularlysampledsignal.{}".format(
-                self._generate_nix_name()
-            )
+            nix_name = f"neo.irregularlysampledsignal.{self._generate_nix_name()}"
             irsig.annotate(nix_name=nix_name)
 
-        if "{}.0".format(nix_name) in nixblock.data_arrays and nixgroup:
+        if f"{nix_name}.0" in nixblock.data_arrays and nixgroup:
             # IrregularlySampledSignal is in multiple Segments.
             # Append DataArrays to Group and return.
             dalist = list()
             for idx in itertools.count():
-                daname = "{}.{}".format(nix_name, idx)
+                daname = f"{nix_name}.{idx}"
                 if daname in nixblock.data_arrays:
                     dalist.append(nixblock.data_arrays[daname])
                 else:
                     break
             nixgroup.data_arrays.extend(dalist)
             return
 
         if isinstance(irsig, BaseProxy):
             data = np.transpose(irsig.load()[:].magnitude)
         else:
             data = np.transpose(irsig[:].magnitude)
 
         parentmd = nixgroup.metadata if nixgroup else nixblock.metadata
-        metadata = parentmd.create_section(
-            nix_name, "neo.irregularlysampledsignal.metadata"
-        )
+        metadata = parentmd.create_section(nix_name, "neo.irregularlysampledsignal.metadata")
         nixdas = list()
         for idx, row in enumerate(data):
-            daname = "{}.{}".format(nix_name, idx)
-            da = nixblock.create_data_array(
-                daname, "neo.irregularlysampledsignal", data=row
-            )
+            daname = f"{nix_name}.{idx}"
+            da = nixblock.create_data_array(daname, "neo.irregularlysampledsignal", data=row)
             da.metadata = metadata
             da.definition = irsig.description
             da.unit = units_to_string(irsig.units)
 
             timedim = da.append_range_dimension(irsig.times.magnitude)
             timedim.unit = units_to_string(irsig.times.units)
             timedim.label = "time"
@@ -836,15 +1137,15 @@
         metadata["neo_name"] = neoname
         if irsig.annotations:
             for k, v in irsig.annotations.items():
                 self._write_property(metadata, k, v)
         if irsig.array_annotations:
             for k, v in irsig.array_annotations.items():
                 p = self._write_property(metadata, k, v)
-                p.definition = ARRAYANNOTATION
+                p.type = ARRAYANNOTATION
 
         self._signal_map[nix_name] = nixdas
 
     def _write_event(self, event, nixblock, nixgroup):
         """
         Convert the provided Neo Event to a NIX MultiTag and write it to the
         NIX file.
@@ -852,54 +1153,49 @@
         :param event: The Neo Event to be written
         :param nixblock: NIX Block where the MultiTag will be created
         :param nixgroup: NIX Group where the MultiTag will be attached
         """
         if "nix_name" in event.annotations:
             nix_name = event.annotations["nix_name"]
         else:
-            nix_name = "neo.event.{}".format(self._generate_nix_name())
+            nix_name = f"neo.event.{self._generate_nix_name()}"
             event.annotate(nix_name=nix_name)
 
         if nix_name in nixblock.multi_tags:
             # Event is in multiple Segments. Append to Group and return.
             mt = nixblock.multi_tags[nix_name]
             nixgroup.multi_tags.append(mt)
             return
 
         if isinstance(event, BaseProxy):
             event = event.load()
 
         times = event.times.magnitude
         units = units_to_string(event.times.units)
         labels = event.labels
-        timesda = nixblock.create_data_array(
-            "{}.times".format(nix_name), "neo.event.times", data=times
-        )
+        timesda = nixblock.create_data_array(f"{nix_name}.times", "neo.event.times", data=times)
         timesda.unit = units
-        nixmt = nixblock.create_multi_tag(nix_name, "neo.event",
-                                          positions=timesda)
+        nixmt = nixblock.create_multi_tag(nix_name, "neo.event", positions=timesda)
 
-        nixmt.metadata = nixgroup.metadata.create_section(
-            nix_name, "neo.event.metadata"
-        )
+        nixmt.metadata = nixgroup.metadata.create_section(nix_name, "neo.event.metadata")
         metadata = nixmt.metadata
 
         labeldim = timesda.append_set_dimension()
         labeldim.labels = labels
 
         neoname = event.name if event.name is not None else ""
         metadata["neo_name"] = neoname
         nixmt.definition = event.description
         if event.annotations:
             for k, v in event.annotations.items():
                 self._write_property(metadata, k, v)
         if event.array_annotations:
             for k, v in event.array_annotations.items():
                 p = self._write_property(metadata, k, v)
-                p.definition = ARRAYANNOTATION
+                p.type = ARRAYANNOTATION
 
         nixgroup.multi_tags.append(nixmt)
 
         # reference all AnalogSignals and IrregularlySampledSignals in Group
         for da in nixgroup.data_arrays:
             if da.type in ("neo.analogsignal", "neo.irregularlysampledsignal"):
                 nixmt.references.append(da)
@@ -912,15 +1208,15 @@
         :param epoch: The Neo Epoch to be written
         :param nixblock: NIX Block where the MultiTag will be created
         :param nixgroup: NIX Group where the MultiTag will be attached
         """
         if "nix_name" in epoch.annotations:
             nix_name = epoch.annotations["nix_name"]
         else:
-            nix_name = "neo.epoch.{}".format(self._generate_nix_name())
+            nix_name = f"neo.epoch.{self._generate_nix_name()}"
             epoch.annotate(nix_name=nix_name)
 
         if nix_name in nixblock.multi_tags:
             # Epoch is in multiple Segments. Append to Group and return.
             mt = nixblock.multi_tags[nix_name]
             nixgroup.multi_tags.append(mt)
             return
@@ -928,47 +1224,39 @@
         if isinstance(epoch, BaseProxy):
             epoch = epoch.load()
         times = epoch.times.magnitude
         tunits = units_to_string(epoch.times.units)
         durations = epoch.durations.magnitude
         dunits = units_to_string(epoch.durations.units)
 
-
-        timesda = nixblock.create_data_array(
-            "{}.times".format(nix_name), "neo.epoch.times", data=times
-        )
+        timesda = nixblock.create_data_array(f"{nix_name}.times", "neo.epoch.times", data=times)
         timesda.unit = tunits
-        nixmt = nixblock.create_multi_tag(nix_name, "neo.epoch",
-                                          positions=timesda)
+        nixmt = nixblock.create_multi_tag(nix_name, "neo.epoch", positions=timesda)
 
-        durada = nixblock.create_data_array(
-            "{}.durations".format(nix_name), "neo.epoch.durations",
-            data=durations
-        )
+        durada = nixblock.create_data_array(f"{nix_name}.durations", "neo.epoch.durations",
+                                            data=durations)
         durada.unit = dunits
         nixmt.extents = durada
 
-        nixmt.metadata = nixgroup.metadata.create_section(
-            nix_name, "neo.epoch.metadata"
-        )
+        nixmt.metadata = nixgroup.metadata.create_section(nix_name, "neo.epoch.metadata")
         metadata = nixmt.metadata
 
         labeldim = timesda.append_set_dimension()
         labeldim.labels = epoch.labels
 
         neoname = epoch.name if epoch.name is not None else ""
         metadata["neo_name"] = neoname
         nixmt.definition = epoch.description
         if epoch.annotations:
             for k, v in epoch.annotations.items():
                 self._write_property(metadata, k, v)
         if epoch.array_annotations:
             for k, v in epoch.array_annotations.items():
                 p = self._write_property(metadata, k, v)
-                p.definition = ARRAYANNOTATION
+                p.type = ARRAYANNOTATION
 
         nixgroup.multi_tags.append(nixmt)
 
         # reference all AnalogSignals and IrregularlySampledSignals in Group
         for da in nixgroup.data_arrays:
             if da.type in ("neo.analogsignal", "neo.irregularlysampledsignal"):
                 nixmt.references.append(da)
@@ -981,15 +1269,15 @@
         :param spiketrain: The Neo SpikeTrain to be written
         :param nixblock: NIX Block where the MultiTag will be created
         :param nixgroup: NIX Group where the MultiTag will be attached
         """
         if "nix_name" in spiketrain.annotations:
             nix_name = spiketrain.annotations["nix_name"]
         else:
-            nix_name = "neo.spiketrain.{}".format(self._generate_nix_name())
+            nix_name = f"neo.spiketrain.{self._generate_nix_name()}"
             spiketrain.annotate(nix_name=nix_name)
 
         if nix_name in nixblock.multi_tags and nixgroup:
             # SpikeTrain is in multiple Segments. Append to Group and return.
             mt = nixblock.multi_tags[nix_name]
             nixgroup.multi_tags.append(mt)
             return
@@ -997,23 +1285,21 @@
         if isinstance(spiketrain, BaseProxy):
             spiketrain = spiketrain.load()
 
         times = spiketrain.times.magnitude
         tunits = units_to_string(spiketrain.times.units)
         waveforms = spiketrain.waveforms
 
-        timesda = nixblock.create_data_array("{}.times".format(nix_name),
-                                             "neo.spiketrain.times", data=times)
+        timesda = nixblock.create_data_array(f"{nix_name}.times", "neo.spiketrain.times",
+                                             data=times)
         timesda.unit = tunits
-        nixmt = nixblock.create_multi_tag(nix_name, "neo.spiketrain",
-                                          positions=timesda)
+        nixmt = nixblock.create_multi_tag(nix_name, "neo.spiketrain", positions=timesda)
 
         parentmd = nixgroup.metadata if nixgroup else nixblock.metadata
-        nixmt.metadata = parentmd.create_section(nix_name,
-                                                 "neo.spiketrain.metadata")
+        nixmt.metadata = parentmd.create_section(nix_name, "neo.spiketrain.metadata")
         metadata = nixmt.metadata
 
         neoname = spiketrain.name if spiketrain.name is not None else ""
         metadata["neo_name"] = neoname
         nixmt.definition = spiketrain.description
 
         self._write_property(metadata, "t_start", spiketrain.t_start)
@@ -1021,66 +1307,56 @@
 
         if spiketrain.annotations:
             for k, v in spiketrain.annotations.items():
                 self._write_property(metadata, k, v)
         if spiketrain.array_annotations:
             for k, v in spiketrain.array_annotations.items():
                 p = self._write_property(metadata, k, v)
-                p.definition = ARRAYANNOTATION
+                p.type = ARRAYANNOTATION
 
         if nixgroup:
             nixgroup.multi_tags.append(nixmt)
 
         if waveforms is not None:
             wfdata = list(wf.magnitude for wf in
-                          list(wfgroup for wfgroup in
-                               spiketrain.waveforms))
+                          list(wfgroup for wfgroup in spiketrain.waveforms))
             wfunits = units_to_string(spiketrain.waveforms.units)
-            wfda = nixblock.create_data_array(
-                "{}.waveforms".format(nix_name), "neo.waveforms",
-                data=wfdata
-            )
+            wfda = nixblock.create_data_array(f"{nix_name}.waveforms", "neo.waveforms",
+                                              data=wfdata)
             wfda.unit = wfunits
-            wfda.metadata = nixmt.metadata.create_section(
-                wfda.name, "neo.waveforms.metadata"
-            )
+            wfda.metadata = nixmt.metadata.create_section(wfda.name, "neo.waveforms.metadata")
             nixmt.create_feature(wfda, nix.LinkType.Indexed)
             # TODO: Move time dimension first for PR #457
             # https://github.com/NeuralEnsemble/python-neo/pull/457
             wfda.append_set_dimension()
             wfda.append_set_dimension()
-            wftime = wfda.append_sampled_dimension(
-                spiketrain.sampling_period.magnitude.item()
-            )
+            wftime = wfda.append_sampled_dimension(spiketrain.sampling_period.magnitude.item())
             wftime.unit = units_to_string(spiketrain.sampling_period.units)
             wftime.label = "time"
 
             if spiketrain.left_sweep is not None:
-                self._write_property(wfda.metadata, "left_sweep",
-                                     spiketrain.left_sweep)
+                self._write_property(wfda.metadata, "left_sweep", spiketrain.left_sweep)
 
     def _write_unit(self, neounit, nixchxsource):
         """
         Convert the provided Neo Unit to a NIX Source and write it to the
         NIX file.
 
         :param neounit: The Neo Unit to be written
         :param nixchxsource: NIX Source (ChannelIndex) where the new Source
         (Unit) will be created
         """
         if "nix_name" in neounit.annotations:
             nix_name = neounit.annotations["nix_name"]
         else:
-            nix_name = "neo.unit.{}".format(self._generate_nix_name())
+            nix_name = f"neo.unit.{self._generate_nix_name()}"
             neounit.annotate(nix_name=nix_name)
-        nixunitsource = nixchxsource.create_source(nix_name,
-                                                   "neo.unit")
-        nixunitsource.metadata = nixchxsource.metadata.create_section(
-            nix_name, "neo.unit.metadata"
-        )
+        nixunitsource = nixchxsource.create_source(nix_name, "neo.unit")
+        nixunitsource.metadata = nixchxsource.metadata.create_section(nix_name,
+                                                                      "neo.unit.metadata")
         metadata = nixunitsource.metadata
         neoname = neounit.name if neounit.name is not None else ""
         metadata["neo_name"] = neoname
         nixunitsource.definition = neounit.description
         if neounit.annotations:
             for k, v in neounit.annotations.items():
                 self._write_property(metadata, k, v)
@@ -1154,17 +1430,19 @@
 
         if isinstance(v, pq.Quantity):
             if len(v.shape):
                 section.create_property(name, tuple(v.magnitude))
             else:
                 section.create_property(name, v.magnitude.item())
             section.props[name].unit = str(v.dimensionality)
-        elif isinstance(v, datetime):
-            section.create_property(name, calculate_timestamp(v))
-        elif isinstance(v, string_types):
+        elif isinstance(v, datetime_types):
+            value, annotype = dt_to_nix(v)
+            prop = section.create_property(name, value)
+            prop.definition = annotype
+        elif isinstance(v, str):
             if len(v):
                 section.create_property(name, v)
             else:
                 section.create_property(name, nix.DataType.String)
         elif isinstance(v, bytes):
             section.create_property(name, v.decode())
         elif isinstance(v, Iterable):
@@ -1179,31 +1457,30 @@
                 definition = EMPTYANNOTATION
             elif hasattr(v, "ndim") and v.ndim == 0:
                 values = v.item()
                 if isinstance(v, pq.Quantity):
                     unit = str(v.dimensionality)
             else:
                 for item in v:
-                    if isinstance(item, string_types):
+                    if isinstance(item, str):
                         item = item
                     elif isinstance(item, pq.Quantity):
                         unit = str(item.dimensionality)
                         item = item.magnitude.item()
                     elif isinstance(item, Iterable):
                         self.logger.warn("Multidimensional arrays and nested "
                                          "containers are not currently "
                                          "supported when writing to NIX.")
                         return None
                     else:
                         item = item
                     values.append(item)
             section.create_property(name, values)
             section.props[name].unit = unit
-            if definition:
-                section.props[name].definition = definition
+            section.props[name].definition = definition
         elif type(v).__module__ == "numpy":
             section.create_property(name, v.item())
         else:
             section.create_property(name, v)
         return section.props[name]
 
     @staticmethod
@@ -1230,30 +1507,27 @@
                 if not len(values):
                     if prop.definition == EMPTYANNOTATION:
                         values = list()
                     elif prop.data_type == nix.DataType.String:
                         values = ""
                 elif len(values) == 1:
                     values = values[0]
-                elif prop.definition == ARRAYANNOTATION:
+                if prop.definition in (DATEANNOTATION, TIMEANNOTATION, DATETIMEANNOTATION):
+                    values = dt_from_nix(values, prop.definition)
+                if prop.type == ARRAYANNOTATION:
                     if 'array_annotations' in neo_attrs:
                         neo_attrs['array_annotations'][prop.name] = values
                     else:
                         neo_attrs['array_annotations'] = {prop.name: values}
                 else:
-                    values = list(values)
-                neo_attrs[prop.name] = values
+                    neo_attrs[prop.name] = values
         # since the 'neo_name' NIX property becomes the actual object's name,
         # there's no reason to keep it in the annotations
         neo_attrs["name"] = stringify(neo_attrs.pop("neo_name", None))
 
-        if "file_datetime" in neo_attrs:
-            neo_attrs["file_datetime"] = datetime.fromtimestamp(
-                neo_attrs["file_datetime"]
-            )
         return neo_attrs
 
     @staticmethod
     def _group_signals(dataarrays):
         """
         Groups data arrays that were generated by the same Neo Signal object.
         The collection can contain both  AnalogSignals and
@@ -1277,102 +1551,90 @@
     def _get_time_dimension(obj):
         for dim in obj.dimensions:
             if hasattr(dim, "label") and dim.label == "time":
                 return dim
         return None
 
     def _use_obj_names(self, blocks):
-
         errmsg = "use_obj_names enabled: found conflict or anonymous object"
-
         allobjs = []
 
         def check_unique(objs):
             names = list(o.name for o in objs)
             if None in names or "" in names:
                 raise ValueError(names)
             if len(names) != len(set(names)):
                 self._names_ok = False
                 raise ValueError(names)
             # collect objs if ok
             allobjs.extend(objs)
 
         try:
             check_unique(blocks)
-        except ValueError as ve:
-            raise ValueError("{} in Blocks {}".format(errmsg, ve))
+        except ValueError as exc:
+            raise ValueError(f"{errmsg} in Blocks") from exc
 
         for blk in blocks:
             try:
                 # Segments
                 check_unique(blk.segments)
-            except ValueError as ve:
-                raise ValueError("{} at Block '{}' > segments > "
-                                 "{}".format(errmsg, blk.name, ve))
+            except ValueError as exc:
+                raise ValueError(f"{errmsg} at Block '{blk.name}' > segments") from exc
 
             # collect all signals in all segments
             signals = []
             # collect all events, epochs, and spiketrains in all segments
             eests = []
             for seg in blk.segments:
                 signals.extend(seg.analogsignals)
                 signals.extend(seg.irregularlysampledsignals)
+                signals.extend(seg.imagesequences)
                 eests.extend(seg.events)
                 eests.extend(seg.epochs)
                 eests.extend(seg.spiketrains)
 
             try:
                 # AnalogSignals and IrregularlySampledSignals
                 check_unique(signals)
-            except ValueError as ve:
-                raise ValueError(
-                    "{} in Signal names "
-                    "of Block '{}' {}".format(errmsg, blk.name, ve)
-                )
+            except ValueError as exc:
+                raise ValueError(f"{errmsg} in Signal names of Block '{blk.name}'") from exc
 
             try:
                 # Events, Epochs, and SpikeTrains
                 check_unique(eests)
-            except ValueError as ve:
+            except ValueError as exc:
                 raise ValueError(
-                    "{} in Event, Epoch, and Spiketrain names "
-                    "of Block '{}' {}".format(errmsg, blk.name, ve)
-                )
+                    f"{errmsg} in Event, Epoch, and Spiketrain names of Block '{blk.name}'"
+                ) from exc
 
             try:
                 # ChannelIndexes
                 check_unique(blk.channel_indexes)
-            except ValueError as ve:
-                raise ValueError(
-                    "{} in ChannelIndex names "
-                    "of Block '{}' {}".format(errmsg, blk.name, ve)
-                )
+            except ValueError as exc:
+                raise ValueError(f"{errmsg} in ChannelIndex names of Block '{blk.name}'") from exc
 
             for chx in blk.channel_indexes:
                 try:
                     check_unique(chx.units)
-                except ValueError as ve:
-                    raise ValueError(
-                        "{} in Unit names of Block "
-                        "'{}' > ChannelIndex '{}' {}".format(errmsg, blk.name,
-                                                             chx.name, ve)
-                    )
+                except ValueError as exc:
+                    raise ValueError(f"{errmsg} in Unit names of Block '{blk.name}' > "
+                                     f"ChannelIndex '{chx.name}'") from exc
 
         # names are OK: assign annotations
         for o in allobjs:
             o.annotations["nix_name"] = o.name
 
     def close(self):
         """
         Closes the open nix file and resets maps.
         """
-        if (hasattr(self, "nix_file")
-                and self.nix_file and self.nix_file.is_open()):
+        if (hasattr(self, "nix_file") and self.nix_file and self.nix_file.is_open()):
             self.nix_file.close()
             self.nix_file = None
             self._neo_map = None
             self._ref_map = None
             self._signal_map = None
+            self._view_map = None
             self._block_read_counter = None
 
     def __del__(self):
         self.close()
```

### Comparing `neo-0.8.0/neo/io/nixio_fr.py` & `neo-0.9.0/neo/io/nixio_fr.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,23 +5,23 @@
 
 
 class NixIO(NIXRawIO, BaseFromRaw):
 
     name = 'NIX IO'
 
     _prefered_signal_group_mode = 'group-by-same-units'
-    _prefered_units_group_mode = 'split-all'
+    _prefered_units_group_mode = 'all-in-one'
 
     def __init__(self, filename):
         NIXRawIO.__init__(self, filename)
         BaseFromRaw.__init__(self, filename)
 
     def read_block(self, block_index=0, lazy=False, signal_group_mode=None,
                    units_group_mode=None, load_waveforms=False):
-        bl = super(NixIO, self).read_block(block_index, lazy,
+        bl = super().read_block(block_index, lazy,
                                            signal_group_mode,
                                            units_group_mode,
                                            load_waveforms)
         for chx in bl.channel_indexes:
             if "nix_name" in chx.annotations:
                 nixname = chx.annotations["nix_name"]
                 chx.annotations["nix_name"] = nixname[0]
```

### Comparing `neo-0.8.0/neo/io/nsdfio.py` & `neo-0.9.0/neo/io/nsdfio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,16 @@
-# -*- coding: utf-8 -*-
-
 """
 Module for reading and writing NSDF files
 
 Author: Mieszko Grodzicki
 
 This module support both reading and writing NDSF files.
 Note: Read file must be written using this IO
 """
 
-from __future__ import absolute_import
 
 import numpy as np
 import quantities as pq
 
 from uuid import uuid1
 import pickle
 from datetime import datetime
@@ -35,20 +32,20 @@
 class NSDFIO(BaseIO):
     """
     Class for reading and writing files in NSDF Format.
 
     It supports reading and writing: Block, Segment, AnalogSignal, ChannelIndex, with all relationships and metadata.
     """
     is_readable = True
-    is_writable = True
+    is_writable = False  # True - disabled pending update to Neo 0.9 API
 
     supported_objects = [Block, Segment, AnalogSignal, ChannelIndex]
 
     readable_objects = [Block, Segment]
-    writeable_objects = [Block, Segment]
+    writeable_objects = []  # [Block, Segment] - disabled pending update to Neo 0.9 API
 
     has_header = False
     is_streameable = False
 
     name = 'NSDF'
     extensions = ['h5']
     mode = 'file'
@@ -73,14 +70,15 @@
 
     def write_all_blocks(self, blocks):
         """
         Write list of blocks to the file
 
         :param blocks: List of blocks to be written
         """
+        raise NotImplementedError("Implementation not yet updated for Neo 0.9")
         writer = self._init_writing()
         neo_model, blocks_model, segments_model = self._prepare_model_tree(writer)
 
         name_pattern = self._name_pattern(len(blocks))
         for i, block in enumerate(blocks):
             self.write_block(block, name_pattern.format(i), writer, blocks_model)
 
@@ -89,14 +87,15 @@
         Write a Block to the file
 
         :param block: Block to be written
         :param name: Name for block representation in NSDF model tree (optional)
         :param writer: NSDFWriter instance (optional)
         :param parent: NSDF ModelComponent which will be the parent of block NSDF representation (optional)
         """
+        raise NotImplementedError("Implementation not yet updated for Neo 0.9")
         if not isinstance(block, Block):
             raise ValueError("Must provide a Block to write.")
 
         if writer is None:
             writer = self._init_writing()
 
         if parent is None:
@@ -131,14 +130,15 @@
         Write a Segment to the file
 
         :param segment: Segment to be written
         :param name: Name for segment representation in NSDF model tree (optional)
         :param writer: NSDFWriter instance (optional)
         :param parent: NSDF ModelComponent which will be the parent of segment NSDF representation (optional)
         """
+        raise NotImplementedError("Implementation not yet updated for Neo 0.9")
         if not isinstance(segment, Segment):
             raise ValueError("Must provide a Segment to write.")
 
         if writer is None:
             writer = self._init_writing()
 
         single_segment = False
@@ -169,14 +169,15 @@
         Write an AnalogSignal to the file
 
         :param signal: AnalogSignal to be written
         :param name: Name for signal representation in NSDF model tree
         :param writer: NSDFWriter instance
         :param parent: NSDF ModelComponent which will be the parent of signal NSDF representation
         """
+        raise NotImplementedError("Implementation not yet updated for Neo 0.9")
         uid = uuid1().hex
         model = nsdf.ModelComponent(name, uid=uid, parent=parent)
 
         if signal.annotations.get('nsdfio_uid') is not None:
             model.attrs['reference_to'] = signal.annotations['nsdfio_uid']
             self._write_model_component(model, writer)
             return
@@ -199,14 +200,15 @@
         Write a ChannelIndex to the file
 
         :param channelindex: ChannelIndex to be written
         :param name: Name for channelindex representation in NSDF model tree
         :param writer: NSDFWriter instance
         :param parent: NSDF ModelComponent which will be the parent of channelindex NSDF representation
         """
+        raise NotImplementedError("Implementation not yet updated for Neo 0.9")
         uid = uuid1().hex
         model = nsdf.ModelComponent(name, uid=uid, parent=parent)
 
         self._write_basic_metadata(model, channelindex)
         self._write_model_component(model, writer)
 
         self._write_channelindex_arrays(model, channelindex, writer)
```

### Comparing `neo-0.8.0/neo/io/pickleio.py` & `neo-0.9.0/neo/io/pickleio.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Module for reading/writing data from/to Python pickle format.
 
 
 Class:
     PickleIO
```

### Comparing `neo-0.8.0/neo/io/plexonio.py` & `neo-0.9.0/neo/io/plexonio.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-# -*- coding: utf-8 -*-
-
 from neo.io.basefromrawio import BaseFromRaw
 from neo.rawio.plexonrawio import PlexonRawIO
 
 
 class PlexonIO(PlexonRawIO, BaseFromRaw):
     """
     Class for reading the old data format from Plexon
@@ -11,12 +9,13 @@
 
     Note that Plexon now use a new format PL2 which is NOT
     supported by this IO.
 
     Compatible with versions 100 to 106.
     Other versions have not been tested.
     """
-    _prefered_signal_group_mode = 'split-all'
+    _prefered_signal_group_mode = 'group-by-same-units'
+    _default_group_mode_have_change_in_0_9 = True
 
     def __init__(self, filename):
         PlexonRawIO.__init__(self, filename=filename)
         BaseFromRaw.__init__(self, filename)
```

### Comparing `neo-0.8.0/neo/io/proxyobjects.py` & `neo-0.9.0/neo/io/proxyobjects.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,30 +1,33 @@
-# -*- coding: utf-8 -*-
 """
 Here a list of proxy object that can be used when lazy=True at neo.io level.
 
 This idea is to be able to postpone that real in memory loading
 for objects that contains big data (AnalogSIgnal, SpikeTrain, Event, Epoch).
 
 The implementation rely on neo.rawio, so it will available only for neo.io that
 ineherits neo.rawio.
 
 """
 
 import numpy as np
 import quantities as pq
+import logging
 
 from neo.core.baseneo import BaseNeo
 
 
 from neo.core import (AnalogSignal,
                       Epoch, Event, SpikeTrain)
 from neo.core.dataobject import ArrayDict
 
 
+logger = logging.getLogger("Neo")
+
+
 class BaseProxy(BaseNeo):
     def __init__(self, array_annotations=None, **annotations):
         # this for py27 str vs py3 str in neo attributes ompatibility
         annotations = check_annotations(annotations)
         if 'file_origin' not in annotations:
             # the str is to make compatible with neo_py27 where attribute
             # used to be str so raw bytes
@@ -65,26 +68,27 @@
       * only a slice of time
       * only a subset of channels
       * have an internal raw magnitude identic to the file (int16) with
         a pq.CompoundUnit().
 
     Usage:
     >>> proxy_anasig = AnalogSignalProxy(rawio=self.reader,
-                                                                global_channel_indexes=None,
-                                                                block_index=0,
-                                                                seg_index=0)
+                                         global_channel_indexes=None,
+                                         block_index=0,
+                                         seg_index=0)
     >>> anasig = proxy_anasig.load()
     >>> slice_of_anasig = proxy_anasig.load(time_slice=(1.*pq.s, 2.*pq.s))
     >>> some_channel_of_anasig = proxy_anasig.load(channel_indexes=[0,5,10])
 
     '''
     _single_parent_objects = ('Segment', 'ChannelIndex')
     _necessary_attrs = (('sampling_rate', pq.Quantity, 0),
                                     ('t_start', pq.Quantity, 0))
     _recommended_attrs = BaseNeo._recommended_attrs
+    proxy_for = AnalogSignal
 
     def __init__(self, rawio=None, global_channel_indexes=None, block_index=0, seg_index=0):
         self._rawio = rawio
         self._block_index = block_index
         self._seg_index = seg_index
         if global_channel_indexes is None:
             global_channel_indexes = slice(None)
@@ -284,14 +288,15 @@
     '''
 
     _single_parent_objects = ('Segment', 'Unit')
     _quantity_attr = 'times'
     _necessary_attrs = (('t_start', pq.Quantity, 0),
                                     ('t_stop', pq.Quantity, 0))
     _recommended_attrs = ()
+    proxy_for = SpikeTrain
 
     def __init__(self, rawio=None, unit_index=None, block_index=0, seg_index=0):
 
         self._rawio = rawio
         self._block_index = block_index
         self._seg_index = seg_index
         self._unit_index = unit_index
@@ -427,17 +432,14 @@
         dtype = 'float64'
         times = self._rawio.rescale_event_timestamp(timestamp, dtype=dtype)
         units = 's'
 
         if durations is not None:
             durations = self._rawio.rescale_epoch_duration(durations, dtype=dtype) * pq.s
 
-        # this should be remove when labesl will be unicode
-        labels = labels.astype('S')
-
         h = self._rawio.header['event_channels'][self._event_channel_index]
         if h['type'] == b'event':
             ret = Event(times=times, labels=labels, units='s',
                 name=self.name, file_origin=self.file_origin,
                 description=self.description, **self.annotations)
         elif h['type'] == b'epoch':
             ret = Epoch(times=times, durations=durations, labels=labels,
@@ -468,15 +470,16 @@
     >>> proxy_event = EventProxy(rawio=self.reader, event_channel_index=0,
                         block_index=0, seg_index=0,)
     >>> event = proxy_event.load()
     >>> slice_of_event = proxy_event.load(time_slice=(1.*pq.s, 2.*pq.s))
 
     '''
     _necessary_attrs = (('times', pq.Quantity, 1),
-                        ('labels', np.ndarray, 1, np.dtype('S')))
+                        ('labels', np.ndarray, 1, np.dtype('U')))
+    proxy_for = Event
 
 
 class EpochProxy(_EventOrEpoch):
     '''
     This object mimic Epoch except that it does not
     have the times nor labels nor durations.
     All other attributes and annotations are here.
@@ -496,36 +499,41 @@
                         block_index=0, seg_index=0,)
     >>> epoch = proxy_epoch.load()
     >>> slice_of_epoch = proxy_epoch.load(time_slice=(1.*pq.s, 2.*pq.s))
 
     '''
     _necessary_attrs = (('times', pq.Quantity, 1),
                         ('durations', pq.Quantity, 1),
-                        ('labels', np.ndarray, 1, np.dtype('S')))
+                        ('labels', np.ndarray, 1, np.dtype('U')))
+    proxy_for = Epoch
 
 
 proxyobjectlist = [AnalogSignalProxy, SpikeTrainProxy, EventProxy,
                             EpochProxy]
 
 
 unit_convert = {'Volts': 'V', 'volts': 'V', 'Volt': 'V',
-                'volt': 'V', ' Volt': 'V', 'microV': 'V'}
+                'volt': 'V', ' Volt': 'V', 'microV': 'uV',
+                # note that "micro" and "mu" are two different characters in Unicode
+                # although they mostly look the same. Here we accept both.
+                'V': 'uV', 'V': 'uV'}
 
 
 def ensure_signal_units(units):
     # test units
     units = units.replace(' ', '')
     if units in unit_convert:
         units = unit_convert[units]
     try:
         units = pq.Quantity(1, units)
     except:
-        logging.warning('Units "{}" can not be converted to a quantity. Using dimensionless '
-                        'instead'.format(units))
+        logger.warning('Units "{}" can not be converted to a quantity. Using dimensionless '
+                       'instead'.format(units))
         units = ''
+        units = pq.Quantity(1, units)
     return units
 
 
 def check_annotations(annotations):
     # force type to str for some keys
     # imposed for tests
     for k in ('name', 'description', 'file_origin'):
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `neo-0.8.0/neo/io/rawbinarysignalio.py` & `neo-0.9.0/neo/io/rawbinarysignalio.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading/writing data in a raw binary interleaved compact file.
 Sampling rate, units, number of channel and dtype must be externally known.
 This generic format is quite widely used in old acquisition systems and is quite universal
 for sharing data.
 
 Supported : Read/Write
@@ -37,15 +36,16 @@
     So now the usage is:
         >>>>r = io.RawBinarySignalIO(filename='file.raw', dtype='int16',
                                     nb_channel=16, sampling_rate=10000.)
 
 
     """
 
-    _prefered_signal_group_mode = 'split-all'
+    _prefered_signal_group_mode = 'group-by-same-units'
+    _default_group_mode_have_change_in_0_9 = True
 
     is_readable = True
     is_writable = True
 
     supported_objects = [Segment, AnalogSignal]
     readable_objects = [Segment]
     writeable_objects = [Segment]
```

### Comparing `neo-0.8.0/neo/io/stimfitio.py` & `neo-0.9.0/neo/io/stimfitio.py`

 * *Files 2% similar despite different names*

```diff
@@ -22,19 +22,14 @@
 than 30 additional file formats (http://pub.ist.ac.at/~schloegl/biosig/TESTED).
 
 Based on exampleio.py and axonio.py from neo.io
 
 08 Feb 2014, C. Schmidt-Hieber, University College London
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
-import sys
-
 import numpy as np
 import quantities as pq
 
 from neo.io.baseio import BaseIO
 from neo.core import Block, Segment, AnalogSignal
 
 try:
```

### Comparing `neo-0.8.0/neo/io/tdtio.py` & `neo-0.9.0/neo/io/tdtio.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-# -*- coding: utf-8 -*-
 from neo.io.basefromrawio import BaseFromRaw
 from neo.rawio.tdtrawio import TdtRawIO
 
 
 class TdtIO(TdtRawIO, BaseFromRaw):
     """
     Class for reading data from from Tucker Davis TTank format.
 
     Terminology:
     TDT holds data with tanks (actually a directory). And tanks hold sub blocks
     (sub directories).
     Tanks correspond to Neo Blocks and TDT blocks correspond to Neo Segments.
     """
-    _prefered_signal_group_mode = 'split-all'
+    _prefered_signal_group_mode = 'group-by-same-units'
+    _default_group_mode_have_change_in_0_9 = True
     mode = 'dir'
 
     def __init__(self, dirname):
         TdtRawIO.__init__(self, dirname=dirname)
         BaseFromRaw.__init__(self, dirname)
```

### Comparing `neo-0.8.0/neo/io/tiffio.py` & `neo-0.9.0/neo/io/tiffio.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Neo IO module for optical imaging data stored as a folder of TIFF images.
 """
 
 import os
 try:
     from PIL import Image
@@ -78,19 +77,14 @@
             raise Exception("Please install the pillow package to use TiffIO")
 
         BaseIO.__init__(self, directory_path, **kwargs)
         self.units = units
         self.sampling_rate = sampling_rate
         self.spatial_scale = spatial_scale
 
-    def read(self, lazy=False, **kwargs):
-        if lazy:
-            raise ValueError('This IO module does not support lazy loading')
-        return [self.read_block(lazy=lazy, **kwargs)]
-
     def read_block(self, lazy=False, **kwargs):
         # to sort file
         def natural_sort(l):
             convert = lambda text: int(text) if text.isdigit() else text.lower()
             alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]
             return sorted(l, key=alphanum_key)
```

### Comparing `neo-0.8.0/neo/io/tools.py` & `neo-0.9.0/neo/io/tools.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tools for IO coder:
   * Creating RecordingChannel and making links with AnalogSignals and
     SPikeTrains
 """
 
 try:
@@ -11,15 +10,15 @@
     from collections import MutableSequence
 
 import numpy as np
 
 from neo.core import (AnalogSignal, Block,
                       Epoch, Event,
                       IrregularlySampledSignal,
-                      ChannelIndex,
+                      ChannelIndex, Group, ChannelView,
                       Segment, SpikeTrain, Unit)
 
 
 # def finalize_block(block):
 #    populate_RecordingChannel(block)
 #    block.create_many_to_one_relationship()
 
@@ -85,17 +84,17 @@
 class LazyList(MutableSequence):
     """ An enhanced list that can load its members on demand. Behaves exactly
     like a regular list for members that are Neo objects. Each item should
     contain the information that ``load_lazy_cascade`` needs to load the
     respective object.
     """
     _container_objects = {
-        Block, Segment, ChannelIndex, Unit}
+        Block, Segment, ChannelIndex, Unit, Group}
     _neo_objects = _container_objects.union(
-        [AnalogSignal, Epoch, Event,
+        [AnalogSignal, Epoch, Event, ChannelView,
          IrregularlySampledSignal, SpikeTrain])
 
     def __init__(self, io, lazy, items=None):
         """
         :param io: IO instance that can load items.
         :param lazy: Lazy parameter with which the container object
             using the list was loaded.
```

### Comparing `neo-0.8.0/neo/io/winedrio.py` & `neo-0.9.0/neo/io/winedrio.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-# -*- coding: utf-8 -*-
-
 from neo.io.basefromrawio import BaseFromRaw
 from neo.rawio.winedrrawio import WinEdrRawIO
 
 
 class WinEdrIO(WinEdrRawIO, BaseFromRaw):
     """
     Class for reading data from WinEdr, a software tool written by
     John Dempster.
 
     WinEdr is free:
     http://spider.science.strath.ac.uk/sipbs/software.htm
     """
-    _prefered_signal_group_mode = 'split-all'
+    _prefered_signal_group_mode = 'group-by-same-units'
+    _default_group_mode_have_change_in_0_9 = True
 
     def __init__(self, filename):
         WinEdrRawIO.__init__(self, filename=filename)
         BaseFromRaw.__init__(self, filename)
```

### Comparing `neo-0.8.0/neo/rawio/__init__.py` & `neo-0.9.0/neo/rawio/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 :mod:`neo.rawio` provides classes for reading with low level API
 electrophysiological data files.
 
 :attr:`neo.rawio.rawiolist` provides a list of successfully imported rawio
 classes.
```

### Comparing `neo-0.8.0/neo/rawio/axographrawio.py` & `neo-0.9.0/neo/rawio/axographrawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 AxographRawIO
 =============
 
 RawIO class for reading AxoGraph files (.axgd, .axgx)
 
 Original author: Jeffrey Gill
@@ -151,17 +150,14 @@
     After data acquisition, the user can annotate an AxoGraph file with
     horizontal, labeled bars called interval bars that span a specified period
     of time. These are not episode specific. AxographRawIO will organize all
     interval bars into a single Neo Epoch channel with the name "AxoGraph
     Intervals".
 """
 
-from __future__ import (unicode_literals, print_function, division,
-                        absolute_import)
-
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import os
 from datetime import datetime
 from io import open, BufferedReader
 from struct import unpack, calcsize
@@ -242,18 +238,17 @@
         else:
             self.logger.debug('Will not treat as episodic')
         self.logger.debug('')
 
         self._generate_minimal_annotations()
         blk_annotations = self.raw_annotations['blocks'][0]
         blk_annotations['format_ver'] = self.info['format_ver']
-        if self.info['format_ver'] >= 3:
-            blk_annotations['comment'] = self.info['comment']
-            blk_annotations['notes'] = self.info['notes']
-            blk_annotations['rec_datetime'] = self._get_rec_datetime()
+        blk_annotations['comment'] = self.info['comment'] if 'comment' in self.info else None
+        blk_annotations['notes'] = self.info['notes'] if 'notes' in self.info else None
+        blk_annotations['rec_datetime'] = self._get_rec_datetime()
 
         # modified time is not ideal but less prone to
         # cross-platform issues than created time (ctime)
         blk_annotations['file_datetime'] = datetime.fromtimestamp(
             os.path.getmtime(self.filename))
 
     def _source_name(self):
@@ -415,23 +410,36 @@
         if self.info['format_ver'] < 3:
             self.logger.debug('Cannot treat as episodic because old format '
                               'contains insufficient metadata')
             return False
 
         # Second check: If the file is episodic, it should report that it
         # contains more than 1 episode.
+        if 'n_episodes' not in self.info:
+            self.logger.debug('Cannot treat as episodic because episode '
+                              'metadata is missing or could not be parsed')
+            return False
         if self.info['n_episodes'] == 1:
             self.logger.debug('Cannot treat as episodic because file reports '
                               'one episode')
             return False
 
         # Third check: If the file is episodic, groups of traces should all
         # contain the same number of traces, one for each episode. This is
         # generally true of "continuous" (single-episode) recordings as well,
         # which normally have 1 trace per group.
+        if 'group_header_info_list' not in self.info:
+            self.logger.debug('Cannot treat as episodic because group '
+                              'metadata is missing or could not be parsed')
+            return False
+        if 'trace_header_info_list' not in self.info:
+            self.logger.debug('Cannot treat as episodic because trace '
+                              'metadata is missing or could not be parsed')
+            return False
+
         group_id_to_col_indexes = {}
         for group_id in self.info['group_header_info_list']:
             col_indexes = []
             for trace_header in self.info['trace_header_info_list'].values():
                 if trace_header['group_id_for_this_trace'] == group_id:
                     col_indexes.append(trace_header['y_index'])
             group_id_to_col_indexes[group_id] = col_indexes
@@ -517,14 +525,17 @@
         """
 
         rec_datetime = None
         date_string = ''
         time_string = ''
         datetime_string = ''
 
+        if 'notes' not in self.info:
+            return None
+
         for note_line in self.info['notes'].split('\n'):
 
             # episodic acquisition mode
             if note_line.startswith('Created on '):
                 date_string = note_line.strip('Created on ')
             if note_line.startswith('Start data acquisition at '):
                 time_string = note_line.strip('Start data acquisition at ')
@@ -547,24 +558,27 @@
 
     def _scan_axograph_file(self):
         """
         This function traverses the entire AxoGraph file, constructing memmaps
         for signals and collecting channel information and other metadata
         """
 
+        self.info = {}
+
         with open(self.filename, 'rb') as fid:
             f = StructFile(fid)
 
             self.logger.debug('filename: {}'.format(self.filename))
             self.logger.debug('')
 
             # the first 4 bytes are always a 4-character file type identifier
             # - for early versions of AxoGraph, this identifier was 'AxGr'
             # - starting with AxoGraph X, the identifier is 'axgx'
             header_id = f.read(4).decode('utf-8')
+            self.info['header_id'] = header_id
             assert header_id in ['AxGr', 'axgx'], \
                 'not an AxoGraph binary file! "{}"'.format(self.filename)
 
             self.logger.debug('header_id: {}'.format(header_id))
 
             # the next two numbers store the format version number and the
             # number of data columns to follow
@@ -582,14 +596,16 @@
                 assert format_ver >= 3, \
                     'mismatch between header identifier "{}" and format ' \
                     'version "{}"!'.format(header_id, format_ver)
             else:
                 raise NotImplementedError(
                     'unimplemented file header identifier "{}"!'.format(
                         header_id))
+            self.info['format_ver'] = format_ver
+            self.info['n_cols'] = n_cols
 
             self.logger.debug('format_ver: {}'.format(format_ver))
             self.logger.debug('n_cols: {}'.format(n_cols))
             self.logger.debug('')
 
             ##############################################
             # BEGIN COLUMNS
@@ -666,55 +682,14 @@
                 if format_ver == 1:
 
                     # for format version 1, all columns are arrays of floats
 
                     dtype = 'f'
                     gain, offset = 1, 0  # data is neither scaled nor off-set
 
-                    if i == 0:
-
-                        # there is no guarantee that this time column is
-                        # regularly sampled, and in fact the test file for
-                        # version 1 has slight variations in the intervals
-                        # between samples (due to numerical imprecision,
-                        # probably), so technically an IrregularlySampledSignal
-                        # is needed here, but I'm going to cheat by assuming
-                        # regularity
-
-                        # create a memory map that allows accessing parts of
-                        # the file without loading it all into memory
-                        array = np.memmap(
-                            self.filename,
-                            mode='r',
-                            dtype=f.byte_order + dtype,
-                            offset=f.tell(),
-                            shape=n_points)
-
-                        # advance the file position to after the data array
-                        f.seek(array.nbytes, 1)
-
-                        first_value, increment = \
-                            array[0], \
-                            np.median(np.diff(array))  # here's the cheat
-
-                        self.logger.debug(
-                            'interval: {}, freq: {}'.format(
-                                increment, 1 / increment))
-                        self.logger.debug(
-                            'start: {}, end: {}'.format(
-                                first_value,
-                                first_value + increment * (n_points - 1)))
-
-                        # assume this is the time column
-                        t_start, sampling_period = first_value, increment
-
-                        self.logger.debug('')
-
-                        continue  # skip saving memmap, chan info for time col
-
                 elif format_ver == 2:
 
                     # for format version 2, the first column is a "series" of
                     # regularly spaced values specified merely by a first value
                     # and an increment, and all subsequent columns are arrays
                     # of shorts with a scaling factor
 
@@ -729,14 +704,16 @@
                         self.logger.debug(
                             'start: {}, end: {}'.format(
                                 first_value,
                                 first_value + increment * (n_points - 1)))
 
                         # assume this is the time column
                         t_start, sampling_period = first_value, increment
+                        self.info['t_start'] = t_start
+                        self.info['sampling_period'] = sampling_period
 
                         self.logger.debug('')
 
                         continue  # skip memmap, chan info for time col
 
                     else:
 
@@ -770,14 +747,16 @@
                                 first_value,
                                 first_value + increment * (n_points - 1)))
 
                         if i == 0:
 
                             # assume this is the time column
                             t_start, sampling_period = first_value, increment
+                            self.info['t_start'] = t_start
+                            self.info['sampling_period'] = sampling_period
 
                             self.logger.debug('')
 
                             continue  # skip memmap, chan info for time col
 
                         else:
 
@@ -837,78 +816,110 @@
                     dtype=f.byte_order + dtype,
                     offset=f.tell(),
                     shape=n_points)
 
                 # advance the file position to after the data array
                 f.seek(array.nbytes, 1)
 
-                self.logger.debug('gain: {}, offset: {}'.format(gain, offset))
-                self.logger.debug('initial data: {}'.format(
-                    array[:5] * gain + offset))
-
-                # channel_info will be cast to _signal_channel_dtype
-                channel_info = (
-                    name, i, 1 / sampling_period, f.byte_order + dtype,
-                    units, gain, offset, 0)
+                if i == 0:
+                    # assume this is the time column containing n_points values
 
-                self.logger.debug('channel_info: {}'.format(channel_info))
-                self.logger.debug('')
+                    # verify times are spaced regularly
+                    diffs = np.diff(array)
+                    increment = np.median(diffs)
+                    max_frac_step_deviation = np.max(np.abs(
+                        diffs / increment - 1))
+                    tolerance = 1e-3
+                    if max_frac_step_deviation > tolerance:
+                        self.logger.debug('largest proportional deviation '
+                                          'from median step size in the first '
+                                          'column exceeds the tolerance '
+                                          'of ' + str(tolerance) + ':'
+                                          ' ' + str(max_frac_step_deviation))
+                        raise ValueError('first data column (assumed to be '
+                                         'time) is not regularly spaced')
 
-                sig_memmaps.append(array)
-                sig_channels.append(channel_info)
+                    first_value = array[0]
 
-            # END COLUMNS
-            ##############################################
+                    self.logger.debug(
+                        'interval: {}, freq: {}'.format(
+                            increment, 1 / increment))
+                    self.logger.debug(
+                        'start: {}, end: {}'.format(
+                            first_value,
+                            first_value + increment * (n_points - 1)))
+
+                    t_start, sampling_period = first_value, increment
+                    self.info['t_start'] = t_start
+                    self.info['sampling_period'] = sampling_period
 
-            if format_ver == 1 or format_ver == 2:
+                    self.logger.debug('')
 
-                # for format versions 1 and 2, metadata like graph display
-                # information was stored separately in the "resource fork" of
-                # the file, so there is nothing more to do here, and the rest
-                # of the file is empty
+                    continue  # skip saving memmap, chan info for time col
 
-                rest_of_the_file = f.read()
-                assert rest_of_the_file == b''
+                else:
+                    # not a time column
 
-                raw_event_timestamps = []
-                raw_epoch_timestamps = []
-                raw_epoch_durations = []
-                event_labels = []
-                epoch_labels = []
+                    self.logger.debug('gain: {}, offset: {}'.format(gain, offset))
+                    self.logger.debug('initial data: {}'.format(
+                        array[:5] * gain + offset))
+
+                    # channel_info will be cast to _signal_channel_dtype
+                    channel_info = (
+                        name, i, 1 / sampling_period, f.byte_order + dtype,
+                        units, gain, offset, 0)
+
+                    self.logger.debug('channel_info: {}'.format(channel_info))
+                    self.logger.debug('')
+
+                    sig_memmaps.append(array)
+                    sig_channels.append(channel_info)
+
+            # END COLUMNS
+            ##############################################
 
-            elif format_ver >= 3:
+            # initialize lists for events and epochs
+            raw_event_timestamps = []
+            raw_epoch_timestamps = []
+            raw_epoch_durations = []
+            event_labels = []
+            epoch_labels = []
 
-                # for format versions 3 and later, there is a lot more!
+            # the remainder of the file may contain metadata, events and epochs
+            try:
 
                 ##############################################
                 # COMMENT
 
                 self.logger.debug('== COMMENT ==')
 
                 comment = f.read_f('S')
+                self.info['comment'] = comment
 
                 self.logger.debug(comment if comment else 'no comment!')
                 self.logger.debug('')
 
                 ##############################################
                 # NOTES
 
                 self.logger.debug('== NOTES ==')
 
                 notes = f.read_f('S')
+                self.info['notes'] = notes
 
                 self.logger.debug(notes if notes else 'no notes!')
                 self.logger.debug('')
 
                 ##############################################
                 # TRACES
 
                 self.logger.debug('== TRACES ==')
 
                 n_traces = f.read_f('l')
+                self.info['n_traces'] = n_traces
 
                 self.logger.debug('n_traces: {}'.format(n_traces))
                 self.logger.debug('')
 
                 trace_header_info_list = {}
                 group_ids = []
                 for i in range(n_traces):
@@ -942,21 +953,23 @@
                     # AxoGraph traces are 1-indexed in GUI, so use i+1 below
                     trace_header_info_list[i + 1] = trace_header_info
                     group_ids.append(
                         trace_header_info['group_id_for_this_trace'])
 
                     self.logger.debug(trace_header_info)
                     self.logger.debug('')
+                self.info['trace_header_info_list'] = trace_header_info_list
 
                 ##############################################
                 # GROUPS
 
                 self.logger.debug('== GROUPS ==')
 
                 n_groups = f.read_f('l')
+                self.info['n_groups'] = n_groups
                 group_ids = \
                     np.sort(list(set(group_ids)))  # remove duplicates and sort
                 assert n_groups == len(group_ids), \
                     'expected group_ids to have length {}: {}'.format(
                         n_groups, group_ids)
 
                 self.logger.debug('n_groups: {}'.format(n_groups))
@@ -991,14 +1004,15 @@
                     for key, fmt in GroupHeaderDescription:
                         group_header_info[key] = f.read_f(fmt)
                     # AxoGraph groups are 0-indexed in GUI, so use i below
                     group_header_info_list[i] = group_header_info
 
                     self.logger.debug(group_header_info)
                     self.logger.debug('')
+                self.info['group_header_info_list'] = group_header_info_list
 
                 ##############################################
                 # UNKNOWN
 
                 self.logger.debug('>> UNKNOWN 1 <<')
 
                 # 36 bytes of undeciphered data (types here are guesses)
@@ -1013,18 +1027,20 @@
                 self.logger.debug('== EPISODES ==')
 
                 # a subset of episodes can be selected for "review", or
                 # episodes can be paged through one by one, and the indexes of
                 # those currently in review appear in this list
                 episodes_in_review = []
                 n_episodes = f.read_f('l')
+                self.info['n_episodes'] = n_episodes
                 for i in range(n_episodes):
                     episode_bool = f.read_f('Z')
                     if episode_bool:
                         episodes_in_review.append(i + 1)
+                self.info['episodes_in_review'] = episodes_in_review
 
                 self.logger.debug('n_episodes: {}'.format(n_episodes))
                 self.logger.debug('episodes_in_review: {}'.format(
                     episodes_in_review))
 
                 if format_ver == 5:
 
@@ -1064,14 +1080,15 @@
                 # indexes of those currently masked appear in this list
                 masked_episodes = []
                 n_episodes4 = f.read_f('l')
                 for i in range(n_episodes4):
                     episode_bool = f.read_f('Z')
                     if episode_bool:
                         masked_episodes.append(i + 1)
+                self.info['masked_episodes'] = masked_episodes
 
                 self.logger.debug('masked_episodes: {}'.format(
                     masked_episodes))
                 if n_episodes4 != n_episodes:
                     self.logger.debug(
                         'n_episodes4 ({}) and n_episodes ({}) '
                         'differ!'.format(n_episodes4, n_episodes))
@@ -1131,23 +1148,25 @@
                         bool(font_settings_info['setting2'] & FONT_UNDERLINE)
                     font_settings_info['strikeout'] = \
                         bool(font_settings_info['setting2'] & FONT_STRIKEOUT)
                     font_settings_info_list[i] = font_settings_info
 
                     self.logger.debug(font_settings_info)
                     self.logger.debug('')
+                self.info['font_settings_info_list'] = font_settings_info_list
 
                 ##############################################
                 # X-AXIS SETTINGS
 
                 self.logger.debug('== X-AXIS SETTINGS ==')
 
                 x_axis_settings_info = {}
                 for key, fmt in XAxisSettingsDescription:
                     x_axis_settings_info[key] = f.read_f(fmt)
+                self.info['x_axis_settings_info'] = x_axis_settings_info
 
                 self.logger.debug(x_axis_settings_info)
                 self.logger.debug('')
 
                 ##############################################
                 # UNKNOWN
 
@@ -1161,14 +1180,15 @@
 
                 ##############################################
                 # EVENTS / TAGS
 
                 self.logger.debug('=== EVENTS / TAGS ===')
 
                 n_events, n_events_again = f.read_f('ll')
+                self.info['n_events'] = n_events
 
                 self.logger.debug('n_events: {}'.format(n_events))
 
                 # event / tag timing is stored as an index into time
                 raw_event_timestamps = []
                 event_labels = []
                 for i in range(n_events_again):
@@ -1184,14 +1204,15 @@
                         zip(event_labels, raw_event_timestamps):
                     # t_start shouldn't be added here
                     event_time = event_index * sampling_period
                     event_list.append({
                         'title': event_label,
                         'index': event_index,
                         'time': event_time})
+                self.info['event_list'] = event_list
                 for event in event_list:
                     self.logger.debug(event)
                 self.logger.debug('')
 
                 ##############################################
                 # UNKNOWN
 
@@ -1205,23 +1226,25 @@
 
                 ##############################################
                 # EPOCHS / INTERVAL BARS
 
                 self.logger.debug('=== EPOCHS / INTERVAL BARS ===')
 
                 n_epochs = f.read_f('l')
+                self.info['n_epochs'] = n_epochs
 
                 self.logger.debug('n_epochs: {}'.format(n_epochs))
 
                 epoch_list = []
                 for i in range(n_epochs):
                     epoch_info = {}
                     for key, fmt in EpochInfoDescription:
                         epoch_info[key] = f.read_f(fmt)
                     epoch_list.append(epoch_info)
+                self.info['epoch_list'] = epoch_list
 
                 # epoch / interval bar timing and duration are stored in
                 # seconds, so here they are converted to (possibly non-integer)
                 # indexes into time to fit into the procrustean beds of
                 # _rescale_event_timestamp and _rescale_epoch_duration
                 raw_epoch_timestamps = []
                 raw_epoch_durations = []
@@ -1241,14 +1264,44 @@
                 self.logger.debug(
                     '>> UNKNOWN 5 (includes y-axis plot ranges) <<')
 
                 # lots of undeciphered data
                 rest_of_the_file = f.read()
 
                 self.logger.debug(rest_of_the_file)
+                self.logger.debug('')
+
+                self.logger.debug('End of file reached (expected)')
+
+            except EOFError as e:
+                if format_ver == 1 or format_ver == 2:
+                    # for format versions 1 and 2, metadata like graph display
+                    # information was stored separately in the "resource fork"
+                    # of the file, so reaching the end of the file before all
+                    # metadata is parsed is expected
+                    self.logger.debug('End of file reached (expected)')
+                    pass
+                else:
+                    # for format versions 3 and later, there should be metadata
+                    # stored at the end of the file, so warn that something may
+                    # have gone wrong, but try to continue anyway
+                    self.logger.warning('End of file reached unexpectedly '
+                                        'while parsing metadata, will attempt '
+                                        'to continue')
+                    self.logger.debug(e, exc_info=True)
+                    pass
+
+            except UnicodeDecodeError as e:
+                # warn that something went wrong with reading a string, but try
+                # to continue anyway
+                self.logger.warning('Problem decoding text while parsing '
+                                    'metadata, will ignore any remaining '
+                                    'metadata and attempt to continue')
+                self.logger.debug(e, exc_info=True)
+                pass
 
         self.logger.debug('')
 
         ##############################################
         # RAWIO HEADER
 
         # event_channels will be cast to _event_channel_dtype
@@ -1279,48 +1332,14 @@
         self._raw_event_epoch_durations = [
             None,
             np.array(raw_epoch_durations)]
         self._event_epoch_labels = [
             np.array(event_labels, dtype='U'),
             np.array(epoch_labels, dtype='U')]
 
-        ##############################################
-        # EXTRA INFORMATION
-
-        # keep other details
-        self.info = {}
-
-        self.info['header_id'] = header_id
-        self.info['format_ver'] = format_ver
-
-        self.info['t_start'] = t_start
-        self.info['sampling_period'] = sampling_period
-
-        if format_ver >= 3:
-            self.info['n_cols'] = n_cols
-            self.info['n_traces'] = n_traces
-            self.info['n_groups'] = n_groups
-            self.info['n_episodes'] = n_episodes
-            self.info['n_events'] = n_events
-            self.info['n_epochs'] = n_epochs
-
-            self.info['comment'] = comment
-            self.info['notes'] = notes
-
-            self.info['trace_header_info_list'] = trace_header_info_list
-            self.info['group_header_info_list'] = group_header_info_list
-            self.info['event_list'] = event_list
-            self.info['epoch_list'] = epoch_list
-
-            self.info['episodes_in_review'] = episodes_in_review
-            self.info['masked_episodes'] = masked_episodes
-
-            self.info['font_settings_info_list'] = font_settings_info_list
-            self.info['x_axis_settings_info'] = x_axis_settings_info
-
 
 class StructFile(BufferedReader):
     """
     A container for the file buffer with some added convenience functions for
     reading AxoGraph files
     """
 
@@ -1335,24 +1354,30 @@
             self.utf_16_decoder = 'utf-16-be'
         elif self.byte_order == '<':
             # little-endian
             self.utf_16_decoder = 'utf-16-le'
         else:
             # unspecified
             self.utf_16_decoder = 'utf-16'
-        super(StructFile, self).__init__(*args, **kwargs)
+        super().__init__(*args, **kwargs)
 
     def read_and_unpack(self, fmt):
         """
         Calculate the number of bytes corresponding to the format string, read
         in that number of bytes, and unpack them according to the format string
         """
-        return unpack(
-            self.byte_order + fmt,
-            self.read(calcsize(self.byte_order + fmt)))
+        try:
+            return unpack(
+                self.byte_order + fmt,
+                self.read(calcsize(self.byte_order + fmt)))
+        except Exception as e:
+            if e.args[0].startswith('unpack requires a buffer of'):
+                raise EOFError(e)
+            else:
+                raise
 
     def read_string(self):
         """
         The most common string format in AxoGraph files is a variable length
         string with UTF-16 encoding, preceded by a 4-byte integer (long)
         specifying the length of the string in bytes. Unlike a Pascal string
         ('p' format), these strings are not stored in a fixed number of bytes
```

### Comparing `neo-0.8.0/neo/rawio/axonrawio.py` & `neo-0.9.0/neo/rawio/axonrawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from pCLAMP and AxoScope
 files (.abf version 1 and 2), developed by Molecular device/Axon technologies.
 
 - abf = Axon binary file
 - atf is a text file based format from axon that could be
   read by AsciiIO (but this file is less efficient.)
@@ -30,17 +29,14 @@
 
 Author: Samuel Garcia, JS Nowacki
 
 Note: j.s.nowacki@gmail.com has a C++ library with SWIG bindings which also
 reads abf files - would be good to cross-check
 
 """
-from __future__ import print_function, division, absolute_import
-# from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
-
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 
 import struct
 import datetime
@@ -154,22 +150,20 @@
             channel_ids = list(range(nbchannel))
 
         sig_channels = []
         adc_nums = []
         for chan_index, chan_id in enumerate(channel_ids):
             if version < 2.:
                 name = info['sADCChannelName'][chan_id].replace(b' ', b'')
-                units = info['sADCUnits'][chan_id].replace(b'\xb5', b'u'). \
-                    replace(b' ', b'').decode('utf-8')  # \xb5 is 
+                units = safe_decode_units(info['sADCUnits'][chan_id])
                 adc_num = info['nADCPtoLChannelMap'][chan_id]
             elif version >= 2.:
                 ADCInfo = info['listADCInfo'][chan_id]
                 name = ADCInfo['ADCChNames'].replace(b' ', b'')
-                units = ADCInfo['ADCChUnits'].replace(b'\xb5', b'u'). \
-                    replace(b' ', b'').decode('utf-8')
+                units = safe_decode_units(ADCInfo['ADCChUnits'])
                 adc_num = ADCInfo['nADCNum']
             adc_nums.append(adc_num)
 
             if info['nDataFormat'] == 0:
                 # int16 gain/offset
                 if version < 2.:
                     gain = info['fADCRange']
@@ -199,31 +193,29 @@
                 gain, offset = 1., 0.
             group_id = 0
             sig_channels.append((name, chan_id, self._sampling_rate,
                                  sig_dtype, units, gain, offset, group_id))
 
         sig_channels = np.array(sig_channels, dtype=_signal_channel_dtype)
 
-        # only one events channel : tag
-        if mode in [3, 5]:  # TODO check if tags exits in other mode
-            # In ABF timstamps are not attached too any particular segment
-            # so each segment acess all event
-            timestamps = []
-            labels = []
-            comments = []
-            for i, tag in enumerate(info['listTag']):
-                timestamps.append(tag['lTagTime'])
-                labels.append(str(tag['nTagType']))
-                comments.append(clean_string(tag['sComment']))
-            self._raw_ev_timestamps = np.array(timestamps)
-            self._ev_labels = np.array(labels, dtype='U')
-            self._ev_comments = np.array(comments, dtype='U')
 
-        event_channels = []
-        event_channels.append(('Tag', '', 'event'))
+        # only one events channel : tag
+        # In ABF timstamps are not attached too any particular segment
+        # so each segment acess all event
+        timestamps = []
+        labels = []
+        comments = []
+        for i, tag in enumerate(info['listTag']):
+            timestamps.append(tag['lTagTime'])
+            labels.append(str(tag['nTagType']))
+            comments.append(clean_string(tag['sComment']))
+        self._raw_ev_timestamps = np.array(timestamps)
+        self._ev_labels = np.array(labels, dtype='U')
+        self._ev_comments = np.array(comments, dtype='U')
+        event_channels = [('Tag', '', 'event')]
         event_channels = np.array(event_channels, dtype=_event_channel_dtype)
 
         # No spikes
         unit_channels = []
         unit_channels = np.array(unit_channels, dtype=_unit_channel_dtype)
 
         # fille into header dict
@@ -355,16 +347,15 @@
                 signals.append(sig)
             sigs_by_segments.append(signals)
 
         sig_names = []
         sig_units = []
         for DACNum in range(nDAC):
             name = info['listDACInfo'][DACNum]['DACChNames'].decode("utf-8")
-            units = info['listDACInfo'][DACNum]['DACChUnits']. \
-                replace(b'\xb5', b'u').decode('utf-8')  # \xb5 is 
+            units = safe_decode_units(info['listDACInfo'][DACNum]['DACChUnits'])
             sig_names.append(name)
             sig_units.append(units)
 
         return sigs_by_segments, sig_names, sig_units
 
 
 def parse_axon_soup(filename):
@@ -454,15 +445,15 @@
             # not very robust. The idea is to remove the first
             # part by find ing one of th fowoling KEY
             # unfortunatly the later part contains a the file
             # taht can contain by accident also one of theses keys...
             f.seek(sections['StringsSection']['uBlockIndex'] * BLOCKSIZE)
             big_string = f.read(sections['StringsSection']['uBytes'])
             goodstart = -1
-            for key in [b'AXENGN', b'clampex', b'Clampex',
+            for key in [b'AXENGN', b'clampex', b'Clampex', b'EDR3',
                         b'CLAMPEX', b'axoscope', b'AxoScope', b'Clampfit']:
                 # goodstart = big_string.lower().find(key)
                 goodstart = big_string.find(b'\x00' + key)
                 if goodstart != -1:
                     break
             assert goodstart != -1, \
                 'This file does not contain clampex, axoscope or clampfit in the header'
@@ -611,14 +602,21 @@
 
 def clean_string(s):
     s = s.rstrip(b'\x00')
     s = s.rstrip(b' ')
     return s
 
 
+def safe_decode_units(s):
+    s = s.replace(b' ', b'')
+    s = s.replace(b'\xb5', b'u')  # \xb5 is 
+    s = s.replace(b'\xb0', b'\xc2\xb0')  # \xb0 is 
+    s = s.decode('utf-8')
+    return s
+
 BLOCKSIZE = 512
 
 headerDescriptionV1 = [
     ('fFileSignature', 0, '4s'),
     ('fFileVersionNumber', 4, 'f'),
     ('nOperationMode', 8, 'h'),
     ('lActualAcqLength', 10, 'i'),
```

### Comparing `neo-0.8.0/neo/rawio/baserawio.py` & `neo-0.9.0/neo/rawio/baserawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,51 +1,49 @@
-# -*- coding: utf-8 -*-
 """
 baserawio
 ======
 
 Classes
 -------
 
 BaseRawIO
 abstract class which should be overridden to write a RawIO.
 
 RawIO is a new API in neo that is supposed to acces as fast as possible
-raw data. All IO with theses carractristics should/could be rewritten:
+raw data. All IO with theses characteristics should/could be rewritten:
   * internally use of memmap (or hdf5)
   * reading header is quite cheap (not read all the file)
   * neo tree object is symetric and logical: same channel/units/event
     along all block and segments.
 
 
-So this handle **only** one simplified but very frequent case of dataset:
+So this handles **only** one simplified but very frequent case of dataset:
     * Only one channel set  for AnalogSignal (aka ChannelIndex) stable along Segment
     * Only one channel set  for SpikeTrain (aka Unit) stable along Segment
     * AnalogSignal have all the same sampling_rate acroos all Segment
     * t_start/t_stop are the same for many object (SpikeTrain, Event) inside a Segment
     * AnalogSignal should all have the same sampling_rate otherwise the won't be read
       a the same time. So signal_group_mode=='split-all' in BaseFromRaw
 
 
-An helper class `neo.io.basefromrawio.BaseFromRaw` should transform a RawIO to
+A helper class `neo.io.basefromrawio.BaseFromRaw` should transform a RawIO to
 neo legacy IO from free.
 
 With this API the IO have an attributes `header` with necessary keys.
 See ExampleRawIO as example.
 
 
 BaseRawIO implement a possible presistent cache system that can be used
 by some IOs to avoid very long parse_header(). The idea is that some variable
 or vector can be store somewhere (near the fiel, /tmp, any path)
 
 
 """
 
 # from __future__ import unicode_literals, print_function, division, absolute_import
-from __future__ import print_function, division, absolute_import
 
 import logging
 import numpy as np
 import os
 import sys
 
 from neo import logging_handler
@@ -88,15 +86,15 @@
 _event_channel_dtype = [
     ('name', 'U64'),
     ('id', 'U64'),
     ('type', 'S5'),  # epoch ot event
 ]
 
 
-class BaseRawIO(object):
+class BaseRawIO:
     """
     Generic class to handle.
 
     """
 
     name = 'BaseIO'
     description = ''
@@ -132,17 +130,17 @@
         else:
             self._cache = None
 
         self.header = None
 
     def parse_header(self):
         """
-        This must parse the file header to get all stuff for fast later one.
+        This must parse the file header to get all stuff for fast use later on.
 
-        This must contain
+        This must create
         self.header['nb_block']
         self.header['nb_segment']
         self.header['signal_channels']
         self.header['units_channels']
         self.header['event_channels']
 
 
@@ -174,15 +172,15 @@
 
         return txt
 
     def _generate_minimal_annotations(self):
         """
         Helper function that generate a nested dict
         of all annotations.
-        must be called when theses are Ok:
+        must be called when these are Ok:
           * block_count()
           * segment_count()
           * signal_channels_count()
           * unit_channels_count()
           * event_channels_count()
 
         Usage:
@@ -256,15 +254,15 @@
             d['file_origin'] = self._source_name()
             a['event_channels'].append(d)
 
         self.raw_annotations = a
 
     def _raw_annotate(self, obj_name, chan_index=0, block_index=0, seg_index=0, **kargs):
         """
-        Annotate a object in the list/dict tree annotations.
+        Annotate an object in the list/dict tree annotations.
         """
         bl_annotations = self.raw_annotations['blocks'][block_index]
         seg_annotations = bl_annotations['segments'][seg_index]
         if obj_name == 'blocks':
             bl_annotations.update(kargs)
         elif obj_name == 'segments':
             seg_annotations.update(kargs)
@@ -313,62 +311,62 @@
         return self.header['nb_block']
 
     def segment_count(self, block_index):
         """return number of segment for a given block"""
         return self.header['nb_segment'][block_index]
 
     def signal_channels_count(self):
-        """Return the number of signal channel.
-        Same allong all block and Segment.
+        """Return the number of signal channels.
+        Same along all Blocks and Segments.
         """
         return len(self.header['signal_channels'])
 
     def unit_channels_count(self):
-        """Return the number of unit (aka spike) channel.
-        Same allong all block and Segment.
+        """Return the number of unit (aka spike) channels.
+        Same along all Blocks and Segment.
         """
         return len(self.header['unit_channels'])
 
     def event_channels_count(self):
-        """Return the number of event/epoch channel.
-        Same allong all block and Segment.
+        """Return the number of event/epoch channels.
+        Same allong all Blocks and Segments.
         """
         return len(self.header['event_channels'])
 
     def segment_t_start(self, block_index, seg_index):
-        """Global t_start of a Segment in s. shared by all objects except
+        """Global t_start of a Segment in s. Shared by all objects except
         for AnalogSignal.
         """
         return self._segment_t_start(block_index, seg_index)
 
     def segment_t_stop(self, block_index, seg_index):
-        """Global t_start of a Segment in s. shared by all objects except
+        """Global t_start of a Segment in s. Shared by all objects except
         for AnalogSignal.
         """
         return self._segment_t_stop(block_index, seg_index)
 
     ###
     # signal and channel zone
 
     def _group_signal_channel_characteristics(self):
         """
-        Usefull for few IOs (TdtrawIO, NeuroExplorerRawIO, ...).
+        Useful for few IOs (TdtrawIO, NeuroExplorerRawIO, ...).
 
         Group signals channels by same characteristics:
           * sampling_rate (global along block and segment)
           * group_id (explicite channel group)
 
-        If all channels have the same characteristics them
+        If all channels have the same characteristics then
         `get_analogsignal_chunk` can be call wihtout restriction.
-        If not then **channel_indexes** must be specified
+        If not, then **channel_indexes** must be specified
         in `get_analogsignal_chunk` and only channels with same
-        caracteristics can be read at the same time.
+        characteristics can be read at the same time.
 
-        This is usefull for some IO  than
-        have internally several signals channels familly.
+        This is useful for some IO  than
+        have internally several signals channels family.
 
         For many RawIO all channels have the same
         sampling_rate/size/t_start. In that cases, internal flag
         **self._several_channel_groups will be set to False, so
         `get_analogsignal_chunk(..)` won't suffer in performance.
 
         Note that at neo.io level this have an impact on
@@ -384,33 +382,33 @@
         if len(unique_characteristics) == 1:
             self._several_channel_groups = False
         else:
             self._several_channel_groups = True
 
     def _check_common_characteristics(self, channel_indexes):
         """
-        Usefull for few IOs (TdtrawIO, NeuroExplorerRawIO, ...).
+        Useful for few IOs (TdtrawIO, NeuroExplorerRawIO, ...).
 
-        Check is a set a signal channel_indexes share common
-        characteristics (**sampling_rate/t_start/size**)
-        Usefull only when RawIO propose differents channels groups
-        with differents sampling_rate for instance.
+        Check that a set a signal channel_indexes share common
+        characteristics (**sampling_rate/t_start/size**).
+        Useful only when RawIO propose differents channels groups
+        with different sampling_rate for instance.
         """
         # ~ print('_check_common_characteristics', channel_indexes)
 
         assert channel_indexes is not None, \
             'You must specify channel_indexes'
         characteristics = self.header['signal_channels'][_common_sig_characteristics]
         # ~ print(characteristics[channel_indexes])
         assert np.unique(characteristics[channel_indexes]).size == 1, \
-            'This channel set have differents characteristics'
+            'This channel set has varied characteristics'
 
-    def get_group_channel_indexes(self):
+    def get_group_signal_channel_indexes(self):
         """
-        Usefull for few IOs (TdtrawIO, NeuroExplorerRawIO, ...).
+        Useful for few IOs (TdtrawIO, NeuroExplorerRawIO, ...).
 
         Return a list of channel_indexes than have same characteristics
         """
         if self._several_channel_groups:
             characteristics = self.header['signal_channels'][_common_sig_characteristics]
             unique_characteristics = np.unique(characteristics)
             channel_indexes_list = []
@@ -439,16 +437,16 @@
         ch = self.header['signal_channels']
         channel_indexes, = np.nonzero(np.in1d(ch['id'], channel_ids))
         assert len(channel_indexes) == len(channel_ids), 'not match'
         return channel_indexes
 
     def _get_channel_indexes(self, channel_indexes, channel_names, channel_ids):
         """
-        select channel_indexes from channel_indexes/channel_names/channel_ids
-        depending which is not None
+        Select channel_indexes from channel_indexes/channel_names/channel_ids
+        depending which is not None.
         """
         if channel_indexes is None and channel_names is not None:
             channel_indexes = self.channel_name_to_index(channel_names)
 
         if channel_indexes is None and channel_ids is not None:
             channel_indexes = self.channel_id_to_index(channel_ids)
 
@@ -521,15 +519,15 @@
 
         """
         timestamp = self._get_spike_timestamps(block_index, seg_index, unit_index, t_start, t_stop)
         return timestamp
 
     def rescale_spike_timestamp(self, spike_timestamps, dtype='float64'):
         """
-        Rescale spike timestamps to second
+        Rescale spike timestamps to seconds.
         """
         return self._rescale_spike_timestamp(spike_timestamps, dtype)
 
     # spiketrain waveform zone
     def get_spike_raw_waveforms(self, block_index=0, seg_index=0, unit_index=0,
                                 t_start=None, t_stop=None):
         wf = self._get_spike_raw_waveforms(block_index, seg_index, unit_index, t_start, t_stop)
@@ -581,44 +579,45 @@
         """
         Rescale epoch raw duration to s
         """
         return self._rescale_epoch_duration(raw_duration, dtype)
 
     def setup_cache(self, cache_path, **init_kargs):
         if self.rawmode in ('one-file', 'multi-file'):
-            ressource_name = self.filename
+            resource_name = self.filename
         elif self.rawmode == 'one-dir':
-            ressource_name = self.dirname
+            resource_name = self.dirname
         else:
-            raise (NotImlementedError)
+            raise (NotImplementedError)
 
         if cache_path == 'home':
             if sys.platform.startswith('win'):
                 dirname = os.path.join(os.environ['APPDATA'], 'neo_rawio_cache')
             elif sys.platform.startswith('darwin'):
                 dirname = '~/Library/Application Support/neo_rawio_cache'
             else:
                 dirname = os.path.expanduser('~/.config/neo_rawio_cache')
             dirname = os.path.join(dirname, self.__class__.__name__)
 
             if not os.path.exists(dirname):
                 os.makedirs(dirname)
         elif cache_path == 'same_as_resource':
-            dirname = os.path.dirname(ressource_name)
+            dirname = os.path.dirname(resource_name)
         else:
             assert os.path.exists(cache_path), \
-                'cache_path do not exists use "home" or "same_as_file" to make this auto'
+                'cache_path do not exists use "home" or "same_as_resource" to make this auto'
 
-        # the hash of the ressource (dir of file) is done with filename+datetime
-        # TODO make something more sofisticated when rawmode='one-dir' that use all filename and datetime
-        d = dict(ressource_name=ressource_name, mtime=os.path.getmtime(ressource_name))
+        # the hash of the resource (dir of file) is done with filename+datetime
+        # TODO make something more sophisticated when rawmode='one-dir' that use all
+        #  filename and datetime
+        d = dict(ressource_name=resource_name, mtime=os.path.getmtime(resource_name))
         hash = joblib.hash(d, hash_name='md5')
 
-        # name is compund by the real_n,ame and the hash
-        name = '{}_{}'.format(os.path.basename(ressource_name), hash)
+        # name is constructed from the real_n,ame and the hash
+        name = '{}_{}'.format(os.path.basename(resource_name), hash)
         self.cache_filename = os.path.join(dirname, name)
 
         if os.path.exists(self.cache_filename):
             self.logger.warning('Use existing cache file {}'.format(self.cache_filename))
             self._cache = joblib.load(self.cache_filename)
         else:
             self.logger.warning('Create cache file {}'.format(self.cache_filename))
@@ -632,15 +631,15 @@
 
     def dump_cache(self):
         assert self.use_cache
         joblib.dump(self._cache, self.cache_filename)
 
     ##################
 
-    # Functions to be implement in IO below here
+    # Functions to be implemented in IO below here
 
     def _parse_header(self):
         raise (NotImplementedError)
         # must call
         # self._generate_empty_annotations()
 
     def _source_name(self):
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `neo-0.8.0/neo/rawio/bci2000rawio.py` & `neo-0.9.0/neo/rawio/bci2000rawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 BCI2000RawIO is a class to read BCI2000 .dat files.
 https://www.bci2000.org/mediawiki/index.php/Technical_Reference:BCI2000_File_Format
 """
-from __future__ import print_function, division, absolute_import  # unicode_literals
 
 from .baserawio import BaseRawIO, _signal_channel_dtype, _unit_channel_dtype, _event_channel_dtype
 
 import numpy as np
 import re
 
 try:
@@ -43,15 +41,27 @@
             ch_name = param_defs['ChannelNames']['value'][chan_ix] \
                 if 'ChannelNames' in param_defs and param_defs['ChannelNames']['value'] is not np.nan else 'ch' + str(chan_ix)
             chan_id = chan_ix + 1
             sr = param_defs['SamplingRate']['value']  # Hz
             dtype = file_info['DataFormat']
             units = 'uV'
             gain = param_defs['SourceChGain']['value'][chan_ix]
+
+            if isinstance(gain, str):
+                r = re.findall(r'(\d+)(\D+)', gain)
+                # some files have strange units attached to gain
+                # in that case it is ignored
+                if len(r) == 1:
+                    gain = r[0][0]
+                gain = float(gain)
+
             offset = param_defs['SourceChOffset']['value'][chan_ix]
+            if isinstance(offset, str):
+                offset = float(offset)
+
             group_id = 0
             sig_channels.append((ch_name, chan_id, sr, dtype, units, gain, offset, group_id))
         self.header['signal_channels'] = np.array(sig_channels, dtype=_signal_channel_dtype)
 
         self.header['unit_channels'] = np.array([], dtype=_unit_channel_dtype)
 
         # creating event channel for each state variable
@@ -201,15 +211,15 @@
                     st_ch_ix = np.where(np.hstack((0, np.diff(state_vec))) != 0)[0]  # event inds
                     if len(st_ch_ix) > 0:
                         ev_times = st_ch_ix
                         durs = np.asarray([None] * len(st_ch_ix))
                         # np.hstack((np.diff(st_ch_ix), len(state_vec) - st_ch_ix[-1]))
                         vals = np.char.mod('%d', state_vec[st_ch_ix])  # event val, string'd
 
-                self._my_events.append([ev_times, durs, vals])
+                self._my_events.append([ev_times, durs, vals.astype('U')])
 
         return self._my_events
 
 
 def parse_bci2000_header(filename):
     # typically we want parameter values in Hz, seconds, or microvolts.
     scales_dict = {
@@ -243,16 +253,15 @@
             el_labels = [unquote(param_list.pop(0)) for x in range(num_els)]
             param_list.pop(0)  # Remove the '}'
         else:
             num_els = int(num_els)
             el_labels = [str(ix) for ix in range(num_els)]
         return num_els, el_labels
 
-    import io
-    with io.open(filename, 'rb') as fid:
+    with open(filename, 'rb') as fid:
 
         # Parse the file header (plain text)
 
         # The first line contains basic information which we store in a dictionary.
         temp = fid.readline().decode('utf8').split()
         keys = [k.rstrip('=') for k in temp[::2]]
         vals = temp[1::2]
```

### Comparing `neo-0.8.0/neo/rawio/blackrockrawio.py` & `neo-0.9.0/neo/rawio/blackrockrawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Module for reading data from files in the Blackrock in raw format.
 
 This work is based on:
   * Chris Rodgers - first version
   * Michael Denker, Lyuba Zehl - second version
   * Samuel Garcia - third version
@@ -53,15 +52,14 @@
     (file spec 2.1 and 2.2)
   * read sif file information
   * read ccf file information
   * fix reading of periodic sampling events (non-neural event type)
     (file spec 2.1 and 2.2)
 """
 
-from __future__ import absolute_import, division, print_function
 
 import datetime
 import os
 import re
 import warnings
 
 import numpy as np
@@ -746,23 +744,19 @@
         if name == 'comments':
             events_data, event_segment_ids = self.nev_data['Comments']
             ev_dict = self.__comment_evdict[self.__nev_spec](events_data)[name]
             # If immediate decoding is desired:
             encoding = {0: 'latin_1', 1: 'utf_16', 255: 'latin_1'}
             labels = [data[ev_dict['field']].decode(
                 encoding[data['char_set']]) for data in events_data]
-            # Only ASCII can be allowed due to using numpy
-            # labels.astype('S') forces to use bytes in BaseFromRaw 401, in read_segment
-            # This is not recommended
-            # TODO: Maybe switch to astype('U')
-            labels = np.array([data.encode('ASCII', errors='ignore') for data in labels])
+            labels = np.array(labels, dtype='U')
         else:
             events_data, event_segment_ids = self.nev_data['NonNeural']
             ev_dict = self.__nonneural_evdicts[self.__nev_spec](events_data)[name]
-            labels = events_data[ev_dict['field']]
+            labels = events_data[ev_dict['field']].astype('U')
 
         mask = ev_dict['mask'] & (event_segment_ids == seg_index)
         timestamp = events_data[mask]['timestamp']
         labels = labels[mask]
 
         # time clip
         sl = self._get_timestamp_slice(timestamp, seg_index, t_start, t_stop)
```

### Comparing `neo-0.8.0/neo/rawio/brainvisionrawio.py` & `neo-0.9.0/neo/rawio/brainvisionrawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,24 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from BrainVision product.
 
 This code was originally made by L. Pezard (2010), modified B. Burle and
 S. More.
 
 Author: Samuel Garcia
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 
 import datetime
 import os
 import re
-import io
 
 
 class BrainVisionRawIO(BaseRawIO):
     """
 
     """
     extensions = ['vhdr']
@@ -182,15 +179,15 @@
 
     def _rescale_event_timestamp(self, event_timestamps, dtype):
         event_times = event_timestamps.astype(dtype) / self._sampling_rate
         return event_times
 
 
 def read_brainvsion_soup(filename):
-    with io.open(filename, 'r', encoding='utf8') as f:
+    with open(filename, 'r', encoding='utf8') as f:
         section = None
         all_info = {}
         for line in f:
             line = line.strip('\n').strip('\r')
             if line.startswith('['):
                 section = re.findall(r'\[([\S ]+)\]', line)[0]
                 all_info[section] = {}
```

### Comparing `neo-0.8.0/neo/rawio/elanrawio.py` & `neo-0.9.0/neo/rawio/elanrawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from Elan.
 
 Elan is software for studying time-frequency maps of EEG data.
 
 Elan is developed in Lyon, France, at INSERM U821
 
@@ -12,15 +11,14 @@
  - .eeg          raw data file
  - .eeg.ent      hearder file
  - .eeg.pos      event file
 
 Author: Samuel Garcia
 
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 
 import datetime
@@ -35,15 +33,15 @@
 
     def __init__(self, filename=''):
         BaseRawIO.__init__(self)
         self.filename = filename
 
     def _parse_header(self):
 
-        with io.open(self.filename + '.ent', mode='rt', encoding='ascii', newline=None) as f:
+        with open(self.filename + '.ent', mode='rt', encoding='ascii', newline=None) as f:
 
             # version
             version = f.readline()[:-1]
             assert version in ['V2', 'V3'], 'Read only V2 or V3 .eeg.ent files. %s given' % version
 
             # info
             info1 = f.readline()[:-1]
@@ -137,15 +135,15 @@
 
         # raw data
         self._raw_signals = np.memmap(self.filename, dtype=sig_dtype, mode='r',
                                       offset=0).reshape(-1, nb_channel + 2)
         self._raw_signals = self._raw_signals[:, :-2]
 
         # triggers
-        with io.open(self.filename + '.pos', mode='rt', encoding='ascii', newline=None) as f:
+        with open(self.filename + '.pos', mode='rt', encoding='ascii', newline=None) as f:
             self._raw_event_timestamps = []
             self._event_labels = []
             self._reject_codes = []
             for l in f.readlines():
                 r = re.findall(r' *(\d+) *(\d+) *(\d+) *', l)
                 self._raw_event_timestamps.append(int(r[0][0]))
                 self._event_labels.append(str(r[0][1]))
```

### Comparing `neo-0.8.0/neo/rawio/examplerawio.py` & `neo-0.9.0/neo/rawio/examplerawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 ExampleRawIO is a class of a  fake example.
 This is to be used when coding a new RawIO.
 
 
 Rules for creating a new class:
   1. Step 1: Create the main class
@@ -33,15 +32,14 @@
   4.Step 4 : IO test
     * create a file in neo/test/iotest with the same previous name with "test_" prefix
     * copy/paste from neo/test/iotest/test_exampleio.py
 
 
 
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
```

### Comparing `neo-0.8.0/neo/rawio/intanrawio.py` & `neo-0.9.0/neo/rawio/intanrawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 
 Support for intan tech rhd  and rhs files.
 
 This 2 formats are more or less the same but:
   * some variance in headers.
   * rhs amplifier is more complexe because the optional DC channel
@@ -13,15 +12,14 @@
 See:
   * http://intantech.com/files/Intan_RHD2000_data_file_formats.pdf
   * http://intantech.com/files/Intan_RHS2000_data_file_formats.pdf
 
 Author: Samuel Garcia
 
 """
-from __future__ import print_function, division, absolute_import
 # from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 from collections import OrderedDict
```

### Comparing `neo-0.8.0/neo/rawio/micromedrawio.py` & `neo-0.9.0/neo/rawio/micromedrawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,15 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading/writing data from micromed (.trc).
 Inspired by the Matlab code for EEGLAB from Rami K. Niazy.
 
 Completed with matlab Guillaume BECQ code.
 
 Author: Samuel Garcia
 """
-from __future__ import print_function, division, absolute_import
 # from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
 
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
@@ -37,15 +35,15 @@
     rawmode = 'one-file'
 
     def __init__(self, filename=''):
         BaseRawIO.__init__(self)
         self.filename = filename
 
     def _parse_header(self):
-        with io.open(self.filename, 'rb') as fid:
+        with open(self.filename, 'rb') as fid:
             f = StructFile(fid)
 
             # Name
             f.seek(64)
             surname = f.read(22).strip(b' ')
             firstname = f.read(20).strip(b' ')
 
@@ -214,15 +212,20 @@
             raw_event = raw_event[keep]
 
         timestamp = raw_event['start']
         if event_channel_index < 2:
             durations = None
         else:
             durations = raw_event['stop'] - raw_event['start']
-        labels = raw_event['label'].astype('U')
+
+        try:
+            labels = raw_event['label'].astype('U')
+        except UnicodeDecodeError:
+            # sometimes the conversion do not work : here a simple fix
+            labels = np.array([e.decode('cp1252') for e in raw_event['label']], dtype='U')
 
         return timestamp, durations, labels
 
     def _rescale_event_timestamp(self, event_timestamps, dtype):
         event_times = event_timestamps.astype(dtype) / self._sampling_rate
         return event_times
```

### Comparing `neo-0.8.0/neo/rawio/neuralynxrawio.py` & `neo-0.9.0/neo/rawio/neuralynxrawio.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,63 +1,72 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from Neuralynx files.
 This IO supports NCS, NEV, NSE and NTT file formats.
 
 
-NCS contains signals for one channel
+NCS contains sampled signal for one channel
 NEV contains events
 NSE contains spikes and waveforms for mono electrodes
 NTT contains spikes and waveforms for tetrodes
 
 
-NCS can contains gaps that can be detected in inregularity
-in timestamps of data blocks. Each gap lead to one new segment.
-NCS files need to be read entirely to detect that gaps.... too bad....
+NCS can contains gaps that can be detected in irregularity
+in timestamps of data blocks. Each gap leads to one new segment.
+Some NCS files may need to be read entirely to detect those gaps which can be slow.
 
 
 Author: Julia Sprenger, Carlos Canova, Samuel Garcia
 """
-from __future__ import print_function, division, absolute_import
 # from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
 
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype,
                         _unit_channel_dtype, _event_channel_dtype)
 
 import numpy as np
 import os
 import re
 import distutils.version
 import datetime
 from collections import OrderedDict
 
 BLOCK_SIZE = 512  # nb sample per signal block
-HEADER_SIZE = 2 ** 14  # file have a txt header of 16kB
 
 
 class NeuralynxRawIO(BaseRawIO):
     """"
-    Class for reading dataset recorded by Neuralynx.
+    Class for reading datasets recorded by Neuralynx.
+
+    This version only works with rawmode of one-dir for a single directory.
 
     Examples:
         >>> reader = NeuralynxRawIO(dirname='Cheetah_v5.5.1/original_data')
         >>> reader.parse_header()
 
-            Inspect all file in the directory.
+            Inspect all files in the directory.
 
         >>> print(reader)
 
-            Display all informations about signal channels, units, segment size....
+            Display all information about signal channels, units, segment size....
     """
     extensions = ['nse', 'ncs', 'nev', 'ntt']
     rawmode = 'one-dir'
 
-    def __init__(self, dirname='', **kargs):
+    def __init__(self, dirname='', keep_original_times=False, **kargs):
+        """
+        Parameters
+        ----------
+        dirname: str
+            name of directory containing all files for dataset
+        keep_original_times:
+            if True, keep original start time as in files,
+            otherwise set 0 of time to first time in dataset
+        """
         self.dirname = dirname
+        self.keep_original_times = keep_original_times
         BaseRawIO.__init__(self, **kargs)
 
     def _source_name(self):
         return self.dirname
 
     def _parse_header(self):
 
@@ -69,49 +78,53 @@
         self.nse_ntt_filenames = OrderedDict()  # (chan_name, chan_id): filename
         self.nev_filenames = OrderedDict()  # chan_id: filename
 
         self._nev_memmap = {}
         self._spike_memmap = {}
         self.internal_unit_ids = []  # channel_index > ((channel_name, channel_id), unit_id)
         self.internal_event_ids = []
-        self._empty_ncs = []  # this list contains filenames of empty records
+        self._empty_ncs = []  # this list contains filenames of empty files
+        self._empty_nev = []
         self._empty_nse_ntt = []
 
-        # explore the directory looking for ncs, nev, nse and ntt
-        # And construct channels headers
+        # Explore the directory looking for ncs, nev, nse and ntt
+        # and construct channels headers.
         signal_annotations = []
         unit_annotations = []
         event_annotations = []
 
         for filename in sorted(os.listdir(self.dirname)):
             filename = os.path.join(self.dirname, filename)
 
             _, ext = os.path.splitext(filename)
             ext = ext[1:]  # remove dot
+            ext = ext.lower()  # make lower case for comparisons
             if ext not in self.extensions:
                 continue
 
-            if (os.path.getsize(filename) <= HEADER_SIZE) and (ext in ['ncs']):
+            # Skip Ncs files with only header. Other empty file types
+            # will have an empty dataset constructed later.
+            if (os.path.getsize(filename) <= NlxHeader.HEADER_SIZE) and ext in ['ncs']:
                 self._empty_ncs.append(filename)
                 continue
 
             # All file have more or less the same header structure
-            info = read_txt_header(filename)
+            info = NlxHeader.build_for_file(filename)
             chan_names = info['channel_names']
             chan_ids = info['channel_ids']
 
             for idx, chan_id in enumerate(chan_ids):
                 chan_name = chan_names[idx]
 
                 chan_uid = (chan_name, chan_id)
                 if ext == 'ncs':
-                    # a signal channels
+                    # a sampled signal channel
                     units = 'uV'
                     gain = info['bit_to_microVolt'][idx]
-                    if info['input_inverted']:
+                    if info.get('input_inverted', False):
                         gain *= -1
                     offset = 0.
                     group_id = 0
                     sig_channels.append((chan_name, chan_id, info['sampling_rate'],
                                          'int16', units, gain, offset, group_id))
                     self.ncs_filenames[chan_uid] = filename
                     keys = [
@@ -136,93 +149,108 @@
                         'NumADChannels',
                         'DspHighCutFilterType',
                     ]
                     d = {k: info[k] for k in keys if k in info}
                     signal_annotations.append(d)
 
                 elif ext in ('nse', 'ntt'):
-                    # nse and ntt are pretty similar except for the wavform shape
-                    # a file can contain several unit_id (so several unit channel)
+                    # nse and ntt are pretty similar except for the waveform shape.
+                    # A file can contain several unit_id (so several unit channel).
                     assert chan_id not in self.nse_ntt_filenames, \
                         'Several nse or ntt files have the same unit_id!!!'
                     self.nse_ntt_filenames[chan_uid] = filename
 
                     dtype = get_nse_or_ntt_dtype(info, ext)
 
-                    if (os.path.getsize(filename) <= HEADER_SIZE):
+                    if (os.path.getsize(filename) <= NlxHeader.HEADER_SIZE):
                         self._empty_nse_ntt.append(filename)
                         data = np.zeros((0,), dtype=dtype)
                     else:
-                        data = np.memmap(filename, dtype=dtype, mode='r', offset=HEADER_SIZE)
+                        data = np.memmap(filename, dtype=dtype, mode='r',
+                                         offset=NlxHeader.HEADER_SIZE)
 
                     self._spike_memmap[chan_uid] = data
 
                     unit_ids = np.unique(data['unit_id'])
                     for unit_id in unit_ids:
                         # a spike channel for each (chan_id, unit_id)
                         self.internal_unit_ids.append((chan_uid, unit_id))
 
                         unit_name = "ch{}#{}#{}".format(chan_name, chan_id, unit_id)
                         unit_id = '{}'.format(unit_id)
                         wf_units = 'uV'
                         wf_gain = info['bit_to_microVolt'][idx]
-                        if info['input_inverted']:
+                        if info.get('input_inverted', False):
                             wf_gain *= -1
                         wf_offset = 0.
                         wf_left_sweep = -1  # NOT KNOWN
                         wf_sampling_rate = info['sampling_rate']
                         unit_channels.append(
                             (unit_name, '{}'.format(unit_id), wf_units, wf_gain,
                              wf_offset, wf_left_sweep, wf_sampling_rate))
                         unit_annotations.append(dict(file_origin=filename))
 
                 elif ext == 'nev':
                     # an event channel
                     # each ('event_id',  'ttl_input') give a new event channel
                     self.nev_filenames[chan_id] = filename
-                    data = np.memmap(
-                        filename, dtype=nev_dtype, mode='r', offset=HEADER_SIZE)
-                    internal_ids = np.unique(
-                        data[['event_id', 'ttl_input']]).tolist()
+
+                    if (os.path.getsize(filename) <= NlxHeader.HEADER_SIZE):
+                        self._empty_nev.append(filename)
+                        data = np.zeros((0,), dtype=nev_dtype)
+                        internal_ids = []
+                    else:
+                        data = np.memmap(filename, dtype=nev_dtype, mode='r',
+                                         offset=NlxHeader.HEADER_SIZE)
+                        internal_ids = np.unique(data[['event_id', 'ttl_input']]).tolist()
                     for internal_event_id in internal_ids:
                         if internal_event_id not in self.internal_event_ids:
                             event_id, ttl_input = internal_event_id
                             name = '{} event_id={} ttl={}'.format(
                                 chan_name, event_id, ttl_input)
                             event_channels.append((name, chan_id, 'event'))
                             self.internal_event_ids.append(internal_event_id)
 
                     self._nev_memmap[chan_id] = data
 
         sig_channels = np.array(sig_channels, dtype=_signal_channel_dtype)
         unit_channels = np.array(unit_channels, dtype=_unit_channel_dtype)
         event_channels = np.array(event_channels, dtype=_event_channel_dtype)
 
+        # require all sampled signals, ncs files, to have same sampling rate
         if sig_channels.size > 0:
             sampling_rate = np.unique(sig_channels['sampling_rate'])
             assert sampling_rate.size == 1
             self._sigs_sampling_rate = sampling_rate[0]
 
-        # read ncs files for gaps detection and nb_segment computation
-        self.read_ncs_files(self.ncs_filenames)
+        # set 2 attributes needed later for header in case there are no ncs files in dataset,
+        #   e.g. Pegasus
+        self._timestamp_limits = None
+        self._nb_segment = 1
+
+        # Read ncs files for gap detection and nb_segment computation.
+        # :TODO: current algorithm depends on side-effect of read_ncs_files on
+        #   self._sigs_memmap, self._sigs_t_start, self._sigs_t_stop,
+        #   self._sigs_length, self._nb_segment, self._timestamp_limits
+        ncsBlocks = self.read_ncs_files(self.ncs_filenames)
 
-        # timestamp limit in nev, nse
-        # so need to scan all spike and event to
+        # Determine timestamp limits in nev, nse file by scanning them.
         ts0, ts1 = None, None
         for _data_memmap in (self._spike_memmap, self._nev_memmap):
             for _, data in _data_memmap.items():
                 ts = data['timestamp']
                 if ts.size == 0:
                     continue
                 if ts0 is None:
                     ts0 = ts[0]
                     ts1 = ts[-1]
                 ts0 = min(ts0, ts[0])
-                ts1 = max(ts0, ts[-1])
+                ts1 = max(ts1, ts[-1])
 
+        # decide on segment and global start and stop times based on files available
         if self._timestamp_limits is None:
             # case  NO ncs but HAVE nev or nse
             self._timestamp_limits = [(ts0, ts1)]
             self._seg_t_starts = [ts0 / 1e6]
             self._seg_t_stops = [ts1 / 1e6]
             self.global_t_start = ts0 / 1e6
             self.global_t_stop = ts1 / 1e6
@@ -237,15 +265,19 @@
         else:
             # case HAVE ncs but  NO nev or nse
             self._seg_t_starts = self._sigs_t_start
             self._seg_t_stops = self._sigs_t_stop
             self.global_t_start = self._sigs_t_start[0]
             self.global_t_stop = self._sigs_t_stop[-1]
 
-        # fille into header dict
+        if self.keep_original_times:
+            self.global_t_stop = self.global_t_stop - self.global_t_start
+            self.global_t_start = 0
+
+        # fill header dictionary
         self.header = {}
         self.header['nb_block'] = 1
         self.header['nb_segment'] = [self._nb_segment]
         self.header['signal_channels'] = sig_channels
         self.header['unit_channels'] = unit_channels
         self.header['event_channels'] = event_channels
 
@@ -273,27 +305,48 @@
                 ev_ann['file_origin'] = self.nev_filenames[chan_id]
 
                 # ~ ev_ann['marker_id'] =
                 # ~ ev_ann['nttl'] =
                 # ~ ev_ann['digital_marker'] =
                 # ~ ev_ann['analog_marker'] =
 
+    # Accessors for segment times which are offset by appropriate global start time
     def _segment_t_start(self, block_index, seg_index):
         return self._seg_t_starts[seg_index] - self.global_t_start
 
     def _segment_t_stop(self, block_index, seg_index):
         return self._seg_t_stops[seg_index] - self.global_t_start
 
     def _get_signal_size(self, block_index, seg_index, channel_indexes):
         return self._sigs_length[seg_index]
 
     def _get_signal_t_start(self, block_index, seg_index, channel_indexes):
         return self._sigs_t_start[seg_index] - self.global_t_start
 
     def _get_analogsignal_chunk(self, block_index, seg_index, i_start, i_stop, channel_indexes):
+        """
+        Retrieve chunk of analog signal, a chunk being a set of contiguous samples.
+
+        PARAMETERS
+        ----------
+        block_index:
+            index of block in dataset, ignored as only 1 block in this implementation
+        seg_index:
+            index of segment to use
+        i_start:
+            sample index of first sample within segment to retrieve
+        i_stop:
+            sample index of last sample within segment to retrieve
+        channel_indexes:
+            list of channel indices to return data for
+
+        RETURNS
+        -------
+            array of samples, with each requested channel in a column
+        """
         if i_start is None:
             i_start = 0
         if i_stop is None:
             i_stop = self._sigs_length[seg_index]
 
         block_start = i_start // BLOCK_SIZE
         block_stop = i_stop // BLOCK_SIZE + 1
@@ -302,29 +355,32 @@
 
         if channel_indexes is None:
             channel_indexes = slice(None)
 
         channel_ids = self.header['signal_channels'][channel_indexes]['id']
         channel_names = self.header['signal_channels'][channel_indexes]['name']
 
+        # create buffer for samples
         sigs_chunk = np.zeros((i_stop - i_start, len(channel_ids)), dtype='int16')
+
         for i, chan_uid in enumerate(zip(channel_names, channel_ids)):
             data = self._sigs_memmap[seg_index][chan_uid]
             sub = data[block_start:block_stop]
             sigs_chunk[:, i] = sub['samples'].flatten()[sl0:sl1]
 
         return sigs_chunk
 
     def _spike_count(self, block_index, seg_index, unit_index):
         chan_uid, unit_id = self.internal_unit_ids[unit_index]
         data = self._spike_memmap[chan_uid]
         ts = data['timestamp']
 
         ts0, ts1 = self._timestamp_limits[seg_index]
 
+        # only count spikes inside the timestamp limits, inclusive, and for the specified unit
         keep = (ts >= ts0) & (ts <= ts1) & (unit_id == data['unit_id'])
         nb_spike = int(data[keep].size)
         return nb_spike
 
     def _get_spike_timestamps(self, block_index, seg_index, unit_index, t_start, t_stop):
         chan_uid, unit_id = self.internal_unit_ids[unit_index]
         data = self._spike_memmap[chan_uid]
@@ -406,15 +462,17 @@
         event_times = event_timestamps.astype(dtype)
         event_times /= 1e6
         event_times -= self.global_t_start
         return event_times
 
     def read_ncs_files(self, ncs_filenames):
         """
-        Given a list of ncs files contrsuct:
+        Given a list of ncs files, return a dictionary of NcsBlocks indexed by channel uid.
+
+        :TODO: Current algorithm has side effects on following attributes:
             * self._sigs_memmap = [ {} for seg_index in range(self._nb_segment) ]
             * self._sigs_t_start = []
             * self._sigs_t_stop = []
             * self._sigs_length = []
             * self._nb_segment
             * self._timestamp_limits
 
@@ -424,24 +482,25 @@
         Other files are not read entirely but we check than gaps
         are at the same place.
 
 
         gap_indexes can be given (when cached) to avoid full read.
 
         """
+        # :TODO: Needs to account for gaps and start and end times potentially
+        #    being different in different groups of channels. These groups typically
+        #    correspond to the channels collected by a single ADC card.
         if len(ncs_filenames) == 0:
-            self._nb_segment = 1
-            self._timestamp_limits = None
-            return
+            return None
 
         good_delta = int(BLOCK_SIZE * 1e6 / self._sigs_sampling_rate)
         chan_uid0 = list(ncs_filenames.keys())[0]
         filename0 = ncs_filenames[chan_uid0]
 
-        data0 = np.memmap(filename0, dtype=ncs_dtype, mode='r', offset=HEADER_SIZE)
+        data0 = np.memmap(filename0, dtype=ncs_dtype, mode='r', offset=NlxHeader.HEADER_SIZE)
 
         gap_indexes = None
         lost_indexes = None
 
         if self.use_cache:
             gap_indexes = self._cache.get('gap_indexes')
             lost_indexes = self._cache.get('lost_indexes')
@@ -449,14 +508,17 @@
         # detect gaps on first file
         if (gap_indexes is None) or (lost_indexes is None):
 
             # this can be long!!!!
             timestamps0 = data0['timestamp']
             deltas0 = np.diff(timestamps0)
 
+            # :TODO: This algorithm needs to account for older style files which had a rounded
+            #   off sampling rate in the header.
+            #
             # It should be that:
             # gap_indexes, = np.nonzero(deltas0!=good_delta)
             # but for a file I have found many deltas0==15999, 16000, 16001 (for sampling at 32000)
             # I guess this is a round problem
             # So this is the same with a tolerance of 1 or 2 ticks
             max_tolerance = 2
             mask = np.abs((deltas0 - good_delta).astype('int64')) > max_tolerance
@@ -465,14 +527,17 @@
 
             if self.use_cache:
                 self.add_in_cache(gap_indexes=gap_indexes)
 
             # update for lost_indexes
             # Sometimes NLX writes a faulty block, but it then validates how much samples it wrote
             # the validation field is in delta0['nb_valid'], it should be equal to BLOCK_SIZE
+            # :TODO: this algorithm ignores samples in partially filled blocks, which
+            #   is not strictly necessary as all channels might have same partially filled
+            #   blocks at the end.
 
             lost_indexes, = np.nonzero(data0['nb_valid'] < BLOCK_SIZE)
 
             if self.use_cache:
                 self.add_in_cache(lost_indexes=lost_indexes)
 
         gap_candidates = np.unique([0]
@@ -493,205 +558,310 @@
         self._sigs_t_stop = []
         self._sigs_length = []
         self._timestamp_limits = []
 
         # create segment with subdata block/t_start/t_stop/length
         for chan_uid, ncs_filename in self.ncs_filenames.items():
 
-            data = np.memmap(ncs_filename, dtype=ncs_dtype, mode='r', offset=HEADER_SIZE)
+            data = np.memmap(ncs_filename, dtype=ncs_dtype, mode='r', offset=NlxHeader.HEADER_SIZE)
             assert data.size == data0.size, 'ncs files do not have the same data length'
 
             for seg_index, (i0, i1) in enumerate(gap_pairs):
 
                 assert data[i0]['timestamp'] == data0[i0][
                     'timestamp'], 'ncs files do not have the same gaps'
                 assert data[i1 - 1]['timestamp'] == data0[i1 - 1][
                     'timestamp'], 'ncs files do not have the same gaps'
 
                 subdata = data[i0:i1]
                 self._sigs_memmap[seg_index][chan_uid] = subdata
 
                 if chan_uid == chan_uid0:
                     ts0 = subdata[0]['timestamp']
-                    ts1 = subdata[-1]['timestamp'] \
-                            + np.uint64(BLOCK_SIZE / self._sigs_sampling_rate * 1e6)
+                    ts1 = subdata[-1]['timestamp'] +\
+                        np.uint64(BLOCK_SIZE / self._sigs_sampling_rate * 1e6)
                     self._timestamp_limits.append((ts0, ts1))
                     t_start = ts0 / 1e6
                     self._sigs_t_start.append(t_start)
                     t_stop = ts1 / 1e6
                     self._sigs_t_stop.append(t_stop)
                     length = subdata.size * BLOCK_SIZE
                     self._sigs_length.append(length)
 
 
-# Keys funcitons
-def _to_bool(txt):
-    if txt == 'True':
-        return True
-    elif txt == 'False':
-        return False
-    else:
-        raise Exception('Can not convert %s to bool' % (txt))
-
-
-# keys in
-txt_header_keys = [
-    ('AcqEntName', 'channel_names', None),  # used
-    ('FileType', '', None),
-    ('FileVersion', '', None),
-    ('RecordSize', '', None),
-    ('HardwareSubSystemName', '', None),
-    ('HardwareSubSystemType', '', None),
-    ('SamplingFrequency', 'sampling_rate', float),  # used
-    ('ADMaxValue', '', None),
-    ('ADBitVolts', 'bit_to_microVolt', None),  # used
-    ('NumADChannels', '', None),
-    ('ADChannel', 'channel_ids', None),  # used
-    ('InputRange', '', None),
-    ('InputInverted', 'input_inverted', _to_bool),  # used
-    ('DSPLowCutFilterEnabled', '', None),
-    ('DspLowCutFrequency', '', None),
-    ('DspLowCutNumTaps', '', None),
-    ('DspLowCutFilterType', '', None),
-    ('DSPHighCutFilterEnabled', '', None),
-    ('DspHighCutFrequency', '', None),
-    ('DspHighCutNumTaps', '', None),
-    ('DspHighCutFilterType', '', None),
-    ('DspDelayCompensation', '', None),
-    ('DspFilterDelay_s', '', None),
-    ('DisabledSubChannels', '', None),
-    ('WaveformLength', '', int),
-    ('AlignmentPt', '', None),
-    ('ThreshVal', '', None),
-    ('MinRetriggerSamples', '', None),
-    ('SpikeRetriggerTime', '', None),
-    ('DualThresholding', '', None),
-    (r'Feature \w+ \d+', '', None),
-    ('SessionUUID', '', None),
-    ('FileUUID', '', None),
-    ('CheetahRev', '', None),  # only for old version
-    ('ProbeName', '', None),
-    ('OriginalFileName', '', None),
-    ('TimeCreated', '', None),
-    ('TimeClosed', '', None),
-    ('ApplicationName', '', None),  # also include version number
-    ('AcquisitionSystem', '', None),
-    ('ReferenceChannel', '', None),
-]
+class NcsBlocks():
+    """
+    Contains information regarding the blocks of records in an Ncs file.
+    Factory methods perform parsing of this information from an Ncs file or
+    confirmation that file agrees with block structure.
+    """
+
+    startBlocks = []
+    endBlocks = []
+    sampFreqUsed = 0
+    microsPerSampUsed = 0
 
 
-def read_txt_header(filename):
+class NlxHeader(OrderedDict):
     """
-    All file in neuralynx contains a 16kB hedaer in txt
-    format.
-    This function parse it to create info dict.
-    This include datetime
+    Representation of basic information in all 16 kbytes Neuralynx file headers,
+    including dates opened and closed if given.
     """
-    with open(filename, 'rb') as f:
-        txt_header = f.read(HEADER_SIZE)
-    txt_header = txt_header.strip(b'\x00').decode('latin-1')
-
-    # find keys
-    info = OrderedDict()
-    for k1, k2, type_ in txt_header_keys:
-        pattern = r'-(?P<name>' + k1 + r') (?P<value>[\S ]*)'
-        matches = re.findall(pattern, txt_header)
-        for match in matches:
-            if k2 == '':
-                name = match[0]
+
+    HEADER_SIZE = 2 ** 14  # Neuralynx files have a txt header of 16kB
+
+    # helper function to interpret boolean keys
+    def _to_bool(txt):
+        if txt == 'True':
+            return True
+        elif txt == 'False':
+            return False
+        else:
+            raise Exception('Can not convert %s to bool' % (txt))
+
+    # keys that may be present in header which we parse
+    txt_header_keys = [
+        ('AcqEntName', 'channel_names', None),  # used
+        ('FileType', '', None),
+        ('FileVersion', '', None),
+        ('RecordSize', '', None),
+        ('HardwareSubSystemName', '', None),
+        ('HardwareSubSystemType', '', None),
+        ('SamplingFrequency', 'sampling_rate', float),  # used
+        ('ADMaxValue', '', None),
+        ('ADBitVolts', 'bit_to_microVolt', None),  # used
+        ('NumADChannels', '', None),
+        ('ADChannel', 'channel_ids', None),  # used
+        ('InputRange', '', None),
+        ('InputInverted', 'input_inverted', _to_bool),  # used
+        ('DSPLowCutFilterEnabled', '', None),
+        ('DspLowCutFrequency', '', None),
+        ('DspLowCutNumTaps', '', None),
+        ('DspLowCutFilterType', '', None),
+        ('DSPHighCutFilterEnabled', '', None),
+        ('DspHighCutFrequency', '', None),
+        ('DspHighCutNumTaps', '', None),
+        ('DspHighCutFilterType', '', None),
+        ('DspDelayCompensation', '', None),
+        ('DspFilterDelay_s', '', None),
+        ('DisabledSubChannels', '', None),
+        ('WaveformLength', '', int),
+        ('AlignmentPt', '', None),
+        ('ThreshVal', '', None),
+        ('MinRetriggerSamples', '', None),
+        ('SpikeRetriggerTime', '', None),
+        ('DualThresholding', '', None),
+        (r'Feature \w+ \d+', '', None),
+        ('SessionUUID', '', None),
+        ('FileUUID', '', None),
+        ('CheetahRev', '', None),  # only for older versions of Cheetah
+        ('ProbeName', '', None),
+        ('OriginalFileName', '', None),
+        ('TimeCreated', '', None),
+        ('TimeClosed', '', None),
+        ('ApplicationName', '', None),  # also include version number when present
+        ('AcquisitionSystem', '', None),
+        ('ReferenceChannel', '', None),
+        ('NLX_Base_Class_Type', '', None)  # in version 4 and earlier versions of Cheetah
+    ]
+
+    # Filename and datetime may appear in header lines starting with # at
+    # beginning of header or in later versions as a property. The exact format
+    # used depends on the application name and its version as well as the
+    # -FileVersion property.
+    #
+    # There are 3 styles understood by this code and the patterns used for parsing
+    # the items within each are stored in a dictionary. Each dictionary is then
+    # stored in main dictionary keyed by an abbreviation for the style.
+    header_pattern_dicts = {
+        # Cheetah before version 5 and BML
+        'bv5': dict(
+            datetime1_regex=r'## Time Opened: \(m/d/y\): (?P<date>\S+)'
+                            r'  At Time: (?P<time>\S+)',
+            filename_regex=r'## File Name: (?P<filename>\S+)',
+            datetimeformat='%m/%d/%Y %H:%M:%S.%f'),
+        # Cheetah version 5 before and including v 5.6.4
+        'bv5.6.4': dict(
+            datetime1_regex=r'## Time Opened \(m/d/y\): (?P<date>\S+)'
+                            r'  \(h:m:s\.ms\) (?P<time>\S+)',
+            datetime2_regex=r'## Time Closed \(m/d/y\): (?P<date>\S+)'
+                            r'  \(h:m:s\.ms\) (?P<time>\S+)',
+            filename_regex=r'## File Name (?P<filename>\S+)',
+            datetimeformat='%m/%d/%Y %H:%M:%S.%f'),
+        # Cheetah after v 5.6.4 and default for others such as Pegasus
+        'def': dict(
+            datetime1_regex=r'-TimeCreated (?P<date>\S+) (?P<time>\S+)',
+            datetime2_regex=r'-TimeClosed (?P<date>\S+) (?P<time>\S+)',
+            filename_regex=r'-OriginalFileName "?(?P<filename>\S+)"?',
+            datetimeformat='%Y/%m/%d %H:%M:%S')
+    }
+
+    def build_for_file(filename):
+        """
+        Factory function to build NlxHeader for a given file.
+        """
+
+        with open(filename, 'rb') as f:
+            txt_header = f.read(NlxHeader.HEADER_SIZE)
+        txt_header = txt_header.strip(b'\x00').decode('latin-1')
+
+        # must start with 8 # characters
+        assert txt_header.startswith("########"),\
+            'Neuralynx files must start with 8 # characters.'
+
+        # find keys
+        info = NlxHeader()
+        for k1, k2, type_ in NlxHeader.txt_header_keys:
+            pattern = r'-(?P<name>' + k1 + r')\s+(?P<value>[\S ]*)'
+            matches = re.findall(pattern, txt_header)
+            for match in matches:
+                if k2 == '':
+                    name = match[0]
+                else:
+                    name = k2
+                value = match[1].rstrip(' ')
+                if type_ is not None:
+                    value = type_(value)
+                info[name] = value
+
+        # if channel_ids or s not in info then the filename is used
+        name = os.path.splitext(os.path.basename(filename))[0]
+
+        # convert channel ids
+        if 'channel_ids' in info:
+            chid_entries = re.findall(r'\w+', info['channel_ids'])
+            info['channel_ids'] = [int(c) for c in chid_entries]
+        else:
+            info['channel_ids'] = [name]
+
+        # convert channel names
+        if 'channel_names' in info:
+            name_entries = re.findall(r'\w+', info['channel_names'])
+            if len(name_entries) == 1:
+                info['channel_names'] = name_entries * len(info['channel_ids'])
+            assert len(info['channel_names']) == len(info['channel_ids']), \
+                'Number of channel ids does not match channel names.'
+        else:
+            info['channel_names'] = [name] * len(info['channel_ids'])
+
+        # version and application name
+        # older Cheetah versions with CheetahRev property
+        if 'CheetahRev' in info:
+            assert 'ApplicationName' not in info
+            info['ApplicationName'] = 'Cheetah'
+            app_version = info['CheetahRev']
+        # new file version 3.4 does not contain CheetahRev property, but ApplicationName instead
+        elif 'ApplicationName' in info:
+            pattern = r'(\S*) "([\S ]*)"'
+            match = re.findall(pattern, info['ApplicationName'])
+            assert len(match) == 1, 'impossible to find application name and version'
+            info['ApplicationName'], app_version = match[0]
+        # BML Ncs file writing contained neither property, assume BML version 2
+        else:
+            info['ApplicationName'] = 'BML'
+            app_version = "2.0"
+
+        info['ApplicationVersion'] = distutils.version.LooseVersion(app_version)
+
+        # convert bit_to_microvolt
+        if 'bit_to_microVolt' in info:
+            btm_entries = re.findall(r'\S+', info['bit_to_microVolt'])
+            if len(btm_entries) == 1:
+                btm_entries = btm_entries * len(info['channel_ids'])
+            info['bit_to_microVolt'] = [float(e) * 1e6 for e in btm_entries]
+            assert len(info['bit_to_microVolt']) == len(info['channel_ids']), \
+                'Number of channel ids does not match bit_to_microVolt conversion factors.'
+
+        if 'InputRange' in info:
+            ir_entries = re.findall(r'\w+', info['InputRange'])
+            if len(ir_entries) == 1:
+                info['InputRange'] = [int(ir_entries[0])] * len(chid_entries)
             else:
-                name = k2
-            value = match[1].rstrip(' ')
-            if type_ is not None:
-                value = type_(value)
-            info[name] = value
-
-    # if channel_ids or s not in info then the filename is used
-    name = os.path.splitext(os.path.basename(filename))[0]
-
-    # convert channel ids
-    if 'channel_ids' in info:
-        chid_entries = re.findall(r'\w+', info['channel_ids'])
-        info['channel_ids'] = [int(c) for c in chid_entries]
-    else:
-        info['channel_ids'] = [name]
-
-    # convert channel names
-    if 'channel_names' in info:
-        name_entries = re.findall(r'\w+', info['channel_names'])
-        if len(name_entries) == 1:
-            info['channel_names'] = name_entries * len(info['channel_ids'])
-        assert len(info['channel_names']) == len(info['channel_ids']), \
-            'Number of channel ids does not match channel names.'
-    else:
-        info['channel_names'] = [name] * len(info['channel_ids'])
-
-    # version and application name
-    if 'CheetahRev' in info:
-        assert 'ApplicationName' not in info
-        info['ApplicationName'] = 'Cheetah'
-        app_version = info['CheetahRev']
-    else:
-        assert 'ApplicationName' in info
-        pattern = r'(\S*) "([\S ]*)"'
-        match = re.findall(pattern, info['ApplicationName'])
-        assert len(match) == 1, 'impossible to find application name and version'
-        info['ApplicationName'], app_version = match[0]
-    info['ApplicationVersion'] = distutils.version.LooseVersion(app_version)
-
-    # convert bit_to_microvolt
-    if 'bit_to_microVolt' in info:
-        btm_entries = re.findall(r'\S+', info['bit_to_microVolt'])
-        if len(btm_entries) == 1:
-            btm_entries = btm_entries * len(info['channel_ids'])
-        info['bit_to_microVolt'] = [float(e) * 1e6 for e in btm_entries]
-        assert len(info['bit_to_microVolt']) == len(info['channel_ids']), \
-            'Number of channel ids does not match bit_to_microVolt conversion factors.'
-
-    if 'InputRange' in info:
-        ir_entries = re.findall(r'\w+', info['InputRange'])
-        if len(ir_entries) == 1:
-            info['InputRange'] = [int(ir_entries[0])] * len(chid_entries)
+                info['InputRange'] = [int(e) for e in ir_entries]
+            assert len(info['InputRange']) == len(chid_entries), \
+                'Number of channel ids does not match input range values.'
+
+        # Filename and datetime depend on app name, app version, and -FileVersion
+        an = info['ApplicationName']
+        if an == 'Cheetah':
+            av = info['ApplicationVersion']
+            if av < '5':
+                hpd = NlxHeader.header_pattern_dicts['bv5']
+            elif av <= '5.6.4':
+                hpd = NlxHeader.header_pattern_dicts['bv5.6.4']
+            else:
+                hpd = NlxHeader.header_pattern_dicts['def']
+        elif an == 'BML':
+            hpd = NlxHeader.header_pattern_dicts['bv5']
         else:
-            info['InputRange'] = [int(e) for e in ir_entries]
-        assert len(info['InputRange']) == len(chid_entries), \
-            'Number of channel ids does not match input range values.'
-
-    # filename and datetime depend on app name and its version
-    if info['ApplicationName'] == 'Cheetah':
-        if info['ApplicationVersion'] <= '5.6.4':
-            old_date_format = True
+            hpd = NlxHeader.header_pattern_dicts['def']
+
+        original_filename = re.search(hpd['filename_regex'], txt_header).groupdict()['filename']
+
+        # opening time
+        dt1 = re.search(hpd['datetime1_regex'], txt_header).groupdict()
+        info['recording_opened'] = datetime.datetime.strptime(
+            dt1['date'] + ' ' + dt1['time'], hpd['datetimeformat'])
+
+        # close time, if available
+        if 'datetime2_regex' in hpd:
+            dt2 = re.search(hpd['datetime2_regex'], txt_header).groupdict()
+            info['recording_closed'] = datetime.datetime.strptime(
+                dt2['date'] + ' ' + dt2['time'], hpd['datetimeformat'])
+
+        return info
+
+    def type_of_recording(self):
+        """
+        Determines type of recording in Ncs file with this header.
+
+        RETURN:
+            one of 'PRE4','BML','DIGITALLYNX','DIGITALLYNXSX','UNKNOWN'
+        """
+
+        if 'NLX_Base_Class_Type' in self:
+
+            # older style standard neuralynx acquisition with rounded sampling frequency
+            if self['NLX_Base_Class_Type'] == 'CscAcqEnt':
+                return 'PRE4'
+
+            # BML style with fractional frequency and microsPerSamp
+            elif self['NLX_Base_Class_Type'] == 'BmlAcq':
+                return 'BML'
+
+            else:
+                return 'UNKNOWN'
+
+        elif 'HardwareSubSystemType' in self:
+
+            # DigitalLynx
+            if self['HardwareSubSystemType'] == 'DigitalLynx':
+                return 'DIGITALLYNX'
+
+            # DigitalLynxSX
+            elif self['HardwareSubSystemType'] == 'DigitalLynxSX':
+                return 'DIGITALLYNXSX'
+
+        elif 'FileType' in self:
+
+            if self['FileVersion'] in ['3.3', '3.4']:
+                return self['AcquisitionSystem'].split()[1].upper()
+
+            else:
+                return 'UNKNOWN'
+
         else:
-            old_date_format = False
-    else:
-        # for other version (pegasus, ..) I don't known the rules
-        old_date_format = (r'## Time Opened' in txt_header)
-
-    if old_date_format:
-        datetime1_regex = r'## Time Opened \(m/d/y\): (?P<date>\S+)  \(h:m:s\.ms\) (?P<time>\S+)'
-        datetime2_regex = r'## Time Closed \(m/d/y\): (?P<date>\S+)  \(h:m:s\.ms\) (?P<time>\S+)'
-        filename_regex = r'## File Name (?P<filename>\S+)'
-        datetimeformat = '%m/%d/%Y %H:%M:%S.%f'
-    else:
-        datetime1_regex = r'-TimeCreated (?P<date>\S+) (?P<time>\S+)'
-        datetime2_regex = r'-TimeClosed (?P<date>\S+) (?P<time>\S+)'
-        filename_regex = r'-OriginalFileName "?(?P<filename>\S+)"?'
-        datetimeformat = '%Y/%m/%d %H:%M:%S'
-
-    original_filename = re.search(filename_regex, txt_header).groupdict()['filename']
-
-    dt1 = re.search(datetime1_regex, txt_header).groupdict()
-    dt2 = re.search(datetime2_regex, txt_header).groupdict()
-
-    info['recording_opened'] = datetime.datetime.strptime(
-        dt1['date'] + ' ' + dt1['time'], datetimeformat)
-    info['recording_closed'] = datetime.datetime.strptime(
-        dt2['date'] + ' ' + dt2['time'], datetimeformat)
+            return 'UNKNOWN'
 
-    return info
+
+class NcsHeader():
+    """
+    Representation of information in Ncs file headers, including exact
+    recording type.
+    """
 
 
 ncs_dtype = [('timestamp', 'uint64'), ('channel_id', 'uint32'), ('sample_rate', 'uint32'),
              ('nb_valid', 'uint32'), ('samples', 'int16', (BLOCK_SIZE,))]
 
 nev_dtype = [
     ('reserved', '<i2'),
```

### Comparing `neo-0.8.0/neo/rawio/neuroexplorerrawio.py` & `neo-0.9.0/neo/rawio/neuroexplorerrawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from NeuroExplorer (.nex)
 
 Note:
   * NeuroExplorer have introduced a new .nex5 file format
     with 64 timestamps. This is NOT implemented here.
     If someone have some file in that new format we could also
@@ -19,15 +18,14 @@
 Documentation for dev :
 http://www.neuroexplorer.com/downloadspage/
 
 
 Author: Samuel Garcia, luc estebanez, mark hollenbeck
 
 """
-from __future__ import print_function, division, absolute_import
 # from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 from collections import OrderedDict
```

### Comparing `neo-0.8.0/neo/rawio/neuroscoperawio.py` & `neo-0.9.0/neo/rawio/neuroscoperawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Reading from neuroscope format files.
 Ref: http://neuroscope.sourceforge.net/
 
 It is an old format from Buzsaki's lab
 
 Some old open datasets from spike sorting
@@ -12,15 +11,14 @@
 This should be done (but maybe never will):
   * SpikeTrain file   '.clu'  '.res'
   * Event  '.ext.evt'  or '.evt.ext'
 
 Author: Samuel Garcia
 
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 from xml.etree import ElementTree
```

### Comparing `neo-0.8.0/neo/rawio/nixrawio.py` & `neo-0.9.0/neo/rawio/nixrawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 
 The RawIO assumes all segments and all blocks have the same structure.
 It supports all kinds of NEO objects.
 
 Author: Chek Yin Choi
 """
 
-from __future__ import print_function, division, absolute_import
 from .baserawio import (BaseRawIO, _signal_channel_dtype,
                         _unit_channel_dtype, _event_channel_dtype)
 from ..io.nixio import NixIO
 from ..io.nixio import check_nix_version
 import numpy as np
 try:
     import nixio as nix
```

### Comparing `neo-0.8.0/neo/rawio/openephysrawio.py` & `neo-0.9.0/neo/rawio/openephysrawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-# -*- coding: utf-8 -*-
 """
 This module implement OpenEphys format.
 
 Author: Samuel Garcia
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 import os
 import re
 
 import numpy as np
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
@@ -77,35 +75,36 @@
         nb_segment = info['nb_segment']
 
         # scan for continuous files
         self._sigs_memmap = {}
         self._sig_length = {}
         self._sig_timestamp0 = {}
         sig_channels = []
-        for seg_index in range(nb_segment):
+        oe_indices = sorted(list(info['continuous'].keys()))
+        for seg_index, oe_index in enumerate(oe_indices):
             self._sigs_memmap[seg_index] = {}
 
             all_sigs_length = []
             all_first_timestamps = []
             all_last_timestamps = []
             all_samplerate = []
-            for chan_index, continuous_filename in enumerate(info['continuous'][seg_index]):
+            for chan_index, continuous_filename in enumerate(info['continuous'][oe_index]):
                 fullname = os.path.join(self.dirname, continuous_filename)
                 chan_info = read_file_header(fullname)
 
                 s = continuous_filename.replace('.continuous', '').split('_')
                 processor_id, ch_name = s[0], s[1]
                 chan_str = re.split(r'(\d+)', s[1])[0]
                 # note that chan_id is not unique in case of CH + AUX
                 chan_id = int(ch_name.replace(chan_str, ''))
 
                 filesize = os.stat(fullname).st_size
                 size = (filesize - HEADER_SIZE) // np.dtype(continuous_dtype).itemsize
                 data_chan = np.memmap(fullname, mode='r', offset=HEADER_SIZE,
-                                        dtype=continuous_dtype, shape=(size, ))
+                                      dtype=continuous_dtype, shape=(size, ))
                 self._sigs_memmap[seg_index][chan_index] = data_chan
 
                 all_sigs_length.append(data_chan.size * RECORD_SIZE)
                 all_first_timestamps.append(data_chan[0]['timestamp'])
                 all_last_timestamps.append(data_chan[-1]['timestamp'])
                 all_samplerate.append(chan_info['sampleRate'])
 
@@ -165,17 +164,17 @@
 
         # scan for spikes files
         unit_channels = []
 
         if len(info['spikes']) > 0:
 
             self._spikes_memmap = {}
-            for seg_index in range(nb_segment):
+            for seg_index, oe_index in enumerate(oe_indices):
                 self._spikes_memmap[seg_index] = {}
-                for spike_filename in info['spikes'][seg_index]:
+                for spike_filename in info['spikes'][oe_index]:
                     fullname = os.path.join(self.dirname, spike_filename)
                     spike_info = read_file_header(fullname)
                     spikes_dtype = make_spikes_dtype(fullname)
 
                     # "STp106.0n0_2.spikes" to "STp106.0n0"
                     name = spike_filename.replace('.spikes', '')
                     if seg_index > 0:
@@ -223,19 +222,19 @@
         unit_channels = np.array(unit_channels, dtype=_unit_channel_dtype)
 
         # event file are:
         #    * all_channel.events (header + binray)  -->  event 0
         # and message.events (text based)      --> event 1 not implemented yet
         event_channels = []
         self._events_memmap = {}
-        for seg_index in range(nb_segment):
-            if seg_index == 0:
+        for seg_index, oe_index in enumerate(oe_indices):
+            if oe_index == 0:
                 event_filename = 'all_channels.events'
             else:
-                event_filename = 'all_channels_{}.events'.format(seg_index + 1)
+                event_filename = 'all_channels_{}.events'.format(oe_index + 1)
 
             fullname = os.path.join(self.dirname, event_filename)
             event_info = read_file_header(fullname)
             self._event_sampling_rate = event_info['sampleRate']
             data_event = np.memmap(fullname, mode='r', offset=HEADER_SIZE,
                                     dtype=events_dtype)
             self._events_memmap[seg_index] = data_event
@@ -251,22 +250,23 @@
         self.header['signal_channels'] = sig_channels
         self.header['unit_channels'] = unit_channels
         self.header['event_channels'] = event_channels
 
         # Annotate some objects from coninuous files
         self._generate_minimal_annotations()
         bl_ann = self.raw_annotations['blocks'][0]
-        for seg_index in range(nb_segment):
+        for seg_index, oe_index in enumerate(oe_indices):
             seg_ann = bl_ann['segments'][seg_index]
             if len(info['continuous']) > 0:
-                fullname = os.path.join(self.dirname, info['continuous'][seg_index][0])
+                fullname = os.path.join(self.dirname, info['continuous'][oe_index][0])
                 chan_info = read_file_header(fullname)
                 seg_ann['openephys_version'] = chan_info['version']
                 bl_ann['openephys_version'] = chan_info['version']
                 seg_ann['date_created'] = chan_info['date_created']
+                seg_ann['openephys_segment_index'] = oe_index + 1
 
     def _segment_t_start(self, block_index, seg_index):
         # segment start/stop are difine by  continuous channels
         return self._sig_timestamp0[seg_index] / self._sig_sampling_rate
 
     def _segment_t_stop(self, block_index, seg_index):
         return (self._sig_timestamp0[seg_index] + self._sig_length[seg_index])\
@@ -354,29 +354,32 @@
         keep = (ts >= ts0) & (ts <= ts1)
 
         subdata = self._events_memmap[seg_index][keep]
         timestamps = subdata['timestamp']
         # question what is the label????
         # here I put a combinaison
         labels = np.array(['{}#{}#{}'.format(int(d['event_type']),
-                                int(d['processor_id']), int(d['chan_id'])) for d in subdata])
+                                             int(d['processor_id']),
+                                             int(d['chan_id']))
+                           for d in subdata],
+                          dtype='U')
         durations = None
 
         return timestamps, durations, labels
 
     def _rescale_event_timestamp(self, event_timestamps, dtype):
         event_times = event_timestamps.astype(dtype) / self._event_sampling_rate
         return event_times
 
     def _rescale_epoch_duration(self, raw_duration, dtype):
         return None
 
 
 continuous_dtype = [('timestamp', 'int64'), ('nb_sample', 'uint16'),
-    ('rec_num', 'uint16'), ('samples', 'int16', RECORD_SIZE),
+    ('rec_num', 'uint16'), ('samples', '>i2', RECORD_SIZE),
     ('markers', 'uint8', 10)]
 
 events_dtype = [('timestamp', 'int64'), ('sample_pos', 'int16'),
     ('event_type', 'uint8'), ('processor_id', 'uint8'),
     ('event_id', 'uint8'), ('chan_id', 'uint8'),
     ('record_num', 'uint16')]
```

### Comparing `neo-0.8.0/neo/rawio/plexonrawio.py` & `neo-0.9.0/neo/rawio/plexonrawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading the old data format from Plexon
 acquisition system (.plx)
 
 Note that Plexon now use a new format PL2 which is NOT
 supported by this IO.
 
@@ -18,15 +17,14 @@
 This should be faster.
 If one day, somebody use it, consider to offer me a beer.
 
 
 Author: Samuel Garcia
 
 """
-from __future__ import print_function, division, absolute_import
 # from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 from collections import OrderedDict
@@ -269,16 +267,16 @@
         for c, channel_index in enumerate(channel_indexes):
             chan_header = self.header['signal_channels'][channel_index]
             chan_id = chan_header['id']
 
             data_blocks = self._data_blocks[5][chan_id]
 
             # loop over data blocks and get chunks
-            bl0 = np.searchsorted(data_blocks['cumsum'], i_start, side='left')
-            bl1 = np.searchsorted(data_blocks['cumsum'], i_stop, side='left')
+            bl0 = np.searchsorted(data_blocks['cumsum'], i_start, side='right') - 1
+            bl1 = np.searchsorted(data_blocks['cumsum'], i_stop, side='right')
             ind = 0
             for bl in range(bl0, bl1):
                 ind0 = data_blocks[bl]['pos']
                 ind1 = data_blocks[bl]['size'] + ind0
                 data = self._memmap[ind0:ind1].view('int16')
                 if bl == bl1 - 1:
                     # right border
```

### Comparing `neo-0.8.0/neo/rawio/rawbinarysignalrawio.py` & `neo-0.9.0/neo/rawio/rawbinarysignalrawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data in a raw binary interleaved compact file.
 Sampling rate, units, number of channel and dtype must be externally known.
 This generic format is quite widely used in old acquisition systems
 and is quite universal for sharing data.
 
 The write part of this IO is only available at neo.io level with the other
@@ -13,15 +12,14 @@
     argmuents of the IO (dtype, nb_channel, sampling_rate) must be
     given at the __init__ and not at read_segment() because there is
     no read_segment() in neo.rawio classes.
 
 
 Author: Samuel Garcia
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 
 import os
```

### Comparing `neo-0.8.0/neo/rawio/rawmcsrawio.py` & `neo-0.9.0/neo/rawio/rawmcsrawio.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from "Raw" Multi Channel System (MCS) format.
 This format is NOT the native MCS format (*.mcd).
 This format is a raw format with an internal binary header exported by the
 "MC_DataTool binary conversion" with the option header selected.
 
 The internal header contains sampling rate, channel names, gain and units.
@@ -10,15 +9,14 @@
 
 If some MCS customers read this you should lobby to get the real specification
 of the real MCS format (.mcd), then an IO module for the native MCS format
 could be written instead of this ersatz.
 
 Author: Samuel Garcia
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 
 import os
```

### Comparing `neo-0.8.0/neo/rawio/spike2rawio.py` & `neo-0.9.0/neo/rawio/spike2rawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Classe for reading data in CED spike2 files (.smr).
 
 This code is based on:
  - sonpy, written by Antonio Gonzalez <Antonio.Gonzalez@cantab.net>
     Disponible here ::
     http://www.neuro.ki.se/broberger/
@@ -14,15 +13,14 @@
 
 This IO support old (<v6) and new files (>v7) of spike2
 
 
 Author: Samuel Garcia
 
 """
-from __future__ import print_function, division, absolute_import
 # from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 from collections import OrderedDict
@@ -50,14 +48,18 @@
         with open(self.filename, 'rb') as fid:
             self._global_info = read_as_dict(fid, headerDescription)
             info = self._global_info
             if info['system_id'] < 6:
                 info['dtime_base'] = 1e-6
                 info['datetime_detail'] = 0
                 info['datetime_year'] = 0
+            if info['system_id'] == 9:
+                self._diskblock = DISKBLOCK
+            else:
+                self._diskblock = 1
 
             self._time_factor = info['us_per_time'] * info['dtime_base']
 
             self._channel_infos = []
             for chan_id in range(info['channels']):
                 fid.seek(512 + 140 * chan_id)
                 chan_info = read_as_dict(fid, channelHeaderDesciption1)
@@ -81,34 +83,34 @@
                         chan_info.update(read_as_dict(fid, [('interleave', 'i2')]))
 
                 chan_info['type'] = dict_kind[chan_info['kind']]
 
                 if chan_info['blocks'] == 0:
                     chan_info['t_start'] = 0.  # this means empty signals
                 else:
-                    fid.seek(chan_info['firstblock'])
+                    fid.seek(chan_info['firstblock'] * self._diskblock)
                     block_info = read_as_dict(fid, blockHeaderDesciption)
                     chan_info['t_start'] = float(block_info['start_time']) * \
                         float(info['us_per_time']) * float(info['dtime_base'])
 
                 self._channel_infos.append(chan_info)
 
         # get data blocks index for all channel
         # run through all data block of of channel to prepare chan to block maps
         self._memmap = np.memmap(self.filename, dtype='u1', offset=0, mode='r')
         self._all_data_blocks = {}
         self._by_seg_data_blocks = {}
         for chan_id, chan_info in enumerate(self._channel_infos):
             data_blocks = []
-            ind = chan_info['firstblock']
+            ind = chan_info['firstblock'] * self._diskblock
             for b in range(chan_info['blocks']):
                 block_info = self._memmap[ind:ind + 20].view(blockHeaderDesciption)[0]
                 data_blocks.append((ind, block_info['items'], 0,
                                     block_info['start_time'], block_info['end_time']))
-                ind = block_info['succ_block']
+                ind = block_info['succ_block'] * self._diskblock
 
             data_blocks = np.array(data_blocks, dtype=[(
                 'pos', 'int32'), ('size', 'int32'), ('cumsum', 'int32'),
                 ('start_time', 'int32'), ('end_time', 'int32')])
             data_blocks['pos'] += 20  # 20 is ths header size
 
             self._all_data_blocks[chan_id] = data_blocks
@@ -119,15 +121,16 @@
         # this part is tricky because we need to check that all channel have same pause.
         all_gaps_block_ind = {}
         for chan_id, chan_info in enumerate(self._channel_infos):
             if chan_info['kind'] in [1, 9]:
                 data_blocks = self._all_data_blocks[chan_id]
                 sig_size = np.sum(self._all_data_blocks[chan_id]['size'])
                 if sig_size > 0:
-                    interval = get_sample_interval(info, chan_info) / self._time_factor
+                    interval = int(np.round(get_sample_interval(info,
+                                            chan_info) / self._time_factor))
                     # detect gaps
                     inter_block_sizes = data_blocks['start_time'][1:] - \
                         data_blocks['end_time'][:-1]
                     gaps_block_ind, = np.nonzero(inter_block_sizes > interval)
                     all_gaps_block_ind[chan_id] = gaps_block_ind
 
         # find t_start/t_stop for each seg based on gaps indexe
@@ -211,15 +214,15 @@
                 if chan_info['kind'] == 1:  # int16
                     gain = chan_info['scale'] / 6553.6
                     offset = chan_info['offset']
                     sig_dtype = 'int16'
                 elif chan_info['kind'] == 9:  # float32
                     gain = 1.
                     offset = 0.
-                    sig_dtype = 'int32'
+                    sig_dtype = 'float32'
                 group_id = 0
                 sig_channels.append((name, chan_id, sampling_rate, sig_dtype,
                                      units, gain, offset, group_id))
 
             elif chan_info['kind'] in [2, 3, 4, 5, 8]:
                 # Event
                 event_channels.append((name, chan_id, 'event'))
@@ -370,16 +373,16 @@
             # But there is no garanty that channels shared the same data block
             # indexes. So this make the job too difficult.
             chan_header = self.header['signal_channels'][channel_index]
             chan_id = chan_header['id']
             data_blocks = self._by_seg_data_blocks[chan_id][seg_index]
 
             # loop over data blocks and get chunks
-            bl0 = np.searchsorted(data_blocks['cumsum'], i_start, side='left')
-            bl1 = np.searchsorted(data_blocks['cumsum'], i_stop, side='left')
+            bl0 = np.searchsorted(data_blocks['cumsum'], i_start, side='right') - 1
+            bl1 = np.searchsorted(data_blocks['cumsum'], i_stop, side='right')
             ind = 0
             for bl in range(bl0, bl1):
                 ind0 = data_blocks[bl]['pos']
                 ind1 = data_blocks[bl]['size'] * dt.itemsize + ind0
                 data = self._memmap[ind0:ind1].view(dt)
                 if bl == bl1 - 1:
                     # right border
@@ -601,18 +604,18 @@
 
 
 def get_sample_interval(info, chan_info):
     """
     Get sample interval for one channel
     """
     if info['system_id'] in [1, 2, 3, 4, 5]:  # Before version 5
-        sample_interval = (chan_info['divide'] * info['us_per_time'] *
+        sample_interval = (int(chan_info['divide']) * info['us_per_time'] *
                            info['time_per_adc']) * 1e-6
     else:
-        sample_interval = (chan_info['l_chan_dvd'] *
+        sample_interval = (int(chan_info['l_chan_dvd']) *
                            info['us_per_time'] * info['dtime_base'])
     return sample_interval
 
 
 # headers structures :
 headerDescription = [
     ('system_id', 'i2'),
@@ -677,7 +680,9 @@
     4: 'EventBoth',
     5: 'Marker',
     6: 'AdcMark',
     7: 'RealMark',
     8: 'TextMark',
     9: 'RealWave',
 }
+
+DISKBLOCK = 512
```

### Comparing `neo-0.8.0/neo/rawio/tdtrawio.py` & `neo-0.9.0/neo/rawio/tdtrawio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from from Tucker Davis TTank format.
 Terminology:
 TDT hold data with tanks (actually a directory). And tanks hold sub block
 (sub directories).
 Tanks correspond to neo.Block and tdt block correspond to neo.Segment.
 
@@ -19,17 +18,14 @@
      and can be use place of TEV.
 
 Units in this IO are not guaranteed.
 
 Author: Samuel Garcia, SummitKwan, Chadwick Boulay
 
 """
-from __future__ import print_function, division, absolute_import
-# from __future__ import unicode_literals is not compatible with numpy.dtype both py2 py3
-
 from .baserawio import BaseRawIO, _signal_channel_dtype, _unit_channel_dtype, _event_channel_dtype
 
 import numpy as np
 import os
 import re
 from collections import OrderedDict
 
@@ -124,16 +120,14 @@
                                 1024:]  # first 1024 bytes are header
                             # update the sort code with the info from this file
                             tsq['sortcode'][1:-1] = newsortcode
                             # print('sortcode updated')
                             break
                 except OSError:
                     pass
-                except IOError:
-                    pass
 
         # Re-order segments according to their start times
         sort_inds = np.argsort(self._seg_t_starts)
         if not np.array_equal(sort_inds, list(range(nb_segment))):
             segment_names = [segment_names[x] for x in sort_inds]
             self._tev_datas = [self._tev_datas[x] for x in sort_inds]
             self._seg_t_starts = [self._seg_t_starts[x] for x in sort_inds]
```

### Comparing `neo-0.8.0/neo/rawio/winedrrawio.py` & `neo-0.9.0/neo/rawio/winedrrawio.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,19 +1,17 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from WinEdr, a software tool written by
 John Dempster.
 
 WinEdr is free:
 http://spider.science.strath.ac.uk/sipbs/software.htm
 
 Author: Samuel Garcia
 
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
 
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 
 import os
```

### Comparing `neo-0.8.0/neo/rawio/winwcprawio.py` & `neo-0.9.0/neo/rawio/winwcprawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,22 @@
-# -*- coding: utf-8 -*-
 """
 Class for reading data from WinWCP, a software tool written by
 John Dempster.
 
 WinWCP is free:
 http://spider.science.strath.ac.uk/sipbs/software.htm
 
 Author : sgarcia
 Author: Samuel Garcia
 """
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 from .baserawio import (BaseRawIO, _signal_channel_dtype, _unit_channel_dtype,
                         _event_channel_dtype)
 
 import numpy as np
 
-import os
-import sys
 import struct
 
 
 class WinWcpRawIO(BaseRawIO):
     extensions = ['wcp']
     rawmode = 'one-file'
```

### Comparing `neo-0.8.0/neo/test/coretest/test_analogsignal.py` & `neo-0.9.0/neo/test/coretest/test_analogsignal.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.analogsignal.AnalogSignal class and related functions
 """
 
-# needed for python 3 compatibility
-from __future__ import division
-
 import os
 import pickle
 import copy
 import warnings
 import unittest
 
 import numpy as np
@@ -20,15 +16,23 @@
 try:
     from IPython.lib.pretty import pretty
 except ImportError as err:
     HAVE_IPYTHON = False
 else:
     HAVE_IPYTHON = True
 
+try:
+    import scipy
+except ImportError:
+    HAVE_SCIPY = False
+else:
+    HAVE_SCIPY = True
+
 from numpy.testing import assert_array_equal
+from neo.core.baseneo import MergeError
 from neo.core.analogsignal import AnalogSignal, _get_sampling_rate
 from neo.core.channelindex import ChannelIndex
 from neo.core import Segment
 
 from neo.test.tools import (assert_arrays_almost_equal, assert_neo_object_is_compliant,
                             assert_same_sub_schema, assert_objects_equivalent,
                             assert_same_attributes, assert_same_sub_schema, assert_arrays_equal,
@@ -366,16 +370,21 @@
     def test__pretty(self):
         for i, signal in enumerate(self.signals):
             prepr = pretty(signal)
             targ = (('AnalogSignal with %d channels of length %d; units %s; datatype %s \n'
                      '' % (signal.shape[1], signal.shape[0],
                            signal.units.dimensionality.unicode, signal.dtype))
                     + ('annotations: %s\n' % signal.annotations)
-                    + ('sampling rate: {}\n'.format(signal.sampling_rate))
-                    + ('time: {} to {}'.format(signal.t_start, signal.t_stop)))
+                    + ('sampling rate: {} {}\n'.format(
+                        float(signal.sampling_rate),
+                        signal.sampling_rate.dimensionality.unicode))
+                    + ('time: {} {} to {} {}'.format(float(signal.t_start),
+                                                     signal.t_start.dimensionality.unicode,
+                                                     float(signal.t_stop),
+                                                     signal.t_stop.dimensionality.unicode)))
             self.assertEqual(prepr, targ)
 
 
 class TestAnalogSignalArrayMethods(unittest.TestCase):
     def setUp(self):
         self.data1 = np.arange(55.0).reshape((11, 5))
         self.data1quant = self.data1 * pq.nA
@@ -729,14 +738,24 @@
     def test__getitem_should_return_single_quantity(self):
         # quantities drops the units in this case
         self.assertEqual(self.signal1[9, 3], 48000 * pq.pA)
         self.assertEqual(self.signal1[9][3], self.signal1[9, 3])
         self.assertTrue(hasattr(self.signal1[9, 3], 'units'))
         self.assertRaises(IndexError, self.signal1.__getitem__, (99, 73))
 
+    def test__time_index(self):
+        # scalar arguments
+        self.assertEqual(self.signal2.time_index(2.0 * pq.s), 2)
+        self.assertEqual(self.signal2.time_index(1.99 * pq.s), 2)
+        self.assertEqual(self.signal2.time_index(2.01 * pq.s), 2)
+
+        # vector arguments
+        assert_array_equal(self.signal2.time_index([2.0, 0.99, 3.01] * pq.s), [2, 1, 3])
+        assert_array_equal(self.signal2.time_index([2.0] * pq.s), [2])
+
     def test__time_slice(self):
         t_start = 2 * pq.s
         t_stop = 4 * pq.s
 
         result = self.signal2.time_slice(t_start, t_stop)
         self.assertIsInstance(result, AnalogSignal)
         assert_neo_object_is_compliant(result)
@@ -1154,14 +1173,127 @@
         # Signals 0 and 1 are selected completely,
         # so their respective array_annotations should be returned
         result3 = signal[:, 0:2]
         assert_arrays_equal(result3.array_annotations['index'], np.array([10, 15]))
         assert_arrays_equal(result3.array_annotations['label'], np.array(['abc', 'def']))
         self.assertIsInstance(result3.array_annotations, ArrayDict)
 
+    @unittest.skipUnless(HAVE_SCIPY, "requires Scipy")
+    def test_downsample(self):
+        # generate signal long enough for decimating
+        data = np.sin(np.arange(1500) / 30).reshape(500, 3) * pq.mV
+        signal = AnalogSignal(data, sampling_rate=30000 * pq.Hz)
+
+        # test decimation using different decimation factors
+        factors = [1, 9, 10, 11]
+        for factor in factors:
+            desired = signal[::factor].magnitude
+            result = signal.downsample(factor)
+
+            self.assertEqual(np.ceil(signal.shape[0] / factor), result.shape[0])
+            self.assertEqual(signal.shape[-1],
+                             result.shape[-1])  # preserve number of recording traces
+            self.assertAlmostEqual(signal.sampling_rate, factor * result.sampling_rate)
+            # only comparing center values due to border effects
+            np.testing.assert_allclose(desired[3:-3], result.magnitude[3:-3], rtol=0.05, atol=0.1)
+
+    @unittest.skipUnless(HAVE_SCIPY, "requires Scipy")
+    def test_resample_less_samples(self):
+        # generate signal long enough for resampling
+        data = np.sin(np.arange(1500) / 30).reshape(3, 500).T * pq.mV
+        signal = AnalogSignal(data, sampling_rate=30000 * pq.Hz)
+
+        # test resampling using different numbers of desired samples
+        sample_counts = [10, 100, 400]
+        for sample_count in sample_counts:
+            sample_ids = np.linspace(0, signal.shape[0], sample_count, dtype=int, endpoint=False)
+            desired = signal.magnitude[sample_ids]
+            result = signal.resample(sample_count)
+
+            self.assertEqual(sample_count, result.shape[0])
+            self.assertEqual(signal.shape[-1],
+                             result.shape[-1])  # preserve number of recording traces
+            self.assertAlmostEqual(sample_count / signal.shape[0] * signal.sampling_rate,
+                                   result.sampling_rate)
+            # only comparing center values due to border effects
+            np.testing.assert_allclose(desired[3:-3], result.magnitude[3:-3], rtol=0.05, atol=0.1)
+
+    @unittest.skipUnless(HAVE_SCIPY, "requires Scipy")
+    def test_resample_more_samples(self):
+        # generate signal long enough for resampling
+        data = np.sin(np.arange(1500) / 100).T * pq.mV
+        signal = AnalogSignal(data, sampling_rate=30000 * pq.Hz)
+
+        # test resampling using different numbers of desired samples
+        factor = 2
+        sample_count = factor * signal.shape[0]
+        desired = np.interp(np.arange(sample_count) / factor, np.arange(signal.shape[0]),
+                            signal.magnitude.flatten()).reshape(-1, 1)
+        result = signal.resample(sample_count)
+
+        self.assertEqual(sample_count, result.shape[0])
+        self.assertEqual(signal.shape[-1], result.shape[-1])  # preserve number of recording traces
+        self.assertAlmostEqual(sample_count / signal.shape[0] * signal.sampling_rate,
+                               result.sampling_rate)
+        # only comparing center values due to border effects
+        np.testing.assert_allclose(desired[10:-10], result.magnitude[10:-10], rtol=0.0, atol=0.1)
+
+    @unittest.skipUnless(HAVE_SCIPY, "requires Scipy")
+    def test_compare_resample_and_downsample(self):
+        # generate signal long enough for resampling
+        data = np.sin(np.arange(1500) / 30).reshape(3, 500).T * pq.mV
+        signal = AnalogSignal(data, sampling_rate=30000 * pq.Hz)
+
+        # test resampling using different numbers of desired samples
+        sample_counts = [10, 100, 250]
+        for sample_count in sample_counts:
+            downsampling_factor = int(signal.shape[0] / sample_count)
+            desired = signal.downsample(downsampling_factor=downsampling_factor)
+            result = signal.resample(sample_count)
+
+            self.assertEqual(desired.shape[0], result.shape[0])
+            self.assertEqual(desired.shape[-1],
+                             result.shape[-1])  # preserve number of recording traces
+            self.assertAlmostEqual(desired.sampling_rate, result.sampling_rate)
+            # only comparing center values due to border effects
+            np.testing.assert_allclose(desired.magnitude[3:-3], result.magnitude[3:-3], rtol=0.05,
+                                       atol=0.1)
+
+    def test_rectify(self):
+        # generate signal long enough for testing the rectification
+        data = np.sin(np.arange(1500) / 30).reshape(500, 3)
+        target_data = np.abs(data)
+
+        array_anno = {'anno1': [0, 1, 2], 'anno2': ['C', 'P', 'F']}
+
+        signal = AnalogSignal(data * pq.mV,
+                              sampling_rate=30000 * pq.Hz,
+                              units=pq.mV,
+                              array_annotations=array_anno)
+
+        target_signal = AnalogSignal(target_data * pq.mV,
+                                     sampling_rate=30000 * pq.Hz,
+                                     units=pq.mV,
+                                     array_annotations=array_anno)
+
+        # Use the rectify method
+        rectified_signal = signal.rectify()
+
+        # Assert that nothing changed
+        assert_arrays_equal(rectified_signal.magnitude, target_signal.magnitude)
+        self.assertEqual(rectified_signal.sampling_rate,
+                         target_signal.sampling_rate)
+        self.assertEqual(rectified_signal.units, target_signal.units)
+        self.assertEqual(rectified_signal.annotations,
+                         target_signal.annotations)
+        assert_arrays_equal(rectified_signal.array_annotations['anno1'],
+                            target_signal.array_annotations['anno1'])
+        assert_arrays_equal(rectified_signal.array_annotations['anno2'],
+                            target_signal.array_annotations['anno2'])
+
 
 class TestAnalogSignalEquality(unittest.TestCase):
     def test__signals_with_different_data_complement_should_be_not_equal(self):
         signal1 = AnalogSignal(np.arange(55.0).reshape((11, 5)), units="mV",
                                sampling_rate=1 * pq.kHz)
         signal2 = AnalogSignal(np.arange(55.0).reshape((11, 5)), units="mV",
                                sampling_rate=2 * pq.kHz)
@@ -1437,14 +1569,168 @@
         self.assertNotIn('anno2', merged24.array_annotations)
         self.assertNotIn('anno3', merged24.array_annotations)
 
         assert_arrays_equal(mergeddata13, targdata13)
         assert_arrays_equal(mergeddata23, targdata23)
         assert_arrays_equal(mergeddata24, targdata24)
 
+    def test_concatenate_simple(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop)
+
+        result = signal1.concatenate(signal2)
+        assert_array_equal(np.arange(7).reshape((-1, 1)), result.magnitude)
+        for attr in signal1._necessary_attrs:
+            self.assertEqual(getattr(signal1, attr[0], None), getattr(result, attr[0], None))
+
+    def test_concatenate_no_signals(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        self.assertIs(signal1, signal1.concatenate())
+
+    def test_concatenate_reverted_order(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop)
+
+        result = signal2.concatenate(signal1)
+        assert_array_equal(np.arange(7).reshape((-1, 1)), result.magnitude)
+        for attr in signal1._necessary_attrs:
+            self.assertEqual(getattr(signal1, attr[0], None), getattr(result, attr[0], None))
+
+    def test_concatenate_no_overlap(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz, t_start=10 * pq.s)
+
+        with self.assertRaises(MergeError):
+            signal1.concatenate(signal2)
+
+    def test_concatenate_multi_trace(self):
+        data1 = np.arange(4).reshape(2, 2)
+        data2 = np.arange(4, 8).reshape(2, 2)
+        signal1 = AnalogSignal(data1 * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal(data2 * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop)
+
+        result = signal1.concatenate(signal2)
+        data_expected = np.array([[0, 1], [2, 3], [4, 5], [6, 7]])
+        assert_array_equal(data_expected, result.magnitude)
+        for attr in signal1._necessary_attrs:
+            self.assertEqual(getattr(signal1, attr[0], None), getattr(result, attr[0], None))
+
+    def test_concatenate_overwrite_true(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop - signal1.sampling_period)
+
+        result = signal1.concatenate(signal2, overwrite=True)
+        assert_array_equal(np.array([0, 1, 2, 4, 5, 6]).reshape((-1, 1)), result.magnitude)
+
+    def test_concatenate_overwrite_false(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop - signal1.sampling_period)
+
+        result = signal1.concatenate(signal2, overwrite=False)
+        assert_array_equal(np.array([0, 1, 2, 3, 5, 6]).reshape((-1, 1)), result.magnitude)
+
+    def test_concatenate_padding_False(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=10 * pq.s)
+
+        with self.assertRaises(MergeError):
+            result = signal1.concatenate(signal2, overwrite=False, padding=False)
+
+    def test_concatenate_padding_True(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop + 3 * signal1.sampling_period)
+
+        result = signal1.concatenate(signal2, overwrite=False, padding=True)
+        assert_array_equal(
+            np.array([0, 1, 2, 3, np.NaN, np.NaN, np.NaN, 4, 5, 6]).reshape((-1, 1)),
+            result.magnitude)
+
+    def test_concatenate_padding_quantity(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop + 3 * signal1.sampling_period)
+
+        result = signal1.concatenate(signal2, overwrite=False, padding=-1 * pq.mV)
+        assert_array_equal(np.array([0, 1, 2, 3, -1e-3, -1e-3, -1e-3, 4, 5, 6]).reshape((-1, 1)),
+                           result.magnitude)
+
+    def test_concatenate_padding_invalid(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop + 3 * signal1.sampling_period)
+
+        with self.assertRaises(MergeError):
+            result = signal1.concatenate(signal2, overwrite=False, padding=1)
+        with self.assertRaises(MergeError):
+            result = signal1.concatenate(signal2, overwrite=False, padding=[1])
+        with self.assertRaises(MergeError):
+            result = signal1.concatenate(signal2, overwrite=False, padding='a')
+        with self.assertRaises(MergeError):
+            result = signal1.concatenate(signal2, overwrite=False, padding=np.array([1, 2, 3]))
+
+    def test_concatenate_array_annotations(self):
+        array_anno1 = {'first': ['a', 'b']}
+        array_anno2 = {'first': ['a', 'b'],
+                       'second': ['c', 'd']}
+        data1 = np.arange(4).reshape(2, 2)
+        data2 = np.arange(4, 8).reshape(2, 2)
+        signal1 = AnalogSignal(data1 * pq.V, sampling_rate=1 * pq.Hz,
+                               array_annotations=array_anno1)
+        signal2 = AnalogSignal(data2 * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop,
+                               array_annotations=array_anno2)
+
+        result = signal1.concatenate(signal2)
+        assert_array_equal(array_anno1.keys(), result.array_annotations.keys())
+
+        for k in array_anno1.keys():
+            assert_array_equal(np.asarray(array_anno1[k]), result.array_annotations[k])
+
+    def test_concatenate_complex(self):
+        signal1 = self.signal1
+        assert_neo_object_is_compliant(self.signal1)
+
+        signal2 = AnalogSignal(self.data1quant, sampling_rate=1 * pq.kHz, name='signal2',
+                               description='test signal', file_origin='testfile.txt',
+                               array_annotations=self.arr_ann1,
+                               t_start=signal1.t_stop)
+
+        concatenated12 = self.signal1.concatenate(signal2)
+
+        for attr in signal1._necessary_attrs:
+            self.assertEqual(getattr(signal1, attr[0], None),
+                             getattr(concatenated12, attr[0], None))
+
+        assert_array_equal(np.vstack((signal1.magnitude, signal2.magnitude)),
+                           concatenated12.magnitude)
+
+    def test_concatenate_multi_signal(self):
+        signal1 = AnalogSignal([0, 1, 2, 3] * pq.V, sampling_rate=1 * pq.Hz)
+        signal2 = AnalogSignal([4, 5, 6] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop + 3 * signal1.sampling_period)
+        signal3 = AnalogSignal([40] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop + 3 * signal1.sampling_period)
+        signal4 = AnalogSignal([30, 35] * pq.V, sampling_rate=1 * pq.Hz,
+                               t_start=signal1.t_stop - signal1.sampling_period)
+
+        concatenated = signal1.concatenate(signal2, signal3, signal4, padding=-1 * pq.V,
+                                           overwrite=True)
+        for attr in signal1._necessary_attrs:
+            self.assertEqual(getattr(signal1, attr[0], None),
+                             getattr(concatenated, attr[0], None))
+        assert_arrays_equal(np.array([0, 1, 2, 30, 35, -1, -1, 40, 5, 6]).reshape((-1, 1)),
+                            concatenated.magnitude)
+
 
 class TestAnalogSignalFunctions(unittest.TestCase):
     def test__pickle_1d(self):
         signal1 = AnalogSignal([1, 2, 3, 4], sampling_period=1 * pq.ms, units=pq.S)
         signal1.annotations['index'] = 2
         signal1.channel_index = ChannelIndex(index=[0])
         signal1.array_annotate(**{'anno1': [23], 'anno2': ['A']})
```

### Comparing `neo-0.8.0/neo/test/coretest/test_base.py` & `neo-0.9.0/neo/test/coretest/test_base.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.baseneo.BaseNeo class and related functions
 """
 
 from datetime import datetime, date, time, timedelta
 from decimal import Decimal
 from fractions import Fraction
@@ -17,25 +16,18 @@
     from IPython.lib.pretty import pretty
 except ImportError as err:
     HAVE_IPYTHON = False
 else:
     HAVE_IPYTHON = True
 
 from neo.core.baseneo import (BaseNeo, _check_annotations,
-                              merge_annotations, merge_annotation)
+                              merge_annotations, merge_annotation,
+                              intersect_annotations)
 from neo.test.tools import assert_arrays_equal
 
-if sys.version_info[0] >= 3:
-    _bytes = bytes
-
-    long = int
-
-    def bytes(s):
-        return _bytes(s, encoding='ascii')
-
 
 class Test_check_annotations(unittest.TestCase):
     '''
     TestCase to make sure _check_annotations works
     '''
 
     def setUp(self):
@@ -140,18 +132,21 @@
     '''
     TestCase to make sure merge_annotations and merge methods work
     '''
 
     def setUp(self):
         self.name1 = 'a base 1'
         self.name2 = 'a base 2'
+        self.name3 = 'a base 3'
         self.description1 = 'this is a test 1'
         self.description2 = 'this is a test 2'
+        self.description3 = 'this is a test 3'
         self.base1 = BaseNeo(name=self.name1, description=self.description1)
         self.base2 = BaseNeo(name=self.name2, description=self.description2)
+        self.base3 = BaseNeo(name=self.name3, description=self.description3)
 
     def test_merge_annotations__dict(self):
         self.base1.annotations = {'val0': 'val0', 'val1': 1,
                                   'val2': 2.2, 'val3': 'test1',
                                   'val4': [.4], 'val5': {0: 0, 1: {0: 0}},
                                   'val6': np.array([0, 1, 2])}
         self.base2.annotations = {'val2': 2.2, 'val3': 'test2',
@@ -185,14 +180,65 @@
         assert_arrays_equal(val62, val62c)
 
         self.assertEqual(self.name1, self.base1.name)
         self.assertEqual(self.name2, self.base2.name)
         self.assertEqual(self.description1, self.base1.description)
         self.assertEqual(self.description2, self.base2.description)
 
+    def test_merge_multiple_annotations__dict(self):
+        self.base1.annotations = {'val0': 'val0', 'val1': 1,
+                                  'val2': 2.2, 'val3': 'test1',
+                                  'val4': [.4], 'val5': {0: 0, 1: {0: 0}},
+                                  'val6': np.array([0, 1, 2])}
+        self.base2.annotations = {'val2': 2.2, 'val3': 'test2',
+                                  'val4': [4, 4.4], 'val5': {1: {1: 1}, 2: 2},
+                                  'val6': np.array([4, 5, 6]), 'val7': True}
+        self.base3.annotations = {'val2': 2.2, 'val3': 'test3',
+                                  'val4': [44], 'val5': {1: {2: 2}, 2: 2, 3: 3},
+                                  'val6': np.array([8, 9, 10]), 'val8': False}
+
+        ann1 = self.base1.annotations
+        ann2 = self.base2.annotations
+        ann3 = self.base3.annotations
+        ann1c = self.base1.annotations.copy()
+        ann2c = self.base2.annotations.copy()
+        ann3c = self.base3.annotations.copy()
+
+        targ = {'val0': 'val0', 'val1': 1, 'val2': 2.2, 'val3': 'test1;test2;test3',
+                'val4': [.4, 4, 4.4, 44], 'val5': {0: 0, 1: {0: 0, 1: 1, 2: 2}, 2: 2, 3: 3},
+                'val7': True, 'val8': False}
+
+        self.base1.merge_annotations(self.base2, self.base3)
+
+        val6t = np.array([0, 1, 2, 4, 5, 6, 8, 9, 10])
+        val61 = ann1.pop('val6')
+        val61c = ann1c.pop('val6')
+        val62 = ann2.pop('val6')
+        val62c = ann2c.pop('val6')
+        val63 = ann3.pop('val6')
+        val63c = ann3c.pop('val6')
+
+        self.assertEqual(ann1, self.base1.annotations)
+        self.assertNotEqual(ann1c, self.base1.annotations)
+        self.assertEqual(ann2c, self.base2.annotations)
+        self.assertEqual(ann3c, self.base3.annotations)
+        self.assertEqual(targ, self.base1.annotations)
+
+        assert_arrays_equal(val61, val6t)
+        self.assertRaises(AssertionError, assert_arrays_equal, val61c, val6t)
+        assert_arrays_equal(val62, val62c)
+        assert_arrays_equal(val63, val63c)
+
+        self.assertEqual(self.name1, self.base1.name)
+        self.assertEqual(self.name2, self.base2.name)
+        self.assertEqual(self.name3, self.base3.name)
+        self.assertEqual(self.description1, self.base1.description)
+        self.assertEqual(self.description2, self.base2.description)
+        self.assertEqual(self.description3, self.base3.description)
+
     def test_merge_annotations__func__dict(self):
         ann1 = {'val0': 'val0', 'val1': 1, 'val2': 2.2, 'val3': 'test1',
                 'val4': [.4], 'val5': {0: 0, 1: {0: 0}},
                 'val6': np.array([0, 1, 2])}
         ann2 = {'val2': 2.2, 'val3': 'test2',
                 'val4': [4, 4.4], 'val5': {1: {1: 1}, 2: 2},
                 'val6': np.array([4, 5, 6]), 'val7': True}
@@ -218,14 +264,55 @@
         self.assertEqual(res, targ)
 
         assert_arrays_equal(val6r, val6t)
         self.assertRaises(AssertionError, assert_arrays_equal, val61, val6t)
         assert_arrays_equal(val61, val61c)
         assert_arrays_equal(val62, val62c)
 
+    def test_merge_multiple_annotations__func__dict(self):
+        ann1 = {'val0': 'val0', 'val1': 1, 'val2': 2.2, 'val3': 'test1',
+                'val4': [.4], 'val5': {0: 0, 1: {0: 0}},
+                'val6': np.array([0, 1, 2])}
+        ann2 = {'val2': 2.2, 'val3': 'test2',
+                'val4': [4, 4.4], 'val5': {1: {1: 1}, 2: 2},
+                'val6': np.array([4, 5, 6]), 'val7': True}
+        ann3 = {'val2': 2.2, 'val3': 'test3',
+                'val4': [44], 'val5': {1: {2: 2}, 2: 2, 3: 3},
+                'val6': np.array([8, 9, 10]), 'val8': False}
+
+        ann1c = ann1.copy()
+        ann2c = ann2.copy()
+        ann3c = ann3.copy()
+
+        targ = {'val0': 'val0', 'val1': 1, 'val2': 2.2, 'val3': 'test1;test2;test3',
+                'val4': [.4, 4, 4.4, 44], 'val5': {0: 0, 1: {0: 0, 1: 1, 2: 2}, 2: 2, 3: 3},
+                'val7': True, 'val8': False}
+
+        res = merge_annotations(ann1, ann2, ann3)
+
+        val6t = np.array([0, 1, 2, 4, 5, 6, 8, 9, 10])
+        val6r = res.pop('val6')
+        val61 = ann1.pop('val6')
+        val61c = ann1c.pop('val6')
+        val62 = ann2.pop('val6')
+        val62c = ann2c.pop('val6')
+        val63 = ann3.pop('val6')
+        val63c = ann3c.pop('val6')
+
+        self.assertEqual(ann1, ann1c)
+        self.assertEqual(ann2, ann2c)
+        self.assertEqual(ann3, ann3c)
+        self.assertEqual(res, targ)
+
+        assert_arrays_equal(val6r, val6t)
+        self.assertRaises(AssertionError, assert_arrays_equal, val61, val6t)
+        assert_arrays_equal(val61, val61c)
+        assert_arrays_equal(val62, val62c)
+        assert_arrays_equal(val63, val63c)
+
     def test_merge_annotation__func__str(self):
         ann1 = 'test1'
         ann2 = 'test2'
 
         targ = 'test1;test2'
 
         res = merge_annotation(ann1, ann2)
@@ -339,62 +426,157 @@
         self.assertEqual(targ, self.base1.annotations)
 
         self.assertEqual(self.name1, self.base1.name)
         self.assertEqual(self.name2, self.base2.name)
         self.assertEqual(self.description1, self.base1.description)
         self.assertEqual(self.description2, self.base2.description)
 
+    def test_merge_multiple__dict(self):
+        self.base1.annotations = {'val0': 'val0', 'val1': 1,
+                                  'val2': 2.2, 'val3': 'test1'}
+        self.base2.annotations = {'val2': 2.2, 'val3': 'test2',
+                                  'val4': [4, 4.4], 'val5': True}
+        self.base3.annotations = {'val2': 2.2, 'val3': 'test3',
+                                  'val4': [44], 'val5': True, 'val6': False}
+
+        ann1 = self.base1.annotations
+        ann1c = self.base1.annotations.copy()
+        ann2c = self.base2.annotations.copy()
+        ann3c = self.base3.annotations.copy()
+
+        targ = {'val0': 'val0', 'val1': 1, 'val2': 2.2, 'val3': 'test1;test2;test3',
+                'val4': [4, 4.4, 44], 'val5': True, 'val6': False}
+
+        self.base1.merge(self.base2, self.base3)
+
+        self.assertEqual(ann1, self.base1.annotations)
+        self.assertNotEqual(ann1c, self.base1.annotations)
+        self.assertEqual(ann2c, self.base2.annotations)
+        self.assertEqual(ann3c, self.base3.annotations)
+        self.assertEqual(targ, self.base1.annotations)
+
+        self.assertEqual(self.name1, self.base1.name)
+        self.assertEqual(self.name2, self.base2.name)
+        self.assertEqual(self.name3, self.base3.name)
+        self.assertEqual(self.description1, self.base1.description)
+        self.assertEqual(self.description2, self.base2.description)
+        self.assertEqual(self.description3, self.base3.description)
+
     def test_merge_annotations__different_type_AssertionError(self):
         self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': 'tester'}
         self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
                                   'val5': True}
         self.base1.merge_annotations(self.base2)
         self.assertEqual(self.base1.annotations,
                          {'val1': 1,
                           'val2': 2.2,
                           'val3': 'MERGE CONFLICT',
                           'val4': [4, 4.4],
                           'val5': True})
 
+    def test_merge_multiple_annotations__different_type_AssertionError(self):
+        self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': 'tester'}
+        self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
+                                  'val5': True}
+        self.base3.annotations = {'val5': 1, 'val6': 79,
+                                  'val7': True}
+        self.base1.merge_annotations(self.base2, self.base3)
+        self.assertEqual(self.base1.annotations,
+                         {'val1': 1,
+                          'val2': 2.2,
+                          'val3': 'MERGE CONFLICT',
+                          'val4': [4, 4.4],
+                          'val5': 'MERGE CONFLICT',
+                          'val6': 79,
+                          'val7': True})
+
     def test_merge__different_type_AssertionError(self):
         self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': 'tester'}
         self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
                                   'val5': True}
         self.base1.merge(self.base2)
         self.assertEqual(self.base1.annotations,
                          {'val1': 1,
                           'val2': 2.2,
                           'val3': 'MERGE CONFLICT',
                           'val4': [4, 4.4],
                           'val5': True})
 
+    def test_merge_multiple__different_type_AssertionError(self):
+        self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': 'tester'}
+        self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
+                                  'val5': True}
+        self.base3.annotations = {'val5': 3.1, 'val6': False,
+                                  'val7': 'val7'}
+        self.base1.merge(self.base2, self.base3)
+        self.assertEqual(self.base1.annotations,
+                         {'val1': 1,
+                          'val2': 2.2,
+                          'val3': 'MERGE CONFLICT',
+                          'val4': [4, 4.4],
+                          'val5': 'MERGE CONFLICT',
+                          'val6': False,
+                          'val7': 'val7'})
+
     def test_merge_annotations__unmergable_unequal_AssertionError(self):
         self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': True}
         self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
                                   'val5': True}
         self.base1.merge_annotations(self.base2)
         self.assertEqual(self.base1.annotations,
                          {'val1': 1,
                           'val2': 2.2,
                           'val3': 'MERGE CONFLICT',
                           'val4': [4, 4.4],
                           'val5': True})
 
+    def test_merge_multiple_annotations__unmergable_unequal_AssertionError(self):
+        self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': True}
+        self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
+                                  'val5': 3.5}
+        self.base3.annotations = {'val5': 3.4, 'val6': [4, 4.4],
+                                  'val7': True}
+        self.base1.merge_annotations(self.base2, self.base3)
+        self.assertEqual(self.base1.annotations,
+                         {'val1': 1,
+                          'val2': 2.2,
+                          'val3': 'MERGE CONFLICT',
+                          'val4': [4, 4.4],
+                          'val5': 'MERGE CONFLICT',
+                          'val6': [4, 4.4],
+                          'val7': True})
+
     def test_merge__unmergable_unequal_AssertionError(self):
         self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': True}
         self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
                                   'val5': True}
         self.base1.merge(self.base2)
         self.assertEqual(self.base1.annotations,
                          {'val1': 1,
                           'val2': 2.2,
                           'val3': 'MERGE CONFLICT',
                           'val4': [4, 4.4],
                           'val5': True})
 
+    def test_merge_multiple__unmergable_unequal_AssertionError(self):
+        self.base1.annotations = {'val1': 1, 'val2': 2.2, 'val3': True}
+        self.base2.annotations = {'val3': False, 'val4': [4, 4.4],
+                                  'val5': True}
+        self.base3.annotations = {'val5': 3.4, 'val6': [4, 4.4],
+                                  'val7': True}
+        self.base1.merge(self.base2, self.base3)
+        self.assertEqual(self.base1.annotations,
+                         {'val1': 1,
+                          'val2': 2.2,
+                          'val3': 'MERGE CONFLICT',
+                          'val4': [4, 4.4],
+                          'val5': 'MERGE CONFLICT',
+                          'val6': [4, 4.4],
+                          'val7': True})
+
 
 class TestBaseNeoCoreTypes(unittest.TestCase):
     '''
     TestCase to make sure annotations are properly checked for core built-in
     python data types
     '''
 
@@ -414,22 +596,14 @@
         '''test to make sure int type data is accepted'''
         value = 10
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertEqual(value, self.base.annotations['data'])
         self.assertDictEqual(result, self.base.annotations)
 
-    def test_python_long(self):
-        '''test to make sure long type data is accepted'''
-        value = long(7)
-        self.base.annotate(data=value)
-        result = {'data': value}
-        self.assertEqual(value, self.base.annotations['data'])
-        self.assertDictEqual(result, self.base.annotations)
-
     def test_python_float(self):
         '''test to make sure float type data is accepted'''
         value = 9.2
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertEqual(value, self.base.annotations['data'])
         self.assertDictEqual(result, self.base.annotations)
@@ -448,23 +622,23 @@
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertEqual(value, self.base.annotations['data'])
         self.assertDictEqual(result, self.base.annotations)
 
     def test_python_unicode(self):
         '''test to make sure unicode type data is accepted'''
-        value = u'this is also a test'
+        value = 'this is also a test'
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertEqual(value, self.base.annotations['data'])
         self.assertDictEqual(result, self.base.annotations)
 
     def test_python_bytes(self):
         '''test to make sure bytes type data is accepted'''
-        value = bytes('1,2,3,4,5')
+        value = bytes('1,2,3,4,5', encoding='ascii')
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertEqual(value, self.base.annotations['data'])
         self.assertDictEqual(result, self.base.annotations)
 
 
 class TestBaseNeoStandardLibraryTypes(unittest.TestCase):
@@ -537,37 +711,37 @@
     def setUp(self):
         '''create the instance to be tested, called before every test'''
         self.base = BaseNeo()
 
     def test_python_list(self):
         '''test to make sure list type data is accepted'''
         value = [None, 10, 9.2, complex(23, 11),
-                 ['this is a test', bytes('1,2,3,4,5')],
+                 ['this is a test', bytes('1,2,3,4,5', encoding='ascii')],
                  [Fraction(13, 21), Decimal("3.14")]]
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertListEqual(value, self.base.annotations['data'])
         self.assertDictEqual(result, self.base.annotations)
 
     def test_python_tuple(self):
         '''test to make sure tuple type data is accepted'''
         value = (None, 10, 9.2, complex(23, 11),
-                 ('this is a test', bytes('1,2,3,4,5')),
+                 ('this is a test', bytes('1,2,3,4,5', encoding='ascii')),
                  (Fraction(13, 21), Decimal("3.14")))
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertTupleEqual(value, self.base.annotations['data'])
         self.assertDictEqual(result, self.base.annotations)
 
     def test_python_dict(self):
         '''test to make sure dict type data is accepted'''
         value = {'NoneType': None, 'int': 10, 'float': 9.2,
                  'complex': complex(23, 11),
                  'dict1': {'string': 'this is a test',
-                           'bytes': bytes('1,2,3,4,5')},
+                           'bytes': bytes('1,2,3,4,5', encoding='ascii')},
                  'dict2': {'Fraction': Fraction(13, 21),
                            'Decimal': Decimal("3.14")}}
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertDictEqual(result, self.base.annotations)
 
     def test_python_set(self):
@@ -771,19 +945,15 @@
         value = np.array([1, 2, 3, 4, 5], dtype=np.str)
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertDictEqual(result, self.base.annotations)
 
     def test_numpy_array_string0(self):
         '''test to make sure string0 type numpy arrays are accepted'''
-        if sys.version_info[0] >= 3:
-            dtype = np.str0
-        else:
-            dtype = np.string0
-        value = np.array([1, 2, 3, 4, 5], dtype=dtype)
+        value = np.array([1, 2, 3, 4, 5], dtype=np.str0)
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertDictEqual(result, self.base.annotations)
 
 
 class TestBaseNeoNumpyScalarTypes(unittest.TestCase):
     '''
@@ -969,19 +1139,15 @@
         value = np.array(99, dtype=np.str)
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertDictEqual(result, self.base.annotations)
 
     def test_numpy_scalar_string0(self):
         '''test to make sure string0 type numpy scalars are rejected'''
-        if sys.version_info[0] >= 3:
-            dtype = np.str0
-        else:
-            dtype = np.string0
-        value = np.array(99, dtype=dtype)
+        value = np.array(99, dtype=np.str0)
         self.base.annotate(data=value)
         result = {'data': value}
         self.assertDictEqual(result, self.base.annotations)
 
 
 class TestBaseNeoQuantitiesArrayTypes(unittest.TestCase):
     '''
@@ -1070,24 +1236,24 @@
     def setUp(self):
         '''create the instance to be tested, called before every test'''
         self.base = BaseNeo()
 
     def test_my_class(self):
         '''test to make sure user defined class type data is rejected'''
 
-        class Foo(object):
+        class Foo:
             pass
 
         value = Foo()
         self.assertRaises(ValueError, self.base.annotate, data=value)
 
     def test_my_class_list(self):
         '''test to make sure user defined class type data is rejected'''
 
-        class Foo(object):
+        class Foo:
             pass
 
         value = [Foo(), Foo(), Foo()]
         self.assertRaises(ValueError, self.base.annotate, data=value)
 
 
 @unittest.skipUnless(HAVE_IPYTHON, "requires IPython")
@@ -1097,9 +1263,54 @@
         description = 'this is a test'
         obj = BaseNeo(name=name, description=description)
         res = pretty(obj)
         targ = "BaseNeo name: '{}' description: '{}'".format(name, description)
         self.assertEqual(res, targ)
 
 
+class Test_intersect_annotations(unittest.TestCase):
+    '''
+    TestCase for intersect_annotations
+    '''
+
+    def setUp(self):
+        self.dict1 = {1: '1', 2: '2'}
+        self.dict2 = {1: '1'}
+        self.dict3 = {'list1': [1, 2, 3]}
+        self.dict4 = {'list1': [1, 2, 3], 'list2': [1, 2, 3]}
+        self.dict5 = {'list1': [1, 2]}
+        self.dict6 = {'array1': np.array([1, 2])}
+        self.dict7 = {'array1': np.array([1, 2]), 'array2': np.array([1, 2]),
+                      'array3': np.array([1, 2, 3])}
+
+        self.all_simple_dicts = [self.dict1, self.dict2, self.dict3,
+                                 self.dict4, self.dict5, ]
+
+    def test_simple(self):
+        result = intersect_annotations(self.dict1, self.dict2)
+        self.assertDictEqual(self.dict2, result)
+
+    def test_intersect_self(self):
+        for d in self.all_simple_dicts:
+            result = intersect_annotations(d, d)
+            self.assertDictEqual(d, result)
+
+    def test_list(self):
+        result = intersect_annotations(self.dict3, self.dict4)
+        self.assertDictEqual(self.dict3, result)
+
+    def test_list_values(self):
+        result = intersect_annotations(self.dict4, self.dict5)
+        self.assertDictEqual({}, result)
+
+    def test_keys(self):
+        result = intersect_annotations(self.dict1, self.dict4)
+        self.assertDictEqual({}, result)
+
+    def test_arrays(self):
+        result = intersect_annotations(self.dict6, self.dict7)
+        self.assertEqual(self.dict6.keys(), result.keys())
+        np.testing.assert_array_equal([1, 2], result['array1'])
+
+
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `neo-0.8.0/neo/test/coretest/test_block.py` & `neo-0.9.0/neo/test/coretest/test_block.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.block.Block class
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 from datetime import datetime
 from copy import deepcopy
 
 import unittest
 
 import numpy as np
 
@@ -243,51 +239,51 @@
         blk1a = fake_neo(Block,
                          seed=self.seed1, n=self.nchildren)
         assert_same_sub_schema(self.blk1, blk1a)
         blk1a.annotate(seed=self.seed2)
         blk1a.segments.append(self.segs2[0])
         blk1a.merge(self.blk2)
 
-        segs1a = clone_object(self.blk1).segments
-        chxs1a = clone_object(self.chxs1)
+        segs1a = deepcopy(self.blk1.segments)
+        chxs1a = deepcopy(self.chxs1)
 
         assert_same_sub_schema(chxs1a + self.chxs2,
                                blk1a.channel_indexes)
         assert_same_sub_schema(segs1a + self.segs2,
                                blk1a.segments)
 
     def test__children(self):
-        segs1a = clone_object(self.blk1).segments
-        chxs1a = clone_object(self.chxs1)
+        segs1a = deepcopy(self.blk1.segments)
+        chxs1a = deepcopy(self.chxs1)
 
         self.assertEqual(self.blk1._container_child_objects,
-                         ('Segment', 'ChannelIndex'))
+                         ('Segment', 'ChannelIndex', 'Group'))
         self.assertEqual(self.blk1._data_child_objects, ())
         self.assertEqual(self.blk1._single_parent_objects, ())
         self.assertEqual(self.blk1._multi_child_objects, ())
         self.assertEqual(self.blk1._multi_parent_objects, ())
         self.assertEqual(self.blk1._child_properties,
                          ('Unit',))
 
         self.assertEqual(self.blk1._single_child_objects,
-                         ('Segment', 'ChannelIndex'))
+                         ('Segment', 'ChannelIndex', 'Group'))
 
         self.assertEqual(self.blk1._container_child_containers,
-                         ('segments', 'channel_indexes'))
+                         ('segments', 'channel_indexes', 'groups'))
         self.assertEqual(self.blk1._data_child_containers, ())
         self.assertEqual(self.blk1._single_child_containers,
-                         ('segments', 'channel_indexes'))
+                         ('segments', 'channel_indexes', 'groups'))
         self.assertEqual(self.blk1._single_parent_containers, ())
         self.assertEqual(self.blk1._multi_child_containers, ())
         self.assertEqual(self.blk1._multi_parent_containers, ())
 
         self.assertEqual(self.blk1._child_objects,
-                         ('Segment', 'ChannelIndex'))
+                         ('Segment', 'ChannelIndex', 'Group'))
         self.assertEqual(self.blk1._child_containers,
-                         ('segments', 'channel_indexes'))
+                         ('segments', 'channel_indexes', 'groups'))
         self.assertEqual(self.blk1._parent_objects, ())
         self.assertEqual(self.blk1._parent_containers, ())
 
         self.assertEqual(len(self.blk1._single_children), 2 * self.nchildren)
         self.assertEqual(len(self.blk1._multi_children), 0)
         self.assertEqual(len(self.blk1.data_children), 0)
         self.assertEqual(len(self.blk1.data_children_recur),
@@ -341,14 +337,15 @@
                                self.segs1 + self.chxs1 +
                                self.units1[:2] +
                                self.units1[2:],
                                exclude=['channel_index'])
 
     def test__size(self):
         targ = {'segments': self.nchildren,
+                'groups': 0,  # need to update test data generation to handle groups
                 'channel_indexes': self.nchildren}
         self.assertEqual(self.targobj.size, targ)
 
     def test__filter_none(self):
         targ = []
         # collecting all data objects in target block
         for seg in self.targobj.segments:
```

### Comparing `neo-0.8.0/neo/test/coretest/test_channelindex.py` & `neo-0.9.0/neo/test/coretest/test_channelindex.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.channelindex.ChannelIndex class
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import unittest
 from copy import deepcopy
 
 import numpy as np
 
 try:
     from IPython.lib.pretty import pretty
@@ -36,15 +32,15 @@
                                  range(len(TEST_ANNOTATIONS))}
 
     # def test__get_fake_values(self):
     #     self.annotations['seed'] = 0
     #     channel_indexes = get_fake_value('channel_indexes', np.ndarray, seed=0,
     #                                      dim=1, dtype='i')
     #     channel_names = get_fake_value('channel_names', np.ndarray, seed=1,
-    #                                    dim=1, dtype=np.dtype('S'))
+    #                                    dim=1, dtype=np.dtype('U'))
     #     name = get_fake_value('name', str, seed=3, obj=ChannelIndex)
     #     description = get_fake_value('description', str, seed=4,
     #                                  obj='ChannelIndex')
     #     file_origin = get_fake_value('file_origin', str)
     #     #coordinates = get_fake_value('coordinates', np.ndarray, seed=2, dim=2, dtype='f')
     #     attrs1 = {'name': name,
     #               'description': description,
@@ -148,25 +144,25 @@
 
     def test__channelindex__init_defaults(self):
         chx = ChannelIndex(index=np.array([1]))
         assert_neo_object_is_compliant(chx)
         self.assertEqual(chx.name, None)
         self.assertEqual(chx.file_origin, None)
         self.assertEqual(chx.analogsignals, [])
-        assert_arrays_equal(chx.channel_names, np.array([], dtype='S'))
+        assert_arrays_equal(chx.channel_names, np.array([], dtype='U'))
         assert_arrays_equal(chx.index, np.array([1]))
 
     def test_channelindex__init(self):
         chx = ChannelIndex(file_origin='temp.dat',
                            index=np.array([1]))
         assert_neo_object_is_compliant(chx)
         self.assertEqual(chx.file_origin, 'temp.dat')
         self.assertEqual(chx.name, None)
         self.assertEqual(chx.analogsignals, [])
-        assert_arrays_equal(chx.channel_names, np.array([], dtype='S'))
+        assert_arrays_equal(chx.channel_names, np.array([], dtype='U'))
         assert_arrays_equal(chx.index, np.array([1]))
 
     def check_creation(self, chx):
         assert_neo_object_is_compliant(chx)
 
         seed = chx.annotations['seed']
```

### Comparing `neo-0.8.0/neo/test/coretest/test_container.py` & `neo-0.9.0/neo/test/coretest/test_container.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.container.Container class
 """
 
 import unittest
 
 import numpy as np
```

### Comparing `neo-0.8.0/neo/test/coretest/test_dataobject.py` & `neo-0.9.0/neo/test/coretest/test_dataobject.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/neo/test/coretest/test_epoch.py` & `neo-0.9.0/neo/test/coretest/test_epoch.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.epoch.Epoch class
 """
 
 import unittest
 import warnings
 from copy import deepcopy
@@ -38,15 +37,15 @@
         self.annotations = {
             str(x): TEST_ANNOTATIONS[x] for x in range(len(TEST_ANNOTATIONS))}
 
     def test__get_fake_values(self):
         self.annotations['seed'] = 0
         times = get_fake_value('times', pq.Quantity, seed=0, dim=1)
         durations = get_fake_value('durations', pq.Quantity, seed=1, dim=1)
-        labels = get_fake_value('labels', np.ndarray, seed=2, dim=1, dtype='S')
+        labels = get_fake_value('labels', np.ndarray, seed=2, dim=1, dtype='U')
         name = get_fake_value('name', str, seed=3, obj=Epoch)
         description = get_fake_value('description', str, seed=4, obj='Epoch')
         file_origin = get_fake_value('file_origin', str)
         arr_ann = get_fake_value('array_annotations', dict, seed=6, obj=Epoch, n=5)
         attrs1 = {'name': name, 'description': description, 'file_origin': file_origin}
         attrs2 = attrs1.copy()
         attrs2.update(self.annotations)
@@ -117,68 +116,73 @@
                          **self.params)
         self.epc.segment = self.seg
 
     def test_Epoch_creation(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'names': ['a', 'b', 'c'], 'index': np.arange(10, 13)}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         assert_arrays_equal(epc.times, [1.1, 1.5, 1.7] * pq.ms)
         assert_arrays_equal(epc.durations, [20, 40, 60] * pq.ns)
         assert_arrays_equal(epc.labels,
-                            np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'))
+                            np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'))
         self.assertEqual(epc.name, 'test')
         self.assertEqual(epc.description, 'tester')
         self.assertEqual(epc.file_origin, 'test.file')
         self.assertEqual(epc.annotations['test0'], [1, 2])
         self.assertEqual(epc.annotations['test1'], 1.1)
         self.assertEqual(epc.annotations['test2'], 'y1')
         self.assertTrue(epc.annotations['test3'])
         assert_arrays_equal(epc.array_annotations['names'], np.array(['a', 'b', 'c']))
         assert_arrays_equal(epc.array_annotations['index'], np.arange(10, 13))
         self.assertIsInstance(epc.array_annotations, ArrayDict)
 
+    def test_Epoch_invalid_times_dimension(self):
+        data2d = np.array([1, 2, 3, 4]).reshape((4, -1))
+        durations = np.array([1, 1, 1, 1])
+        self.assertRaises(ValueError, Epoch, times=data2d * pq.s, durations=durations)
+
     def test_Epoch_creation_invalid_durations_labels(self):
         self.assertRaises(ValueError, Epoch, [1.1, 1.5, 1.7] * pq.ms,
                           durations=[20, 40, 60, 80] * pq.ns)
         self.assertRaises(ValueError, Epoch, [1.1, 1.5, 1.7] * pq.ms,
                           durations=[20, 40, 60] * pq.ns,
                           labels=["A", "B"])
 
     def test_Epoch_creation_scalar_duration(self):
         # test with scalar for durations
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=20 * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'))
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'))
         assert_neo_object_is_compliant(epc)
 
         assert_arrays_equal(epc.times, [1.1, 1.5, 1.7] * pq.ms)
         assert_arrays_equal(epc.durations, [20, 20, 20] * pq.ns)
         self.assertEqual(epc.durations.size, 3)
         assert_arrays_equal(epc.labels,
-                            np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'))
+                            np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'))
 
     def test_Epoch_creation_from_lists(self):
         epc = Epoch([1.1, 1.5, 1.7],
                     [20.0, 20.0, 20.0],
                     ['test event 1', 'test event 2', 'test event 3'],
                     units=pq.ms)
         assert_arrays_equal(epc.times, [1.1, 1.5, 1.7] * pq.ms)
         assert_arrays_equal(epc.durations, [20.0, 20.0, 20.0] * pq.ms)
         assert_arrays_equal(epc.labels,
                             np.array(['test event 1', 'test event 2', 'test event 3']))
 
     def test_Epoch_repr(self):
         params = {'test2': 'y1', 'test3': True}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         targ = ('<Epoch: test epoch 1@1.1 ms for 20.0 ns, '
                 + 'test epoch 2@1.5 ms for 40.0 ns, '
                 + 'test epoch 3@1.7 ms for 60.0 ns>')
@@ -191,25 +195,25 @@
         params1 = {'test2': 'y1', 'test3': True}
         params2 = {'test2': 'no', 'test4': False}
         paramstarg = {'test2': 'yes;no', 'test3': True, 'test4': False}
         arr_ann1 = {'index': np.arange(10, 13)}
         arr_ann2 = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc1 = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.us,
                      labels=np.array(['test epoch 1 1', 'test epoch 1 2', 'test epoch 1 3'],
-                                     dtype='S'), name='test', description='tester 1',
+                                     dtype='U'), name='test', description='tester 1',
                      file_origin='test.file', test1=1, array_annotations=arr_ann1, **params1)
         epc2 = Epoch([2.1, 2.5, 2.7] * pq.us, durations=[3, 5, 7] * pq.ms,
                      labels=np.array(['test epoch 2 1', 'test epoch 2 2', 'test epoch 2 3'],
-                                     dtype='S'), name='test', description='tester 2',
+                                     dtype='U'), name='test', description='tester 2',
                      file_origin='test.file', test1=1, array_annotations=arr_ann2, **params2)
         epctarg = Epoch([1.1, 1.5, 1.7, .0021, .0025, .0027] * pq.ms,
                         durations=[20, 40, 60, 3000, 5000, 7000] * pq.us,
                         labels=np.array(['test epoch 1 1', 'test epoch 1 2', 'test epoch 1 3',
                                          'test epoch 2 1', 'test epoch 2 2', 'test epoch 2 3'],
-                                        dtype='S'),
+                                        dtype='U'),
                         name='test',
                         description='merge(tester 1, tester 2)', file_origin='test.file',
                         array_annotations={'index': [10, 11, 12, 0, 1, 2]}, test1=1, **paramstarg)
         assert_neo_object_is_compliant(epc1)
         assert_neo_object_is_compliant(epc2)
         assert_neo_object_is_compliant(epctarg)
 
@@ -245,15 +249,15 @@
         epc.labels = ['D', 'E', 'F']
         assert_array_equal(epc.labels, np.array(['D', 'E', 'F']))
         self.assertRaises(ValueError, setattr, epc, "labels", ['X', 'Y'])
 
     def test__children(self):
         params = {'test2': 'y1', 'test3': True}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         segment = Segment(name='seg1')
         segment.epochs = [epc]
         segment.create_many_to_one_relationship()
@@ -271,52 +275,52 @@
         self.assertEqual(epc.parents[0].name, 'seg1')
 
         assert_neo_object_is_compliant(epc)
 
     @unittest.skipUnless(HAVE_IPYTHON, "requires IPython")
     def test__pretty(self):
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file')
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         prepr = pretty(epc)
         targ = ("Epoch\nname: '%s'\ndescription: '%s'\nannotations: %s"
                 "" % (epc.name, epc.description, pretty(epc.annotations)))
 
         self.assertEqual(prepr, targ)
 
     def test__time_slice(self):
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc = Epoch(times=[10, 20, 30] * pq.s, durations=[10, 5, 7] * pq.ms,
-                    labels=np.array(['btn0', 'btn1', 'btn2'], dtype='S'), foo='bar',
+                    labels=np.array(['btn0', 'btn1', 'btn2'], dtype='U'), foo='bar',
                     array_annotations=arr_ann)
 
         epc2 = epc.time_slice(10 * pq.s, 20 * pq.s)
         assert_arrays_equal(epc2.times, [10, 20] * pq.s)
         assert_arrays_equal(epc2.durations, [10, 5] * pq.ms)
-        assert_arrays_equal(epc2.labels, np.array(['btn0', 'btn1'], dtype='S'))
+        assert_arrays_equal(epc2.labels, np.array(['btn0', 'btn1'], dtype='U'))
         self.assertEqual(epc.annotations, epc2.annotations)
         assert_arrays_equal(epc2.array_annotations['index'], np.arange(2))
         assert_arrays_equal(epc2.array_annotations['test'], np.array(['a', 'b']))
         self.assertIsInstance(epc2.array_annotations, ArrayDict)
 
     def test_time_slice2(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         targ = Epoch([1.5] * pq.ms, durations=[40] * pq.ns,
-                     labels=np.array(['test epoch 2'], dtype='S'), name='test',
+                     labels=np.array(['test epoch 2'], dtype='U'), name='test',
                      description='tester', file_origin='test.file', test1=1,
                      array_annotations={'index': [1], 'test': ['b']}, **params)
         targ.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(targ)
 
         t_start = 1.2
         t_stop = 1.6
@@ -410,22 +414,22 @@
 
         self.assertFalse(all(self.epc == result))
 
     def test_time_slice_out_of_boundries(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         targ = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                     labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                     labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                      name='test', description='tester', file_origin='test.file', test1=1,
                      array_annotations=arr_ann, **params)
         targ.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(targ)
 
         t_start = 0.0001
         t_stop = 30
@@ -442,20 +446,20 @@
         self.assertEqual(result.annotations['test2'], targ.annotations['test2'])
         assert_arrays_equal(result.array_annotations['index'], np.array(arr_ann['index']))
         assert_arrays_equal(result.array_annotations['test'], np.array(arr_ann['test']))
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
     def test_time_slice_empty(self):
         params = {'test2': 'y1', 'test3': True}
-        epc = Epoch([] * pq.ms, durations=[] * pq.ns, labels=np.array([], dtype='S'), name='test',
+        epc = Epoch([] * pq.ms, durations=[] * pq.ns, labels=np.array([], dtype='U'), name='test',
                     description='tester', file_origin='test.file', test1=1, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
-        targ = Epoch([] * pq.ms, durations=[] * pq.ns, labels=np.array([], dtype='S'), name='test',
+        targ = Epoch([] * pq.ms, durations=[] * pq.ns, labels=np.array([], dtype='U'), name='test',
                      description='tester', file_origin='test.file', test1=1, **params)
         targ.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(targ)
 
         t_start = 1.2
         t_stop = 1.6
         result = epc.time_slice(t_start, t_stop)
@@ -471,22 +475,22 @@
         self.assertEqual(result.annotations['test2'], targ.annotations['test2'])
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
     def test_time_slice_none_stop(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         targ = Epoch([1.5, 1.7] * pq.ms, durations=[40, 60] * pq.ns,
-                     labels=np.array(['test epoch 2', 'test epoch 3'], dtype='S'), name='test',
+                     labels=np.array(['test epoch 2', 'test epoch 3'], dtype='U'), name='test',
                      description='tester', file_origin='test.file', test1=1,
                      array_annotations={'index': [1, 2], 'test': ['b', 'c']}, **params)
         targ.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(targ)
 
         t_start = 1.2
         t_stop = None
@@ -505,22 +509,22 @@
         assert_arrays_equal(result.array_annotations['test'], np.array(['b', 'c']))
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
     def test_time_slice_none_start(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         targ = Epoch([1.1, 1.5] * pq.ms, durations=[20, 40] * pq.ns,
-                     labels=np.array(['test epoch 1', 'test epoch 2'], dtype='S'), name='test',
+                     labels=np.array(['test epoch 1', 'test epoch 2'], dtype='U'), name='test',
                      description='tester', file_origin='test.file', test1=1,
                      array_annotations={'index': [0, 1], 'test': ['a', 'b']}, **params)
         targ.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(targ)
 
         t_start = None
         t_stop = 1.6
@@ -539,22 +543,22 @@
         assert_arrays_equal(result.array_annotations['test'], np.array(['a', 'b']))
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
     def test_time_slice_none_both(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         targ = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                     labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                     labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                      name='test', description='tester', file_origin='test.file', test1=1,
                      array_annotations=arr_ann, **params)
         targ.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(targ)
 
         t_start = None
         t_stop = None
@@ -573,22 +577,22 @@
         assert_arrays_equal(result.array_annotations['test'], np.array(['a', 'b', 'c']))
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
     def test_time_slice_differnt_units(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epc = Epoch([1.1, 1.5, 1.7] * pq.ms, durations=[20, 40, 60] * pq.ns,
-                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='S'),
+                    labels=np.array(['test epoch 1', 'test epoch 2', 'test epoch 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         epc.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(epc)
 
         targ = Epoch([1.5] * pq.ms, durations=[40] * pq.ns,
-                     labels=np.array(['test epoch 2'], dtype='S'), name='test',
+                     labels=np.array(['test epoch 2'], dtype='U'), name='test',
                      description='tester', file_origin='test.file', test1=1,
                      array_annotations={'index': [1], 'test': ['b']}, **params)
         targ.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(targ)
 
         t_start = 0.0012 * pq.s
         t_stop = 0.0016 * pq.s
@@ -687,14 +691,40 @@
         assert_array_equal(single_epoch.times, np.array([3.0, 4.0]))
         assert_array_equal(single_epoch.durations, np.array([0.2, 0.3]))
         assert_array_equal(single_epoch.labels, np.array(["B", "C"]))
         assert_arrays_equal(single_epoch.array_annotations['index'], np.arange(1, 3))
         assert_arrays_equal(single_epoch.array_annotations['test'], np.array(['b', 'c']))
         self.assertIsInstance(single_epoch.array_annotations, ArrayDict)
 
+    def test_rescale(self):
+        times = [2, 3, 4, 5]
+        durations = [0.1, 0.2, 0.3, 0.4]
+        labels = ["A", "B", "C", "D"]
+        arr_ann = {'index': np.arange(4), 'test': ['a', 'b', 'c', 'd']}
+        epc = Epoch(times * pq.ms, durations=durations * pq.ms, labels=labels,
+                    array_annotations=arr_ann)
+        result = epc.rescale(pq.us)
+
+        self.assertIsInstance(result, Epoch)
+        assert_neo_object_is_compliant(result)
+        assert_arrays_equal(result.array_annotations['index'], np.arange(4))
+        assert_arrays_equal(result.array_annotations['test'],
+                            np.array(['a', 'b', 'c', 'd']))
+        self.assertIsInstance(result.array_annotations, ArrayDict)
+
+        self.assertEqual(result.units, 1 * pq.us)
+        assert_array_equal(epc.labels, result.labels)
+        assert_arrays_almost_equal(result.times, [2000, 3000, 4000, 5000] * pq.us, 1e-9)
+        assert_arrays_almost_equal(result.times.magnitude,
+                                   np.array([2000, 3000, 4000, 5000]),
+                                   1e-9)
+        assert_arrays_almost_equal(result.durations.magnitude,
+                                   np.array([100, 200, 300, 400]),
+                                   1e-9)
+
 
 class TestDuplicateWithNewData(unittest.TestCase):
     def setUp(self):
         self.data = np.array([0.1, 0.5, 1.2, 3.3, 6.4, 7])
         self.durations = np.array([0.2, 0.4, 1.1, 2.4, 0.2, 2.0])
         self.quant = pq.ms
         self.arr_ann = {'index': np.arange(6), 'test': ['a', 'b', 'c', 'd', 'e', 'f']}
@@ -716,15 +746,15 @@
         self.assertIsInstance(signal1b.array_annotations, ArrayDict)
 
 
 class TestEpochFunctions(unittest.TestCase):
     def test__pickle(self):
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         epoch1 = Epoch(np.arange(0, 30, 10) * pq.s, durations=[1, 2, 3] * pq.s,
-                       labels=np.array(['t0', 't1', 't2'], dtype='S'), units='s',
+                       labels=np.array(['t0', 't1', 't2'], dtype='U'), units='s',
                        annotation1="foo", annotation2="bar", array_annotations=arr_ann)
         fobj = open('./pickle', 'wb')
         pickle.dump(epoch1, fobj)
         fobj.close()
 
         fobj = open('./pickle', 'rb')
         try:
```

### Comparing `neo-0.8.0/neo/test/coretest/test_event.py` & `neo-0.9.0/neo/test/coretest/test_event.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.event.Event class
 """
 
 import unittest
 import warnings
 from copy import deepcopy
@@ -39,15 +38,15 @@
         np.random.seed(0)
         self.annotations = {
             str(x): TEST_ANNOTATIONS[x] for x in range(len(TEST_ANNOTATIONS))}
 
     def test__get_fake_values(self):
         self.annotations['seed'] = 0
         times = get_fake_value('times', pq.Quantity, seed=0, dim=1)
-        labels = get_fake_value('labels', np.ndarray, seed=1, dim=1, dtype='S')
+        labels = get_fake_value('labels', np.ndarray, seed=1, dim=1, dtype='U')
         name = get_fake_value('name', str, seed=2, obj=Event)
         description = get_fake_value('description', str, seed=3, obj='Event')
         file_origin = get_fake_value('file_origin', str)
         arr_ann = get_fake_value('array_annotations', dict, seed=5, obj=Event, n=5)
         attrs1 = {'name': name, 'description': description, 'file_origin': file_origin}
         attrs2 = attrs1.copy()
         attrs2.update(self.annotations)
@@ -118,34 +117,38 @@
     def test_setup_compliant(self):
         assert_neo_object_is_compliant(self.evt)
 
     def test_Event_creation(self):
         params = {'test2': 'y1', 'test3': True}
         arr_ann = {'names': ['a', 'b', 'c'], 'index': np.arange(10, 13)}
         evt = Event([1.1, 1.5, 1.7] * pq.ms,
-                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='S'),
+                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1,
                     array_annotations=arr_ann, **params)
         evt.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(evt)
 
         assert_arrays_equal(evt.times, [1.1, 1.5, 1.7] * pq.ms)
         assert_arrays_equal(evt.labels,
-                            np.array(['test event 1', 'test event 2', 'test event 3'], dtype='S'))
+                            np.array(['test event 1', 'test event 2', 'test event 3'], dtype='U'))
         self.assertEqual(evt.name, 'test')
         self.assertEqual(evt.description, 'tester')
         self.assertEqual(evt.file_origin, 'test.file')
         self.assertEqual(evt.annotations['test0'], [1, 2])
         self.assertEqual(evt.annotations['test1'], 1.1)
         self.assertEqual(evt.annotations['test2'], 'y1')
         self.assertTrue(evt.annotations['test3'])
         assert_arrays_equal(evt.array_annotations['names'], np.array(['a', 'b', 'c']))
         assert_arrays_equal(evt.array_annotations['index'], np.arange(10, 13))
         self.assertIsInstance(evt.array_annotations, ArrayDict)
 
+    def test_Event_invalid_times_dimension(self):
+        data2d = np.array([1, 2, 3, 4]).reshape((4, -1))
+        self.assertRaises(ValueError, Event, times=data2d * pq.s)
+
     def test_Event_creation_invalid_labels(self):
         self.assertRaises(ValueError, Event, [1.1, 1.5, 1.7] * pq.ms,
                           labels=["A", "B"])
 
     def test_Event_creation_from_lists(self):
         evt = Event([1.1, 1.5, 1.7],
                     ['test event 1', 'test event 2', 'test event 3'],
@@ -440,15 +443,15 @@
         assert_arrays_equal(result.array_annotations['index'], np.arange(5, 8))
         assert_arrays_equal(result.array_annotations['test'], np.arange(105, 108))
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
     def test_Event_repr(self):
         params = {'test2': 'y1', 'test3': True}
         evt = Event([1.1, 1.5, 1.7] * pq.ms,
-                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='S'),
+                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1, **params)
         evt.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(evt)
 
         targ = ('<Event: test event 1@1.1 ms, test event 2@1.5 ms, ' + 'test event 3@1.7 ms>')
 
         res = repr(evt)
@@ -460,24 +463,24 @@
         params1 = {'test2': 'y1', 'test3': True}
         params2 = {'test2': 'no', 'test4': False}
         paramstarg = {'test2': 'yes;no', 'test3': True, 'test4': False}
         arr_ann1 = {'index': np.arange(10, 13)}
         arr_ann2 = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
         evt1 = Event([1.1, 1.5, 1.7] * pq.ms,
                      labels=np.array(['test event 1 1', 'test event 1 2', 'test event 1 3'],
-                                     dtype='S'), name='test', description='tester 1',
+                                     dtype='U'), name='test', description='tester 1',
                      file_origin='test.file', array_annotations=arr_ann1, test1=1, **params1)
         evt2 = Event([2.1, 2.5, 2.7] * pq.us,
                      labels=np.array(['test event 2 1', 'test event 2 2', 'test event 2 3'],
-                                     dtype='S'), name='test', description='tester 2',
+                                     dtype='U'), name='test', description='tester 2',
                      file_origin='test.file', array_annotations=arr_ann2, test1=1, **params2)
         evttarg = Event([1.1, 1.5, 1.7, .0021, .0025, .0027] * pq.ms,
                         labels=np.array(['test event 1 1', 'test event 1 2', 'test event 1 3',
                                          'test event 2 1', 'test event 2 2', 'test event 2 3'],
-                                        dtype='S'),
+                                        dtype='U'),
                         name='test',
                         description='merge(tester 1, tester 2)', file_origin='test.file',
                         array_annotations={'index': [10, 11, 12, 0, 1, 2]}, test1=1, **paramstarg)
         assert_neo_object_is_compliant(evt1)
         assert_neo_object_is_compliant(evt2)
         assert_neo_object_is_compliant(evttarg)
 
@@ -507,15 +510,15 @@
         evt.labels = ['D', 'E', 'F']
         assert_array_equal(evt.labels, np.array(['D', 'E', 'F']))
         self.assertRaises(ValueError, setattr, evt, "labels", ['X', 'Y'])
 
     def test__children(self):
         params = {'test2': 'y1', 'test3': True}
         evt = Event([1.1, 1.5, 1.7] * pq.ms,
-                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='S'),
+                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file', test1=1, **params)
         evt.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(evt)
 
         segment = Segment(name='seg1')
         segment.events = [evt]
         segment.create_many_to_one_relationship()
@@ -533,15 +536,15 @@
         self.assertEqual(evt.parents[0].name, 'seg1')
 
         assert_neo_object_is_compliant(evt)
 
     @unittest.skipUnless(HAVE_IPYTHON, "requires IPython")
     def test__pretty(self):
         evt = Event([1.1, 1.5, 1.7] * pq.ms,
-                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='S'),
+                    labels=np.array(['test event 1', 'test event 2', 'test event 3'], dtype='U'),
                     name='test', description='tester', file_origin='test.file')
         evt.annotate(test1=1.1, test0=[1, 2])
         assert_neo_object_is_compliant(evt)
 
         prepr = pretty(evt)
         targ = ("Event\nname: '%s'\ndescription: '%s'\nannotations: %s"
                 "" % (evt.name, evt.description, pretty(evt.annotations)))
@@ -644,14 +647,35 @@
         odd_event = Event(times=np.array([5.0, 12.0, 23.0]), units="ms",
                           labels=np.array(["A", "B", "C"]))
         self.assertRaises(ValueError, odd_event.to_epoch, pairwise=True)
 
         # todo: fix Epoch, as the following does not raise a ValueError  # self.assertRaises(
         # ValueError, event.to_epoch, durations=2.0)  # missing units
 
+    def test_rescale(self):
+        times = [2, 3, 4, 5]
+        labels = ["A", "B", "C", "D"]
+        arr_ann = {'index': np.arange(4), 'test': ['a', 'b', 'c', 'd']}
+        evt = Event(times * pq.ms, labels=labels,
+                    array_annotations=arr_ann)
+        result = evt.rescale(pq.us)
+
+        self.assertIsInstance(result, Event)
+        assert_neo_object_is_compliant(result)
+        assert_arrays_equal(result.array_annotations['index'], np.arange(4))
+        assert_arrays_equal(result.array_annotations['test'],
+                            np.array(['a', 'b', 'c', 'd']))
+        self.assertIsInstance(result.array_annotations, ArrayDict)
+
+        self.assertEqual(result.units, 1 * pq.us)
+        assert_array_equal(evt.labels, result.labels)
+        assert_arrays_almost_equal(result.times, [2000, 3000, 4000, 5000] * pq.us, 1e-9)
+        assert_arrays_almost_equal(result.times.magnitude,
+                                   np.array([2000, 3000, 4000, 5000]),
+                                   1e-9)
 
 class TestDuplicateWithNewData(unittest.TestCase):
     def setUp(self):
         self.data = np.array([0.1, 0.5, 1.2, 3.3, 6.4, 7])
         self.dataquant = self.data * pq.ms
         self.arr_ann = {'index': np.arange(6), 'test': ['a', 'b', 'c', 'd', 'e', 'f']}
         self.event = Event(times=self.dataquant, labels=np.array(['a', 'b', 'c', 'd', 'e', 'f']),
@@ -670,15 +694,15 @@
         self.assertTrue('test' not in signal1b.array_annotations)
         self.assertIsInstance(signal1b.array_annotations, ArrayDict)
 
 
 class TestEventFunctions(unittest.TestCase):
     def test__pickle(self):
         arr_ann = {'index': np.arange(3), 'test': ['a', 'b', 'c']}
-        event1 = Event(np.arange(0, 30, 10) * pq.s, labels=np.array(['t0', 't1', 't2'], dtype='S'),
+        event1 = Event(np.arange(0, 30, 10) * pq.s, labels=np.array(['t0', 't1', 't2'], dtype='U'),
                        units='s', annotation1="foo", annotation2="bar", array_annotations=arr_ann)
         fobj = open('./pickle', 'wb')
         pickle.dump(event1, fobj)
         fobj.close()
 
         fobj = open('./pickle', 'rb')
         try:
```

### Comparing `neo-0.8.0/neo/test/coretest/test_generate_datasets.py` & `neo-0.9.0/neo/test/coretest/test_generate_datasets.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 '''
 Test to  make sure generated datasets are sane.
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import unittest
 
 from datetime import datetime
 
 import numpy as np
 import quantities as pq
 
@@ -592,15 +588,15 @@
 
         assert_neo_object_is_compliant(res)
         self.assertEqual(res.annotations, self.annotations)
 
         resattr = get_fake_values(cls, annotate=False, seed=0)
         if seed is not None:
             for name, value in resattr.items():
-                if name in ['channel_names', 'channel_indexes', 'channel_index', 'coordinates']:
+                if name in ['channel_names', 'channel_ids', 'index', 'coordinates']:
                     continue
                 try:
                     try:
                         resvalue = getattr(res, name)
                     except AttributeError:
                         if name == 'signal':
                             continue
```

### Comparing `neo-0.8.0/neo/test/coretest/test_imagesequence.py` & `neo-0.9.0/neo/test/coretest/test_imagesequence.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,80 +1,111 @@
+from neo.core.analogsignal import AnalogSignal
 import unittest
 from neo.core import ImageSequence
-from neo.core.regionofinterest import CircularRegionOfInterest, RectangularRegionOfInterest, PolygonRegionOfInterest
+from neo.core.regionofinterest import (
+    CircularRegionOfInterest,
+    RectangularRegionOfInterest,
+    PolygonRegionOfInterest,
+)
 import quantities as pq
 import numpy as np
 from neo.core import Block, Segment
 
 
 class TestImageSequence(unittest.TestCase):
-
     def setUp(self):
         self.data = []
         for frame in range(20):
             self.data.append([])
             for y in range(50):
                 self.data[frame].append([])
                 for x in range(50):
                     self.data[frame][y].append(x)
 
     def test_sampling_rate(self):
         # test if error is raise when not giving sample_rate
         with self.assertRaises(ValueError):
-            ImageSequence(self.data, units='V', spatial_scale='m')
+            ImageSequence(self.data, units="V", spatial_scale=1 * pq.um)
 
         with self.assertRaises(TypeError):
-            ImageSequence(self.data, sampling_period=500, units='V', spatial_scale='m')
+            ImageSequence(self.data, frame_duration=500, units="V", spatial_scale=1 * pq.um)
         # test if error is raise when not giving frequency at sampling rate
         with self.assertRaises(TypeError):
-            ImageSequence(self.data, units='V', sampling_rate=500, spatial_scale='m')
+            ImageSequence(self.data, units="V", sampling_rate=500, spatial_scale=1 * pq.um)
 
     def test_error_spatial_scale(self):
         # test if error is raise when not giving spatial scale
         with self.assertRaises(ValueError):
-            ImageSequence(self.data, units='V', sampling_rate=500 * pq.Hz)
+            ImageSequence(self.data, units="V", sampling_rate=500 * pq.Hz)
 
     def test_units(self):
         with self.assertRaises(TypeError):
-            ImageSequence(self.data, sampling_rate=500 * pq.Hz, spatial_scale='m')
+            ImageSequence(self.data, sampling_rate=500 * pq.Hz, spatial_scale=1 * pq.um)
 
     def test_wrong_dimensions(self):
-        l = ImageSequence(self.data, sampling_rate=500 * pq.Hz, units='V',
-                          spatial_scale='m')
+        seq = ImageSequence(self.data, sampling_rate=500 * pq.Hz,
+                            units="V", spatial_scale=1 * pq.um)
 
-        self.assertEqual(l.sampling_rate, 500 * pq.Hz)
-        self.assertEqual(l.spatial_scale, 'm')
+        self.assertEqual(seq.sampling_rate, 500 * pq.Hz)
+        self.assertEqual(seq.spatial_scale, 1 * pq.um)
         # giving wrong dimension test if it give an error
         with self.assertRaises(ValueError):
-            ImageSequence([[0, 1, 2, 4, 2], [0, 1, 2, 4, 5]],
-                          sampling_rate=500 * pq.Hz, units='V', spatial_scale='m')
+            ImageSequence(
+                [[0, 1, 2, 4, 2], [0, 1, 2, 4, 5]],
+                sampling_rate=500 * pq.Hz,
+                units="V",
+                spatial_scale=1 * pq.um,
+            )
+
+    def test_t_start(self):
+        seq = ImageSequence(
+            self.data,
+            sampling_rate=500 * pq.Hz,
+            units="V",
+            t_start=250 * pq.ms,
+            spatial_scale=1 * pq.um,
+        )
+        self.assertEqual(seq.t_start, 250 * pq.ms)
+        n_frames = seq.shape[0]
+        self.assertEqual(seq.duration, n_frames / seq.sampling_rate)
+        self.assertEqual(seq.t_stop, 290 * pq.ms)
 
 
 class TestMethodImageSequence(unittest.TestCase):
-
     def fake_region_of_interest(self):
         self.rect_ROI = RectangularRegionOfInterest(2, 2, 2, 2)
         self.data = []
         for frame in range(25):
             self.data.append([])
             for y in range(5):
                 self.data[frame].append([])
                 for x in range(5):
                     self.data[frame][y].append(x)
 
     def test_signal_from_region(self):
         self.fake_region_of_interest()
-        l = ImageSequence(self.data, units='V', sampling_rate=500 * pq.Hz, spatial_scale='m').signal_from_region(
-            self.rect_ROI)
-        self.assertIsInstance(l, list)
-        for i in range(len(l)):
-            self.assertIsInstance(l[i], object)
+        seq = ImageSequence(
+            self.data,
+            units="V",
+            sampling_rate=500 * pq.Hz,
+            t_start=250 * pq.ms,
+            spatial_scale=1 * pq.um,
+        )
+        signals = seq.signal_from_region(self.rect_ROI)
+        self.assertIsInstance(signals, list)
+        self.assertEqual(len(signals), 1)
+        for signal in signals:
+            self.assertIsInstance(signal, AnalogSignal)
+            self.assertEqual(signal.t_start, seq.t_start)
+            self.assertEqual(signal.sampling_period, seq.frame_duration)
         with self.assertRaises(ValueError):  # no pixels in region
-            ImageSequence(self.data, units='V', sampling_rate=500 * pq.Hz,
-                          spatial_scale='m').signal_from_region(RectangularRegionOfInterest(1, 1, 0, 0))
+            ImageSequence(
+                self.data, units="V", sampling_rate=500 * pq.Hz, spatial_scale=1 * pq.um
+            ).signal_from_region(RectangularRegionOfInterest(1, 1, 0, 0))
         with self.assertRaises(ValueError):
-            ImageSequence(self.data, units='V', sampling_rate=500 *
-                          pq.Hz, spatial_scale='m').signal_from_region()
+            ImageSequence(
+                self.data, units="V", sampling_rate=500 * pq.Hz, spatial_scale=1 * pq.um
+            ).signal_from_region()
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `neo-0.8.0/neo/test/coretest/test_irregularysampledsignal.py` & `neo-0.9.0/neo/test/coretest/test_irregularysampledsignal.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.irregularlysampledsignal.IrregularySampledSignal class
 """
 
 import unittest
 
 import os
@@ -19,14 +18,21 @@
 try:
     from IPython.lib.pretty import pretty
 except ImportError as err:
     HAVE_IPYTHON = False
 else:
     HAVE_IPYTHON = True
 
+try:
+    import scipy
+except ImportError:
+    HAVE_SCIPY = False
+else:
+    HAVE_SCIPY = True
+
 from neo.core.irregularlysampledsignal import IrregularlySampledSignal
 from neo.core import Segment, ChannelIndex
 from neo.core.baseneo import MergeError
 from neo.test.tools import (assert_arrays_almost_equal, assert_arrays_equal,
                             assert_neo_object_is_compliant, assert_same_sub_schema,
                             assert_same_attributes, assert_same_annotations,
                             assert_same_array_annotations)
@@ -229,21 +235,19 @@
                                        name='test', description='tester', file_origin='test.file',
                                        test1=1)
         assert_neo_object_is_compliant(sig)
 
         if np.__version__.split(".")[:2] > ['1', '13']:
             # see https://github.com/numpy/numpy/blob/master/doc/release/1.14.0-notes.rst#many
             # -changes-to-array-printing-disableable-with-the-new-legacy-printing-mode
-            targ = (
-                '<IrregularlySampledSignal(array([[2.],\n       [4.],\n       [6.]]) * V '
-                '' + 'at times [1.1 1.5 1.7] s)>')
+            targ = ('<IrregularlySampledSignal(array([[2.],\n       [4.],\n       [6.]]) * V '
+                    '' + 'at times [1.1 1.5 1.7] s)>')
         else:
-            targ = (
-                '<IrregularlySampledSignal(array([[ 2.],\n       [ 4.],\n       [ 6.]]) '
-                '* V ' + 'at times [ 1.1  1.5  1.7] s)>')
+            targ = ('<IrregularlySampledSignal(array([[ 2.],\n       [ 4.],\n       [ 6.]]) '
+                    '* V ' + 'at times [ 1.1  1.5  1.7] s)>')
         res = repr(sig)
         self.assertEqual(targ, res)
 
 
 class TestIrregularlySampledSignalArrayMethods(unittest.TestCase):
     def setUp(self):
         self.data1 = np.arange(10.0)
@@ -348,17 +352,14 @@
         self.assertEqual(self.signal1.max(), 9 * pq.mV)
         self.assertEqual(self.signal1.min(), 0 * pq.mV)
         self.assertEqual(self.signal1.mean(), targmean)
 
     def test_mean_interpolation_NotImplementedError(self):
         self.assertRaises(NotImplementedError, self.signal1.mean, True)
 
-    def test_resample_NotImplementedError(self):
-        self.assertRaises(NotImplementedError, self.signal1.resample, True)
-
     def test__rescale_same(self):
         result = self.signal1.copy()
         result = result.rescale(pq.mV)
 
         self.assertIsInstance(result, IrregularlySampledSignal)
         assert_neo_object_is_compliant(result)
         self.assertEqual(result.name, 'spam')
@@ -454,15 +455,15 @@
         self.assertNotEqual(self.signal1.annotations['test1'], result.annotations['test1'])
         self.assertNotEqual(self.signal1.annotations['test2'], result.annotations['test2'])
 
     def test__time_slice_deepcopy_array_annotations(self):
         length = self.signal1.shape[-1]
         params1 = {'test0': ['y{}'.format(i) for i in range(length)],
                    'test1': ['deeptest' for i in range(length)],
-                   'test2': [(-1)**i > 0 for i in range(length)]}
+                   'test2': [(-1) ** i > 0 for i in range(length)]}
         self.signal1.array_annotate(**params1)
         result = self.signal1.time_slice(None, None)
 
         # Change annotations of original
         params2 = {'test0': ['x{}'.format(i) for i in range(length)],
                    'test2': [(-1) ** (i + 1) > 0 for i in range(length)]}
         self.signal1.array_annotate(**params2)
@@ -472,34 +473,34 @@
                              == result.array_annotations['test0']))
         self.assertFalse(all(self.signal1.array_annotations['test1']
                              == result.array_annotations['test1']))
         self.assertFalse(all(self.signal1.array_annotations['test2']
                              == result.array_annotations['test2']))
 
         # Change annotations of result
-        params3 = {'test0': ['z{}'.format(i) for i in range(1, result.shape[-1]+1)]}
+        params3 = {'test0': ['z{}'.format(i) for i in range(1, result.shape[-1] + 1)]}
         result.array_annotate(**params3)
         result.array_annotations['test1'][0] = 'shallow2'
         self.assertFalse(all(self.signal1.array_annotations['test0']
                              == result.array_annotations['test0']))
         self.assertFalse(all(self.signal1.array_annotations['test1']
                              == result.array_annotations['test1']))
         self.assertFalse(all(self.signal1.array_annotations['test2']
                              == result.array_annotations['test2']))
 
     def test__time_slice_deepcopy_data(self):
         result = self.signal1.time_slice(None, None)
 
         # Change values of original array
-        self.signal1[2] = 7.3*self.signal1.units
+        self.signal1[2] = 7.3 * self.signal1.units
 
         self.assertFalse(all(self.signal1 == result))
 
         # Change values of sliced array
-        result[3] = 9.5*result.units
+        result[3] = 9.5 * result.units
 
         self.assertFalse(all(self.signal1 == result))
 
     def test_time_slice_out_of_boundries(self):
         targdataquant = self.data1quant
         targtimequant = self.time1quant
         targ_signal = IrregularlySampledSignal(targtimequant, signal=targdataquant, name='spam',
@@ -706,14 +707,22 @@
         assert_array_equal(self.data1, sig_as_q.magnitude.flat)
 
     def test__copy_should_preserve_parent_objects(self):
         result = self.signal1.copy()
         self.assertIs(result.segment, self.signal1.segment)
         self.assertIs(result.channel_index, self.signal1.channel_index)
 
+    @unittest.skipUnless(HAVE_SCIPY, "requires Scipy")
+    def test_resample(self):
+        factors = [1, 2, 10]
+        for factor in factors:
+            result = self.signal1.resample(self.signal1.shape[0] * factor)
+            np.testing.assert_allclose(self.signal1.magnitude, result.magnitude[::factor],
+                                       rtol=1e-7, atol=0)
+
 
 class TestIrregularlySampledSignalCombination(unittest.TestCase):
     def setUp(self):
         self.data1 = np.arange(10.0)
         self.data1quant = self.data1 * pq.mV
         self.time1 = np.logspace(1, 5, 10)
         self.time1quant = self.time1 * pq.ms
@@ -930,14 +939,81 @@
                             np.array([0, 1, 2, 3, 4, 5, 100, 101, 102]))
         self.assertIsInstance(merged12.array_annotations, ArrayDict)
 
         assert_arrays_equal(merged12.magnitude, target_data12)
 
         self.assertRaises(MergeError, signal1.merge, signal3)
 
+    def test_concatenate_simple(self):
+        signal1 = IrregularlySampledSignal(signal=[0, 1, 2, 3] * pq.s,
+                                           times=[1, 10, 11, 14] * pq.s)
+        signal2 = IrregularlySampledSignal(signal=[4, 5, 6] * pq.s, times=[15, 16, 21] * pq.s)
+
+        result = signal1.concatenate(signal2)
+        assert_array_equal(np.array([0, 1, 2, 3, 4, 5, 6]).reshape((-1, 1)), result.magnitude)
+        assert_array_equal(np.array([1, 10, 11, 14, 15, 16, 21]), result.times)
+        for attr in signal1._necessary_attrs:
+            if attr[0] == 'times':
+                continue
+            self.assertEqual(getattr(signal1, attr[0], None), getattr(result, attr[0], None))
+
+    def test_concatenate_no_overlap(self):
+        signal1 = IrregularlySampledSignal(signal=[0, 1, 2, 3] * pq.s, times=range(4) * pq.s)
+        signal2 = IrregularlySampledSignal(signal=[4, 5, 6] * pq.s, times=range(4, 7) * pq.s)
+
+        for allow_overlap in [True, False]:
+            result = signal1.concatenate(signal2, allow_overlap=allow_overlap)
+            assert_array_equal(np.arange(7).reshape((-1, 1)), result.magnitude)
+            assert_array_equal(np.arange(7), result.times)
+
+    def test_concatenate_overlap_exception(self):
+        signal1 = IrregularlySampledSignal(signal=[0, 1, 2, 3] * pq.s, times=range(4) * pq.s)
+        signal2 = IrregularlySampledSignal(signal=[4, 5, 6] * pq.s, times=range(2, 5) * pq.s)
+
+        self.assertRaises(ValueError, signal1.concatenate, signal2, allow_overlap=False)
+
+    def test_concatenate_overlap(self):
+        signal1 = IrregularlySampledSignal(signal=[0, 1, 2, 3] * pq.s, times=range(4) * pq.s)
+        signal2 = IrregularlySampledSignal(signal=[4, 5, 6] * pq.s, times=range(2, 5) * pq.s)
+
+        result = signal1.concatenate(signal2, allow_overlap=True)
+        assert_array_equal(np.array([0, 1, 2, 4, 3, 5, 6]).reshape((-1, 1)), result.magnitude)
+        assert_array_equal(np.array([0, 1, 2, 2, 3, 3, 4]), result.times)
+
+    def test_concatenate_multi_trace(self):
+        data1 = np.arange(4).reshape(2, 2)
+        data2 = np.arange(4, 8).reshape(2, 2)
+        n1 = len(data1)
+        n2 = len(data2)
+        signal1 = IrregularlySampledSignal(signal=data1 * pq.s, times=range(n1) * pq.s)
+        signal2 = IrregularlySampledSignal(signal=data2 * pq.s, times=range(n1, n1 + n2) * pq.s)
+
+        result = signal1.concatenate(signal2)
+        data_expected = np.array([[0, 1], [2, 3], [4, 5], [6, 7]])
+        assert_array_equal(data_expected, result.magnitude)
+
+    def test_concatenate_array_annotations(self):
+        array_anno1 = {'first': ['a', 'b']}
+        array_anno2 = {'first': ['a', 'b'],
+                       'second': ['c', 'd']}
+        data1 = np.arange(4).reshape(2, 2)
+        data2 = np.arange(4, 8).reshape(2, 2)
+        n1 = len(data1)
+        n2 = len(data2)
+        signal1 = IrregularlySampledSignal(signal=data1 * pq.s, times=range(n1) * pq.s,
+                                           array_annotations=array_anno1)
+        signal2 = IrregularlySampledSignal(signal=data2 * pq.s, times=range(n1, n1 + n2) * pq.s,
+                                           array_annotations=array_anno2)
+
+        result = signal1.concatenate(signal2)
+        assert_array_equal(array_anno1.keys(), result.array_annotations.keys())
+
+        for k in array_anno1.keys():
+            assert_array_equal(np.asarray(array_anno1[k]), result.array_annotations[k])
+
 
 class TestAnalogSignalFunctions(unittest.TestCase):
     def test__pickle(self):
         signal1 = IrregularlySampledSignal(np.arange(10.0) / 100 * pq.s, np.arange(10.0),
                                            units="mV")
 
         fobj = open('./pickle', 'wb')
```

### Comparing `neo-0.8.0/neo/test/coretest/test_regionofinterest.py` & `neo-0.9.0/neo/test/coretest/test_regionofinterest.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/neo/test/coretest/test_segment.py` & `neo-0.9.0/neo/test/coretest/test_segment.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.segment.Segment class
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 from copy import deepcopy
 
 from datetime import datetime
 
 import unittest
 
 import numpy as np
@@ -209,15 +205,14 @@
         self.assertEqual(len(seg.spiketrains), self.nchildren ** 2)
 
     def test__creation(self):
         self.check_creation(self.seg1)
         self.check_creation(self.seg2)
 
     def test_times(self):
-
         for seg in [self.seg1, self.seg2]:
             # calculate target values for t_start and t_stop
             t_starts, t_stops = [], []
             for children in [seg.analogsignals,
                              seg.epochs,
                              seg.events,
                              seg.irregularlysampledsignals,
@@ -235,14 +230,55 @@
                         t_stops.append(child.times[-1])
             targ_t_start = min(t_starts)
             targ_t_stop = max(t_stops)
 
             self.assertEqual(seg.t_start, targ_t_start)
             self.assertEqual(seg.t_stop, targ_t_stop)
 
+        # Testing times with ProxyObjects
+        seg = Segment()
+        reader = ExampleRawIO(filename='my_filename.fake')
+        reader.parse_header()
+
+        proxy_anasig = AnalogSignalProxy(rawio=reader, global_channel_indexes=None, block_index=0,
+                                         seg_index=0)
+        seg.analogsignals.append(proxy_anasig)
+
+        proxy_st = SpikeTrainProxy(rawio=reader, unit_index=0, block_index=0, seg_index=0)
+        seg.spiketrains.append(proxy_st)
+
+        proxy_event = EventProxy(rawio=reader, event_channel_index=0, block_index=0, seg_index=0)
+        seg.events.append(proxy_event)
+
+        proxy_epoch = EpochProxy(rawio=reader, event_channel_index=1, block_index=0, seg_index=0)
+        seg.epochs.append(proxy_epoch)
+
+        t_starts, t_stops = [], []
+        for children in [seg.analogsignals,
+                         seg.epochs,
+                         seg.events,
+                         seg.irregularlysampledsignals,
+                         seg.spiketrains]:
+            for child in children:
+                if hasattr(child, 't_start'):
+                    t_starts.append(child.t_start)
+                if hasattr(child, 't_stop'):
+                    t_stops.append(child.t_stop)
+                if hasattr(child, 'time'):
+                    t_starts.append(child.time)
+                    t_stops.append(child.time)
+                if hasattr(child, 'times'):
+                    t_starts.append(child.times[0])
+                    t_stops.append(child.times[-1])
+        targ_t_start = min(t_starts)
+        targ_t_stop = max(t_stops)
+
+        self.assertEqual(seg.t_start, targ_t_start)
+        self.assertEqual(seg.t_stop, targ_t_stop)
+
     def test__merge(self):
         seg1a = fake_neo(Block, seed=self.seed1, n=self.nchildren).segments[0]
         assert_same_sub_schema(self.seg1, seg1a)
         seg1a.epochs.append(self.epcs2[0])
         seg1a.merge(self.seg2)
 
         assert_same_sub_schema(self.sigarrs1a + self.sigarrs2,
@@ -962,14 +998,41 @@
 
         if has_event:
             self.assertTrue(isinstance(sliced.events[0],
                                        Event))
             assert_same_attributes(sliced.events[0],
                                    sliced_event)
 
+    def test_time_slice_None(self):
+        time_slices = [(None, 5.0 * pq.s), (5.0 * pq.s, None), (None, None)]
+
+        anasig = AnalogSignal(np.arange(50.0) * pq.mV, sampling_rate=1.0 * pq.Hz)
+        seg = Segment()
+        seg.analogsignals = [anasig]
+
+        block = Block()
+        block.segments = [seg]
+        block.create_many_to_one_relationship()
+
+        # test without resetting the time
+        for t_start, t_stop in time_slices:
+            sliced = seg.time_slice(t_start, t_stop)
+
+            assert_neo_object_is_compliant(sliced)
+            self.assertEqual(len(sliced.analogsignals), 1)
+
+            exp_t_start, exp_t_stop = t_start, t_stop
+            if exp_t_start is None:
+                exp_t_start = seg.t_start
+            if exp_t_stop is None:
+                exp_t_stop = seg.t_stop
+
+            self.assertEqual(exp_t_start, sliced.t_start)
+            self.assertEqual(exp_t_stop, sliced.t_stop)
+
     # to remove
     # def test_segment_take_analogsignal_by_unit(self):
     #     result1 = self.seg1.take_analogsignal_by_unit()
     #     result21 = self.seg1.take_analogsignal_by_unit([self.unit1])
     #     result22 = self.seg1.take_analogsignal_by_unit([self.unit2])
     #
     #     self.assertEqual(result1, [])
```

### Comparing `neo-0.8.0/neo/test/coretest/test_spiketrain.py` & `neo-0.9.0/neo/test/coretest/test_spiketrain.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.spiketrain.SpikeTrain class and related functions
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 import sys
 
 import unittest
 import warnings
 from copy import deepcopy
 
 import numpy as np
@@ -21,14 +17,17 @@
 try:
     from IPython.lib.pretty import pretty
 except ImportError as err:
     HAVE_IPYTHON = False
 else:
     HAVE_IPYTHON = True
 
+from neo.rawio.examplerawio import ExampleRawIO
+from neo.io.proxyobjects import SpikeTrainProxy
+
 from neo.core.spiketrain import (check_has_dimensions_time, SpikeTrain, _check_time_in_range,
                                  _new_spiketrain)
 from neo.core import Segment, Unit
 from neo.core.baseneo import MergeError
 from neo.test.tools import (assert_arrays_equal, assert_arrays_almost_equal,
                             assert_neo_object_is_compliant,
                             assert_same_attributes, assert_same_annotations,
@@ -139,14 +138,20 @@
         d = np.arange(3) * pq.minute
         check_has_dimensions_time(a)
         self.assertRaises(ValueError, check_has_dimensions_time, b)
         self.assertRaises(ValueError, check_has_dimensions_time, c)
         check_has_dimensions_time(d)
         self.assertRaises(ValueError, check_has_dimensions_time, a, b, c, d)
 
+    # Regression test for #763
+    # This test ensures the function works for compound units
+    def test__check_has_dimensions_time_compound_unit(self):
+        a = np.arange(3) * pq.CompoundUnit("1/10*s")
+        check_has_dimensions_time(a)
+
 
 class Testcheck_time_in_range(unittest.TestCase):
     def test__check_time_in_range_empty_array(self):
         value = np.array([])
         t_start = 0 * pq.s
         t_stop = 10 * pq.s
         _check_time_in_range(value, t_start=t_start, t_stop=t_stop)
@@ -660,14 +665,18 @@
         self.assertRaises(ValueError, _new_spiketrain, SpikeTrain, np.arange(t_start, t_stop + 5),
                           units='ms', t_start=t_start, t_stop=t_stop)
 
     def test__create_with_len_times_different_size_than_waveform_shape1_ValueError(self):
         self.assertRaises(ValueError, SpikeTrain, times=np.arange(10), units='s', t_stop=4,
                           waveforms=np.ones((10, 6, 50)))
 
+    def test__create_with_invalid_times_dimension(self):
+        data2d = np.array([1, 2, 3, 4]).reshape((4, -1))
+        self.assertRaises(ValueError, SpikeTrain, times=data2d * pq.s, t_stop=10 * pq.s)
+
     def test_defaults(self):
         # default recommended attributes
         train1 = SpikeTrain([3, 4, 5], units='sec', t_stop=10.0)
         train2 = _new_spiketrain(SpikeTrain, [3, 4, 5], units='sec', t_stop=10.0)
         assert_neo_object_is_compliant(train1)
         assert_neo_object_is_compliant(train2)
         self.assertEqual(train1.dtype, np.float)
@@ -1045,15 +1054,15 @@
         # Array annotations should be updated according to time slice
         assert_arrays_equal(result.array_annotations['index'], np.array(self.arr_ann['index']))
         assert_arrays_equal(result.array_annotations['label'], np.array(self.arr_ann['label']))
         self.assertIsInstance(result.array_annotations['index'], np.ndarray)
         self.assertIsInstance(result.array_annotations['label'], np.ndarray)
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
-    def test_time_slice_out_of_boundries(self):
+    def test_time_slice_out_of_boundaries(self):
         self.train1.t_start = 0.1 * pq.ms
         assert_neo_object_is_compliant(self.train1)
 
         # time_slice spike train, keep sliced spike times
         t_start = 0.01 * pq.ms
         t_stop = 70.0 * pq.ms
         result = self.train1.time_slice(t_start, t_stop)
@@ -1073,14 +1082,20 @@
         # Array annotations should be updated according to time slice
         assert_arrays_equal(result.array_annotations['index'], np.array(self.arr_ann['index']))
         assert_arrays_equal(result.array_annotations['label'], np.array(self.arr_ann['label']))
         self.assertIsInstance(result.array_annotations['index'], np.ndarray)
         self.assertIsInstance(result.array_annotations['label'], np.ndarray)
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
+    def test_time_slice_completely_out_of_boundaries(self):
+        # issue 831
+        t_start = 20.0 * pq.ms
+        t_stop = 70.0 * pq.ms
+        self.assertRaises(ValueError, self.train1.time_slice, t_start, t_stop)
+
     def test_time_slice_empty(self):
         waveforms = np.array([[[]]]) * pq.mV
         train = SpikeTrain([] * pq.ms, t_stop=10.0, waveforms=waveforms)
         assert_neo_object_is_compliant(train)
 
         # time_slice spike train, keep sliced spike times
         t_start = 0.01 * pq.ms
@@ -1281,34 +1296,109 @@
 
             self.assertTrue(len(w) == 1)
             self.assertEqual(w[0].category, UserWarning)
             self.assertSequenceEqual(str(w[0].message), "The following array annotations were "
                                                         "omitted, because they were only present"
                                                         " in one of the merged objects: "
                                                         "['label'] from the one that was merged "
-                                                        "into and ['label2'] from the one that "
-                                                        "was merged into the other")
+                                                        "into and ['label2'] from the ones that "
+                                                        "were merged into it.")
 
         assert_neo_object_is_compliant(result)
 
         # Make sure array annotations are merged correctly
         self.assertTrue('label' not in result.array_annotations)
         self.assertTrue('label2' not in result.array_annotations)
         assert_arrays_equal(result.array_annotations['index'],
                             np.array([1, 101, 2, 102, 3, 103, 4, 104, 5, 105, 6, 106]))
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
+    def test_merge_multiple(self):
+        self.train1.waveforms = None
+
+        train3 = self.train1.duplicate_with_new_data(self.train1.times.magnitude * pq.microsecond)
+        train3.segment = self.train1.segment
+        train3.array_annotate(index=np.arange(301, 307))
+
+        train4 = self.train1.duplicate_with_new_data(self.train1.times / 2)
+        train4.segment = self.train1.segment
+        train4.array_annotate(index=np.arange(401, 407))
+
+        # Array annotations merge warning was already tested, can be ignored now
+        with warnings.catch_warnings(record=True) as w:
+            result = self.train1.merge(train3, train4)
+            self.assertEqual(len(w), 1)
+            self.assertTrue("array annotations" in str(w[0].message))
+
+        assert_neo_object_is_compliant(result)
+
+        self.assertEqual(len(result.shape), 1)
+        self.assertEqual(result.shape[0], sum(len(st)
+                                              for st in (self.train1, train3, train4)))
+
+        self.assertEqual(self.train1.sampling_rate, result.sampling_rate)
+
+        time_unit = result.units
+
+        expected = np.concatenate((self.train1.rescale(time_unit).times,
+                                   train3.rescale(time_unit).times,
+                                   train4.rescale(time_unit).times))
+        expected *= time_unit
+        sorting = np.argsort(expected)
+        expected = expected[sorting]
+        np.testing.assert_array_equal(result.times, expected)
+
+        # Make sure array annotations are merged correctly
+        self.assertTrue('label' not in result.array_annotations)
+        assert_arrays_equal(result.array_annotations['index'],
+                            np.concatenate([st.array_annotations['index']
+                                            for st in (self.train1, train3, train4)])[sorting])
+        self.assertIsInstance(result.array_annotations, ArrayDict)
+
     def test_merge_with_waveforms(self):
         # Array annotations merge warning was already tested, can be ignored now
         with warnings.catch_warnings(record=True) as w:
             result = self.train1.merge(self.train2)
             self.assertEqual(len(w), 1)
             self.assertTrue("array annotations" in str(w[0].message))
         assert_neo_object_is_compliant(result)
 
+    def test_merge_multiple_with_waveforms(self):
+        train3 = self.train1.duplicate_with_new_data(self.train1.times.magnitude * pq.microsecond)
+        train3.segment = self.train1.segment
+        train3.array_annotate(index=np.arange(301, 307))
+        train3.waveforms = self.train1.waveforms / 10
+
+        train4 = self.train1.duplicate_with_new_data(self.train1.times / 2)
+        train4.segment = self.train1.segment
+        train4.array_annotate(index=np.arange(401, 407))
+        train4.waveforms = self.train1.waveforms / 2
+
+        # Array annotations merge warning was already tested, can be ignored now
+        with warnings.catch_warnings(record=True) as w:
+            result = self.train1.merge(train3, train4)
+            self.assertEqual(len(w), 1)
+            self.assertTrue("array annotations" in str(w[0].message))
+
+        assert_neo_object_is_compliant(result)
+        self.assertEqual(len(result.shape), 1)
+        self.assertEqual(result.shape[0], sum(len(st) for st in (self.train1, train3, train4)))
+
+        time_unit = result.units
+
+        expected = np.concatenate((self.train1.rescale(time_unit).times,
+                                   train3.rescale(time_unit).times,
+                                   train4.rescale(time_unit).times))
+        sorting = np.argsort(expected)
+
+        assert_arrays_equal(result.waveforms,
+                            np.vstack([st.waveforms.rescale(self.train1.waveforms.units)
+                                       for st in (self.train1, train3, train4)])[sorting]
+                            * self.train1.waveforms.units)
+
     def test_correct_shape(self):
         # Array annotations merge warning was already tested, can be ignored now
         with warnings.catch_warnings(record=True) as w:
             result = self.train1.merge(self.train2)
             self.assertEqual(len(w), 1)
             self.assertTrue("array annotations" in str(w[0].message))
         self.assertEqual(len(result.shape), 1)
@@ -1348,14 +1438,71 @@
         # Make sure array annotations are merged correctly
         self.assertTrue('label' not in result.array_annotations)
         self.assertTrue('label2' not in result.array_annotations)
         assert_arrays_equal(result.array_annotations['index'],
                             np.array([1, 2, 3, 4, 5, 6, 101, 102, 103, 104, 105, 106]))
         self.assertIsInstance(result.array_annotations, ArrayDict)
 
+    def test_name_file_origin_description(self):
+        self.train1.waveforms = None
+        self.train2.waveforms = None
+        self.train1.name = 'name1'
+        self.train1.description = 'desc1'
+        self.train1.file_origin = 'file1'
+        self.train2.name = 'name2'
+        self.train2.description = 'desc2'
+        self.train2.file_origin = 'file2'
+
+        train3 = self.train1.duplicate_with_new_data(self.train1.times.magnitude * pq.microsecond)
+        train3.segment = self.train1.segment
+        train3.name = 'name3'
+        train3.description = 'desc3'
+        train3.file_origin = 'file3'
+
+        train4 = self.train1.duplicate_with_new_data(self.train1.times / 2)
+        train4.segment = self.train1.segment
+        train4.name = 'name3'
+        train4.description = 'desc3'
+        train4.file_origin = 'file3'
+
+        # merge two spiketrains with different attributes
+        merge1 = self.train1.merge(self.train2)
+
+        self.assertEqual(merge1.name, 'merge(name1; name2)')
+        self.assertEqual(merge1.description, 'merge(desc1; desc2)')
+        self.assertEqual(merge1.file_origin, 'merge(file1; file2)')
+
+        # merge a merged spiketrain with a regular one
+        merge2 = merge1.merge(train3)
+
+        self.assertEqual(merge2.name, 'merge(name1; name2; name3)')
+        self.assertEqual(merge2.description, 'merge(desc1; desc2; desc3)')
+        self.assertEqual(merge2.file_origin, 'merge(file1; file2; file3)')
+
+        # merge two merged spiketrains
+        merge3 = merge1.merge(merge2)
+
+        self.assertEqual(merge3.name, 'merge(name1; name2; name3)')
+        self.assertEqual(merge3.description, 'merge(desc1; desc2; desc3)')
+        self.assertEqual(merge3.file_origin, 'merge(file1; file2; file3)')
+
+        # merge two spiketrains with identical attributes
+        merge4 = train3.merge(train4)
+
+        self.assertEqual(merge4.name, 'name3')
+        self.assertEqual(merge4.description, 'desc3')
+        self.assertEqual(merge4.file_origin, 'file3')
+
+        # merge a reqular spiketrain with a merged spiketrain
+        merge5 = train3.merge(merge1)
+
+        self.assertEqual(merge5.name, 'merge(name3; name1; name2)')
+        self.assertEqual(merge5.description, 'merge(desc3; desc1; desc2)')
+        self.assertEqual(merge5.file_origin, 'merge(file3; file1; file2)')
+
     def test_sampling_rate(self):
         # Array annotations merge warning was already tested, can be ignored now
         with warnings.catch_warnings(record=True) as w:
             result = self.train1.merge(self.train2)
             self.assertEqual(len(w), 1)
             self.assertTrue("array annotations" in str(w[0].message))
         self.assertEqual(result.sampling_rate, self.train1.sampling_rate)
@@ -1380,14 +1527,64 @@
         train3 = self.train1.duplicate_with_new_data(self.train1, t_start=-1 * pq.s)
         train3.segment = self.train1.segment
         with self.assertRaises(MergeError):
             train3.merge(self.train2)
         with self.assertRaises(MergeError):
             self.train2.merge(train3)
 
+    def test_merge_multiple_raise_merge_errors(self):
+        # different t_start
+        train3 = self.train1.duplicate_with_new_data(self.train1, t_start=-1 * pq.s)
+        train3.segment = self.train1.segment
+        with self.assertRaises(MergeError):
+            train3.merge(self.train2, self.train1)
+        with self.assertRaises(MergeError):
+            self.train2.merge(train3, self.train1)
+
+        # different t_stop
+        train3 = self.train1.duplicate_with_new_data(self.train1, t_stop=133 * pq.s)
+        train3.segment = self.train1.segment
+        with self.assertRaises(MergeError):
+            train3.merge(self.train2, self.train1)
+        with self.assertRaises(MergeError):
+            self.train2.merge(train3, self.train1)
+
+        # different segment
+        train3 = self.train1.duplicate_with_new_data(self.train1)
+        seg = Segment()
+        train3.segment = seg
+        with self.assertRaises(MergeError):
+            train3.merge(self.train2, self.train1)
+        with self.assertRaises(MergeError):
+            self.train2.merge(train3, self.train1)
+
+        # missing waveforms
+        train3 = self.train1.duplicate_with_new_data(self.train1)
+        train3.waveforms = None
+        with self.assertRaises(MergeError):
+            train3.merge(self.train2, self.train1)
+        with self.assertRaises(MergeError):
+            self.train2.merge(train3, self.train1)
+
+        # different sampling rate
+        train3 = self.train1.duplicate_with_new_data(self.train1)
+        train3.sampling_rate = 1 * pq.s
+        with self.assertRaises(MergeError):
+            train3.merge(self.train2, self.train1)
+        with self.assertRaises(MergeError):
+            self.train2.merge(train3, self.train1)
+
+        # different left sweep
+        train3 = self.train1.duplicate_with_new_data(self.train1)
+        train3.left_sweep = 1 * pq.s
+        with self.assertRaises(MergeError):
+            train3.merge(self.train2, self.train1)
+        with self.assertRaises(MergeError):
+            self.train2.merge(train3, self.train1)
+
 
 class TestDuplicateWithNewData(unittest.TestCase):
     def setUp(self):
         self.waveforms = np.array(
             [[[0., 1.], [0.1, 1.1]], [[2., 3.], [2.1, 3.1]], [[4., 5.], [4.1, 5.1]],
              [[6., 7.], [6.1, 7.1]], [[8., 9.], [8.1, 9.1]], [[10., 11.], [10.1, 11.1]]]) * pq.mV
         self.data = np.array([0.1, 0.5, 1.2, 3.3, 6.4, 7])
@@ -1617,17 +1814,14 @@
         assert_neo_object_is_compliant(train)
         assert_arrays_equal(train, np.array([7, 8, 9]))
 
     def test__changing_multiple_spiketimes_should_check_time_in_range(self):
         data = [3, 4, 5] * pq.ms
         train = SpikeTrain(data, copy=False, t_start=0.5, t_stop=10.0)
         assert_neo_object_is_compliant(train)
-        if sys.version_info[0] == 2:
-            self.assertRaises(ValueError, train.__setslice__, 0, 3, [3, 4, 11] * pq.ms)
-            self.assertRaises(ValueError, train.__setslice__, 0, 3, [0, 4, 5] * pq.ms)
 
     def test__adding_time_scalar(self):
         data = [3, 4, 5] * pq.ms
         train = SpikeTrain(data, copy=False, t_start=0.5, t_stop=10.0)
         assert_neo_object_is_compliant(train)
         # t_start and t_stop are also changed
         self.assertEqual((train + 10 * pq.ms).t_start, 10.5 * pq.ms)
```

### Comparing `neo-0.8.0/neo/test/coretest/test_unit.py` & `neo-0.9.0/neo/test/coretest/test_unit.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.core.unit.Unit class
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import unittest
 from copy import deepcopy
 
 import numpy as np
 
 try:
     from IPython.lib.pretty import pretty
```

### Comparing `neo-0.8.0/neo/test/coretest/tmp.py` & `neo-0.9.0/neo/test/coretest/tmp.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/neo/test/generate_datasets.py` & `neo-0.9.0/neo/test/generate_datasets.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 '''
 Generate datasets for testing
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 from datetime import datetime
 
 import numpy as np
 from numpy.random import rand
 import quantities as pq
 
 from neo.core import (AnalogSignal, Block, Epoch, Event, IrregularlySampledSignal, ChannelIndex,
@@ -90,15 +86,15 @@
             seg.spiketrains.append(sptr)
 
     if Event in supported_objects:
         for name, labels in event_types.items():
             evt_size = rand() * np.diff(event_size_range)
             evt_size += event_size_range[0]
             evt_size = int(evt_size)
-            labels = np.array(labels, dtype='S')
+            labels = np.array(labels, dtype='U')
             labels = labels[(rand(evt_size) * len(labels)).astype('i')]
             evt = Event(times=rand(evt_size) * duration, labels=labels)
             # Randomly generate array_annotations from given options
             arr_ann = {key: value[(rand(evt_size) * len(value)).astype('i')] for (key, value) in
                        array_annotations.items()}
             evt.array_annotate(**arr_ann)
             seg.events.append(evt)
@@ -110,15 +106,15 @@
             durations = []
             while t < duration:
                 times.append(t)
                 dur = rand() * (epoch_duration_range[1] - epoch_duration_range[0])
                 dur += epoch_duration_range[0]
                 durations.append(dur)
                 t = t + dur
-            labels = np.array(labels, dtype='S')
+            labels = np.array(labels, dtype='U')
             labels = labels[(rand(len(times)) * len(labels)).astype('i')]
             assert len(times) == len(durations)
             assert len(times) == len(labels)
             epc = Epoch(times=pq.Quantity(times, units=pq.s),
                         durations=pq.Quantity(durations, units=pq.s),
                         labels=labels,)
             assert epc.times.dtype == 'float'
@@ -206,18 +202,22 @@
 
     if name == 'sampling_rate':
         data = np.array(10000.0)
     elif name == 't_start':
         data = np.array(0.0)
     elif name == 't_stop':
         data = np.array(1.0)
-    elif n and name == 'channel_indexes':
+    elif n and name in ['channel_indexes', 'channel_ids']:
         data = np.arange(n)
+    elif n and name == 'coordinates':
+        data = np.arange(0, 2*n).reshape((n, 2))
     elif n and name == 'channel_names':
         data = np.array(["ch%d" % i for i in range(n)])
+    elif n and name == 'index':  # ChannelIndex.index
+        data = np.random.randint(0, n, n)
     elif n and obj == 'AnalogSignal':
         if name == 'signal':
             size = []
             for _ in range(int(dim)):
                 size.append(np.random.randint(5) + 1)
             size[1] = n
             data = np.random.random(size) * 1000.
@@ -274,16 +274,15 @@
 
     If seed is not None, use the seed to set the random number generator.
     The seed is incremented by 1 for each successive object.
 
     If annotate is True (default), also add annotations to the values.
     """
 
-    if hasattr(cls,
-               'lower'):  # is this a test that cls is a string? better to use isinstance(cls,
+    if hasattr(cls, 'lower'):  # is this a test that cls is a string? better to use isinstance(cls,
         # basestring), no?
         cls = class_by_name[cls]
     # iseed is needed below for generation of array annotations
     iseed = None
     kwargs = {}  # assign attributes
     for i, attr in enumerate(cls._necessary_attrs + cls._recommended_attrs):
         if seed is not None:
@@ -395,14 +394,16 @@
 
     # this is used to signal other containers that they shouldn't duplicate
     # data
     if obj_type == 'Block':
         cascade = 'block'
     for i, childname in enumerate(getattr(obj, '_child_objects', [])):
         # we create a few of each class
+        if childname == 'Group':
+            continue  # avoid infinite recursion, since Groups can contain  Groups
         for j in range(n):
             if seed is not None:
                 iseed = 10 * seed + 100 * i + 1000 * j
             else:
                 iseed = None
             child = fake_neo(obj_type=childname, cascade=cascade, seed=iseed, n=n)
             child.annotate(i=i, j=j)
```

### Comparing `neo-0.8.0/neo/test/iotest/common_io_test.py` & `neo-0.9.0/neo/test/iotest/common_io_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 Common tests for IOs:
  * check presence of all necessary attr
  * check types
  * write/read consistency
 
 See BaseTestIO.
@@ -12,17 +11,14 @@
 
 To deposite new testing files,  please create a account at
 gin.g-node.org and upload files at NeuralEnsemble/ephy_testing_data
 data repo.
 
 '''
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 __test__ = False
 
 import os
 from copy import copy
 import unittest
 
 from neo.core import Block, Segment
@@ -45,15 +41,15 @@
 from neo.test.generate_datasets import generate_from_supported_objects
 
 
 # url_for_tests = "https://portal.g-node.org/neo/" #This is the old place
 url_for_tests = "https://web.gin.g-node.org/NeuralEnsemble/ephy_testing_data/raw/master/"
 
 
-class BaseTestIO(object):
+class BaseTestIO:
     '''
     This class make common tests for all IOs.
 
     Several startegies:
       * for IO able to read write : test_write_then_read
       * for IO able to read write with hash conservation (optional):
         test_read_then_write
@@ -121,15 +117,15 @@
             raise unittest.SkipTest("Requires download of data from the web")
 
         url = url_for_tests + self.shortname
         try:
             make_all_directories(self.files_to_download, self.local_test_dir)
             download_test_file(self.files_to_download,
                                self.local_test_dir, url)
-        except IOError as exc:
+        except OSError as exc:
             raise unittest.TestCase.failureException(exc)
 
     download_test_files_if_not_present.__test__ = False
 
     def cleanup_file(self, path):
         '''
         Remove test files or directories safely.
@@ -492,15 +488,15 @@
         ''' % self.ioclass.__name__
         for obj, path in self.iter_objects(lazy=False, return_path=True):
             try:
                 # Check compliance of the block
                 assert_neo_object_is_compliant(obj)
             # intercept exceptions and add more information
             except BaseException as exc:
-                exc.args += ('from %s' % os.path.basename(path))
+                exc.args += ('from %s' % os.path.basename(path), )
                 raise
 
     def test_readed_with_lazy_is_compliant(self):
         '''
         Reading %s files in `files_to_test` with `lazy` is compliant.
 
         Test the reader with lazy = True.
```

### Comparing `neo-0.8.0/neo/test/iotest/test_asciiimageio.py` & `neo-0.9.0/neo/test/iotest/test_asciiimageio.py`

 * *Files identical despite different names*

### Comparing `neo-0.8.0/neo/test/iotest/test_asciisignalio.py` & `neo-0.9.0/neo/test/iotest/test_asciisignalio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.asciisignalio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import os
 import unittest
 import json
 import csv
 import numpy as np
 import quantities as pq
 from numpy.testing import assert_array_almost_equal, assert_array_equal
```

### Comparing `neo-0.8.0/neo/test/iotest/test_axographio.py` & `neo-0.9.0/neo/test/iotest/test_nixio_fr.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,192 +1,141 @@
-# -*- coding: utf-8 -*-
 """
-Tests of neo.io.axographio
+Tests of neo.io.nixio_fr
 """
-
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
-from datetime import datetime
-import unittest
-
-from neo.io import AxographIO
-from neo.test.iotest.common_io_test import BaseTestIO
-
 import numpy as np
-from numpy.testing import assert_equal
+import unittest
+from quantities import s
+from neo.io.nixio_fr import NixIO as NixIOfr
 import quantities as pq
+from neo.io.nixio import NixIO
+from neo.test.iotest.common_io_test import BaseTestIO
+from neo.core import Block, Segment, AnalogSignal, SpikeTrain, Event
+from neo.test.iotest.tools import get_test_file_full_path
+try:
+    import nixio as nix
+
+    HAVE_NIX = True
+except ImportError:
+    HAVE_NIX = False
+import os
+
+
+@unittest.skipUnless(HAVE_NIX, "Requires NIX")
+class TestNixfr(BaseTestIO, unittest.TestCase, ):
+    ioclass = NixIOfr
+
+    files_to_test = ['nixio_fr.nix']
+
+    files_to_download = ['nixio_fr.nix']
+
+    def setUp(self):
+        super().setUp()
+        self.testfilename = self.get_filename_path('nixio_fr.nix')
+        self.reader_fr = NixIOfr(filename=self.testfilename)
+        self.reader_norm = NixIO(filename=self.testfilename, mode='ro')
+        self.blk = self.reader_fr.read_block(block_index=1, load_waveforms=True)
+        # read block with NixIOfr
+        self.blk1 = self.reader_norm.read_block(index=1)  # read same block with NixIO
+
+    def tearDown(self):
+        self.reader_fr.file.close()
+        self.reader_norm.close()
+
+    def test_check_same_neo_structure(self):
+        self.assertEqual(len(self.blk.segments), len(self.blk1.segments))
+        for seg1, seg2 in zip(self.blk.segments, self.blk1.segments):
+            self.assertEqual(len(seg1.analogsignals), len(seg2.analogsignals))
+            self.assertEqual(len(seg1.spiketrains), len(seg2.spiketrains))
+            self.assertEqual(len(seg1.events), len(seg2.events))
+            self.assertEqual(len(seg1.epochs), len(seg2.epochs))
+
+    def test_check_same_data_content(self):
+        for seg1, seg2 in zip(self.blk.segments, self.blk1.segments):
+            for asig1, asig2 in zip(seg1.analogsignals, seg2.analogsignals):
+                np.testing.assert_almost_equal(asig1.magnitude, asig2.magnitude)
+                # not completely equal
+            for st1, st2 in zip(seg1.spiketrains, seg2.spiketrains):
+                np.testing.assert_array_equal(st1.magnitude, st2.times)
+                for wf1, wf2 in zip(st1.waveforms, st2.waveforms):
+                    np.testing.assert_array_equal(wf1.shape, wf2.shape)
+                    np.testing.assert_almost_equal(wf1.magnitude, wf2.magnitude)
+            for ev1, ev2 in zip(seg1.events, seg2.events):
+                np.testing.assert_almost_equal(ev1.times, ev2.times)
+                assert np.all(ev1.labels == ev2.labels)
+            for ep1, ep2 in zip(seg1.epochs, seg2.epochs):
+                assert len(ep1.durations) == len(ep2.times)
+                np.testing.assert_almost_equal(ep1.times, ep2.times)
+                np.testing.assert_array_equal(ep1.durations, ep2.durations)
+                np.testing.assert_array_equal(ep1.labels, ep2.labels)
+
+        # Not testing for channel_index as rawio always read from seg
+        for chid1, chid2 in zip(self.blk.channel_indexes, self.blk1.channel_indexes):
+            for asig1, asig2 in zip(chid1.analogsignals, chid2.analogsignals):
+                np.testing.assert_almost_equal(asig1.magnitude, asig2.magnitude)
+
+    def test_analog_signal(self):
+        seg1 = self.blk.segments[0]
+        an_sig1 = seg1.analogsignals[0]
+        assert len(an_sig1) == 30
+        an_sig2 = seg1.analogsignals[1]
+        assert an_sig2.shape == (50, 3)
+
+    def test_spike_train(self):
+        st1 = self.blk.segments[0].spiketrains[0]
+        assert np.all(st1.times == np.cumsum(np.arange(0, 1, 0.1)).tolist() * pq.s + 10 * pq.s)
+
+    def test_event(self):
+        seg1 = self.blk.segments[0]
+        event1 = seg1.events[0]
+        raw_time = 10 + np.cumsum(np.array([0, 1, 2, 3, 4]))
+        assert np.all(event1.times == np.array(raw_time * pq.s / 1000))
+        assert np.all(event1.labels == np.array(['A', 'B', 'C', 'D', 'E'], dtype='U'))
+        assert len(seg1.events) == 1
+
+    def test_epoch(self):
+        seg1 = self.blk.segments[1]
+        seg2 = self.blk1.segments[1]
+        epoch1 = seg1.epochs[0]
+        epoch2 = seg2.epochs[0]
+        assert len(epoch1.durations) == len(epoch1.times)
+        assert np.all(epoch1.durations == epoch2.durations)
+        assert np.all(epoch1.labels == epoch2.labels)
+
+    def test_annotations(self):
+        self.testfilename = self.get_filename_path('nixio_fr_ann.nix')
+        with NixIO(filename=self.testfilename, mode='ow') as io:
+            annotations = {'my_custom_annotation': 'hello block'}
+            bl = Block(**annotations)
+            annotations = {'something': 'hello hello000'}
+            seg = Segment(**annotations)
+            an =AnalogSignal([[1, 2, 3], [4, 5, 6]], units='V',
+                                        sampling_rate=1*pq.Hz)
+            an.annotations['ansigrandom'] = 'hello chars'
+            sp = SpikeTrain([3, 4, 5]* s, t_stop=10.0)
+            sp.annotations['railway'] = 'hello train'
+            ev = Event(np.arange(0, 30, 10)*pq.Hz,
+                       labels=np.array(['trig0', 'trig1', 'trig2'], dtype='S'))
+            ev.annotations['venue'] = 'hello event'
+            ev2 = Event(np.arange(0, 30, 10) * pq.Hz,
+                       labels=np.array(['trig0', 'trig1', 'trig2'], dtype='S'))
+            ev2.annotations['evven'] = 'hello ev'
+            seg.spiketrains.append(sp)
+            seg.events.append(ev)
+            seg.events.append(ev2)
+            seg.analogsignals.append(an)
+            bl.segments.append(seg)
+            io.write_block(bl)
+            io.close()
+        with NixIOfr(filename=self.testfilename) as frio:
+            frbl = frio.read_block()
+            assert 'my_custom_annotation' in frbl.annotations
+            assert 'something' in frbl.segments[0].annotations
+            # assert 'ansigrandom' in frbl.segments[0].analogsignals[0].annotations
+            assert 'railway' in frbl.segments[0].spiketrains[0].annotations
+            assert 'venue' in frbl.segments[0].events[0].annotations
+            assert 'evven' in frbl.segments[0].events[1].annotations
+        os.remove(self.testfilename)
 
 
-class TestAxographIO(BaseTestIO, unittest.TestCase):
-    files_to_test = [
-        'AxoGraph_Graph_File',      # version 1 file, provided with AxoGraph
-        'AxoGraph_Digitized_File',  # version 2 file, provided with AxoGraph
-        'AxoGraph_X_File.axgx',     # version 5 file, provided with AxoGraph
-        'File_axograph.axgd',       # version 6 file
-        'episodic.axgd',
-        'events_and_epochs.axgx',
-    ]
-    files_to_download = files_to_test
-    ioclass = AxographIO
-
-    def test_version_1(self):
-        """Test reading a version 1 AxoGraph file"""
-
-        filename = self.get_filename_path('AxoGraph_Graph_File')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-        assert_equal(blk.annotations['format_ver'], 1)
-
-        names = [sig.name for sig in blk.segments[0].analogsignals]
-        assert_equal(names, ['Current', 'Current'])
-
-        sig = blk.segments[0].analogsignals[0][:5]
-        arr = sig.as_array('pA')
-        target = np.array([[-5.5078130],
-                           [-3.1171880],
-                           [+1.6640626],
-                           [+1.6640626],
-                           [+4.0546880]], dtype=np.float32)
-        assert_equal(arr, target)
-
-        assert_equal(sig.t_start, 0.0005000000237487257 * pq.s)
-
-        assert_equal(sig.sampling_period, 0.0005000010132789612 * pq.s)
-
-    def test_version_2(self):
-        """Test reading a version 2 AxoGraph file"""
-
-        filename = self.get_filename_path('AxoGraph_Digitized_File')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-        assert_equal(blk.annotations['format_ver'], 2)
-
-        names = [sig.name for sig in blk.segments[0].analogsignals]
-        assert_equal(names, ['Current', 'Voltage', 'Column4', 'Column5',
-                             'Column6', 'Column7', 'Column8', 'Column9',
-                             'Column10', 'Column11', 'Column12', 'Column13',
-                             'Column14', 'Column15', 'Column16', 'Column17',
-                             'Column18', 'Column19', 'Column20', 'Column21',
-                             'Column22', 'Column23', 'Column24', 'Column25',
-                             'Column26', 'Column27', 'Column28', 'Column29'])
-
-        sig = blk.segments[0].analogsignals[0][:5]
-        arr = sig.as_array('pA')
-        target = np.array([[0.3125],
-                           [9.6875],
-                           [9.6875],
-                           [9.6875],
-                           [9.3750]], dtype=np.float32)
-        assert_equal(arr, target)
-
-        assert_equal(sig.t_start, 0.00009999999747378752 * pq.s)
-
-        assert_equal(sig.sampling_period, 0.00009999999747378750 * pq.s)
-
-    def test_version_5(self):
-        """Test reading a version 5 AxoGraph file"""
-
-        filename = self.get_filename_path('AxoGraph_X_File.axgx')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-        assert_equal(blk.annotations['format_ver'], 5)
-
-        names = [sig.name for sig in blk.segments[0].analogsignals]
-        assert_equal(names, ['Current', '', '', '', '', ''])
-
-        sig = blk.segments[0].analogsignals[0][:5]
-        arr = sig.as_array('pA')
-        target = np.array([[+3.0846775],
-                           [-2.5403225],
-                           [-1.2903225],
-                           [+6.8346770],
-                           [-5.0403230]], dtype=np.float32)
-        assert_equal(arr, target)
-
-        assert_equal(sig.t_start, 0.00005 * pq.s)
-
-        assert_equal(sig.sampling_period, 0.00005 * pq.s)
-
-    def test_version_6(self):
-        """Test reading a version 6 AxoGraph file"""
-
-        filename = self.get_filename_path('File_axograph.axgd')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-        assert_equal(blk.annotations['format_ver'], 6)
-
-        names = [sig.name for sig in blk.segments[0].analogsignals]
-        assert_equal(names, ['Membrane Voltage-1'])
-
-        sig = blk.segments[0].analogsignals[0][:5]
-        arr = sig.as_array('mV')
-        target = np.array([[-60.731834],
-                           [-60.701313],
-                           [-60.670795],
-                           [-60.701313],
-                           [-60.731834]], dtype=np.float32)
-        assert_equal(arr, target)
-
-        assert_equal(sig.t_start, 0.00002 * pq.s)
-
-        assert_equal(sig.sampling_period, 0.00002 * pq.s)
-
-    def test_multi_segment(self):
-        """Test reading an episodic file into multiple Segments"""
-
-        filename = self.get_filename_path('episodic.axgd')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-        assert_equal(len(blk.segments), 30)
-        assert_equal(len(blk.channel_indexes), 2)
-
-    def test_force_single_segment(self):
-        """Test reading an episodic file into one Segment"""
-
-        filename = self.get_filename_path('episodic.axgd')
-        reader = AxographIO(filename=filename, force_single_segment=True)
-        blk = reader.read_block()
-        assert_equal(len(blk.segments), 1)
-        assert_equal(len(blk.channel_indexes), 60)
-
-    def test_events_and_epochs(self):
-        """Test loading events and epochs"""
-
-        filename = self.get_filename_path('events_and_epochs.axgx')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-
-        event = blk.segments[0].events[0]
-        assert_equal(event.times, [5999, 5999, 23499, 23499,
-                                   26499, 26499, 35999]
-                     * blk.segments[0].analogsignals[0].sampling_period)
-        assert_equal(event.labels, [b'Stop', b'Start', b'Stop', b'Start',
-                                    b'Stop', b'Start', b'Stop'])
-
-        epoch = blk.segments[0].epochs[0]
-        assert_equal(epoch.times, np.array([0.1, 4]) * pq.s)
-        assert_equal(epoch.durations, np.array([1.4, 2]) * pq.s)
-        assert_equal(epoch.labels, [b'test interval 1', b'test interval 2'])
-
-    def test_rec_datetime(self):
-        """Test parsing the recording datetime from notes"""
-
-        # parsing of rec_datetime differs depending on acquisition mode
-
-        # file obtained in episodic acquisition mode has date and time on
-        # separate lines of notes
-        filename = self.get_filename_path('episodic.axgd')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-        assert_equal(blk.rec_datetime, datetime(2018, 6, 7, 15, 11, 36))
-
-        # file obtained in continuous acquisition mode has date and time in
-        # single line of notes
-        filename = self.get_filename_path('events_and_epochs.axgx')
-        reader = AxographIO(filename=filename)
-        blk = reader.read_block()
-        assert_equal(blk.rec_datetime, datetime(2019, 5, 25, 20, 16, 25))
-
 
-if __name__ == "__main__":
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `neo-0.8.0/neo/test/iotest/test_axonio.py` & `neo-0.9.0/neo/test/iotest/test_axonio.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,33 +1,28 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.axonio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
-import sys
-
 import unittest
 
 from neo.io import AxonIO
 from neo.test.iotest.common_io_test import BaseTestIO
 
 
 class TestAxonIO(BaseTestIO, unittest.TestCase):
-    files_to_test = ['File_axon_1.abf',
-                     'File_axon_2.abf',
-                     'File_axon_3.abf',
-                     'File_axon_4.abf',
-                     'File_axon_5.abf',
-                     'File_axon_6.abf',
-                     'File_axon_7.abf',
-
-                     ]
+    files_to_test = [
+        'File_axon_1.abf',
+        'File_axon_2.abf',
+        'File_axon_3.abf',
+        'File_axon_4.abf',
+        'File_axon_5.abf',
+        'File_axon_6.abf',
+        'File_axon_7.abf',
+        'test_file_edr3.abf',
+    ]
     files_to_download = files_to_test
     ioclass = AxonIO
 
     def test_annotations(self):
         reader = AxonIO(filename=self.get_filename_path('File_axon_2.abf'))
         bl = reader.read_block()
         ev = bl.segments[0].events[0]
```

### Comparing `neo-0.8.0/neo/test/iotest/test_baseio.py` & `neo-0.9.0/neo/test/iotest/test_baseio.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.baseio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import unittest
 
 from neo.core import objectlist
 from neo.io.baseio import BaseIO
 
 
 class TestIOObjects(unittest.TestCase):
```

### Comparing `neo-0.8.0/neo/test/iotest/test_blackrockio.py` & `neo-0.9.0/neo/test/iotest/test_blackrockio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.blackrockio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 import unittest
 import warnings
 
 from numpy.testing import assert_equal
 
 import numpy as np
 import quantities as pq
@@ -109,21 +105,20 @@
 
         # Same length of spike train?
         # Both should have read the complete data set!
         self.assertEqual(numspa, numspb)
 
         # test 4 Units
         block = reader.read_block(load_waveforms=True,
-                                signal_group_mode='split-all',
-                                units_group_mode='all-in-one')
+                                  signal_group_mode='split-all')
 
         self.assertEqual(len(block.segments[0].analogsignals), 10)
-        self.assertEqual(len(block.channel_indexes[-1].units), 4)
-        self.assertEqual(len(block.channel_indexes[-1].units),
-                         len(block.segments[0].spiketrains))
+        #self.assertEqual(len(block.channel_indexes[-1].units), 4)
+        #self.assertEqual(len(block.channel_indexes[-1].units),
+        #                 len(block.segments[0].spiketrains))
 
         anasig = block.segments[0].analogsignals[0]
         self.assertIsNotNone(anasig.file_origin)
 
     def test_inputs_V21(self):
         """
         Test various inputs to BlackrockIO.read_block with version 2.3 file
@@ -163,22 +158,21 @@
 
         # Same length of spike train?
         # Both should have read the complete data set!
         self.assertEqual(numspa, numspb)
 
         # test 4 Units
         block = reader.read_block(load_waveforms=True,
-                                signal_group_mode='split-all',
-                              units_group_mode='all-in-one')
+                                  signal_group_mode='split-all',
+                                  )#units_group_mode='all-in-one')
 
         self.assertEqual(len(block.segments[0].analogsignals), 96)
-        self.assertEqual(len(block.channel_indexes[-1].units), 218)
-        self.assertEqual(len(block.channel_indexes[-1].units),
-                         len(block.segments[0].spiketrains))
-
+        #self.assertEqual(len(block.channel_indexes[-1].units), 218)
+        #self.assertEqual(len(block.channel_indexes[-1].units),
+        #                 len(block.segments[0].spiketrains))
         anasig = block.segments[0].analogsignals[0]
         self.assertIsNotNone(anasig.file_origin)
 
     def test_load_muliple_nsx(self):
         """
         Test if multiple nsx signals can be loaded at the same time.
         """
@@ -261,34 +255,34 @@
 
             # Load data from original data files using the Neo BlackrockIO
             session = BlackrockIO(
                 dirname,
                 verbose=False, **param[1])
             block = session.read_block(load_waveforms=True, signal_group_mode='split-all')
             # Check if analog data are equal
-            self.assertGreater(len(block.channel_indexes), 0)
-            for i, chidx in enumerate(block.channel_indexes):
+            self.assertGreater(len(block.groups), 0)
+            for i, chidx_grp in enumerate(block.channel_indexes):
                 # Break for ChannelIndexes for Units that don't contain any Analogsignals
-                if len(chidx.analogsignals) == 0 and len(chidx.units) >= 1:
+                if len(chidx_grp.analogsignals) == 0 and len(chidx_grp.spiketrains) >= 1:
                     break
-                # Should only have one AnalogSignal per ChannelIndex
-                self.assertEqual(len(chidx.analogsignals), 1)
+                # Should only have one AnalogSignal per ChannelIndex-representing Group
+                self.assertEqual(len(chidx_grp.analogsignals), 1)
 
                 # Find out channel_id in order to compare correctly
-                idx = chidx.analogsignals[0].annotations['channel_id']
+                idx = chidx_grp.analogsignals[0].annotations['channel_id']
                 # Get data of AnalogSignal without pq.units
-                anasig = np.squeeze(chidx.analogsignals[0].base[:].magnitude)
+                anasig = np.squeeze(chidx_grp.analogsignals[0].base[:].magnitude)
                 # Test for equality of first nonzero values of AnalogSignal
                 #                                   and matlab file contents
                 # If not equal test if hardcoded gain is responsible for this
                 # See BlackrockRawIO ll. 1420 commit 77a645655605ae39eca2de3ee511f3b522f11bd7
                 j = 0
                 while anasig[j] == 0:
                     j += 1
-                if lfp_ml[i, j] != np.squeeze(chidx.analogsignals[0].base[j].magnitude):
+                if lfp_ml[i, j] != np.squeeze(chidx_grp.analogsignals[0].base[j].magnitude):
                     anasig = anasig / 152.592547
                     anasig = np.round(anasig).astype(int)
 
                 # Special case because id 142 is not included in ns2 file
                 if idx == 143:
                     idx -= 1
                 if idx > 128:
```

### Comparing `neo-0.8.0/neo/test/iotest/test_brainvisionio.py` & `neo-0.9.0/neo/test/rawiotest/test_brainvisionrawio.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,30 +1,26 @@
-# -*- coding: utf-8 -*-
-"""
-Tests of neo.io.brainvisionio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
+"""
 
 import unittest
 
-from neo.io import BrainVisionIO
+from neo.rawio.brainvisionrawio import BrainVisionRawIO
 
-from neo.test.iotest.common_io_test import BaseTestIO
+from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
 
 
-class TestBrainVisionIO(BaseTestIO, unittest.TestCase, ):
-    ioclass = BrainVisionIO
-    files_to_test = ['File_brainvision_1.vhdr',
-                     'File_brainvision_2.vhdr',
-                     'File_brainvision_3_float32.vhdr',
-                     'File_brainvision_3_int16.vhdr',
-                     'File_brainvision_3_int32.vhdr',
-                     ]
+class TestBrainVisionRawIO(BaseTestRawIO, unittest.TestCase, ):
+    rawioclass = BrainVisionRawIO
+    entities_to_test = ['File_brainvision_1.vhdr',
+                        'File_brainvision_2.vhdr',
+                        'File_brainvision_3_float32.vhdr',
+                        'File_brainvision_3_int16.vhdr',
+                        'File_brainvision_3_int32.vhdr',
+                        ]
     files_to_download = ['File_brainvision_1.eeg',
                          'File_brainvision_1.vhdr',
                          'File_brainvision_1.vmrk',
                          'File_brainvision_2.eeg',
                          'File_brainvision_2.vhdr',
                          'File_brainvision_2.vmrk',
                          'File_brainvision_3_float32.eeg',
```

### Comparing `neo-0.8.0/neo/test/iotest/test_brainwaredamio.py` & `neo-0.9.0/neo/test/iotest/test_brainwaredamio.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,33 +1,26 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.brainwaredamio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import os.path
-import sys
 
 import unittest
 
 import numpy as np
 import quantities as pq
 
 from neo.core import (AnalogSignal, Block,
-                      ChannelIndex, Segment)
+                      Group, Segment)
 from neo.io import BrainwareDamIO
 from neo.test.iotest.common_io_test import BaseTestIO
 from neo.test.tools import (assert_same_sub_schema,
                             assert_neo_object_is_compliant)
 from neo.test.iotest.tools import create_generic_reader
 
-PY_VER = sys.version_info[0]
-
 
 def proc_dam(filename):
     '''Load an dam file that has already been processed by the official matlab
     file converter.  That matlab data is saved to an m-file, which is then
     converted to a numpy '.npz' file.  This numpy file is the file actually
     loaded.  This function converts it to a neo block and returns the block.
     This block can be compared to the block produced by BrainwareDamIO to
@@ -51,20 +44,17 @@
 
     signals = [res.flatten() for res in damfile['signal']]
     stimIndexes = [int(res[0, 0].tolist()) for res in damfile['stimIndex']]
     timestamps = [res[0, 0] for res in damfile['timestamp']]
 
     block = Block(file_origin=filename)
 
-    chx = ChannelIndex(file_origin=filename,
-                       index=np.array([0]),
-                       channel_ids=np.array([1]),
-                       channel_names=np.array(['Chan1'], dtype='S'))
+    gr = Group(file_origin=filename)
 
-    block.channel_indexes.append(chx)
+    block.groups.append(gr)
 
     params = [res['params'][0, 0].flatten() for res in damfile['stim']]
     values = [res['values'][0, 0].flatten() for res in damfile['stim']]
     params = [[res1[0] for res1 in res] for res in params]
     values = [[res1 for res1 in res] for res in values]
     stims = [dict(zip(param, value)) for param, value in zip(params, values)]
 
@@ -75,14 +65,16 @@
                            file_origin=filename,
                            sampling_period=1. * pq.s)
         segment = Segment(file_origin=filename,
                           index=stimIndex,
                           **stim)
         segment.analogsignals = [sig]
         block.segments.append(segment)
+        gr.analogsignals.append(sig)
+        sig.group = gr
 
     block.create_many_to_one_relationship()
 
     return block
 
 
 class BrainwareDamIOTestCase(BaseTestIO, unittest.TestCase):
@@ -104,33 +96,33 @@
     files_to_compare = ['block_300ms_4rep_1clust_part_ch1',
                         'interleaved_500ms_5rep_ch2',
                         '',
                         'multi_500ms_mulitrep_ch1',
                         'random_500ms_12rep_noclust_part_ch2',
                         'sequence_500ms_5rep_ch2']
 
-    # add the appropriate suffix depending on the python version
+    # add the suffix
     for i, fname in enumerate(files_to_compare):
         if fname:
-            files_to_compare[i] += '_dam_py%s.npz' % PY_VER
+            files_to_compare[i] += '_dam_py3.npz'
 
     # Will fetch from g-node if they don't already exist locally
     # How does it know to do this before any of the other tests?
     files_to_download = files_to_test + files_to_compare
 
     def test_reading_same(self):
         for ioobj, path in self.iter_io_objects(return_path=True):
             obj_reader_base = create_generic_reader(ioobj, target=False)
             obj_reader_single = create_generic_reader(ioobj)
 
             obj_base = obj_reader_base()
             obj_single = obj_reader_single()
 
             try:
-                assert_same_sub_schema(obj_base, obj_single)
+                assert_same_sub_schema(obj_base, [obj_single])
             except BaseException as exc:
                 exc.args += ('from ' + os.path.basename(path),)
                 raise
 
     def test_against_reference(self):
         for filename, refname in zip(self.files_to_test,
                                      self.files_to_compare):
```

### Comparing `neo-0.8.0/neo/test/iotest/test_brainwaref32io.py` & `neo-0.9.0/neo/test/iotest/test_brainwaref32io.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,32 +1,25 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.brainwaref32io
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import os.path
-import sys
 
 import unittest
 
 import numpy as np
 import quantities as pq
 
-from neo.core import Block, ChannelIndex, Segment, SpikeTrain, Unit
+from neo.core import Block, Segment, SpikeTrain, Group
 from neo.io import BrainwareF32IO
 from neo.test.iotest.common_io_test import BaseTestIO
 from neo.test.tools import (assert_same_sub_schema,
                             assert_neo_object_is_compliant)
 from neo.test.iotest.tools import create_generic_reader
 
-PY_VER = sys.version_info[0]
-
 
 def proc_f32(filename):
     '''Load an f32 file that has already been processed by the official matlab
     file converter.  That matlab data is saved to an m-file, which is then
     converted to a numpy '.npz' file.  This numpy file is the file actually
     loaded.  This function converts it to a neo block and returns the block.
     This block can be compared to the block produced by BrainwareF32IO to
@@ -44,27 +37,21 @@
              f32 file name = 'file1.f32'
     '''
 
     filenameorig = os.path.basename(filename[:-12] + '.f32')
 
     # create the objects to store other objects
     block = Block(file_origin=filenameorig)
-    chx = ChannelIndex(file_origin=filenameorig,
-                       index=np.array([], dtype=np.int),
-                       channel_names=np.array([], dtype='S'))
-    unit = Unit(file_origin=filenameorig)
-
-    # load objects into their containers
-    block.channel_indexes.append(chx)
-    chx.units.append(unit)
+    gr = Group(file_origin=filenameorig)
+    block.groups.append(gr)
 
     try:
         with np.load(filename, allow_pickle=True) as f32obj:
             f32file = list(f32obj.items())[0][1].flatten()
-    except IOError as exc:
+    except OSError as exc:
         if 'as a pickle' in exc.message:
             block.create_many_to_one_relationship()
             return block
         else:
             raise
 
     sweeplengths = [res[0, 0].tolist() for res in f32file['sweeplength']]
@@ -84,15 +71,15 @@
             params = dict(zip(paramnames, stim))
             train = SpikeTrain(trainpts, units=pq.ms,
                                t_start=0, t_stop=sweeplength,
                                file_origin=filenameorig)
 
             segment = Segment(file_origin=filenameorig, **params)
             segment.spiketrains = [train]
-            unit.spiketrains.append(train)
+            gr.spiketrains.append(train)
             block.segments.append(segment)
 
     block.create_many_to_one_relationship()
 
     return block
 
 
@@ -109,16 +96,16 @@
                      'block_500ms_5rep_empty_partclust_ch1.f32',
                      'interleaved_500ms_5rep_ch2.f32',
                      'interleaved_500ms_5rep_nospikes_ch1.f32',
                      'multi_500ms_mulitrep_ch1.f32',
                      'random_500ms_12rep_noclust_part_ch2.f32',
                      'sequence_500ms_5rep_ch2.f32']
 
-    # add the appropriate suffix depending on the python version
-    suffix = '_f32_py%s.npz' % PY_VER
+    # add the appropriate suffix
+    suffix = '_f32_py3.npz'
     files_to_download = files_to_test[:]
 
     # add the reference files to the list of files to download
     files_to_compare = []
     for fname in files_to_test:
         if fname:
             files_to_compare.append(os.path.splitext(fname)[0] + suffix)
@@ -132,15 +119,15 @@
             obj_reader_base = create_generic_reader(ioobj, target=False)
             obj_reader_single = create_generic_reader(ioobj)
 
             obj_base = obj_reader_base()
             obj_single = obj_reader_single()
 
             try:
-                assert_same_sub_schema(obj_base, obj_single)
+                assert_same_sub_schema(obj_base, [obj_single])
             except BaseException as exc:
                 exc.args += ('from ' + os.path.basename(path),)
                 raise
 
     def test_against_reference(self):
         for obj, path in self.iter_objects(return_path=True):
             filename = os.path.basename(path)
```

### Comparing `neo-0.8.0/neo/test/iotest/test_brainwaresrcio.py` & `neo-0.9.0/neo/test/iotest/test_brainwaresrcio.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,34 +1,27 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.brainwaresrcio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division, print_function
-
 import logging
 import os.path
-import sys
 
 import unittest
 
 import numpy as np
 import quantities as pq
 
 from neo.core import (Block, Event,
-                      ChannelIndex, Segment, SpikeTrain, Unit)
+                      Group, Segment, SpikeTrain)
 from neo.io import BrainwareSrcIO, brainwaresrcio
 from neo.test.iotest.common_io_test import BaseTestIO
 from neo.test.tools import (assert_same_sub_schema,
                             assert_neo_object_is_compliant)
 from neo.test.iotest.tools import create_generic_reader
 
-PY_VER = sys.version_info[0]
-
 FILES_TO_TEST = ['block_300ms_4rep_1clust_part_ch1.src',
                  'block_500ms_5rep_empty_fullclust_ch1.src',
                  'block_500ms_5rep_empty_partclust_ch1.src',
                  'interleaved_500ms_5rep_ch2.src',
                  'interleaved_500ms_5rep_nospikes_ch1.src',
                  'interleaved_500ms_7rep_noclust_ch1.src',
                  'long_170s_1rep_1clust_ch2.src',
@@ -77,20 +70,16 @@
     NChannels = srcfile['NChannels'][0, 0][0, 0]
     side = str(srcfile['side'][0, 0][0])
     ADperiod = srcfile['ADperiod'][0, 0][0, 0]
 
     comm_seg = proc_src_comments(srcfile, filename)
     block.segments.append(comm_seg)
 
-    chx = proc_src_units(srcfile, filename)
-    chan_nums = np.arange(NChannels, dtype='int')
-    chan_names = ['Chan{}'.format(i) for i in range(NChannels)]
-    chx.index = chan_nums
-    chx.channel_names = np.array(chan_names, dtype='string_')
-    block.channel_indexes.append(chx)
+    all_units = proc_src_units(srcfile, filename)
+    block.groups.extend(all_units)
 
     for rep in srcfile['sets'][0, 0].flatten():
         proc_src_condition(rep, filename, ADperiod, side, block)
 
     block.create_many_to_one_relationship()
 
     return block
@@ -105,59 +94,56 @@
     senders = [res[0] for res in commentarray['sender'].flatten()]
     texts = [res[0] for res in commentarray['text'].flatten()]
     timeStamps = [res[0, 0] for res in commentarray['timeStamp'].flatten()]
 
     timeStamps = np.array(timeStamps, dtype=np.float32)
     t_start = timeStamps.min()
     timeStamps = pq.Quantity(timeStamps - t_start, units=pq.d).rescale(pq.s)
-    texts = np.array(texts, dtype='S')
+    texts = np.array(texts, dtype='U')
     senders = np.array(senders, dtype='S')
     t_start = brainwaresrcio.convert_brainwaresrc_timestamp(t_start.tolist())
 
     comments = Event(times=timeStamps, labels=texts, senders=senders)
     comm_seg.events = [comments]
     comm_seg.rec_datetime = t_start
 
     return comm_seg
 
 
 def proc_src_units(srcfile, filename):
     '''Get the units in an src file that has been processed by the official
     matlab function.  See proc_src for details'''
-    chx = ChannelIndex(file_origin=filename,
-                       index=np.array([], dtype=int))
-    un_unit = Unit(name='UnassignedSpikes', file_origin=filename,
+    all_units = []
+    un_unit = Group(name='UnassignedSpikes', file_origin=filename,
                    elliptic=[], boundaries=[], timestamp=[], max_valid=[])
 
-    chx.units.append(un_unit)
+    all_units.append(un_unit)
 
     sortInfo = srcfile['sortInfo'][0, 0]
     timeslice = sortInfo['timeslice'][0, 0]
     maxValid = timeslice['maxValid'][0, 0]
     cluster = timeslice['cluster'][0, 0]
     if len(cluster):
         maxValid = maxValid[0, 0]
         elliptic = [res.flatten() for res in cluster['elliptic'].flatten()]
         boundaries = [res.flatten() for res in cluster['boundaries'].flatten()]
         fullclust = zip(elliptic, boundaries)
         for ielliptic, iboundaries in fullclust:
-            unit = Unit(file_origin=filename,
+            unit = Group(file_origin=filename,
                         boundaries=[iboundaries],
                         elliptic=[ielliptic], timeStamp=[],
                         max_valid=[maxValid])
-            chx.units.append(unit)
-    return chx
+            all_units.append(unit)
+    return all_units
 
 
 def proc_src_condition(rep, filename, ADperiod, side, block):
     '''Get the condition in a src file that has been processed by the official
     matlab function.  See proc_src for details'''
 
-    chx = block.channel_indexes[0]
-
     stim = rep['stim'].flatten()
     params = [str(res[0]) for res in stim['paramName'][0].flatten()]
     values = [res for res in stim['paramVal'][0].flatten()]
     stim = dict(zip(params, values))
     sweepLen = rep['sweepLen'][0, 0]
 
     if not len(rep):
@@ -168,15 +154,15 @@
         damaIndexes = [res[0, 0] for res in unassignedSpikes['damaIndex']]
         timeStamps = [res[0, 0] for res in unassignedSpikes['timeStamp']]
         spikeunit = [res.flatten() for res in unassignedSpikes['spikes']]
         respWin = np.array([], dtype=np.int32)
         trains = proc_src_condition_unit(spikeunit, sweepLen, side, ADperiod,
                                          respWin, damaIndexes, timeStamps,
                                          filename)
-        chx.units[0].spiketrains.extend(trains)
+        block.groups[0].spiketrains.extend(trains)
         atrains = [trains]
     else:
         damaIndexes = []
         timeStamps = []
         atrains = []
 
     clusters = rep['clusters'].flatten()
@@ -194,18 +180,18 @@
             spikeunits.append(spikes)
     else:
         IdStrings = []
         sweepLens = []
         respWins = []
         spikeunits = []
 
-    for unit, IdString in zip(chx.units[1:], IdStrings):
+    for unit, IdString in zip(block.groups[1:], IdStrings):
         unit.name = str(IdString)
 
-    fullunit = zip(spikeunits, chx.units[1:], sweepLens, respWins)
+    fullunit = zip(spikeunits, block.groups[1:], sweepLens, respWins)
     for spikeunit, unit, sweepLen, respWin in fullunit:
         trains = proc_src_condition_unit(spikeunit, sweepLen, side, ADperiod,
                                          respWin, damaIndexes, timeStamps,
                                          filename)
         atrains.append(trains)
         unit.spiketrains.extend(trains)
 
@@ -279,25 +265,25 @@
 
     # These are the files it tries to read and test for compliance
     files_to_test = FILES_TO_TEST
 
     # these are reference files to compare to
     files_to_compare = FILES_TO_COMPARE
 
-    # add the appropriate suffix depending on the python version
+    # add the suffix
     for i, fname in enumerate(files_to_compare):
         if fname:
-            files_to_compare[i] += '_src_py%s.npz' % PY_VER
+            files_to_compare[i] += '_src_py3.npz'
 
     # Will fetch from g-node if they don't already exist locally
     # How does it know to do this before any of the other tests?
     files_to_download = files_to_test + files_to_compare
 
     def setUp(self):
-        super(BrainwareSrcIOTestCase, self).setUp()
+        super().setUp()
 
     def test_reading_same(self):
         for ioobj, path in self.iter_io_objects(return_path=True):
             obj_reader_all = create_generic_reader(ioobj, readall=True)
             obj_reader_base = create_generic_reader(ioobj, target=False)
             obj_reader_next = create_generic_reader(ioobj, target='next_block')
             obj_reader_single = create_generic_reader(ioobj)
@@ -306,15 +292,15 @@
             obj_base = obj_reader_base()
             obj_single = obj_reader_single()
             obj_next = [obj_reader_next()]
             while ioobj._isopen:
                 obj_next.append(obj_reader_next())
 
             try:
-                assert_same_sub_schema(obj_all[0], obj_base)
+                assert_same_sub_schema(obj_all, obj_base)
                 assert_same_sub_schema(obj_all[0], obj_single)
                 assert_same_sub_schema(obj_all, obj_next)
             except BaseException as exc:
                 exc.args += ('from ' + os.path.basename(path),)
                 raise
 
             self.assertEqual(len(obj_all), len(obj_next))
@@ -325,15 +311,15 @@
             if not refname:
                 continue
             obj = self.read_file(filename=filename, readall=True)[0]
             refobj = proc_src(self.get_filename_path(refname))
             try:
                 assert_neo_object_is_compliant(obj)
                 assert_neo_object_is_compliant(refobj)
-                assert_same_sub_schema(obj, refobj)
+                #assert_same_sub_schema(obj, refobj)  # commented out until IO is adapted to use Group
             except BaseException as exc:
                 exc.args += ('from ' + filename,)
                 raise
 
 
 if __name__ == '__main__':
     logger = logging.getLogger(BrainwareSrcIO.__module__ +
```

### Comparing `neo-0.8.0/neo/test/iotest/test_elanio.py` & `neo-0.9.0/neo/test/iotest/test_igorio.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,27 +1,26 @@
-# -*- coding: utf-8 -*-
 """
-Tests of neo.io.elanio
+Tests of neo.io.igorproio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
-import sys
-
 import unittest
 
-from neo.io import ElanIO
+try:
+    import igor
+
+    HAVE_IGOR = True
+except ImportError:
+    HAVE_IGOR = False
+from neo.io.igorproio import IgorIO
 from neo.test.iotest.common_io_test import BaseTestIO
 
 
-class TestElanIO(BaseTestIO, unittest.TestCase, ):
-    ioclass = ElanIO
-    files_to_test = ['File_elan_1.eeg']
-    files_to_download = ['File_elan_1.eeg',
-                         'File_elan_1.eeg.ent',
-                         'File_elan_1.eeg.pos',
-                         ]
+@unittest.skipUnless(HAVE_IGOR, "requires igor")
+class TestIgorIO(BaseTestIO, unittest.TestCase):
+    ioclass = IgorIO
+    files_to_test = ['mac-version2.ibw',
+                     'win-version2.ibw']
+    files_to_download = files_to_test
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `neo-0.8.0/neo/test/iotest/test_elphyio.py` & `neo-0.9.0/neo/test/iotest/test_stimfitio.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,33 +1,33 @@
 # -*- coding: utf-8 -*-
 """
-Tests of neo.io.elphyio
+Tests of neo.io.stimfitio
 """
 
 # needed for python 3 compatibility
-from __future__ import division
+from __future__ import absolute_import
 
 import sys
 
 import unittest
 
-try:
-    from neo.io.elphyio import ElphyIO
-except ImportError:
-    ElphyIO = None
+from neo.io import StimfitIO
+from neo.io.stimfitio import HAS_STFIO
 from neo.test.iotest.common_io_test import BaseTestIO
 
 
-# @unittest.skipIf(sys.version_info[0] > 2, "not Python 3 compatible")
-# @unittest.skip("ElphyIO not yet updated to the new API")
-class TestElphyIO(BaseTestIO, unittest.TestCase):
-    ioclass = ElphyIO
-    files_to_test = ['ElphyExample.DAT',
-                     'ElphyExample_Mode1.dat',
-                     'ElphyExample_Mode2.dat',
-                     'ElphyExample_Mode3.dat',
+@unittest.skipIf(sys.version_info[0] > 2, "not Python 3 compatible")
+@unittest.skipUnless(HAS_STFIO, "requires stfio")
+class TestStimfitIO(BaseTestIO, unittest.TestCase):
+    files_to_test = ['File_stimfit_1.h5',
+                     'File_stimfit_2.h5',
+                     'File_stimfit_3.h5',
+                     'File_stimfit_4.h5',
+                     'File_stimfit_5.h5',
+                     'File_stimfit_6.h5',
                      ]
     files_to_download = files_to_test
+    ioclass = StimfitIO
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `neo-0.8.0/neo/test/iotest/test_exampleio.py` & `neo-0.9.0/neo/test/iotest/test_exampleio.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.exampleio
 """
 
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 import unittest
 
 from neo.io.exampleio import ExampleIO  # , HAVE_SCIPY
 from neo.test.iotest.common_io_test import BaseTestIO
 from neo.io.proxyobjects import (AnalogSignalProxy,
                 SpikeTrainProxy, EventProxy, EpochProxy)
 from neo import (AnalogSignal, SpikeTrain)
@@ -61,16 +57,16 @@
             assert ev.name is not None
         for ep in seg.epochs:
             assert ep.name is not None
 
     def test_read_block(self):
         r = ExampleIO(filename=None)
         bl = r.read_block(lazy=True)
-        assert len(bl.list_units) == 3
-        assert len(bl.channel_indexes) == 1 + 3  # signals grouped + units
+        #assert len(bl.list_units) == 3
+        #assert len(bl.channel_indexes) == 1 + 1  # signals grouped + units grouped
 
     def test_read_segment_with_time_slice(self):
         r = ExampleIO(filename=None)
         seg = r.read_segment(time_slice=None)
         shape_full = seg.analogsignals[0].shape
         spikes_full = seg.spiketrains[0]
         event_full = seg.events[0]
```

### Comparing `neo-0.8.0/neo/test/iotest/test_hdf5io.py` & `neo-0.9.0/neo/test/iotest/test_hdf5io.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.hdf5io_new
 
 """
 
 import unittest
+import sys
 import numpy as np
 from numpy.testing import assert_array_equal
 from quantities import kHz, mV, ms, second, nA
 
 try:
     import h5py
 
@@ -62,23 +62,25 @@
             self.assertEqual(st.t_stop, 1000 * ms)
             self.assertEqual(st.t_start, 0 * ms)
             self.assertEqual(st.segment, segment)
 
             self.assertEqual(len(segment.events), 1)
             ev = segment.events[0]
             assert_array_equal(ev.labels,
-                               np.array(['trig0', 'trig1', 'trig2'], dtype='|S5'))
+                               np.array(['trig0', 'trig1', 'trig2'],
+                                        dtype=(sys.byteorder == 'little' and '<' or '>') + 'U5'))
             self.assertEqual(ev.units, second)
             assert_array_equal(ev.magnitude, np.arange(0, 30, 10))
             self.assertEqual(ev.segment, segment)
 
             self.assertEqual(len(segment.epochs), 1)
             ep = segment.epochs[0]
             assert_array_equal(ep.labels,
-                               np.array(['btn0', 'btn1', 'btn2'], dtype='|S4'))
+                               np.array(['btn0', 'btn1', 'btn2'],
+                                        dtype=(sys.byteorder == 'little' and '<' or '>') + 'U4'))
             assert_array_equal(ep.durations.magnitude,
                                np.array([10, 5, 7]))
             self.assertEqual(ep.units, second)
             assert_array_equal(ep.magnitude, np.arange(0, 30, 10))
             self.assertEqual(ep.segment, segment)
 
             self.assertEqual(len(segment.irregularlysampledsignals), 2)
```

### Comparing `neo-0.8.0/neo/test/iotest/test_klustakwikio.py` & `neo-0.9.0/neo/test/iotest/test_klustakwikio.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.klustakwikio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 import glob
 import os.path
 import sys
 import tempfile
 
 import unittest
```

### Comparing `neo-0.8.0/neo/test/iotest/test_neomatlabio.py` & `neo-0.9.0/neo/test/iotest/test_neomatlabio.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.neomatlabio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import unittest
 
 import quantities as pq
 from neo import Block, Segment, SpikeTrain
 from neo.test.iotest.common_io_test import BaseTestIO
 from neo.io.neomatlabio import NeoMatlabIO, HAVE_SCIPY
 
@@ -19,26 +15,32 @@
     ioclass = NeoMatlabIO
     files_to_test = []
     files_to_download = []
 
     def test_write_read_single_spike(self):
         block1 = Block()
         seg = Segment('segment1')
-        spiketrain = SpikeTrain([1] * pq.s, t_stop=10 * pq.s, sampling_rate=1 * pq.Hz)
+        spiketrain1 = SpikeTrain([1] * pq.s, t_stop=10 * pq.s, sampling_rate=1 * pq.Hz)
+        spiketrain1.annotate(yep='yop')
         block1.segments.append(seg)
-        seg.spiketrains.append(spiketrain)
+        seg.spiketrains.append(spiketrain1)
 
         # write block
         filename = BaseTestIO.get_filename_path(self, 'matlabiotestfile.mat')
         io1 = self.ioclass(filename)
         io1.write_block(block1)
 
         # read block
         io2 = self.ioclass(filename)
         block2 = io2.read_block()
 
         self.assertEqual(block1.segments[0].spiketrains[0],
                          block2.segments[0].spiketrains[0])
 
+        # test annotations
+        spiketrain2 = block2.segments[0].spiketrains[0]
+        assert 'yep' in spiketrain2.annotations
+        assert spiketrain2.annotations['yep'] == 'yop'
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `neo-0.8.0/neo/test/iotest/test_nestio.py` & `neo-0.9.0/neo/test/iotest/test_nestio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.exampleio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
 import warnings
 
 import unittest
 
 import quantities as pq
 import numpy as np
```

### Comparing `neo-0.8.0/neo/test/iotest/test_neuralynxio.py` & `neo-0.9.0/neo/test/iotest/test_neuralynxio.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
-Tests of neo.io.blackrockio
+Tests of neo.io.neuralynxio.py
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 import time
 import warnings
 
 import unittest
 
 import numpy as np
 import quantities as pq
@@ -22,20 +18,22 @@
 from neo.io.neuralynxio_v1 import NeuralynxIO as OldNeuralynxIO
 from neo import AnalogSignal
 
 
 class CommonNeuralynxIOTest(BaseTestIO, unittest.TestCase, ):
     ioclass = NeuralynxIO
     files_to_test = [
+        # 'Cheetah_v4.0.2/original_data',
         'Cheetah_v5.5.1/original_data',
         'Cheetah_v5.6.3/original_data',
         'Cheetah_v5.7.4/original_data',
         'Pegasus_v2.1.1',
         'Cheetah_v6.3.2/incomplete_blocks']
     files_to_download = [
+        'Cheetah_v4.0.2/original_data/CSC14_trunc.Ncs',
         'Cheetah_v5.5.1/original_data/CheetahLogFile.txt',
         'Cheetah_v5.5.1/original_data/CheetahLostADRecords.txt',
         'Cheetah_v5.5.1/original_data/Events.nev',
         'Cheetah_v5.5.1/original_data/STet3a.nse',
         'Cheetah_v5.5.1/original_data/STet3b.nse',
         'Cheetah_v5.5.1/original_data/Tet3a.ncs',
         'Cheetah_v5.5.1/original_data/Tet3b.ncs',
@@ -102,21 +100,21 @@
         block = nio.read_block(load_waveforms=True)
         self.assertEqual(len(block.segments[0].analogsignals), 1)
         self.assertEqual(len(block.segments[0].spiketrains), 2)
         self.assertEqual(block.segments[0].spiketrains[0].waveforms.shape[0],
                          block.segments[0].spiketrains[0].shape[0])
         self.assertGreater(len(block.segments[0].events), 0)
 
-        self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), 2)  # 2 segment
+        # self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), 2)  # 2 segment
 
-        block = nio.read_block(load_waveforms=True, units_group_mode='all-in-one')
-        self.assertEqual(len(block.channel_indexes[-1].units), 2)  # 2 units
+        # block = nio.read_block(load_waveforms=True, units_group_mode='all-in-one')
+        # self.assertEqual(len(block.channel_indexes[-1].units), 2)  # 2 units
 
-        block = nio.read_block(load_waveforms=True, units_group_mode='split-all')
-        self.assertEqual(len(block.channel_indexes[-1].units), 1)  # 1 units by ChannelIndex
+        # block = nio.read_block(load_waveforms=True, units_group_mode='split-all')
+        # self.assertEqual(len(block.channel_indexes[-1].units), 1)  # 1 units by ChannelIndex
 
     def test_read_segment(self):
         dirname = self.get_filename_path('Cheetah_v5.5.1/original_data')
         nio = NeuralynxIO(dirname=dirname, use_cache=False)
 
         # read first segment entirely
         seg = nio.read_segment(seg_index=0, time_slice=None)
@@ -159,21 +157,21 @@
         self.assertEqual(block.segments[0].spiketrains[0].waveforms.shape[0],
                          block.segments[0].spiketrains[0].shape[0])
         # this is tetrode data, containing 32 samples per waveform
         self.assertEqual(block.segments[0].spiketrains[0].waveforms.shape[1], 4)
         self.assertEqual(block.segments[0].spiketrains[0].waveforms.shape[-1], 32)
         self.assertGreater(len(block.segments[0].events), 0)
 
-        self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), 2)
+        # self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), 2)
 
-        block = nio.read_block(load_waveforms=True, units_group_mode='all-in-one')
-        self.assertEqual(len(block.channel_indexes[-1].units), 8)
+        # block = nio.read_block(load_waveforms=True, units_group_mode='all-in-one')
+        # self.assertEqual(len(block.channel_indexes[-1].units), 8)
 
-        block = nio.read_block(load_waveforms=True, units_group_mode='split-all')
-        self.assertEqual(len(block.channel_indexes[-1].units), 1)  # 1 units by ChannelIndex
+        # block = nio.read_block(load_waveforms=True, units_group_mode='split-all')
+        # self.assertEqual(len(block.channel_indexes[-1].units), 1)  # 1 units by ChannelIndex
 
     def test_read_segment(self):
         dirname = self.get_filename_path('Cheetah_v5.5.1/original_data')
         nio = NeuralynxIO(dirname=dirname, use_cache=False)
 
         # read first segment entirely
         seg = nio.read_segment(seg_index=0, time_slice=None)
@@ -211,18 +209,18 @@
         # Testing different parameter combinations
         block = nio.read_block(load_waveforms=True)
         self.assertEqual(len(block.segments[0].analogsignals), 1)
         self.assertEqual(len(block.segments[0].spiketrains), 0)
         self.assertGreater(len(block.segments[0].events), 0)
 
         block = nio.read_block(signal_group_mode='split-all')
-        self.assertEqual(len(block.channel_indexes), 5)
+        self.assertEqual(len(block.groups), 5)
 
         block = nio.read_block(signal_group_mode='group-by-same-units')
-        self.assertEqual(len(block.channel_indexes), 1)
+        self.assertEqual(len(block.groups), 1)
 
 
 class TestPegasus_v211(CommonNeuralynxIOTest, unittest.TestCase):
     pegasus_version = '2.1.1'
     files_to_test = []
 
     def test_read_block(self):
@@ -246,48 +244,71 @@
         self.assertEqual(len(block.channel_indexes), 0)
 
         block = nio.read_block(signal_group_mode='group-by-same-units')
         self.assertEqual(len(block.channel_indexes), 0)
 
 
 class TestData(CommonNeuralynxIOTest, unittest.TestCase):
-    def test_ncs(self):
-        for session in self.files_to_test[1:2]:  # in the long run this should include all files
+    # def test_ncs(self):
+    #     for session in self.files_to_test[1:2]:  # in the long run this should include all files
+    #         dirname = self.get_filename_path(session)
+    #         nio = NeuralynxIO(dirname=dirname, use_cache=False)
+    #         block = nio.read_block()
+
+    #         for anasig_id, anasig in enumerate(block.segments[0].analogsignals):
+    #             chid = anasig.channel_index.channel_ids[anasig_id]
+
+    #             # need to decode, unless keyerror
+    #             chname = anasig.channel_index.channel_names[anasig_id]
+    #             chuid = (chname, chid)
+    #             filename = nio.ncs_filenames[chuid][:-3] + 'txt'
+    #             filename = filename.replace('original_data', 'plain_data')
+    #             plain_data = np.loadtxt(filename)[:, 5:].flatten()  # first columns are meta info
+    #             overlap = 512 * 500
+    #             gain_factor_0 = plain_data[0] / anasig.magnitude[0, 0]
+    #             np.testing.assert_allclose(plain_data[:overlap],
+    #                                        anasig.magnitude[:overlap, 0] * gain_factor_0,
+    #                                        rtol=0.01)
+
+    def test_keep_original_spike_times(self):
+        for session in self.files_to_test:
             dirname = self.get_filename_path(session)
-            nio = NeuralynxIO(dirname=dirname, use_cache=False)
+            nio = NeuralynxIO(dirname=dirname, keep_original_times=True)
             block = nio.read_block()
 
-            for anasig_id, anasig in enumerate(block.segments[0].analogsignals):
-                chid = anasig.channel_index.channel_ids[anasig_id]
-
-                # need to decode, unless keyerror
-                chname = anasig.channel_index.channel_names[anasig_id].decode('UTF-8')
-                chuid = (chname, chid)
-                filename = nio.ncs_filenames[chuid][:-3] + 'txt'
-                filename = filename.replace('original_data', 'plain_data')
-                plain_data = np.loadtxt(filename)[:, 5:].flatten()  # first columns are meta info
-                overlap = 512 * 500
-                gain_factor_0 = plain_data[0] / anasig.magnitude[0, 0]
-                np.testing.assert_allclose(plain_data[:overlap],
-                                           anasig.magnitude[:overlap, 0] * gain_factor_0,
-                                           rtol=0.01)
+            for st in block.segments[0].spiketrains:
+                filename = st.file_origin.replace('original_data', 'plain_data')
+                if '.nse' in st.file_origin:
+                    filename = filename.replace('.nse', '.txt')
+                    times_column = 0
+                    plain_data = np.loadtxt(filename)[:, times_column]
+                elif '.ntt' in st.file_origin:
+                    filename = filename.replace('.ntt', '.txt')
+                    times_column = 2
+                    plain_data = np.loadtxt(filename)[:, times_column]
+                    # ntt files contain 4 rows per spike time
+                    plain_data = plain_data[::4]
+
+                times = st.rescale(pq.microsecond).magnitude
+                overlap = min(len(plain_data), len(times))
+                np.testing.assert_allclose(plain_data[:overlap], times[:overlap], rtol=1e-10)
 
 
 class TestIncompleteBlocks(CommonNeuralynxIOTest, unittest.TestCase):
     def test_incomplete_block_handling_v632(self):
         dirname = self.get_filename_path('Cheetah_v6.3.2/incomplete_blocks')
         nio = NeuralynxIO(dirname=dirname, use_cache=False)
 
         block = nio.read_block()
 
         # known gap values
         n_gaps = 2
         # so 3 segments, 3 anasigs by Channelindex
         self.assertEqual(len(block.segments), n_gaps + 1)
-        self.assertEqual(len(block.channel_indexes[0].analogsignals), n_gaps + 1)
+        # self.assertEqual(len(block.channel_indexes[0].analogsignals), n_gaps + 1)
 
         for t, gt in zip(nio._sigs_t_start, [8408.806811, 8427.832053, 8487.768561]):
             self.assertEqual(np.round(t, 4), np.round(gt, 4))
         for t, gt in zip(nio._sigs_t_stop, [8427.830803, 8487.768029, 8515.816549]):
             self.assertEqual(np.round(t, 4), np.round(gt, 4))
 
 
@@ -298,28 +319,28 @@
 
         block = nio.read_block()
 
         # known gap values
         n_gaps = 1
         # so 2 segments, 2 anasigs by Channelindex, 2 SpikeTrain by Units
         self.assertEqual(len(block.segments), n_gaps + 1)
-        self.assertEqual(len(block.channel_indexes[0].analogsignals), n_gaps + 1)
-        self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), n_gaps + 1)
+        # self.assertEqual(len(block.channel_indexes[0].analogsignals), n_gaps + 1)
+        # self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), n_gaps + 1)
 
     def test_gap_handling_v563(self):
         dirname = self.get_filename_path('Cheetah_v5.6.3/original_data')
         nio = NeuralynxIO(dirname=dirname, use_cache=False)
         block = nio.read_block()
 
         # known gap values
         n_gaps = 1
         # so 2 segments, 2 anasigs by Channelindex, 2 SpikeTrain by Units
         self.assertEqual(len(block.segments), n_gaps + 1)
-        self.assertEqual(len(block.channel_indexes[0].analogsignals), n_gaps + 1)
-        self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), n_gaps + 1)
+        # self.assertEqual(len(block.channel_indexes[0].analogsignals), n_gaps + 1)
+        # self.assertEqual(len(block.channel_indexes[-1].units[0].spiketrains), n_gaps + 1)
 
 
 def compare_old_and_new_neuralynxio():
     base = '/tmp/files_for_testing_neo/neuralynx/'
     dirname = base + 'Cheetah_v5.5.1/original_data/'
     # ~ dirname = base+'Cheetah_v5.7.4/original_data/'
```

### Comparing `neo-0.8.0/neo/test/iotest/test_neuroexplorerio.py` & `neo-0.9.0/neo/test/iotest/test_neuroexplorerio.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.neuroexplorerio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
-import sys
-
 import unittest
 
 from neo.io import NeuroExplorerIO
 from neo.test.iotest.common_io_test import BaseTestIO
 
 from neo.test.iotest.tools import get_test_file_full_path
```

### Comparing `neo-0.8.0/neo/test/iotest/test_neuroshareio.py` & `neo-0.9.0/neo/test/iotest/test_neuroshareio.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.neuroshareio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import sys
 import os
 import tarfile
 import zipfile
 import tempfile
 import platform
```

### Comparing `neo-0.8.0/neo/test/iotest/test_nixio.py` & `neo-0.9.0/neo/test/iotest/test_nixio.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,66 +1,73 @@
-# -*- coding: utf-8 -*-
 # Copyright (c) 2016, German Neuroinformatics Node (G-Node)
 #                     Achilleas Koutsou <achilleas.k@gmail.com>
 #
 # All rights reserved.
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted under the terms of the BSD License. See
 # LICENSE file in the root of the Project.
 """
 Tests for NixIO
 """
 
 import os
 import shutil
+
 try:
     from collections.abc import Iterable
 except ImportError:
     from collections import Iterable
-from datetime import datetime
+from datetime import date, time, datetime
 
 from tempfile import mkdtemp
-
+from itertools import chain
 import unittest
 import string
 import numpy as np
 import quantities as pq
 
 from neo.core import (Block, Segment, ChannelIndex, AnalogSignal,
-                      IrregularlySampledSignal, Unit, SpikeTrain, Event, Epoch)
+                      IrregularlySampledSignal, Unit, SpikeTrain,
+                      Event, Epoch, ImageSequence, Group, ChannelView)
 from neo.test.iotest.common_io_test import BaseTestIO
-from neo.io.nixio import NixIO, create_quantity, units_to_string, neover
+from neo.io.nixio import (NixIO, create_quantity, units_to_string, neover,
+                          dt_from_nix, dt_to_nix, DATETIMEANNOTATION)
 from neo.io.nixio_fr import NixIO as NixIO_lazy
-from neo.io.proxyobjects import AnalogSignalProxy, SpikeTrainProxy, EventProxy, EpochProxy
+from neo.io.proxyobjects import (AnalogSignalProxy, SpikeTrainProxy,
+                                 EventProxy, EpochProxy)
 
 try:
     import nixio as nix
 
     HAVE_NIX = True
 except ImportError:
     HAVE_NIX = False
 
 try:
     from unittest import mock
+
     SKIPMOCK = False
 except ImportError:
     SKIPMOCK = True
 
 
 @unittest.skipUnless(HAVE_NIX, "Requires NIX")
 class NixIOTest(unittest.TestCase):
     io = None
     tempdir = None
     filename = None
 
     def compare_blocks(self, neoblocks, nixblocks):
         for neoblock, nixblock in zip(neoblocks, nixblocks):
             self.compare_attr(neoblock, nixblock)
-            self.assertEqual(len(neoblock.segments), len(nixblock.groups))
+            self.assertEqual(len(neoblock.segments),
+                             len([grp for grp in nixblock.groups if grp.type == "neo.segment"]))
+            self.assertEqual(len(neoblock.groups),
+                             len([grp for grp in nixblock.groups if grp.type == "neo.group"]))
             for idx, neoseg in enumerate(neoblock.segments):
                 nixgrp = nixblock.groups[neoseg.annotations["nix_name"]]
                 self.compare_segment_group(neoseg, nixgrp)
             self.assertEqual(len(neoblock.channel_indexes),
                              len(nixblock.sources))
             for idx, neochx in enumerate(neoblock.channel_indexes):
                 nixsrc = nixblock.sources[neochx.annotations["nix_name"]]
@@ -88,21 +95,25 @@
 
         for nixchan in nix_channels:
             nixchanidx = nixchan.metadata["index"]
             try:
                 neochanpos = list(neochx.index).index(nixchanidx)
             except ValueError:
                 self.fail("Channel indexes do not match.")
+
             if len(neochx.channel_names):
                 neochanname = neochx.channel_names[neochanpos]
                 if ((not isinstance(neochanname, str)) and
                         isinstance(neochanname, bytes)):
                     neochanname = neochanname.decode()
                 nixchanname = nixchan.metadata["neo_name"]
                 self.assertEqual(neochanname, nixchanname)
+            else:
+                # Check if channel name exists but not loaded
+                self.assertNotIn("neo_name", nixchan.metadata)
             if len(neochx.channel_ids):
                 neochanid = neochx.channel_ids[neochanpos]
                 nixchanid = nixchan.metadata["channel_id"]
                 self.assertEqual(neochanid, nixchanid)
             elif "channel_id" in nixchan.metadata:
                 self.fail("Channel ID not loaded")
 
@@ -129,26 +140,25 @@
         """
         for idx, neochx in enumerate(neoblock.channel_indexes):
             nixchx = nixblock.sources[neochx.annotations["nix_name"]]
             # AnalogSignals referencing CHX
             neoasigs = list(sig.annotations["nix_name"]
                             for sig in neochx.analogsignals)
             nixasigs = list({da.metadata.name for da in nixblock.data_arrays
-                                if da.type == "neo.analogsignal" and
-                                nixchx in da.sources})
+                             if da.type == "neo.analogsignal"
+                             and nixchx in da.sources})
 
             self.assertEqual(len(neoasigs), len(nixasigs))
-
             # IrregularlySampledSignals referencing CHX
             neoisigs = list(sig.annotations["nix_name"] for sig in
                             neochx.irregularlysampledsignals)
             nixisigs = list(
                 {da.metadata.name for da in nixblock.data_arrays
-                    if da.type == "neo.irregularlysampledsignal" and
-                    nixchx in da.sources}
+                 if da.type == "neo.irregularlysampledsignal"
+                 and nixchx in da.sources}
             )
             self.assertEqual(len(neoisigs), len(nixisigs))
             # SpikeTrains referencing CHX and Units
             for sidx, neounit in enumerate(neochx.units):
                 nixunit = nixchx.sources[neounit.annotations["nix_name"]]
                 neosts = list(st.annotations["nix_name"]
                               for st in neounit.spiketrains)
@@ -173,28 +183,29 @@
                                           "neo.irregularlysampledsignal"])
             for nee in nixevep:
                 for ns in nixsigs:
                     self.assertIn(ns, nee.references)
 
     def compare_segment_group(self, neoseg, nixgroup):
         self.compare_attr(neoseg, nixgroup)
-        neo_signals = neoseg.analogsignals + neoseg.irregularlysampledsignals
+        neo_signals = neoseg.analogsignals + neoseg.irregularlysampledsignals \
+            + neoseg.imagesequences
         self.compare_signals_das(neo_signals, nixgroup.data_arrays)
         neo_eests = neoseg.epochs + neoseg.events + neoseg.spiketrains
         self.compare_eests_mtags(neo_eests, nixgroup.multi_tags)
 
     def compare_signals_das(self, neosignals, data_arrays):
         totalsignals = 0
         for sig in neosignals:
             dalist = list()
             nixname = sig.annotations["nix_name"]
             for da in data_arrays:
                 if da.metadata.name == nixname:
                     dalist.append(da)
-            _, nsig = np.shape(sig)
+            nsig = np.shape(sig)[-1]
             totalsignals += nsig
             self.assertEqual(nsig, len(dalist))
             self.compare_signal_dalist(sig, dalist)
         self.assertEqual(totalsignals, len(data_arrays))
 
     def compare_signal_dalist(self, neosig, nixdalist):
         """
@@ -208,38 +219,51 @@
         self.assertTrue(all(nixmd == da.metadata for da in nixdalist))
         neounit = neosig.units
         if isinstance(neosig, AnalogSignalProxy):
             neosig = neosig.load()
         for sig, da in zip(np.transpose(neosig), nixdalist):
             self.compare_attr(neosig, da)
             daquant = create_quantity(da[:], da.unit)
-            np.testing.assert_almost_equal(sig, daquant)
+            np.testing.assert_almost_equal(sig.view(pq.Quantity), daquant)
             nixunit = create_quantity(1, da.unit)
             self.assertEqual(neounit, nixunit)
-            timedim = da.dimensions[0]
+
             if isinstance(neosig, AnalogSignal):
+                timedim = da.dimensions[0]
                 self.assertEqual(timedim.dimension_type,
                                  nix.DimensionType.Sample)
                 neosp = neosig.sampling_period
                 nixsp = create_quantity(timedim.sampling_interval,
                                         timedim.unit)
                 self.assertEqual(neosp, nixsp)
                 tsunit = timedim.unit
                 if "t_start.units" in da.metadata.props:
                     tsunit = da.metadata["t_start.units"]
                 neots = neosig.t_start
                 nixts = create_quantity(timedim.offset, tsunit)
                 self.assertEqual(neots, nixts)
             elif isinstance(neosig, IrregularlySampledSignal):
+                timedim = da.dimensions[0]
                 self.assertEqual(timedim.dimension_type,
                                  nix.DimensionType.Range)
                 np.testing.assert_almost_equal(neosig.times.magnitude,
                                                timedim.ticks)
                 self.assertEqual(timedim.unit,
                                  units_to_string(neosig.times.units))
+            elif isinstance(neosig, ImageSequence):
+                rate = da.metadata["sampling_rate"]
+                unit = da.metadata.props["sampling_rate"].unit
+                sampling_rate = create_quantity(rate, unit)
+                neosr = neosig.sampling_rate
+                self.assertEqual(sampling_rate, neosr)
+                scale = da.metadata["spatial_scale"]
+                unit = da.metadata.props["spatial_scale"].unit
+                spatial_scale = create_quantity(scale, unit)
+                neosps = neosig.spatial_scale
+                self.assertEqual(spatial_scale, neosps)
 
     def compare_eests_mtags(self, eestlist, mtaglist):
         self.assertEqual(len(eestlist), len(mtaglist))
         for eest in eestlist:
             if isinstance(eest, (EventProxy, EpochProxy, SpikeTrainProxy)):
                 eest = eest.load()
             mtag = mtaglist[eest.annotations["nix_name"]]
@@ -259,35 +283,24 @@
         posquant = create_quantity(pos[:], pos.unit)
         ext = mtag.extents
         extquant = create_quantity(ext[:], ext.unit)
         np.testing.assert_almost_equal(epoch.as_quantity(), posquant)
         np.testing.assert_almost_equal(epoch.durations, extquant)
         for neol, nixl in zip(epoch.labels,
                               mtag.positions.dimensions[0].labels):
-            # Dirty. Should find the root cause instead
-            if isinstance(neol, bytes):
-                neol = neol.decode()
-            if isinstance(nixl, bytes):
-                nixl = nixl.decode()
             self.assertEqual(neol, nixl)
 
     def compare_event_mtag(self, event, mtag):
         self.assertEqual(mtag.type, "neo.event")
         self.compare_attr(event, mtag)
         pos = mtag.positions
         posquant = create_quantity(pos[:], pos.unit)
         np.testing.assert_almost_equal(event.as_quantity(), posquant)
         for neol, nixl in zip(event.labels,
                               mtag.positions.dimensions[0].labels):
-            # Dirty. Should find the root cause instead
-            # Only happens in 3.2
-            if isinstance(neol, bytes):
-                neol = neol.decode()
-            if isinstance(nixl, bytes):
-                nixl = nixl.decode()
             self.assertEqual(neol, nixl)
 
     def compare_spiketrain_mtag(self, spiketrain, mtag):
         self.assertEqual(mtag.type, "neo.spiketrain")
         self.compare_attr(spiketrain, mtag)
         pos = mtag.positions
         posquant = create_quantity(pos[:], pos.unit)
@@ -305,27 +318,30 @@
                              nix.DimensionType.Set)
             self.assertEqual(nixwfs.dimensions[1].dimension_type,
                              nix.DimensionType.Set)
             self.assertEqual(nixwfs.dimensions[2].dimension_type,
                              nix.DimensionType.Sample)
 
     def compare_attr(self, neoobj, nixobj):
-        if isinstance(neoobj, (AnalogSignal, IrregularlySampledSignal)):
+        if isinstance(neoobj, (AnalogSignal, IrregularlySampledSignal,
+                               ImageSequence)):
             nix_name = ".".join(nixobj.name.split(".")[:-1])
         else:
             nix_name = nixobj.name
+
         self.assertEqual(neoobj.annotations["nix_name"], nix_name)
         self.assertEqual(neoobj.description, nixobj.definition)
         if hasattr(neoobj, "rec_datetime") and neoobj.rec_datetime:
             self.assertEqual(neoobj.rec_datetime,
                              datetime.fromtimestamp(nixobj.created_at))
         if hasattr(neoobj, "file_datetime") and neoobj.file_datetime:
-            self.assertEqual(neoobj.file_datetime,
-                             datetime.fromtimestamp(
-                                 nixobj.metadata["file_datetime"]))
+            nixdt = dt_from_nix(nixobj.metadata["file_datetime"],
+                                DATETIMEANNOTATION)
+            assert neoobj.file_datetime == nixdt
+            self.assertEqual(neoobj.file_datetime, nixdt)
         if neoobj.annotations:
             nixmd = nixobj.metadata
             for k, v, in neoobj.annotations.items():
                 if k == "nix_name":
                     continue
                 if isinstance(v, pq.Quantity):
                     nixunit = nixmd.props[str(k)].unit
@@ -349,16 +365,16 @@
                         nixvalue = nixmd[str(k)]
                         if isinstance(nixvalue, Iterable):
                             nixvalue = np.array(nixvalue)
                         np.testing.assert_almost_equal(nixvalue, v.magnitude)
                     if isinstance(v, np.ndarray):
                         self.assertTrue(np.all(v == nixmd[str(k)]))
                     else:
-                        self.assertEqual(nixmd[str(k)], v,
-                                         "Property value mismatch: {}".format(k))
+                        msg = "Property value mismatch: {}".format(k)
+                        self.assertEqual(nixmd[str(k)], v, msg)
 
     @classmethod
     def create_full_nix_file(cls, filename):
         nixfile = nix.File.open(filename, nix.FileMode.Overwrite)
 
         nix_block_a = nixfile.create_block(cls.rword(10), "neo.block")
         nix_block_a.definition = cls.rsentence(5, 10)
@@ -397,17 +413,18 @@
             siggroup = list()
             asig_name = "{}_asig{}".format(cls.rword(10), n)
             asig_definition = cls.rsentence(5, 5)
             asig_md = group.metadata.create_section(asig_name,
                                                     asig_name + ".metadata")
 
             arr_ann_name, arr_ann_val = 'anasig_arr_ann', cls.rquant(10, pq.uV)
-            asig_md.create_property(arr_ann_name, arr_ann_val.magnitude.flatten())
+            asig_md.create_property(arr_ann_name,
+                                    arr_ann_val.magnitude.flatten())
             asig_md.props[arr_ann_name].unit = str(arr_ann_val.dimensionality)
-            asig_md.props[arr_ann_name].definition = 'ARRAYANNOTATION'
+            asig_md.props[arr_ann_name].type = 'ARRAYANNOTATION'
 
             for idx in range(10):
                 da_asig = blk.create_data_array(
                     "{}.{}".format(asig_name, idx),
                     "neo.analogsignal",
                     data=cls.rquant(100, 1)
                 )
@@ -421,27 +438,60 @@
                 timedim.label = "time"
                 timedim.offset = 10
                 da_asig.append_set_dimension()
                 group.data_arrays.append(da_asig)
                 siggroup.append(da_asig)
             asig_md["t_start.dim"] = "ms"
             allsignalgroups.append(siggroup)
+        # imagesequence
+        for n in range(5):
+            imgseqgroup = list()
+            imgseq_name = "{}_imgs{}".format(cls.rword(10), n)
+            imgseq_definition = cls.rsentence(5, 5)
+            imgseq_md = group.metadata.create_section(imgseq_name,
+                                                      imgseq_name + ".metadata")
+
+            arr_ann_name, arr_ann_val = 'imgseq_arr_ann', cls.rquant(10, pq.V)
+            imgseq_md.create_property(arr_ann_name,
+                                      arr_ann_val.magnitude.flatten())
+            imgseq_md.props[arr_ann_name].unit = str(arr_ann_val.dimensionality)
+            imgseq_md.props[arr_ann_name].type = 'ARRAYANNOTATION'
+
+            for idx in range(10):
+                da_imgseq = blk.create_data_array(
+                    "{}.{}".format(imgseq_name, idx),
+                    "neo.imagesequence",
+                    data=cls.rquant((20, 10), 1)
+                )
+                da_imgseq.definition = imgseq_definition
+                da_imgseq.unit = "mV"
 
+                da_imgseq.metadata = imgseq_md
+                imgseq_md["sampling_rate"] = 10
+                imgseq_md.props["sampling_rate"].unit = units_to_string(pq.V)
+                imgseq_md["spatial_scale"] = 10
+                imgseq_md.props["spatial_scale"].unit = units_to_string(pq.micrometer)
+
+                group.data_arrays.append(da_imgseq)
+                imgseqgroup.append(da_imgseq)
+
+            allsignalgroups.append(imgseqgroup)
         # irregularlysampledsignals
         for n in range(2):
             siggroup = list()
             isig_name = "{}_isig{}".format(cls.rword(10), n)
             isig_definition = cls.rsentence(12, 12)
             isig_md = group.metadata.create_section(isig_name,
                                                     isig_name + ".metadata")
             isig_times = cls.rquant(200, 1, True)
             arr_ann_name, arr_ann_val = 'irrsig_arr_ann', cls.rquant(7, pq.uV)
-            isig_md.create_property(arr_ann_name, arr_ann_val.magnitude.flatten())
+            isig_md.create_property(arr_ann_name,
+                                    arr_ann_val.magnitude.flatten())
             isig_md.props[arr_ann_name].unit = str(arr_ann_val.dimensionality)
-            isig_md.props[arr_ann_name].definition = 'ARRAYANNOTATION'
+            isig_md.props[arr_ann_name].type = 'ARRAYANNOTATION'
             for idx in range(7):
                 da_isig = blk.create_data_array(
                     "{}.{}".format(isig_name, idx),
                     "neo.irregularlysampledsignal",
                     data=cls.rquant(200, 1)
                 )
                 da_isig.definition = isig_definition
@@ -452,15 +502,14 @@
                 timedim = da_isig.append_range_dimension(isig_times)
                 timedim.unit = "s"
                 timedim.label = "time"
                 da_isig.append_set_dimension()
                 group.data_arrays.append(da_isig)
                 siggroup.append(da_isig)
             allsignalgroups.append(siggroup)
-
         # SpikeTrains with Waveforms
         for n in range(4):
             stname = "{}-st{}".format(cls.rword(20), n)
             times = cls.rquant(40, 1, True)
             times_da = blk.create_data_array(
                 "{}.times".format(stname),
                 "neo.spiketrain.times",
@@ -473,17 +522,18 @@
             mtag_st_md = group.metadata.create_section(
                 mtag_st.name, mtag_st.name + ".metadata"
             )
             mtag_st.metadata = mtag_st_md
             mtag_st_md.create_property("t_stop", times[-1] + 1.0)
 
             arr_ann_name, arr_ann_val = 'st_arr_ann', cls.rquant(40, pq.uV)
-            mtag_st_md.create_property(arr_ann_name, arr_ann_val.magnitude.flatten())
+            mtag_st_md.create_property(arr_ann_name,
+                                       arr_ann_val.magnitude.flatten())
             mtag_st_md.props[arr_ann_name].unit = str(arr_ann_val.dimensionality)
-            mtag_st_md.props[arr_ann_name].definition = 'ARRAYANNOTATION'
+            mtag_st_md.props[arr_ann_name].type = 'ARRAYANNOTATION'
 
             waveforms = cls.rquant((10, 8, 5), 1)
             wfname = "{}.waveforms".format(mtag_st.name)
             wfda = blk.create_data_array(wfname, "neo.waveforms",
                                          data=waveforms)
             wfda.unit = "mV"
             mtag_st.create_feature(wfda, nix.LinkType.Indexed)
@@ -513,29 +563,29 @@
             extents = cls.rquant(5, 1)
             extents_da = blk.create_data_array(
                 "{}.durations".format(epname),
                 "neo.epoch.durations",
                 data=extents
             )
             extents_da.unit = "s"
-
             mtag_ep = blk.create_multi_tag(
                 epname, "neo.epoch", times_da
             )
             mtag_ep.metadata = group.metadata.create_section(
                 epname, epname + ".metadata"
             )
             group.multi_tags.append(mtag_ep)
             mtag_ep.definition = cls.rsentence(2)
             mtag_ep.extents = extents_da
 
             arr_ann_name, arr_ann_val = 'ep_arr_ann', cls.rquant(5, pq.uV)
-            mtag_ep.metadata.create_property(arr_ann_name, arr_ann_val.magnitude.flatten())
+            mtag_ep.metadata.create_property(arr_ann_name,
+                                             arr_ann_val.magnitude.flatten())
             mtag_ep.metadata.props[arr_ann_name].unit = str(arr_ann_val.dimensionality)
-            mtag_ep.metadata.props[arr_ann_name].definition = 'ARRAYANNOTATION'
+            mtag_ep.metadata.props[arr_ann_name].type = 'ARRAYANNOTATION'
 
             label_dim = mtag_ep.positions.append_set_dimension()
             label_dim.labels = cls.rsentence(5).split(" ")
             # reference all signals in the group
             for siggroup in allsignalgroups:
                 mtag_ep.references.extend(siggroup)
 
@@ -555,18 +605,20 @@
             )
             mtag_ev.metadata = group.metadata.create_section(
                 evname, evname + ".metadata"
             )
             group.multi_tags.append(mtag_ev)
             mtag_ev.definition = cls.rsentence(2)
 
-            arr_ann_name, arr_ann_val = 'ev_arr_ann', cls.rquant(5, pq.uV)
-            mtag_ev.metadata.create_property(arr_ann_name, arr_ann_val.magnitude.flatten())
+            arr_ann_name, arr_ann_val = 'ev_arr_ann',\
+                                        cls.rquant(5, pq.uV)
+            mtag_ev.metadata.create_property(arr_ann_name,
+                                             arr_ann_val.magnitude.flatten())
             mtag_ev.metadata.props[arr_ann_name].unit = str(arr_ann_val.dimensionality)
-            mtag_ev.metadata.props[arr_ann_name].definition = 'ARRAYANNOTATION'
+            mtag_ev.metadata.props[arr_ann_name].type = 'ARRAYANNOTATION'
 
             label_dim = mtag_ev.positions.append_set_dimension()
             label_dim.labels = cls.rsentence(5).split(" ")
             # reference all signals in the group
             for siggroup in allsignalgroups:
                 mtag_ev.references.extend(siggroup)
 
@@ -668,32 +720,36 @@
         cls.populate_dates(blk)
 
         seg = Segment()
         seg.annotate(**cls.rdict(4))
         cls.populate_dates(seg)
         blk.segments.append(seg)
 
-        asig = AnalogSignal(signal=signal, sampling_rate=pq.Hz, array_annotations=signal_ann)
+        asig = AnalogSignal(signal=signal, sampling_rate=pq.Hz,
+                            array_annotations=signal_ann)
         asig.annotate(**cls.rdict(2))
         seg.analogsignals.append(asig)
 
         isig = IrregularlySampledSignal(times=times, signal=signal,
-                                        time_units=pq.s, array_annotations=signal_ann)
+                                        time_units=pq.s,
+                                        array_annotations=signal_ann)
         isig.annotate(**cls.rdict(2))
         seg.irregularlysampledsignals.append(isig)
 
-        epoch = Epoch(times=times, durations=times, array_annotations=times_ann)
+        epoch = Epoch(times=times, durations=times,
+                      array_annotations=times_ann)
         epoch.annotate(**cls.rdict(4))
         seg.epochs.append(epoch)
 
         event = Event(times=times, array_annotations=times_ann)
         event.annotate(**cls.rdict(4))
         seg.events.append(event)
 
-        spiketrain = SpikeTrain(times=times, t_stop=pq.s, units=pq.s, array_annotations=times_ann)
+        spiketrain = SpikeTrain(times=times, t_stop=pq.s, units=pq.s,
+                                array_annotations=times_ann)
         d = cls.rdict(6)
         d["quantity"] = pq.Quantity(10, "mV")
         d["qarray"] = pq.Quantity(range(10), "mA")
         spiketrain.annotate(**d)
         seg.spiketrains.append(spiketrain)
 
         chx = ChannelIndex(name="achx", index=[1, 2], channel_ids=[0, 10])
@@ -824,14 +880,26 @@
                                      units="mV", time_units="s",
                                      dtype=np.float,
                                      name="some sort of signal",
                                      description="the signal is described")
         )
         self.write_and_compare([block, anotherblock])
 
+    def test_imagesequence_write(self):
+        block = Block()
+        seg = Segment()
+        block.segments.append(seg)
+
+        imgseq = ImageSequence(image_data=self.rquant((19, 10, 15), 1),
+                               sampling_rate=pq.Quantity(10, "Hz"),
+                               spatial_scale=pq.Quantity(10, "micrometer"),
+                               units=pq.V)
+        seg.imagesequences.append(imgseq)
+        self.write_and_compare([block])
+
     def test_signals_compound_units(self):
         block = Block()
         seg = Segment()
         block.segments.append(seg)
 
         units = pq.CompoundUnit("1/30000*V")
         srate = pq.Quantity(10, pq.CompoundUnit("1.0/10 * Hz"))
@@ -868,34 +936,48 @@
                                      units="mV", dtype=np.float,
                                      name="some sort of signal",
                                      description="the signal is described")
         )
 
         self.write_and_compare([block, anotherblock])
 
+    def test_imagesequence_compound_units(self):
+        block = Block()
+        seg = Segment()
+        block.segments.append(seg)
+
+        units = pq.CompoundUnit("1/30000*V")
+        srate = pq.Quantity(10, pq.CompoundUnit("1.0/10 * Hz"))
+        size = pq.Quantity(10, pq.CompoundUnit("1.0/10 * micrometer"))
+        imgseq = ImageSequence(image_data=self.rquant((10, 20, 10), units),
+                               sampling_rate=srate, spatial_scale=size)
+        seg.imagesequences.append(imgseq)
+
+        self.write_and_compare([block])
+
     def test_epoch_write(self):
         block = Block()
         seg = Segment()
         block.segments.append(seg)
 
         epoch = Epoch(times=[1, 1, 10, 3] * pq.ms,
                       durations=[3, 3, 3, 1] * pq.ms,
-                      labels=np.array(["one", "two", "three", "four"]),
+                      labels=np.array(["one", "two", "three", "four"], dtype='U'),
                       name="test epoch", description="an epoch for testing")
 
         seg.epochs.append(epoch)
         self.write_and_compare([block])
 
     def test_event_write(self):
         block = Block()
         seg = Segment()
         block.segments.append(seg)
 
         event = Event(times=np.arange(0, 30, 10) * pq.s,
-                      labels=np.array(["0", "1", "2"]),
+                      labels=np.array(["0", "1", "2"], dtype='U'),
                       name="event name",
                       description="event description")
         seg.events.append(event)
         self.write_and_compare([block])
 
     def test_spiketrain_write(self):
         block = Block()
@@ -918,14 +1000,96 @@
 
         spiketrain.left_sweep = np.random.random(10) * pq.ms
         self.write_and_compare([block])
 
         spiketrain.left_sweep = pq.Quantity(-10, "ms")
         self.write_and_compare([block])
 
+    def test_group_write(self):
+        signals = [
+            AnalogSignal(np.random.random(size=(1000, 5)) * pq.mV,
+                         sampling_period=1 * pq.ms, name="sig1"),
+            AnalogSignal(np.random.random(size=(1000, 3)) * pq.mV,
+                         sampling_period=1 * pq.ms, name="sig2"),
+        ]
+        spiketrains = [
+            SpikeTrain([0.1, 54.3, 76.6, 464.2], units=pq.ms,
+                       t_stop=1000.0 * pq.ms, t_start=0.0 * pq.ms),
+            SpikeTrain([30.1, 154.3, 276.6, 864.2], units=pq.ms,
+                       t_stop=1000.0 * pq.ms, t_start=0.0 * pq.ms),
+            SpikeTrain([120.1, 454.3, 576.6, 764.2], units=pq.ms,
+                       t_stop=1000.0 * pq.ms, t_start=0.0 * pq.ms),
+        ]
+        epochs =  [
+            Epoch(times=[0, 500], durations=[100, 100], units=pq.ms, labels=["A", "B"])
+        ]
+
+        seg = Segment(name="seg1")
+        seg.analogsignals.extend(signals)
+        seg.spiketrains.extend(spiketrains)
+        seg.epochs.extend(epochs)
+        for obj in chain(signals, spiketrains, epochs):
+            obj.segment = seg
+
+        views = [ChannelView(index=np.array([0, 3, 4]), obj=signals[0], name="view_of_sig1")]
+        groups = [
+            Group(objects=(signals[0:1] + spiketrains[0:2] + epochs + views), name="group1"),
+            Group(objects=(signals[1:2] + spiketrains[1:] + epochs), name="group2")
+        ]
+
+        block = Block(name="block1")
+        block.segments.append(seg)
+        block.groups.extend(groups)
+        for obj in chain([seg], groups):
+            obj.block = block
+
+        self.write_and_compare([block])
+
+    def test_group_write_nested(self):
+        signals = [
+            AnalogSignal(np.random.random(size=(1000, 5)) * pq.mV,
+                         sampling_period=1 * pq.ms, name="sig1"),
+            AnalogSignal(np.random.random(size=(1000, 3)) * pq.mV,
+                         sampling_period=1 * pq.ms, name="sig2"),
+        ]
+        spiketrains = [
+            SpikeTrain([0.1, 54.3, 76.6, 464.2], units=pq.ms,
+                       t_stop=1000.0 * pq.ms, t_start=0.0 * pq.ms),
+            SpikeTrain([30.1, 154.3, 276.6, 864.2], units=pq.ms,
+                       t_stop=1000.0 * pq.ms, t_start=0.0 * pq.ms),
+            SpikeTrain([120.1, 454.3, 576.6, 764.2], units=pq.ms,
+                       t_stop=1000.0 * pq.ms, t_start=0.0 * pq.ms),
+        ]
+        epochs =  [
+            Epoch(times=[0, 500], durations=[100, 100], units=pq.ms, labels=["A", "B"])
+        ]
+
+        seg = Segment(name="seg1")
+        seg.analogsignals.extend(signals)
+        seg.spiketrains.extend(spiketrains)
+        seg.epochs.extend(epochs)
+        for obj in chain(signals, spiketrains, epochs):
+            obj.segment = seg
+
+        views = [ChannelView(index=np.array([0, 3, 4]), obj=signals[0], name="view_of_sig1")]
+
+        subgroup = Group(objects=(signals[0:1] + views), name="subgroup")
+        groups = [
+            Group(objects=([subgroup] + spiketrains[0:2] + epochs), name="group1"),
+            Group(objects=(signals[1:2] + spiketrains[1:] + epochs), name="group2")
+        ]
+
+        block = Block(name="block1")
+        block.segments.append(seg)
+        block.groups.extend(groups)
+        for obj in chain([seg], groups):
+            obj.block = block
+
+        self.write_and_compare([block])
+
     def test_metadata_structure_write(self):
         neoblk = self.create_all_annotated()
         self.io.write_block(neoblk)
         blk = self.io.nix_file.blocks[0]
 
         blkmd = blk.metadata
         self.assertEqual(blk.name, blkmd.name)
@@ -948,33 +1112,40 @@
 
         self.write_and_compare([neoblk])
 
     def test_anonymous_objects_write(self):
         nblocks = 2
         nsegs = 2
         nanasig = 4
+        nimgseq = 4
         nirrseg = 2
         nepochs = 3
         nevents = 4
         nspiketrains = 3
         nchx = 5
         nunits = 10
 
         times = self.rquant(1, pq.s)
         signal = self.rquant(1, pq.V)
+
         blocks = []
         for blkidx in range(nblocks):
             blk = Block()
             blocks.append(blk)
             for segidx in range(nsegs):
                 seg = Segment()
                 blk.segments.append(seg)
                 for anaidx in range(nanasig):
                     seg.analogsignals.append(AnalogSignal(signal=signal,
                                                           sampling_rate=pq.Hz))
+                for imgseqdx in range(nimgseq):
+                    seg.imagesequences.append(ImageSequence(image_data=self.rquant(
+                                                            (10, 20, 10), pq.V),
+                                                            sampling_rate=pq.Hz,
+                                                            spatial_scale=pq.micrometer))
                 for irridx in range(nirrseg):
                     seg.irregularlysampledsignals.append(
                         IrregularlySampledSignal(times=times,
                                                  signal=signal,
                                                  time_units=pq.s)
                     )
                 for epidx in range(nepochs):
@@ -998,14 +1169,15 @@
         with self.assertRaises(ValueError):
             self.writer.write_all_blocks(blocks, use_obj_names=True)
 
     def test_name_objects_write(self):
         nblocks = 2
         nsegs = 2
         nanasig = 4
+        nimgseq = 2
         nirrseg = 2
         nepochs = 3
         nevents = 4
         nspiketrains = 3
         nchx = 5
         nunits = 10
 
@@ -1020,14 +1192,22 @@
                 blk.segments.append(seg)
                 for anaidx in range(nanasig):
                     asig = AnalogSignal(
                         name="{}:as{}".format(seg.name, anaidx),
                         signal=signal, sampling_rate=pq.Hz
                     )
                     seg.analogsignals.append(asig)
+                # imagesequence
+                for imgseqdx in range(nimgseq):
+                    imseq = ImageSequence(
+                        name="{}:imgs{}".format(seg.name, imgseqdx),
+                        image_data=np.random.rand(20, 10, 10), units=pq.mV,
+                        sampling_rate=pq.Hz, spatial_scale=pq.micrometer
+                    )
+                    seg.imagesequences.append(imseq)
                 for irridx in range(nirrseg):
                     isig = IrregularlySampledSignal(
                         name="{}:is{}".format(seg.name, irridx),
                         times=times,
                         signal=signal,
                         time_units=pq.s
                     )
@@ -1059,15 +1239,14 @@
                     chx.units.append(unit)
 
         # put guard on _generate_nix_name
         if not SKIPMOCK:
             nixgenmock = mock.Mock(name="_generate_nix_name",
                                    wraps=self.io._generate_nix_name)
             self.io._generate_nix_name = nixgenmock
-
         self.writer.write_block(blocks[0], use_obj_names=True)
         self.compare_blocks([blocks[0]], self.reader.blocks)
         self.compare_blocks(self.writer.read_all_blocks(), self.reader.blocks)
         self.compare_blocks(blocks, self.reader.blocks)
         if not SKIPMOCK:
             nixgenmock.assert_not_called()
 
@@ -1118,14 +1297,20 @@
 
         times = self.rquant(1, pq.s)
         signal = self.rquant(1, pq.V)
         # name conflict: analog + irregular signals
         seg.analogsignals.append(
             AnalogSignal(name="signal", signal=signal, sampling_rate=pq.Hz)
         )
+        seg.imagesequences.append(
+            ImageSequence(name='signal',
+                          image_data=self.rquant((10, 20, 10), pq.V),
+                          sampling_rate=pq.Hz,
+                          spatial_scale=pq.micrometer))
+
         seg.irregularlysampledsignals.append(
             IrregularlySampledSignal(name="signal", signal=signal, times=times)
         )
         blk = Block(name="Signal conflict Block")
         blk.segments.append(seg)
         with self.assertRaises(ValueError):
             self.io.write_block(blk, use_obj_names=True)
@@ -1164,25 +1349,29 @@
     def test_multiref_write(self):
         blk = Block("blk1")
         signal = AnalogSignal(name="sig1", signal=[0, 1, 2], units="mV",
                               sampling_period=pq.Quantity(1, "ms"))
         othersignal = IrregularlySampledSignal(name="i1", signal=[0, 0, 0],
                                                units="mV", times=[1, 2, 3],
                                                time_units="ms")
+        imgseq = ImageSequence(name="img1", image_data=self.rquant((10, 20, 10), pq.mV),
+                               frame_duration=pq.Quantity(1, "ms"),
+                               spatial_scale=pq.meter)
         event = Event(name="Evee", times=[0.3, 0.42], units="year")
         epoch = Epoch(name="epoche", times=[0.1, 0.2] * pq.min,
                       durations=[0.5, 0.5] * pq.min)
         st = SpikeTrain(name="the train of spikes", times=[0.1, 0.2, 10.3],
                         t_stop=11, units="us")
 
         for idx in range(3):
             segname = "seg" + str(idx)
             seg = Segment(segname)
             blk.segments.append(seg)
             seg.analogsignals.append(signal)
+            seg.imagesequences.append(imgseq)
             seg.irregularlysampledsignals.append(othersignal)
             seg.events.append(event)
             seg.epochs.append(epoch)
             seg.spiketrains.append(st)
 
         chidx = ChannelIndex([10, 20, 29])
         seg = blk.segments[0]
@@ -1313,15 +1502,15 @@
         writeprop(section, "qvalue", qvalue)
         self.assertEqual(section["qvalue"], 10)
         self.assertEqual(section.props["qvalue"].unit, "mV")
 
         # datetime
         dt = self.rdate()
         writeprop(section, "dt", dt)
-        self.assertEqual(datetime.fromtimestamp(section["dt"]), dt)
+        self.assertEqual(section["dt"], dt_to_nix(dt)[0])
 
         # string
         randstr = self.rsentence()
         writeprop(section, "randstr", randstr)
         self.assertEqual(section["randstr"], randstr)
 
         # bytes
@@ -1377,29 +1566,54 @@
                        los=losval)
         self.writer.write_block(wblock)
         rblock = self.writer.read_block(neoname="block with list of strings")
         self.assertEqual(rblock.annotations["los"], losval)
 
         # TODO: multi dimensional value (GH Issue #501)
 
+    def test_empty_array_annotations(self):
+        wblock = Block("block with spiketrain")
+        wseg = Segment()
+        wseg.spiketrains = [SpikeTrain(times=[] * pq.s, t_stop=1 * pq.s,
+                                       array_annotations={'empty': []})]
+        wblock.segments = [wseg]
+        self.writer.write_block(wblock)
+        try:
+            rblock = self.writer.read_block(neoname="block with spiketrain")
+        except Exception as exc:
+            self.fail('The following exception was raised when'
+                      + ' reading the block with an empty array annotation:\n'
+                      + str(exc))
+        rst = rblock.segments[0].spiketrains[0]
+        self.assertEqual(len(rst.array_annotations), 1)
+        self.assertIn('empty', rst.array_annotations.keys())
+        self.assertEqual(len(rst.array_annotations['empty']), 0)
+
     def test_write_proxyobjects(self):
 
         def generate_complete_block():
             block = Block()
             seg = Segment()
             block.segments.append(seg)
 
             # add spiketrain
             waveforms = self.rquant((3, 5, 10), pq.mV)
-            spiketrain = SpikeTrain(times=[1, 1.1, 1.2] * pq.ms, t_stop=1.5 * pq.s,
+            spiketrain = SpikeTrain(times=[1, 1.1, 1.2] * pq.ms,
+                                    t_stop=1.5 * pq.s,
                                     name="spikes with wf",
                                     description="spikes for waveform test",
                                     waveforms=waveforms)
             seg.spiketrains.append(spiketrain)
+            # add imagesequence
+            imgseq = ImageSequence(name="img1",
+                                   image_data=self.rquant((10, 20, 10), pq.mV),
+                                   frame_duration=pq.Quantity(1, "ms"),
+                                   spatial_scale=pq.meter)
 
+            seg.imagesequences.append(imgseq)
             # add signals
             asig = AnalogSignal(signal=self.rquant((19, 15), pq.mV),
                                 sampling_rate=pq.Quantity(10, "Hz"))
             seg.analogsignals.append(asig)
             irsig = IrregularlySampledSignal(signal=np.random.random((20, 30)),
                                              times=self.rquant(20, pq.ms, True),
                                              units=pq.A)
@@ -1414,18 +1628,20 @@
             event = Event(times=np.arange(0, 30, 10) * pq.s,
                           labels=np.array(["0", "1", "2"]),
                           name="event name",
                           description="event description")
             seg.events.append(event)
 
             # add channel index and unit
-            channel = ChannelIndex([0], channel_names=['mychannelname'], channel_ids=[4],
+            channel = ChannelIndex([0], channel_names=['mychannelname'],
+                                   channel_ids=[4],
                                    name=['testname'])
             block.channel_indexes.append(channel)
-            unit = Unit(name='myunit', description='blablabla', file_origin='fileA.nix',
+            unit = Unit(name='myunit', description='blablabla',
+                        file_origin='fileA.nix',
                         myannotation='myannotation')
             channel.units.append(unit)
             unit.spiketrains.append(spiketrain)
 
             # make sure everything is linked properly
             block.create_relationship()
 
@@ -1442,14 +1658,37 @@
 
         # reading data as lazy objects from file 1
         with NixIO_lazy(filename2) as io:
             block_lazy = io.read_block(lazy=True)
 
             self.write_and_compare([block_lazy])
 
+    def test_annotation_types(self):
+        annotations = {
+            "somedate": self.rdate(),
+            "now": datetime.now(),
+            "today": date.today(),
+            "sometime": time(13, 37, 42),
+            "somequantity": self.rquant(10, pq.ms),
+            "somestring": self.rsentence(3),
+            "npfloat": np.float(10),
+            "nparray": np.array([1, 2, 400]),
+            "emptystr": "",
+        }
+        wblock = Block("annotation_block", **annotations)
+        self.writer.write_block(wblock)
+        rblock = self.writer.read_block(neoname="annotation_block")
+        for k in annotations:
+            orig = annotations[k]
+            readval = rblock.annotations[k]
+            if isinstance(orig, np.ndarray):
+                np.testing.assert_almost_equal(orig, readval)
+            else:
+                self.assertEqual(annotations[k], rblock.annotations[k])
+
 
 @unittest.skipUnless(HAVE_NIX, "Requires NIX")
 class NixIOReadTest(NixIOTest):
     nixfile = None
     nix_blocks = None
 
     @classmethod
@@ -1519,14 +1758,15 @@
             neoblock = self.io.read_block(neoname=neoname)
             self.assertEqual(neoblock.annotations["nix_name"], nixblock.name)
 
     def test_array_annotations_read(self):
         for bl in self.io.read_all_blocks():
             nix_block = self.nixfile.blocks[bl.annotations['nix_name']]
             for seg in bl.segments:
+
                 for anasig in seg.analogsignals:
                     da = nix_block.data_arrays[anasig.annotations['nix_name'] + '.0']
                     self.assertIn('anasig_arr_ann', da.metadata)
                     self.assertIn('anasig_arr_ann', anasig.array_annotations)
                     nix_ann = da.metadata['anasig_arr_ann']
                     neo_ann = anasig.array_annotations['anasig_arr_ann']
                     self.assertTrue(np.all(nix_ann == neo_ann.magnitude))
@@ -1537,14 +1777,23 @@
                     self.assertIn('irrsig_arr_ann', da.metadata)
                     self.assertIn('irrsig_arr_ann', irrsig.array_annotations)
                     nix_ann = da.metadata['irrsig_arr_ann']
                     neo_ann = irrsig.array_annotations['irrsig_arr_ann']
                     self.assertTrue(np.all(nix_ann == neo_ann.magnitude))
                     self.assertEqual(da.metadata.props['irrsig_arr_ann'].unit,
                                      units_to_string(neo_ann.units))
+                for imgseq in seg.imagesequences:
+                    da = nix_block.data_arrays[imgseq.annotations['nix_name'] + '.0']
+                    self.assertIn('imgseq_arr_ann', da.metadata)
+                    self.assertIn('imgseq_arr_ann', imgseq.array_annotations)
+                    nix_ann = da.metadata['imgseq_arr_ann']
+                    neo_ann = imgseq.array_annotations['imgseq_arr_ann']
+                    self.assertTrue(np.all(nix_ann == neo_ann.magnitude))
+                    self.assertEqual(da.metadata.props['imgseq_arr_ann'].unit,
+                                     units_to_string(neo_ann.units))
                 for ev in seg.events:
                     da = nix_block.multi_tags[ev.annotations['nix_name']]
                     self.assertIn('ev_arr_ann', da.metadata)
                     self.assertIn('ev_arr_ann', ev.array_annotations)
                     nix_ann = da.metadata['ev_arr_ann']
                     neo_ann = ev.array_annotations['ev_arr_ann']
                     self.assertTrue(np.all(nix_ann == neo_ann.magnitude))
@@ -1565,14 +1814,27 @@
                     self.assertIn('st_arr_ann', st.array_annotations)
                     nix_ann = da.metadata['st_arr_ann']
                     neo_ann = st.array_annotations['st_arr_ann']
                     self.assertTrue(np.all(nix_ann == neo_ann.magnitude))
                     self.assertEqual(da.metadata.props['st_arr_ann'].unit,
                                      units_to_string(neo_ann.units))
 
+    def test_read_blocks_are_writable(self):
+        filename = os.path.join(self.tempdir, "testnixio_out.nix")
+        writer = NixIO(filename, "ow")
+
+        blocks = self.io.read_all_blocks()
+
+        try:
+            writer.write_all_blocks(blocks)
+        except Exception as exc:
+            self.fail('The following exception was raised when'
+                      + ' writing the blocks loaded with NixIO:\n'
+                      + str(exc))
+
 
 @unittest.skipUnless(HAVE_NIX, "Requires NIX")
 class NixIOContextTests(NixIOTest):
     def setUp(self):
         self.tempdir = mkdtemp(prefix="nixiotest")
         self.filename = os.path.join(self.tempdir, "testnixio.nix")
```

### Comparing `neo-0.8.0/neo/test/iotest/test_nsdfio.py` & `neo-0.9.0/neo/test/iotest/test_nsdfio.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.NSDFIO
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import numpy as np
 import quantities as pq
 from datetime import datetime
 import os
 
 import unittest
```

### Comparing `neo-0.8.0/neo/test/iotest/test_openephysio.py` & `neo-0.9.0/neo/test/iotest/test_openephysio.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import unittest
 
 import quantities as pq
 
 from neo.io import OpenEphysIO
 from neo.test.iotest.common_io_test import BaseTestIO
 from neo.test.rawiotest.test_openephysrawio import TestOpenEphysRawIO
```

### Comparing `neo-0.8.0/neo/test/iotest/test_pickleio.py` & `neo-0.9.0/neo/test/iotest/test_pickleio.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.io.pickleio.PickleIO class
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import os
 
 import unittest
 
 import numpy as np
 import quantities as pq
 
@@ -56,15 +52,15 @@
         self.assertIsInstance(r_seg.spiketrains[0].unit, Unit)
         self.assertIsInstance(r_seg.epochs[0], Epoch)
         os.remove('blk.pkl')
 
         # Epoch
         epoch = Epoch(times=np.arange(0, 30, 10) * pq.s,
                       durations=[10, 5, 7] * pq.ms,
-                      labels=np.array(['btn0', 'btn1', 'btn2'], dtype='S'))
+                      labels=np.array(['btn0', 'btn1', 'btn2'], dtype='U'))
         epoch.segment = Segment()
         blk = Block()
         seg = Segment()
         seg.epochs.append(epoch)
         blk.segments.append(seg)
 
         reader = PickleIO(filename="blk.pkl")
@@ -74,15 +70,15 @@
         r_blk = reader.read_block()
         r_seg = r_blk.segments[0]
         self.assertIsInstance(r_seg.epochs[0].segment, Segment)
         os.remove('blk.pkl')
 
         # Event
         event = Event(np.arange(0, 30, 10) * pq.s,
-                      labels=np.array(['trig0', 'trig1', 'trig2'], dtype='S'))
+                      labels=np.array(['trig0', 'trig1', 'trig2'], dtype='U'))
         event.segment = Segment()
 
         blk = Block()
         seg = Segment()
         seg.events.append(event)
         blk.segments.append(seg)
```

### Comparing `neo-0.8.0/neo/test/iotest/test_proxyobjects.py` & `neo-0.9.0/neo/test/iotest/test_proxyobjects.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests proxyobject mechanisms with ExampleRawIO
 """
 
 
 import unittest
```

### Comparing `neo-0.8.0/neo/test/iotest/test_spike2io.py` & `neo-0.9.0/neo/test/iotest/test_spike2io.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.spike2io
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
-
 import unittest
 
 import quantities as pq
 
 from neo.io import Spike2IO
 from neo.test.iotest.common_io_test import BaseTestIO
 
@@ -18,14 +14,15 @@
     ioclass = Spike2IO
     files_to_test = [
         'File_spike2_1.smr',
         'File_spike2_2.smr',
         'File_spike2_3.smr',
         '130322-1LY.smr',  # this is for bug 182
         'multi_sampling.smr',  # this is for bug 466
+        'Two-mice-bigfile-test000.smr',  # SONv9 file
     ]
     files_to_download = files_to_test
 
     def test_multi_sampling_no_grouping(self):
         """
         Some file can have several sampling_rate.
         This one contain 3 differents signals sampling rate
```

### Comparing `neo-0.8.0/neo/test/iotest/test_tdtio.py` & `neo-0.9.0/neo/test/iotest/test_tdtio.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.io.tdtio
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import, division
 import unittest
 from neo.io import TdtIO
 from neo.test.iotest.common_io_test import BaseTestIO
 from neo.test.iotest.tools import get_test_file_full_path
 import numpy as np
```

### Comparing `neo-0.8.0/neo/test/iotest/test_tiffio.py` & `neo-0.9.0/neo/test/iotest/test_tiffio.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-
 import unittest
 import os
 from PIL import Image
 import numpy as np
 import shutil
 from neo.io.tiffio import TiffIO
 import quantities as pq
```

### Comparing `neo-0.8.0/neo/test/iotest/tools.py` & `neo-0.9.0/neo/test/iotest/tools.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,13 @@
-# -*- coding: utf-8 -*-
 """
 Common tools that are useful for neo.io object tests
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
-import logging
 import os
 import shutil
-import tempfile
 
 from neo.core import Block, Segment
 from neo.test.generate_datasets import generate_from_supported_objects
 
 
 def close_object_safe(obj):
     """
```

### Comparing `neo-0.8.0/neo/test/rawiotest/common_rawio_test.py` & `neo-0.9.0/neo/test/rawiotest/common_rawio_test.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 Common tests for RawIOs:
 
 It is copy/paste from neo/test/iotests/common_io_test.py
 
 The code should be shared for common parts.
 
@@ -12,17 +11,14 @@
 To deposite new testing files,  please create a account at
 gin.g-node.org and upload files at NeuralEnsemble/ephy_testing_data
 data repo.
 
 
 '''
 
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 __test__ = False
 
 import os
 import logging
 import unittest
 
 from neo.test.rawiotest.tools import (can_use_network, make_all_directories,
@@ -31,15 +27,15 @@
 from neo.test.rawiotest import rawio_compliance as compliance
 
 
 # url_for_tests = "https://portal.g-node.org/neo/" #This is the old place
 url_for_tests = "https://web.gin.g-node.org/NeuralEnsemble/ephy_testing_data/raw/master/"
 
 
-class BaseTestRawIO(object):
+class BaseTestRawIO:
     '''
     This class make common tests for all IOs.
 
     Basically download files from G-node portal.
     And test the IO is working.
 
     '''
@@ -84,15 +80,15 @@
             raise unittest.SkipTest("Requires download of data from the web")
 
         url = url_for_tests + self.shortname
         try:
             make_all_directories(self.files_to_download, self.local_test_dir)
             download_test_file(self.files_to_download,
                                self.local_test_dir, url)
-        except IOError as exc:
+        except OSError as exc:
             raise unittest.SkipTest(exc)
 
     download_test_files_if_not_present.__test__ = False
 
     def cleanup_file(self, path):
         '''
         Remove test files or directories safely.
```

### Comparing `neo-0.8.0/neo/test/rawiotest/rawio_compliance.py` & `neo-0.9.0/neo/test/rawiotest/rawio_compliance.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Here a list for testing neo.rawio API compliance.
 This is called automatically by `BaseTestRawIO`
 
 All rules are listed as function so it should be easier to:
   * identify the rawio API
   * debug
@@ -73,15 +72,15 @@
         for seg_index in range(nb_seg):
             t_start = reader.segment_t_start(block_index=block_index, seg_index=seg_index)
             t_stop = reader.segment_t_stop(block_index=block_index, seg_index=seg_index)
             assert t_stop > t_start
 
             if nb_sig > 0:
                 if reader._several_channel_groups:
-                    channel_indexes_list = reader.get_group_channel_indexes()
+                    channel_indexes_list = reader.get_group_signal_channel_indexes()
                     for channel_indexes in channel_indexes_list:
                         sig_size = reader.get_signal_size(block_index, seg_index,
                                                           channel_indexes=channel_indexes)
                 else:
                     sig_size = reader.get_signal_size(block_index, seg_index,
                                                       channel_indexes=None)
 
@@ -130,15 +129,15 @@
     AKA _need_chan_index_check
     """
     nb_sig = reader.signal_channels_count()
     if nb_sig == 0:
         return
 
     if reader._several_channel_groups:
-        channel_indexes_list = reader.get_group_channel_indexes()
+        channel_indexes_list = reader.get_group_signal_channel_indexes()
     else:
         channel_indexes_list = [None]
 
     # read all chunk for all channel all block all segment
     for channel_indexes in channel_indexes_list:
         for raw_chunk in iter_over_sig_chunks(reader, channel_indexes, chunksize=1024):
             assert raw_chunk.ndim == 2
@@ -206,23 +205,45 @@
 
             assert float_chunk0.dtype == dt
             if unique_chan_name:
                 np.testing.assert_array_equal(float_chunk0, float_chunk1)
             if unique_chan_id:
                 np.testing.assert_array_equal(float_chunk0, float_chunk2)
 
+        # read 500ms with several chunksize
+        sr = reader.get_signal_sampling_rate(channel_indexes=channel_indexes)
+        lenght_to_read = int(.5 * sr)
+        if lenght_to_read < sig_size:
+            ref_raw_sigs = reader.get_analogsignal_chunk(block_index=block_index,
+                                                    seg_index=seg_index, i_start=0,
+                                                    i_stop=lenght_to_read,
+                                                    channel_indexes=channel_indexes)
+            for chunksize in (511, 512, 513, 1023, 1024, 1025):
+                i_start = 0
+                chunks = []
+                while i_start < lenght_to_read:
+                    i_stop = min(i_start + chunksize, lenght_to_read)
+                    raw_chunk = reader.get_analogsignal_chunk(block_index=block_index,
+                                                            seg_index=seg_index, i_start=i_start,
+                                                            i_stop=i_stop,
+                                                            channel_indexes=channel_indexes)
+                    chunks.append(raw_chunk)
+                    i_start += chunksize
+                chunk_raw_sigs = np.concatenate(chunks, axis=0)
+                np.testing.assert_array_equal(ref_raw_sigs, chunk_raw_sigs)
+
 
 def benchmark_speed_read_signals(reader):
     """
     A very basic speed measurement that read all signal
     in a file.
     """
 
     if reader._several_channel_groups:
-        channel_indexes_list = reader.get_group_channel_indexes()
+        channel_indexes_list = reader.get_group_signal_channel_indexes()
     else:
         channel_indexes_list = [None]
 
     for channel_indexes in channel_indexes_list:
         if channel_indexes is None:
             nb_sig = reader.signal_channels_count()
         else:
```

### Comparing `neo-0.8.0/neo/test/rawiotest/test_axographrawio.py` & `neo-0.9.0/neo/test/rawiotest/test_axographrawio.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,16 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.rawio.axographrawio
 """
 
-# needed for python 3 compatibility
-from __future__ import (unicode_literals, print_function, division,
-                        absolute_import)
-
 import unittest
 
 from neo.rawio.axographrawio import AxographRawIO
 from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
 
 
 class TestAxographRawIO(BaseTestRawIO, unittest.TestCase):
@@ -18,13 +13,16 @@
     files_to_download = [
         'AxoGraph_Graph_File',      # version 1 file, provided with AxoGraph
         'AxoGraph_Digitized_File',  # version 2 file, provided with AxoGraph
         'AxoGraph_X_File.axgx',     # version 5 file, provided with AxoGraph
         'File_axograph.axgd',       # version 6 file
         'episodic.axgd',
         'events_and_epochs.axgx',
+        'written-by-axographio-with-linearsequence.axgx',
+        'written-by-axographio-without-linearsequence.axgx',
+        'corrupt-comment.axgx',
     ]
     entities_to_test = files_to_download
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `neo-0.8.0/neo/test/rawiotest/test_axonrawio.py` & `neo-0.9.0/neo/test/rawiotest/test_axonrawio.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,7 @@
-# -*- coding: utf-8 -*-
-
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 import unittest
 
 from neo.rawio.axonrawio import AxonRawIO
 
 from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
 
 
@@ -16,14 +11,15 @@
         'File_axon_1.abf',  # V2.0
         'File_axon_2.abf',  # V1.8
         'File_axon_3.abf',  # V1.8
         'File_axon_4.abf',  # 2.0
         'File_axon_5.abf',  # V.20
         'File_axon_6.abf',  # V.20
         'File_axon_7.abf',  # V2.6
+        'test_file_edr3.abf',  # EDR3
     ]
     files_to_download = entities_to_test
 
     def test_read_raw_protocol(self):
         reader = AxonRawIO(filename=self.get_filename_path('File_axon_7.abf'))
         reader.parse_header()
```

### Comparing `neo-0.8.0/neo/test/rawiotest/test_blackrockrawio.py` & `neo-0.9.0/neo/test/rawiotest/test_blackrockrawio.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,11 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.rawio.examplerawio
 """
 
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 import unittest
 
 from neo.rawio.blackrockrawio import BlackrockRawIO
 from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
 
 import numpy as np
 from numpy.testing import assert_equal
```

### Comparing `neo-0.8.0/neo/test/rawiotest/test_brainvisionrawio.py` & `neo-0.9.0/neo/test/iotest/test_brainvisionio.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,30 +1,26 @@
-# -*- coding: utf-8 -*-
 """
-
+Tests of neo.io.brainvisionio
 """
 
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 import unittest
 
-from neo.rawio.brainvisionrawio import BrainVisionRawIO
+from neo.io import BrainVisionIO
 
-from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
+from neo.test.iotest.common_io_test import BaseTestIO
 
 
-class TestBrainVisionRawIO(BaseTestRawIO, unittest.TestCase, ):
-    rawioclass = BrainVisionRawIO
-    entities_to_test = ['File_brainvision_1.vhdr',
-                        'File_brainvision_2.vhdr',
-                        'File_brainvision_3_float32.vhdr',
-                        'File_brainvision_3_int16.vhdr',
-                        'File_brainvision_3_int32.vhdr',
-                        ]
+class TestBrainVisionIO(BaseTestIO, unittest.TestCase, ):
+    ioclass = BrainVisionIO
+    files_to_test = ['File_brainvision_1.vhdr',
+                     'File_brainvision_2.vhdr',
+                     'File_brainvision_3_float32.vhdr',
+                     'File_brainvision_3_int16.vhdr',
+                     'File_brainvision_3_int32.vhdr',
+                     ]
     files_to_download = ['File_brainvision_1.eeg',
                          'File_brainvision_1.vhdr',
                          'File_brainvision_1.vmrk',
                          'File_brainvision_2.eeg',
                          'File_brainvision_2.vhdr',
                          'File_brainvision_2.vmrk',
                          'File_brainvision_3_float32.eeg',
```

### Comparing `neo-0.8.0/neo/test/rawiotest/test_examplerawio.py` & `neo-0.9.0/neo/test/rawiotest/test_examplerawio.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests of neo.rawio.examplerawio
 
 Note for dev:
 if you write a new RawIO class your need to put some file
 to be tested at g-node portal, Ask neuralensemble list for that.
 The file need to be small.
@@ -19,17 +18,14 @@
 See neo.test.iotest.*
 
 
 Author: Samuel Garcia
 
 """
 
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 import unittest
 
 from neo.rawio.examplerawio import ExampleRawIO
 
 from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
```

### Comparing `neo-0.8.0/neo/test/rawiotest/test_openephysrawio.py` & `neo-0.9.0/neo/test/rawiotest/test_openephysrawio.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,12 +1,7 @@
-# -*- coding: utf-8 -*-
-
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 import unittest
 
 from neo.rawio.openephysrawio import OpenEphysRawIO
 from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
 
 
 class TestOpenEphysRawIO(BaseTestRawIO, unittest.TestCase, ):
```

### Comparing `neo-0.8.0/neo/test/rawiotest/test_tdtrawio.py` & `neo-0.9.0/neo/test/rawiotest/test_tdtrawio.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,12 +1,7 @@
-# -*- coding: utf-8 -*-
-
-# needed for python 3 compatibility
-from __future__ import unicode_literals, print_function, division, absolute_import
-
 import unittest
 
 from neo.rawio.tdtrawio import TdtRawIO
 from neo.test.rawiotest.common_rawio_test import BaseTestRawIO
 
 
 class TestTdtRawIO(BaseTestRawIO, unittest.TestCase, ):
```

### Comparing `neo-0.8.0/neo/test/rawiotest/tools.py` & `neo-0.9.0/neo/test/rawiotest/tools.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,24 +1,16 @@
-# -*- coding: utf-8 -*-
 """
 Common tools that are useful for neo.io object tests
 """
 
-# needed for python 3 compatibility
-from __future__ import absolute_import
-
 import logging
 import os
-import shutil
 import tempfile
 
-try:
-    from urllib2 import urlopen
-except ImportError:
-    from urllib.request import urlopen
+from urllib.request import urlopen
 
 
 def can_use_network():
     """
     Return True if network access is allowed
     """
     if os.environ.get('NOSETESTS_NO_NETWORK', False):
```

### Comparing `neo-0.8.0/neo/test/test_utils.py` & `neo-0.9.0/neo/test/test_utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 """
 Tests of the neo.utils module
 """
 
 import unittest
 
 import numpy as np
@@ -28,16 +27,18 @@
     def setUp(self):
         self.reader = ExampleRawIO(filename='my_filename.fake')
         self.reader.parse_header()
 
 
 class TestUtilsWithoutProxyObjects(unittest.TestCase):
     def test__get_events(self):
-        starts_1 = Event(times=[0.5, 10.0, 25.2] * pq.s)
-        starts_1.annotate(event_type='trial start', pick='me')
+        starts_1 = Event(times=[0.5, 10.0, 25.2] * pq.s,
+                         labels=['label1', 'label2', 'label3'],
+                         name='pick_me')
+        starts_1.annotate(event_type='trial start')
         starts_1.array_annotate(trial_id=[1, 2, 3])
 
         stops_1 = Event(times=[5.5, 14.9, 30.1] * pq.s)
         stops_1.annotate(event_type='trial stop')
         stops_1.array_annotate(trial_id=[1, 2, 3])
 
         starts_2 = Event(times=[33.2, 41.7, 52.4] * pq.s)
@@ -52,17 +53,17 @@
         seg2 = Segment()
         seg.events = [starts_1, stops_1]
         seg2.events = [starts_2, stops_2]
 
         block = Block()
         block.segments = [seg, seg2]
 
-        # test getting one whole event via annotation
+        # test getting one whole event via annotation or attribute
         extracted_starts1 = get_events(seg, event_type='trial start')
-        extracted_starts1b = get_events(block, pick='me')
+        extracted_starts1b = get_events(block, name='pick_me')
 
         self.assertEqual(len(extracted_starts1), 1)
         self.assertEqual(len(extracted_starts1b), 1)
 
         extracted_starts1 = extracted_starts1[0]
         extracted_starts1b = extracted_starts1b[0]
 
@@ -124,14 +125,28 @@
         self.assertEqual(starts_1.name, trials_1_2.name)
         self.assertEqual(starts_1.description, trials_1_2.description)
         self.assertEqual(starts_1.file_origin, trials_1_2.file_origin)
         self.assertEqual(starts_1.annotations['event_type'], trials_1_2.annotations['event_type'])
         assert_arrays_equal(trials_1_2.array_annotations['trial_id'], np.array([1, 2]))
         self.assertIsInstance(trials_1_2.array_annotations, ArrayDict)
 
+        # test selecting event times by label
+        trials_1_2 = get_events(block, labels=['label1', 'label2'])
+
+        self.assertEqual(len(trials_1_2), 1)
+
+        trials_1_2 = trials_1_2[0]
+
+        self.assertEqual(starts_1.name, trials_1_2.name)
+        self.assertEqual(starts_1.description, trials_1_2.description)
+        self.assertEqual(starts_1.file_origin, trials_1_2.file_origin)
+        self.assertEqual(starts_1.annotations['event_type'], trials_1_2.annotations['event_type'])
+        assert_arrays_equal(trials_1_2.array_annotations['trial_id'], np.array([1, 2]))
+        self.assertIsInstance(trials_1_2.array_annotations, ArrayDict)
+
         # test getting more than one event time of more than one event
         trials_1_2b = get_events(block, trial_id=[1, 2])
 
         self.assertEqual(len(trials_1_2b), 2)
 
         start_idx = np.where(np.array([ev.annotations['event_type']
                                        for ev in trials_1_2b]) == 'trial start')[0][0]
@@ -342,28 +357,28 @@
                         waveforms=np.array([[[0., 1.], [0.1, 1.1]], [[2., 3.], [2.1, 3.1]],
                                             [[4., 5.], [4.1, 5.1]], [[6., 7.], [6.1, 7.1]],
                                             [[8., 9.], [8.1, 9.1]], [[12., 13.], [12.1, 13.1]],
                                             [[14., 15.], [14.1, 15.1]],
                                             [[16., 17.], [16.1, 17.1]]]) * pq.mV,
                         array_annotations={'spikenum': np.arange(1, 9)})
 
+        # test without resetting the time
         seg = Segment()
         seg2 = Segment(name='NoCut')
         seg.epochs = [epoch, epoch2]
         seg.events = [event]
         seg.analogsignals = [anasig]
         seg.irregularlysampledsignals = [irrsig]
         seg.spiketrains = [st]
 
-        block = Block()
-        block.segments = [seg, seg2]
-        block.create_many_to_one_relationship()
+        original_block = Block()
+        original_block.segments = [seg, seg2]
+        original_block.create_many_to_one_relationship()
 
-        # test without resetting the time
-        cut_block_by_epochs(block, properties={'pick': 'me'})
+        block = cut_block_by_epochs(original_block, properties={'pick': 'me'})
 
         assert_neo_object_is_compliant(block)
         self.assertEqual(len(block.segments), 3)
 
         for epoch_idx in range(len(epoch)):
             self.assertEqual(len(block.segments[epoch_idx].events), 1)
             self.assertEqual(len(block.segments[epoch_idx].spiketrains), 1)
@@ -394,28 +409,28 @@
         assert_same_attributes(block.segments[0].epochs[0],
                                epoch.time_slice(t_start=epoch.times[0],
                                                  t_stop=epoch.times[0] + epoch.durations[0]))
         assert_same_attributes(block.segments[0].epochs[1],
                                epoch2.time_slice(t_start=epoch.times[0],
                                                 t_stop=epoch.times[0] + epoch.durations[0]))
 
+        # test with resetting the time
         seg = Segment()
         seg2 = Segment(name='NoCut')
         seg.epochs = [epoch, epoch2]
         seg.events = [event]
         seg.analogsignals = [anasig]
         seg.irregularlysampledsignals = [irrsig]
         seg.spiketrains = [st]
 
-        block = Block()
-        block.segments = [seg, seg2]
-        block.create_many_to_one_relationship()
+        original_block = Block()
+        original_block.segments = [seg, seg2]
+        original_block.create_many_to_one_relationship()
 
-        # test with resetting the time
-        cut_block_by_epochs(block, properties={'pick': 'me'}, reset_time=True)
+        block = cut_block_by_epochs(original_block, properties={'pick': 'me'}, reset_time=True)
 
         assert_neo_object_is_compliant(block)
         self.assertEqual(len(block.segments), 3)
 
         for epoch_idx in range(len(epoch)):
             self.assertEqual(len(block.segments[epoch_idx].events), 1)
             self.assertEqual(len(block.segments[epoch_idx].spiketrains), 1)
@@ -564,19 +579,19 @@
         seg.epochs.append(proxy_epoch)
 
         loaded_epoch = proxy_epoch.load()
         loaded_event = proxy_event.load()
         loaded_st = proxy_st.load()
         loaded_anasig = proxy_anasig.load()
 
-        block = Block()
-        block.segments = [seg]
-        block.create_many_to_one_relationship()
+        original_block = Block()
+        original_block.segments = [seg]
+        original_block.create_many_to_one_relationship()
 
-        cut_block_by_epochs(block, properties={'pick': 'me'})
+        block = cut_block_by_epochs(original_block, properties={'pick': 'me'})
 
         assert_neo_object_is_compliant(block)
         self.assertEqual(len(block.segments), proxy_epoch.shape[0])
 
         for epoch_idx in range(len(loaded_epoch)):
             sliced_event = loaded_event.time_slice(t_start=loaded_epoch.times[epoch_idx],
                                                  t_stop=loaded_epoch.times[epoch_idx]
@@ -618,20 +633,24 @@
         seg2.epochs = [proxy_epoch, epoch]
         block2.segments = [seg2]
         block2.create_many_to_one_relationship()
 
         # test correct loading and slicing of EpochProxy objects
         # (not tested above since we used the EpochProxy to cut the block)
 
-        cut_block_by_epochs(block2, properties={'pick': 'me instead'})
+        block3 = cut_block_by_epochs(block2, properties={'pick': 'me instead'})
 
         for epoch_idx in range(len(epoch)):
             sliced_epoch = loaded_epoch.time_slice(t_start=epoch.times[epoch_idx],
                                                    t_stop=epoch.times[epoch_idx]
                                                           + epoch.durations[epoch_idx])
             has_epoch = len(sliced_epoch) > 0
 
             if has_epoch:
-                self.assertTrue(isinstance(block2.segments[epoch_idx].epochs[0],
+                self.assertTrue(isinstance(block3.segments[epoch_idx].epochs[0],
                                            Epoch))
-                assert_same_attributes(block2.segments[epoch_idx].epochs[0],
+                assert_same_attributes(block3.segments[epoch_idx].epochs[0],
                                        sliced_epoch)
+
+
+if __name__ == "__main__":
+    unittest.main()
```

### Comparing `neo-0.8.0/neo/test/tools.py` & `neo-0.9.0/neo/test/tools.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-# -*- coding: utf-8 -*-
 '''
 Tools for use with neo tests.
 '''
 
 import hashlib
 import os
 
@@ -148,24 +147,25 @@
                 if attrtype == np.ndarray:
                     dtp = ioattr[3]
                     assert obattr.dtype.kind == dtp.kind, '%s.%s dtype.kind is %s should be %s' \
                                                           '' % (classname, attrname,
                                                                 obattr.dtype.kind, dtp.kind)
 
     # test bijectivity : parents and children
-    for container in getattr(ob, '_single_child_containers', []):
-        for i, child in enumerate(getattr(ob, container, [])):
-            assert hasattr(child, _reference_name(
-                classname)), '%s should have %s attribute (2 way relationship)' \
-                             '' % (container, _reference_name(classname))
-            if hasattr(child, _reference_name(classname)):
-                parent = getattr(child, _reference_name(classname))
-                assert parent == ob, '%s.%s %s is not symmetric with %s.%s' \
-                                     '' % (container, _reference_name(classname), i, classname,
-                                           container)
+    if classname != "Group":  # objects in a Group do not keep a reference to the group.
+        for container in getattr(ob, '_single_child_containers', []):
+            for i, child in enumerate(getattr(ob, container, [])):
+                assert hasattr(child, _reference_name(
+                    classname)), '%s should have %s attribute (2 way relationship)' \
+                                '' % (container, _reference_name(classname))
+                if hasattr(child, _reference_name(classname)):
+                    parent = getattr(child, _reference_name(classname))
+                    assert parent == ob, '%s.%s %s is not symmetric with %s.%s' \
+                                        '' % (container, _reference_name(classname), i, classname,
+                                            container)
 
     # recursive on one to many rel
     for i, child in enumerate(getattr(ob, 'children', [])):
         try:
             assert_neo_object_is_compliant(child)
         # intercept exceptions and add more information
         except BaseException as exc:
```

### Comparing `neo-0.8.0/neo/utils.py` & `neo-0.9.0/neo/utils.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,17 +1,15 @@
-# -*- coding: utf-8 -*-
 '''
 This module defines multiple utility functions for filtering, creation, slicing,
 etc. of neo.core objects.
 '''
 
 import neo
 import copy
 import warnings
-import inspect
 import numpy as np
 import quantities as pq
 
 
 def get_events(container, **properties):
     """
     This function returns a list of Event objects, corresponding to given
@@ -45,31 +43,34 @@
     Returns:
     --------
     events: list
         A list of Event objects matching the given criteria.
 
     Example:
     --------
+        >>> import neo
+        >>> from neo.utils import get_events
+        >>> import quantities as pq
         >>> event = neo.Event(times=[0.5, 10.0, 25.2] * pq.s)
-        >>> event.annotate(event_type='trial start',
-                           trial_id=[1, 2, 3])
+        >>> event.annotate(event_type='trial start')
+        >>> event.array_annotate(trial_id=[1, 2, 3])
         >>> seg = neo.Segment()
         >>> seg.events = [event]
 
         # Will return a list with the complete event object
-        >>> get_events(seg, properties={'event_type': 'trial start'})
+        >>> get_events(seg, event_type='trial start')
 
         # Will return an empty list
-        >>> get_events(seg, properties={'event_type': 'trial stop'})
+        >>> get_events(seg, event_type='trial stop')
 
         # Will return a list with an Event object, but only with trial 2
-        >>> get_events(seg, properties={'trial_id': 2})
+        >>> get_events(seg, trial_id=2)
 
         # Will return a list with an Event object, but only with trials 1 and 2
-        >>> get_events(seg, properties={'trial_id': [1, 2]})
+        >>> get_events(seg, trial_id=[1, 2])
     """
     if isinstance(container, neo.Segment):
         return _get_from_list(container.events, prop=properties)
 
     elif isinstance(container, neo.Block):
         event_lst = []
         for seg in container.segments:
@@ -114,32 +115,35 @@
     Returns:
     --------
     epochs: list
         A list of Epoch objects matching the given criteria.
 
     Example:
     --------
+        >>> import neo
+        >>> from neo.utils import get_epochs
+        >>> import quantities as pq
         >>> epoch = neo.Epoch(times=[0.5, 10.0, 25.2] * pq.s,
-                              durations = [100, 100, 100] * pq.ms)
-        >>> epoch.annotate(event_type='complete trial',
-                           trial_id=[1, 2, 3])
+        ...                   durations=[100, 100, 100] * pq.ms,
+        ...                   epoch_type='complete trial')
+        >>> epoch.array_annotate(trial_id=[1, 2, 3])
         >>> seg = neo.Segment()
         >>> seg.epochs = [epoch]
 
         # Will return a list with the complete event object
-        >>> get_epochs(seg, prop={'epoch_type': 'complete trial'})
+        >>> get_epochs(seg, epoch_type='complete trial')
 
         # Will return an empty list
-        >>> get_epochs(seg, prop={'epoch_type': 'error trial'})
+        >>> get_epochs(seg, epoch_type='error trial')
 
         # Will return a list with an Event object, but only with trial 2
-        >>> get_epochs(seg, prop={'trial_id': 2})
+        >>> get_epochs(seg, trial_id=2)
 
         # Will return a list with an Event object, but only with trials 1 and 2
-        >>> get_epochs(seg, prop={'trial_id': [1, 2]})
+        >>> get_epochs(seg, trial_id=[1, 2])
     """
     if isinstance(container, neo.Segment):
         return _get_from_list(container.epochs, prop=properties)
 
     elif isinstance(container, neo.Block):
         epoch_list = []
         for seg in container.segments:
@@ -214,127 +218,50 @@
     return _event_epoch_slice_by_valid_ids(obj, valid_ids)
 
 
 def _event_epoch_slice_by_valid_ids(obj, valid_ids):
     """
     Internal function
     """
-    # modify annotations
-    sparse_annotations = _get_valid_annotations(obj, valid_ids)
-
-    # modify array annotations
-    sparse_array_annotations = {key: value[valid_ids]
-                                for key, value in obj.array_annotations.items() if len(value)}
-
-    if obj.labels is not None and obj.labels.size > 0:
-        labels = obj.labels[valid_ids]
-    else:
-        labels = obj.labels
-    if type(obj) is neo.Event:
-        sparse_obj = neo.Event(
-            times=copy.deepcopy(obj.times[valid_ids]),
-            labels=copy.deepcopy(labels),
-            units=copy.deepcopy(obj.units),
-            name=copy.deepcopy(obj.name),
-            description=copy.deepcopy(obj.description),
-            file_origin=copy.deepcopy(obj.file_origin),
-            array_annotations=sparse_array_annotations,
-            **sparse_annotations)
-    elif type(obj) is neo.Epoch:
-        sparse_obj = neo.Epoch(
-            times=copy.deepcopy(obj.times[valid_ids]),
-            durations=copy.deepcopy(obj.durations[valid_ids]),
-            labels=copy.deepcopy(labels),
-            units=copy.deepcopy(obj.units),
-            name=copy.deepcopy(obj.name),
-            description=copy.deepcopy(obj.description),
-            file_origin=copy.deepcopy(obj.file_origin),
-            array_annotations=sparse_array_annotations,
-            **sparse_annotations)
+    if type(obj) is neo.Event or type(obj) is neo.Epoch:
+        sparse_obj = copy.deepcopy(obj[valid_ids])
     else:
         raise TypeError('Can only slice Event and Epoch objects by valid IDs.')
 
     return sparse_obj
 
 
 def _get_valid_ids(obj, annotation_key, annotation_value):
     """
     Internal function
     """
-    # wrap annotation value to be list
-    if not type(annotation_value) in [list, np.ndarray]:
-        annotation_value = [annotation_value]
-
-    # get all real attributes of object
-    attributes = inspect.getmembers(obj)
-    attributes_names = [t[0] for t in attributes if not(
-        t[0].startswith('__') and t[0].endswith('__'))]
-    attributes_ids = [i for i, t in enumerate(attributes) if not(
-        t[0].startswith('__') and t[0].endswith('__'))]
-
-    # check if annotation is present
-    value_avail = False
-    if annotation_key in obj.annotations:
-        check_value = obj.annotations[annotation_key]
-        value_avail = True
-    elif annotation_key in obj.array_annotations:
-        check_value = obj.array_annotations[annotation_key]
-        value_avail = True
-    elif annotation_key in attributes_names:
-        check_value = attributes[attributes_ids[
-            attributes_names.index(annotation_key)]][1]
-        value_avail = True
-
-    if value_avail:
-        # check if annotation is list and fits to length of object list
-        if not _is_annotation_list(check_value, len(obj)):
-            # check if annotation is single value and fits to requested value
-            if check_value in annotation_value:
-                valid_mask = np.ones(obj.shape)
-            else:
-                valid_mask = np.zeros(obj.shape)
-                if type(check_value) != str:
-                    warnings.warn(
-                        'Length of annotation "%s" (%s) does not fit '
-                        'to length of object list (%s)' % (
-                            annotation_key, len(check_value), len(obj)))
 
-        # extract object entries, which match requested annotation
-        else:
-            valid_mask = np.zeros(obj.shape)
-            for obj_id in range(len(obj)):
-                if check_value[obj_id] in annotation_value:
-                    valid_mask[obj_id] = True
-    else:
-        valid_mask = np.zeros(obj.shape)
+    valid_mask = np.zeros(obj.shape)
 
-    valid_ids = np.where(valid_mask)[0]
+    if annotation_key in obj.annotations and obj.annotations[annotation_key] == annotation_value:
+        valid_mask = np.ones(obj.shape)
 
-    return valid_ids
+    elif annotation_key == 'labels':
+        # wrap annotation value to be list
+        if not type(annotation_value) in [list, np.ndarray]:
+            annotation_value = [annotation_value]
+        valid_mask = np.in1d(obj.labels, annotation_value)
 
+    elif annotation_key in obj.array_annotations:
+        # wrap annotation value to be list
+        if not type(annotation_value) in [list, np.ndarray]:
+            annotation_value = [annotation_value]
+        valid_mask = np.in1d(obj.array_annotations[annotation_key], annotation_value)
 
-def _get_valid_annotations(obj, valid_ids):
-    """
-    Internal function
-    """
-    sparse_annotations = copy.deepcopy(obj.annotations)
-    for key in sparse_annotations:
-        if _is_annotation_list(sparse_annotations[key], len(obj)):
-            sparse_annotations[key] = list(np.array(sparse_annotations[key])[
-                valid_ids])
-    return sparse_annotations
+    elif hasattr(obj, annotation_key) and getattr(obj, annotation_key) == annotation_value:
+        valid_mask = np.ones(obj.shape)
 
+    valid_ids = np.where(valid_mask)[0]
 
-def _is_annotation_list(value, exp_length):
-    """
-    Internal function
-    """
-    return (
-        (isinstance(value, list) or (
-            isinstance(value, np.ndarray) and value.ndim > 0)) and (len(value) == exp_length))
+    return valid_ids
 
 
 def add_epoch(
         segment, event1, event2=None, pre=0 * pq.s, post=0 * pq.s,
         attach_result=True, **kwargs):
     """
     Create Epochs around a single Event, or between pairs of events. Starting
@@ -409,22 +336,21 @@
             'Requested durations %s.' % durations)
     elif any(durations == 0):
         raise ValueError('Can not create epoch with zero duration.')
 
     if 'name' not in kwargs:
         kwargs['name'] = 'epoch'
     if 'labels' not in kwargs:
-        # this needs to be changed to '%s_%i' % (kwargs['name'], i) for i in range(len(times))]
-        # when labels become unicode
-        kwargs['labels'] = [
-            ('%s_%i' % (kwargs['name'], i)).encode('ascii') for i in range(len(times))]
+        kwargs['labels'] = [u'{}_{}'.format(kwargs['name'], i)
+                            for i in range(len(times))]
 
     ep = neo.Epoch(times=times, durations=durations, **kwargs)
 
     ep.annotate(**event1.annotations)
+    ep.array_annotate(**event1.array_annotations)
 
     if attach_result:
         segment.epochs.append(ep)
         segment.create_relationship()
 
     return ep
 
@@ -512,18 +438,18 @@
 
     Parameters
     ----------
     block: Block
         Contains the Segments to cut according to the Epoch criteria provided
     properties: dictionary
         A dictionary that contains the Epoch keys and values to filter for.
-        Each key of the dictionary is matched to an attribute or an an
-        annotation of the Event. The value of each dictionary entry corresponds
-        to a valid entry or a list of valid entries of the attribute or
-        annotation.
+        Each key of the dictionary is matched to an attribute or an
+        annotation or an array_annotation of the Event.
+        The value of each dictionary entry corresponds to a valid entry or a
+        list of valid entries of the attribute or (array) annotation.
 
         If the value belonging to the key is a list of entries of the same
         length as the number of epochs in the Epoch object, the list entries
         are matched to the epochs in the Epoch object. The resulting Epoch
         object contains only those epochs where the values match up.
 
         Otherwise, the value is compared to the attributes or annotation of the
@@ -543,16 +469,17 @@
     --------
     None
     """
     if not isinstance(block, neo.Block):
         raise TypeError(
             'block needs to be a Block, not %s' % type(block))
 
-    old_segments = copy.copy(block.segments)
-    for seg in old_segments:
+    new_block = neo.Block()
+
+    for seg in block.segments:
         epochs = _get_from_list(seg.epochs, prop=properties)
         if len(epochs) > 1:
             warnings.warn(
                 'Segment %s contains multiple epochs with '
                 'requested properties (%s). Sub-segments can '
                 'have overlapping times' % (seg.name, properties))
 
@@ -560,18 +487,19 @@
             warnings.warn(
                 'No epoch is matching the requested epoch properties %s. '
                 'No cutting of segment %s performed.' % (properties, seg.name))
 
         for epoch in epochs:
             new_segments = cut_segment_by_epoch(
                 seg, epoch=epoch, reset_time=reset_time)
-            block.segments += new_segments
+            new_block.segments.extend(new_segments)
+
+    new_block.create_many_to_one_relationship(force=True)
 
-        block.segments.remove(seg)
-    block.create_many_to_one_relationship(force=True)
+    return new_block
 
 
 def cut_segment_by_epoch(seg, epoch, reset_time=False):
     """
     Cuts a Segment according to an Epoch object
 
     The function returns a list of Segments, where each segment corresponds
@@ -601,37 +529,99 @@
         SpikeTrain Objects will be generated and returned. Each Segment will
         receive the annotations of the corresponding epoch in the input.
     """
     if not isinstance(seg, neo.Segment):
         raise TypeError(
             'Seg needs to be of type Segment, not %s' % type(seg))
 
-    if type(seg.parents[0]) != neo.Block:
-        raise ValueError(
-            'Segment has no block as parent. Can not cut segment.')
-
     if not isinstance(epoch, neo.Epoch):
         raise TypeError(
             'Epoch needs to be of type Epoch, not %s' % type(epoch))
 
     segments = []
     for ep_id in range(len(epoch)):
         subseg = seg.time_slice(epoch.times[ep_id],
                                 epoch.times[ep_id] + epoch.durations[ep_id],
                                 reset_time=reset_time)
 
-        # Add annotations of Epoch
-        for a in epoch.annotations:
-            if type(epoch.annotations[a]) is list \
-                    and len(epoch.annotations[a]) == len(epoch):
-                subseg.annotations[a] = copy.copy(epoch.annotations[a][ep_id])
-            else:
-                subseg.annotations[a] = copy.copy(epoch.annotations[a])
+        subseg.annotate(**copy.copy(epoch.annotations))
 
         # Add array-annotations of Epoch
         for key, val in epoch.array_annotations.items():
             if len(val):
                 subseg.annotations[key] = copy.copy(val[ep_id])
 
         segments.append(subseg)
 
     return segments
+
+
+def is_block_rawio_compatible(block, return_problems=False):
+    """
+    The neo.rawio layer have some restriction compared to neo.io layer:
+      * consistent channels across segments
+      * no IrregularlySampledSignal
+      * consistent sampling rate across segments
+
+    This function tests if a neo.Block that could be written in a nix file could be read
+    back with the NIXRawIO.
+
+    Parameters
+    ----------
+    block: Block
+        A block
+    return_problems: bool (False by default)
+        Controls whether a list of str that describe problems is also provided as return value
+
+    Returns:
+    --------
+    is_rawio_compatible: bool
+        Compatible or not.
+    problems: list of str
+        Optional, depending on value of `return_problems`.
+        A list that describe problems for rawio compatibility.
+    """
+    assert len(block.segments) > 0, "This block doesn't have segments"
+
+    problems = []
+
+    # check that all Segments have the same number of object.
+    n_sig = len(block.segments[0].analogsignals)
+    n_st = len(block.segments[0].spiketrains)
+    n_ev = len(block.segments[0].events)
+    n_ep = len(block.segments[0].epochs)
+    sig_count_consistent = True
+    for seg in block.segments:
+        if len(seg.analogsignals) != n_sig:
+            problems.append('Number of AnalogSignals is not consistent across segments')
+            sig_count_consistent = False
+        if len(seg.spiketrains) != n_st:
+            problems.append('Number of SpikeTrains is not consistent across segments')
+        if len(seg.events) != n_ev:
+            problems.append('Number of Events is not consistent across segments')
+        if len(seg.epochs) != n_ep:
+            problems.append('Number of Epochs is not consistent across segments')
+
+    # check for AnalogSigal that sampling_rate/units/number of channel
+    # is consistent across segments.
+    if sig_count_consistent:
+        seg0 = block.segments[0]
+        for i in range(n_sig):
+            for seg in block.segments:
+                if seg.analogsignals[i].sampling_rate != seg0.analogsignals[i].sampling_rate:
+                    problems.append('AnalogSignals have inconsistent sampling rate across segments')
+                if seg.analogsignals[i].shape[1] != seg0.analogsignals[i].shape[1]:
+                    problems.append('AnalogSignals have inconsistent channel count across segments')
+                if seg.analogsignals[i].units != seg0.analogsignals[i].units:
+                    problems.append('AnalogSignals have inconsistent units across segments')
+
+    # check no IrregularlySampledSignal
+    for seg in block.segments:
+        if len(seg.irregularlysampledsignals) > 0:
+            problems.append('IrregularlySampledSignals are not raw compatible')
+
+    # returns
+    is_rawio_compatible = (len(problems) == 0)
+    if return_problems:
+        return is_rawio_compatible, problems
+    else:
+        return is_rawio_compatible
```

### Comparing `neo-0.8.0/neo.egg-info/PKG-INFO` & `neo-0.9.0/neo.egg-info/PKG-INFO`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: neo
-Version: 0.8.0
+Version: 0.9.0
 Summary: Neo is a package for representing electrophysiology data in Python, together with support for reading a wide range of neurophysiology file formats
 Home-page: https://neuralensemble.org/neo
 Author: Neo authors and contributors
 Author-email: samuel.garcia@cnrs.fr
 License: BSD-3-Clause
 Description: ===
         Neo
@@ -17,15 +17,15 @@
         
         The goal of Neo is to improve interoperability between Python tools for
         analyzing, visualizing and generating electrophysiology data by providing a common,
         shared object model. In order to be as lightweight a dependency as possible,
         Neo is deliberately limited to represention of data, with no functions for data
         analysis or visualization.
         
-        Neo is used by a number of other software tools, including 
+        Neo is used by a number of other software tools, including
         SpykeViewer_ (data analysis and visualization), Elephant_ (data analysis),
         the G-node_ suite (databasing), PyNN_ (simulations), tridesclous_ (spike sorting)
         and ephyviewer_ (data visualization).
         OpenElectrophy_ (data analysis and visualization) uses an older version of neo.
         
         Neo implements a hierarchical data model well adapted to intracellular and
         extracellular electrophysiology and EEG data with support for multi-electrodes
@@ -60,17 +60,26 @@
         - Documentation: http://neo.readthedocs.io/
         - Bug reports: https://github.com/NeuralEnsemble/python-neo/issues
         
         For installation instructions, see doc/source/install.rst
         
         To cite Neo in publications, see CITATION.txt
         
-        :copyright: Copyright 2010-2018 by the Neo team, see doc/source/authors.rst.
+        :copyright: Copyright 2010-2020 by the Neo team, see doc/source/authors.rst.
         :license: 3-Clause Revised BSD License, see LICENSE.txt for details.
         
+        Funding
+        -------
+        
+        Development of PyNN has been partially funded by the European Union Sixth Framework Program (FP6) under
+        grant agreement FETPI-015879 (FACETS), by the European Union Seventh Framework Program (FP7/2007-2013)
+        under grant agreements no. 269921 (BrainScaleS) and no. 604102 (HBP),
+        and by the European Unions Horizon 2020 Framework Programme for
+        Research and Innovation under the Specific Grant Agreements No. 720270 (Human Brain Project SGA1),
+        No. 785907 (Human Brain Project SGA2) and No. 945539 (Human Brain Project SGA3).
         
         .. _OpenElectrophy: https://github.com/OpenElectrophy/OpenElectrophy
         .. _Elephant: http://neuralensemble.org/elephant
         .. _G-node: http://www.g-node.org/
         .. _Neuroshare: http://neuroshare.org/
         .. _SpykeViewer: https://spyke-viewer.readthedocs.org/en/latest/
         .. _NiBabel: http://nipy.sourceforge.net/nibabel/
@@ -83,21 +92,21 @@
         
 Platform: UNKNOWN
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Natural Language :: English
 Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 2.7
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.5
 Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Topic :: Scientific/Engineering
-Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*
-Provides-Extra: kwikio
-Provides-Extra: nixio
-Provides-Extra: neomatlabio
-Provides-Extra: stimfitio
+Requires-Python: >=3.6
 Provides-Extra: tiffio
-Provides-Extra: igorproio
 Provides-Extra: hdf5io
+Provides-Extra: neomatlabio
+Provides-Extra: kwikio
+Provides-Extra: igorproio
+Provides-Extra: stimfitio
+Provides-Extra: nixio
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `neo-0.8.0/neo.egg-info/SOURCES.txt` & `neo-0.9.0/neo.egg-info/SOURCES.txt`

 * *Files 4% similar despite different names*

```diff
@@ -9,21 +9,23 @@
 doc/source/api_reference.rst
 doc/source/authors.rst
 doc/source/conf.py
 doc/source/core.rst
 doc/source/developers_guide.rst
 doc/source/developers_guide.rst.orig
 doc/source/examples.rst
+doc/source/grouping.rst
 doc/source/index.rst
 doc/source/install.rst
 doc/source/io.rst
 doc/source/io_developers_guide.rst
 doc/source/rawio.rst
 doc/source/usecases.rst
 doc/source/whatisnew.rst
+doc/source/images/.DS_Store
 doc/source/images/base_schematic.png
 doc/source/images/generate_diagram.py
 doc/source/images/multi_segment_diagram.png
 doc/source/images/multi_segment_diagram_spiketrain.png
 doc/source/images/neo_UML_French_workshop.png
 doc/source/images/neologo.png
 doc/source/images/neologo_light.png
@@ -34,24 +36,29 @@
 doc/source/releases/0.5.2.rst
 doc/source/releases/0.6.0.rst
 doc/source/releases/0.7.0.rst
 doc/source/releases/0.7.1.rst
 doc/source/releases/0.7.2.rst
 doc/source/releases/0.8.0.rst
 doc/source/releases/0.8.0.rst.orig
+doc/source/releases/0.9.0.rst
+doc/source/scripts/multi_tetrode_example.py
+doc/source/scripts/spike_sorting_example.py
 examples/generated_data.py
 examples/hbp_d571_example.py
 examples/hbp_d571_example2.py
+examples/hbp_d571_example_orig.py
 examples/imageseq.py
 examples/read_files_neo_io.py
 examples/read_files_neo_rawio.py
 examples/read_proxy_with_lazy_load.py
 examples/roi_demo.py
 examples/simple_plot_with_matplotlib.py
 neo/__init__.py
+neo/converter.py
 neo/utils.py
 neo/version.py
 neo.egg-info/PKG-INFO
 neo.egg-info/SOURCES.txt
 neo.egg-info/dependency_links.txt
 neo.egg-info/requires.txt
 neo.egg-info/top_level.txt
@@ -61,32 +68,33 @@
 neo/core/basesignal.py
 neo/core/block.py
 neo/core/channelindex.py
 neo/core/container.py
 neo/core/dataobject.py
 neo/core/epoch.py
 neo/core/event.py
+neo/core/group.py
 neo/core/imagesequence.py
-neo/core/imagesequence_BACKUP_79699.py
-neo/core/imagesequence_BASE_79699.py
-neo/core/imagesequence_LOCAL_79699.py
-neo/core/imagesequence_REMOTE_79699.py
 neo/core/irregularlysampledsignal.py
 neo/core/regionofinterest.py
 neo/core/segment.py
 neo/core/spiketrain.py
 neo/core/unit.py
+neo/core/view.py
 neo/io/__init__.py
 neo/io/alphaomegaio.py
 neo/io/asciiimageio.py
 neo/io/asciisignalio.py
 neo/io/asciispiketrainio.py
 neo/io/axographio.py
 neo/io/axonio.py
 neo/io/basefromrawio.py
+neo/io/basefromrawio_new.py
+neo/io/basefromrawio_orig.py
+neo/io/basefromrawio_sg.py
 neo/io/baseio.py
 neo/io/bci2000io.py
 neo/io/blackrockio.py
 neo/io/blackrockio_v4.py
 neo/io/blkio.py
 neo/io/brainvisionio.py
 neo/io/brainwaredamio.py
@@ -146,32 +154,38 @@
 neo/rawio/rawmcsrawio.py
 neo/rawio/spike2rawio.py
 neo/rawio/tdtrawio.py
 neo/rawio/winedrrawio.py
 neo/rawio/winwcprawio.py
 neo/test/__init__.py
 neo/test/generate_datasets.py
+neo/test/issue807.py
+neo/test/issue807b.py
+neo/test/issue808.py
+neo/test/test_converter.py
 neo/test/test_utils.py
 neo/test/tools.py
 neo/test/coretest/__init__.py
 neo/test/coretest/test_analogsignal.py
 neo/test/coretest/test_base.py
 neo/test/coretest/test_block.py
 neo/test/coretest/test_channelindex.py
 neo/test/coretest/test_container.py
 neo/test/coretest/test_dataobject.py
 neo/test/coretest/test_epoch.py
 neo/test/coretest/test_event.py
 neo/test/coretest/test_generate_datasets.py
+neo/test/coretest/test_group.py
 neo/test/coretest/test_imagesequence.py
 neo/test/coretest/test_irregularysampledsignal.py
 neo/test/coretest/test_regionofinterest.py
 neo/test/coretest/test_segment.py
 neo/test/coretest/test_spiketrain.py
 neo/test/coretest/test_unit.py
+neo/test/coretest/test_view.py
 neo/test/coretest/tmp.py
 neo/test/iotest/__init__.py
 neo/test/iotest/common_io_test.py
 neo/test/iotest/test_alphaomegaio.py
 neo/test/iotest/test_asciiimageio.py
 neo/test/iotest/test_asciisignalio.py
 neo/test/iotest/test_asciispiketrainio.py
@@ -181,15 +195,14 @@
 neo/test/iotest/test_bci2000.py
 neo/test/iotest/test_blackrockio.py
 neo/test/iotest/test_brainvisionio.py
 neo/test/iotest/test_brainwaredamio.py
 neo/test/iotest/test_brainwaref32io.py
 neo/test/iotest/test_brainwaresrcio.py
 neo/test/iotest/test_elanio.py
-neo/test/iotest/test_elphyio.py
 neo/test/iotest/test_exampleio.py
 neo/test/iotest/test_hdf5io.py
 neo/test/iotest/test_igorio.py
 neo/test/iotest/test_intanio.py
 neo/test/iotest/test_klustakwikio.py
 neo/test/iotest/test_kwikio.py
 neo/test/iotest/test_micromedio.py
```

### Comparing `neo-0.8.0/setup.py` & `neo-0.9.0/setup.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 #!/usr/bin/env python
-# -*- coding: utf-8 -*-
 
 from setuptools import setup
 import os
 
 long_description = open("README.rst").read()
-install_requires = ['numpy>=1.7.1',
-                    'quantities>=0.9.0']
+install_requires = ['numpy>=1.13.0,!=1.16.0',
+                    'quantities>=0.12.1']
 extras_require = {
     'hdf5io': ['h5py'],
     'igorproio': ['igor'],
     'kwikio': ['scipy', 'klusta'],
-    'neomatlabio': ['scipy>=0.12.0'],
+    'neomatlabio': ['scipy>=1.0.0'],
     'nixio': ['nixio>=1.5.0b2'],
     'stimfitio': ['stfio'],
     'tiffio': ['pillow']
 }
 
 with open("neo/version.py") as fp:
     d = {}
@@ -34,21 +33,21 @@
     author_email="samuel.garcia@cnrs.fr",
     description="Neo is a package for representing electrophysiology data in "
                 "Python, together with support for reading a wide range of "
                 "neurophysiology file formats",
     long_description=long_description,
     license="BSD-3-Clause",
     url='https://neuralensemble.org/neo',
-    python_requires=">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*",
+    python_requires=">=3.6",
     classifiers=[
         'Development Status :: 4 - Beta',
         'Intended Audience :: Science/Research',
         'License :: OSI Approved :: BSD License',
         'Natural Language :: English',
         'Operating System :: OS Independent',
-        'Programming Language :: Python :: 2',
-        'Programming Language :: Python :: 2.7',
         'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.5',
         'Programming Language :: Python :: 3.6',
+        'Programming Language :: Python :: 3.7',
+        'Programming Language :: Python :: 3.8',
+        'Programming Language :: Python :: 3 :: Only',
         'Topic :: Scientific/Engineering']
 )
```

